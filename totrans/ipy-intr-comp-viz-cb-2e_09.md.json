["```py\n    In [1]: import numpy as np\n            import scipy as sp\n            import scipy.optimize as opt\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: f = lambda x: np.cos(x) - x\n    ```", "```py\n    In [3]: x = np.linspace(-5, 5, 1000)\n            y = f(x)\n            plt.plot(x, y)\n            plt.axhline(0, color='k')\n            plt.xlim(-5,5)\n    ```", "```py\n    In [4]: opt.bisect(f, -5, 5)\n    Out[4]: 0.7390851332155535\n    ```", "```py\n    In [5]: plt.plot(x, y)\n            plt.axhline(0, color='k')\n            plt.scatter([_], [0], c='r', s=100)\n            plt.xlim(-5,5)\n    ```", "```py\n    In [6]: opt.brentq(f, -5, 5)\n    Out[6]: 0.7390851332151607\n    ```", "```py\n    In [7]: %timeit opt.bisect(f, -5, 5)\n            %timeit opt.brentq(f, -5, 5)\n    1000 loops, best of 3: 331 µs per loop\n    10000 loops, best of 3: 71 µs per loop\n    ```", "```py\n    In [1]: import numpy as np\n            import scipy as sp\n            import scipy.optimize as opt\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: f = lambda x: 1-np.sin(x)/x\n    ```", "```py\n    In [3]: x = np.linspace(-20., 20., 1000)\n            y = f(x)\n    In [4]: plt.plot(x, y)\n    ```", "```py\n    In [5]: x0 = 3\n            xmin = opt.minimize(f, x0).x\n    ```", "```py\n    In [6]: plt.plot(x, y)\n            plt.scatter(x0, f(x0), marker='o', s=300)\n            plt.scatter(xmin, f(xmin), marker='v', s=300)\n            plt.xlim(-20, 20)\n    ```", "```py\n    In [7]: x0 = 10\n            xmin = opt.minimize(f, x0).x\n    In [8]: plt.plot(x, y)\n            plt.scatter(x0, f(x0), marker='o', s=300)\n            plt.scatter(xmin, f(xmin), marker='v', s=300)\n            plt.xlim(-20, 20)\n    ```", "```py\n    In [9]: xmin = opt.minimize(f, x0, method='Anneal').x\n    In [10]: plt.plot(x, y)\n             plt.scatter(x0, f(x0), marker='o', s=300)\n             plt.scatter(xmin, f(xmin), marker='v', s=300)\n             plt.xlim(-20, 20)\n    ```", "```py\n    In [11]: def g(X):\n                 # X is a 2*N matrix, each column contains\n                 # x and y coordinates.\n                 x, y = X\n                 return (np.sin(3*np.pi*x)**2 +\n                         (x-1)**2 * (1+np.sin(3*np.pi*y)**2) +\n                         (y-1)**2 * (1+np.sin(2*np.pi*y)**2))\n    ```", "```py\n    In [12]: n = 200\n             k = 10\n             X, Y = np.mgrid[-k:k:n*1j,-k:k:n*1j]\n    In [13]: Z = g(np.vstack((X.ravel(),\n                              Y.ravel()))).reshape(n,n)\n    In [14]: # We use a logarithmic scale for the color here.\n             plt.imshow(np.log(Z), cmap=plt.cm.hot_r)\n             plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [15]: x0, y0 = opt.minimize(g, (8, 3)).x\n    In [16]: plt.imshow(np.log(Z), cmap=plt.cm.hot_r,\n                        extent=(-k, k, -k, k), origin=0)\n             plt.scatter([x0], [y0], c=['r'], s=100)\n             plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [1]: import numpy as np\n            import scipy.optimize as opt\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: def f(x, a, b, c, d):\n                return a/(1 + np.exp(-c * (x-d))) + b\n    ```", "```py\n    In [3]: a, c = np.random.exponential(size=2)\n            b, d = np.random.randn(2)\n    ```", "```py\n    In [4]: n = 100\n            x = np.linspace(-10., 10., n)\n            y_model = f(x, a, b, c, d)\n            y = y_model + a * .2 * np.random.randn(n)\n    ```", "```py\n    In [5]: plt.plot(x, y_model, '--k')\n            plt.plot(x, y, 'o')\n    ```", "```py\n    In [6]: (a_, b_, c_, d_), _ = opt.curve_fit(f, x, y,\n                                                (a, b, c, d))\n    ```", "```py\n    In [7]: y_fit = f(x, a_, b_, c_, d_)\n    In [8]: plt.plot(x, y_model, '--k')\n            plt.plot(x, y, 'o')\n            plt.plot(x, y_fit, '-')\n    ```", "```py\n    In [1]: import numpy as np\n            import scipy.optimize as opt\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: g = 9.81  # gravity of Earth\n            m = .1  # mass, in kg\n            n = 20  # number of masses\n            e = .1  # initial distance between the masses\n            l = e  # relaxed length of the springs\n            k = 10000  # spring stiffness\n    ```", "```py\n    In [3]: P0 = np.zeros((n, 2))\n            P0[:,0] = np.repeat(e*np.arange(n//2), 2)\n            P0[:,1] = np.tile((0,-e), n//2)\n    ```", "```py\n    In [4]: A = np.eye(n, n, 1) + np.eye(n, n, 2)\n    ```", "```py\n    In [5]: L = l * (np.eye(n, n, 1) + np.eye(n, n, 2))\n            for i in range(n//2-1):\n                L[2*i+1,2*i+2] *= np.sqrt(2)\n    ```", "```py\n    In [6]: I, J = np.nonzero(A)\n    ```", "```py\n    In [7]: dist = lambda P: np.sqrt(\n                        (P[:,0]-P[:,0][:, np.newaxis])**2 + \n                        (P[:,1]-P[:,1][:, np.newaxis])**2)\n    ```", "```py\n    In [8]: def show_bar(P):\n                # Wall.\n                plt.axvline(0, color='k', lw=3)\n                # Distance matrix.\n                D = dist(P)\n                # We plot the springs.\n                for i, j in zip(I, J):\n                    # The color depends on the spring tension,\n                    # which is proportional to the spring \n                    # elongation.\n                    c = D[i,j] - L[i,j]\n                    plt.plot(P[[i,j],0], P[[i,j],1], \n                             lw=2, color=plt.cm.copper(c*150))\n                # We plot the masses.\n                plt.plot(P[[I,J],0], P[[I,J],1], 'ok',)\n                # We configure the axes.\n                plt.axis('equal')\n                plt.xlim(P[:,0].min()-e/2, P[:,0].max()+e/2)\n                plt.ylim(P[:,1].min()-e/2, P[:,1].max()+e/2)\n                plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [9]: show_bar(P0)\n            plt.title(\"Initial configuration\")\n    ```", "```py\n    In [10]: def energy(P):\n                 # The argument P is a vector (flattened \n                 # matrix). We convert it to a matrix here.\n                 P = P.reshape((-1, 2))\n                 # We compute the distance matrix.\n                 D = dist(P)\n                 # The potential energy is the sum of the\n                 # gravitational and elastic potential \n                 # energies.\n                 return (g * m * P[:,1].sum() + \n                         .5 * (k * A * (D - L)**2).sum())\n    ```", "```py\n    In [11]: energy(P0.ravel())\n    Out[11]: -0.98099\n    ```", "```py\n    In [12]: bounds = np.c_[P0[:2,:].ravel(),\n                            P0[:2,:].ravel()].tolist() + \\\n                                  [[None, None]] * (2*(n-2))\n    In [13]: P1 = opt.minimize(energy, P0.ravel(),\n                               method='L-BFGS-B',\n                               bounds=bounds).x \\\n                                         .reshape((-1, 2))\n    ```", "```py\n    In [14]: show_bar(P1)\n             plt.title(\"Equilibrium configuration\")\n    ```"]