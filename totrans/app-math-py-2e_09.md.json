["```py\npython3.10 -m pip install numpy scipy matplotlib nashpy\n```", "```py\nimport numpy as np\nfrom scipy import optimize\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n```", "```py\n    A = np.array([\n    ```", "```py\n        [2, 1], # 2*x0 + x1 <= 6\n    ```", "```py\n        [-1, -1] # -x0 - x1 <= -4\n    ```", "```py\n    ])\n    ```", "```py\n    b = np.array([6, -4])\n    ```", "```py\n    x0_bounds = (-3, 14) # -3 <= x0 <= 14\n    ```", "```py\n    x1_bounds = (2, 12)      # 2 <= x1 <= 12\n    ```", "```py\n    c = np.array([1, 5])\n    ```", "```py\n    def func(x):\n    ```", "```py\n        return np.tensordot(c, x, axes=1)\n    ```", "```py\n    fig = plt.figure()\n    ```", "```py\n    ax = fig.add_subplot(projection=\"3d\")\n    ```", "```py\n    ax.set(xlabel=\"x0\", ylabel=\"x1\", zlabel=\"func\")\n    ```", "```py\n    ax.set_title(\"Values in Feasible region\")\n    ```", "```py\n    X0 = np.linspace(*x0_bounds)\n    ```", "```py\n    X1 = np.linspace(*x1_bounds)\n    ```", "```py\n    x0, x1 = np.meshgrid(X0, X1)\n    ```", "```py\n    z = func([x0, x1])\n    ```", "```py\n    ax.plot_surface(x0, x1, z, cmap=\"gray\",\n    ```", "```py\n        vmax=100.0, alpha=0.3)\n    ```", "```py\n    Y = (b[0] - A[0, 0]*X0) / A[0, 1]\n    ```", "```py\n    I = np.logical_and(Y >= x1_bounds[0], Y <= x1_bounds[1])\n    ```", "```py\n    ax.plot(X0[I], Y[I], func([X0[I], Y[I]]), \n    ```", "```py\n        \"k\", lw=1.5, alpha=0.6)\n    ```", "```py\n    Y = (b[1] - A[1, 0]*X0) / A[1, 1]\n    ```", "```py\n    I = np.logical_and(Y >= x1_bounds[0], Y <= x1_bounds[1])\n    ```", "```py\n    ax.plot(X0[I], Y[I], func([X0[I], Y[I]]), \n    ```", "```py\n        \"k\", lw=1.5, alpha=0.6)\n    ```", "```py\n    B = np.tensordot(A, np.array([x0, x1]), axes=1)\n    ```", "```py\n    II = np.logical_and(B[0, ...] <= b[0], B[1, ...] <= b[1])\n    ```", "```py\n    ax.plot_trisurf(x0[II], x1[II], z[II], \n    ```", "```py\n        color=\"k\", alpha=0.5)\n    ```", "```py\n    res = optimize.linprog(c, A_ub=A, b_ub=b,\n    ```", "```py\n        bounds= (x0_bounds, x1_bounds))\n    ```", "```py\n    print(res)\n    ```", "```py\n    ax.plot([res.x[0]], [res.x[1]], [res.fun], \"kx\")\n    ```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom scipy import optimize\n```", "```py\n    def func(x):\n    ```", "```py\n        return ((x[0] - 0.5)**2 + (\n    ```", "```py\n            x[1] + 0.5)**2)*np.cos(0.5*x[0]*x[1])\n    ```", "```py\n    x_r = np.linspace(-1, 1)\n    ```", "```py\n    y_r = np.linspace(-2, 2)\n    ```", "```py\n    x, y = np.meshgrid(x_r, y_r)\n    ```", "```py\n    z = func([x, y])\n    ```", "```py\n    fig = plt.figure(tight_layout=True)\n    ```", "```py\n    ax = fig.add_subplot(projection=\"3d\")\n    ```", "```py\n    ax.tick_params(axis=\"both\", which=\"major\", labelsize=9)\n    ```", "```py\n    ax.set(xlabel=\"x\", ylabel=\"y\", zlabel=\"z\")\n    ```", "```py\n    ax.set_title(\"Objective function\")\n    ```", "```py\n    ax.plot_surface(x, y, z, cmap=\"gray\",\n    ```", "```py\n        vmax=8.0, alpha=0.5)\n    ```", "```py\n    x0 = np.array([-0.5, 1.0])\n    ```", "```py\n    ax.plot([x0[0]], [x0[1]], func(x0), \"k*\")\n    ```", "```py\n    result = optimize.minimize(\n    ```", "```py\n        func, x0, tol=1e-6, method= \"Nelder-Mead\")\n    ```", "```py\n    print(result)\n    ```", "```py\n    ax.plot([result.x[0]], [result.x[1]], [result.fun], \"kx\")\n    ```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n```", "```py\n    def descend(func,x0,grad,bounds,tol=1e-8,max_iter=100):\n    ```", "```py\n        xn = x0\n    ```", "```py\n        previous = np.inf\n    ```", "```py\n        grad_xn = grad(x0)\n    ```", "```py\n        for i in range(max_iter):\n    ```", "```py\n            if np.linalg.norm(xn - previous) < tol:\n    ```", "```py\n                break\n    ```", "```py\n            direction = -grad_xn\n    ```", "```py\n            previous = xn\n    ```", "```py\n            xn = xn + 0.2*direction\n    ```", "```py\n            grad_xn = grad(xn)\n    ```", "```py\n            yield i, xn, func(xn), grad_xn\n    ```", "```py\n    def func(x):\n    ```", "```py\n        return ((x[0] - 0.5)**2 + (\n    ```", "```py\n            x[1] + 0.5)**2)*np.cos(0.5*x[0]*x[1])\n    ```", "```py\n    x_r = np.linspace(-1, 1)\n    ```", "```py\n    y_r = np.linspace(-2, 2)\n    ```", "```py\n    x, y = np.meshgrid(x_r, y_r)\n    ```", "```py\n    z = func([x, y])\n    ```", "```py\n    surf_fig = plt.figure(tight_layout=True)\n    ```", "```py\n    surf_ax = surf_fig.add_subplot(projection=\"3d\")\n    ```", "```py\n    surf_ax.tick_params(axis=\"both\", which=\"major\",\n    ```", "```py\n        labelsize=9)\n    ```", "```py\n    surf_ax.set(xlabel=\"x\", ylabel=\"y\", zlabel=\"z\")\n    ```", "```py\n    surf_ax.set_title(\"Objective function\")\n    ```", "```py\n    surf_ax.plot_surface(x, y, z, cmap=\"gray\", \n    ```", "```py\n        vmax=8.0, alpha=0.5)\n    ```", "```py\n    x0 = np.array([-0.8, 1.3])\n    ```", "```py\n    surf_ax.plot([x0[0]], [x0[1]], func(x0), \"k*\")\n    ```", "```py\n    def grad(x):\n    ```", "```py\n        c1 = x[0]**2 - x[0] + x[1]**2 + x[1] + 0.5\n    ```", "```py\n        cos_t = np.cos(0.5*x[0]*x[1])\n    ```", "```py\n        sin_t = np.sin(0.5*x[0]*x[1])\n    ```", "```py\n        return np.array([\n    ```", "```py\n            (2*x[0]-1)*cos_t - 0.5*x[1]*c1*sin_t,\n    ```", "```py\n            (2*x[1]+1)*cos_t - 0.5*x[0]*c1*sin_t\n    ```", "```py\n        ])\n    ```", "```py\n    cont_fig, cont_ax = plt.subplots()\n    ```", "```py\n    cont_ax.set(xlabel=\"x\", ylabel=\"y\")\n    ```", "```py\n    cont_ax.set_title(\"Contour plot with iterates\")\n    ```", "```py\n    cont_ax.contour(x, y, z, levels=25, cmap=\"gray\",\n    ```", "```py\n        vmax=8.0, opacity=0.6)\n    ```", "```py\n    bounds = ((-1, 1), (-2, 2))\n    ```", "```py\n    xnm1 = x0\n    ```", "```py\n    for i, xn, fxn, grad_xn in descend(func, x0, grad, bounds):\n    ```", "```py\n        cont_ax.plot([xnm1[0], xn[0]], [xnm1[1], xn[1]],           \t        \"k*--\")\n    ```", "```py\n        xnm1, grad_xnm1 = xn, grad_xn\n    ```", "```py\n    print(f\"iterations={i}\")\n    ```", "```py\n    print(f\"min val at {xn}\")\n    ```", "```py\n    print(f\"min func value = {fxn}\")\n    ```", "```py\niterations=37\nmin val at [ 0.49999999 -0.49999999]\nmin func value = 2.1287163880894953e-16\n```", "```py\nalphas = np.array([\n    (bounds[0][0] - xn[0]) / direction[0],\n    # x lower\n   (bounds[1][0] - xn[1]) / direction[1],\n    # y lower\n    (bounds[0][1] - xn[0]) / direction[0],\n    # x upper\n    (bounds[1][1] - xn[1]) / direction[1] \n    # y upper\n])\nalpha_max = alphas[alphas >= 0].min()\nalpha_min = alphas[alphas < 0].max()\nresult = minimize_scalar(lambda t: \n    func(xn + t*direction),\n    method=\"bounded\",\n    bounds=(alpha_min, alpha_max))\namount = result.x\n```", "```py\nxn = xn + amount * direction\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nfrom numpy.random import default_rng\nrng = default_rng(12345)\n```", "```py\nfrom scipy.optimize import curve_fit\n```", "```py\n    SIZE = 100\n    ```", "```py\n    x_data = rng.uniform(-3.0, 3.0, size=SIZE)\n    ```", "```py\n    noise = rng.normal(0.0, 0.8, size=SIZE)\n    ```", "```py\n    y_data = 2.0*x_data**2 - 4*x_data + noise\n    ```", "```py\n    fig, ax = plt.subplots()\n    ```", "```py\n    ax.scatter(x_data, y_data)\n    ```", "```py\n    ax.set(xlabel=\"x\", ylabel=\"y\",\n    ```", "```py\n        title=\"Scatter plot of sample data\")\n    ```", "```py\n    def func(x, a, b, c):\n    ```", "```py\n        return a*x**2 + b*x + c\n    ```", "```py\n    coeffs, _ = curve_fit(func, x_data, y_data)\n    ```", "```py\n    print(coeffs)\n    ```", "```py\n    # [ 1.99611157 -3.97522213 0.04546998]\n    ```", "```py\n    x = np.linspace(-3.0, 3.0, SIZE)\n    ```", "```py\n    y = func(x, coeffs[0], coeffs[1], coeffs[2])\n    ```", "```py\n    ax.plot(x, y, \"k--\")\n    ```", "```py\ndef func(params, x, y):\n    return y -(\n        params[0]*x**2 + params[1]*x + params[2])\n```", "```py\nresults = least_squares(func, [1, 0, 0], args=(x_data, y_data))\n```", "```py\nimport numpy as np\nimport nashpy as nash\n```", "```py\n    you = np.array([[1, 3], [1, 4]])\n    ```", "```py\n    colleague = np.array([[3, 2], [2, 2]])\n    ```", "```py\n    dilemma = nash.Game(you, colleague)\n    ```", "```py\n    print(dilemma[[1, 0], [1, 0]])      # [1 3]\n    ```", "```py\n    print(dilemma[[1, 0], [0, 1]])      # [3 2]\n    ```", "```py\n    print(dilemma[[0, 1], [1, 0]])      # [1 2]\n    ```", "```py\n    print(dilemma[[0, 1], [0, 1]])      # [4 2]\n    ```", "```py\n    print(dilemma[[0.1, 0.9], [0.5, 0.5]]) # [2.45 2.05]\n    ```", "```py\nimport numpy as np\nimport nashpy as nash\n```", "```py\n    rps_p1 = np.array([\n    ```", "```py\n        [ 0, -1, 1], # rock payoff\n    ```", "```py\n        [ 1, 0, -1], # paper payoff\n    ```", "```py\n        [-1, 1, 0] # scissors payoff\n    ```", "```py\n    ])\n    ```", "```py\n    rps_p2 = rps_p1.transpose()\n    ```", "```py\n    rock_paper_scissors = nash.Game(rps_p1, rps_p2)\n    ```", "```py\n    equilibria = rock_paper_scissors.support_enumeration()\n    ```", "```py\n    for p1, p2 in equilibria:\n    ```", "```py\n        print(\"Player 1\", p1)\n    ```", "```py\n        print(\"Player 2\", p2)\n    ```", "```py\nPlayer 1 [0.33333333 0.33333333 0.33333333]\nPlayer 2 [0.33333333 0.33333333 0.33333333]\n```"]