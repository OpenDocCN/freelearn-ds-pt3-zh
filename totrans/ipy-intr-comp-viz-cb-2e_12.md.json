["```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: def logistic(r, x):\n                return r*x*(1-x)\n    ```", "```py\n    In [3]: n = 10000\n            r = np.linspace(2.5, 4.0, n)\n    ```", "```py\n    In [4]: iterations = 1000\n            last = 100\n    ```", "```py\n    In [5]: x = 1e-5 * np.ones(n)\n    ```", "```py\n    In [6]: lyapunov = np.zeros(n)\n    ```", "```py\n    In [7]: plt.subplot(211)\n            for i in range(iterations):\n                x = logistic(r, x)\n                # We compute the partial sum of the\n                # Lyapunov exponent.\n                lyapunov += np.log(abs(r-2*r*x))\n                # We display the bifurcation diagram.\n                if i >= (iterations - last):\n                    plt.plot(r, x, ',k', alpha=.02)\n            plt.xlim(2.5, 4)\n            plt.title(\"Bifurcation diagram\")\n\n            # We display the Lyapunov exponent.\n            plt.subplot(212)\n            plt.plot(r[lyapunov<0],\n                     lyapunov[lyapunov<0] / iterations,\n                     ',k', alpha=0.1)\n            plt.plot(r[lyapunov>=0],\n                     lyapunov[lyapunov>=0] / iterations,\n                     ',r', alpha=0.25)\n            plt.xlim(2.5, 4)\n            plt.ylim(-2, 1)\n            plt.title(\"Lyapunov exponent\")\n    ```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: u = np.array([[4], [2], [1]])\n    ```", "```py\n    In [3]: def step(x, rule_binary):\n                \"\"\"Compute a single stet of an elementary\n                cellular automaton.\"\"\"\n                # The columns contain the L, C, R values\n                # of all cells.\n                y = np.vstack((np.roll(x, 1), x,\n                               np.roll(x, -1))).astype(np.int8)\n                # We get the LCR pattern numbers \n                # between 0 and 7.\n                z = np.sum(y * u, axis=0).astype(np.int8)\n                # We get the patterns given by the rule.\n                return rule_binary[7-z]\n    ```", "```py\n    In [4]: def generate(rule, size=80, steps=80):\n                \"\"\"Simulate an elementary cellular automaton\n                given its rule (number between 0 and 255).\"\"\"\n                # Compute the binary representation of the\n                # rule.\n                rule_binary = np.array(\n                    [int(x) for x in np.binary_repr(rule, 8)],\n                    dtype=np.int8)\n                x = np.zeros((steps, size), dtype=np.int8)\n                # Random initial state.\n                x[0,:] = np.random.rand(size) < .5\n                # Apply the step function iteratively.\n                for i in range(steps-1):\n                    x[i+1,:] = step(x[i,:], rule_binary)\n                return x\n    ```", "```py\n    In [5]: rules = [  3,  18,  30, \n                      90, 106, 110, \n                     158, 154, 184]\n            for i, rule in enumerate(rules):\n                x = generate(rule)\n                plt.subplot(331+i)\n                plt.imshow(x, interpolation='none',\n                           cmap=plt.cm.binary)\n                plt.xticks([]); plt.yticks([])\n                plt.title(str(rule))\n    ```", "```py\n    In [1]: import numpy as np\n            import scipy.integrate as spi\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: m = 1\\.  # particle's mass\n            k = 1\\.  # drag coefficient\n            g = 9.81  # gravity acceleration\n    ```", "```py\n    In [3]: # The initial position is (0, 0).\n            v0 = np.zeros(4)\n            # The initial speed vector is oriented\n            # to the top right.\n            v0[2] = 4.\n            v0[3] = 10.\n    ```", "```py\n    In [4]: def f(v, t0, k):\n                # v has four components: v=[u, u'].\n                u, udot = v[:2], v[2:]\n                # We compute the second derivative u'' of u.\n                udotdot = -k/m * udot\n                udotdot[1] -= g\n                # We return v'=[u', u''].\n                return np.r_[udot, udotdot]\n    ```", "```py\n    In [5]: # We want to evaluate the system on 30 linearly\n            # spaced times between t=0 and t=3.\n            t = np.linspace(0., 3., 30)\n            # We simulate the system for different values of k.\n            for k in np.linspace(0., 1., 5):\n                # We simulate the system and evaluate $v$ on\n                # the given times.\n                v = spi.odeint(f, v0, t, args=(k,))\n                # We plot the particle's trajectory.\n                plt.plot(v[:,0], v[:,1], 'o-',\n                         mew=1, ms=8, mec='w',\n                         label='k={0:.1f}'.format(k))\n            plt.legend()\n            plt.xlim(0, 12)\n            plt.ylim(0, 6)\n    ```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: a = 2.8e-4\n            b = 5e-3\n            tau = .1\n            k = -.005\n    ```", "```py\n    In [3]: size = 80  # size of the 2D grid\n            dx = 2./size  # space step\n    In [4]: T = 10.0  # total time\n            dt = .9 * dx**2/2  # time step\n            n = int(T/dt)\n    ```", "```py\n    In [5]: U = np.random.rand(size, size)\n            V = np.random.rand(size, size)\n    ```", "```py\n    In [6]: def laplacian(Z):\n                Ztop = Z[0:-2,1:-1]\n                Zleft = Z[1:-1,0:-2]\n                Zbottom = Z[2:,1:-1]\n                Zright = Z[1:-1,2:]\n                Zcenter = Z[1:-1,1:-1]\n                return (Ztop + Zleft + Zbottom + Zright \\\n                        - 4 * Zcenter) / dx**2\n    ```", "```py\n    In [7]: for i in range(n):\n                # We compute the Laplacian of u and v.\n                deltaU = laplacian(U)\n                deltaV = laplacian(V)\n                # We take the values of u and v\n                # inside the grid.\n                Uc = U[1:-1,1:-1]\n                Vc = V[1:-1,1:-1]\n                # We update the variables.\n                U[1:-1,1:-1], V[1:-1,1:-1] = (\n                  Uc + dt * (a*deltaU + Uc - Uc**3 - Vc + k), \n                  Vc + dt * (b*deltaV + Uc - Vc) / tau)\n                # Neumann conditions: derivatives at the edges\n                # are null.\n                for Z in (U, V):\n                    Z[0,:] = Z[1,:]\n                    Z[-1,:] = Z[-2,:]\n                    Z[:,0] = Z[:,1]\n                    Z[:,-1] = Z[:,-2]\n    ```", "```py\n    In [8]: plt.imshow(U, cmap=plt.cm.copper, extent=[-1,1,-1,1])\n    ```"]