<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Visualizing Online Data</h1>
                </header>
            
            <article>
                
<p>At this point, we have already covered the basics of creating and customizing plots using Matplotlib. In this chapter, we begin the journey of understanding more advanced Matplotlib usage through examples in specialized topics.</p>
<p>When considering the visualization of a concept, the following important factors have to be considered carefully:</p>
<ul>
<li>Source of the data</li>
<li>Filtering and data processing</li>
<li>Choosing the right plot type for the data:
<ul>
<li>Visualizing the trend of data:
<ul>
<li>Line chart, area chart, and stacked area chart</li>
</ul>
</li>
<li>Visualizing univariate distribution:
<ul>
<li>Bar chart, histogram, and kernel density estimation</li>
</ul>
</li>
<li>Visualizing bivariate distribution:
<ul>
<li>Scatter plot, KDE density chart, and hexbin chart</li>
</ul>
</li>
<li>Visualizing categorical data:
<ul>
<li>Categorical scatter plot, box plot, swarm plot, violin plot</li>
</ul>
</li>
</ul>
</li>
<li>Adjusting figure aesthetics for effective storytelling</li>
</ul>
<p>We will cover these topics via the use of demographic and financial data. First, we will discuss typical data formats when we fetch data from the <strong>Application Programming Interface</strong> (<strong>API</strong>). Next, we will explore how we can integrate Matplotlib 2.0 with other Python packages such as Pandas, Scipy, and Seaborn for the visualization of different data types. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Typical API data formats</h1>
                </header>
            
            <article>
                
<p><span>Many websites offer their data via an API, which bridges applications via standardized architecture. While we are not going to cover the details of using APIs here as site-specific documentation is usually available online; we will show you the three most common data formats as used in many APIs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSV</h1>
                </header>
            
            <article>
                
<p><strong>CSV</strong> (<strong>Comma-Separated Values</strong>) is one of the oldest file formats, which was introduced long before the internet even existed. However, it is now becoming deprecated as other advanced formats, such as JSON and XML, are gaining popularity. As the name suggests, data values are separated by commas. The preinstalled <kbd>csv</kbd> package and the <kbd>pandas</kbd> package contain classes to read and write data in CSV format. This CSV example defines a population table with two countries:</p>
<pre>Country,Time,Sex,Age,Value<br/>United Kingdom,1950,Male,0-4,2238.735<br/>United States of America,1950,Male,0-4,8812.309</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON</h1>
                </header>
            
            <article>
                
<p><strong>JSON</strong> (<strong>JavaScript Object Notation</strong>) is gaining popularity these days due to its efficiency and simplicity. JSON allows the specification of number, string, Boolean, array, and object. Python provides the default <kbd>json</kbd> package for parsing JSON. Alternatively, the <kbd>pandas.read_json</kbd> class can be used to import JSON as a Pandas dataframe. The preceding population table can be represented as JSON in the following example:</p>
<pre>{<br/> "population": [<br/> {<br/> "Country": "United Kingdom",<br/> "Time": 1950,<br/> "Sex", "Male",<br/> "Age", "0-4",<br/> "Value",2238.735<br/> },{<br/> "Country": "United States of America",<br/> "Time": 1950,<br/> "Sex", "Male",<br/> "Age", "0-4",<br/> "Value",8812.309<br/> },<br/> ]<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XML</h1>
                </header>
            
            <article>
                
<p><strong>XML</strong> (<strong>eXtensible Markup Language</strong>) is the Swiss Army knife of data formats, and it has become the default container for Microsoft Office, Apple iWork, XHTML, SVG, and more. XML's versatility comes with a price, as it makes XML verbose and slower. There are several ways to parse XML in Python, but <kbd>xml.etree.ElementTree</kbd> is recommended due to its Pythonic interface, backed by an efficient C backend. We are not going to cover XML parsing in this book, but good tutorials exist elsewhere (such as <a href="http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree" target="_blank">http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree</a>).</p>
<p>As an example, the same population table can be transformed into XML:</p>
<pre>&lt;?xml version='1.0' encoding='utf-8'?&gt;<br/>&lt;populations&gt;<br/> &lt;population&gt;<br/> &lt;Country&gt;United Kingdom&lt;/Country&gt; <br/> &lt;Time&gt;1950&lt;/Time&gt;<br/> &lt;Sex&gt;Male&lt;/Sex&gt;<br/> &lt;Age&gt;0-4&lt;/Age&gt;<br/> &lt;Value&gt;2238.735&lt;/Value&gt;<br/> &lt;/population&gt;<br/> &lt;population&gt;<br/> &lt;Country&gt;United States of America&lt;/Country&gt;<br/> &lt;Time&gt;1950&lt;/Time&gt;<br/> &lt;Sex&gt;Male&lt;/Sex&gt;<br/> &lt;Age&gt;0-4&lt;/Age&gt;<br/> &lt;Value&gt;8812.309&lt;/Value&gt;<br/> &lt;/population&gt;<br/>&lt;/populations&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing pandas</h1>
                </header>
            
            <article>
                
<p>Beside NumPy and SciPy, pandas is one of the most common scientific computing libraries for Python. Its authors aim to make pandas the most powerful and flexible open source data analysis and manipulation tool available in any language, and in fact, they are almost achieving that goal. Its powerful and efficient library is a perfect match for data scientists. Like other Python packages, Pandas can <span>easily</span><span> </span><span>be installed via PyPI:</span></p>
<pre><strong>pip install pandas</strong></pre>
<p>First introduced in version 1.5, Matplotlib supports the use of pandas DataFrame as the input in various plotting classes. Pandas DataFrame is a powerful two-dimensional labeled data structure that supports indexing, querying, grouping, merging, and some other common relational database operations. DataFrame is similar to spreadsheets in the sense that each row of the DataFrame contains different variables of an instance, while each column contains a vector of a specific variable across all instances.</p>
<div class="packt_tip">pandas DataFrame supports heterogeneous data types, such as string, integer, and float. By default, rows are indexed sequentially and columns are composed of pandas Series. Optional row labels or column labels can be specified through the index and columns attributes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing online population data in the CSV format</h1>
                </header>
            
            <article>
                
<p>Let's begin by looking at the steps to import an online CSV file as a pandas DataFrame. In this example, we are going to use the annual population summary published by the Department of Economic and Social Affairs, United Nations, in 2015. Projected population figures towards 2100 were also included in the dataset:</p>
<pre>import numpy as np # Python scientific computing package<br/>import pandas as pd # Python data analysis package<br/><br/># URL for Annual Population by Age and Sex - Department of Economic<br/># and Social Affairs, United Nations<br/>source = "https://github.com/PacktPublishing/Matplotlib-2.x-By-Example/blob/master/WPP2015_DB04_Population_Annual.zip"<br/><br/># Pandas support both local or online files <br/>data = pd.read_csv(source, header=0, compression='zip', encoding='latin_1') <br/><br/># Show the first five rows of the DataFrame<br/>data.head() </pre>
<p><span>The expected output of the code is shown here:</span></p>
<table style="border-collapse: collapse;width: 50%" border="1">
<tbody>
<tr>
<td><strong>LocID</strong></td>
<td><strong>Location</strong></td>
<td><strong>VarID</strong></td>
<td><strong>Variant</strong></td>
<td><strong>Time</strong></td>
<td><strong>MidPeriod</strong></td>
<td><strong>SexID</strong></td>
<td><strong>Sex</strong></td>
<td><strong>AgeGrp</strong></td>
<td><strong>AgeGrpStart</strong></td>
<td><strong>AgeGrpSpan</strong></td>
<td><strong>Value</strong></td>
<td>
<p> </p>
</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>0-4</td>
<td>0</td>
<td>5</td>
<td>630.044</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>5-9</td>
<td>5</td>
<td>5</td>
<td>516.205</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>10-14</td>
<td>10</td>
<td>5</td>
<td>461.378</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>15-19</td>
<td>15</td>
<td>5</td>
<td>414.368</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>20-24</td>
<td>20</td>
<td>5</td>
<td>374.110</td>
</tr>
</tbody>
</table>
<div class="text_cell_render rendered_html packt_tip">
<p>The <kbd>pandas.read_csv</kbd> class is extremely versatile, supporting column headers, custom delimiters, various compressed formats (for example, <kbd>.gzip</kbd>, <kbd>.bz2</kbd>, <kbd>.zip</kbd>, and <kbd>.xz</kbd>), different text encodings, and much more. Readers can consult the documentation page (<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html" target="_blank">http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html</a>) for more information.</p>
<p>By calling the <kbd>.head()</kbd> function of the Pandas DataFrame object, we can quickly observe the first five rows of the data.</p>
</div>
<p>As we progress through this chapter, we are going to integrate this population dataset with other datasets in Quandl. However, Quandl uses three-letter country codes (ISO 3166 alpha-3) to denote geographical locations; therefore we need to reformat the location names accordingly.</p>
<p>The <kbd>pycountry</kbd> package is an excellent choice for conversion of country names according to ISO 3166 standards. Similarly, <kbd>pycountry</kbd> can be installed through PyPI:</p>
<pre><strong>pip install pycountry </strong></pre>
<p>Continuing the previous code example, we are going to add a new <kbd>country</kbd> column to the dataframe:</p>
<pre class="mce-root">from pycountry import countries<br/><br/><br/>def get_alpha_3(location):<br/>    """Convert full country name to three letter code (ISO 3166 alpha-3)<br/> <br/>    Args:<br/>        location: Full location name<br/>    Returns:<br/>        three letter code or None if not found"""<br/><br/>    try:<br/>        return countries.get(name=location).alpha_3<br/>    except:<br/>        return None<br/> <br/># Add a new country column to the dataframe<br/>population_df['country'] = population_df['Location'].apply(lambda x: get_alpha_3(x))<br/>population_df.head()</pre>
<p><span>The expected output of the code is shown here:</span></p>
<table style="border-collapse: collapse;width: 50%" class="table" border="1">
<tbody>
<tr>
<td><strong>-</strong></td>
<td><strong>LocID</strong></td>
<td><strong>Location</strong></td>
<td><strong>VarID</strong></td>
<td><strong>Variant</strong></td>
<td><strong>Time</strong></td>
<td><strong>MidPeriod</strong></td>
<td><strong>SexID</strong></td>
<td><strong>Sex</strong></td>
<td><strong>AgeGrp</strong></td>
<td><strong>AgeGrpStart</strong></td>
<td><strong>AgeGrpSpan</strong></td>
<td><strong>Value</strong></td>
<td><strong>country</strong></td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>0-4</td>
<td>0</td>
<td>5</td>
<td>630.044</td>
<td>AFG</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>5-9</td>
<td>5</td>
<td>5</td>
<td>516.205</td>
<td>AFG</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>10-14</td>
<td>10</td>
<td>5</td>
<td>461.378</td>
<td>AFG</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>15-19</td>
<td>15</td>
<td>5</td>
<td>414.368</td>
<td>AFG</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Afghanistan</td>
<td>2</td>
<td>Medium</td>
<td>1950</td>
<td>1950.5</td>
<td>1</td>
<td>Male</td>
<td>20-24</td>
<td>20</td>
<td>5</td>
<td>374.110</td>
<td>AFG</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing online financial data in the JSON format</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will also draw upon financial data from Quandl's API to create insightful visualizations. If you are not familiar with Quandl, it is a financial and economic data warehouse that stores millions of datasets from hundreds of publishers. The best thing about Quandl is that these datasets are delivered via the unified API, without worrying about the procedures to parse the data correctly. Anonymous users can get up to 50 API calls per day, and you get up to 500 free API calls if you are a registered user. Readers can sign up for a free API key at <a href="https://www.quandl.com/?modal=register">https://www.quandl.com/?modal=register</a>.</p>
<p>At Quandl, every dataset is identified by a unique ID, as defined by the Quandl Code on each search result webpage. For example, the Quandl code GOOG/NASDAQ_SWTX defines the historical NASDAQ index data published by Google Finance. Every dataset is available in three formats--CSV, JSON, and XML.</p>
<p class="mce-root"/>
<p>Although an official Python client library is available from Quandl, we are not going to use that for the sake of demonstrating the general procedures of importing JSON data. According to Quandl's documentation, we can fetch JSON formatted data tables through the following API call:<br/>
<kbd>GET https://www.quandl.com/api/v3/datasets/{Quandl code}/data.json</kbd></p>
<p>Let's try to get the Big Mac index data from Quandl.</p>
<pre>from urllib.request import urlopen<br/>import json<br/>import time<br/>import pandas as pd<br/><br/><br/>def get_bigmac_codes():<br/>    """Get a Pandas DataFrame of all codes in the Big Mac index dataset<br/><br/>    The first column contains the code, while the second header<br/>    contains the description of the code.<br/>    <br/>    for example, <br/>    ECONOMIST/BIGMAC_ARG,Big Mac Index - Argentina<br/>    ECONOMIST/BIGMAC_AUS,Big Mac Index - Australia<br/>    ECONOMIST/BIGMAC_BRA,Big Mac Index - Brazil<br/>    <br/>    Returns:<br/>        codes: Pandas DataFrame of Quandl dataset codes"""<br/>    <br/>    codes_url = "https://www.quandl.com/api/v3/databases/ECONOMIST/codes"<br/>    codes = pd.read_csv(codes_url, header=None, names=['Code', 'Description'], <br/>                        compression='zip', encoding='latin_1')<br/>    <br/>    return codes<br/><br/>    <br/>def get_quandl_dataset(api_key, code):<br/>    """Obtain and parse a quandl dataset in Pandas DataFrame format<br/><br/>    Quandl returns dataset in JSON format, where data is stored as a <br/>    list of lists in response['dataset']['data'], and column headers<br/>    stored in response['dataset']['column_names'].<br/>    <br/>    for example, {'dataset': {...,<br/>             'column_names': ['Date',<br/>                              'local_price',<br/>                              'dollar_ex',<br/>                              'dollar_price',<br/>                              'dollar_ppp',<br/>                              'dollar_valuation',<br/>                              'dollar_adj_valuation',<br/>                              'euro_adj_valuation',<br/>                              'sterling_adj_valuation',<br/>                              'yen_adj_valuation',<br/>                              'yuan_adj_valuation'],<br/>             'data': [['2017-01-31',<br/>                       55.0,<br/>                       15.8575,<br/>                       3.4683903515687,<br/>                       10.869565217391,<br/>                       -31.454736135007,<br/>                       6.2671477203176,<br/>                       8.2697553162259,<br/>                       29.626894343348,<br/>                       32.714616745128,<br/>                       13.625825886047],<br/>                      ['2016-07-31',<br/>                       50.0,<br/>                       14.935,<br/>                       3.3478406427854,<br/>                       9.9206349206349,<br/>                       -33.574590420925,<br/>                       2.0726096168216,<br/>                       0.40224795003514,<br/>                       17.56448458418,<br/>                       19.76377270142,<br/>                       11.643103380531]<br/>                      ],<br/>             'database_code': 'ECONOMIST',<br/>             'dataset_code': 'BIGMAC_ARG',<br/>             ... }}<br/>    <br/>    A custom column--country is added to denote the 3-letter country code.<br/>    <br/>    Args:<br/>        api_key: Quandl API key<br/>        code: Quandl dataset code<br/><br/>    Returns:<br/>        df: Pandas DataFrame of a Quandl dataset<br/><br/>    """<br/>    base_url = "https://www.quandl.com/api/v3/datasets/"<br/>    url_suffix = ".json?api_key="<br/><br/>    # Fetch the JSON response <br/>    u = urlopen(base_url + code + url_suffix + api_key)<br/>    response = json.loads(u.read().decode('utf-8'))<br/>    <br/>    # Format the response as Pandas Dataframe<br/>    df = pd.DataFrame(response['dataset']['data'], columns=response['dataset']['column_names'])<br/>    <br/>    # Label the country code<br/>    df['country'] = code[-3:]<br/>    <br/>    return df<br/><br/><br/>quandl_dfs = []<br/>codes = get_bigmac_codes()<br/><br/># Replace this with your own API key<br/>api_key = "INSERT YOUR KEY HERE" <br/><br/>for code in codes.Code:<br/>    # Get the DataFrame of a Quandl dataset<br/>    df = get_quandl_dataset(api_key, code)<br/>    <br/>    # Store in a list<br/>    quandl_dfs.append(df)<br/>    <br/>    # Prevents exceeding the API speed limit<br/>    time.sleep(2)<br/>    <br/>    <br/># Concatenate the list of dataframes into a single one    <br/>bigmac_df = pd.concat(quandl_dfs)<br/>bigmac_df.head()</pre>
<p>The expected output is as follows:</p>
<table style="border-collapse: collapse;width: 50%" class="table" border="1">
<tbody>
<tr>
<td>-</td>
<td><strong>Date</strong></td>
<td><strong>local_price</strong></td>
<td><strong>dollar_ex</strong></td>
<td><strong>dollar_price</strong></td>
<td><strong>dollar_ppp</strong></td>
<td><strong>dollar_valuation</strong></td>
<td><strong>dollar_adj_valuation</strong></td>
<td><strong>euro_adj_valuation</strong></td>
<td><strong>sterling_adj_valuation</strong></td>
<td><strong>yen_adj_valuation</strong></td>
<td><strong>yuan_adj_valuation</strong></td>
<td><strong>country</strong></td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>2017-01-31</td>
<td>55.0</td>
<td>15.85750</td>
<td>3.468390</td>
<td>10.869565</td>
<td>-31.454736</td>
<td>6.26715</td>
<td>8.26976</td>
<td>29.6269</td>
<td>32.7146</td>
<td>13.6258</td>
<td>ARG</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>2016-07-31</td>
<td>50.0</td>
<td>14.93500</td>
<td>3.347841</td>
<td>9.920635</td>
<td>-33.574590</td>
<td>2.07261</td>
<td>0.402248</td>
<td>17.5645</td>
<td>19.7638</td>
<td>11.6431</td>
<td>ARG</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2016-01-31</td>
<td>33.0</td>
<td>13.80925</td>
<td>2.389703</td>
<td>6.693712</td>
<td>-51.527332</td>
<td>-24.8619</td>
<td>-18.714</td>
<td>-18.7209</td>
<td>0.40859</td>
<td>-17.029</td>
<td>ARG</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>2015-07-31</td>
<td>28.0</td>
<td>9.13500</td>
<td>3.065134</td>
<td>5.845511</td>
<td>-36.009727</td>
<td>-4.7585</td>
<td>-0.357918</td>
<td>-6.01091</td>
<td>30.8609</td>
<td>5.02868</td>
<td>ARG</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>2015-01-31</td>
<td>28.0</td>
<td>8.61000</td>
<td>3.252033</td>
<td>5.845511</td>
<td>-32.107881</td>
<td>0.540242</td>
<td>-0.804495</td>
<td>-2.49468</td>
<td>34.3905</td>
<td>6.01183</td>
<td>ARG</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The Big Mac index was invented by The Economist in 1986 as a lighthearted guide to check whether currencies are at their correct level. It is based on the theory of <strong>purchasing power parity</strong> (<strong>PPP</strong>) and is considered an informal measure of currency exchange rates at PPP. It measures their value against a similar basket of goods and services, in this case, a Big Mac. Differing prices at market exchange rates would imply that one currency is undervalued or overvalued.</p>
<p>The code for parsing JSON from the Quandl API is a bit more complicated, and thus extra explanations might help you to understand it. The first function, <kbd>get_bigmac_codes()</kbd>, parses the list of all available dataset codes in the Quandl Economist database as a pandas DataFrame. Meanwhile, the second function, <kbd>get_quandl_dataset(api_key, code)</kbd>, converts the JSON response of a Quandl dataset API query to a pandas DataFrame. All datasets obtained are concatenated using <kbd>pandas.concat()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing the trend of data</h1>
                </header>
            
            <article>
                
<p>Once we have imported the two datasets, we can set out on a further visualization journey. Let's begin by plotting the world population trends from 1950 to 2017. To select rows based on the value of a column, we can use the following syntax: <kbd>df[df.variable_name == "target"]</kbd> or <kbd>df[df['variable_name'] == "target"]</kbd>, where <kbd>df</kbd> is the dataframe object. Other conditional operators, such as larger than &gt; or smaller than &lt;, are also supported. Multiple conditional statements can be chained together using the "and" operator &amp;, or the "or" operator |.</p>
<p>To aggregate the population across all age groups within a year, we are going to rely on <kbd>df.groupby().sum()</kbd>, as shown in the following example:</p>
<pre>import matplotlib.pyplot as plt<br/><br/><br/># Select the aggregated population data from the world for both genders,<br/># during 1950 to 2017.<br/>selected_data = data[(data.Location == 'WORLD') &amp; (data.Sex == 'Both') &amp; (data.Time &lt;= 2017) ]<br/><br/># Calculate aggregated population data across all age groups for each year <br/># Set as_index=False to avoid the Time variable to be used as index<br/>grouped_data = selected_data.groupby('Time', as_index=False).sum()<br/><br/># Generate a simple line plot of population vs time<br/>fig = plt.figure()<br/>plt.plot(grouped_data.Time, grouped_data.Value)<br/><br/># Label the axis<br/>plt.xlabel('Year')<br/>plt.ylabel('Population (thousands)')<br/><br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/f5dd839a-cb94-48c2-a532-bf2005cf3771.png" style="width:34.08em;height:22.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Area chart and stacked area chart</h1>
                </header>
            
            <article>
                
<p class="cell text_cell rendered selected">Sometimes, we may want to shade the area under the line plot with color for a greater visual impact. This can be achieved via the <kbd>fill_between</kbd> class:</p>
<div class="cell text_cell rendered selected"/>
<pre class="cell text_cell rendered selected">fill_between(x, y1, y2=0, where=None, interpolate=False, step=None)</pre>
<p class="cell text_cell rendered selected">By default, <kbd>fill_between</kbd> shades the region between <kbd>y=0</kbd> and the line when <kbd>y2</kbd> is not specified. More complex shading behavior can be specified using the where, interpolate, and step keyword arguments. Readers can refer to the following link for more information: <a href="https://matplotlib.org/examples/pylab_examples/fill_between_demo.html">https://matplotlib.org/examples/pylab_examples/fill_between_demo.html.</a></p>
<p class="cell text_cell rendered selected">Let's try to plot a more detailed chart by separating the two genders. We are going to explore the relative contribution of males and females towards the population growth. To do that, we can prepare a stacked area chart using the <kbd>stackplot</kbd> class:</p>
<pre># Select the aggregated population data from the world for each gender,<br/># during 1950 to 2017.<br/>male_data = data[(data.Location == 'WORLD') &amp; (data.Sex == 'Male') &amp; (data.Time &lt;= 2017) ]<br/>female_data = data[(data.Location == 'WORLD') &amp; (data.Sex == 'Female') &amp; (data.Time &lt;= 2017) ]<br/><br/># Calculate aggregated population data across all age groups for each year <br/># Set as_index=False to avoid the Time variable to be used as index<br/>grouped_male_data = male_data.groupby('Time', as_index=False).sum()<br/>grouped_female_data = female_data.groupby('Time', as_index=False).sum()<br/><br/># Create two subplots with shared y-axis (sharey=True)<br/>fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(12,4), sharey=True)<br/><br/># Generate a simple line plot of population vs time,<br/># then shade the area under the line in sky blue.<br/>ax1.plot(grouped_data.Time, grouped_data.Value)<br/>ax1.fill_between(grouped_data.Time, grouped_data.Value, color='skyblue')<br/><br/># Use set_xlabel() or set_ylabel() instead to set the axis label of an<br/># axes object<br/>ax1.set_xlabel('Year')<br/>ax1.set_ylabel('Population (thousands)')<br/><br/># Generate a stacked area plot of population vs time<br/>ax2.stackplot(grouped_male_data.Time, grouped_male_data.Value, grouped_female_data.Value)<br/><br/># Add a figure legend<br/>ax2.legend(['Male', 'Female'], loc='upper left')<br/><br/># Set the x-axis label only this time<br/>ax2.set_xlabel('Year')<br/>plt.show()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/a7eff28b-2fbb-4d2a-91f5-66abcfebd085.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Seaborn</h1>
                </header>
            
            <article>
                
<p>Seaborn by Michael Waskom is a statistical visualization library that is built on top of Matplotlib. It comes with handy functions for visualizing categorical variables, univariate distributions, and bivariate distributions. For more complex plots, various statistical methods such as linear regression models and clustering algorithms are available. Like Matplotlib, Seaborn also supports Pandas dataframes as input, plus automatically performing the necessary slicing, grouping, aggregation, and statistical model fitting to produce informative figures.</p>
<p>These Seaborn functions aim to bring publication-quality figures through an API with a minimal set of arguments, while maintaining the full customization capabilities of Matplotlib. In fact, many functions in Seaborn return a Matplotlib axis or grid object when invoked. Therefore, Seaborn is a great companion of Matplotlib. To install Seaborn through PyPI, you can issue the following command in the terminal:</p>
<pre><strong>pip install pandas</strong></pre>
<p>Seaborn will be imported as <kbd>sns</kbd> throughout this book. This section will not be a documentation of Seaborn. Rather our goal is to give a high-level overview of Seaborn's capabilities from the perspective of Matplotlib users. Readers can refer to the official <span>Seaborn</span><span> </span><span>site (</span><a href="http://seaborn.pydata.org/index.html">http://seaborn.pydata.org/index.html</a><span>) for more information.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing univariate distribution</h1>
                </header>
            
            <article>
                
<p>Seaborn makes the task of visualizing the distribution of a dataset much easier. Starting with the population data as discussed before, let's see how it distributes among different countries in 2017 by plotting a bar plot:</p>
<pre class="mce-root">import seaborn as sns<br/>import matplotlib.pyplot as plt<br/><br/><br/># Extract USA population data in 2017<br/>current_population = population_df[(population_df.Location <br/>                                    == 'United States of America') &amp; <br/>                                   (population_df.Time == 2017) &amp;<br/>                                   (population_df.Sex != 'Both')]<br/><br/># Population Bar chart <br/>sns.barplot(x="AgeGrp",y="Value", hue="Sex", data = current_population)<br/><br/># Use Matplotlib functions to label axes rotate tick labels<br/>ax = plt.gca()<br/>ax.set(xlabel="Age Group", ylabel="Population (thousands)")<br/>ax.set_xticklabels(ax.xaxis.get_majorticklabels(), rotation=45)<br/>plt.title("Population Barchart (USA)")<br/><br/># Show the figure<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/56262850-c1ee-41e9-a1f7-64ecdcd0773c.png" style="width:42.58em;height:30.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bar chart in Seaborn</h1>
                </header>
            
            <article>
                
<p>The <kbd>seaborn.barplot()</kbd> function shows a series of data points as rectangular bars. If multiple points per group are available, confidence intervals will be shown on top of the bars to indicate the uncertainty of the point estimates. Like most other Seaborn functions, various input data formats are supported, such as Python lists, Numpy arrays, pandas Series, and pandas DataFrame.</p>
<p>A more traditional way to show the population structure is through the use of a population pyramid.</p>
<p>So what is a population pyramid? As its name suggests, it is a pyramid-shaped plot that shows the age distribution of a population. It can be roughly classified into three classes, namely constrictive, stationary, and expansive for populations that are undergoing negative, stable, and rapid growth respectively. For instance, constrictive populations have a lower proportion of young people, so the pyramid base appears to be constricted. Stable populations have a more or less similar number of young and middle-aged groups. Expansive populations, on the other hand, have a large proportion of youngsters, thus resulting in pyramids with enlarged bases.</p>
<p>We can build a population pyramid by plotting two bar charts on two subplots with a shared y-axis:</p>
<pre class="mce-root">import seaborn as sns<br/>import matplotlib.pyplot as plt<br/><br/># Extract USA population data in 2017<br/>current_population = population_df[(population_df.Location <br/>                                    == 'United States of America') &amp; <br/>                                   (population_df.Time == 2017) &amp;<br/>                                   (population_df.Sex != 'Both')]<br/><br/># Change the age group to descending order<br/>current_population = current_population.iloc[::-1]<br/><br/># Create two subplots with shared y-axis<br/>fig, axes = plt.subplots(ncols=2, sharey=True)<br/><br/># Bar chart for male<br/>sns.barplot(x="Value",y="AgeGrp", color="darkblue", ax=axes[0],<br/>            data = current_population[(current_population.Sex == 'Male')])<br/># Bar chart for female<br/>sns.barplot(x="Value",y="AgeGrp", color="darkred", ax=axes[1],<br/>            data = current_population[(current_population.Sex == 'Female')])<br/><br/># Use Matplotlib function to invert the first chart<br/>axes[0].invert_xaxis()<br/><br/># Use Matplotlib function to show tick labels in the middle<br/>axes[0].yaxis.tick_right()<br/><br/># Use Matplotlib functions to label the axes and titles<br/>axes[0].set_title("Male")<br/>axes[1].set_title("Female")<br/>axes[0].set(xlabel="Population (thousands)", ylabel="Age Group")<br/>axes[1].set(xlabel="Population (thousands)", ylabel="")<br/>fig.suptitle("Population Pyramid (USA)")<br/><br/># Show the figure<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/91b3a3a5-fb14-4335-9b3c-2d09f36fdb79.png" style="width:41.25em;height:32.67em;"/></div>
<p>Since Seaborn is built on top of the solid foundations of Matplotlib, we can customize the plot easily using built-in functions of Matplotlib. In the preceding example, we used <kbd>matplotlib.axes.Axes.invert_xaxis()</kbd> to flip the male population plot horizontally, followed by changing the location of the tick labels to the right-hand side using <kbd>matplotlib.axis.YAxis.tick_right()</kbd>. We further customized the titles and axis labels for the plot using a combination of <kbd>matplotlib.axes.Axes.set_title()</kbd>, <kbd>matplotlib.axes.Axes.set()</kbd>, and <kbd>matplotlib.figure.Figure.suptitle()</kbd>.</p>
<p>Let's try to plot the population pyramids for Cambodia and Japan as well by changing the line <kbd>population_df.Location == 'United States of America'</kbd> to <kbd>population_df.Location == 'Cambodia'</kbd> or <kbd>population_df.Location == 'Japan'</kbd>. Can you classify the pyramids into one of the three population pyramid classes?</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/b728e146-f453-4ef9-b6cb-3a3f26fab503.png" style="width:47.50em;height:37.50em;"/></div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/6e1566cb-b049-4965-8d57-00b608cdd74f.png" style="width:47.92em;height:36.75em;"/></div>
<p>To see how Seaborn simplifies the code for relatively complex plots, let's see how a similar plot can be achieved using vanilla Matplotlib.</p>
<p class="mce-root">First, like the previous Seaborn-based example, we create two subplots with shared y-axis:</p>
<pre class="mce-root">fig, axes = plt.subplots(ncols=2, sharey=True)</pre>
<p class="mce-root">Next, we plot horizontal bar charts using <kbd>matplotlib.pyplot.barh()</kbd> and set the location and labels of ticks, followed by adjusting the subplot spacing:</p>
<pre class="mce-root"># Get a list of tick positions according to the data bins<br/>y_pos = range(len(current_population.AgeGrp.unique()))<br/><br/># Horizontal barchart for male<br/>axes[0].barh(y_pos, current_population[(current_population.Sex ==<br/>             'Male')].Value, color="darkblue")<br/><br/># Horizontal barchart for female<br/>axes[1].barh(y_pos, current_population[(current_population.Sex == <br/>             'Female')].Value, color="darkred")<br/><br/># Show tick for each data point, and label with the age group<br/>axes[0].set_yticks(y_pos)<br/>axes[0].set_yticklabels(current_population.AgeGrp.unique())<br/><br/># Increase spacing between subplots to avoid clipping of ytick labels<br/>plt.subplots_adjust(wspace=0.3)</pre>
<p class="mce-root">Finally, we use the same code to further customize the look and feel of the figure:</p>
<pre class="mce-root"># Invert the first chart<br/>axes[0].invert_xaxis()<br/><br/># Show tick labels in the middle<br/>axes[0].yaxis.tick_right()<br/><br/># Label the axes and titles<br/>axes[0].set_title("Male")<br/>axes[1].set_title("Female")<br/>axes[0].set(xlabel="Population (thousands)", ylabel="Age Group")<br/>axes[1].set(xlabel="Population (thousands)", ylabel="")<br/>fig.suptitle("Population Pyramid (USA)")<br/><br/># Show the figure<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/15c72474-c183-42d7-b957-a88958c89c46.png" style="width:37.83em;height:32.50em;"/></div>
<p>When compared to the Seaborn-based code, the pure Matplotlib implementation requires extra lines to define the tick positions, tick labels, and subplot spacing. For some other Seaborn plot types that include extra statistical calculations such as linear regression, and pearson correlation, the code reduction is even more dramatic. Therefore, Seaborn is a "batteries-included" statistical visualization package that allows users to write less verbose code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Histogram and distribution fitting in Seaborn</h1>
                </header>
            
            <article>
                
<p>In the population example, the raw data was already binned into different age groups. What if the data is not binned (for example, the BigMac Index data)? Turns out, <kbd>seaborn.distplot</kbd> can help us to process the data into bins and show us a histogram as a result. Let's look at this example:</p>
<pre class="mce-root">import seaborn as sns<br/>import matplotlib.pyplot as plt<br/><br/><br/># Get the BigMac index in 2017<br/>current_bigmac = bigmac_df[(bigmac_df.Date == "2017-01-31")]<br/><br/># Plot the histogram<br/>ax = sns.distplot(current_bigmac.dollar_price)<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/c013bf79-99a6-4605-910d-05b2dfa1162d.png" style="width:42.67em;height:29.83em;"/></div>
<p>The <kbd>seaborn.distplot</kbd> function expects either pandas Series, single-dimensional numpy.array, or a Python list as input. Then, it determines the size of the bins according to the Freedman-Diaconis rule, and finally it fits a <strong>kernel density estimate</strong> (<strong>KDE</strong>) over the histogram.</p>
<p>KDE is a non-parametric method used to estimate the distribution of a variable. We can also supply a parametric distribution, such as beta, gamma, or normal distribution, to the <kbd>fit</kbd> argument.</p>
<p>In this example, we are going to fit the normal distribution from the <kbd>scipy.stats</kbd> package over the Big Mac Index dataset:</p>
<pre>from scipy import stats<br/><br/>ax = sns.distplot(current_bigmac.dollar_price, kde=False, fit=stats.norm)<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/834e6988-4fef-4f3c-bb46-d2c348144fff.png" style="width:42.67em;height:30.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing a bivariate distribution</h1>
                </header>
            
            <article>
                
<p>We should bear in mind that the Big Mac index is not directly comparable between countries. Normally, we would expect commodities in poor countries to be cheaper than those in rich ones. To represent a fairer picture of the index, it would be better to show the relationship between Big Mac pricing and <strong>Gross Domestic Product</strong> (<strong>GDP</strong>) per capita.</p>
<p>We are going to acquire GDP per capita from Quandl's <strong>World Bank World Development Indicators</strong> (<strong>WWDI</strong>) dataset. Based on the previous code example of acquiring JSON data from Quandl, can you try to adapt it to download the GDP per capita dataset?</p>
<p>For those who are impatient, here is the full code:</p>
<pre class="mce-root">import urllib<br/>import json<br/>import pandas as pd<br/>import time<br/>from urllib.request import urlopen<br/><br/><br/>def get_gdp_dataset(api_key, country_code):<br/>    """Obtain and parse a quandl GDP dataset in Pandas DataFrame format<br/>    Quandl returns dataset in JSON format, where data is stored as a <br/>    list of lists in response['dataset']['data'], and column headers<br/>    stored in response['dataset']['column_names'].<br/> <br/>    Args:<br/>        api_key: Quandl API key<br/>        country_code: Three letter code to represent country<br/><br/>    Returns:<br/>        df: Pandas DataFrame of a Quandl dataset<br/>    """<br/>    base_url = "https://www.quandl.com/api/v3/datasets/"<br/>    url_suffix = ".json?api_key="<br/> <br/>    # Compose the Quandl API dataset code to get GDP per capita<br/>    # (constant 2000 US$) dataset<br/>    gdp_code = "WWDI/" + country_code + "_NY_GDP_PCAP_KD"<br/> <br/>    # Parse the JSON response from Quandl API<br/>    # Some countries might be missing, so we need error handling code<br/>    try:<br/>        u = urlopen(base_url + gdp_code + url_suffix + api_key)<br/>    except urllib.error.URLError as e:<br/>        print(gdp_code,e)<br/>        return None<br/> <br/>    response = json.loads(u.read().decode('utf-8'))<br/> <br/>    # Format the response as Pandas Dataframe<br/>    df = pd.DataFrame(response['dataset']['data'], columns=response['dataset']['column_names'])<br/> <br/>    # Add a new country code column<br/>    df['country'] = country_code<br/> <br/>    return df<br/><br/><br/>api_key = "INSERT YOUR KEY HERE"<br/>quandl_dfs = []<br/><br/># Loop through all unique country code values in the BigMac index DataFrame<br/>for country_code in bigmac_df.country.unique():<br/>    # Fetch the GDP dataset for the corresponding country <br/>    df = get_gdp_dataset(api_key, country_code)<br/> <br/>    # Skip if the response is empty<br/>    if df is None:<br/>        continue<br/> <br/>    # Store in a list DataFrames<br/>    quandl_dfs.append(df)<br/> <br/>    # Prevents exceeding the API speed limit<br/>    time.sleep(2)<br/> <br/># Concatenate the list of DataFrames into a single one <br/>gdp_df = pd.concat(quandl_dfs)<br/>gdp_df.head()</pre>
<p>The expected output:</p>
<pre class="mce-root"><strong>WWDI/EUR_NY_GDP_PCAP_KD HTTP Error 404: Not Found</strong><br/><strong>WWDI/SIN_NY_GDP_PCAP_KD HTTP Error 404: Not Found</strong><br/><strong>WWDI/ROC_NY_GDP_PCAP_KD HTTP Error 404: Not Found</strong><br/><strong>WWDI/UAE_NY_GDP_PCAP_KD HTTP Error 404: Not Found</strong></pre>
<table style="border-collapse: collapse;width: 50%" class="dataframe" border="1">
<tbody>
<tr>
<td/>
<td>Date</td>
<td>Value</td>
<td>country</td>
</tr>
<tr>
<td>0</td>
<td>2015-12-31</td>
<td>10501.660269</td>
<td>ARG</td>
</tr>
<tr>
<td>1</td>
<td>2014-12-31</td>
<td>10334.780146</td>
<td>ARG</td>
</tr>
<tr>
<td>2</td>
<td>2013-12-31</td>
<td>10711.229530</td>
<td>ARG</td>
</tr>
<tr>
<td>3</td>
<td>2012-12-31</td>
<td>10558.265365</td>
<td>ARG</td>
</tr>
<tr>
<td>4</td>
<td>2011-12-31</td>
<td>10780.342508</td>
<td>ARG</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We can see that the GDP per capita dataset is not available for four geographical locations, but we can ignore that for now.</p>
<p>Next, we will merge the two DataFrames that contain Big Mac Index and GDP per capita respectively using <kbd>pandas.merge()</kbd>. The most recent record in WWDI's GDP per capita dataset was collected at the end of 2015, so let's pair that up with the corresponding Big Mac index dataset in the same year.</p>
<p>For those who are familiar with the SQL language, <kbd>pandas.merge()</kbd> supports four modes, namely left, right, inner, and outer joins. Since we are interested in rows that have matching countries in both DataFrames only, we are going to choose inner join:</p>
<pre>merged_df = pd.merge(bigmac_df[(bigmac_df.Date == "2015-01-31")], gdp_df[(gdp_df.Date == "2015-12-31")], how='inner', on='country')<br/>merged_df.head()</pre>
<table style="border-collapse: collapse;width: 50%" class="table" border="1">
<tbody>
<tr>
<td/>
<td>Date_x</td>
<td>local_price</td>
<td>dollar_ex</td>
<td>dollar_price</td>
<td>dollar_ppp</td>
<td>dollar_valuation</td>
<td>dollar_adj_valuation</td>
<td>euro_adj_valuation</td>
<td>sterling_adj_valuation</td>
<td>yen_adj_valuation</td>
<td>yuan_adj_valuation</td>
<td>country</td>
<td>Date_y</td>
<td>Value</td>
</tr>
<tr>
<td>0</td>
<td>2015-01-31</td>
<td>28.00</td>
<td>8.610000</td>
<td>3.252033</td>
<td>5.845511</td>
<td>-32.107881</td>
<td>0.540242</td>
<td>-0.804495</td>
<td>-2.49468</td>
<td>34.3905</td>
<td>6.01183</td>
<td>ARG</td>
<td>2015-12-31</td>
<td>10501.660269</td>
</tr>
<tr>
<td>1</td>
<td>2015-01-31</td>
<td>5.30</td>
<td>1.227220</td>
<td>4.318705</td>
<td>1.106472</td>
<td>-9.839144</td>
<td>-17.8995</td>
<td>-18.9976</td>
<td>-20.3778</td>
<td>9.74234</td>
<td>-13.4315</td>
<td>AUS</td>
<td>2015-12-31</td>
<td>54688.445933</td>
</tr>
<tr>
<td>2</td>
<td>2015-01-31</td>
<td>13.50</td>
<td>2.592750</td>
<td>5.206827</td>
<td>2.818372</td>
<td>8.702019</td>
<td>68.4555</td>
<td>66.2024</td>
<td>63.3705</td>
<td>125.172</td>
<td>77.6231</td>
<td>BRA</td>
<td>2015-12-31</td>
<td>11211.891104</td>
</tr>
<tr>
<td>3</td>
<td>2015-01-31</td>
<td>2.89</td>
<td>0.661594</td>
<td>4.368235</td>
<td>0.603340</td>
<td>-8.805115</td>
<td>3.11257</td>
<td>1.73343</td>
<td>0</td>
<td>37.8289</td>
<td>8.72415</td>
<td>GBR</td>
<td>2015-12-31</td>
<td>41182.619517</td>
</tr>
<tr>
<td>4</td>
<td>2015-01-31</td>
<td>5.70</td>
<td>1.228550</td>
<td>4.639616</td>
<td>1.189979</td>
<td>-3.139545</td>
<td>-2.34134</td>
<td>-3.64753</td>
<td>-5.28928</td>
<td>30.5387</td>
<td>2.97343</td>
<td>CAN</td>
<td>2015-12-31</td>
<td>50108.065004</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scatter plot in Seaborn</h1>
                </header>
            
            <article>
                
<p class="mce-root">A scatter plot is one of the most common plots in the scientific and business worlds. It is particularly useful for displaying the relationship between two variables. While we can simply use <kbd>matplotlib.pyplot.scatter</kbd> to draw a scatter plot, we can also use Seaborn to build similar plots with more advanced features.</p>
<p class="mce-root">The two functions <kbd>seaborn.regplot()</kbd> and <kbd>seaborn.lmplot()</kbd> display a linear relationship in the form of a scatter plot, a regression line, plus the 95% confidence interval around that regression line. The main difference between the two functions is that <kbd>lmplot()</kbd> combines <kbd>regplot()</kbd> with <kbd>FacetGrid</kbd> such that we can create color-coded or faceted scatter plots to show the interaction between three or more pairs of variables. We will demonstrate the use of <kbd>lmplot()</kbd> later in this chapter and the next chapter.</p>
<p class="mce-root">The simplest form of <kbd>seaborn.regplot()</kbd> supports numpy arrays, pandas Series, or pandas DataFrames as input. The regression line and the confidence interval can be removed by specifying <kbd>fit_reg=False</kbd>.</p>
<p class="mce-root">We are going to investigate the hypothesis that Big Macs are cheaper in poorer countries, and vice versa, checking whether there is any correlation between the Big Mac index and GDP per capita:</p>
<pre class="mce-root">import seaborn as sns<br/>import matplotlib.pyplot as plt<br/><br/># seaborn.regplot() returns matplotlib.Axes object<br/>ax = sns.regplot(x="Value", y="dollar_price", data=merged_df, fit_reg=False)<br/>ax.set_xlabel("GDP per capita (constant 2000 US$)")<br/>ax.set_ylabel("BigMac index (US$)")<br/><br/>plt.show()</pre>
<p>The expected output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d36ae630-7dc2-486c-9bd5-26840c2e65fb.png" style="width:42.00em;height:29.25em;"/></div>
<p>So far so good! It looks like the Big Mac index is positively correlated with GDP per capita. Let's turn the regression line back on and label a few countries that show extreme Big Mac index values:</p>
<pre class="mce-root">ax = sns.regplot(x="Value", y="dollar_price", data=merged_df)<br/>ax.set_xlabel("GDP per capita (constant 2000 US$)")<br/>ax.set_ylabel("BigMac index (US$)")<br/><br/># Label the country code for those who demonstrate extreme BigMac index<br/>for row in merged_df.itertuples():<br/>    if row.dollar_price &gt;= 5 or row.dollar_price &lt;= 2:<br/>        ax.text(row.Value,row.dollar_price+0.1,row.country)<br/><br/>plt.show()</pre>
<p>This is the expected output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/6aab88b3-8ea2-4e0f-a530-a0040339e8b3.png" style="width:43.75em;height:30.75em;"/></div>
<p class="mce-root">We can see that many countries fall within the confidence interval of the regression line. Given the GDP per capita level for each country, the linear regression model predicts the corresponding Big Mac index. The currency value shows signs of under- or over-valuation if the actual index deviates from the regression model.</p>
<p class="mce-root">By labeling the countries that show extremely high or low values, we can clearly see that the average price of a Big Mac in Brazil and Switzerland is overvalued, while it is undervalued in India, Russia, and Ukraine even if the differences in GDP are considered.</p>
<p class="mce-root">Since Seaborn is not a package for statistical analysis, we would need to rely on other packages, such as <kbd>scipy.stats</kbd> or <kbd>statsmodels</kbd>, to obtain the parameters of a regression model. In the next example, we are going to get the <kbd>slope</kbd> and <kbd>intercept</kbd> parameters from the regression model, and apply different colors for points that are above or below the regression line:</p>
<pre class="mce-root">from scipy.stats import linregress<br/><br/><br/>ax = sns.regplot(x="Value", y="dollar_price", data=merged_df)<br/>ax.set_xlabel("GDP per capita (constant 2000 US$)")<br/>ax.set_ylabel("BigMac index (US$)")<br/><br/># Calculate linear regression parameters<br/>slope, intercept, r_value, p_value, std_err = linregress(merged_df.Value, merged_df.dollar_price)<br/><br/>colors = []<br/>for row in merged_df.itertuples():<br/>    if row.dollar_price &gt; row.Value * slope + intercept:<br/>        # Color markers as darkred if they are above the regression line<br/>        color = "darkred"<br/>    else:<br/>        # Color markers as darkblue if they are below the regression line<br/>        color = "darkblue"<br/> <br/>    # Label the country code for those who demonstrate extreme BigMac index<br/>    if row.dollar_price &gt;= 5 or row.dollar_price &lt;= 2:<br/>        ax.text(row.Value,row.dollar_price+0.1,row.country)<br/> <br/>    # Highlight the marker that corresponds to China<br/>    if row.country == "CHN":<br/>        t = ax.text(row.Value,row.dollar_price+0.1,row.country)<br/>        color = "yellow"<br/> <br/>    colors.append(color)<br/><br/># Overlay another scatter plot on top with marker-specific color<br/>ax.scatter(merged_df.Value, merged_df.dollar_price, c=colors)<br/><br/># Label the r squared value and p value of the linear regression model.<br/># transform=ax.transAxes indicates that the coordinates are given relative<br/># to the axes bounding box, with 0,0 being the lower left of the axes<br/># and 1,1 the upper right.<br/>ax.text(0.1, 0.9, "$r^2={0:.3f}, p={1:.3e}$".format(r_value ** 2, p_value), transform=ax.transAxes)<br/><br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/a7c33727-4494-44f6-b659-ab2f314cd1ba.png" style="width:42.00em;height:29.58em;"/></div>
<p>Contrary to popular belief, it looks like China's currency was not significantly under-valued in 2015 since its marker lies well within the 95% confidence interval of the regression line.</p>
<p>To better illustrate the distribution of values, we can combine histograms of <kbd>x</kbd> or <kbd>y</kbd> values with scatter plots using <kbd>seaborn.jointplot()</kbd>:</p>
<pre class="mce-root"># seaborn.jointplot() returns a seaborn.JointGrid object<br/>g = sns.jointplot(x="Value", y="dollar_price", data=merged_df)<br/><br/># Provide custom axes labels through accessing the underlying axes object<br/># We can get matplotlib.axes.Axes of the scatter plot by calling g.ax_joint<br/>g.ax_joint.set_xlabel("GDP per capita (constant 2000 US$)")<br/>g.ax_joint.set_ylabel("BigMac index (US$)")<br/><br/># Set the title and adjust the margin<br/>g.fig.suptitle("Relationship between GDP per capita and BigMac Index")<br/>g.fig.subplots_adjust(top=0.9)<br/><br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e59c5502-83f1-483a-81e8-790b6d4df877.png" style="width:36.58em;height:36.58em;"/></div>
<p>By additionally specifying the <kbd>kind</kbd> parameter in <kbd>jointplot</kbd> to <kbd>reg</kbd>, <kbd>resid</kbd>, <kbd>hex</kbd>, or <kbd>kde</kbd>, we can quickly change the plot type to regression, residual, hex bin, or KDE contour plot respectively.</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/28dec103-04b7-40ff-a72e-eb2f1b82571f.png"/></div>
<p>Here is a big disclaimer: with the data in our hands, it is still too early to make any conclusions about the valuation of currencies! Different business factors such as labor cost, rent, raw material costs, and taxation can all contribute to the pricing model of Big Mac, but this is beyond the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visualizing categorical data</h1>
                </header>
            
            <article>
                
<p class="mce-root">Towards the end of this chapter, let's try to integrate all datasets that we have processed so far. Remember that we briefly introduced the three categories of population structures (that is, constrictive, stable, and expansive) earlier in this chapter?</p>
<p class="mce-root">In this section, we are going to implement a naive algorithm for classifying populations into one of the three categories. After that, we will explore different techniques of visualizing categorical data.</p>
<p class="mce-root">Most references online discuss visual classification of population pyramids only (for example, <a href="https://www.populationeducation.org/content/what-are-different-types-population-pyramids" target="_blank">https://www.populationeducation.org/content/what-are-different-types-population-pyramids</a>). Clustering-based methods do exist (for example, Korenjak-Cˇ erne, Kejžar, Batagelj (2008). <em>Clustering of Population Pyramids</em>. Informatica. 32.), but to date, mathematical definitions of population categories are scarcely discussed. We will build a naive classifier based on the ratio of populations between "0-4" and "50-54" age groups in the next example:</p>
<pre class="mce-root">import pandas as pd<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/><br/><br/># Select total population for each country in 2015<br/>current_population = population_df[(population_df.Time == 2015) &amp;<br/>                                   (population_df.Sex == 'Both')]<br/><br/># A list for storing the population type for each country<br/>pop_type_list = []<br/><br/># Look through each country in the BigMac index dataset<br/>for country in merged_df.country.unique():<br/>    # Make sure the country also exist in the GDP per capita dataset<br/>    if not country in current_population.country.values:<br/>       continue<br/> <br/>    # Calculate the ratio of population between "0-4" and "50-54"<br/>    # age groups<br/>    young = current_population[(current_population.country == country) &amp;<br/>                               (current_population.AgeGrp == "0-4")].Value<br/> <br/>    midage = current_population[(current_population.country == country) &amp;<br/>                                (current_population.AgeGrp == "50-54")].Value<br/> <br/>    ratio = float(young) / float(midage)<br/> <br/>    # Classify the populations based on arbitrary ratio thresholds<br/>    if ratio &lt; 0.8:<br/>        pop_type = "constrictive"<br/>    elif ratio &lt; 1.2 and ratio &gt;= 0.8:<br/>        pop_type = "stable"<br/>    else:<br/>        pop_type = "expansive"<br/> <br/>    pop_type_list.append([country, ratio, pop_type])<br/><br/># Convert the list to Pandas DataFrame<br/>pop_type_df = pd.DataFrame(pop_type_list, columns=['country','ratio','population type'])<br/><br/># Merge the BigMac index DataFrame with population type DataFrame<br/>merged_df2 = pd.merge(merged_df, pop_type_df, how='inner', on='country')<br/>merged_df2.head()</pre>
<p>The expected output is as follows:</p>
<table style="border-collapse: collapse;width: 50%" class="class" border="1">
<tbody>
<tr>
<td/>
<td>Date_x</td>
<td>local_price</td>
<td>dollar_ex</td>
<td>dollar_price</td>
<td>dollar_ppp</td>
<td>dollar_valuation</td>
<td>dollar_adj_valuation</td>
<td>euro_adj_valuation</td>
<td>sterling_adj_valuation</td>
<td>yen_adj_valuation</td>
<td>yuan_adj_valuation</td>
<td>country</td>
<td>Date_y</td>
<td>Value</td>
<td>ratio</td>
<td>population type</td>
</tr>
<tr>
<td>0</td>
<td>2015-01-31</td>
<td>28.00</td>
<td>8.610000</td>
<td>3.252033</td>
<td>5.845511</td>
<td>-32.107881</td>
<td>0.540242</td>
<td>-0.804495</td>
<td>-2.49468</td>
<td>34.3905</td>
<td>6.01183</td>
<td>ARG</td>
<td>2015-12-31</td>
<td>10501.660269</td>
<td>1.695835</td>
<td>expansive</td>
</tr>
<tr>
<td>1</td>
<td>2015-01-31</td>
<td>5.30</td>
<td>1.227220</td>
<td>4.318705</td>
<td>1.106472</td>
<td>-9.839144</td>
<td>-17.8995</td>
<td>-18.9976</td>
<td>-20.3778</td>
<td>9.74234</td>
<td>-13.4315</td>
<td>AUS</td>
<td>2015-12-31</td>
<td>54688.445933</td>
<td>0.961301</td>
<td>stable</td>
</tr>
<tr>
<td>2</td>
<td>2015-01-31</td>
<td>13.50</td>
<td>2.592750</td>
<td>5.206827</td>
<td>2.818372</td>
<td>8.702019</td>
<td>68.4555</td>
<td>66.2024</td>
<td>63.3705</td>
<td>125.172</td>
<td>77.6231</td>
<td>BRA</td>
<td>2015-12-31</td>
<td>11211.891104</td>
<td>1.217728</td>
<td>expansive</td>
</tr>
<tr>
<td>3</td>
<td>2015-01-31</td>
<td>2.89</td>
<td>0.661594</td>
<td>4.368235</td>
<td>0.603340</td>
<td>-8.805115</td>
<td>3.11257</td>
<td>1.73343</td>
<td>0</td>
<td>37.8289</td>
<td>8.72415</td>
<td>GBR</td>
<td>2015-12-31</td>
<td>41182.619517</td>
<td>0.872431</td>
<td>stable</td>
</tr>
<tr>
<td>4</td>
<td>2015-01-31</td>
<td>5.70</td>
<td>1.228550</td>
<td>4.639616</td>
<td>1.189979</td>
<td>-3.139545</td>
<td>-2.34134</td>
<td>-3.64753</td>
<td>-5.28928</td>
<td>30.5387</td>
<td>2.97343</td>
<td>CAN</td>
<td>2015-12-31</td>
<td>50108.065004</td>
<td>0.690253</td>
<td>constrictive</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Categorical scatter plot</h1>
                </header>
            
            <article>
                
<p class="mce-root">With the data classified into categories, we can check whether different population types exhibit different<span> </span><span>Big Mac index</span><span> distributions.</span></p>
<p class="mce-root">We can use <kbd>seaborn.lmplot</kbd> to dissect the data and create a categorical scatter plot. As a recap, <kbd>lmplot()</kbd> combines <kbd>regplot()</kbd> with <kbd>FacetGrid</kbd> for visualization of three or more pairs of variables in faceted grids or color-coded scatter plots. In the upcoming examples, we are going to assign the population type variable to the <kbd>col</kbd>, <kbd>row</kbd>, or <kbd>hue</kbd> parameters of <kbd>lmplot()</kbd>. Let's see how the results look:</p>
<pre class="mce-root"># Horizontal faceted grids (col="population type")<br/>g = sns.lmplot(x="Value", y="dollar_price", col="population type", data=merged_df2)<br/>g.set_xlabels("GDP per capita (constant 2000 US$)")<br/>g.set_ylabels("BigMac index (US$)")<br/><br/>plt.show()</pre>
<p>The preceding code excerpt generates:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/16f3a772-128b-4ce5-a459-4d800fe6be9d.png"/></div>
<p>Alternatively, if we set <kbd>row="population type"</kbd> instead of <kbd>col="population type"</kbd> in the code excerpt, the following plot will be generated:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/67e697a9-e0c3-417c-afce-88e886b33e97.png" style="width:18.42em;height:55.25em;"/></div>
<p>Finally, by changing <kbd>col="population type"</kbd> to <kbd>hue="population type"</kbd> , a color-coded categorical scatter plot will be generated:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9a1cc962-df10-4723-9b8d-c44045acb922.png" style="width:42.25em;height:34.08em;"/></div>
<p class="mce-root">In fact, <kbd>col</kbd>, <kbd>row</kbd>, and <kbd>hue</kbd> can be mixed together to create a rich faceted grid. This is particularly useful when there are lots of dimensions in your data. Further discussion of facet grids will be available in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strip plot and swarm plot</h1>
                </header>
            
            <article>
                
<p class="mce-root">A strip is basically a scatter plot where the <em>x-</em>axis represents a categorical variable. Typical uses of a strip plot involve applying a small random jitter value to each data point such that the separation between points becomes clearer:</p>
<pre class="mce-root"># Strip plot with jitter value<br/>ax = sns.stripplot(x="population type", y="dollar_price", data=merged_df2, jitter=True)<br/>ax.set_xlabel("Population type")<br/>ax.set_ylabel("BigMac index (US$)")<br/><br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e4e4391d-bc58-4a57-bb5f-326427efab08.png" style="width:43.25em;height:30.50em;"/></div>
<p>A swarm plot is very similar to a strip plot, yet the locations of points are adjusted automatically to avoid overlap even if the jitter value is not applied. These plots resemble bees swarming a position, and are likewise named.</p>
<p>If we change the Seaborn function call from <kbd>sns.stripplot</kbd> to <kbd>sns.swarmplot</kbd> in the preceding code excerpt, the result will be changed to this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e4ba8226-f575-468f-aaa5-f2756bf1ff60.png" style="width:44.83em;height:31.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Box plot and violin plot</h1>
                </header>
            
            <article>
                
<p class="mce-root">The way a strip plot and swarm plot represent data makes<span> </span><span>comparison</span><span> difficult. Suppose you want to find out whether the stable or constrictive population type has a higher median BigMac index value. Can you do that based on the two previous example plots?</span></p>
<p class="mce-root">You might be tempted to think that the constrictive group has a higher median value because of the higher maximum data point, but in fact, the stable group has a higher median value.</p>
<p class="mce-root">Could there be a better plot type for comparing the distribution of categorical data? Here you go! Let's try a box plot:</p>
<pre class="mce-root"># Box plot<br/>ax = sns.boxplot(x="population type", y="dollar_price", data=merged_df2)<br/>ax.set_xlabel("Population type")<br/>ax.set_ylabel("BigMac index (US$)")<br/><br/>plt.show()</pre>
<p>The expected output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9bfdeb24-db50-4d68-afe2-db7f168ad864.png" style="width:47.92em;height:33.58em;"/></div>
<div class="mce-root packt_infobox">The box represents quartiles of the data, the center line denotes the median value, and the whiskers represent the full range of the data. Data points that deviate by more than 1.5 times the interquartile range from the upper or lower quartile are deemed to be outliers and show as fliers.</div>
<p>A violin plot combines the kernel density estimate of our data with the box plot. Both box plot and violin plot display the median and interquartile range, but a violin plot goes one step further by showing the full estimated probability distribution that is fit to the data. Therefore, we can tell whether there are peaks within the data and also compare their relative amplitude.</p>
<p>If we change the Seaborn function call from <kbd>sns.boxplot</kbd> to <kbd>sns.violinplot</kbd> in the code excerpt, the result would be like this:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/38295ea3-2e32-4184-b1a0-a36920164742.png" style="width:36.58em;height:26.25em;"/></div>
<p class="mce-root">We can also overlay a strip plot or swarm plot on top of the box plot or swarm plot in order to get the best of both worlds. Here is an example code:</p>
<pre class="mce-root"># Prepare a box plot<br/>ax = sns.boxplot(x="population type", y="dollar_price", data=merged_df2)<br/><br/># Overlay a swarm plot on top of the same axes<br/>sns.swarmplot(x="population type", y="dollar_price", data=merged_df2, color="w", ax=ax)<br/>ax.set_xlabel("Population type")<br/>ax.set_ylabel("BigMac index (US$)")<br/><br/>plt.show()</pre>
<p>The expected output:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/dafadade-eb00-4342-a389-eeb43e92bd97.png" style="width:42.58em;height:29.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling Seaborn figure aesthetics</h1>
                </header>
            
            <article>
                
<p>While we can use Matplotlib to customize the figure aesthetics, Seaborn comes with several handy functions to make customization easier. If you are using Seaborn version 0.8 or later, <kbd>seaborn.set()</kbd> must be called explicitly after import if you would like to enable the beautiful Seaborn default theme. In earlier versions, <kbd>seaborn.set()</kbd> was called implicitly on import.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preset themes</h1>
                </header>
            
            <article>
                
<p>The five default themes in Seaborn, namely darkgrid, whitegrid, dark, white, and ticks, can be selected by calling the <kbd>seaborn.set_style()</kbd> function.</p>
<div class="packt_tip"><kbd>seaborn.set_style()</kbd> must be called before issuing any plotting commands in order to display the theme properly.</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/bce26e90-c0f9-46b7-9e0e-36e05a8045d1.png" style="width:32.08em;height:48.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing spines from the figure</h1>
                </header>
            
            <article>
                
<p>To remove or adjust the positions of spines, we can make use of the <kbd>seaborn.despine</kbd> function. By default, the spines on the top and right side of a figure are removed, and additional spines can be removed by setting <kbd>left=True</kbd> or <kbd>bottom=True</kbd>. Through the use of offset and trim parameters, the location of the spines can be adjusted as well.</p>
<div class="packt_tip"><kbd>seaborn.despine</kbd> has to be called after calling the <span>S</span>eaborn plotting functions.</div>
<p>Here are the results of different combinations of parameters in the <kbd>seaborn.despine</kbd> function:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/0f326188-f03d-4b94-93a7-1a22173aac6e.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing the size of the figure</h1>
                </header>
            
            <article>
                
<p class="mce-root">To control the height and width of the figure, we can <span>rely on</span> <kbd>matplotlib.pyplot.figure(figsize=(WIDTH,HEIGHT))</kbd><span> as well.</span></p>
<p class="mce-root">In this example, we are going to change the size of the previous histogram example to 8 inches wide and 4 inches tall:</p>
<pre class="mce-root">import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>from scipy import stats<br/><br/># Note: Codes related to data preparation are skipped for brevity<br/># Reset all previous theme settings to defaults<br/>sns.set()<br/><br/># Change the size to 8 inches wide and 4 inches tall<br/>fig = plt.figure(figsize=(8,4))<br/><br/># We are going to reuse current_bigmac that was generated earlier<br/># Plot the histogram<br/>ax = sns.distplot(current_bigmac.dollar_price)<br/>plt.show()</pre>
<p>Here is the expected output from the preceding code:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/23c2759b-5997-492d-a47d-994d9e936d04.png"/></div>
<p>Seaborn also comes with the <kbd>seaborn.set_context()</kbd> function to control the scale of plot elements. There are four preset contexts, paper, notebook, talk, and poster, which are in ascending <span>order</span><span> of </span><span>size. By default, the Notebook style is chosen. This is an example of setting the context to <kbd>poster</kbd>:</span></p>
<pre class="mce-root"># Reset all previous theme settings to defaults<br/>sns.set()<br/><br/># Set Seaborn context to poster<br/>sns.set_context("poster")<br/><br/># We are going to reuse current_bigmac that was generated earlier<br/># Plot the histogram<br/>ax = sns.distplot(current_bigmac.dollar_price)<br/>plt.show()</pre>
<p>Here is the expected output from the preceding code:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/fc0cc554-44ee-4cfe-bd19-1cba41ff9859.png" style="width:42.67em;height:29.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fine-tuning the style of the figure</h1>
                </header>
            
            <article>
                
<p>Almost every element in a Seaborn figure can be further customized via <kbd>seaborn.set</kbd>. Here is the list of parameters that are supported:</p>
<ul>
<li><kbd>context</kbd>: One of the preset contexts--{paper, notebook, talk, poster}.</li>
<li><kbd>style</kbd>: One of the axes' styles--{darkgrid, whitegrid, dark, white, ticks}.</li>
<li><kbd>palette</kbd>: One of the color palettes as defined in <a href="https://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette" target="_blank">https://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette</a>.</li>
<li><kbd>font</kbd>: A supported font or font family name, such as serif, sans-serif, cursive, fantasy, or monospace. For more information, visit <a href="https://matplotlib.org/api/font_manager_api.html" target="_blank">https://matplotlib.org/api/font_manager_api.html</a>.</li>
<li><kbd>font_scale</kbd>: An independent scaling factor of font elements.</li>
<li><kbd>rc</kbd>: A dictionary of extra <kbd>rc</kbd> parameters mappings. To obtain the full list of all <kbd>rc</kbd> parameters, we can run <kbd>seaborn.axes_style()</kbd>.</li>
</ul>
<div class="packt_tip">RC parameters that are not defined in the currently used preset context or axis style cannot be overridden. For more information on <kbd>seaborn.set()</kbd>, please visit <a href="https://seaborn.pydata.org/generated/seaborn.set.html#seaborn.set" target="_blank">https://seaborn.pydata.org/generated/seaborn.set.html#seaborn.set</a>.</div>
<p>Let's try to increase the font scale, increase the line width of the KDE plot, and change the color of several plot elements:</p>
<pre class="mce-root"># Get a dictionary of all parameters that can be changed<br/>sns.axes_style()<br/><br/>"""<br/>Returns<br/>{'axes.axisbelow': True,<br/> 'axes.edgecolor': '.8',<br/> 'axes.facecolor': 'white',<br/> 'axes.grid': True,<br/> 'axes.labelcolor': '.15',<br/> 'axes.linewidth': 1.0,<br/> 'figure.facecolor': 'white',<br/> 'font.family': [u'sans-serif'],<br/> 'font.sans-serif': [u'Arial',<br/> u'DejaVu Sans',<br/> u'Liberation Sans',<br/> u'Bitstream Vera Sans',<br/> u'sans-serif'],<br/> 'grid.color': '.8',<br/> 'grid.linestyle': u'-',<br/> 'image.cmap': u'rocket',<br/> 'legend.frameon': False,<br/> 'legend.numpoints': 1,<br/> 'legend.scatterpoints': 1,<br/> 'lines.solid_capstyle': u'round',<br/> 'text.color': '.15',<br/> 'xtick.color': '.15',<br/> 'xtick.direction': u'out',<br/> 'xtick.major.size': 0.0,<br/> 'xtick.minor.size': 0.0,<br/> 'ytick.color': '.15',<br/> 'ytick.direction': u'out',<br/> 'ytick.major.size': 0.0,<br/> 'ytick.minor.size': 0.0}<br/> """<br/><br/># Increase the font scale to 2, change the grid color to light grey, <br/># and axes label color to dark blue<br/>sns.set(context="notebook", <br/> style="darkgrid",<br/> font_scale=2, <br/> rc={'grid.color': '0.6', <br/> 'axes.labelcolor':'darkblue',<br/> "lines.linewidth": 2.5})<br/><br/># Plot the histogram<br/>ax = sns.distplot(current_bigmac.dollar_price)<br/>plt.show()</pre>
<p>The code generates the following histogram:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/6c428fb8-6c10-4ca1-85ad-44a045e0e4de.png" style="width:20.00em;height:14.58em;"/></div>
<p>So far, only functions that control global aesthetics were introduced. What if we want to change the style of a specific plot only?</p>
<p>Luckily, most Seaborn plotting functions come with specific parameters for the customization of styles. This also means that there isn't a universal styling tutorial for all Seaborn plotting functions. However, we can take a closer look at this <kbd>seaborn.distplot()</kbd> code excerpt to get an idea:</p>
<pre class="mce-root"># Note: Codes related to data preparation and imports are skipped for<br/># brevity<br/># Reset the style<br/>sns.set(context="notebook", style="darkgrid")<br/><br/># Plot the histogram with custom style<br/>ax = sns.distplot(current_bigmac.dollar_price,<br/>                 kde_kws={"color": "g", <br/>                          "linewidth": 3, <br/>                          "label": "KDE"},<br/>                 hist_kws={"histtype": "step", <br/>                           "alpha": 1, <br/>                           "color": "k",<br/>                           "label": "histogram"})<br/><br/>plt.show()</pre>
<p>The expected result:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e36290b7-95b4-4879-b185-053078956c6b.png" style="width:35.75em;height:25.25em;"/></div>
<p>Some Seaborn functions support a more direct approach of customizing aesthetics. For example, <kbd>seaborn.barplot</kbd> can pass through keyword arguments such as <kbd>facecolor</kbd>, <kbd>edgecolor</kbd>, <kbd>ecolor</kbd>, and <kbd>linewidth</kbd> to the underlying <kbd>matplotlib.pyplot.bar</kbd> function:</p>
<pre class="mce-root"># Note: Codes related to data preparation and imports are skipped<br/># for brevity<br/># Population Bar chart <br/>sns.barplot(x="AgeGrp",y="Value", hue="Sex",<br/>            linewidth=2, edgecolor="w",<br/>            data = current_population)<br/><br/># Use Matplotlib functions to label axes rotate tick labels<br/>ax = plt.gca()<br/>ax.set(xlabel="Age Group", ylabel="Population (thousands)")<br/>ax.set_xticklabels(ax.xaxis.get_majorticklabels(), rotation=45)<br/>plt.title("Population Barchart (USA)")<br/><br/># Show the figure<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/a19813ac-e20d-45de-8a2e-9c1cb51b255b.png" style="width:40.42em;height:28.83em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More about colors</h1>
                </header>
            
            <article>
                
<p class="mce-root">Color is perhaps the most important aspect of figure style, and thus it deserves its own subsection. There are many great resources that discuss the principles of choosing colors in visualizations (for example, <a href="https://betterfigures.org/2015/06/23/picking-a-colour-scale-for-scientific-graphics/">https://betterfigures.org/2015/06/23/picking-a-colour-scale-for-scientific-graphics/</a> and <a href="https://earthobservatory.nasa.gov/blogs/elegantfigures/2013/08/05/subtleties-of-color-part-1-of-6/">https://earthobservatory.nasa.gov/blogs/elegantfigures/2013/08/05/subtleties-of-color-part-1-of-6/</a>). The official Matplotlib documentation also contains a good overview of color maps (<a href="http://matplotlib.org/users/colormaps.html">http://matplotlib.org/users/colormaps.html</a>).</p>
<p class="mce-root">Effective use of color adds sufficient contrast to make something stand out and draw your audience's attention. Colors can also evoke emotions; for example, red is often associated with important or passionate, while green is often associated with natural or stable. If you are trying to deliver a story from your plots, do try to use an appropriate color scheme. It's estimated that 8% of men and 0.5% of women suffer from red-green color blindness, so we need to pick colors with these individuals in mind as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Color scheme and color palettes</h1>
                </header>
            
            <article>
                
<p class="mce-root">There are three general kinds of color palettes available in seaborn--qualitative, diverging, and sequential:</p>
<ul>
<li class="mce-root">Qualitative palettes are best for data with discrete levels or nominal or categorical data. Custom qualitative palettes can be created by providing a list of Matplotlib colors to <kbd>seaborn.color_palette</kbd>.</li>
<li class="mce-root">Diverging palettes are used for highlighting low and high values in a figure, with a neutrally colored midpoint. Custom diverging palettes can be created by passing two hue values plus the optional lightness and saturation values for the extremes to the <kbd>seaborn.diverging_palette</kbd> function.</li>
<li class="mce-root">Sequential palettes are usually used for quantitative data that progresses continuously from low to high.<br/>
Custom sequential palettes can be created by providing a single Matplotlib color to <kbd>seaborn.light_palette</kbd> or <kbd>seaborn.dark_palette</kbd>, which produces a palette that changes gradually from light or dark desaturated values to the seed color.</li>
</ul>
<p class="mce-root">In the next example, we are going to plot the most commonly used qualitative, diverging, and sequential palettes, as well as a few custom palettes:</p>
<pre class="mce-root">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from matplotlib.colors import ListedColormap<br/><br/><br/>def palplot(pal, ax):<br/>    """Plot the values in a color palette as a horizontal array.<br/>    Adapted from seaborn.palplot<br/>    <br/>    Args:<br/>        p : seaborn color palette<br/>        ax : axes to plot the color palette<br/>    """<br/>    n = len(pal) <br/>    ax.imshow(np.arange(n).reshape(1, n),<br/>              cmap=ListedColormap(list(pal)),<br/>              interpolation="nearest", aspect="auto")<br/>    ax.set_xticks(np.arange(n) - .5)<br/>    ax.set_yticks([-.5, .5])<br/>    ax.set_xticklabels([])<br/>    ax.set_yticklabels([])<br/>    <br/>    <br/>palettes = {"qualitative": ["deep", "pastel", "bright", "dark", <br/>                            "colorblind", "Accent", "Paired", <br/>                            "Set1", "Set2", "Set3", "Pastel1", <br/>                            "Pastel2", "Dark2"],<br/>            "diverging": ["BrBG", "PiYG", "PRGn", "PuOr", "RdBu", <br/>                          "RdBu_r", "RdGy", "RdGy_r", "RdYlGn", <br/>                          "coolwarm"],<br/>            "sequential": ["husl", "Greys", "Blues", "BuGn_r", <br/>                           "GnBu_d", "plasma", "viridis","cubehelix"]}<br/><br/>#Reset to default Seaborn style<br/>sns.set()<br/><br/># Create one subplot per palette, the x-axis is shared<br/>fig, axarr = plt.subplots(13, 3, sharex=True, figsize=(12,11))<br/><br/># Plot 9 color blocks for each palette<br/>for i, palette_type in enumerate(palettes.keys()):<br/>    for j, palette in enumerate(palettes[palette_type]):<br/>        pal = sns.color_palette(palettes[palette_type][j], 9)<br/>        palplot(pal, axarr[j,i])<br/>        axarr[j,i].set_xlabel(palettes[palette_type][j])<br/> <br/># Plot a few more custom diverging palette<br/>custom_diverging_palette = [<br/> sns.diverging_palette(220, 20, n=9),<br/> sns.diverging_palette(10, 220, sep=80, n=9),<br/> sns.diverging_palette(145, 280, s=85, l=25, n=9)<br/>]<br/><br/>for i, palette in enumerate(custom_diverging_palette):<br/>    palplot(palette, axarr[len(palettes["diverging"])+i,1])<br/>    axarr[len(palettes["diverging"])+i,1].set_xlabel("custom diverging <br/>    {}".format(i+1))<br/><br/># Plot a few more custom sequential palette<br/>other_custom_palette = [<br/> sns.light_palette("green", 9),<br/> sns.light_palette("green", 9, reverse=True),<br/> sns.dark_palette("navy", 9),<br/> sns.dark_palette("navy", 9, reverse=True),<br/> sns.color_palette(["#49a17a","#4aae82","#4eb98a","#55c091","#c99b5f",<br/> "#cbb761","#c5cc62","#accd64","#94ce65"])<br/>]<br/><br/>for i, palette in enumerate(other_custom_palette):<br/>    palplot(palette, axarr[len(palettes["sequential"])+i,2])<br/>    axarr[len(palettes["sequential"])+i,2].set_xlabel("custom sequential<br/>    {}".format(i+1))<br/><br/># Reduce unnecessary margin space<br/>plt.tight_layout()<br/><br/># Show the plot<br/>plt.show()</pre>
<p>The expected output is as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/350e9195-9024-4abe-968d-8132a67660b8.png"/></div>
<p class="mce-root">To change the color scheme of a Seaborn plot, we can use either the <kbd>color</kbd> or <kbd>palette</kbd> parameter available in most Seaborn functions. The <kbd>color</kbd> parameter supports a single color that will be applied to all of the elements. On the other hand, <kbd>palette</kbd> supports a range of colors to differentiate levels of the <kbd>hue</kbd> variable.</p>
<p class="mce-root">Some Seaborn functions support the <kbd>color</kbd> parameter only (for example, dist plot), while others can support both <kbd>color</kbd> and <kbd>palette</kbd> (for example, bar plot and box plot). Readers can refer to the official documentation to see which parameter is supported.</p>
<p>The following three code excerpts demonstrate the use of the <kbd>color</kbd> or <kbd>palette</kbd> parameter in a dist plot, bar plot, and box plot:</p>
<pre># Note: Codes related to data preparation and imports are skipped<br/># for brevity<br/># Change the color of histogram and KDE line to darkred<br/>ax = sns.distplot(current_bigmac.dollar_price, color="darkred")<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/5e4191a4-96db-4e82-8f8f-c743638be797.png" style="width:43.08em;height:30.17em;"/></div>
<pre>current_population = population_df[(population_df.Location == 'United States of America') &amp; <br/>                                   (population_df.Time == 2017) &amp;<br/>                                   (population_df.Sex != 'Both')]<br/># Change the color palette of the bar chart to Paired <br/>sns.barplot(x="AgeGrp",y="Value", hue="Sex", palette="Paired", data = current_population)<br/># Rotate tick labels by 30 degree<br/>plt.setp(plt.gca().get_xticklabels(), rotation=30, horizontalalignment='right') <br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/a40ff9dd-aa78-4012-b2f2-85475fb98618.png" style="width:43.17em;height:30.00em;"/></div>
<pre># Note: Codes related to data preparation and imports are skipped<br/># for brevity<br/># Change the color palette of the bar chart to Set2 from color<br/># brewer library<br/>ax = sns.boxplot(x="population type", y="dollar_price", palette="Set2", data=merged_df2)<br/>plt.show()</pre>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" src="assets/f80e3932-a7f3-4cf6-866e-41f6d36ddd76.png" style="width:44.58em;height:31.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>You just learned how we can parse online data in CSV or JSON formats using the versatile Pandas package. You further learned how to filter, subset, merge, and process data into insights. You have now equipped yourself with the knowledge to visualize time series, univariate, bivariate, and categorical data. The chapter concluded with a number of useful techniques to customize figure aesthetics for effective storytelling.</p>
<p>Phew! We have just completed a long chapter, so go grab a burger, have a break, and relax.</p>


            </article>

            
        </section>
    </body></html>