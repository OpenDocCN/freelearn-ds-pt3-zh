<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer155">
    <h1 class="chapterNumber">11</h1>
    <h1 class="chapterTitle" id="_idParaDest-119">The Data Project – Prototyping Projects in Streamlit</h1>
    <p class="normal">In the previous chapter, we discussed how to create Streamlit applications that are specific to job applications. Another fun application of Streamlit is to try out new and interesting data science ideas and create interactive apps for others. Some examples of this include applying a new machine learning model to an existing dataset, carrying out an analysis of some data uploaded by users, or creating an interactive analysis on a private dataset. There are numerous reasons for making a project like this, such as personal education or community contribution.</p>
    <p class="normal">In terms of personal education, often, the best way to learn about a new topic is to observe how it actually works by applying it to the world around you or a dataset that you know closely. For instance, if you try to learn how <strong class="keyWord">Principal Component Analysis</strong> works, you can always learn about it in a textbook or watch someone else apply it to a dataset. However, I have found that my comprehension of a topic goes through the roof when I actually apply it myself in practice. Streamlit is perfect for this. It allows you to give new ideas a shot in a responsive, fun environment that can be easily shared with others. Learning data science can be collaborative, which leads me to the next reason for creating data projects in Streamlit.</p>
    <p class="normal">In terms of community contribution, one of the best parts of Streamlit – and, frankly, data science – is the growing community around the tools and toys we routinely play with. By learning with others and sharing Streamlit apps on Twitter (<a href="https://twitter.com/tylerjrichards"><span class="url">https://twitter.com/tylerjrichards</span></a>), LinkedIn, and the Streamlit forums (<a href="https://discuss.streamlit.io/"><span class="url">https://discuss.streamlit.io/</span></a>), we can turn away from the zero-sum experience that is taught in most schools and universities (where if your classmate gets a good grade, that usually comparatively hurts you) and toward a positive-sum experience (where you directly benefit from the lessons learned by others). </p>
    <p class="normal">To use the previous example, if you created an app that helped you understand the statistics behind principal component analysis, sharing that with others will probably teach them something too.</p>
    <p class="normal">In this chapter, we will run through one thorough data project from end to end, starting with an idea and ending with the final product. Specifically, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Data science ideation</li>
      <li class="bulletList">Collecting and cleaning data</li>
      <li class="bulletList">Making a <strong class="keyWord">Minimum Viable Product</strong> (<strong class="keyWord">MVP</strong>)</li>
      <li class="bulletList">Iterative improvement</li>
      <li class="bulletList">Hosting and promotion</li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-120">Technical requirements</h1>
    <p class="normal">In this section, we will utilize the website <em class="italic">Goodreads.com</em>, which is a popular website owned by Amazon that is used to track everything about a user’s reading habits, from when they started and finished books to what they would like to read next. It is recommended that you first head over to <a href="https://www.goodreads.com/"><span class="url">https://www.goodreads.com/</span></a>, sign up for an account, and explore a little (perhaps you can even add your own book lists!).</p>
    <h1 class="heading-1" id="_idParaDest-121">Data science ideation</h1>
    <p class="normal">Often, coming up with a new<a id="_idIndexMarker405"/> idea for a data science project is the most daunting part. You might have numerous doubts. What if I start a project that no one likes? What if my data actually doesn’t work out well? What if I can’t think of anything? The good news is that if you create projects that you actually do care about and would use, then the worst-case scenario is that you have an audience of one! And if you send me (<code class="inlineCode">tylerjrichards@gmail.com</code>) your project, I promise to read it. So that makes it an audience of two at the very least.</p>
    <p class="normal">Some examples I have either created or observed in the wild include the following:</p>
    <ul>
      <li class="bulletList">Recording ping-pong games for a semester to determine the best player with an Elo model (<a href="http://www.tylerjrichards.com/Ping_pong.html"><span class="url">http://www.tylerjrichards.com/Ping_pong.html</span></a> or <a href="https://www.youtube.com/watch?v=uPg7PEdx7WA"><span class="url">https://www.youtube.com/watch?v=uPg7PEdx7WA</span></a>)</li>
      <li class="bulletList">Using Large Language Models to chat with your organization’s Snowflake data (<a href="https://snowchat.streamlit.app/"><span class="url">https://snowchat.streamlit.app/</span></a>)</li>
      <li class="bulletList">Analyzing thousands of pizza reviews to find the best NYC pizza near you (<a href="https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1"><span class="url">https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1</span></a>)</li>
      <li class="bulletList">Analyzing your reading habits with Goodreads data (<a href="https://goodreads.streamlit.app/"><span class="url">https://goodreads.streamlit.app/</span></a>)</li>
      <li class="bulletList">Using your Spotify data to dig into your listening history (<a href="https://spotify-history.streamlit.app/"><span class="url">https://spotify-history.streamlit.app/</span></a>)</li>
    </ul>
    <p class="normal">While only two of <a id="_idIndexMarker406"/>these data projects use Streamlit, as the rest came out before the library was released, all of these could have been improved by deploying them on Streamlit rather than just uploading them to a Jupyter notebook (the first project in the list) or a Word document/HTML file (<em class="italic">the second and third projects</em>).</p>
    <p class="normal">There are many different methods that you can use to come up with your own idea for a data project, but the most popular methods generally fall into three categories:</p>
    <ul>
      <li class="bulletList">Finding data that only you could gather (for example, your friend’s ping-pong games)</li>
      <li class="bulletList">Finding data that you care about (for example, Spotify’s reading data)</li>
      <li class="bulletList">Thinking of an analysis/app you wish existed to solve a problem you have and executing it (for example, hostel Wi-Fi analysis or finding the best pizza near you in NYC)</li>
    </ul>
    <p class="normal">You can try one of these or start with another idea that you have already. The best method is the one that works best for you! For this chapter, we will walk through and recreate the <a id="_idIndexMarker407"/>Goodreads Streamlit app, in depth, as an example of a data project. You can access it again at <a href="https://goodreads.streamlit.app/"><span class="url">https://goodreads.streamlit.app/</span></a>.</p>
    <p class="normal">This app is designed to scrape a user’s Goodreads history and create a set of graphs to inform them about their reading habits since they started using Goodreads. The sets of graphs should be similar to the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_01.png"/></figure>
    <p class="packt_figref">Figure 11.1: Examples of Goodreads graphs</p>
    <p class="normal">I came up with this idea by doing a personal analysis of my book history, and then I thought to myself that others might also be interested in this analysis! I came away from this project knowing that I wanted to read older books (or books that have a longer “book age”). There really was no better reason than that, and often, the most fun projects start out that way. To begin, we will work on collecting and cleaning the user data that exists on Goodreads.</p>
    <h1 class="heading-1" id="_idParaDest-122">Collecting and cleaning data</h1>
    <p class="normal">There are two <a id="_idIndexMarker408"/>ways in which to get data from Goodreads: through<a id="_idIndexMarker409"/> its <strong class="keyWord">Application Programming Interface</strong> (<strong class="keyWord">API</strong>), which <a id="_idIndexMarker410"/>allows developers to programmatically access data about books, and through its manual exporting function. Sadly, Goodreads is deprecating its API in the near future and, as of December 2020, does not give access to new developers.</p>
    <p class="normal">The original Goodreads app uses the API, but our version will rely on the manual exporting function that the Goodreads website has instead. To get your data, head over to <a href="https://www.goodreads.com/review/import"><span class="url">https://www.goodreads.com/review/import</span></a> and download your own data. If you do not have a Goodreads account, feel free to use my personal data for this, which can be found at <a href="https://github.com/tylerjrichards/goodreads_book_demo"><span class="url">https://github.com/tylerjrichards/goodreads_book_demo</span></a>. I have saved my Goodreads data in a file, called <code class="inlineCode">goodreads_history.csv</code>, in a new folder, called <code class="inlineCode">streamlit_goodreads_book</code>. To make your own folder with the appropriate setup, run the following in your terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir streamlit_goodreads_book
cd streamlit_goodreads_book
touch goodreads_app.py
</code></pre>
    <p class="normal">Now we <a id="_idIndexMarker411"/>are ready to get started. We really have no idea <a id="_idIndexMarker412"/>what this data looks like or what is in this dataset, so our first steps are to do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Put titles and an explanation at the top of our app.</li>
      <li class="numberedList">Allow the user to upload their own data, or use ours as the default if they have no data of their own.</li>
      <li class="numberedList">Write the first few rows of data to the app so that we can take a look at it.</li>
    </ol>
    <p class="normal">The following code block does all of this. Feel free to change the text so that your app has your name, and also add links to your profile that people can view! At the time of writing, around 10 percent of the traffic to my personal website comes from the Streamlit apps I have produced:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
st.title(<span class="hljs-string">'Analyzing Your Goodreads Reading Habits'</span>)
st.subheader(<span class="hljs-string">'A Web App by [Tyler Richards](http://www.tylerjrichards.com)'</span>)
<span class="hljs-string">"""</span>
<span class="hljs-string">Hey there! Welcome to Tyler's Goodreads Analysis App. This app analyzes (and never stores!)</span>
<span class="hljs-string">the books you've read using the popular service Goodreads, including looking at the distribution</span>
<span class="hljs-string">of the age and length of books you've read. Give it a go by uploading your data below!</span>
<span class="hljs-string">"""</span>
goodreads_file = st.file_uploader(<span class="hljs-string">'Please Import Your Goodreads Data'</span>)
<span class="hljs-keyword">if</span> goodreads_file <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
     books_df = pd.read_csv(<span class="hljs-string">'goodreads_history.csv'</span>)
     st.write(<span class="hljs-string">"Analyzing Tyler's Goodreads history"</span>)
<span class="hljs-keyword">else</span>:
     books_df = pd.read_csv(goodreads_file)
     st.write(<span class="hljs-string">'Analyzing your Goodreads history'</span>)
st.write(books_df.head())
</code></pre>
    <p class="normal">Now, when we run this Streamlit app, we should get an app that looks similar to the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_02.png"/></figure>
    <p class="packt_figref">Figure 11.2: The first five rows</p>
    <p class="normal">As you can see, we<a id="_idIndexMarker413"/> get a dataset where each book is a unique<a id="_idIndexMarker414"/> row. Additionally, we get a ton of data about each book, including the title and author, the average rating of the book, your rating of the book, the number of pages, and even if you have read the book, are planning to read the book, or are in the middle of reading the book. The data looks mostly clean but with some weirdness – for instance, the data having both a publication year and an original<a id="_idIndexMarker415"/> publication year, and the fact that the <strong class="keyWord">ISBN</strong> (<strong class="keyWord">International Standard Book Number</strong>) comes in the format of <em class="italic">=”1400067820”</em>, which is just odd. Now that we know more about the data at hand, we can switch to trying to build some interesting graphs for users.</p>
    <h1 class="heading-1" id="_idParaDest-123">Making an MVP</h1>
    <p class="normal">Looking at <a id="_idIndexMarker416"/>our data, we can start by asking a basic question: what are the most interesting questions I can answer with this data? After looking at the data and thinking about what information I would want from my Goodreads reading history, here are a few questions that I have thought of:</p>
    <ul>
      <li class="bulletList">How many books do I read each year?</li>
      <li class="bulletList">How long does it take for me to finish a book that I have started?</li>
      <li class="bulletList">How long are the books that I have read?</li>
      <li class="bulletList">How old are the books that I have read? </li>
      <li class="bulletList">How do I rate books compared to other Goodreads users?</li>
    </ul>
    <p class="normal">We can take these questions, figure out how to modify our data to visualize them well, and then make the first attempt at creating our product by printing out all of the graphs.</p>
    <h2 class="heading-2" id="_idParaDest-124">How many books do I read each year?</h2>
    <p class="normal">For the<a id="_idIndexMarker417"/> first question about books read per year, we have the <strong class="keyWord">Date Read</strong> column with the data presented in the format of <em class="italic">yyyy/mm/dd</em>. The following code block will do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Convert our column into the datetime format.</li>
      <li class="numberedList">Extract the year from the <strong class="keyWord">Date Read</strong> column.</li>
      <li class="numberedList">Group the books by this column and make a count of books per year.</li>
      <li class="numberedList">Graph this using Plotly.</li>
    </ol>
    <p class="normal">The following code block does this, starting with the datetime conversion. It is important to note here that, as with all things, I didn’t get this right on the very first try. In fact, it took me some time to figure out exactly how I needed to manage and convert this data. When you create projects of your own, do not feel bad if you find that data cleaning and converting takes a long time! Very often, it is the hardest step:</p>
    <pre class="programlisting code"><code class="hljs-code">     goodreads_file = st.file_uploader(<span class="hljs-string">'Please Import Your Goodreads Data'</span>)
<span class="hljs-keyword">if</span> goodreads_file <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
     books_df = pd.read_csv(<span class="hljs-string">'goodreads_history.csv'</span>)
     st.write(<span class="hljs-string">"Analyzing Tyler's Goodreads history"</span>)
<span class="hljs-keyword">else</span>:
     books_df = pd.read_csv(goodreads_file)
     st.write(<span class="hljs-string">'</span><span class="hljs-string">Analyzing your Goodreads history'</span>)
books_df[<span class="hljs-string">'Year Finished'</span>] = pd.to_datetime(books_df[<span class="hljs-string">'Date Read'</span>]).dt.year
books_per_year = books_df.groupby(<span class="hljs-string">'Year Finished'</span>)[<span class="hljs-string">'Book Id'</span>].count().reset_index()
books_per_year.columns = [<span class="hljs-string">'Year Finished'</span>, <span class="hljs-string">'Count'</span>]
fig_year_finished = px.bar(books_per_year, x=<span class="hljs-string">'Year Finished'</span>, y=<span class="hljs-string">'Count'</span>, title=<span class="hljs-string">'Books Finished per Year'</span>)
st.plotly_chart(fig_year_finished)
</code></pre>
    <p class="normal">The preceding code block will create the following graph:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_03.png"/></figure>
    <p class="packt_figref">Figure 11.3: Year Finished bar plot</p>
    <p class="normal">We actually <a id="_idIndexMarker418"/>made an assumption here – that is, we assumed the year in the <strong class="keyWord">Date Read</strong> column represents when we read the book. But what if we start a book in the middle of December and finish it on January 2? Or, what if we start a book in 2019 but only get a few pages into it, and then pick it back up during 2021? We know this will not be a perfect approximation of the number of books read per year, but it will be better to express this as the number of books finished per year.</p>
    <h2 class="heading-2" id="_idParaDest-125">How long does it take for me to finish a book that I have started?</h2>
    <p class="normal">Our next question is about the time it takes for us to finish a book once we have started it. To answer this, we need to find the difference between two columns: the <strong class="keyWord">Date Read</strong> column and the <strong class="keyWord">Date Added</strong> column. Again, this is going to be an approximation, as we do not have the date of when the user started reading the book but only when they added the book to Goodreads. Given this, our next steps include the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Convert the two columns into the datetime format.</li>
      <li class="numberedList">Find the difference between the two columns in days.</li>
      <li class="numberedList">Plot this difference as a histogram.</li>
    </ol>
    <p class="normal">The following code block starts with the conversion, as we have done previously, and then moves through our list of tasks:</p>
    <pre class="programlisting code"><code class="hljs-code">books_df[<span class="hljs-string">'days_to_finish'</span>] = (pd.to_datetime(
            books_df[<span class="hljs-string">'Date Read'</span>]) - pd.to_datetime(books_df[<span class="hljs-string">'Date Added'</span>])).dt.days
fig_days_finished = px.histogram(books_df, x=<span class="hljs-string">'days_to_finish'</span>)
st.plotly_chart(fig_days_finished)
</code></pre>
    <p class="normal">The previous <a id="_idIndexMarker419"/>code block can be added to the bottom of your current Streamlit app, which, when run, should show a new graph:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_04.png"/></figure>
    <p class="packt_figref">Figure 11.4: The days to finish graph</p>
    <p class="normal">This is not the most helpful graph for my data. It looks as though, at some point, I added books that I had read in the past to Goodreads, which show up in this chart. We also have a set of books that have not been finished yet or are on the to-read bookshelf, which exist as <code class="inlineCode">null</code> values in this dataset. We can do a few things here, such as filtering the dataset to just include books where the number of days is positive and filtering the data to only finished books, which the following code block does:</p>
    <pre class="programlisting code"><code class="hljs-code">books_df[<span class="hljs-string">'days_to_finish'</span>] = (pd.to_datetime(
            books_df[<span class="hljs-string">'Date Read'</span>]) - pd.to_datetime(books_df[<span class="hljs-string">'Date Added'</span>])).dt.days
books_finished_filtered = books_df[(books_df[<span class="hljs-string">'</span><span class="hljs-string">Exclusive Shelf'</span>] == <span class="hljs-string">'read'</span>) &amp; (books_df[<span class="hljs-string">'days_to_finish'</span>] &gt;= <span class="hljs-number">0</span>)]
fig_days_finished = px.histogram(books_finished_filtered,
x=<span class="hljs-string">'days_to_finish'</span>, title=<span class="hljs-string">'Time Between Date Added And Date Finished'</span>,
     labels={<span class="hljs-string">'days_to_finish'</span>:<span class="hljs-string">'days'</span>})
st.plotly_chart(fig_days_finished)
</code></pre>
    <p class="normal">This change in<a id="_idIndexMarker420"/> our code makes the graph significantly better. It makes some assumptions, but it also provides a more accurate analysis. The finished graph can be viewed in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_05.png"/></figure>
    <p class="packt_figref">Figure 11.5: The improved days to finish graph</p>
    <p class="normal">This looks much better! Now, let’s move on to the next question.</p>
    <h2 class="heading-2" id="_idParaDest-126">How long are the books that I have read?</h2>
    <p class="normal">The data for this question is already in a fairly good state. We have a single column called <strong class="keyWord">Number of Pages</strong>, which, you guessed it, has the number of pages in each book. We just need to pass that column to another histogram, and we will be good to go:</p>
    <pre class="programlisting code"><code class="hljs-code">fig_num_pages = px.histogram(books_df, x=<span class="hljs-string">'Number of Pages'</span>, title=<span class="hljs-string">'Book Length Histogram'</span>)
st.plotly_chart(fig_num_pages)
</code></pre>
    <p class="normal">This code will <a id="_idIndexMarker421"/>produce something similar to the following screenshot, showing a histogram of book length as measured in pages:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_06.png"/></figure>
    <p class="packt_figref">Figure 11.6: The Number of Pages histogram</p>
    <p class="normal">This makes sense to me; a ton of books are in the 300–400 page range, with a few giant books that have 1,000+ pages. Now, let’s move on to the age of these books!</p>
    <h2 class="heading-2" id="_idParaDest-127">How old are the books that I have read? </h2>
    <p class="normal">Our next graph should be straightforward. How do we figure out how old the books that we read are? Are our tendencies to go for the newest set of books that are published or to shoot toward reading classics? There are two columns that we can get this information from, the publication year and the original publication year. There is very little documentation on this dataset, but I think we can safely assume that the original publication year is what we are looking for, and the publication year shows when a publisher republishes a book. </p>
    <p class="normal">The following code block checks this assumption by printing out all the books where the original publication year is later than the publication year:</p>
    <pre class="programlisting code"><code class="hljs-code">st.write(<span class="hljs-string">'</span><span class="hljs-string">Assumption check'</span>)
st.write(<span class="hljs-built_in">len</span>(books_df[books_df[<span class="hljs-string">'Original Publication Year'</span>] &gt; books_df[<span class="hljs-string">'Year Published'</span>]]))
</code></pre>
    <p class="normal">When we run this, the app should return zero books with the original publication year greater than the year published. Now that we have checked this assumption, we can do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Group the books by the original publication year.</li>
      <li class="numberedList">Plot this on a bar chart.</li>
    </ol>
    <p class="normal">The following code block takes two steps:</p>
    <pre class="programlisting code"><code class="hljs-code">books_publication_year = books_df.groupby(<span class="hljs-string">'Original Publication Year'</span>)[<span class="hljs-string">'Book Id'</span>].count().reset_index()
books_publication_year.columns = [<span class="hljs-string">'Year Published'</span>, <span class="hljs-string">'Count'</span>]
fig_year_published = px.bar(books_publication_year, x=<span class="hljs-string">'</span><span class="hljs-string">Year Published'</span>, y=<span class="hljs-string">'Count'</span>, title=<span class="hljs-string">'Book Age Plot'</span>)
st.plotly_chart(fig_year_published)
</code></pre>
    <p class="normal">When we run this<a id="_idIndexMarker422"/> app, we should get the following graph:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_07.png"/></figure>
    <p class="packt_figref">Figure 11.7: Book Age Plot</p>
    <p class="normal">At first glance, this graph does not appear to be incredibly useful, as there are quite a few books written so far back in history (for example, Plato’s writings in -375 BCE) that the entire graph is hard to read. However, Plotly is interactive by default, and it allows us to zoom into sections of history that we care about more than others. For example, the following<a id="_idIndexMarker423"/> screenshot shows us what happens when we zoom into the period of 1850 to the present, which most of the books that I’ve read happen to be in:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_08.png"/></figure>
    <p class="packt_figref">Figure 11.8: Zooming in on Year Published</p>
    <p class="normal">This is a much better graph! There are a couple of options going forward. We can start with the graph that is not as useful and tell users to zoom in, we can filter our dataset for only younger books (which would defeat the main purpose of the graph), or we can set a default zoom state for the graph and also alert users at the bottom that they can zoom in as they’d like. I think the third option is the best one. The following code implements this option:</p>
    <pre class="programlisting code"><code class="hljs-code">Books_publication_year = books_df.groupby(<span class="hljs-string">'Original Publication Year'</span>)[<span class="hljs-string">'Book Id'</span>].count().reset_index()
books_publication_year.columns = [<span class="hljs-string">'Year Published'</span>, <span class="hljs-string">'Count'</span>]
st.write(books_df.sort_values(by=<span class="hljs-string">'Original Publication Year'</span>).head())
fig_year_published = px.bar(books_publication_year, x=<span class="hljs-string">'Year Published'</span>, y=<span class="hljs-string">'Count'</span>, title=<span class="hljs-string">'Book Age Plot'</span>)
fig_year_published.update_xaxes(<span class="hljs-built_in">range</span>=[<span class="hljs-number">1850</span>, <span class="hljs-number">2021</span>])
st.plotly_chart(fig_year_published)
st.write(<span class="hljs-string">'This chart is zoomed into the period of 1850-2021, but is interactive so try zooming in/out on interesting periods!'</span>)
</code></pre>
    <p class="normal">When we run this code, we should get our final plot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_09.png"/></figure>
    <p class="packt_figref">Figure 11.9: A default zoom with helpful text</p>
    <p class="normal">Four questions down – we have one to go!</p>
    <h2 class="heading-2" id="_idParaDest-128">How do I rate books compared to other Goodreads users?</h2>
    <p class="normal">For this final<a id="_idIndexMarker424"/> question, we really need two separate graphs. First, we need to plot how we have rated the books. Second, we need to plot how other users have rated the books that we also rated. This isn’t a perfect analysis because Goodreads just shows us the average rating of the books – we have not read the distribution. For example, if we had read <em class="italic">The Snowball</em>, a biography of Warren Buffett, and rated it 3 stars, and half of Goodreads’ readers rated it 1 star while the other half rated it 5 stars, we would have rated it exactly the same as the average rating, but we would not have rated it the same as any individual rater! However, we do what we can with the data we have. So, we can do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Filter the books according to the ones we have rated (and, therefore, read).</li>
      <li class="numberedList">Create a histogram of the average rating per book for our first graph.</li>
      <li class="numberedList">Create another histogram for your own ratings.</li>
    </ol>
    <p class="normal">This next code block does exactly that:</p>
    <pre class="programlisting code"><code class="hljs-code">books_rated = books_df[books_df[<span class="hljs-string">'</span><span class="hljs-string">My Rating'</span>] != <span class="hljs-number">0</span>]
fig_my_rating = px.histogram(books_rated, x=<span class="hljs-string">'My Rating'</span>, title=<span class="hljs-string">'User Rating'</span>)
st.plotly_chart(fig_my_rating)
fig_avg_rating = px.histogram(books_rated, x=<span class="hljs-string">'Average Rating'</span>, title=<span class="hljs-string">'Average Goodreads Rating'</span>)
st.plotly_chart(fig_avg_rating)
</code></pre>
    <p class="normal">As you can see in the following screenshot, the first graph with the user rating distribution looks great. It looks as though I mainly rate books either 4 or 5 stars, which are, overall, pretty lenient ratings:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_10.png"/></figure>
    <p class="packt_figref">Figure 11.10: The User Rating distribution</p>
    <p class="normal">When we also look at the <a id="_idIndexMarker425"/>second graph, we see a fairly clean distribution. However, we run into the problem that we have addressed before – all the rating averages are more tightly bundled than the user ratings:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_11.png"/></figure>
    <p class="packt_figref">Figure 11.11: Average Goodreads Ratings</p>
    <p class="normal">We can always<a id="_idIndexMarker426"/> set the <em class="italic">x</em>-axis range to 1–5 for both graphs, but this will not help our actual problem. Instead, we can leave both of the graphs but also calculate whether, on average, we rate books higher or lower than the Goodreads average. The following code block will calculate this and add it underneath the average Goodreads rating graph:</p>
    <pre class="programlisting code"><code class="hljs-code">Fig_avg_rating = px.histogram(books_rated, x=<span class="hljs-string">'Average Rating'</span>, title=<span class="hljs-string">'Average Goodreads Rating'</span>)
st.plotly_chart(fig_avg_rating)
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
avg_difference = np.<span class="hljs-built_in">round</span>(np.mean(books_rated[<span class="hljs-string">'My Rating'</span>] – books_rated[<span class="hljs-string">'Average Rating'</span>]), <span class="hljs-number">2</span>)
<span class="hljs-keyword">if</span> avg_difference &gt;= <span class="hljs-number">0</span>:
     sign = <span class="hljs-string">'higher'</span>
<span class="hljs-keyword">else</span>:
     sign = <span class="hljs-string">'lower'</span>
st.write(<span class="hljs-string">f"You rate books </span><span class="hljs-subst">{sign}</span><span class="hljs-string"> than the average Goodreads user by </span><span class="hljs-subst">{</span><span class="hljs-built_in">abs</span><span class="hljs-subst">(avg_difference)}</span><span class="hljs-string">!"</span>)
</code></pre>
    <p class="normal">This <a id="_idIndexMarker427"/>code block makes our average and creates a dynamic string that will say that the Goodreads user rates books either higher or lower than the average Goodreads user. The result for my data is as follows:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_12.png"/></figure>
    <p class="packt_figref">Figure 11.12: Adding an average difference</p>
    <p class="normal">This is better and completes our MVP. Our app is in a decent state, and the difficult manipulation and visualization steps are pretty much complete. However, our app certainly doesn’t look great and is just a bunch of graphs that appear in a row. This might be <a id="_idIndexMarker428"/>good for an MVP, but we need to add some styling to really improve our state. That leads us to our next section: iterating on this idea to make it even better.</p>
    <h1 class="heading-1" id="_idParaDest-129">Iterative improvement</h1>
    <p class="normal">So far, we <a id="_idIndexMarker429"/>have been almost purely in production mode with this app. Iterative improvement is all about editing the work we have already done and organizing it in a way that makes the app more usable and, frankly, nicer to look at. There are a few improvements that we can shoot for here:</p>
    <ul>
      <li class="bulletList">Beautification via animation</li>
      <li class="bulletList">Organization using columns and width</li>
      <li class="bulletList">Narrative building through text and additional statistics</li>
    </ul>
    <p class="normal">Let’s start by <a id="_idIndexMarker430"/>using animations to make our apps a bit prettier!</p>
    <h2 class="heading-2" id="_idParaDest-130">Beautification via animation</h2>
    <p class="normal">In <em class="chapterRef">Chapter 7</em>, <em class="italic">Exploring Streamlit Components</em>, we explored the use of various Streamlit Components; one of these was a component called <code class="inlineCode">streamlit-lottie</code>, which gives us the ability to add animation to our Streamlit applications. We can improve our current app by adding an<a id="_idIndexMarker431"/> animation to the top of our current Streamlit app using the following code. If you want to learn more about Streamlit Components, please head back over to <em class="chapterRef">Chapter 7</em>, <em class="italic">Exploring Streamlit Components</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> streamlit_lottie <span class="hljs-keyword">import</span> st_lottie
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">def</span> <span class="hljs-title">load_lottieurl</span>(<span class="hljs-params">url: </span><span class="hljs-built_in">str</span>):
    r = requests.get(url)
    <span class="hljs-keyword">if</span> r.status_code != <span class="hljs-number">200</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">return</span> r.json()
file_url = <span class="hljs-string">'https://assets4.lottiefiles.com/temp/lf20_aKAfIn.json'</span>
lottie_book = load_lottieurl(file_url)
st_lottie(lottie_book, speed=<span class="hljs-number">1</span>, height=<span class="hljs-number">200</span>, key=<span class="hljs-string">"initial"</span>)
</code></pre>
    <p class="normal">This Lottie file is an animation of a book flipping its pages, as shown in the following screenshot. These animations are always a nice touch for longer Streamlit apps:</p>
    <figure class="mediaobject"><img alt="Figure 12.13 – Goodreads animation " src="../Images/B18444_11_13.png"/></figure>
    <p class="packt_figref">Figure 11.13: Goodreads animation</p>
    <p class="normal">Now that <a id="_idIndexMarker432"/>we have added our animation, we can move on to how to organize our app a bit better.</p>
    <h2 class="heading-2" id="_idParaDest-131">Organization using columns and width</h2>
    <p class="normal">As we <a id="_idIndexMarker433"/>discussed earlier, our app does not look very good, with each graph appearing one after the other. Another improvement we can make is to allow our app to be in a wide, rather than narrow, format, and then put our apps side by side in each column.</p>
    <p class="normal">To begin, at the top of our app, we need the first Streamlit call to be the one that sets the configuration of our Streamlit app to wide rather than narrow, as shown in the following code block:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> requests
st.set_page_config(layout=<span class="hljs-string">"wide"</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title">load_lottieurl</span>(<span class="hljs-params">url: </span><span class="hljs-built_in">str</span>):
    r = requests.get(url)
    <span class="hljs-keyword">if</span> r.status_code != <span class="hljs-number">200</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">return</span> r.json()
</code></pre>
    <p class="normal">This will set our Streamlit app to the wide format. So far, in our app, we have called each graph a unique name (such as <code class="inlineCode">fig_year_finished</code>) to make this next step easier. We can now remove all of our <code class="inlineCode">st.plotly_chart()</code> calls and create a set of two columns and three rows, where we can place our six graphs. The following code creates each of these. We name each space first, and then fill them with one of our graphs:</p>
    <pre class="programlisting code"><code class="hljs-code">row1_col1, row1_col2 = st.columns(<span class="hljs-number">2</span>)
row2_col1, row2_col2 = st.columns(<span class="hljs-number">2</span>)
row3_col1, row3_col2 = st.columns(<span class="hljs-number">2</span>)
<span class="hljs-keyword">with</span> row1_col1:
     st.plotly_chart(fig_year_finished)
<span class="hljs-keyword">with</span> row1_col2:
     st.plotly_chart(fig_days_finished)
<span class="hljs-keyword">with</span> row2_col1:
     st.plotly_chart(fig_num_pages)
<span class="hljs-keyword">with</span> row2_col2:
     st.plotly_chart(fig_year_published)
     st.write(<span class="hljs-string">'This chart is zoomed into the period of 1850-2021, but is interactive so try zooming in/out on interesting periods!'</span>)
<span class="hljs-keyword">with</span> row3_col1:
     st.plotly_chart(fig_my_rating)
<span class="hljs-keyword">with</span> row3_col2:
     st.plotly_chart(fig_avg_rating)
     st.write(<span class="hljs-string">f"You rate books </span><span class="hljs-subst">{sign}</span><span class="hljs-string"> than the average Goodreads user by </span><span class="hljs-subst">{</span><span class="hljs-built_in">abs</span><span class="hljs-subst">(avg_difference)}</span><span class="hljs-string">!"</span>)
</code></pre>
    <p class="normal">This code will <a id="_idIndexMarker434"/>create the app that appears in the following screenshot, which has been cropped to the top two graphs for brevity:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_14.png"/></figure>
    <p class="packt_figref">Figure 11.14: The wide format example</p>
    <p class="normal">This makes our graphs much easier to read and easily allows us to compare them. We have intentionally paired our two graphs according to ratings, and the rest also appear to fit quite well next to each other. Our final step is to add a bit more text to make the entire app easier to read.</p>
    <h2 class="heading-2" id="_idParaDest-132">Narrative building through text and additional statistics</h2>
    <p class="normal">These<a id="_idIndexMarker435"/> graphs are already quite helpful to understand how the user reads, but we can bolster the readability of this app by adding some useful statistics and text underneath each graph and at the beginning of the app.</p>
    <p class="normal">Right above where we start to define our columns, we can add an initial section that shows the unique number of books that we have read, the unique authors, and our favorite author, all in one. We can use these basic statistics to kick off the app and tell the user that each graph is also interactive:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> goodreads_file <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
     st.subheader(<span class="hljs-string">"Tyler's Analysis Results:"</span>)
<span class="hljs-keyword">else</span>:
     st.subheader(<span class="hljs-string">'Your Analysis Results:'</span>)
books_finished = books_df[books_df[<span class="hljs-string">'Exclusive Shelf'</span>] == <span class="hljs-string">'read'</span>]
u_books = <span class="hljs-built_in">len</span>(books_finished[<span class="hljs-string">'Book Id'</span>].unique())
u_authors = <span class="hljs-built_in">len</span>(books_finished[<span class="hljs-string">'Author'</span>].unique())
mode_author = books_finished[<span class="hljs-string">'Author'</span>].mode()[<span class="hljs-number">0</span>]
st.write(<span class="hljs-string">f'It looks like you have finished </span><span class="hljs-subst">{u_books}</span><span class="hljs-string"> books with a total of </span><span class="hljs-subst">{u_authors}</span><span class="hljs-string"> unique authors. Your most read author is </span><span class="hljs-subst">{mode_author}</span><span class="hljs-string">!'</span>)
st.write(<span class="hljs-string">f'Your app results can be found below, we have analyzed everything from your book length distribution to how you rate books. Take a look around, all the graphs are interactive!'</span>)
row1_col1, row1_col2 = st.columns(<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">Now we need to add four new text sections below the four graphs that do not have any annotated text as of yet. For the first three graphs, the following code will add some statistics and text to each:</p>
    <pre class="programlisting code"><code class="hljs-code">row1_col1, row1_col2 = st.columns(<span class="hljs-number">2</span>)
row2_col1, row2_col2 = st.columns(<span class="hljs-number">2</span>)
row3_col1, row3_col2 = st.columns(<span class="hljs-number">2</span>)
<span class="hljs-keyword">with</span> row1_col1:
     mode_year_finished = <span class="hljs-built_in">int</span>(books_df[<span class="hljs-string">'Year Finished'</span>].mode()[<span class="hljs-number">0</span>])
     st.plotly_chart(fig_year_finished)
     st.write(<span class="hljs-string">f'You finished the most books in </span><span class="hljs-subst">{mode_year_finished}</span><span class="hljs-string">. Awesome job!'</span>)
<span class="hljs-keyword">with</span> row1_col2:
     st.plotly_chart(fig_days_finished)
     mean_days_to_finish = <span class="hljs-built_in">int</span>(books_finished_filtered[<span class="hljs-string">'days_to_finish'</span>].mean())
     st.write(<span class="hljs-string">f'It took you an average of </span><span class="hljs-subst">{mean_days_to_finish}</span><span class="hljs-string"> days between when the book was added to Goodreads and when you finished the book. This is not a perfect metric, as you may have added this book to a to-read list!'</span>)
<span class="hljs-keyword">with</span> row2_col1:
     st.plotly_chart(fig_num_pages)
     avg_pages = <span class="hljs-built_in">int</span>(books_df[<span class="hljs-string">'Number of Pages'</span>].mean())
     st.write(<span class="hljs-string">f'Your books are an average of </span><span class="hljs-subst">{avg_pages}</span><span class="hljs-string"> pages long, check out the distribution above!'</span>)
</code></pre>
    <p class="normal">One example<a id="_idIndexMarker436"/> graph here is the histogram of book length. The preceding code adds an average length and some text below the graph, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_11_15.png"/></figure>
    <p class="packt_figref">Figure 11.15: The average number of pages text</p>
    <p class="normal">For the final <a id="_idIndexMarker437"/>set of graphs, we can add text to the ones without context:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> row2_col2:
     st.plotly_chart(fig_year_published)
     st.write(<span class="hljs-string">'This chart is zoomed into the period of 1850-2021, but is interactive so try zooming in/out on interesting periods!'</span>)
<span class="hljs-keyword">with</span> row3_col1:
     st.plotly_chart(fig_my_rating)
     avg_my_rating = <span class="hljs-built_in">round</span>(books_rated[<span class="hljs-string">'My Rating'</span>].mean(), <span class="hljs-number">2</span>)
     st.write(<span class="hljs-string">f'You rate books an average of </span><span class="hljs-subst">{avg_my_rating}</span><span class="hljs-string"> stars on Goodreads.'</span>)
<span class="hljs-keyword">with</span> row3_col2:
     st.plotly_chart(fig_avg_rating)
     st.write(<span class="hljs-string">f"You rate books </span><span class="hljs-subst">{sign}</span><span class="hljs-string"> than the average Goodreads user by </span><span class="hljs-subst">{</span><span class="hljs-built_in">abs</span><span class="hljs-subst">(avg_difference)}</span><span class="hljs-string">!"</span>)
</code></pre>
    <p class="normal">This completes our section on adding text and additional statistics! </p>
    <h1 class="heading-1" id="_idParaDest-133">Hosting and promotion</h1>
    <p class="normal">Our final step is to<a id="_idIndexMarker438"/> host this app on Streamlit Community Cloud. To do<a id="_idIndexMarker439"/> this, we need to perform the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a GitHub repository for this work.</li>
      <li class="numberedList">Add a <code class="inlineCode">requirements.txt</code> file.</li>
      <li class="numberedList">Use one-click deployment on Streamlit Community Cloud to deploy the app.</li>
    </ol>
    <p class="normal">We have already covered this extensively in <em class="chapterRef">Chapter 5</em>, <em class="italic">Deploying Streamlit with Streamlit Community Cloud</em>, so give it a shot now without instructions.</p>
    <h1 class="heading-1" id="_idParaDest-134">Summary</h1>
    <p class="normal">What a fun chapter! We have learned so much here – from how to come up with data science projects of our own, and how to create initial MVPs, to the iterative improvement of our apps. We did this all through the lens of our Goodreads dataset, and we took this app from just an idea to a fully functioning app hosted on Streamlit Community Cloud. I look forward to seeing all the different types of Streamlit apps that you create. Please create something fun and send it to me on Twitter at <code class="inlineCode">@tylerjrichards</code>. In the next chapter, we will focus on interviews with Streamlit power users and creators to learn tips and tricks, why they use Streamlit so extensively, and also where they think the library will go from here. See you there!</p>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/sl"><span class="url">https://packt.link/sl</span></a></p>
    <p class="normal"><img alt="" role="presentation" src="../Images/QR_Code13440134443835796.png"/></p>
  </div>
</body></html>