- en: '*Chapter 11*: Using Streamlit for Teams'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the past two chapters, we have deeply explored how to use Streamlit
    for things such as personal data projects, projects for resume building, and even
    for creating apps for take-home job applications. In this chapter, we will focus
    on using Streamlit at your place of work, as a data scientist, machine learning
    engineer, or data analyst. We already know that Streamlit can be used as a convincing
    tool to influence those around us through thoughtful and interactive analyses,
    and we will work on applying that to the work data scientists actually do.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit is both a company and an open source library and makes revenue by
    being such an excellent tool in a data science toolkit that companies are convinced
    to pay for special features and customizations that increase the productivity
    of their own data scientists. The best part about this is that the company is
    directly incentivized to make the experience of using the tool as useful and valuable
    as possible; if you're a better data scientist because of Streamlit, your company
    is more likely to pay more for access.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Streamlit is already designed to be collaborative. If another
    developer has access to a GitHub repository that is being used for a Streamlit
    app, then any edits they make will pop up on the deployed app automatically. Because
    of this, Streamlit is a natural collaborative fit for both individual data scientists
    and groups of data science teams working on similar analyses or applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing hypothetical survey costs using Streamlit for Teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and deploying apps from private repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication with Streamlit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To kick us off for this chapter, we will start with an example of when we would
    use Streamlit for Teams instead of static analysis at work.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing hypothetical survey costs using Streamlit for Teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you are a data scientist for **Big Internet Company** (**BIC**). BIC
    sells budgeting software to users, and you are responsible for surveying the users
    of your app to see where the app could be improved. You work with a fairly typical
    team made up of a product manager, two software engineers, three project managers,
    two user experience researchers, and yourself, the lone data scientist. One day,
    your product manager messages you on Slack and asks you to figure out the right
    sample of users between the ages of 16 and 24, a crucial segment of the business,
    to take a 10-question survey about the software. In a brainstorming session, your
    researchers have found some evidence that giving people a 10% chance at winning
    a $500 gift card is more effective than giving people $50 for the response rates
    in your survey, and want you to incorporate that into your analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many factors that you need to consider here: how much does the team
    want to spend? How many samples should we choose? The hardest part here is the
    trade-off between cost and the representativeness of the sample. We have a few
    options. We could recommend a sample size without really informing the team why
    we are recommending a sample size. We could also give the team a few options on
    costs, describing some of the pros and cons in a list. A better option than any
    of these is to create a short Streamlit app that will help us make this decision
    as a team to understand all the trade-offs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to do the latter! Our general steps here are going
    to be to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new Streamlit app folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Illustrating the representativeness of the sample
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the cost of the sample
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using interaction to show trade-offs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to start with the first option, setting up our folder.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new Streamlit app folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have taken this step quite a few times in this book before. Go ahead and
    set up a folder called `random_survey_app` and place within it a file called `app.py`,
    where we will put our new Streamlit app. Now on to the central problem at hand!
  prefs: []
  type: TYPE_NORMAL
- en: Illustrating the representativeness of the sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we are the data scientist for BIC, we know a lot of data about the user
    population in question. We want to make sure that the sample we grab is representative
    of the population as a whole, especially in reference to one or more key variables
    of the business. For this example, we can assume that the most important metric
    to the business is user time spent on our app. We already know the distribution
    of user time spent and can represent that within our app using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `np.random.seed(1)` line so that you will see the same sample
    as the figures in this book, but when developing a user-facing app, I would recommend
    leaving this out, otherwise clever users will be more suspicious about your random
    selection methods! Setting a seed in `numpy` allows reproducible results with
    randomly selected data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the distribution of the user time spent on the app, we can
    show the user how representative different-sized sub-samples will be by drawing
    the two distributions of user time spent next to each other. While this is not
    the best method for determining representativeness, it is going to be useful to
    prove the general point to your audience. The next code block sub-samples 100
    from the set of 1,000 samples, and plots each in a histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block will produce the following app, showing that at 100 users,
    it looks fairly representative of the total time spent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Survey sample size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Survey sample size
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to figure out the trade-off – how to determine the cost of a set
    sample of users.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the cost of the sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed before, we can calculate the cost of the sample by looking at
    the number of survey respondents multiplied by the cost of each one. The cost
    of any individual survey respondent is a 10% chance at a $500 gift card, so we
    should show the expected value as 10% times $500, which is $50 on average. We
    should also be able to say, *what percent of the time does the cost of the experiment
    fall below some dollar amount?* dynamically, to assure the group of the costing
    risks associated with the randomness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate and print out the expected cost using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have this, we can simulate this survey running 10,000 times and count
    how often the cost of the experiment goes over a certain value, which we call
    `max_cost` in the next code block. We use the `numpy` library again to sample
    from the binomial distribution, which is the number of successes given a set of
    independent events with the same probability (for example, if you flipped a coin
    10 times, how many times it would land on heads):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For our survey size of 100 and a max cost of $5,000, the expected cost is $5,000
    and the cost goes over our limit ~41% of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Expected cost of survey'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Expected cost of survey
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the set pieces, we need to actually make this interactive
    with Streamlit features.
  prefs: []
  type: TYPE_NORMAL
- en: Using interaction to show trade-offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make this app better than a static analysis, we need to let the
    user interact with our app. We can do this in two ways, first by allowing the
    user to change the number of people surveyed, and second by changing the max cost
    variable we assigned. We can do both of those things using the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this block, we set a minimum and maximum value for the Streamlit slider,
    and also set the default value for the maximum amount to be the expected value
    to make it easier for the user as they change the number of surveys. We should
    also add some text above this to instruct the user how to interact with our app,
    as shown in the following addition to the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These two additions to our app produce the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Streamlit sliders with costing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Streamlit sliders with costing
  prefs: []
  type: TYPE_NORMAL
- en: So far, this works perfectly fine. However, because you are working for a company,
    you want to make sure that none of this information in the app is released to
    the public or any competitors. Because of this, deploying this app publicly is
    not an option, and we need to figure out how to privately deploy the application.
    In [*Chapter 9*](B16864_09_Final_VK_ePub.xhtml#_idTextAnchor094), *Improving Job
    Applications with Streamlit*, we discussed how to make our applications private
    with password protection, but Streamlit for Teams also allows us to deploy from
    private GitHub repositories, which is the topic of our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and deploying apps from private repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One great feature of the Streamlit for Teams product is the ability to use Streamlit
    Sharing from private GitHub repositories. This works exactly the same as how we
    learned in [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056), *Deploying
    Streamlit with Streamlit Sharing*, but from a private rather than a public repository.
    To make this change, you will need to have access to Streamlit Teams or get access
    from the Streamlit team (they might just let you try it out if you ask nicely!).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a private GitHub repo, head over to [https://github.com/new](https://github.com/new)
    and make sure to click the **Private** rather than **Public** option, as shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Private repository on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Private repository on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: And after we add our current code to our GitHub repository, we can deploy on
    Streamlit Sharing just as we normally would, by going over to [https://share.streamlit.io](https://share.streamlit.io)
    and following the directions for one-click deployment. I have deployed this Streamlit
    app using my own private repo, and the Streamlit app can be found at [https://share.streamlit.io/tylerjrichards/random_survey_app/main/app.py](https://share.streamlit.io/tylerjrichards/random_survey_app/main/app.py).
    Our next problem to work on is finding alternatives to the password method that
    we have already explored, with user-specific authentication with Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: User authentication with Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One feature currently in beta on Streamlit for Teams but with an expected release
    date of late 2021 is Google-based **single sign-on** (**SSO**) authentication
    for our applications. This will allow us to make our app totally private, only
    viewable by users that we put on an allow list. The first step we need to take
    is to link our own Google account, by heading over to [https://share.streamlit.io](https://share.streamlit.io)
    and clicking on **Settings** in the top-right corner. Once we are there, we will
    see the screen shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Linking Google accounts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Linking Google accounts
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now click the blue **Connect** button and then sign in to our Google
    account. Once that is finished, we need to head over to our main page at [https://share.streamlit.io](https://share.streamlit.io)
    and figure out which app we want to restrict traffic to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Streamlit sharing options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Streamlit sharing options
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I want to limit the reach of the second app, so I will go to the
    settings of this app by clicking the icon on the far-right side of the page and
    selecting **Settings**, as we have done before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we connected our Google account, we only had the option to edit the
    **Secrets** sections of our apps, but now we have this entirely new section called
    **Viewers**, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Viewers auth'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_11_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – Viewers auth
  prefs: []
  type: TYPE_NORMAL
- en: We can set our app to private with the checkbox and add people with their email
    to this list. If they are not on the list, they will get a 404 error when trying
    to reach the app! This works extraordinarily well for a smaller number of users
    but does not work as well if you are trying to reach hundreds or thousands of
    users, especially those who do not have Google-related email accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored an example costing analysis, which showed us a
    job-specific use case for Streamlit. In this example, we discussed how to use
    interactive Streamlit applications to help improve and inform the data-based decision
    making of teams. After that, we also learned how to deploy Streamlit applications
    from private GitHub repositories, and we learned about multiple methods to make
    our Streamlit applications only available to a private audience with password
    protection and Google SSO. This concludes the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on interviews with power Streamlit users
    and creators to learn tips and tricks, why they use Streamlit so extensively,
    and also where they think the library will go from here. See you there!
  prefs: []
  type: TYPE_NORMAL
