<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer138">
    <h1 class="chapterNumber">10</h1>
    <h1 class="chapterTitle" id="_idParaDest-109">Improving Job Applications with Streamlit</h1>
    <p class="normal">At this point in this book, you should already be an experienced Streamlit user. You have a good grasp of everything – from Streamlit design to deployment, to data visualization, and everything in between. This chapter is designed to be application-focused; it will show you some great use cases for Streamlit applications so that you can be inspired to create your own! We will start by demonstrating how to use Streamlit for <strong class="keyWord">Proof-of-Skill Data Projects</strong>. Then, we will move on to discuss how to use Streamlit in the <strong class="keyWord">Take-Home</strong> sections of job applications.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Using Streamlit for proof-of-skill data projects</li>
      <li class="bulletList">Improving job applications in Streamlit</li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-110">Technical requirements</h1>
    <p class="normal">The following is a list of software and hardware installations that are required for this chapter:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">streamlit-lottie</code>: We already installed this library in our Components chapter, but if you have yet to install it, now is a great time! To download this library, run the following code in your Terminal:
        <pre class="programlisting con"><code class="hljs-con">pip install streamlit-lottie
</code></pre>
    <p class="normal">Interestingly, <code class="inlineCode">streamlit-lottie</code> uses the <code class="inlineCode">lottie</code> open-source library, which allows us to add web-native animations (such as a GIF) to our Streamlit apps. Frankly, it is a wonderful library that you can use to beautify Streamlit apps and was created by Fanilo Andrianasolo, a prolific Streamlit app creator.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">The job application example folder: The central repository for this book can be found at <a href="https://github.com/tylerjrichards/Streamlit-for-Data-Science"><span class="url">https://github.com/tylerjrichards/Streamlit-for-Data-Science</span></a>. Within this repository, the <code class="inlineCode">job_application_example</code> folder will contain some of the files that you will need for the second section of the chapter, covering job applications. If you do not have this main repository downloaded already, use the following code in your Terminal to clone it:
        <pre class="programlisting con"><code class="hljs-con">https://github.com/tylerjrichards/Streamlit-for-Data-Science
</code></pre>
      </li>
    </ul>
    <p class="normal">Now that we have everything set up, let’s begin!</p>
    <h1 class="heading-1" id="_idParaDest-111">Using Streamlit for proof-of-skill data projects</h1>
    <p class="normal">Proving<a id="_idIndexMarker362"/> to others that you are a skilled <a id="_idIndexMarker363"/>data scientist is notoriously difficult. Anyone can put Python or machine learning on their résumé or even work in a research group at a university that might involve some machine learning. But often, recruiters, professors you want to work with, and data science managers rely on things on your résumé that are proxies for competence, such as having attended the “right” university or already having a fancy data science internship or job.</p>
    <p class="normal">Prior to Streamlit, there were not many effective ways to show off your work quickly and easily. If you put a Python file or Jupyter notebook on your GitHub profile, the time it would take for someone to understand whether the work was impressive or not was too much of a risk to take. If the recruiter has to click on the right repository in your GitHub profile and then click through numerous files until they find a Jupyter notebook with unreadable code (without comments), you’ve already lost them. If the recruiter sees “machine learning” on your résumé, but it takes five clicks to see any machine learning product or code that you’ve written, you’ve already lost them. Most interested parties will spend a very small amount of time on your résumé; for example, on average, visitors to my personal portfolio site (<a href="http://www.tylerjrichards.com"><span class="url">www.tylerjrichards.com</span></a>) spend around 2 minutes on the site before moving elsewhere. If this is a recruiter, I need to make sure they get a grasp of who I am and why I might be a good candidate quickly!</p>
    <p class="normal">One solution to this issue is to try creating and sharing Streamlit apps that are specific to the skills that you would like to showcase the most broadly. For instance, if you have a lot of experience in fundamental statistics, you might create a Streamlit app that proves, or illustrates, a fundamental statistical theorem such as the central limit theorem – just as we did earlier in this book. </p>
    <p class="normal">If instead, you have experience in natural language processing, you could create an app that shows off a new text-generating neural network that you have created. The point here is to minimize the number of clicks someone<a id="_idIndexMarker364"/> would need to make until they get proof<a id="_idIndexMarker365"/> of your competence within a desired area.</p>
    <p class="normal">Many of the Streamlit apps that we have created already do serve this purpose. Let’s run through a few examples.</p>
    <h2 class="heading-2" id="_idParaDest-112">Machine learning – the Penguins app</h2>
    <p class="normal">In <em class="chapterRef">Chapter 4</em>, <em class="italic">Machine Learning and AI with Streamlit</em>, we created a random forest model that was trained on <a id="_idIndexMarker366"/>our Palmer Penguins dataset to predict the species of penguin according to features such as weight, island of habitation, and bill length. Then, we saved that model so that we could use it in our Streamlit app.</p>
    <p class="normal">Before proceeding to create the Streamlit app, we need (in the first iteration) to run the following code, which will create the deployed model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">import</span> pickle
penguin_df = pd.read_csv(<span class="hljs-string">'penguins.csv'</span>)
penguin_df.dropna(inplace=<span class="hljs-literal">True</span>)
output = penguin_df[<span class="hljs-string">'species'</span>]
features = penguin_df[[<span class="hljs-string">'island'</span>, <span class="hljs-string">'bill_length_mm'</span>, <span class="hljs-string">'bill_depth_mm'</span>,
                       <span class="hljs-string">'flipper_length_mm'</span>, <span class="hljs-string">'body_mass_g'</span>, <span class="hljs-string">'sex'</span>]]
features = pd.get_dummies(features)
output, uniques = pd.factorize(output)
x_train, x_test, y_train, y_test = train_test_split(
    features, output, test_size=<span class="hljs-number">.8</span>)
rfc = RandomForestClassifier(random_state=<span class="hljs-number">15</span>)
rfc.fit(x_train, y_train)
y_pred = rfc.predict(x_test)
score = accuracy_score(y_pred, y_test)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Our accuracy score for this model is {}'</span>.<span class="hljs-built_in">format</span>(score))
</code></pre>
    <p class="normal">In this first section, we import our libraries, load our data, and train/evaluate our model while printing out the evaluation results. Then, we save the model results to the <code class="inlineCode">pickle</code> files using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">rf_pickle = <span class="hljs-built_in">open</span>(<span class="hljs-string">'random_forest_penguin.pickle'</span>, <span class="hljs-string">'wb'</span>)
pickle.dump(rfc, rf_pickle)
rf_pickle.close()
output_pickle = <span class="hljs-built_in">open</span>(<span class="hljs-string">'output_penguin.pickle'</span>, <span class="hljs-string">'wb'</span>)
pickle.dump(uniques, output_pickle)
output_pickle.close()
</code></pre>
    <p class="normal">Recall that at the<a id="_idIndexMarker367"/> end of the chapter, we added a new feature so that if a user uploaded their own dataset, they could use our model training script to train a model entirely on their data (provided it was in the same format; it came with some preconditions).</p>
    <p class="normal">This app, in its final form, shows that we have at least some knowledge about data cleaning, how to do one-hot encoding on our variables, how we think about evaluating our models on test data, and finally, how to deploy our pre-trained models in an application. That alone is going to look much better than just putting “machine learning” on our résumé, and it shows evidence of some of the skills that we have. Without this proof of skill, the recruiter or hiring manager who is looking at our application will have to either trust that we are being entirely honest on our résumé (and from reading hundreds of résumés over the years, that is a bad assumption to make) or use a proxy for confidence such as a university degree (this is also a bad proxy for assessing competence).</p>
    <p class="normal">In addition to this, when we deploy this app to Streamlit Community Cloud and use a public GitHub repository (i.e., like we did in <em class="chapterRef">Chapter 5</em>, <em class="italic">Deploying Streamlit with Streamlit Community Cloud</em>), we get an automatic feature that comes free in our app, which is a GitHub repo button. As you can see in the following screenshot, when we deploy our apps to Streamlit Community Cloud, a button is added to the top right of the user’s view that allows them to view the source code behind the app. If you are the owner of the app, you will see a <strong class="screenText">Share</strong> button as well, which lets you share the app with others!</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_10_01.png"/></figure>
    <p class="packt_figref">Figure 10.1: The View app source option</p>
    <p class="normal">In this way, users <a id="_idIndexMarker368"/>can always check to make sure malicious code (for example, whether a researcher’s Penguin data is being stored by the app) is not being deployed by Streamlit Community Cloud. As a secondary feature, the user can also view the code that you wrote to build the app, which improves the ability for us to use Streamlit as<a id="_idIndexMarker369"/> a <strong class="keyWord">Proof-of-Skill</strong> tool.</p>
    <h2 class="heading-2" id="_idParaDest-113">Visualization – the Pretty Trees app</h2>
    <p class="normal">In <em class="chapterRef">Chapter 6</em>, <em class="italic">Beautifying Streamlit Apps</em>, we <a id="_idIndexMarker370"/>worked on a Streamlit application that could create beautiful and dynamic visualizations of trees in San Francisco, which resulted in the following app:</p>
    <figure class="mediaobject"><img alt="Figure 9.2 – Mapping a web app " src="../Images/B18444_10_02.png"/></figure>
    <p class="packt_figref">Figure 10.2: Mapping a web app</p>
    <p class="normal">Within this<a id="_idIndexMarker371"/> app, we had to create multiple different visualizations (that is, two histograms and one map) that dynamically updated based on the user inputs on the right-hand side. With an app like this, we were able to show off our data manipulation skills, our familiarity with the <code class="inlineCode">pandas</code>, <code class="inlineCode">matplotlib</code>, and <code class="inlineCode">seaborn</code> libraries, and even that we understood how to deal with datetimes in Python. Let’s take a look at the section of the app’s code that focuses on visualization:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#define multiple columns, add two graphs</span>
col1, col2 = st.columns(<span class="hljs-number">2</span>)
<span class="hljs-keyword">with</span> col1:
     st.write(<span class="hljs-string">'Trees by Width'</span>)
     fig_1, ax_1 = plt.subplots()
     ax_1 = sns.histplot(trees_df[<span class="hljs-string">'dbh'</span>],
          color=graph_color)
     plt.xlabel(<span class="hljs-string">'Tree Width'</span>)
     st.pyplot(fig_1)
<span class="hljs-keyword">with</span> col2:
     st.write(<span class="hljs-string">'Trees by Age'</span>)
     fig_2, ax_2 = plt.subplots()
     ax_2 = sns.histplot(trees_df[<span class="hljs-string">'age'</span>],
          color=graph_color)
     plt.xlabel(<span class="hljs-string">'Age (Days)'</span>)
     st.pyplot(fig_2)
st.write(<span class="hljs-string">'Trees by Location'</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">'longitude'</span>, <span class="hljs-string">'latitude'</span>])
trees_df = trees_df.sample(n = <span class="hljs-number">1000</span>, replace=<span class="hljs-literal">True</span>)
st.<span class="hljs-built_in">map</span>(trees_df)
</code></pre>
    <p class="normal">This code is fairly easy to read for anyone who is familiar with Python or other scripting languages, and it is a heck of a lot better than simply putting “data visualization” or “pandas” on a résumé.</p>
    <p class="normal">At this point, I <a id="_idIndexMarker372"/>hope you are convinced. Streamlit apps are an excellent way to showcase your work to recruiters, potential hiring managers, or anyone to whom you need to prove your set of skills. In the next section, we will cover this process in a little more detail and demonstrate how to use Streamlit to bolster your applications to companies that you might want to work for.</p>
    <h1 class="heading-1" id="_idParaDest-114">Improving job applications in Streamlit</h1>
    <p class="normal">Often, data science<a id="_idIndexMarker373"/> and machine learning job applications rely<a id="_idIndexMarker374"/> on take-home data science challenges to judge candidates. Frankly, this is a brutal and annoying experience that companies can demand because of the dynamic between the applicant and the employer. For instance, it could take a candidate 5–10 hours to fully complete a data science challenge, but it might only take the employer 10 minutes to evaluate it. Additionally, an individual virtual or telephone interview might take 30–45 minutes for the employer, plus an extra 15 minutes to write up feedback, compared to the same 30–45 minutes for the applicant. Because getting 5–10 hours of work gives them a very high signal per minute of employee time, employers have trended toward including these challenges within their job applications.</p>
    <p class="normal">You can use the opportunity here to use Streamlit to stand out from the crowd by creating a fully functioning application instead of sending the company a Jupyter notebook, Word document, or PowerPoint deck.</p>
    <h2 class="heading-2" id="_idParaDest-115">Questions</h2>
    <p class="normal">Let’s walk through a fictional example about a job applicant who is in the middle of applying to a major US airline. They are given two main questions to solve – one has a dataset included:</p>
    <ul>
      <li class="bulletList">Question 1: Airport distance
    <p class="normal">The first exercise asks, “<em class="italic">Given the included dataset of airports and locations (in latitude and longitude), write a function that takes an airport code as input and returns the airports listed from nearest to furthest from the input airport.</em>”</p></li>
    </ul>
    <ul>
      <li class="bulletList">Question 2: Representation
    <p class="normal">The second question asks, “<em class="italic">How would you transform a collection of searches into a numeric vector representing a trip? Assume that we have hundreds of thousands of users and we want to represent all of their trips this way. Ideally, we want this to be a general representation that we could use in multiple different modeling projects, but we definitely care about finding similar trips. How, precisely, would you compare two trips to see how similar they are? What information do you feel might be missing from the preceding data that would help improve your representation?</em>”</p></li>
    </ul>
    <p class="normal">Now that <a id="_idIndexMarker375"/>we have the required questions, we can <a id="_idIndexMarker376"/>get a new Streamlit app started. To do this, I went through the same process that we have used in each chapter thus far. We create a new folder for our app within our central folder (<code class="inlineCode">streamlit_apps</code>), called <code class="inlineCode">job_application_example</code>. </p>
    <p class="normal">Within this folder, we can create a Python file, called <code class="inlineCode">job_streamlit.py</code>, in our Terminal, using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">touch job_streamlit.py
</code></pre>
    <h2 class="heading-2" id="_idParaDest-116">Answering Question 1</h2>
    <p class="normal">It is not hugely important for you to understand exactly how to answer the problem at hand (calculating airport distances), but the overall framework of creating Streamlit apps is quite important. The Streamlit app we create should read like an incredibly dynamic document that answers the question in a unique way, depending on the ability of Streamlit to make an application that could not easily be replicated by an applicant with a Word document.</p>
    <p class="normal">To begin, we can create a title that introduces us and kicks off the format for the whole application. One improvement here is to add an optional animation at the top of the application using the <code class="inlineCode">streamlit-lottie</code> library that we learned about in <em class="chapterRef">Chapter 7</em>, <em class="italic">Exploring Streamlit Components</em>, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> streamlit_lottie <span class="hljs-keyword">import</span> st_lottie
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">def</span> <span class="hljs-title">load_lottieurl</span>(<span class="hljs-params">url: </span><span class="hljs-built_in">str</span>):
    r = requests.get(url)
    <span class="hljs-keyword">if</span> r.status_code != <span class="hljs-number">200</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">return</span> r.json()
lottie_airplane = load_lottieurl(<span class="hljs-string">'</span><span class="hljs-string">https://assets4.lottiefiles.com/packages/lf20_jhu1lqdz.json'</span>)
st_lottie(lottie_airplane, speed=<span class="hljs-number">1</span>, height=<span class="hljs-number">200</span>, key=<span class="hljs-string">"initial"</span>)
st.title(<span class="hljs-string">'Major US Airline Job Application'</span>)
st.write(<span class="hljs-string">'by Tyler Richards'</span>)
st.subheader(<span class="hljs-string">'Question 1: Airport Distance'</span>)
</code></pre>
    <p class="normal">The <a id="_idIndexMarker377"/>preceding code will create an application with a beautiful<a id="_idIndexMarker378"/> airplane animation at the top, as presented in the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 9.3 – An airplane GIF  " src="../Images/B18444_10_03.png"/></figure>
    <p class="packt_figref">Figure 10.3: An airplane animation</p>
    <p class="normal">Next, we need to copy and paste the question below our subheader. Streamlit has many options for putting text into applications. One option that we have not used yet is to wrap our text inside three apostrophe signs, which tells Streamlit to write this text using the Markdown language. This is useful for large blocks of text, such as the following one, which begins to answer the first question:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">The first exercise asks us 'Given the table of airports and</span>
<span class="hljs-string">locations (in latitude and longitude) below,</span>
<span class="hljs-string">write a function that takes an airport code as input and</span>
<span class="hljs-string">returns the airports listed from nearest to furthest from</span>
<span class="hljs-string">the input airport.' There are three steps here:</span>
<span class="hljs-string">1. Load the data</span>
<span class="hljs-string">2. Implement a distance algorithm</span>
<span class="hljs-string">3. Apply the distance formula across all airports other than the input</span>
<span class="hljs-string">4. Return a sorted list of the airports' distances</span>
<span class="hljs-string">"""</span>
</code></pre>
    <p class="normal">As <a id="_idIndexMarker379"/>mentioned in the <em class="italic">Technical requirements</em> section <a id="_idIndexMarker380"/>of this chapter, two files are needed to complete this application. The first is the dataset of the airport locations (called <code class="inlineCode">airport_location.csv</code>), and the second is a picture that shows the Haversine distance (that is, the distance between two points on a sphere; the file is appropriately named <code class="inlineCode">haversine.png</code>). Please copy those files into the same folder as the Streamlit application Python file.</p>
    <p class="normal">Now, we need to complete the first step: loading the data. We need to both complete this step in Streamlit and also show the code to the user. This is different from other Streamlit applications, where the code is hidden in the background. However, because the user definitely wants to see our code, as they will be assessing us on it, we need to do both. We can use the <code class="inlineCode">st.echo()</code> function, which we used previously, to print out the code block to our app. We can do this with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">airport_distance_df = pd.read_csv(<span class="hljs-string">'airport_location.csv'</span>)
<span class="hljs-keyword">with</span> st.echo():
     <span class="hljs-comment">#load necessary data</span>
     airport_distance_df = pd.read_csv(<span class="hljs-string">'airport_location.csv'</span>)
</code></pre>
    <p class="normal">I would like to note here that we have placed a comment at the top of this code. This is not for the purpose of annotating code for you, the reader, but for the application reader. It is good practice to occasionally comment on the purpose of the code that you are writing both within the code and in the blocks of text before and after; this is so that the reader understands the approach you are trying to take. This is especially important in a job application but is a good practice for collaborative Streamlit apps, too.</p>
    <p class="normal">Our next<a id="_idIndexMarker381"/> step is to explain the Haversine formula and show the<a id="_idIndexMarker382"/> image in our Streamlit application, which we have done in the following code block. It is totally acceptable to take a narrative format in your blocks of text. Simply imagine what you would like to read as a hiring manager and try to replicate that as well as you can:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">From some quick googling, I found that the Haversine distance is</span>
<span class="hljs-string">a good approximation for distance. At least good enough to get the</span>
<span class="hljs-string">distance between airports! Haversine distances can be off by up to .5%</span>
<span class="hljs-string">because the Earth is not actually a sphere. It looks like the latitudes</span>
<span class="hljs-string">and longitudes are in degrees, so I'll make sure to have a way to account</span>
<span class="hljs-string">for that as well. The Haversine distance formula is labeled below,</span>
<span class="hljs-string">followed by an implementation in Python</span>
<span class="hljs-string">"""</span>
st.image(<span class="hljs-string">'haversine.png'</span>)
</code></pre>
    <p class="normal">Now, our application should look similar to the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 9.4 – Loading the data for Question 1 " src="../Images/B18444_10_04.png"/></figure>
    <p class="packt_figref">Figure 10.4: Loading the data for Question 1</p>
    <p class="normal">We have<a id="_idIndexMarker383"/> our list of items to address, the animation, the Haversine <a id="_idIndexMarker384"/>distance formula, and the basic code to read in the data. At this point, we need to implement the Haversine distance formula in Python and also show our implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> st.echo():
    <span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> atan2, cos, radians, sin, sqrt
    <span class="hljs-keyword">def</span> <span class="hljs-title">haversine_distance</span>(<span class="hljs-params">long1, lat1, </span>
<span class="hljs-params">  long2, lat2,    degrees=</span><span class="hljs-literal">False</span>):
        <span class="hljs-comment"># degrees vs radians</span>
        <span class="hljs-keyword">if</span> degrees == <span class="hljs-literal">True</span>:
            long1 = radians(long1)
            lat1 = radians(lat1)
            long2 = radians(long2)
            lat2 = radians(lat2)
        <span class="hljs-comment"># implementing haversine</span>
        a = (
            sin((lat2 - lat1) / <span class="hljs-number">2</span>) ** <span class="hljs-number">2</span>
            + cos(lat1) * cos(lat2) * sin((long2 - long1) / <span class="hljs-number">2</span>) ** <span class="hljs-number">2</span>
        )
        c = <span class="hljs-number">2</span> * atan2(sqrt(a), sqrt(<span class="hljs-number">1</span> - a))
        distance = <span class="hljs-number">6371</span> * c  <span class="hljs-comment"># radius of earth in kilometers</span>
        <span class="hljs-keyword">return</span> distance
</code></pre>
    <p class="normal">The first<a id="_idIndexMarker385"/> section of our code does not create our function but, <a id="_idIndexMarker386"/>instead, prints out the function that we will create in the Streamlit app. This is so that the reader of the application can view both pieces of important code that we have written and interact with the code itself. If we had just created a function to implement the Haversine distance, the reader of our application would not really have known how we solved the problem at hand! The following code block creates this function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#execute haversine function definition</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> radians, sin, cos, atan2, sqrt
<span class="hljs-keyword">def</span> <span class="hljs-title">haversine_distance</span>(<span class="hljs-params">long1, lat1, </span>
<span class="hljs-params">                       long2, lat2, </span>
<span class="hljs-params">                       degrees=</span><span class="hljs-literal">False</span>):
    <span class="hljs-comment"># degrees vs radians</span>
    <span class="hljs-keyword">if</span> degrees == <span class="hljs-literal">True</span>:
        long1 = radians(long1)
        lat1 = radians(lat1)
        long2 = radians(long2)
        lat2 = radians(lat2)
 
    <span class="hljs-comment"># implementing haversine</span>
    a = (
        sin((lat2 - lat1) / <span class="hljs-number">2</span>) ** <span class="hljs-number">2</span>
        + cos(lat1) * cos(lat2) * sin((long2 - long1) / <span class="hljs-number">2</span>) ** <span class="hljs-number">2</span>
    )
    c = <span class="hljs-number">2</span> * atan2(sqrt(a), sqrt(<span class="hljs-number">1</span> - a))
    distance = <span class="hljs-number">6371</span> * c  
<span class="hljs-comment"># radius of earth in kilometers</span>
    <span class="hljs-keyword">return</span> distance
</code></pre>
    <p class="normal">We have completed our Haversine implementation! Whenever we want to find the distance between two locations, we can call our formula, input the longitude and latitude, and get the distance in kilometers. This app is useful; however, at the moment, it is not much better than a Word document. Our next step is to allow the user to input their own points to check and see whether the Haversine distance is working. Almost no one knows how many kilometers apart two points on the globe are, so I have included default points and checked the real distance between them:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">Now, we need to test out our function! The</span>
<span class="hljs-string">distance between the default points is</span>
<span class="hljs-string">18,986 kilometers, but feel free to try out</span>
<span class="hljs-string">your own points of interest.</span>
<span class="hljs-string">"""</span>
long1 = st.number_input(<span class="hljs-string">'Longitude 1'</span>, value = <span class="hljs-number">2.55</span>)
long2 = st.number_input(<span class="hljs-string">'Longitude 2'</span>, value = <span class="hljs-number">172.00</span>)
lat1 = st.number_input(<span class="hljs-string">'Latitude 1'</span>, value = <span class="hljs-number">49.01</span>)
lat2 = st.number_input(<span class="hljs-string">'Latitude 2'</span>, value = -<span class="hljs-number">43.48</span>)
test_distance = haversine_distance(long1 = long1, long2 = long2,
          lat1 = lat1, lat2 = lat2, degrees=<span class="hljs-literal">True</span>)
st.write(<span class="hljs-string">'Your distance is: {} kilometers'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>(test_distance)))
</code></pre>
    <p class="normal">When we <a id="_idIndexMarker387"/>put in our default values, the app returns a distance <a id="_idIndexMarker388"/>that is approximately 2 kilometers off, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 9.5 – Implementing the Haversine distance  " src="../Images/B18444_10_05.png"/></figure>
    <p class="packt_figref">Figure 10.5: Implementing the Haversine distance</p>
    <p class="normal">At <a id="_idIndexMarker389"/>this point, our next step is to combine all of the pieces by using<a id="_idIndexMarker390"/> the implemented Haversine distance calculator on our given dataset. This is briefly shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_10_06.png"/></figure>
    <p class="packt_figref">Figure 10.6: The airport distances that have been given</p>
    <p class="normal">This dataset has airport codes and their corresponding <code class="inlineCode">lat</code> and <code class="inlineCode">long</code> values. The following code block introduces a solution that combines the two distances and leaves out the full <code class="inlineCode">get_distance_list</code> function, as it is simply a copy of the function that we have implemented twice already:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">We have the Haversine distance implemented, and we also have</span>
<span class="hljs-string">proven to ourselves that it works reasonably well.</span>
<span class="hljs-string">Our next step is to implement this in a function!</span>
<span class="hljs-string">"""</span> 
<span class="hljs-keyword">def</span> <span class="hljs-title">get_distance_list</span>(<span class="hljs-params">airport_dataframe,</span>
<span class="hljs-params">                      airport_code</span>):
    df = airport_dataframe.copy()
    row = df[df.loc[:, <span class="hljs-string">"Airport Code"</span>] == airport_code]
    lat = row[<span class="hljs-string">"Lat"</span>]
    long = row[<span class="hljs-string">"Long"</span>]
    df = df[df[<span class="hljs-string">"Airport Code"</span>] != airport_code]
    df[<span class="hljs-string">"Distance"</span>] = df.apply(
        <span class="hljs-keyword">lambda</span> x: haversine_distance(
            lat1=lat, long1=long, lat2=x.Lat, long2=x.Long, degrees=<span class="hljs-literal">True</span>
        ),
        axis=<span class="hljs-number">1</span>,
    )
    df_to_return = df.sort_values(by=<span class="hljs-string">"Distance"</span>).reset_index()
    <span class="hljs-keyword">return</span> df_to_return
<span class="hljs-keyword">with</span> st.echo():
     <span class="hljs-keyword">def</span> <span class="hljs-title">get_distance_list</span>(<span class="hljs-params">airport_dataframe, airport_code</span>):
          *copy of function above <span class="hljs-keyword">with</span> comments*
</code></pre>
    <p class="normal">Finally, we <a id="_idIndexMarker391"/>can implement this distance formula on the DataFrame we have been given. We can allow the user to input their own airport code from the <a id="_idIndexMarker392"/>options that we have data on and return the correct values:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">To use this function, select an airport from the airports provided in the dataframe</span>
<span class="hljs-string">and this application will find the distance between each one, and</span>
<span class="hljs-string">return a list of the airports ordered from closest to furthest.</span>
<span class="hljs-string">"""</span>
selected_airport = st.selectbox(<span class="hljs-string">'Airport Code'</span>, airport_distance_df[<span class="hljs-string">'Airport Code'</span>])
distance_airports = get_distance_list(
     airport_dataframe=airport_distance_df, airport_code=selected_airport)
st.write(<span class="hljs-string">'Your closest airports in order are {}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">list</span>(distance_airports)))
</code></pre>
    <p class="normal">This is the end of our first question. We can add an optional section at the end about how we would change our implementation if we had more time to work on this problem. This is always a good idea if you know you only want to spend a few hours on the total application, but you also want to demonstrate that you know how to improve it if you had more time. </p>
    <p class="normal">An example of this is shown in the following code block, to be placed directly after the preceding code block:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">This all seems to work just fine! There are a few ways I would improve this if I was working on</span>
<span class="hljs-string">this for a longer period of time.  </span>
<span class="hljs-string">1. I would implement the [Vincenty Distance](https://en.wikipedia.org/wiki/Vincenty%27s_formulae)</span>
<span class="hljs-string">instead of the Haversine distance, which is much more accurate but cumbersome to implement.  </span>
<span class="hljs-string">2. I would vectorize this function and make it more efficient overall.</span>
<span class="hljs-string">Because this dataset is only 7 rows long, it wasn't particularly important,</span>
<span class="hljs-string">but if this was a crucial function that was run in production, we would want to vectorize it for speed.</span>
<span class="hljs-string">"""</span>
</code></pre>
    <p class="normal">Alternatively, you<a id="_idIndexMarker393"/> could always just end with a statement about <a id="_idIndexMarker394"/>the preceding code and move on to the second question. At this point, our answer to <em class="italic">Question 1</em> is complete and should look similar to the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 9.7 – Taking user input  " src="../Images/B18444_10_07.png"/></figure>
    <p class="packt_figref">Figure 10.7: Taking user input</p>
    <p class="normal">We have now successfully answered <em class="italic">Question 1</em>! We can always check the distances between these airports by hand to obtain the same result. But let’s move on to the second question in our application.</p>
    <h2 class="heading-2" id="_idParaDest-117">Answering Question 2</h2>
    <p class="normal">The <a id="_idIndexMarker395"/>second question is far more straightforward and <a id="_idIndexMarker396"/>only asks for text responses. Here, the trick is to try to add some lists or Python objects in order to break up large paragraphs of text. To begin, we will explain our attempt at answering the question and then demonstrate how it might look inside a DataFrame:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">For this transformation, there are a few things</span>
<span class="hljs-string">that I would start with. First, I would have to define</span>
<span class="hljs-string">what a unique trip actually was. In order to do this, I would</span>
<span class="hljs-string">group by the origin, the destination, and the departure date</span>
<span class="hljs-string">(for the departure date, often customers will change around</span>
<span class="hljs-string">this departure date, so we should group by the date plus or</span>
<span class="hljs-string">minus at least 1 buffer day to capture all the correct dates).</span>
<span class="hljs-string">Additionally, we can see that often users search from an entire city,</span>
<span class="hljs-string">and then shrink the results down to a specific airport. So we should also</span>
<span class="hljs-string">consider a group of individual queries from cities and airports in the</span>
<span class="hljs-string">same city, as the same search, and do the same for the destination.</span>
<span class="hljs-string">From that point, we should add these important columns to each unique search.</span>
<span class="hljs-string">"""</span>
</code></pre>
    <p class="normal">Now, we can think of some columns that would be useful for when we are making a representation of when a user is searching for flights on this major US airline. We can put them into an example DataFrame, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">example_df = pd.DataFrame(columns=[<span class="hljs-string">'userid'</span>, <span class="hljs-string">'number_of_queries'</span>, <span class="hljs-string">'round_trip'</span>, <span class="hljs-string">'distance'</span>, <span class="hljs-string">'number_unique_destinations'</span>,
                     <span class="hljs-string">'number_unique_origins'</span>, <span class="hljs-string">'</span><span class="hljs-string">datetime_first_searched'</span>,<span class="hljs-string">'average_length_of_stay'</span>,
                     <span class="hljs-string">'length_of_search'</span>])
example_row = {<span class="hljs-string">'userid'</span>:<span class="hljs-number">98593</span>, <span class="hljs-string">'number_of_queries'</span>:<span class="hljs-number">5</span>, <span class="hljs-string">'round_trip'</span>:<span class="hljs-number">1</span>,
                   <span class="hljs-string">'distance'</span>:<span class="hljs-number">893</span>, <span class="hljs-string">'number_unique_destinations'</span>:<span class="hljs-number">5</span>,
                     <span class="hljs-string">'number_unique_origins'</span>:<span class="hljs-number">1</span>, <span class="hljs-string">'datetime_first_searched'</span>:<span class="hljs-string">'2015-01-09'</span>,
                   <span class="hljs-string">'average_length_of_stay'</span>:<span class="hljs-number">5</span>, <span class="hljs-string">'length_of_search'</span>:<span class="hljs-number">4</span>}
st.write(example_df.append(example_row, ignore_index=<span class="hljs-literal">True</span>))
</code></pre>
    <p class="normal">For the remainder of the question, we can add a bit of knowledge regarding how to find the distance between two points using different methods and then call it a day:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"""</span>
<span class="hljs-string">To answer the second part of the question, we should take the Euclidian distance</span>
<span class="hljs-string">on two normalized vectors. There are two solid options for comparing two</span>
<span class="hljs-string">entirely numeric rows, the euclidian distance (which is just the straight line</span>
<span class="hljs-string">difference between two values), and the Manhattan distance (think of this as the</span>
<span class="hljs-string">distance traveled if you had to use city blocks to travel diagonally across Manhattan).</span>
<span class="hljs-string">Because we have normalized data, and the data is not high-dimensional or sparse, I</span>
<span class="hljs-string">would recommend using the Euclidian distance to start off. This distance would tell</span>
<span class="hljs-string">us how similar two trips were.</span>
<span class="hljs-string">"""</span>
</code></pre>
    <p class="normal">The second <a id="_idIndexMarker397"/>question’s answer should be similar to the following <a id="_idIndexMarker398"/>screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 9.8 – Answering Question 2 " src="../Images/B18444_10_08.png"/></figure>
    <p class="packt_figref">Figure 10.8: Answering Question 2</p>
    <p class="normal">As you can<a id="_idIndexMarker399"/> see, this example demonstrates how to <a id="_idIndexMarker400"/>approach take-home data assignments with the help of the Streamlit library to make more impressive applications. The final step of this work is to deploy this Streamlit app and share the link with the recruiter. I would strongly advise you to deploy this on Heroku to guarantee that no one else can view the questions or the data that has been provided by the company. You can also take further precautions, such as putting a textbox at the beginning of the application that functions as a password protector (although certainly not a good password protector) for the application, as shown in the following code block:</p>
    <pre class="programlisting code"><code class="hljs-code">password_attempt = st.text_input(<span class="hljs-string">'Please Enter The Password'</span>)
<span class="hljs-keyword">if</span> password_attempt != <span class="hljs-string">'example_password'</span>:
     st.write(<span class="hljs-string">'Incorrect Password!'</span>)
     st.stop()
</code></pre>
    <p class="normal">Now, the entire<a id="_idIndexMarker401"/> application will not run unless the user inputs <code class="inlineCode">example_password</code> into the textbox. This is certainly not secure, but it is useful for relatively<a id="_idIndexMarker402"/> unimportant (at least, in terms of secrecy) applications such as a take-home application:</p>
    <figure class="mediaobject"><img alt="Figure 9.9 – Entering the password " src="../Images/B18444_10_09.png"/></figure>
    <p class="packt_figref">Figure 10.9: Entering the password</p>
    <p class="normal">As you <a id="_idIndexMarker403"/>can see, the only way for this application to load is if <a id="_idIndexMarker404"/>the correct password has been entered. Otherwise, the user will see a blank page.</p>
    <h1 class="heading-1" id="_idParaDest-118">Summary</h1>
    <p class="normal">This chapter is the most application-focused chapter we have created so far. We focused heavily on job applications and the application cycle for data science and machine learning interviews. Additionally, we learned how to password-protect our applications, how to create applications that prove to recruiters and data science hiring managers that we are the skilled data scientists that we know we are, and how to stand out in take-home data science interviews by creating Streamlit apps. The next chapter will focus on Streamlit as a toy, and you will learn how to create public-facing Streamlit projects for the community.</p>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/sl"><span class="url">https://packt.link/sl</span></a></p>
    <p class="normal"><img alt="" role="presentation" src="../Images/QR_Code13440134443835796.png"/></p>
  </div>
</body></html>