<html><head></head><body>
		<div id="_idContainer153">
			<h1 id="_idParaDest-119"><em class="italic"><a id="_idTextAnchor118"/>Chapter 8</em>: Calculating Data Frequency and Building Interactive Tables</h1>
			<p>All the chart types that we've explored so far displayed our data as is. In other words, every marker, whether it was a circle, a bar, a map, or any other shape, corresponded to a single data point in our dataset. <strong class="bold">Histograms</strong>, on the other hand, display bars that correspond to a summary statistic about <em class="italic">groups</em> of data points. A histogram is mainly used to count values in a dataset. It does so by grouping, or "binning," the data into bins and displaying the count of observations in each bin. Other functions are possible, of course, such as working out the mean or maximum, but counting is the typical use case. The counts are represented like a bar chart, where the heights of the bars correspond to the counts (or other function) of each bin. Another important result is that we also see how data is distributed, and what shape/kind of distribution we have. Are the observations concentrated around a certain point or more than one point? Are they skewed to the left or the right? This can give us an overview of this aspect of our data.</p>
			<p>Probability distributions are fundamental in statistics and crucial in getting an overview of our data. It is important to know how data values are spread in our sample or dataset, and where they are concentrated. If a dataset looks normally distributed, we might make different assumptions and have different expectations than if it were exponentially distributed. Histograms help in revealing the shape of the distribution of our data.</p>
			<p>We will also explore Dash's <strong class="bold">DataTable</strong> component in this chapter. This is a flexible, powerful, and feature-rich component that helps us with, among other things, displaying, filtering, and exporting tables of data.</p>
			<p>We will go through the following topics in this chapter: </p>
			<ul>
				<li>Creating a histogram</li>
				<li>Customizing the histogram by modifying its bins and using multiple histograms</li>
				<li>Adding interactivity to histograms</li>
				<li>Creating a 2D histogram</li>
				<li>Creating a DataTable</li>
				<li>Controlling the look and feel of the table (cell width, height, text display, and more)</li>
				<li>Adding histograms and tables to the app</li>
			</ul>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Technical requirements</h1>
			<p>We will use similar tools to the ones we used in the previous chapter with one addition. We will be using Plotly Express as well as the <strong class="source-inline">graph_objects</strong> module for creating our charts. The packages to use are Plotly, Dash, Dash Core Component, Dash HTML Components, Dash Bootstrap Components, pandas, and the new <strong class="source-inline">dash_table</strong> package. You don't need to install this separately (although you can), as it is installed together with Dash when you install it.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_08">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_08</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3sGSCes">https://bit.ly/3sGSCes</a>.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Creating a histogram</h1>
			<p>We want to see how we can get the distribution of a sample of data and get an idea of where values <a id="_idIndexMarker434"/>are concentrated, as well as how much variability/spread it has. We will do this by creating a histogram.</p>
			<p>As always, we'll start with the simplest possible example: </p>
			<ol>
				<li value="1">We open the <strong class="source-inline">poverty</strong> DataFrame and create a subset of it, containing only countries and data from the year 2015:<p class="source-code">import pandas as pd</p><p class="source-code">poverty = pd.read_csv('data/poverty.csv')</p><p class="source-code">df = poverty[poverty['is_country'] &amp; poverty['year'].eq(2015)]</p></li>
				<li>Import Plotly Express and run the <strong class="source-inline">histogram</strong> function with <strong class="source-inline">df</strong> as the argument to the <strong class="source-inline">data_frame</strong> parameter and the indicator of our choice for the <strong class="source-inline">x</strong> parameter: <p class="source-code">import plotly.express as px</p><p class="source-code">gini = 'GINI index (World Bank estimate)'</p><p class="source-code">px.histogram(data_frame=df, x=gini)</p><p>As a result, we get the histogram that you can see in <em class="italic">Figure 8.1</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B16780_08_1.jpg" alt="Figure 8.1 – A histogram of the Gini indicator"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A histogram of the Gini indicator</p>
			<p>The <em class="italic">x</em> axis was named using the indicator we chose, and the <em class="italic">y</em> axis was given the title <strong class="source-inline">count</strong>. This is the <a id="_idIndexMarker435"/>default function that the <strong class="source-inline">histogram</strong> function uses, and it is clear also from the hover box that we see when hovering over any of the bars. Here we learn that there are 18 countries whose Gini index was in the interval (<strong class="bold">35, 39.9</strong>) in the year 2015. We have previously visualized this indicator by country (visualizing each and every country), but this time, we are getting an idea of how many values are available in each bin and how those values are distributed. We can see that the majority of countries have a Gini index between 25 and 40 and that the numbers get progressively lower the higher the Gini index becomes. This is valid for this particular year only, of course.</p>
			<p>We are using the default number of bins, but we can modify it if we want. This is something that you typically want to interactively modify until you get a good view. In an interactive setting, such as in a dashboard, it's probably a good idea to allow users to modify the number of bins, especially if you don't know which metric they will choose and how the <a id="_idIndexMarker436"/>values are distributed for that metric. This is exactly our case in the dataset we are working with.</p>
			<p>Let's see the effect of changing the number of bins, as well as other available modifications.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Customizing the histogram by modifying its bins and using multiple histograms</h1>
			<p>We can <a id="_idIndexMarker437"/>change the number of bins through the <strong class="source-inline">nbins</strong> parameter. We will first see the effect of using two extreme values for the <a id="_idIndexMarker438"/>number of bins. Setting <strong class="source-inline">nbins=2</strong> generates the chart in <em class="italic">Figure 8.2</em>: </p>
			<p class="figure-caption">  </p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B16780_08_2.jpg" alt="Figure 8.2 – A histogram of the Gini indicator with two bins"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – A histogram of the Gini indicator with two bins</p>
			<p>As you can see, the values were split into two equal bins, (<strong class="bold">20, 39.9</strong>) and (<strong class="bold">40, 59.9</strong>), and we can see how many countries are in each bin. It's quite simple and easy to understand, but not as nuanced as the histogram in <em class="italic">Figure 8.1</em>. On the other hand, setting <strong class="source-inline">nbins=500</strong> produces the chart in <em class="italic">Figure 8.3</em>:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B16780_08_3.jpg" alt="Figure 8.3 – A histogram of the Gini indicator with 500 bins"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – A histogram of the Gini indicator with 500 bins</p>
			<p>It is now much more detailed, maybe more detailed than useful. When you set too many bins, it is almost like looking at the raw data.</p>
			<p>The default <a id="_idIndexMarker439"/>number of bins resulted in the bin size being intervals of five. Now that we know that our values range between 25 and 60 (45), we might want to see how the data is distributed across 45 bins. This makes the size of each bin 1. <em class="italic">Figure 8.4</em> shows the result of setting <strong class="source-inline">nbins=45</strong>:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B16780_08_4.jpg" alt="Figure 8.4 – A histogram of the Gini indicator with 45 bins"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – A histogram of the Gini indicator with 45 bins</p>
			<p>All the figures we created in this chapter so far were for the same dataset. You can see how different the distribution looks based on the selected number of bins. You can also think of it as looking at the distribution of the data with varying resolutions. There is usually an <a id="_idIndexMarker440"/>optimal resolution for your use case that can be manually tweaked until you find the most useful/insightful one for you. This is a major advantage of making histograms interactive, where you allow your users to explore as they see fit.</p>
			<p>Recall that we have a few categorical columns in our dataset and that we might use those columns to color our bars to get a more detailed view of the data. Let's see how this can be done.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Using color to further split the data</h2>
			<p>As you might have guessed, adding color to a Plotly Express chart is simply done by selecting <a id="_idIndexMarker441"/>a column from the DataFrame we are using. Setting <strong class="source-inline">color='Income Group'</strong> generates the chart you can see in <em class="italic">Figure 8.5</em>:</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B16780_08_5.jpg" alt="Figure 8.5 – A histogram of the Gini indicator colored by Income Group"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – A histogram of the Gini indicator colored by Income Group</p>
			<p>This is the exact same histogram but enriched by another dimension of the dataset. Each bar is split by <strong class="bold">Income Group</strong> and colored accordingly. We can now see for each bin how many countries there are from each income group.</p>
			<p>You can also see the effect of setting <strong class="source-inline">color='Region', color_discrete_sequence=px.colors.qualitative.Set1</strong> in <em class="italic">Figure 8.6</em>:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B16780_08_6.jpg" alt="Figure 8.6 – A histogram of the Gini indicator colored by Region"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – A histogram of the Gini indicator colored by Region</p>
			<p>Again, we have <a id="_idIndexMarker442"/>the same histogram, but colored using a different column, <strong class="bold">Region</strong> in this case. If you remember our discussion of bar charts in <a href="B16780_05_Final_NM_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 5</em></a>, <em class="italic">Interactively Comparing Values with Bar Charts and Dropdown Menus</em>, we saw that there are different ways of displaying bars. This can also be achieved using the <strong class="source-inline">barmode</strong> parameter. Let's explore how this applies to histograms.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You might have noticed that the bars in histograms are displayed in a connected manner, without any spaces between them as is the case in bar charts. This is a visual cue, to indicate the connected nature of histograms. The bins are arbitrary separation points that separate a group of observations from one another. As we saw, those can be selected differently, and result in quite different shapes. Bar charts are typically used for discrete or categorical variables and are typically displayed with some space between them to express this fact.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Exploring other ways of displaying multiple bars in histograms</h2>
			<p>The two <a id="_idIndexMarker443"/>previous histograms displayed the sub-bars in each bin stacked on top of one another. This makes sense, as those sub-bars represent a grouping of the data under the respective bin. In other words, they show the distribution of groups of countries for each bin.</p>
			<p>In some other cases, we might want to do the same thing but for two different years. In this case, having the bars stacked might give the false impression that the sub-bars correspond to portions of the same bin, whereas they correspond to the same bin but for different years. An example can show this more easily: </p>
			<ol>
				<li value="1">Create a subset of <strong class="source-inline">poverty</strong> that contains only countries and the range of years is <strong class="source-inline">[2010, 2015]</strong>: <p class="source-code">df = poverty[poverty['is_country'] &amp; poverty['year'].isin([2010, 2015])]</p></li>
				<li>Run the <strong class="source-inline">histogram</strong> function for the Gini index, coloring by <strong class="source-inline">year</strong> and setting <strong class="source-inline">barmode='group'</strong>: <p class="source-code">px.histogram(df, x=gini, color='year', <strong class="bold">barmode='group'</strong>)</p><p>This <a id="_idIndexMarker444"/>results in the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B16780_08_7.jpg" alt="Figure 8.7 – A histogram of the Gini indicator colored by year, with barmode set to &quot;group&quot;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – A histogram of the Gini indicator colored by year, with barmode set to "group"</p>
			<p>Because years represent a "before and after" view of the same metric and the same bin, I think it makes more sense to display them next to each other, so we can see how each bin value increased or decreased for the two, or more, selected years.</p>
			<p>There is another approach to the same issue if we are more interested in highlighting the change in the distribution as a whole. We can run the same function we just ran, but use facets in addition to color to split the histogram in two. The code is also straightforward and contains one more argument, as follows:</p>
			<p class="source-code">px.histogram(df, x=gini, color='year', <strong class="bold">facet_col='year'</strong>)</p>
			<p>This results in the following output:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B16780_08_8.jpg" alt="Figure 8.8 – A histogram of the Gini indicator colored and split by year"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – A histogram of the Gini indicator colored and split by year</p>
			<p>Again, the last two charts display the same information in two different ways. In <em class="italic">Figure 8.7</em>, it's very easy to compare how the count of countries for each bin changed from year to year. But it's a bit more difficult to see how the <em class="italic">distributions</em> have changed between <a id="_idIndexMarker445"/>the first and second years. The opposite is true for <em class="italic">Figure 8.8</em>. Note that we could also use <strong class="source-inline">facet_row</strong> as well, and this would have displayed the charts on top of one another. But we chose to display them next to each other because we are interested in comparing the heights of the bars, and it's much easier to do so when they are next to each other. Had we set <strong class="source-inline">orientation='h'</strong> (for horizontal), then it would have been easier to use <strong class="source-inline">facet_row</strong> in this case.</p>
			<p>Sometimes we might be more interested in the percentage of the number of values in a certain bin, as opposed to the absolute count for each bin. Getting this is also very simple. We just need to set <strong class="source-inline">histnorm='percent'</strong>. We start by creating a <strong class="source-inline">fig</strong> object and add the new option:</p>
			<p class="source-code">fig = px.histogram(df, x=gini, color='year', facet_col='year',</p>
			<p>We can also make it more explicit that we are displaying percentages by adding a tick suffix to the <em class="italic">y</em>-axis ticks. This can be achieved with the following code: </p>
			<p class="source-code">fig.layout.yaxis.ticksuffix = '%'</p>
			<p>We might also want to set a more descriptive title for the <em class="italic">y</em> axis, which can also be easily achieved using the following code:</p>
			<p class="source-code">fig.layout.yaxis.title = 'Percent of total'</p>
			<p>Running this modified code produces the chart in <em class="italic">Figure 8.9</em>:</p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B16780_08_9.jpg" alt="Figure 8.9 – A histogram of the Gini indicator colored and split by year, showing percentages"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – A histogram of the Gini indicator colored and split by year, showing percentages</p>
			<p>This chart <a id="_idIndexMarker446"/>looks identical to the one in <em class="italic">Figure 8.8</em>. The main difference is that the height of the bars represents the percentage and not the absolute count. This was also made clearer with tick suffixes and a <em class="italic">y</em>-axis title.</p>
			<p>We have explored quite a few options with histograms. Let's now make our histograms interactive and add a few other options.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Adding interactivity to histograms</h1>
			<p>Just like <a id="_idIndexMarker447"/>we did in <a href="B16780_07_Final_NM_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Map Plots and Enriching Your Dashboards with Markdown</em>, we can do the same with histograms. We can allow users to get a better idea about the distribution of a certain indicator in a certain year or more. The difference is that we want to allow them to customize the number of bins. Since we are now comfortable with handling multiple inputs and outputs, let's <a id="_idIndexMarker448"/>also add some more options for our users. We can also allow users to select multiple years and display multiple years on multiple sub-plots using faceting. <em class="italic">Figure 8.10</em> shows what we will be working toward to make it clear:</p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B16780_08_10.jpg" alt="Figure 8.10 – A histogram app allowing the selection of indicator, year(s), and bins"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – A histogram app allowing the selection of indicator, year(s), and bins</p>
			<p>Let's start building right away. We won't be discussing the layout elements such as color and width, but you can always refer to the code repository for the exact solution. We will focus on building the interactivity for this. Later on, we will add it to our app: </p>
			<ol>
				<li value="1">Make the necessary imports:<p class="source-code">from jupyter_dash import JupyterDash</p><p class="source-code">import dash_core_components as dcc</p><p class="source-code">import dash_html_components as html</p><p class="source-code">import dash_bootstrap_components as dbc</p><p class="source-code">from dash.dependencies import Output, Input</p></li>
				<li>Create an <strong class="source-inline">app</strong> object and its <strong class="source-inline">layout</strong> attribute:<p class="source-code">app = JupyterDash(__name__)</p><p class="source-code">app.layout = html.Div([])</p></li>
				<li>Add <strong class="source-inline">Label</strong> and <strong class="source-inline">Dropdown</strong> components as the first elements to the div just created. The <strong class="source-inline">Dropdown</strong> component displays the available indicators, and is the exact same <a id="_idIndexMarker449"/>one we created in <a href="B16780_07_Final_NM_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Map Plots and Enriching Your Dashboards with Markdown</em>:<p class="source-code">html.Div([</p><p class="source-code">    dbc.Label('Indicator:'),</p><p class="source-code">    dcc.Dropdown(id='hist_indicator_dropdown',</p><p class="source-code">                 index (World Bank estimate)',</p><p class="source-code">                 indicator, 'value': indicator}</p><p class="source-code">for indicator in poverty.columns[3:54]]),</p><p class="source-code">])</p></li>
				<li>Add a <strong class="source-inline">dbc.Label</strong> and a <strong class="source-inline">dcc.Dropdown</strong> component to the list in the div for indicating that the user can select a year and the actual years to be selected, allowing multiple selections. Note that since this dropdown allows multiple selection, its default value, if provided, needs to be provided as a list:<p class="source-code">dbc.Label('Years:'), dcc.Dropdown(id='hist_multi_year_selector',</p><p class="source-code">             <strong class="bold">value=[2015]</strong>,</p><p class="source-code">             one or more years',</p><p class="source-code">             year, 'value': year}</p><p class="source-code">                      for year in poverty['year'].drop_duplicates().sort_values()]),</p></li>
				<li>Again, to the same list in the div, we add another <strong class="source-inline">dbc.Label</strong> component and a <strong class="source-inline">dcc.Slider</strong> component that will allow users to modify the number of bins in the resulting histogram(s). Note that by not setting a default value, Plotly will provide the <a id="_idIndexMarker450"/>default number of bins based on the data being analyzed. It would show as <strong class="bold">0</strong> in the slider. Users are then free to modify it if they wish to do so:<p class="source-code">dbc.Label('Modify number of bins:'),</p><p class="source-code">dcc.Slider(id='hist_bins_slider',</p><p class="source-code">           min=0,</p><p class="source-code">           step=5,</p><p class="source-code">           marks={x: str(x) for x in range(0, 105, 5)}),</p></li>
				<li>Finally, we add a <strong class="source-inline">Graph</strong> component, and this will complete our layout: <p class="source-code">dcc.Graph(id='indicator_year_histogram')</p></li>
			</ol>
			<p>Running these steps creates our app's visible part (the layout) without any functionality. The default looks as in <em class="italic">Figure 8.11</em>, and I'll leave it to you to modify the colors, alignment, and relative positioning, using the knowledge we built in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>:</p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B16780_08_11.jpg" alt="Figure 8.11 – The default view of the histogram app with no functionality"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – The default view of the histogram app with no functionality</p>
			<p>We'll now go <a id="_idIndexMarker451"/>on to build the interactivity. In this case, we need to build a function that takes three inputs (the indicator dropdown, the years dropdown, and the bins slider). It will return a <strong class="source-inline">Figure</strong> object, which will modify the chart at the bottom of the figure:</p>
			<ol>
				<li value="1">Create the callback. There is nothing special here; we just make sure to have the IDs show that they are related to the histogram:<p class="source-code">@app.callback(Output('indicator_year_histogram', 'figure'),</p><p class="source-code">              Input('hist_multi_year_selector', 'value'),</p><p class="source-code">              Input('hist_indicator_dropdown', 'value'),</p><p class="source-code">              Input('hist_bins_slider', 'value'))</p></li>
				<li>Create the function that generates our histogram using the inputs just created. We first check that neither <strong class="source-inline">year</strong> nor <strong class="source-inline">indicator</strong> is provided, in which case we <strong class="source-inline">raise PreventUpdate</strong>:<p class="source-code">def display_histogram(years, indicator, nbins):</p><p class="source-code">    if (not years) or (not indicator):</p><p class="source-code">        raise PreventUpdate</p></li>
				<li>Create a sub-set, <strong class="source-inline">df</strong>, by selecting countries only, as well as getting rows where the year is in the provided <strong class="source-inline">years</strong> argument:<p class="source-code">df = poverty[poverty['year'].isin(years) &amp; poverty['is_country']]</p></li>
				<li>We are now ready to create the figure, which is done by calling the <strong class="source-inline">histogram</strong> function. As we saw in this chapter, we provide <strong class="source-inline">df</strong> to the <strong class="source-inline">data_frame</strong> parameter, <strong class="source-inline">indicator</strong> for the <strong class="source-inline">x</strong> parameter, and <strong class="source-inline">year</strong> to <strong class="source-inline">color</strong>. The title of the figure will <a id="_idIndexMarker452"/>be set by concatenating the indicator with the <strong class="source-inline">Histogram</strong> string. The <strong class="source-inline">nbins</strong> parameter will take the <strong class="source-inline">nbins</strong> value selected by the user from the slider. For facets, we use the <strong class="source-inline">year</strong> column. Since we don't know how many years users will select, and we don't want them to end up creating a difficult-to-read chart, we set <strong class="source-inline">facet_col_wrap=4</strong>. This will ensure that each row of charts will contain no more than four, and the following one will be added to the next row of charts:<p class="source-code">fig = px.histogram(df,</p><p class="source-code">                   color='year',</p><p class="source-code">                   + ' Histogram',</p><p class="source-code">                   facet_col='year',</p><p class="source-code">                   height=700)</p></li>
				<li>A new and interesting option that we haven't covered so far is the <strong class="source-inline">for_each_xaxis</strong> attribute. Note that this is only one of several <strong class="source-inline">for_each_</strong> attributes, which you can explore separately. This is useful in situations where the number of <em class="italic">x</em>-axis attributes is not known, such as in this case, or simply when multiple attributes exist. By default, every facet (or sub-plot) will have its own <em class="italic">x</em>-axis title. As you know, there are many indicator names that are very long and will overlap in this case. To eliminate this, we set all <strong class="source-inline">xaxis</strong> titles to an empty string:<p class="source-code"><strong class="bold">fig.for_each_xaxis(lambda axis: axis.update(title=''))</strong></p></li>
				<li>To replace the deleted <em class="italic">x</em>-axis titles, we can create an annotation instead. The annotation is a simple string that can easily be added with the <strong class="source-inline">add_annotation</strong> method. Because we want the <strong class="source-inline">X</strong> position of the annotation to be at the center of the figure, we set its <strong class="source-inline">x</strong> value to <strong class="source-inline">0.5</strong>. Also, because we want the <strong class="source-inline">Y</strong> position to be slightly below the plot area, we set the <strong class="source-inline">y</strong> value to <strong class="source-inline">-0.12</strong>. Now, it's important to indicate to Plotly the meaning of those numbers we provide, or their reference. We can use the <strong class="source-inline">xref</strong> and <strong class="source-inline">yref</strong> parameters to indicate that these values should take <strong class="source-inline">paper</strong> as their reference. This means to take these points as fractions of the plot and not as data points, like in scatter plots, for example. This is useful <a id="_idIndexMarker453"/>because those annotations will serve as axis titles, and so we want their position to be fixed. By default, annotations come with arrows pointing to the point selected. We can remove that by setting <strong class="source-inline">showarrow=False</strong>, as follows:<p class="source-code">fig.add_annotation(text=indicator,</p><p class="source-code">                   y=-0.12,</p><p class="source-code">                   <strong class="bold">yref='paper'</strong>,</p></li>
			</ol>
			<p>The following is the full code of the function to make it clearer:</p>
			<p class="source-code">@app.callback(Output('indicator_year_histogram', 'figure'),</p>
			<p class="source-code">              Input('hist_multi_year_selector', 'value'),</p>
			<p class="source-code">              Input('hist_indicator_dropdown', 'value'),</p>
			<p class="source-code">              Input('hist_bins_slider', 'value'))</p>
			<p class="source-code">def display_histogram(years, indicator, nbins):</p>
			<p class="source-code">    if (not years) or (not indicator):</p>
			<p class="source-code">        raise PreventUpdate</p>
			<p class="source-code">    df = poverty[poverty['year'].isin(years) &amp; poverty['is_country']]</p>
			<p class="source-code">    fig = px.histogram(df,</p>
			<p class="source-code">                       color='year', </p>
			<p class="source-code">                       + ' Histogram',</p>
			<p class="source-code">                       facet_col='year',</p>
			<p class="source-code">                       height=700)</p>
			<p class="source-code">    fig.for_each_xaxis(lambda axis: axis.update(title=''))</p>
			<p class="source-code">    fig.add_annotation(text=indicator, </p>
			<p class="source-code">                       y=-0.12, </p>
			<p class="source-code">                       yref='paper',</p>
			<p class="source-code">                       fig</p>
			<p>With this, we have <a id="_idIndexMarker454"/>created an independent app that can run in JupyterLab. I encourage you to fully run it and see whether you come across issues, and to also customize and make some changes to it.</p>
			<p>So far, we have explored how to visualize the counts and distributions of values for a single set of observations. There is also an interesting way to explore two sets of observations at the same time, which can be done using a 2D histogram.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Creating a 2D histogram</h1>
			<p>In the first case, we basically counted the observations in each bin of our dataset. In this case, we will <a id="_idIndexMarker455"/>do the same but for <em class="italic">combinations</em> of bins for both datasets. The bins for each variable will end up creating a matrix. A simple example can make this easy. Let's create one and see:</p>
			<ol>
				<li value="1">Create a subset of <strong class="source-inline">poverty</strong> containing only countries, where the year is equal to <strong class="source-inline">2000</strong>:<p class="source-code">df = poverty[poverty['year'].eq(2000) &amp; poverty['is_country']]</p></li>
				<li>Create a <strong class="source-inline">Figure</strong> object and add a <strong class="source-inline">histogram2d</strong> trace (at the time of writing, this chart type is not available in Plotly Express). We simply select any two indicators that we would like to plot together and pass them to <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>: <p class="source-code">fig = go.Figure()</p><p class="source-code">fig.add_histogram2d(x=df['Income share held by fourth 20%'],</p><p class="source-code">                    y=df['GINI index (World Bank estimate)'],</p><p class="source-code">                    colorscale='cividis')</p></li>
				<li>Add titles for the <em class="italic">x</em> and <em class="italic">y</em> axes: <p class="source-code">fig.layout.xaxis.title = 'Income share held by fourth 20%'</p><p class="source-code">fig.layout.yaxis.title = 'GINI index (World Bank estimate)'</p><p class="source-code">fig.show()</p></li>
			</ol>
			<p>Running <a id="_idIndexMarker456"/>the preceding code generates the chart in <em class="italic">Figure 8.12</em>:</p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B16780_08_12.jpg" alt="Figure 8.12 – A 2D histogram"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – A 2D histogram</p>
			<p>The frequency of values is expressed in a different way here. With a 1D histogram, the height of the bars represents the frequency of values in the respective bin. In a 2D histogram, the "height" is expressed using a continuous color scale. We can see from the color bar that the counts range from 0 to 10, and that the bin combination with the most values is the <strong class="bold">x</strong> interval (<strong class="bold">22, 22.9</strong>) and the <strong class="bold">y</strong> interval (<strong class="bold">30, 39.9</strong>), with a <strong class="bold">z</strong> value (height) of <strong class="bold">10</strong>. Generally, <em class="italic">z</em> is used to refer to the third dimension, and so this can also be thought of as the height of this rectangle.</p>
			<p>Note that this is different from using a scatter plot for two variables. In that case, we would be interested in seeing a correlation between the two variables, or at least how they both vary. In this case, we are trying to identify where the most frequent observations are, across two variables, and under which combination of bins.</p>
			<p>There are <a id="_idIndexMarker457"/>still many options that you can explore with histograms, or visualizing distributions and counts in general. We have explored many of those options, and now we'll turn to explore another interactive component that is available in Dash, the DataTable.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Creating a DataTable</h1>
			<p>Technically, <strong class="source-inline">dash_table</strong> is a separate package, as mentioned at the beginning of the c<a id="_idTextAnchor127"/>hapter, and <a id="_idIndexMarker458"/>can be installed separately. It is installed automatically with Dash, the correct, up-to-date version, which is the recommended approach.</p>
			<p>Many times, displaying tables, especially if they are interactive, can add a lot of value to users of our dashboards. Also, if our dashboards or data visualizations are not sufficient for users, or if they want to run their own analysis, it is probably a good idea to allow them to get the raw data for that. Finally, the <strong class="source-inline">DataTable</strong> component allows its own data visualization through custom coloring, fonts, sizes, and so on. So, we have another way to visualize and understand our data through tables. We will explore a few options in this chapter, but definitely not all of them.</p>
			<p>Let's see how we can create a simple DataTable in a simple app using a DataFrame:</p>
			<ol>
				<li value="1">Create a subset of <strong class="source-inline">poverty</strong> containing only countries, from the year 2000, and containing columns that have <strong class="source-inline">Country Name</strong> or have the income share of the top and bottom 10% of the population. We use the <strong class="source-inline">filter</strong> method with a regular expression to achieve that:<p class="source-code">df = poverty[poverty['year'].eq(2000)&amp;poverty['is_country']].filter(regex='Country Name|Income share.*10')</p></li>
				<li>Create an app in JupyterLab with a <strong class="source-inline">layout</strong> attribute: <p class="source-code">app = JupyterDash(__name__, external_stylesheets=[dbc.themes.COSMO])</p><p class="source-code">app.layout = html.Div([])</p></li>
				<li>Pass a <strong class="source-inline">DataTable</strong> object to the div just created. As a minimum, a table requires values for the <strong class="source-inline">data</strong> parameter, as well as the <strong class="source-inline">columns</strong> parameter. One of the easiest ways to do this is by providing a dictionary converted from a DataFrame, using the <strong class="source-inline">to_dict('records')</strong> method. <strong class="source-inline">columns</strong> needs to be a list of dictionaries, where each dictionary contains the <strong class="source-inline">name</strong> and <strong class="source-inline">id</strong> keys. The name is what appears to users, and the ID is the value that will actually be used:<p class="source-code">DataTable(data=df.to_dict('records'),</p><p class="source-code">          columns=[{'name': col, 'id': col}</p><p class="source-code">                   col in df.columns])</p></li>
			</ol>
			<p>Running this <a id="_idIndexMarker459"/>simple app with <strong class="source-inline">app.run_server()</strong> produces a table as you can see in <em class="italic">Figure 8.13</em>, showing the first few rows:</p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B16780_08_13.jpg" alt="Figure 8.13 – A simple DataTable"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – A simple DataTable</p>
			<p>Many times, your tables or column headers might not fit neatly in the container they are placed in. For example, in our case, many indicator names are extremely long, and their columns contain <a id="_idIndexMarker460"/>numbers that don't take much horizontal space. Let's explore some of the available options to handle this.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Controlling the look and feel of the table (cell width, height, text display, and more)</h1>
			<p>There are numerous options available to modify how your tables look, and it's always good to <a id="_idIndexMarker461"/>consult the documentation for ideas and solutions. The potentially tricky part is when you have combinations of options. In some cases, these might modify each other and not be displayed exactly the way you want. So, it is always good to isolate the options as much as possible when debugging.</p>
			<p>In <em class="italic">Figure 8.13</em>, we displayed only three columns and the first few rows. We will now see how to display more columns and enable users to explore more rows:</p>
			<ol>
				<li value="1">Modify <strong class="source-inline">df</strong> to include all columns that contain <strong class="source-inline">Income share</strong>:<p class="source-code">df = poverty[poverty['year'].eq(2000)&amp;poverty['is_country']].filter(regex='Country Name|Income share')</p></li>
				<li>Place the DataTable in a <strong class="source-inline">dbc.Col</strong> component with the desired width, <strong class="source-inline">7</strong> in this case. The table automatically takes the width of the container it is in, so this would set its width implicitly:<p class="source-code">dbc.Col([], lg=7)</p></li>
				<li>We now want to determine how the column headers will behave, especially as they have quite long names. This can be achieved with the <strong class="source-inline">style_header</strong> parameter. Note that there are several <strong class="source-inline">style_</strong> parameters for headers, cells, and tables, and they also have <strong class="source-inline">_conditional</strong> variants, for example, <strong class="source-inline">style_cell_conditional</strong>, to conditionally set the style of cells. We now specify the header style with the following option, to allow text to overflow into multiple lines when/if needed:<p class="source-code">style_header={'whiteSpace': 'normal'}</p></li>
				<li>We now want to make sure that while scrolling, the headers remain fixed in place:<p class="source-code">fixed_rows={'headers': True}</p></li>
				<li>In order to control the height of the table as a whole, we can simply do so with the following parameter:<p class="source-code">style_table={'height': '400px'}</p></li>
				<li>In cases where we have thousands of rows, it might be heavy and affect the performance of the page, so we can use <strong class="source-inline">virtualization</strong>. In our case, it is a very small table, but we can set <strong class="source-inline">virtualization</strong> to demonstrate its usage:<p class="source-code">virtualization=True</p></li>
			</ol>
			<p>Putting <a id="_idIndexMarker462"/>the code together, here is the full code to generate the table:</p>
			<p class="source-code">dbc.Col([</p>
			<p class="source-code">    DataTable(data=df.to_dict('records'),</p>
			<p class="source-code">              columns=[{'name': col, 'id': col}</p>
			<p class="source-code">                       col in df.columns],</p>
			<p class="source-code">              style_header={'whiteSpace': 'normal'},</p>
			<p class="source-code">              fixed_rows={'headers': True},</p>
			<p class="source-code">              virtualization=True,</p>
			<p class="source-code">              style_table={'height': '400px'})</p>
			<p class="source-code">], lg =7),</p>
			<p>Running this modified code produces the table in <em class="italic">Figure 8.14</em>:</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B16780_08_14.jpg" alt="Figure 8.14 – A DataTable with custom options for width, height, scrolling, and virtualization"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – A DataTable with custom options for width, height, scrolling, and virtualization</p>
			<p>The scroll bar is only visible if the cursor is pointing there. It was kept for demonstration, and to <a id="_idIndexMarker463"/>make it clear that scrolling is enabled. Now users can see all the available rows by scrolling as much as they want. We will now see how to incorporate some interactivity with tables and add this to our app. We'll also use this as an opportunity to demonstrate a few other options available to the DataTable component.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor129"/>Adding histograms and tables to the app</h1>
			<p>We are now ready to incorporate the table functionality into our app and add it to the callback <a id="_idIndexMarker464"/>function that we already created. What we will do is display <a id="_idIndexMarker465"/>the data that is used to generate the histograms right under the histogram figure. Since the histograms don't show data points as we discussed (only aggregates), it might be interesting for users to see for themselves if they wish.</p>
			<p>Let's add this functionality right away:</p>
			<ol>
				<li value="1">Add a new div right underneath the histogram figure:<p class="source-code">html.Div(id='table_histogram_output')</p></li>
				<li>Add this as an <strong class="source-inline">Output</strong> to the callback function:<p class="source-code">@app.callback(Output('indicator_year_histogram', 'figure'),</p><p class="source-code">              <strong class="bold">Output('table_histogram_output', 'children')</strong>,</p><p class="source-code">              Input('hist_multi_year_selector', 'value'),</p><p class="source-code">              Input('hist_indicator_dropdown', 'value'),</p><p class="source-code">              Input('hist_bins_slider', 'value'))</p></li>
				<li>Right after we finish the definition of our <strong class="source-inline">Figure</strong> object, we add the definition of our DataTable. We will be using the same options as before and adding a few new ones. We first add the ability to sort columns:<p class="source-code">sort_action='native'</p></li>
				<li>Now, we <a id="_idIndexMarker466"/>add the ability to filter columns. This will add <a id="_idIndexMarker467"/>an empty box right under each column header. Users can enter text and hit <em class="italic">Enter</em> to get a filtered table:<p class="source-code">filter_action='native'</p></li>
				<li>Add the ability to export the table to CSV format:<p class="source-code">export_format='csv'</p></li>
				<li>We set a minimum width for cells to keep it consistent and avoid any formatting issues due to different columns' headers:<p class="source-code">style_cell={'minWidth': '150px'}</p></li>
				<li>Finally, add the table to the <strong class="source-inline">return</strong> statement at the end of the function, so it returns two items instead of one: <p class="source-code">return fig, table</p></li>
			</ol>
			<p>As a result of adding this functionality, our updated app will contain the table that is being used to generate the histograms, and users can export it or interact with it if they want. <em class="italic">Figure 8.15</em> shows our app with the additional customized DataTable:</p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B16780_08_15.jpg" alt="Figure 8.15 – A DataTable showing the data used to generate the histograms"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – A DataTable showing the data used to generate the histograms</p>
			<p>We now have an <strong class="bold">Export</strong> button, which is clear and immediately triggers the download functionality in the browser. Header names now have arrows that allow users to sort, in an ascending or descending manner. You can also see the filtering option, with the <strong class="bold">filter data…</strong> placeholder text, which users can filter by.</p>
			<p>Now, in order <a id="_idIndexMarker468"/>to incorporate this functionality into our app, we simply have to copy the components where we want them to appear. As this can be thought <a id="_idIndexMarker469"/>of as exploratory functionality (users are still not digging deep into an indicator), it's probably good to have it under the map chart.</p>
			<p>To add the interactivity, we only have to add the callback function that we created, as we always do, after the layout of the app.</p>
			<p>We have already done this many times, and it should be straightforward for you to do so.</p>
			<p>Our app is now getting really rich. We have two main exploratory interactive charts at the top. The maps allow users to select a metric and see its variation across countries on the map. They can also select the year and/or allow it to play like a video. The selected indicator triggers the display of descriptive text about it, for more context to users. Under that, we have the option of selecting an indicator and one or more years, to see how this indicator is distributed with histograms. Users can modify the number of bins to get an optimal view. This also updates the table they can interact with and export.</p>
			<p>After having <a id="_idIndexMarker470"/>explored the indicators of interest, users can go <a id="_idIndexMarker471"/>on to explore specific indicators using the three specialized charts that we created.</p>
			<p>Congratulations! We have now completed <em class="italic">Part 2 </em>of the book, so it's good to review what we have done in the chapter, as well as <em class="italic">Part 2</em>, and get ready for <em class="italic">Part 3</em>.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor130"/>Summary</h1>
			<p>In this chapter, we first learned about the main difference between histograms and the other types of charts we have covered so far. We saw how easy it is to create them, and more importantly, we saw how customizable they can be with bins, <strong class="source-inline">barmode</strong>, colors, and facets. We then explored how to add interactivity to histograms by connecting them to other components with a callback function.</p>
			<p>We then explored the 2D histogram and saw how it can provide an even richer view of two columns visualized against each other.</p>
			<p>We introduced a new interactive component, the DataTable. We barely scratched the surface of what can be done with tables. We used them to make it easier for users to obtain, interact with, or simply view the raw data behind our histograms. We also explored the different ways to control the look and feel of our tables.</p>
			<p>Finally, we incorporated the table functionality with the callback function we created and added the interactivity to our app.</p>
			<p>Let's now take a quick look at what we have covered so far in the book and prepare for <em class="italic">Part 3</em>.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor131"/>What we have covered so far</h1>
			<p>In the first part of the book, we covered the basics of Dash apps. We first explored how they are structured and how to manage the visual elements. Then, we explored how interactivity is created, which is mainly by using callback functions. This allowed us to create fully interactive apps. We then explored the structure of the <strong class="source-inline">Figure</strong> object and learned how to modify and manipulate it to generate the charts we desire. After that, we saw how important data manipulation and preparation are for data visualization. We went through a reshaping of our dataset, to make things more intuitive to work with. This paved the way for easily learning and using Plotly Express.</p>
			<p><em class="italic">Part 2</em> was about getting thoroughly familiar with several types of charts, as well as interactive components. We implemented all the knowledge we built in <em class="italic">Part 1</em>, but most importantly, we did this in a practical setting. We gradually added more and more charts, components, and functionality to one app. At every step, we had to consider how it will affect the whole app and had to make sure we did so with a holistic view. You are now very familiar with making changes to many types of functionality. Although we didn't cover every type of chart and component, the general principles are similar, and you can easily adapt the knowledge you have to new situations.</p>
			<p><em class="italic">Part 3</em> will move on to more general topics about apps, URLs, advanced callbacks, and deployment. But the next chapter will explore a few <strong class="bold">machine learning</strong> options. Our dataset contains many countries, years, and indicators, and the number of possible combinations to explore is massive. So, we will explore a few techniques that can help uncover trends or correlations in our data.</p>
		</div>
	</body></html>