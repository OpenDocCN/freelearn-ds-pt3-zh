<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-99" class="chapter-number"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.2.1">Data Transformation – Merging and Concatenating</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">Understanding how to transform and manipulate data is crucial for unlocking valuable insights. </span><span class="koboSpan" id="kobo.3.2">Techniques such as joining, merging, and appending allow us to blend information from various sources and organize and analyze subsets of data. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we’ll learn how to merge multiple datasets into a single dataset and explore the various techniques that we can use. </span><span class="koboSpan" id="kobo.3.4">We’ll understand how to avoid duplicate values while merging datasets and some tricks to improve the process of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">merging datasets.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
			<ul>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">Joining datasets</span></span></li>
				<li><span class="koboSpan" id="kobo.8.1">Handling duplicates when </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">merging datasets</span></span></li>
				<li><span class="koboSpan" id="kobo.10.1">Performance tricks </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">for merging</span></span></li>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Concatenating DataFrames</span></span></li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.14.1">You can find all the code for the chapter at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">link: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/tree/main/chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/tree/main/chapter05</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.18.1">Each section is followed by a script with a similar naming convention, so feel free to execute the scripts and/or follow along by reading </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">the chapter.</span></span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.20.1">Joining datasets</span></h1>
			<p><span class="koboSpan" id="kobo.21.1">In data</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.22.1"> analysis projects, it is common to encounter data that is spread across multiple sources or datasets. </span><span class="koboSpan" id="kobo.22.2">Each dataset may contain different pieces of information related to a common entity or subject. </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Data merging</span></strong><span class="koboSpan" id="kobo.24.1">, also</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.25.1"> known as data joining or </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.26.1">data concatenation, is the process of combining these separate datasets into a single cohesive dataset. </span><span class="koboSpan" id="kobo.26.2">In data analysis projects, it’s common to encounter situations where information about a particular subject or entity is spread across multiple datasets. </span><span class="koboSpan" id="kobo.26.3">For instance, imagine you’re analyzing customer data for a retail business. </span><span class="koboSpan" id="kobo.26.4">You might have one dataset containing customer demographics, such as names, ages, and addresses, and another dataset with </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.27.1">their purchase history, such as transaction dates, items bought, and total spending. </span><span class="koboSpan" id="kobo.27.2">Each of these datasets provides valuable insights but, individually, they don’t give a complete picture of customer behavior. </span><span class="koboSpan" id="kobo.27.3">To gain a comprehensive understanding, you need to combine these datasets. </span><span class="koboSpan" id="kobo.27.4">By merging the customer demographics with their purchase history based on a common identifier, such as a customer ID, you create a single dataset that allows for richer analysis. </span><span class="koboSpan" id="kobo.27.5">For example, you could identify patterns such as which age groups are buying specific products or how spending habits vary </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">by location.</span></span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.29.1">Choosing the correct merge strategy</span></h2>
			<p><span class="koboSpan" id="kobo.30.1">Choosing </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.31.1">the correct join type is crucial as it determines which rows from the input DataFrames are included in the joined output. </span><span class="koboSpan" id="kobo.31.2">Python’s pandas library provides several join types, each with different behaviors. </span><span class="koboSpan" id="kobo.31.3">Let’s introduce the use case example we are going to work on in this chapter and then expand on the different types </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">of joins.</span></span></p>
			<p><span class="koboSpan" id="kobo.33.1">In this chapter, our use case involves employee data and project assignments for a company managing its workforce and projects. </span><span class="koboSpan" id="kobo.33.2">You can execute the following script to see the DataFrames in more </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">detail: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/1.use_case.py"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/1.use_case.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.37.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">employee_data</span></strong><span class="koboSpan" id="kobo.39.1"> DataFrame represents employee details, such as their names and departments, as </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">presented here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.41.1">
   employee_id     name department
0            1    Alice         HR
1            2      Bob         IT</span></pre>			<p><span class="koboSpan" id="kobo.42.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">project_data</span></strong><span class="koboSpan" id="kobo.44.1"> DataFrame contains information about project assignments, including the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">project names:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
   employee_id project_name
0            2     ProjectA
1            3     ProjectB</span></pre>			<p><span class="koboSpan" id="kobo.47.1">In the following</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.48.1"> sections, we will discuss the different DataFrame merging options, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">inner join.</span></span></p>
			<h3><span class="koboSpan" id="kobo.50.1">Inner merge</span></h3>
			<p><span class="koboSpan" id="kobo.51.1">The inner merge </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.52.1">returns only the rows that have matching values </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.53.1">in both DataFrames for the specified join columns. </span><span class="koboSpan" id="kobo.53.2">It’s very important to note </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the following:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.55.1">Rows with non-matching keys in either DataFrame will be excluded from the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">merged output</span></span></li>
				<li><span class="koboSpan" id="kobo.57.1">Rows with missing values in the key columns will be excluded from the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">merged result</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.59.1">The result of an inner merge is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">following figure:</span></span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<span class="koboSpan" id="kobo.61.1"><img src="image/B19801_05_1.jpg" alt="Figure 5.1 – Inner merge"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.62.1">Figure 5.1 – Inner merge</span></p>
			<p><span class="koboSpan" id="kobo.63.1">Let’s have a look at how we can achieve the preceding result using the pandas </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">merge</span></strong><span class="koboSpan" id="kobo.65.1"> function, using the example presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">previous section:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
merged_data = pd.merge(employee_data, project_data, on='employee_id', how='inner')</span></pre>			<p><span class="koboSpan" id="kobo.68.1">As we see in the preceding code snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">pd.merge()</span></strong><span class="koboSpan" id="kobo.70.1"> function is used to merge the two DataFrames. </span><span class="koboSpan" id="kobo.70.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">on='employee_id'</span></strong><span class="koboSpan" id="kobo.72.1"> argument specifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">employee_id</span></strong><span class="koboSpan" id="kobo.74.1"> column should be used as the key on which to join the DataFrames. </span><span class="koboSpan" id="kobo.74.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">how='inner'</span></strong><span class="koboSpan" id="kobo.76.1"> argument specifies that an inner join should be performed. </span><span class="koboSpan" id="kobo.76.2">This type of join returns only the rows that have matching values in both DataFrames, which, in this case, are the rows where </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">employee_id</span></strong><span class="koboSpan" id="kobo.78.1"> matches in both </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">employee_data</span></strong><span class="koboSpan" id="kobo.80.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">project_data</span></strong><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">In the following table, you can see the output of the inner join of the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">two DataFrames:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.84.1">
   employee_id     name department project_name
0            2      Bob         IT     ProjectA
1            3  Charlie  Marketing     ProjectB
2            4    David    Finance     ProjectC
3            5      Eva         IT     ProjectD</span></pre>			<p><span class="koboSpan" id="kobo.85.1">This </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.86.1">approach ensures </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.87.1">that the data from both DataFrames is combined based </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.88.1">on a </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">common key</span></strong><span class="koboSpan" id="kobo.90.1">, with rows included only when there is a match across both DataFrames, adhering to the principles of an </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">inner join.</span></span></p>
			<p><span class="koboSpan" id="kobo.92.1">If this is still not clear, in the following list, we present specific examples from the data world where an inner </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.93.1">merge </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">is crucial:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.95.1">Match tables</span></strong><span class="koboSpan" id="kobo.96.1">: Inner joins are ideal when you need to match data from different tables. </span><span class="koboSpan" id="kobo.96.2">For example, if you have a table of employees and another table of department names, you can use an inner join to match each employee with their </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">respective department.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.98.1">Data filtering</span></strong><span class="koboSpan" id="kobo.99.1">: Inner joins can act as a filter to exclude rows that do not have corresponding entries in both tables. </span><span class="koboSpan" id="kobo.99.2">This is useful in scenarios where you only want to consider records that have complete data across multiple tables. </span><span class="koboSpan" id="kobo.99.3">For instance, matching customer orders with product details only where both </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">records exist.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Efficiency in query execution</span></strong><span class="koboSpan" id="kobo.102.1">: Since inner joins only return rows with matching values in both tables, they can be more efficient in terms of query execution time compared to outer joins, which need to check for and handle non-matching entries </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">as well.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.104.1">Reducing data duplication</span></strong><span class="koboSpan" id="kobo.105.1">: Inner joins help in reducing data duplication by only returning matched rows, thus ensuring that the data in the result set is relevant and </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">not redundant.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.107.1">Simplifying complex queries</span></strong><span class="koboSpan" id="kobo.108.1">: When dealing with multiple tables, inner joins can be used to </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.109.1">simplify queries by reducing the number of rows to be examined and processed in subsequent query operations. </span><span class="koboSpan" id="kobo.109.2">This is particularly useful in complex database schemas where multiple tables </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">are interrelated.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.111.1">Moving from an </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.112.1">inner join to an outer join expands the scope of the merged data, incorporating all available rows from both datasets, even if they don’t have </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">corresponding matches.</span></span></p>
			<h3><span class="koboSpan" id="kobo.114.1">Outer merge</span></h3>
			<p><span class="koboSpan" id="kobo.115.1">The </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.116.1">outer merge (also known as full outer join) returns all the rows </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.117.1">from both DataFrames, combining the matching rows as well as the non-matching rows. </span><span class="koboSpan" id="kobo.117.2">The full outer join ensures that no data is lost from either DataFrame, but it can introduce NaN values where there are unmatched rows in </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">either DataFrame.</span></span></p>
			<p><span class="koboSpan" id="kobo.119.1">The result of an outer merge is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">following figure:</span></span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<span class="koboSpan" id="kobo.121.1"><img src="image/B19801_05_2.jpg" alt="Figure 5.2 – Outer merge"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.122.1">Figure 5.2 – Outer merge</span></p>
			<p><span class="koboSpan" id="kobo.123.1">Let’s have a look at how we can achieve the preceding result using the pandas </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">merge</span></strong><span class="koboSpan" id="kobo.125.1"> function, using the example presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">previous section:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.127.1">
full_outer_merged_data = pd.merge(employee_data, project_data, on='employee_id', how='outer')</span></pre>			<p><span class="koboSpan" id="kobo.128.1">As we see in the preceding code snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">pd.merge()</span></strong><span class="koboSpan" id="kobo.130.1"> function is used to merge the two DataFrames. </span><span class="koboSpan" id="kobo.130.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">on='employee_id'</span></strong><span class="koboSpan" id="kobo.132.1"> argument specifies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">employee_id</span></strong><span class="koboSpan" id="kobo.134.1"> column should be used as the key on which to merge the DataFrames. </span><span class="koboSpan" id="kobo.134.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">how='outer'</span></strong><span class="koboSpan" id="kobo.136.1"> argument specifies that a full outer join should be performed. </span><span class="koboSpan" id="kobo.136.2">This type of join returns all rows from both DataFrames, filling in </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">NaN</span></strong><span class="koboSpan" id="kobo.138.1"> where there is no match. </span><span class="koboSpan" id="kobo.138.2">In the following table, you can see the output of the outer join of the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">two DataFrames:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
   employee_id     name  department  project_name
0            1    Alice          HR           NaN
1            2      Bob          IT      ProjectA
2            3  Charlie   Marketing      ProjectB
3            4    David     Finance      ProjectC
4            5      Eva          IT      ProjectD
5            6      NaN         NaN      ProjectE</span></pre>			<p><span class="koboSpan" id="kobo.141.1">This </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.142.1">approach ensures that the data from both DataFrames is </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.143.1">combined, allowing for a comprehensive view of all available data, even if some of it is incomplete due to mismatches between </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">the DataFrames.</span></span></p>
			<p><span class="koboSpan" id="kobo.145.1">In the following list, we </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.146.1">present specific examples from the data world where an outer merge </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">is crucial:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.148.1">Including optional data</span></strong><span class="koboSpan" id="kobo.149.1">: Outer joins are ideal when you want to include rows that have optional data in another table. </span><span class="koboSpan" id="kobo.149.2">For instance, if you have a table of users and a separate table of addresses, not all users might have an address. </span><span class="koboSpan" id="kobo.149.3">An outer join allows you to list all users and show addresses for those who have them, without excluding users </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">without addresses.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">Data integrity and completeness</span></strong><span class="koboSpan" id="kobo.152.1">: In scenarios where you need a comprehensive dataset that includes records from both tables, regardless of whether there’s a matching record in the joined table or not, outer joins are essential. </span><span class="koboSpan" id="kobo.152.2">This ensures that you have a complete view of the data, which is particularly important in reports that need to show all entities, such as a report listing all customers and their purchases, including those who have not made </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">any purchases.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.154.1">Mismatched data analysis</span></strong><span class="koboSpan" id="kobo.155.1">: Outer joins can be used to identify discrepancies or mismatches between tables. </span><span class="koboSpan" id="kobo.155.2">For example, if you are comparing a list of registered users against a list of participants in an event, an outer join can help identify users who did not participate and participants who are </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">not registered.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.157.1">Complex data merging</span></strong><span class="koboSpan" id="kobo.158.1">: When</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.159.1"> merging data from multiple sources that do not perfectly align, outer joins can be used to ensure that no data is lost during the merging process. </span><span class="koboSpan" id="kobo.159.2">This is particularly useful in complex data environments where data integrity </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">is critical.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.161.1">Transitioning from</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.162.1"> an outer join to a right join narrows the focus of the merged data, emphasizing the inclusion of all rows from the right DataFrame while maintaining matches from the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">left DataFrame.</span></span></p>
			<h3><span class="koboSpan" id="kobo.164.1">Right merge</span></h3>
			<p><span class="koboSpan" id="kobo.165.1">The</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.166.1"> right merge (also known as right outer join) returns all </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.167.1">the rows from the right DataFrame and the matching rows from the left DataFrame. </span><span class="koboSpan" id="kobo.167.2">The result of a right merge is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">following figure:</span></span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<span class="koboSpan" id="kobo.169.1"><img src="image/B19801_05_3.jpg" alt="Figure 5.3 – Right merge"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 5.3 – Right merge</span></p>
			<p><span class="koboSpan" id="kobo.171.1">Let’s have a look at how we can achieve the preceding result using the pandas </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">merge</span></strong><span class="koboSpan" id="kobo.173.1"> function, using the example presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">previous section:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
right_merged_data = pd.merge(employee_data, project_data, on='employee_id', how='right')</span></pre>			<p><span class="koboSpan" id="kobo.176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">how='right'</span></strong><span class="koboSpan" id="kobo.178.1"> argument specifies that a right outer join should be performed. </span><span class="koboSpan" id="kobo.178.2">This type of join returns all rows from the right DataFrame (</span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">project_data</span></strong><span class="koboSpan" id="kobo.180.1">), and the matched rows from the left DataFrame (</span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">employee_data</span></strong><span class="koboSpan" id="kobo.182.1">). </span><span class="koboSpan" id="kobo.182.2">Where there is no match, the result will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">NaN</span></strong><span class="koboSpan" id="kobo.184.1"> in the columns of the left DataFrame. </span><span class="koboSpan" id="kobo.184.2">In the following table, you can see the output of the preceding join of the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">two DataFrames:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
   employee_id     name department project_name
0            2      Bob         IT     ProjectA
1            3  Charlie  Marketing     ProjectB
2            4    David    Finance     ProjectC
3            5      Eva         IT     ProjectD
4            6      NaN        NaN     ProjectE</span></pre>			<p><span class="koboSpan" id="kobo.187.1">In the </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.188.1">following list, we present specific examples from the data world </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.189.1">where a right merge </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">is crucial:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Completing data</span></strong><span class="koboSpan" id="kobo.192.1">: A right merge is useful when you need to ensure that all entries from the right DataFrame are retained in the result, which is important when the right DataFrame contains essential data that must not </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">be lost</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">Data enrichment</span></strong><span class="koboSpan" id="kobo.195.1">: This type of join can be used to enrich a dataset (right DataFrame) with additional attributes from another dataset (left DataFrame) while ensuring that all records from the primary dataset </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">are preserved</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.197.1">Mismatched data analysis</span></strong><span class="koboSpan" id="kobo.198.1">: Like outer joins, right merges can help identify which entries in the right DataFrame do not have corresponding entries in the left DataFrame, which can be critical for data cleaning and </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">validation processes</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.200.1">Transitioning from a right to a left merge shifts the perspective of the merged data, prioritizing the inclusion of all rows from the left DataFrame while maintaining matches from the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">right DataFrame.</span></span></p>
			<h3><span class="koboSpan" id="kobo.202.1">Left merge</span></h3>
			<p><span class="koboSpan" id="kobo.203.1">The </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.204.1">left merge (also known as left outer join) returns all the rows from the left DataFrame and the matching rows from the right DataFrame. </span><span class="koboSpan" id="kobo.204.2">The result of a</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.205.1"> left merge is presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">following figure:</span></span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<span class="koboSpan" id="kobo.207.1"><img src="image/B19801_05_4.jpg" alt="Figure 5.4 – Left merge"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">Figure 5.4 – Left merge</span></p>
			<p><span class="koboSpan" id="kobo.209.1">Let’s have a look at how we can achieve the preceding result using the pandas </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">merge</span></strong><span class="koboSpan" id="kobo.211.1"> function, using the example presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">previous section:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
left_merged_data = pd.merge(employee_data, project_data, on='employee_id', how='left')</span></pre>			<p><span class="koboSpan" id="kobo.214.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">how='left'</span></strong><span class="koboSpan" id="kobo.216.1"> argument</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.217.1"> specifies that a left outer join should be performed. </span><span class="koboSpan" id="kobo.217.2">This type of join returns all rows from the left DataFrame (</span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">employee_data</span></strong><span class="koboSpan" id="kobo.219.1">), and the matched rows from the right DataFrame (</span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">project_data</span></strong><span class="koboSpan" id="kobo.221.1">). </span><span class="koboSpan" id="kobo.221.2">Where there is no match, the result </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.222.1">will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">NaN</span></strong><span class="koboSpan" id="kobo.224.1"> in the columns of the right DataFrame. </span><span class="koboSpan" id="kobo.224.2">In the following table, you can see the output of the preceding join of the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">two DataFrames:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
   employee_id     name department project_name
0            1    Alice         HR          NaN
1            2      Bob         IT     ProjectA
2            3  Charlie  Marketing     ProjectB
3            4    David    Finance     ProjectC
4            5      Eva         IT     ProjectD</span></pre>			<p><span class="koboSpan" id="kobo.227.1">If you are wondering when the left merge should be used, then the considerations presented in the previous section about the right merge apply in this case too. </span><span class="koboSpan" id="kobo.227.2">Now that we have discussed merge operations, let’s move on to handling duplicates that may arise during the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">merging process.</span></span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.229.1">Handling duplicates when merging datasets</span></h1>
			<p><span class="koboSpan" id="kobo.230.1">Handling duplicate keys </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.231.1">before performing merge operations is crucial because duplicates can lead to unexpected results, such as Cartesian products, where rows are multiplied by the number of matching entries. </span><span class="koboSpan" id="kobo.231.2">This can not only distort the data analysis but also significantly impact performance due to the increased size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">resulting DataFrame.</span></span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.233.1">Why handle duplication in rows and columns?</span></h2>
			<p><span class="koboSpan" id="kobo.234.1">Duplicate keys </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.235.1">can lead to a range of problems that may compromise the accuracy of your results and the efficiency of your data processing. </span><span class="koboSpan" id="kobo.235.2">Let’s explore why it’s a good idea to handle duplicate keys prior to </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">merging data:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.237.1">If there are duplicate keys in either table, merging these tables can result in a </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">Cartesian product</span></strong><span class="koboSpan" id="kobo.239.1">, where</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.240.1"> each duplicate key in one table matches with each occurrence of the same key in the other table, leading to an exponential increase in the number </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">of rows</span></span></li>
				<li><span class="koboSpan" id="kobo.242.1">Duplicate keys might represent data errors or inconsistencies, which can lead to incorrect analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">or conclusions</span></span></li>
				<li><span class="koboSpan" id="kobo.244.1">Reducing the dataset size by removing duplicates can lead to faster processing times during the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">merge operation</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.246.1">Having understood the importance of handling duplicate keys, let’s now examine various strategies to effectively manage these duplicates before proceeding with </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">merge operations.</span></span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.248.1">Dropping duplicate rows</span></h2>
			<p><span class="koboSpan" id="kobo.249.1">Dropping duplicate</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.250.1"> entries in your datasets involves identifying and removing any duplicate rows based on specific key columns, which ensures that each entry is unique. </span><span class="koboSpan" id="kobo.250.2">This step not only simplifies subsequent data merging but also enhances the reliability of the analysis by eliminating potential sources of error caused by duplicate data. </span><span class="koboSpan" id="kobo.250.3">To showcase the dropping of duplicates, we will expand the example we have been using to add more duplicated rows in each of the DataFrames. </span><span class="koboSpan" id="kobo.250.4">As always, you can follow the full code </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/6a.manage_duplicates.py"><span class="No-Break"><span class="koboSpan" id="kobo.252.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/6a.manage_duplicates.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.253.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.254.1">Let’s first create the sample employee data with some duplicate keys in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">employee_id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1"> column:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
employee_data = pd.DataFrame({
    'employee_id': [1, 2, 2, 3, 4, 5, 5],
    'name': ['Alice', 'Bob', 'Bob', 'Charlie', 'David', 'Eva', 'Eva'],
    'department': ['HR', 'IT', 'IT', 'Marketing', 'Finance', 'IT', 'IT']
})</span></pre>			<p><span class="koboSpan" id="kobo.258.1">Let’s also </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.259.1">create the sample project data with some duplicate keys in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">employee_id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1"> column:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.262.1">
project_data = pd.DataFrame({
    'employee_id': [2, 3, 4, 5, 5, 6],
    'project_name': ['ProjectA', 'ProjectB', 'ProjectC', 'ProjectD', 'ProjectD', 'ProjectE']
})</span></pre>			<p><span class="koboSpan" id="kobo.263.1">Now, we want to merge these datasets. </span><span class="koboSpan" id="kobo.263.2">But first, we’ll drop any duplicates so that we can make the merge operation as lightweight as possible. </span><span class="koboSpan" id="kobo.263.3">Dropping the duplicates before the merge is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">code snippet:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
employee_data = employee_data.drop_duplicates(subset='employee_id', keep='first')
project_data = project_data.drop_duplicates(subset='employee_id', keep='first')</span></pre>			<p><span class="koboSpan" id="kobo.266.1">As shown in the code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">drop_duplicates()</span></strong><span class="koboSpan" id="kobo.268.1"> is used to remove duplicate rows based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">employee_id</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">keep='first'</span></strong><span class="koboSpan" id="kobo.272.1"> parameter ensures that only the first occurrence is kept while others </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">are removed.</span></span></p>
			<p><span class="koboSpan" id="kobo.274.1">After dropping the duplicates, you can proceed with the merge operation, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">following code:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
merged_data = pd.merge(employee_data, project_data, on='employee_id', how='inner')</span></pre>			<p><span class="koboSpan" id="kobo.277.1">The merged dataset can be </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">seen here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
   employee_id     name department project_name
0            2      Bob         IT     ProjectA
1            3  Charlie  Marketing     ProjectB
2            4    David    Finance     ProjectC
3            5      Eva         IT     ProjectD</span></pre>			<p><span class="koboSpan" id="kobo.280.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">merged_data</span></strong><span class="koboSpan" id="kobo.282.1"> DataFrame includes columns from both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">employee_data</span></strong><span class="koboSpan" id="kobo.284.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">project_data</span></strong><span class="koboSpan" id="kobo.286.1"> DataFrames, showing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">employee_id</span></strong><span class="koboSpan" id="kobo.288.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">name</span></strong><span class="koboSpan" id="kobo.290.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">department</span></strong><span class="koboSpan" id="kobo.292.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">project_name</span></strong><span class="koboSpan" id="kobo.294.1"> values </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.295.1">for each employee that exists in both datasets. </span><span class="koboSpan" id="kobo.295.2">The duplicates are removed, ensuring each employee appears only once in the final merged dataset. </span><span class="koboSpan" id="kobo.295.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">drop_duplicates</span></strong><span class="koboSpan" id="kobo.297.1"> operation is crucial for avoiding data redundancy and potential conflicts during the merge operation. </span><span class="koboSpan" id="kobo.297.2">Next, we will discuss how we can guarantee that the merge operation respects the uniqueness of the keys and adheres to </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">specific constraints.</span></span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.299.1">Validating data before merging</span></h2>
			<p><span class="koboSpan" id="kobo.300.1">When merging datasets, especially</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.301.1"> large and complex ones, ensuring the integrity and validity of the merge operation is crucial. </span><span class="koboSpan" id="kobo.301.2">pandas provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">validate</span></strong><span class="koboSpan" id="kobo.303.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">merge()</span></strong><span class="koboSpan" id="kobo.305.1"> function to enforce specific conditions and relationships between the keys used in the merge. </span><span class="koboSpan" id="kobo.305.2">This helps in identifying and preventing unintended duplications or data mismatches that could compromise </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">the analysis.</span></span></p>
			<p><span class="koboSpan" id="kobo.307.1">The following code demonstrates how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">validate</span></strong><span class="koboSpan" id="kobo.309.1"> parameter to enforce </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">merge()</span></strong><span class="koboSpan" id="kobo.311.1"> constraints and handle exceptions when these constraints are not met. </span><span class="koboSpan" id="kobo.311.2">You can see the full code </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">at </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/6b.manage_duplicates_validate.py"><span class="No-Break"><span class="koboSpan" id="kobo.313.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/6b.manage_duplicates_validate.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.314.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.315.1">
try:
    merged_data = pd.merge(employee_data, project_data, on='employee_id', how='inner', validate='one_to_many')
    print("Merged Data Result:")
    print(merged_data)
except ValueError as e:
    print("Merge failed:", e)</span></pre>			<p><span class="koboSpan" id="kobo.316.1">In the preceding code snippet, the merge operation is wrapped in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">try-except</span></strong><span class="koboSpan" id="kobo.318.1"> block. </span><span class="koboSpan" id="kobo.318.2">This is a way to handle exceptions, which are errors occurring during a program’s execution. </span><span class="koboSpan" id="kobo.318.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">try</span></strong><span class="koboSpan" id="kobo.320.1"> block contains the code that might raise an exception, in this case, the merge operation. </span><span class="koboSpan" id="kobo.320.2">If an exception occurs, the code execution moves to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">except</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.322.1"> block.</span></span></p>
			<p><span class="koboSpan" id="kobo.323.1">If the merge </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.324.1">operation fails the validation check (in our case, if there are duplicate keys in the left DataFrame when they are expected to be unique), </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">ValueError</span></strong><span class="koboSpan" id="kobo.326.1"> exception will be raised, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">except</span></strong><span class="koboSpan" id="kobo.328.1"> block will be executed. </span><span class="koboSpan" id="kobo.328.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">except</span></strong><span class="koboSpan" id="kobo.330.1"> block catches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">ValueError</span></strong><span class="koboSpan" id="kobo.332.1"> exception and prints a </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Merge failed:</span></strong><span class="koboSpan" id="kobo.334.1"> message, followed by the error message provided </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">by pandas.</span></span></p>
			<p><span class="koboSpan" id="kobo.336.1">After executing the preceding code, you will see the following </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">error message:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
Merge failed: Merge keys are not unique in left dataset; not a one-to-many merge</span></pre>			<p><span class="koboSpan" id="kobo.339.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">validate='one_to_many'</span></strong><span class="koboSpan" id="kobo.341.1"> parameter is included in the merge operation. </span><span class="koboSpan" id="kobo.341.2">This parameter tells pandas to check that the merge operation is of the specified type. </span><span class="koboSpan" id="kobo.341.3">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">one_to_many</span></strong><span class="koboSpan" id="kobo.343.1"> means that the merge keys should be unique in the left DataFrame (</span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">employee_data</span></strong><span class="koboSpan" id="kobo.345.1">) but can have duplicates in the right DataFrame (</span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">project_data</span></strong><span class="koboSpan" id="kobo.347.1">). </span><span class="koboSpan" id="kobo.347.2">If the validation check fails, pandas will raise a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">ValueError</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> exception.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.350.1">When to use which approach</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.351.1">Use </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">manual duplicate removal</span></strong><span class="koboSpan" id="kobo.353.1"> when you need fine control over how duplicates are identified and </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.354.1">handled, or when duplicates require special processing (e.g., aggregation or transformation based on other </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">column values).</span></span></p>
			<p class="callout"><span class="koboSpan" id="kobo.356.1">Use </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">merge validation</span></strong><span class="koboSpan" id="kobo.358.1"> when </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.359.1">you want to ensure the structural integrity of your data model directly within the merge operation, especially in straightforward cases where the relationship between the tables is well-defined and should not include duplicate keys according to the business logic or </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">data model.</span></span></p>
			<p><span class="koboSpan" id="kobo.361.1">If there is a good reason for the existence of duplicates in the data, we can consider employing aggregation methods during the merge to consolidate </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">redundant information.</span></span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.363.1">Aggregation</span></h2>
			<p><span class="koboSpan" id="kobo.364.1">Aggregation</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.365.1"> is a powerful technique for managing </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.366.1">duplicates in datasets, particularly when dealing with key columns that should be unique but contain multiple entries. </span><span class="koboSpan" id="kobo.366.2">By grouping data on these key columns and applying aggregation functions, we can consolidate duplicate entries into a single, summarized record. </span><span class="koboSpan" id="kobo.366.3">Aggregation functions such as sum, average, or maximum can be used to combine or summarize the data in a way that aligns with the </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">analytical goals.</span></span></p>
			<p><span class="koboSpan" id="kobo.368.1">Let’s see how </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.369.1">aggregation can be employed to effectively deal with duplicates before merging data. </span><span class="koboSpan" id="kobo.369.2">We will extend the dataset a little bit to help us with this example, as shown here. </span><span class="koboSpan" id="kobo.369.3">You can see the full example </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">at </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/6c.merge_and_aggregate.py"><span class="No-Break"><span class="koboSpan" id="kobo.371.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/6c.merge_and_aggregate.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.372.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
employee_data = pd.DataFrame({
    'employee_id': [1, 2, 2, 3, 4, 5, 5],
    'name': ['Alice', 'Bob', 'Bob', 'Charlie', 'David', 'Eva', 'Eva'],
    'department': ['HR', 'IT', 'IT', 'Marketing', 'Finance', 'IT', 'IT'],
    'salary': [50000, 60000, 60000, 55000, 65000, 70000, 70000]
})
# Sample project assignment data with potential duplicate keys
project_data = pd.DataFrame({
    'employee_id': [2, 3, 4, 5, 7, 6],
    'project_name': ['ProjectA', 'ProjectB', 'ProjectC', 'ProjectD', 'ProjectD', 'ProjectE']
})</span></pre>			<p><span class="koboSpan" id="kobo.374.1">Now, let’s </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.375.1">perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">aggregation step:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
aggregated_employee_data = employee_data.groupby('employee_id').agg({
    'name': 'first', # Keep the first name encountered
    'department': 'first', # Keep the first department encountered
    'salary': 'sum' # Sum the salaries in case of duplicates
}).reset_index()</span></pre>			<p><span class="koboSpan" id="kobo.378.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">groupby()</span></strong><span class="koboSpan" id="kobo.380.1"> method</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.381.1"> is used on </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">employee_data</span></strong><span class="koboSpan" id="kobo.383.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">employee_id</span></strong><span class="koboSpan" id="kobo.385.1"> as the key. </span><span class="koboSpan" id="kobo.385.2">This groups the DataFrame by </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">employee_id</span></strong><span class="koboSpan" id="kobo.387.1">, which is necessary because of the duplicate </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">employee_id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.389.1"> values.</span></span></p>
			<p><span class="koboSpan" id="kobo.390.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">agg()</span></strong><span class="koboSpan" id="kobo.392.1"> method is then applied to perform specific aggregations on </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">different columns:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">'name': 'first'</span></strong><span class="koboSpan" id="kobo.395.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">'department': 'first'</span></strong><span class="koboSpan" id="kobo.397.1"> ensure that the first encountered values for these columns are retained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">grouped data</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">'salary': 'sum'</span></strong><span class="koboSpan" id="kobo.400.1"> sums up the salaries for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">employee_id</span></strong><span class="koboSpan" id="kobo.402.1"> value, which is useful if the duplicates represent split records of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">cumulative data</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.404.1">In the final step, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">pd.merge()</span></strong><span class="koboSpan" id="kobo.406.1"> function is used to combine </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">aggregated_employee_data</span></strong><span class="koboSpan" id="kobo.408.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">project_data</span></strong><span class="koboSpan" id="kobo.410.1"> using an inner join on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">employee_id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.412.1"> column:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
merged_data = pd.merge(aggregated_employee_data, project_data, on='employee_id', how='inner')</span></pre>			<p><span class="koboSpan" id="kobo.414.1">This ensures that only employees with project assignments are included in the result. </span><span class="koboSpan" id="kobo.414.2">The result after the merge is </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
   employee_id     name department  salary project_name
0            2      Bob         IT  120000     ProjectA
1            3  Charlie  Marketing   55000     ProjectB
2            4    David    Finance   65000     ProjectC
3            5      Eva         IT  140000     ProjectD</span></pre>			<p><span class="koboSpan" id="kobo.417.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">agg()</span></strong><span class="koboSpan" id="kobo.419.1"> method</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.420.1"> in pandas is highly versatile, offering numerous options beyond the simple “keep first” approach demonstrated in</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.421.1"> the previous example. </span><span class="koboSpan" id="kobo.421.2">This method can apply a wide range of aggregation functions to consolidate data, such as summing numerical values, finding averages, or selecting maximum or minimum entries. </span><span class="koboSpan" id="kobo.421.3">We will dive deeper into the various capabilities of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">agg()</span></strong><span class="koboSpan" id="kobo.423.1"> method in the next chapter, exploring how these different options can be applied to enhance data preparation </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">and analysis.</span></span></p>
			<p><span class="koboSpan" id="kobo.425.1">Let’s move on from using aggregation as a way to handle duplicates to concatenating duplicated rows when dealing with text or </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">categorical data.</span></span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.427.1">Concatenation</span></h2>
			<p><span class="koboSpan" id="kobo.428.1">The concatenation</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.429.1"> of values from duplicate </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.430.1">rows into a single row can be a useful technique, especially when dealing with categorical or textual data that may have multiple valid entries for the same key. </span><span class="koboSpan" id="kobo.430.2">This approach allows you to preserve all the information across duplicates without </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">losing data.</span></span></p>
			<p><span class="koboSpan" id="kobo.432.1">Let’s see how</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.433.1"> concatenation of rows can be employed to effectively deal with duplicates before merging data. </span><span class="koboSpan" id="kobo.433.2">To showcase this method, we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">following DataFrame:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
employee_data = pd.DataFrame({
    'employee_id': [1, 2, 2, 3, 4, 5, 5],
    'name': ['Alice', 'Bob', 'Bob', 'Charlie', 'David', 'Eva', 'Eva'],
    'department': ['HR', 'IT', 'Marketing', 'Marketing', 'Finance', 'IT', 'HR']
})</span></pre>			<p><span class="koboSpan" id="kobo.436.1">Now, let’s perform the concatenation step, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">code snippet:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
employee_data['department'] = employee_data.groupby('employee_id')['department'].transform(lambda x: ', '.join(x))</span></pre>			<p><span class="koboSpan" id="kobo.439.1">In the</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.440.1"> concatenation step, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">groupby('employee_id')</span></strong><span class="koboSpan" id="kobo.442.1"> method groups the data by </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">employee_id</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">transform(lambda x: ', '.join(x))</span></strong><span class="koboSpan" id="kobo.446.1"> method is then applied to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">department</span></strong><span class="koboSpan" id="kobo.448.1"> column. </span><span class="koboSpan" id="kobo.448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">transform</span></strong><span class="koboSpan" id="kobo.450.1"> function is used here with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">lambda</span></strong><span class="koboSpan" id="kobo.452.1"> function that joins all entries </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.453.1">of the column department for each group (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">employee_id</span></strong><span class="koboSpan" id="kobo.455.1">) into a single string separated </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">by commas.</span></span></p>
			<p><span class="koboSpan" id="kobo.457.1">The result of this operation replaces the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">department</span></strong><span class="koboSpan" id="kobo.459.1"> column in </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">employee_data</span></strong><span class="koboSpan" id="kobo.461.1">, where each </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">employee_id</span></strong><span class="koboSpan" id="kobo.463.1"> now has a single entry for </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">department</span></strong><span class="koboSpan" id="kobo.465.1"> that includes all original department data concatenated into one string, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">following table:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
   employee_id     name     department
0            1    Alice             HR
1            2      Bob  Marketing, IT
3            3  Charlie      Marketing
4            4    David        Finance
5            5      Eva         IT, HR</span></pre>			<p><span class="koboSpan" id="kobo.468.1">Use concatenation when you need to preserve all categorical or textual data across duplicate entries without preferring one entry </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">over another.</span></span></p>
			<p><span class="koboSpan" id="kobo.470.1">This method is useful for summarizing textual data in a way that is still readable and informative, especially when dealing with attributes that can have multiple valid values (e.g., an employee belonging to </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">multiple departments).</span></span></p>
			<p><span class="koboSpan" id="kobo.472.1">Once duplicate rows in each DataFrame are resolved, attention shifts to identifying and resolving duplicate columns across the DataFrames to </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">be merged.</span></span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.474.1">Handling duplication in columns</span></h2>
			<p><span class="koboSpan" id="kobo.475.1">When</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.476.1"> merging data from different sources, it’s not uncommon to encounter DataFrames with overlapping column names. </span><span class="koboSpan" id="kobo.476.2">This challenge often arises when combining data from </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">similar datasets.</span></span></p>
			<p><span class="koboSpan" id="kobo.478.1">Expanding the example data we have been using so far, we will adjust the DataFrames to help us showcase the options we have when dealing with common columns across DataFrames. </span><span class="koboSpan" id="kobo.478.2">The data can be </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">seen here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
employee_data_1 = pd.DataFrame({
    'employee_id': [1, 2, 3, 4, 5],
    'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
    'department': ['HR', 'IT', 'Marketing', 'Finance', 'IT']
})
employee_data_2 = pd.DataFrame({
    'employee_id': [6, 7, 8, 9, 10],
    'name': ['Frank', 'Grace', 'Hannah', 'Ian', 'Jill'],
    'department': ['Logistics', 'Marketing', 'IT', 'Marketing', 'Finance']
})</span></pre>			<p><span class="koboSpan" id="kobo.481.1">Let’s see how we can merge these datasets by applying different techniques without breaking the </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">merge operation.</span></span></p>
			<h3><span class="koboSpan" id="kobo.483.1">Handling duplicate columns while merging</span></h3>
			<p><span class="koboSpan" id="kobo.484.1">The </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.485.1">columns in the two DataFrames presented previously share identical names and may represent the same data. </span><span class="koboSpan" id="kobo.485.2">However, we have decided to retain both sets of columns in the merged DataFrame. </span><span class="koboSpan" id="kobo.485.3">This decision is based on the suspicion that, despite having the same column names, the entries are not entirely identical, indicating that they may be different representations of the same data. </span><span class="koboSpan" id="kobo.485.4">This is an issue that we can address later, following the </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">merge operation.</span></span></p>
			<p><span class="koboSpan" id="kobo.487.1">The best approach to keep both sets of columns is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">suffixes</span></strong><span class="koboSpan" id="kobo.489.1"> parameter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">merge()</span></strong><span class="koboSpan" id="kobo.491.1"> function. </span><span class="koboSpan" id="kobo.491.2">This will allow you to differentiate between the columns from each DataFrame without losing any data. </span><span class="koboSpan" id="kobo.491.3">Here’s how you can implement this in Python </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">using pandas:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
merged_data = pd.merge(employee_data_1, employee_data_2, on='employee_id', how='outer', suffixes=('_1', '_2'))</span></pre>			<p><span class="koboSpan" id="kobo.494.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">pd.merge()</span></strong><span class="koboSpan" id="kobo.496.1"> function</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.497.1"> is used to merge the two DataFrames on </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">employee_id</span></strong><span class="koboSpan" id="kobo.499.1">. </span><span class="koboSpan" id="kobo.499.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">how='outer'</span></strong><span class="koboSpan" id="kobo.501.1"> parameter is used to ensure all records from both DataFrames are included in the merged DataFrame, even if there are no matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">employee_id</span></strong><span class="koboSpan" id="kobo.503.1"> values. </span><span class="koboSpan" id="kobo.503.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">suffixes=('_1', '_2')</span></strong><span class="koboSpan" id="kobo.505.1"> parameter adds suffixes to the columns from each DataFrame to differentiate them in the merged DataFrame. </span><span class="koboSpan" id="kobo.505.2">This is crucial when columns have the same names but come from different sources. </span><span class="koboSpan" id="kobo.505.3">Let’s review the </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">output DataFrame:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
   employee_id   name_1 department_1  name_2 department_2
0            1    Alice           HR     NaN          NaN
1            2      Bob           IT     NaN          NaN
2            3  Charlie    Marketing     NaN          NaN
3            4    David      Finance     NaN          NaN
4            5      Eva           IT     NaN          NaN
5            6      NaN          NaN   Frank    Logistics
6            7      NaN          NaN   Grace    Marketing
7            8      NaN          NaN  Hannah           IT
8            9      NaN          NaN     Ian    Marketing
9           10      NaN          NaN    Jill      Finance</span></pre>			<p><span class="koboSpan" id="kobo.508.1">This approach is particularly useful in scenarios where merging data from different sources involves overlapping column names but where it’s also important to retain and clearly distinguish these columns in the resulting DataFrame. </span><span class="koboSpan" id="kobo.508.2">Another point to consider is that suffixes allow for identifying which DataFrame the data originated from, which is useful in analyses involving data from </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">multiple sources.</span></span></p>
			<p><span class="koboSpan" id="kobo.510.1">In the next section, we will explain how to deal with duplicate columns by dropping them </span><em class="italic"><span class="koboSpan" id="kobo.511.1">before</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.512.1">the merge.</span></span></p>
			<h3><span class="koboSpan" id="kobo.513.1">Dropping duplicate columns before the merge</span></h3>
			<p><span class="koboSpan" id="kobo.514.1">If we find </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.515.1">that we have copies of the same column in both DataFrames we want to merge and that the column in one of the DataFrames is sufficient or more reliable than the other, then it may be more practical to drop one of the duplicate columns before a merge operation instead of keeping both. </span><span class="koboSpan" id="kobo.515.2">This decision can be driven by the need to simplify the dataset, reduce redundancy, or when one of the columns does not provide additional value to the analysis. </span><span class="koboSpan" id="kobo.515.3">Let’s have a look at the data for </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">this example:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
employee_data_1 = pd.DataFrame({
    'employee_id': [1, 2, 3, 4, 5],
    'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
    'department': ['HR', 'IT', 'Marketing', 'Finance', 'IT']
})
employee_data_2 = pd.DataFrame({
    'employee_id': [1, 2, 3, 4, 5],
    'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
    'department': ['Human Resources', 'Information Technology', 'Sales', 'Financial', 'Technical']
})</span></pre>			<p><span class="koboSpan" id="kobo.518.1">If we take a closer look at this data, we can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">department</span></strong><span class="koboSpan" id="kobo.520.1"> column in the two DataFrames captures the same information but in different formats. </span><span class="koboSpan" id="kobo.520.2">For the sake of our example, let’s assume that we know the HR system tracks the department of each employee in the format presented in the first DataFrame. </span><span class="koboSpan" id="kobo.520.3">That’s why we will trust this column more than the one in the second DataFrame. </span><span class="koboSpan" id="kobo.520.4">Therefore, we will drop the second one before the merge operation. </span><span class="koboSpan" id="kobo.520.5">Here’s how you can drop the column before </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">the merge:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
employee_data_2.drop(columns=['department'], inplace=True)</span></pre>			<p><span class="koboSpan" id="kobo.523.1">Before merging, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">department</span></strong><span class="koboSpan" id="kobo.525.1"> column from </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">employee_data_2</span></strong><span class="koboSpan" id="kobo.527.1"> is dropped because it’s deemed less reliable. </span><span class="koboSpan" id="kobo.527.2">This is done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">drop(columns=['department'], inplace=True)</span></strong><span class="koboSpan" id="kobo.529.1"> method. </span><span class="koboSpan" id="kobo.529.2">Having dropped the required columns, we can proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">the merge:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
merged_data = pd.merge(employee_data_1, employee_data_2, on=['employee_id', 'name'], how='inner')</span></pre>			<p><span class="koboSpan" id="kobo.532.1">The</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.533.1"> DataFrames are merged using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">employee_id</span></strong><span class="koboSpan" id="kobo.535.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">name</span></strong><span class="koboSpan" id="kobo.537.1"> columns as keys with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">pd.merge()</span></strong><span class="koboSpan" id="kobo.539.1"> function. </span><span class="koboSpan" id="kobo.539.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">how='inner'</span></strong><span class="koboSpan" id="kobo.541.1"> parameter is used to perform an inner join, which includes only rows that have matching values in </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">both DataFrames.</span></span></p>
			<p><span class="koboSpan" id="kobo.543.1">To optimize the merging process and improve performance, it’s often beneficial to drop unnecessary columns before performing the merge operation for the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">following reasons:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.545.1">It leads to improved performance by significantly reducing the memory footprint during the merge operation, as it minimizes the amount of data to be processed and combined, thereby expediting </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the process.</span></span></li>
				<li><span class="koboSpan" id="kobo.547.1">The resulting DataFrame becomes simpler and cleaner, facilitating easier data management and subsequent analysis. </span><span class="koboSpan" id="kobo.547.2">This reduction in complexity not only streamlines the merge operation but also reduces the likelihood </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">of errors.</span></span></li>
				<li><span class="koboSpan" id="kobo.549.1">In resource-constrained environments, such as those with limited computing resources, minimizing the dataset before intensive operations such as merging enhances resource efficiency and ensures </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">smoother execution.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.551.1">In the case that we have identical columns across the DataFrames, another option is to consider whether we can use them as keys in the </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">merge operation.</span></span></p>
			<h3><span class="koboSpan" id="kobo.553.1">Duplicate keys</span></h3>
			<p><span class="koboSpan" id="kobo.554.1">When</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.555.1"> encountering identical keys across DataFrames, a smart approach is to merge based on these common columns. </span><span class="koboSpan" id="kobo.555.2">Let’s revisit the example presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">previous section:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
merged_data = pd.merge(employee_data_1, employee_data_2, on=['employee_id', 'name'], how='inner')</span></pre>			<p><span class="koboSpan" id="kobo.558.1">We can see here that we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">['employee_id', 'name']</span></strong><span class="koboSpan" id="kobo.560.1"> as keys in the merge. </span><span class="koboSpan" id="kobo.560.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">employee_id</span></strong><span class="koboSpan" id="kobo.562.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">name</span></strong><span class="koboSpan" id="kobo.564.1"> are reliable identifiers that ensure accurate matching of records across DataFrames, they should be used as keys. </span><span class="koboSpan" id="kobo.564.2">This ensures that the merged data accurately represents combined records from </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">both sources.</span></span></p>
			<p><span class="koboSpan" id="kobo.566.1">As the volume and complexity of data continues to grow, it is crucial to efficiently combine datasets, as we will learn in the </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">following section.</span></span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.568.1">Performance tricks for merging</span></h1>
			<p><span class="koboSpan" id="kobo.569.1">When </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.570.1">working with large datasets, the performance of merge operations can significantly impact the overall efficiency of data processing tasks. </span><span class="koboSpan" id="kobo.570.2">Merging is a common and often necessary step in data analysis, but it can be computationally intensive, especially when dealing with big data. </span><span class="koboSpan" id="kobo.570.3">Therefore, employing performance optimization techniques is crucial to ensure that merges are executed as quickly and efficiently </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">as possible.</span></span></p>
			<p><span class="koboSpan" id="kobo.572.1">Optimizing merge operations can lead to reduced execution time, lower memory consumption, and an overall smoother data-handling experience. </span><span class="koboSpan" id="kobo.572.2">In the following sections, we will explore various performance tricks that can be applied to merge operations in pandas, such as utilizing indexes, sorting indexes, choosing the right merge method, and reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">memory usage.</span></span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.574.1">Set indexes</span></h2>
			<p><span class="koboSpan" id="kobo.575.1">Utilizing indexes</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.576.1"> in pandas is a critical aspect of data manipulation and analysis, particularly when dealing with large datasets or performing frequent data retrieval operations. </span><span class="koboSpan" id="kobo.576.2">Indexes serve as a tool for both identification and efficient data access, providing several benefits that can significantly enhance performance. </span><span class="koboSpan" id="kobo.576.3">Specifically, when merging DataFrames, utilizing indexes can lead to performance improvements. </span><span class="koboSpan" id="kobo.576.4">Merging on indexes, rather than on columns, is generally faster because pandas can perform the merge operation using optimized index-based joining methods, which is more efficient than column-based merging. </span><span class="koboSpan" id="kobo.576.5">Let’s revisit the employee example to prove this concept. </span><span class="koboSpan" id="kobo.576.6">The full code for this example can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">at </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/8a.perfomance_benchmark_set_index.py"><span class="No-Break"><span class="koboSpan" id="kobo.578.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/8a.perfomance_benchmark_set_index.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.580.1">First, let’s</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.581.1"> import the </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">necessary libraries:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
import pandas as pd
import numpy as np
from time import time</span></pre>			<p><span class="koboSpan" id="kobo.584.1">Select the number of rows for the benchmarking example for </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">each DataFrame:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
num_rows = 5</span></pre>			<p><span class="koboSpan" id="kobo.587.1">Let’s create the DataFrames for the example, which will have the number of rows as defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">num_rows</span></strong><span class="koboSpan" id="kobo.589.1"> variable. </span><span class="koboSpan" id="kobo.589.2">The first employee DataFrame is </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">defined here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.591.1">
employee_data_1 = pd.DataFrame({
  'employee_id': np.arange(</span><strong class="bold"><span class="koboSpan" id="kobo.592.1">num_rows</span></strong><span class="koboSpan" id="kobo.593.1">),
  'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
  'department': ['HR', 'IT', 'Marketing', 'Finance', 'IT'],
  'salary': [50000, 60000, 70000, 80000, 90000]
})</span></pre>			<p><span class="koboSpan" id="kobo.594.1">The second DataFrame is </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
employee_data_2 = pd.DataFrame({
  'employee_id': np.arange(</span><strong class="bold"><span class="koboSpan" id="kobo.597.1">num_rows</span></strong><span class="koboSpan" id="kobo.598.1">),
  'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
  'department': ['HR', 'IT', 'Sales', 'Finance', 'Operations'],
  'bonus': [3000, 4000, 5000, 6000, 7000]
})</span></pre>			<p><span class="koboSpan" id="kobo.599.1">To demonstrate the effectiveness of the performance tricks we applied, we will initially perform the merge </span><em class="italic"><span class="koboSpan" id="kobo.600.1">without utilizing the index</span></em><span class="koboSpan" id="kobo.601.1">. </span><span class="koboSpan" id="kobo.601.2">We’ll calculate the time taken for this operation. </span><span class="koboSpan" id="kobo.601.3">Subsequently, we’ll set the index in both DataFrames and repeat the merge operation, recalculating</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.602.1"> the time. </span><span class="koboSpan" id="kobo.602.2">Finally, we will present the results. </span><span class="koboSpan" id="kobo.602.3">Let’s hope this approach yields the desired outcome! </span><span class="koboSpan" id="kobo.602.4">Let’s start </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">the clock:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
start_time = time()</span></pre>			<p><span class="koboSpan" id="kobo.605.1">Let’s perform the merge operation without using indexes, just by inner joining on </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">['</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">employee_id', 'name']</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
merged_data = pd.merge(employee_data_1, employee_data_2, on=['employee_id', 'name'], how='inner', suffixes=('_1', '_2'))</span></pre>			<p><span class="koboSpan" id="kobo.610.1">Let’s calculate the time it took to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the merge:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
end_time = time()
merge_time = end_time - start_time
</span><strong class="bold"><span class="koboSpan" id="kobo.613.1">Merge operation took around 0.00289 seconds</span></strong></pre>			<p class="callout-heading"><span class="koboSpan" id="kobo.614.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.615.1">The timings may vary depending on the computer used to execute the program. </span><span class="koboSpan" id="kobo.615.2">The idea is that the optimized version takes less time than the original </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">merge operation.</span></span></p>
			<p><span class="koboSpan" id="kobo.617.1">By setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">employee_id</span></strong><span class="koboSpan" id="kobo.619.1"> as the index for both DataFrames (</span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">employee_data_1</span></strong><span class="koboSpan" id="kobo.621.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">employee_data_2</span></strong><span class="koboSpan" id="kobo.623.1">), we allow pandas to use optimized index-based joining methods. </span><span class="koboSpan" id="kobo.623.2">This is particularly effective because indexes in pandas are implemented via hash tables or B-trees, depending on the data type and the sortedness of the index, which facilitates </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">faster lookups:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
employee_data_1.set_index('employee_id', inplace=True)
employee_data_2.set_index('employee_id', inplace=True)</span></pre>			<p><span class="koboSpan" id="kobo.626.1">Let’s repeat the merge operation after setting the indexes and calculate the time </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">once more:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.628.1">
start_time = time()
merged_data_reduced = pd.merge(employee_data_1, employee_data_2, left_index=True, right_index=True, suffixes=('_1', '_2'))
end_time = time()
merge_reduced_time = end_time - start_time
</span><strong class="bold"><span class="koboSpan" id="kobo.629.1">Merge operation with reduced memory took around 0.00036 seconds</span></strong></pre>			<p><span class="koboSpan" id="kobo.630.1">Now, if we</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.631.1"> calculate the percentage difference from the initial time to the final one, we see that we managed to drop the time by around 88.5%, just by setting the index. </span><span class="koboSpan" id="kobo.631.2">This seems impressive but let’s also discuss some considerations when </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">setting indexes.</span></span></p>
			<h3><span class="koboSpan" id="kobo.633.1">Index considerations</span></h3>
			<p><span class="koboSpan" id="kobo.634.1">It’s important to </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.635.1">choose the right columns for indexing based on the query patterns. </span><span class="koboSpan" id="kobo.635.2">Over-indexing can lead to unnecessary use of disk space and can degrade write performance due to the overhead of maintaining </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">the indexes.</span></span></p>
			<p><strong class="bold"><span class="koboSpan" id="kobo.637.1">Rebuilding</span></strong><span class="koboSpan" id="kobo.638.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">reorganizing indexes</span></strong><span class="koboSpan" id="kobo.640.1"> is essential </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.641.1">for optimal performance. </span><span class="koboSpan" id="kobo.641.2">These tasks address index fragmentation and ensure consistent performance </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">over time.</span></span></p>
			<p><span class="koboSpan" id="kobo.643.1">While indexes can significantly improve read performance, they can also impact write performance. </span><span class="koboSpan" id="kobo.643.2">It’s crucial to find a balance between optimizing for read operations (such as searches and joins) and maintaining efficient write operations (such as inserts </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">and updates).</span></span></p>
			<p><span class="koboSpan" id="kobo.645.1">Multi-column indexes, or concatenated indexes, can be beneficial when multiple fields are often used together in queries. </span><span class="koboSpan" id="kobo.645.2">However, the order of the fields in the index definition is important and should reflect the most common </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">query patterns.</span></span></p>
			<p><span class="koboSpan" id="kobo.647.1">Having proved the importance of setting indexes, let’s go a step further and discuss the option of sorting the index </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">before merging.</span></span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.649.1">Sorting indexes</span></h2>
			<p><span class="koboSpan" id="kobo.650.1">Sorting the</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.651.1"> index in pandas can be particularly beneficial in scenarios where you are frequently merging or performing join operations on large DataFrames. </span><span class="koboSpan" id="kobo.651.2">When indexes are sorted, pandas can take advantage of more efficient algorithms to align and join data, which can lead to significant performance improvements. </span><span class="koboSpan" id="kobo.651.3">Let’s deep dive into this before proceeding to the </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">code example:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.653.1">When indexes are sorted, pandas can use binary search algorithms to locate the matching rows between DataFrames. </span><span class="koboSpan" id="kobo.653.2">Binary search has a time complexity of </span><em class="italic"><span class="koboSpan" id="kobo.654.1">O(log n)</span></em><span class="koboSpan" id="kobo.655.1">, which is much faster than the linear search required for unsorted indexes, especially as the size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">DataFrame grows.</span></span></li>
				<li><span class="koboSpan" id="kobo.657.1">Sorted indexes facilitate quicker data alignment. </span><span class="koboSpan" id="kobo.657.2">This is because pandas can make certain assumptions about the order of the data, which streamlines the process of finding corresponding rows in each DataFrame during </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">a merge.</span></span></li>
				<li><span class="koboSpan" id="kobo.659.1">With sorted indexes, pandas can avoid unnecessary comparisons that would be required if the indexes were unsorted. </span><span class="koboSpan" id="kobo.659.2">This reduces the computational overhead and speeds up the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">merging process.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.661.1">Let’s go back to the code example by adding the sorting of the index. </span><span class="koboSpan" id="kobo.661.2">The original data remains the same; however, in this experiment, we are comparing the time it takes to perform the merge operation after the setting of the index versus the time it takes to perform the merge operation after the setting and sorting of indexes. </span><span class="koboSpan" id="kobo.661.3">The following code shows the main code components but, as always, you can follow the full example </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">at </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/8b.performance_benchmark_sort_indexes.py"><span class="No-Break"><span class="koboSpan" id="kobo.663.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter05/8b.performance_benchmark_sort_indexes.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.664.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
employee_data_1.set_index('employee_id', inplace=True)
employee_data_2.set_index('employee_id', inplace=True)</span></pre>			<p><span class="koboSpan" id="kobo.666.1">Let’s perform the merge operation without </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">sorting indexes:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.668.1">
merged_data = pd.merge(employee_data_1, employee_data_2, left_index=True, right_index=True, suffixes=('_1', '_2'))
</span><strong class="bold"><span class="koboSpan" id="kobo.669.1">Merge operation with setting index took around 0.00036 seconds</span></strong></pre>			<p><span class="koboSpan" id="kobo.670.1">Let’s repeat </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.671.1">the merge operation after sorting the indexes and calculate the time </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">once more:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
employee_data_1.sort_index(inplace=True)
employee_data_2.sort_index(inplace=True)
merged_data_reduced = pd.merge(employee_data_1, employee_data_2, left_index=True, right_index=True, suffixes=('_1', '_2'))
</span><strong class="bold"><span class="koboSpan" id="kobo.674.1">Merge operation after sorting took around 0.00028 seconds.</span></strong></pre>			<p><span class="koboSpan" id="kobo.675.1">Now, if we calculate the percentage difference from the initial time to the final one, we see that we managed to drop the time by an extra ~22%, by sorting the index. </span><span class="koboSpan" id="kobo.675.2">This seems impressive but let’s also discuss some considerations when </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">setting indexes.</span></span></p>
			<h3><span class="koboSpan" id="kobo.677.1">Sorting index considerations</span></h3>
			<p><span class="koboSpan" id="kobo.678.1">Sorting a </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.679.1">DataFrame’s index is not free of computational cost. </span><span class="koboSpan" id="kobo.679.2">The initial sorting operation itself takes time, so it’s most beneficial when the sorted DataFrame will be used in multiple merge or join operations, amortizing the cost of sorting over </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">these operations.</span></span></p>
			<p><span class="koboSpan" id="kobo.681.1">Sorting can sometimes increase the memory overhead, as pandas may create a sorted copy of the DataFrame’s index. </span><span class="koboSpan" id="kobo.681.2">This should be considered when working with very large datasets where memory is </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">a constraint.</span></span></p>
			<p><span class="koboSpan" id="kobo.683.1">Sorting the index is most beneficial when the key used for merging is not only unique but also has some logical order that can be leveraged, such as time-series data or ordered </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">categorical data.</span></span></p>
			<p><span class="koboSpan" id="kobo.685.1">Index management and maintenance are crucial aspects you should consider when working with pandas DataFrames, especially when dealing with large datasets. </span><span class="koboSpan" id="kobo.685.2">Maintaining a well-managed index requires careful consideration. </span><span class="koboSpan" id="kobo.685.3">For example, regularly updating or reindexing a DataFrame can introduce computational costs, similar to sorting operations. </span><span class="koboSpan" id="kobo.685.4">Each time you modify the index—by sorting, reindexing, or resetting—it can result in additional memory usage and processing time, particularly with </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">large datasets.</span></span></p>
			<p><span class="koboSpan" id="kobo.687.1">Indexes need to</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.688.1"> be maintained in a way that balances performance and resource usage. </span><span class="koboSpan" id="kobo.688.2">For instance, if you frequently merge or join DataFrames, ensuring that the index is properly sorted and unique can significantly speed up these operations. </span><span class="koboSpan" id="kobo.688.3">However, continuously maintaining a sorted index can be resource-intensive, so it’s most beneficial when the DataFrame will be involved in multiple operations that can leverage the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">sorted index.</span></span></p>
			<p><span class="koboSpan" id="kobo.690.1">Additionally, choosing the right index type—whether it’s a simple integer-based index, a datetime index for time-series data, or a multi-level index for hierarchical data—can influence how efficiently pandas handles your data. </span><span class="koboSpan" id="kobo.690.2">The choice of index should align with the structure and access patterns of your data to minimize </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">unnecessary overhead.</span></span></p>
			<p><span class="koboSpan" id="kobo.692.1">In the next section, we will discuss how using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">join</span></strong><span class="koboSpan" id="kobo.694.1"> function instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">merge</span></strong><span class="koboSpan" id="kobo.696.1"> can </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">impact performance.</span></span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.698.1">Merge versus join</span></h2>
			<p><span class="koboSpan" id="kobo.699.1">While</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.700.1"> merging is a commonly used method to combine datasets based on specific conditions or keys, there is another approach: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">join</span></strong><span class="koboSpan" id="kobo.702.1"> function. </span><span class="koboSpan" id="kobo.702.2">This </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.703.1">function provides a streamlined way to perform merges primarily based on indexes, offering a simpler alternative to the more general merge function. </span><span class="koboSpan" id="kobo.703.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">join</span></strong><span class="koboSpan" id="kobo.705.1"> method in pandas is particularly useful when the DataFrames involved have their indexes set up as the keys for joining, allowing for efficient and straightforward data combinations without the need for specifying complex </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">join conditions.</span></span></p>
			<p><span class="koboSpan" id="kobo.707.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">join</span></strong><span class="koboSpan" id="kobo.709.1"> function instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">merge</span></strong><span class="koboSpan" id="kobo.711.1"> can impact performance in several ways, primarily due to the underlying mechanisms and default behaviors of these </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">two functions:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.713.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">join</span></strong><span class="koboSpan" id="kobo.715.1"> function in pandas is optimized for index-based joining, meaning it’s designed to be efficient when joining DataFrames on their indexes. </span><span class="koboSpan" id="kobo.715.2">If your DataFrames are already indexed by the keys you want to join on, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">join</span></strong><span class="koboSpan" id="kobo.717.1"> can be more performance-efficient because it leverages the optimized index </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">structures [2][6][7].</span></span></li>
				<li><span class="koboSpan" id="kobo.719.1">Join is a simplified version of merge that defaults to joining on indexes. </span><span class="koboSpan" id="kobo.719.2">This simplicity can translate into performance benefits, especially for straightforward joining tasks where the complexity of merge is unnecessary. </span><span class="koboSpan" id="kobo.719.3">By avoiding the overhead of aligning non-index columns, join can execute more quickly in these </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">scenarios [2][6].</span></span></li>
				<li><span class="koboSpan" id="kobo.721.1">Under </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.722.1">the hood, join uses </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">merge [2][6].</span></span></li>
				<li><span class="koboSpan" id="kobo.724.1">When</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.725.1"> joining large DataFrames, the way join and merge handle memory can impact performance. </span><span class="koboSpan" id="kobo.725.2">A join, by focusing on index-based joining, might manage memory usage more efficiently in certain scenarios, especially when the DataFrames have indexes that pandas can optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">on [1][3][4].</span></span></li>
				<li><span class="koboSpan" id="kobo.727.1">While merge offers greater flexibility by allowing joins on arbitrary columns, this flexibility comes with a performance cost, especially for complex joins involving multiple columns or non-index joins. </span><span class="koboSpan" id="kobo.727.2">Join offers a performance advantage in simpler, index-based joins due to its more specific use </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">case [2][6].</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.729.1">In summary, choosing between </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">join</span></strong><span class="koboSpan" id="kobo.731.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">merge</span></strong><span class="koboSpan" id="kobo.733.1"> depends on the specific requirements of your task. </span><span class="koboSpan" id="kobo.733.2">If your joining operation is primarily based on indexes, join can offer performance benefits due to its optimization for index-based joining and its simpler interface. </span><span class="koboSpan" id="kobo.733.3">However, for more complex joining needs that involve specific columns or multiple keys, merge provides the necessary flexibility, albeit with potential impacts </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">on performance.</span></span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.735.1">Concatenating DataFrames</span></h1>
			<p><span class="koboSpan" id="kobo.736.1">When you have datasets spread across multiple DataFrames with similar structures (same columns or same rows) and you want to combine them into a single DataFrame, this is where concatenating shines. </span><span class="koboSpan" id="kobo.736.2">The concatenation process can be along a particular axis, either row-wise (</span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">axis=0</span></strong><span class="koboSpan" id="kobo.738.1">) or </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">column-wise (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">axis=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">).</span></span></p>
			<p><span class="koboSpan" id="kobo.742.1">Let’s deep dive into the row-wise concatenation, also known </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">as append.</span></span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.744.1">Row-wise concatenation</span></h2>
			<p><span class="koboSpan" id="kobo.745.1">The </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.746.1">row-wise concatenation is used to</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.747.1"> concatenate one DataFrame to another along </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">axis=0</span></strong><span class="koboSpan" id="kobo.749.1">. </span><span class="koboSpan" id="kobo.749.2">To showcase this operation, two DataFrames, </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">employee_data_1</span></strong><span class="koboSpan" id="kobo.751.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">employee_data_2</span></strong><span class="koboSpan" id="kobo.753.1">, created with the same structure but different data can be </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">seen here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.755.1">
employee_data_1 = pd.DataFrame({
  'employee_id': np.arange(1, 6),
  'name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
  'department': ['HR', 'IT', 'Marketing', 'Finance', 'IT']
})
employee_data_2 = pd.DataFrame({
  'employee_id': np.arange(6, 11),
  'name': ['Frank', 'Grace', 'Hannah', 'Ian', 'Jill'],
  'department': ['Logistics', 'HR', 'IT', 'Marketing', 'Finance']
})</span></pre>			<p><span class="koboSpan" id="kobo.756.1">Let’s perform the row-wise concatenation, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">code snippet:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
concatenated_data = pd.concat([employee_data_1, employee_data_2], axis=0)</span></pre>			<p><span class="koboSpan" id="kobo.759.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">pd.concat()</span></strong><span class="koboSpan" id="kobo.761.1"> function is used to concatenate the two DataFrames. </span><span class="koboSpan" id="kobo.761.2">The first argument is a list of DataFrames to concatenate, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">axis=0</span></strong><span class="koboSpan" id="kobo.763.1"> parameter specifies that the concatenation should be row-wise, stacking the DataFrames on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">each other.</span></span></p>
			<p><span class="koboSpan" id="kobo.765.1">The result can be </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">seen here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
   employee_id     name department
0            1    Alice         HR
1            2      Bob         IT
2            3  Charlie  Marketing
3            4    David    Finance
4            5      Eva         IT
0            6    Frank  Logistics
1            7    Grace         HR
2            8   Hannah         IT
3            9      Ian  Marketing
4           10     Jill    Finance</span></pre>			<p><span class="koboSpan" id="kobo.768.1">Some things </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.769.1">you need to consider </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.770.1">when performing row-wise concatenation are </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">as follows:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.772.1">Ensure that the columns you want to concatenate are aligned correctly. </span><span class="koboSpan" id="kobo.772.2">pandas will automatically align columns by name and fill any missing columns with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">NaN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.774.1"> values.</span></span></li>
				<li><span class="koboSpan" id="kobo.775.1">After concatenation, you may want to reset the index of the resulting DataFrame to avoid duplicate index values, especially if the original DataFrames had their own range of indices. </span><span class="koboSpan" id="kobo.775.2">Observe the index in the following example before performing a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">reset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1"> operation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.778.1">
   employee_id     name  department
0            1    Alice          HR
1            2      Bob          IT
2            3  Charlie   Marketing
3            4    David     Finance
4            5      Eva          IT
0            6    Frank   Logistics
1            7    Grace          HR
2            8   Hannah          IT
3            9      Ian   Marketing
4           10     Jill     Finance</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.779.1">Let’s</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.780.1"> now perform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">reset</span></strong><span class="koboSpan" id="kobo.782.1"> operation on </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">the index:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.784.1">concatenated_data_reset = concatenated_data.reset_index(drop=True)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.785.1">Let’s see</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.786.1"> the output </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">once more:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.788.1">   employee_id     name  department
0            1    Alice          HR
1            2      Bob          IT
2            3  Charlie   Marketing
3            4    David     Finance
4            5      Eva          IT
5            6    Frank   Logistics
6            7    Grace          HR
7            8   Hannah          IT
8            9      Ian   Marketing
9           10     Jill     Finance</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.789.1">Resetting the index creates a new, continuous index for the concatenated DataFrame. </span><span class="koboSpan" id="kobo.789.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">drop=True</span></strong><span class="koboSpan" id="kobo.791.1"> parameter is used to avoid adding the old index as a column in the new DataFrame. </span><span class="koboSpan" id="kobo.791.2">This step is crucial for maintaining a clean DataFrame, especially when the index itself does not carry meaningful data. </span><span class="koboSpan" id="kobo.791.3">A continuous index is often easier to work with, particularly for indexing, slicing, and potential future merges </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">or joins.</span></span></p></li>				<li><span class="koboSpan" id="kobo.793.1">Concatenation can increase the memory usage of your program, especially when working with large DataFrames. </span><span class="koboSpan" id="kobo.793.2">Be mindful of the available </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">memory resources.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.795.1">In the next section, we will discuss the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">column-wise concatenation.</span></span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.797.1">Column-wise concatenation</span></h2>
			<p><span class="koboSpan" id="kobo.798.1">Concatenating </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.799.1">DataFrames column-wise</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.800.1"> in pandas involves combining two or more DataFrames side by side, aligning them by their index. </span><span class="koboSpan" id="kobo.800.2">To showcase this operation, the two DataFrames we have been using so far, </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">employee_data_1</span></strong><span class="koboSpan" id="kobo.802.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">employee_data_2</span></strong><span class="koboSpan" id="kobo.804.1">, will be used, and the operation can be done as </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">shown here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
concatenated_data = pd.concat([employee_data_1, employee_performance], axis=1)</span></pre>			<p><span class="koboSpan" id="kobo.807.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">pd.concat()</span></strong><span class="koboSpan" id="kobo.809.1"> function is used with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">axis=1</span></strong><span class="koboSpan" id="kobo.811.1"> parameter to concatenate the DataFrames side by side. </span><span class="koboSpan" id="kobo.811.2">This aligns the DataFrames by their index, effectively adding new columns from </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">employee_performance</span></strong><span class="koboSpan" id="kobo.813.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">employee_data_1</span></strong><span class="koboSpan" id="kobo.815.1">. </span><span class="koboSpan" id="kobo.815.2">This will display the </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">following output:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.817.1">
  employee_id     name department employee_id performance_rating
0           1    Alice         HR           1            3
1           2      Bob         IT           2            4
2           3  Charlie  Marketing           3            5
3           4    David    Finance           4            3
4           5      Eva         IT           5            4</span></pre>			<p><span class="koboSpan" id="kobo.818.1">Some things you </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.819.1">need to consider when performing column-wise concatenation are </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">as follows:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.821.1">The indices of the DataFrames to be concatenated are aligned properly. </span><span class="koboSpan" id="kobo.821.2">When concatenating DataFrames column-wise, each row in the resulting DataFrame should ideally represent data from the same entity (e.g., the same employee). </span><span class="koboSpan" id="kobo.821.3">Misaligned indexes can lead to a scenario where data from different entities is erroneously combined, leading to inaccurate and misleading results. </span><span class="koboSpan" id="kobo.821.4">For example, if the index represents employee IDs, misalignment could result in an employee’s details being incorrectly paired with another employee’s </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">performance data.</span></span></li>
				<li><span class="koboSpan" id="kobo.823.1">If the </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.824.1">DataFrames contain columns with the same name but are intended to be distinct, consider renaming these columns before concatenation to avoid confusion or errors in the </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">resulting DataFrame.</span></span></li>
				<li><span class="koboSpan" id="kobo.826.1">While </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.827.1">column-wise concatenation typically does not increase memory usage as significantly as row-wise concatenation, it is still important to monitor memory usage, especially with </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">large DataFrames.</span></span></li>
			</ul>
			<p class="callout-heading"><span class="koboSpan" id="kobo.829.1">Join versus concatenation</span></p>
			<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.830.1">Concatenation</span></strong><span class="koboSpan" id="kobo.831.1"> is primarily</span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.832.1"> used for combining DataFrames along an axis (either rows or columns) without considering the values within. </span><span class="koboSpan" id="kobo.832.2">It’s ideal for situations where you simply want to stack DataFrames together based on their order or extend them with </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">additional columns.</span></span></p>
			<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.834.1">Joins</span></strong><span class="koboSpan" id="kobo.835.1"> are used to </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.836.1">combine DataFrames based on one or more keys (a common identifier in each DataFrame). </span><span class="koboSpan" id="kobo.836.2">This is more about merging datasets based on shared data points, which allows for more complex and conditional combinations </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">of data.</span></span></p>
			<p><span class="koboSpan" id="kobo.838.1">Having explored the nuances of concatenation in pandas, including its importance for aligning indexes and how it contrasts with join operations, let’s now summarize the key points discussed to encapsulate our understanding and highlight the critical takeaways from our exploration of DataFrame manipulations </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">in pandas.</span></span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.840.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.841.1">In this chapter, we explored various aspects of DataFrame operations in pandas, focusing on concatenation, merging, and the importance of </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">managing indexes.</span></span></p>
			<p><span class="koboSpan" id="kobo.843.1">We discussed merging, which is suited for complex combinations based on shared keys, offering flexibility through various join types such as inner, outer, left, and right joins. </span><span class="koboSpan" id="kobo.843.2">We also discussed how concatenation is used to combine DataFrames along a specific axis (either row-wise or column-wise) and is particularly useful for appending datasets or adding new dimensions to data. </span><span class="koboSpan" id="kobo.843.3">The performance implications of these operations were discussed, highlighting that proper index management can significantly enhance the efficiency of these operations, especially in </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">large datasets.</span></span></p>
			<p><span class="koboSpan" id="kobo.845.1">In the upcoming chapter, we will deep dive into how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">groupby</span></strong><span class="koboSpan" id="kobo.847.1"> function can be leveraged alongside various aggregation functions to extract meaningful insights from complex </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">data structures.</span></span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.849.1">References</span></h1>
			<ol>
				<li><a href="https://github.com/pandas-dev/pandas/issues/38418"><span class="No-Break"><span class="koboSpan" id="kobo.850.1">https://github.com/pandas-dev/pandas/issues/38418</span></span></a></li>
				<li><a href="https://realpython.com/pandas-merge-join-and-concat/"><span class="No-Break"><span class="koboSpan" id="kobo.851.1">https://realpython.com/pandas-merge-join-and-concat/</span></span></a></li>
				<li><a href="https://datascience.stackexchange.com/questions/44476/merging-dataframes-in-pandas-is-taking-a-surprisingly-long-time"><span class="No-Break"><span class="koboSpan" id="kobo.852.1">https://datascience.stackexchange.com/questions/44476/merging-dataframes-in-pandas-is-taking-a-surprisingly-long-time</span></span></a></li>
				<li><a href="https://stackoverflow.com/questions/40860457/improve-pandas-merge-performance"><span class="No-Break"><span class="koboSpan" id="kobo.853.1">https://stackoverflow.com/questions/40860457/improve-pandas-merge-performance</span></span></a></li>
				<li><a href="https://www.youtube.com/watch?v=P6hSBrxs0Eg"><span class="No-Break"><span class="koboSpan" id="kobo.854.1">https://www.youtube.com/watch?v=P6hSBrxs0Eg</span></span></a></li>
				<li><a href="https://pandas.pydata.org/pandas-docs/version/1.5.1/user_guide/merging.html"><span class="No-Break"><span class="koboSpan" id="kobo.855.1">https://pandas.pydata.org/pandas-docs/version/1.5.1/user_guide/merging.html</span></span></a></li>
				<li><a href="https://pandas.pydata.org/pandas-docs/version/0.20/merging.html"><span class="No-Break"><span class="koboSpan" id="kobo.856.1">https://pandas.pydata.org/pandas-docs/version/0.20/merging.html</span></span></a></li>
			</ol>
		</div>
	</body></html>