- en: Chapter 15. Symbolic and Numerical Mathematics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Diving into symbolic computing with SymPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving equations and inequalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing real-valued functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing exact probabilities and manipulating random variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit of number theory with SymPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a Boolean propositional formula from a truth table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Sage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce **SymPy**, a Python library for symbolic
    mathematics. Whereas most of the book deals with numerical methods, we will see
    examples here where symbolic computations are more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: SymPy is to symbolic computing what NumPy is to numerical computing. For example,
    SymPy can help us analyze a mathematical model before we run a simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Although quite powerful, SymPy is a bit slow compared to other computer algebra
    systems. The main reason is that SymPy is written in pure Python. A faster and
    more powerful mathematics system is **Sage** (see also the *Getting started with
    Sage* recipe in this chapter). Sage is a heavy standalone program that has many
    big dependencies (including SymPy!), and it uses only Python 2 at the time of
    writing. It is essentially meant for interactive use. Sage includes an IPython-like
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LaTeX** is a document markup language widely used to write publication-quality
    mathematical equations. Equations written in LaTeX can be displayed in the browser
    with the **MathJax** JavaScript library. SymPy uses this system to display equations
    in the IPython notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX equations can also be used in matplotlib. In this case, it is recommended
    to have a LaTeX installation on your local computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX on Wikipedia, at [http://en.wikipedia.org/wiki/LaTeX](http://en.wikipedia.org/wiki/LaTeX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MathJax, available at [www.mathjax.org](http://www.mathjax.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LaTeX in matplotlib, described at [http://matplotlib.org/users/usetex.html](http://matplotlib.org/users/usetex.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for displaying equations with SymPy, available at [http://docs.sympy.org/latest/tutorial/printing.html](http://docs.sympy.org/latest/tutorial/printing.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To install LaTeX on your computer, refer to [http://latex-project.org/ftp.html](http://latex-project.org/ftp.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into symbolic computing with SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will give a brief introduction to symbolic computing with
    SymPy. We will see more advanced features of SymPy in the next recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy is a pure Python package with no other dependencies, and as such, it is
    very easy to install. With Anaconda, you can type `conda install sympy` in a terminal.
    On Windows, you can use Chris Gohlke's package ([www.lfd.uci.edu/~gohlke/pythonlibs/#sympy](http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy)).
    Finally, you can use the `pip install sympy` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy can be used from a Python module, or interactively in IPython. In the
    notebook, all mathematical expressions are displayed with LaTeX, thanks to the
    MathJax JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an introduction to SymPy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import SymPy and enable LaTeX printing in the IPython notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To deal with symbolic variables, we first need to declare them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `var()` function creates symbols and injects them into the namespace. This
    function should only be used in the interactive mode. In a Python module, it is
    better to use the `symbols()` function that returns the symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can create mathematical expressions with these symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Are these expressions equal?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These expressions are mathematically equal, but not syntactically identical.
    To test whether they are mathematically equal, we can ask SymPy to simplify the
    difference algebraically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A very common operation with symbolic expressions is the substitution of a symbol
    by another symbol, expression, or a number, using the `subs()` method of a symbolic
    expression:![How to do it...](img/4818OS_15_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Substitution in a SymPy expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A rational number cannot be written simply as `1/2` as this Python expression
    evaluates to 0\. A possibility is to convert the number `1` into a SymPy integer
    object, for example by using the `S()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exactly represented numbers can be evaluated numerically with `evalf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can easily create a Python function from a SymPy symbolic expression using
    the `lambdify()` function. The resulting function can notably be evaluated on
    NumPy arrays. This is quite convenient when we need to go from the symbolic world
    to the numerical world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A core idea in SymPy is to use the standard Python syntax to manipulate exact
    expressions. Although this is very convenient and natural, there are a few caveats.
    Symbols such as `x`, which represent mathematical variables, cannot be used in
    Python before being instantiated (otherwise, a `NameError` exception is thrown
    by the interpreter). This is in contrast to most other computer algebra systems.
    For this reason, SymPy offers ways to declare symbolic variables beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is integer division; as `1/2` evaluates to `0` (in Python 2),
    SymPy has no way to know that the user intended to write a fraction instead. We
    need to convert the numerical integer `1` to the symbolic integer `1` before dividing
    it by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the Python equality refers to the equality between syntax trees rather
    than between mathematical expressions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Solving equations and inequalities* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Getting started with Sage* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving equations and inequalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SymPy offers several ways to solve linear and nonlinear equations and systems
    of equations. Of course, these functions do not always succeed in finding closed-form
    exact solutions. In this case, we can fall back to numerical solvers and obtain
    approximate solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first need to import SymPy. We also initialize pretty printing in the notebook
    (see the first recipe of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a few symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `solve()` function to solve equations (the right-hand side is `0`
    by default):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also solve inequalities. Here, we need to use the `solve_univariate_inequality()`
    function to solve this univariate inequality in the real domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `solve()` function also accepts systems of equations (here, a linear system):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Nonlinear systems are also handled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Singular linear systems can also be solved (here, there is an infinite number
    of solutions because the two equations are collinear):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s solve a linear system using matrices containing symbolic variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create the **augmented matrix**, which is the horizontal concatenation of
    the system''s matrix with the linear coefficients and the right-hand side vector.
    This matrix corresponds to the following system in *x,y: ax+by=u, cx+dy=v*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This system needs to be nonsingular in order to have a unique solution, which
    is equivalent to saying that the determinant of the system''s matrix needs to
    be nonzero (otherwise the denominators in the preceding fractions are equal to
    zero):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrix support in SymPy is quite rich; we can perform a large number of operations
    and decompositions (see the reference guide at [http://docs.sympy.org/latest/modules/matrices/matrices.html](http://docs.sympy.org/latest/modules/matrices/matrices.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are more references about linear algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra on Wikipedia, at [http://en.wikipedia.org/wiki/Linear_algebra#Further_reading](http://en.wikipedia.org/wiki/Linear_algebra#Further_reading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear algebra on Wikibooks, at [http://en.wikibooks.org/wiki/Linear_Algebra](http://en.wikibooks.org/wiki/Linear_Algebra)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing real-valued functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SymPy contains a rich **calculus** toolbox to analyze real-valued functions:
    limits, power series, derivatives, integrals, Fourier transforms, and so on. In
    this recipe, we will show the very basics of these capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first need to import SymPy. We also initialize pretty printing in the notebook
    (see the first recipe of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a few symbols and a function (which is just an expression depending
    on `x`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s evaluate this function at `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compute the derivative of this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What is `f`''s limit to infinity? (Note the double o (`oo`) for the infinity
    symbol):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here's how to compute a Taylor series (here, around `0`, of order `9`). The
    **Big O** can be removed with the `removeO()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compute definite integrals (here, over the entire real line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SymPy can also compute indefinite integrals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s compute `f`''s Fourier transforms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy includes a large number of other integral transforms besides the Fourier
    transform ([http://docs.sympy.org/dev/modules/integrals/integrals.html](http://docs.sympy.org/dev/modules/integrals/integrals.html)).
    However, SymPy will not always be able to find closed-form solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few general references about real analysis and calculus:'
  prefs: []
  type: TYPE_NORMAL
- en: Real analysis on Wikipedia, at [http://en.wikipedia.org/wiki/Real_analysis#Bibliography](http://en.wikipedia.org/wiki/Real_analysis#Bibliography)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculus on Wikibooks, at [http://en.wikibooks.org/wiki/Calculus](http://en.wikibooks.org/wiki/Calculus)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing exact probabilities and manipulating random variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SymPy includes a module named `stats` that lets us create and manipulate random
    variables. This is useful when we work with probabilistic or statistical models;
    we can compute symbolic expectancies, variances probabilities, and densities of
    random variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import SymPy and the stats module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s roll two dice, `X` and `Y`, with six faces each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compute probabilities defined by equalities (with the `Eq` operator)
    or inequalities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Conditions can also involve multiple random variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compute conditional probabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also work with arbitrary discrete or continuous random variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compute expectancies and variances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also compute densities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can plot these densities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_15_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The Gaussian density
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SymPy''s `stats` module contains many functions to define random variables
    with classical laws (binomial, exponential, and so on), discrete or continuous.
    It works by leveraging SymPy''s powerful integration algorithms to compute exact
    probabilistic quantities as integrals of probability distributions. For example,
    ![How it works...](img/4818OS_15_10.jpg) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the equality condition is written using the `Eq` operator rather than
    the more standard `==` Python syntax. This is a general feature in SymPy; `==`
    means equality between Python variables, whereas `Eq` is the mathematical operation
    between symbolic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: A bit of number theory with SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SymPy contains many number-theory-related routines: obtaining prime numbers,
    integer decompositions, and much more. We will show a few examples here.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To display legends using LaTeX in matplotlib, you will need an installation
    of LaTeX on your computer (see this chapter's *Introduction*).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import SymPy and the number theory package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can test whether a number is prime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can find the next prime after a given number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the 1000th prime number?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many primes less than 2011 are there?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can plot ![How to do it...](img/4818OS_15_11.jpg), the **prime-counting
    function** (the number of prime numbers less than or equal to some number *x*).
    The famous **prime number theorem** states that this function is asymptotically
    equivalent to *x/*log*(x)*. This expression approximately quantifies the distribution
    of prime numbers among all integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_15_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Distribution of prime numbers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s compute the integer factorization of a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, a small problem. A lazy mathematician is counting his marbles. When
    they are arranged in three rows, the last column contains one marble. When they
    form four rows, there are two marbles in the last column, and there are three
    with five rows. How many marbles are there? (Hint: The lazy mathematician has
    fewer than 100 marbles.)![How to do it...](img/4818OS_15_05.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Counting marbles with the Chinese Remainder Theorem
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Chinese Remainder Theorem gives us the answer:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are infinitely many solutions: 58 plus any multiple of 60\. Since there
    are less than 100 marbles, 58 is the right answer.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SymPy contains many number-theory-related functions. Here, we used the **Chinese
    Remainder Theorem** to find the solutions of the following system of arithmetic
    equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Chinese Remainder Theorem
  prefs: []
  type: TYPE_NORMAL
- en: The triple bar is the symbol for modular congruence. Here, it means that *m[i]*
    divides *a[i]-n*. In other words, *n* and *a[i]* are equal up to a multiple of
    *m[i]*. Reasoning with congruences is very convenient when periodic scales are
    involved. For example, operations involving 12-hour clocks are done modulo 12\.
    The numbers 11 and 23 are equivalent modulo 12 (they represent the same hour on
    the clock) because their difference is a multiple of 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe''s example, three congruences have to be satisfied: the remainder
    of the number of marbles in the division with 3 is 1 (there''s one extra marble
    in that arrangement), it is 2 in the division with 4, and 3 in the division with
    5\. With SymPy, we simply specify these values in the `solve_congruence()` function
    to get the solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: The theorem states that solutions exist as soon as the *m[i]* are pairwise co-prime
    (any two distinct numbers among them are co-prime). All solutions are congruent
    modulo the product of the *m[i]*. This fundamental theorem in number theory has
    several applications, notably in cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few textbooks about number theory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Undergraduate level: *Elementary Number Theory*, *Gareth A. Jones*, *Josephine
    M. Jones*, *Springer*, *(1998)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Graduate level: *A Classical Introduction to Modern Number Theory*, *Kenneth
    Ireland*, *Michael Rosen*, *Springer*, *(1982)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on SymPy's number-theory module, available at [http://docs.sympy.org/dev/modules/ntheory.html](http://docs.sympy.org/dev/modules/ntheory.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chinese Remainder Theorem on Wikipedia, at [http://en.wikipedia.org/wiki/Chinese_remainder_theorem](http://en.wikipedia.org/wiki/Chinese_remainder_theorem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications of the Chinese Remainder Theorem, given at [http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem](http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a Boolean propositional formula from a truth table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logic module in SymPy lets us manipulate complex Boolean expressions, also
    known as **propositional formulas**.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show an example where this module can be useful. Let's suppose
    that, in a program, we need to write a complex `if` statement depending on three
    Boolean variables. We can think about each of the eight possible cases (true,
    true and false, and so on) and evaluate what the outcome should be. SymPy offers
    a function to generate a compact logic expression that satisfies our truth table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import SymPy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s define a few symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can define propositional formulas with symbols and a few operators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use `subs()` to evaluate a formula on actual Boolean values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we want to find a propositional formula depending on `x`, `y`, and `z`,
    with the following truth table:![How to do it...](img/4818OS_15_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A truth table
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s write down all combinations that we want to evaluate to `True`, and
    those for which the outcome does not matter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use the `SOPform()` function to derive an adequate formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s test that this proposition works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SOPform()` function generates a full expression corresponding to a truth
    table and simplifies it using the **Quine-McCluskey algorithm**. It returns the
    smallest *Sum of Products* form (or disjunction of conjunctions). Similarly, the
    `POSform()` function returns a Product of Sums.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given truth table can occur in this case: suppose that we want to write
    a file if it doesn''t already exist (`z`), or if the user wants to force the writing
    (`x`). In addition, the user can prevent the writing (`y`). The expression evaluates
    to `True` if the file is to be written. The resulting SOP formula works if we
    explicitly forbid `x` and `y` in the first place (forcing and preventing the writing
    at the same time is forbidden).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: The propositional formula on Wikipedia, at [http://en.wikipedia.org/wiki/Propositional_formula](http://en.wikipedia.org/wiki/Propositional_formula)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum of Products on Wikipedia, at [http://en.wikipedia.org/wiki/Canonical_normal_form](http://en.wikipedia.org/wiki/Canonical_normal_form)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Quine–McCluskey algorithm on Wikipedia, at [http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm](http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will conduct a brief analytical study of a famous nonlinear differential
    system: the **Lotka-Volterra equations**, also known as predator-prey equations.
    These equations are first-order differential equations that describe the evolution
    of two interacting populations (for example, sharks and sardines), where the predators
    eat the prey. This example illustrates how to obtain exact expressions and results
    about fixed points and their stability with SymPy.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, knowing the basics of linear and nonlinear systems of differential
    equations is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create some symbols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variables `x` and `y` represent the populations of the prey and predators,
    respectively. The parameters `a`, `b`, `c`, and `d` are strictly positive parameters
    (described more precisely in the *How it works...* section of this recipe). The
    equations are:![How to do it...](img/4818OS_15_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lotka-Volterra equations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s find the fixed points of the system (solving *f(x,y) = g(x,y) = 0*).
    We call them *(x[0], y[0])* and *(x[1], y[1])*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s write the 2D vector with the two equations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can compute the **Jacobian** of the system, as a function of `(x, y)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s study the stability of the first fixed point by looking at the eigenvalues
    of the Jacobian at this point. The first fixed point corresponds to extinct populations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parameters `a` and `c` are strictly positive, so the eigenvalues are real
    and of opposite signs, and this fixed point is a **saddle point**. As this point
    is unstable, the extinction of both populations is unlikely in this model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s consider the second fixed point now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The eigenvalues are purely imaginary; thus, this fixed point is not hyperbolic.
    Therefore, we cannot draw conclusions from this linear analysis about the qualitative
    behavior of the system around this fixed point. However, we could show with other
    methods that oscillations occur around this point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lotka-Volterra equations model the growth of the predator and prey populations,
    taking into account their interactions. In the first equation, the *ax* term represents
    the exponential growth of the prey, and *-bxy* represents death by predators.
    Similarly, in the second equation, *-yc* represents the natural death of the predators,
    and *dxy* represents their growth as they eat more and more prey.
  prefs: []
  type: TYPE_NORMAL
- en: To find the **equilibrium points** of the system, we need to find the values
    *x, y* such that *dx/dt = dy/dt = 0*, that is, *f(x, y) = g(x, y) = 0*, so that
    the variables do not evolve anymore. Here, we were able to obtain analytical values
    for these equilibrium points with the `solve()` function.
  prefs: []
  type: TYPE_NORMAL
- en: To analyze their stability, we need to perform a linear analysis of the nonlinear
    equations, by taking the **Jacobian matrix** at these equilibrium points. This
    matrix represents the linearized system, and its eigenvalues tell us about the
    stability of the system near the equilibrium point. The **Hartman–Grobman theorem**
    states that the behavior of the original system qualitatively matches the behavior
    of the linearized system around an equilibrium point if this point is **hyperbolic**
    (meaning that no eigenvalues of the matrix have a real part equal to 0). Here,
    the first equilibrium point is hyperbolic as *a, c > 0*, but the second is not.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we were able to compute symbolic expressions for the Jacobian matrix and
    its eigenvalues at the equilibrium points.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even when a differential system is not solvable analytically (as is the case
    here), a mathematical analysis can still give us qualitative information about
    the behavior of the system's solutions. A purely numerical analysis is not always
    relevant when we are interested in qualitative results, as numerical errors and
    approximations can lead to wrong conclusions about the system's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix documentation in SymPy, available at [http://docs.sympy.org/dev/modules/matrices/matrices.html](http://docs.sympy.org/dev/modules/matrices/matrices.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamical systems on Wikipedia, at [http://en.wikipedia.org/wiki/Dynamical_system](http://en.wikipedia.org/wiki/Dynamical_system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equilibrium points on Scholarpedia, at [www.scholarpedia.org/article/Equilibrium](http://www.scholarpedia.org/article/Equilibrium)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bifurcation theory on Wikipedia, at [http://en.wikipedia.org/wiki/Bifurcation_theory](http://en.wikipedia.org/wiki/Bifurcation_theory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaos theory on Wikipedia, at [http://en.wikipedia.org/wiki/Chaos_theory](http://en.wikipedia.org/wiki/Chaos_theory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading on dynamical systems, at [http://en.wikipedia.org/wiki/Dynamical_system#Further_reading](http://en.wikipedia.org/wiki/Dynamical_system#Further_reading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Sage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sage ([www.sagemath.org](http://www.sagemath.org)) is a standalone mathematics
    software based on Python. It is an open source alternative to commercial products
    such as Mathematica, Maple, or MATLAB. Sage provides a unified interface to many
    open source mathematical libraries. These libraries include SciPy, SymPy, NetworkX,
    and other Python scientific packages, but also non-Python libraries such as ATLAS,
    BLAS, GSL, LAPACK, Singular, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will give a brief introduction to Sage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can either:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Sage on your local computer ([www.sagemath.org/doc/installation/](http://www.sagemath.org/doc/installation/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create Sage notebooks remotely in the cloud ([https://cloud.sagemath.com/](https://cloud.sagemath.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Being based on so many libraries, Sage is heavy and hard to compile from source.
    Binaries exist for most systems except Windows, where you generally have to use
    VirtualBox (a virtualization solution: [www.virtualbox.org](http://www.virtualbox.org)).'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use Sage in a browser with an IPython notebook running
    on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Sage is not compatible with Python 3 at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, Sage is used interactively with the built-in notebook (which resembles
    the IPython notebook). If you want to use Sage in a Python program (that is, importing
    Sage from Python), you need to run Sage's built-in Python interpreter ([www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script](http://www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will create a new Sage notebook and introduce the most basic features:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sage accepts mathematical expressions as we would expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Being based on Python, Sage''s syntax is almost Python, but there are a few
    differences. For example, the power exponent is the more classical `^` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like in SymPy, symbolic variables need to be declared beforehand with the `var()`
    function. However, the `x` variable is always predefined. Here, we define a new
    mathematical function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s simplify the expression of `f`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s evaluate `f` on a given point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Functions can be differentiated and integrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sage also supports numerical computations in addition to symbolic computations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sage also comes with rich plotting capabilities (including interactive plotting
    widgets):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_15_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This (too) short recipe cannot do justice to the huge list of possibilities
    offered by Sage. Many aspects of mathematics are covered: algebra, combinatorics,
    numerical mathematics, number theory, calculus, geometry, graph theory, and many
    others. Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: An in-depth tutorial on Sage, available at [www.sagemath.org/doc/tutorial/](http://www.sagemath.org/doc/tutorial/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sage reference manual, available at [www.sagemath.org/doc/reference/](http://www.sagemath.org/doc/reference/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Videos on Sage, available at [www.sagemath.org/help-video.html](http://www.sagemath.org/help-video.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Diving into symbolic computing with SymPy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
