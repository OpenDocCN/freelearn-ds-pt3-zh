<html><head></head><body>
		<div id="_idContainer174">
			<h1 id="_idParaDest-143"><em class="italic"><a id="_idTextAnchor143"/>Chapter 10</em>: Turbo-charge Your Apps with Advanced Callbacks</h1>
			<p>We will now take our apps to a new level of abstraction and power by introducing new options available to callbacks. The general pattern we have followed has been that we provide users with a component that they can interact with. Based on a given set of options available to the component, users can influence certain actions, such as producing a chart, for example. We will be exploring other options such as deferring the execution of callbacks until a certain event happens, for example, clicking a "Submit" button. We will also take a look at how we can allow users to modify the layout of the app itself, by allowing them to add new dynamic components to it. We will use some of this knowledge to add a minor but important improvement to the clustering functionality that we introduced in <a href="B16780_09_Final_NM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 9</em></a>, <em class="italic">Letting Your Data Speak for Itself with Machine Learning</em>.</p>
			<p>We will first start by introducing the optional <strong class="bold">State</strong> parameter in our callbacks. So far, all of our callbacks fire immediately when the user makes changes to any of the inputs. In many cases, we want the users to set a few options and only then hit a "Submit" button to invoke the callback function. This becomes important when we have multiple inputs where it might be annoying or awkward if outputs change while users are still making changes. In other cases, those callbacks might take a long time to execute and/or be expensive to run. Again, in this case, we want to block the execution until the user decides to trigger it.</p>
			<p>Once the concept of <strong class="source-inline">State</strong> has been established, we will explore a new type of dynamic callbacks that enable our users to make changes to the app, by adding new charts for example. So far, we have allowed the users to simply modify the input values available in the interactive components. We can take this to a new level by introducing dynamic components that are generated based on the user's interactions.</p>
			<p>Finally, we will get an overview of <strong class="bold">pattern-matching callbacks</strong>, which allow us to link dynamically created and interactive components together in a streamlined way.</p>
			<p>Here are the main topics that we will cover in this chapter:</p>
			<ul>
				<li>Understanding <strong class="source-inline">State</strong></li>
				<li>Creating components that control other components</li>
				<li>Allowing users to add dynamic components to the app</li>
				<li>Introducing pattern-matching callbacks</li>
			</ul>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor144"/>Technical requirements</h1>
			<p>We will be using the same basic tools that we have used in most chapters so far, and mainly focus on some new features in callback functions. We will use Dash, Dash HTML Components, Dash Core Components, and Dash Bootstrap Components for making our apps. For data manipulation, we will use pandas. For the charts and visualizations, we will be using Plotly and Plotly Express, and finally, we will use JupyterLab to interactively explore and create new functionality independently, before incorporating it into our app.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_10">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_10</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3v6ZYJw">https://bit.ly/3v6ZYJw</a>.</p>
			<p>Let's start by getting familiar with <strong class="source-inline">State</strong>.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/>Understanding State</h1>
			<p>The typical callback function <a id="_idIndexMarker503"/>structure that we used so far contained one or more <strong class="source-inline">Output</strong> elements and one or more <strong class="source-inline">Input</strong> elements. As mentioned in the introduction, the callbacks fire immediately when users modify an <strong class="source-inline">Input</strong> element. We want to relax this option a little. We will start with a simple example demonstrating why and how to use <strong class="source-inline">State</strong>, which is an optional argument that can be given to our callbacks.</p>
			<p>To make the problem we are trying to solve clear, take a look at <em class="italic">Figure 10.1</em>:</p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B16780_10_1.jpg" alt="Figure 10.1 – An interactive app with outputs that are not properly synchronized with input values"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – An interactive app with outputs that are not properly synchronized with input values</p>
			<p>As you can see, the output<a id="_idIndexMarker504"/> is showing the wrong values. The reason is that the app was made very slow by introducing a waiting time, to simulate a practical situation that you might face with your apps. The output was not wrong, actually; it just took too long to update, so when the input was changed, it wasn't immediately reflected in the output area. This is more important in this case because there are two inputs governing the output. The interval between modifying the first and second output might cause such confusion.</p>
			<p>Another more important issue is that these options might take much more time and cost a lot in terms of lost computing power and/or lost analyst time. Our dataset is very small, and the types of calculations we ran on it are also very simple, so performance was not an issue. In practical situations, you will more likely deal with much larger datasets and run computations that take a considerable amount of time. For example, changing the number of clusters to update our model took a really negligible amount of time. In reality, that might take seconds, minutes, or even more. We will solve this by adding a "Submit" button and introducing <strong class="source-inline">State</strong> to our callback function.</p>
			<p>Buttons are available as HTML components from the Dash HTML Components package. They can also be used through Dash Bootstrap Components. Using the latter has two advantages. First, they integrate well <a id="_idIndexMarker505"/>with the theme you are using, so this takes care of visual consistency. Also, and this is probably more important, they easily get one of the meaningful colors in case you want to communicate "success," "warning," "danger," or any of the other available colors/messages.</p>
			<p>Buttons are available as <strong class="source-inline">dcc.Button</strong> or <strong class="source-inline">dbc.Button</strong>. Let's see how they can be used to control the behavior of our app.</p>
			<p>We need to first clarify the difference between <strong class="source-inline">Input</strong> and <strong class="source-inline">State</strong> in our callbacks.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/>Understanding the difference between Input and State</h2>
			<p>First, keep in mind that <strong class="source-inline">Input</strong> is what<a id="_idIndexMarker506"/> triggers the function, and that <strong class="source-inline">State</strong> is simply a set of conditions <a id="_idIndexMarker507"/>that the app is in. It is up to us to decide which components functions as <strong class="source-inline">State</strong> and which as <strong class="source-inline">Input</strong>. </p>
			<p>Let's update the guidelines for callback functions to clarify the distinction that was just introduced:</p>
			<ul>
				<li>The order of callback arguments has to always be one or more of <strong class="source-inline">Output</strong>, <strong class="source-inline">Input</strong>, and optionally <strong class="source-inline">State</strong> arguments, in that order. If we have multiple elements of any one of them, they all need to follow one another.</li>
				<li><strong class="source-inline">State</strong> is optional.</li>
				<li>The <strong class="source-inline">Input</strong> element(s) is what triggers the callback to fire. Changing any or all of the <strong class="source-inline">State</strong> in the app would not cause the execution of the callback.</li>
				<li>Once an <strong class="source-inline">Input</strong> element is modified, the callback will be triggered with whatever <strong class="source-inline">State</strong> has been changed since it was last triggered.</li>
			</ul>
			<p>Let's now see how to produce the code for the app shown in <em class="italic">Figure 10.1</em>, and then modify it for the desired behavior. The callback function currently looks like this:</p>
			<p class="source-code">@app.callback(Output('output', 'children'),</p>
			<p class="source-code">              <strong class="bold">Input('dropdown', 'value')</strong>,</p>
			<p class="source-code">              <strong class="bold">Input('textarea', 'value')</strong>)</p>
			<p class="source-code">def display_values(dropdown_val, textarea_val):</p>
			<p class="source-code">    return f'You chose "{dropdown_val}" from the dropdown, and wrote "{textarea_val}" in the textarea.'</p>
			<p>This is how we have managed all callbacks so far. Note that the callback will run if either of the two inputs were modified. The <a id="_idIndexMarker508"/>change we want to introduce will require two steps: </p>
			<ol>
				<li value="1">Add a button component <a id="_idIndexMarker509"/>to the page, placed under the <strong class="source-inline">Textarea</strong> component: <p class="source-code">import dash_bootstrap_components as dbc</p><p class="source-code">dbc.Button("Submit", id="button")</p><p class="source-code"># OR</p><p class="source-code">import dash_html_components as html</p><p class="source-code">html.Button("Submit", id="button")</p></li>
				<li>Add the button as an <strong class="source-inline">Input</strong> argument to the callback function. We now introduce a new property that we haven't seen yet, which is <strong class="source-inline">n_clicks</strong>. As the name suggests, this corresponds to the number of clicks that were made on a certain component during its lifetime in the user session. With every click, the number gets incremented by one, and we can use that variable to check and control the callback's behavior. Note that we can also give it a default starting value, typically zero, but we can give it another number if we want:<p class="source-code">Input("button", "n_clicks")</p></li>
				<li>Now that we have made the button our <strong class="source-inline">Input</strong>, we want to keep <strong class="source-inline">Dropdown</strong> and <strong class="source-inline">Textarea</strong>, but make them <strong class="source-inline">State</strong> arguments as follows:<p class="source-code">@app.callback(Output('output', 'children'),</p><p class="source-code">              <strong class="bold">Input('button', 'n_clicks')</strong>,</p><p class="source-code">              <strong class="bold">State('dropdown', 'value')</strong>,</p><p class="source-code">              <strong class="bold">State('textarea', 'value')</strong>)</p></li>
				<li>With these changes, the callback now waits for <strong class="source-inline">Input</strong> to be changed. The user can change <strong class="source-inline">Dropdown</strong> and/or <strong class="source-inline">Textarea</strong> as many times as they want without being interrupted, and<a id="_idIndexMarker510"/> when they are ready, they can hit the "Submit" button to get the desired result.</li>
				<li>When the app loads for the<a id="_idIndexMarker511"/> first time, the default value of the <strong class="source-inline">n_clicks</strong> property is <strong class="source-inline">None</strong>. Also, we have nothing in the <strong class="source-inline">Textarea</strong> component and there are no options selected from the dropdown yet. So, we do as usual: we use <strong class="source-inline">raise PreventUpdate</strong> if we don't have a value for <strong class="source-inline">n_clicks</strong>. To update the function we introduced, we can simply introduce the following change to the signature of the function. Note the addition of the corresponding <strong class="source-inline">n_clicks</strong> argument, as well as its relative order:<p class="source-code">def display_values(<strong class="bold">n_clicks</strong>, dropdown_val, textarea_val):</p><p class="source-code">    if not n_clicks:</p><p class="source-code">        raise PreventUpdate</p><p class="source-code">    return … </p></li>
			</ol>
			<p>If we update the code, we can see that things will work as expected and the user will be more in control of the process. <em class="italic">Figure 10.2</em> shows the updated functionality: </p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B16780_10_2.jpg" alt="Figure 10.2 – An interactive app with outputs now properly displaying the expected input values"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – An interactive app with outputs now properly displaying the expected input values</p>
			<p>We can improve this<a id="_idIndexMarker512"/> experience even more by providing the user with a visual cue, indicating that<a id="_idIndexMarker513"/> some processing is underway.</p>
			<p>With this new knowledge fresh in mind, let's use it to modify the behavior of our clustering functionality that we discussed in the introduction to this chapter. <em class="italic">Figure 10.3</em> shows the desired outcome that we want to achieve:</p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B16780_10_3.jpg" alt="Figure 10.3 – The clustering functionality with a Submit button and a visual progress indicator"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – The clustering functionality with a Submit button and a visual progress indicator</p>
			<p>As you can see, we have introduced two new features. The first is the button that we have already discussed and implemented in our independent small app. The second is the Dash Core Components <strong class="source-inline">Loading</strong> component. This component is responsible for displaying the symbol that<a id="_idIndexMarker514"/> is seen moving, or sometimes spinning, where the<a id="_idIndexMarker515"/> output is expected to appear. Using it is extremely simple, but it's also crucial in such cases as this. It's always good to confirm to users that their selection (or any other interaction) has been acknowledged and is under process. Actually, I think it's good to use the <strong class="source-inline">Loading</strong> component on all outputs to give this confirmation to users. It's very easy to implement, and this is how we can update the app to reflect this functionality: </p>
			<p class="source-code">import dash_core_components as dcc</p>
			<p class="source-code"><strong class="bold">dcc.Loading([</strong></p>
			<p class="source-code">    dcc.Graph(id='clustered_map_chart')</p>
			<p class="source-code"><strong class="bold">])</strong></p>
			<p>The <strong class="source-inline">Graph</strong> component already exists in our app; we just need to add it as the <strong class="source-inline">children</strong> argument to the <strong class="source-inline">Loading</strong> component as you can see in the preceding code. This will cause the animated symbol to remain animated until the underlying object appears in its place.</p>
			<p>Let's now modify the callback function to make the desired change:</p>
			<p class="source-code">@app.callback(Output('clustered_map_chart', 'figure'),</p>
			<p class="source-code">              <strong class="bold">Input('clustering_submit_button', 'n_clicks')</strong>,</p>
			<p class="source-code">              <strong class="bold">State</strong>('year_cluster_slider', 'value'),</p>
			<p class="source-code">              <strong class="bold">State</strong>('ncluster_cluster_slider', 'value'),</p>
			<p class="source-code">              <strong class="bold">State</strong>('cluster_indicator_dropdown', 'value'))</p>
			<p class="source-code">def clustered_map(<strong class="bold">n_clicks</strong>, year, n_clusters, indicators):</p>
			<p>We basically made two changes. We first introduced <strong class="source-inline">clustering_submit_button</strong> as an <strong class="source-inline">Input</strong> element and renamed each of the other arguments from <strong class="source-inline">Input</strong> to <strong class="source-inline">State</strong>. The other change is passing <strong class="source-inline">n_clicks</strong> as the first argument to the function signature. Remember<a id="_idIndexMarker516"/> that the names of the arguments can be anything, and what <a id="_idIndexMarker517"/>matters is their order. We gave them clear names so we can easily refer to them and manage them in the body of the function.</p>
			<p>You have now modified the clustering functionality, giving the user more control and making it visually clearer with the <strong class="source-inline">Loading</strong> component. Feel free to add it wherever you want in the app.</p>
			<p>Now we can take our callbacks to another interesting level.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor147"/>Creating components that control other components</h1>
			<p>How about we provide <a id="_idIndexMarker518"/>an interactive component on the page where its values (set by the user) serve as inputs to another function, which is in turn responsible for the final output? <em class="italic">Figure 10.4</em> shows what the result looks like, and following that is a discussion of the details and implementation:</p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B16780_10_4.jpg" alt="Figure 10.4 – An app with a component that dynamically determines the values of another component"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – An app with a component that dynamically determines the values of another component</p>
			<p>Let's go through the visual elements of this app's layout, one by one: </p>
			<ol>
				<li value="1"><strong class="bold">Success message</strong>: The green strip at the top doesn't appear when the app loads. It only appears after the user adds the options to the dropdown and hits the <strong class="bold">Set options</strong> button. Note that <a id="_idIndexMarker519"/>there is a dynamic message showing the user the values that they added. Also, note that the alert message is "dismissable." We have the <strong class="bold">x</strong> symbol on the right, allowing the user to remove this message.</li>
				<li><strong class="bold">Instruction</strong> <strong class="bold">line</strong>: A simple message telling the user that they can add text in the <strong class="source-inline">Textarea</strong> component, which will be used to feed into the <strong class="source-inline">options</strong> property of the <strong class="source-inline">Dropdown</strong> component underneath it. At this point in the app, <strong class="source-inline">Dropdown</strong> is empty and has no options to choose from, and the <strong class="source-inline">Graph</strong> component also shows an empty chart.</li>
				<li><strong class="bold">The Set options button</strong>: Once the user adds a set of options to <strong class="source-inline">Textarea</strong> and hits this button, those lines will become options in <strong class="source-inline">Dropdown</strong>.</li>
				<li><strong class="bold">The</strong> <strong class="bold">resulting</strong> <strong class="bold">chart</strong>: We have used the three-letter country codes here. The user inputs whichever country codes they want, and these become options to the <strong class="source-inline">Dropdown</strong> component. After that, choosing a certain country code filters the dataset by getting rows where the country code is equal to the user's selection. It then uses the resulting DataFrame to create the chart at the end.</li>
			</ol>
			<p>There is not much practical <a id="_idIndexMarker520"/>value in such an app, as it would have been much easier to simply provide the options in a <strong class="source-inline">Dropdown</strong> component and produce the chart. We are simply doing this to demonstrate the new options that we can utilize and doing so with a dataset with which we are familiar. There is also a big potential for errors. What if the user doesn't know the code for a certain country? What if they make a typo? Again, this is just for demonstration purposes.</p>
			<p>This app can be written in around 30 lines of code and gives us two layers of options, where one depends on the other. One set of options "waits" and depends on the others to produce its outputs accordingly.</p>
			<p>We now code the layout of the app, and after that we create the two callback functions that make it interactive:</p>
			<ol>
				<li value="1">Run the necessary imports:<p class="source-code">from jupyter_dash import JupyterDash</p><p class="source-code">import dash_core_components as dcc</p><p class="source-code">import dash_html_components as html</p><p class="source-code">import dash_bootstrap_components as dbc</p><p class="source-code">import pandas as pd</p><p class="source-code">poverty = pd.read_csv('data/poverty.csv')</p></li>
				<li>Create an app and its layout. All the following elements go into the app's layout:<p class="source-code">app = JupyterDash(__name__,</p><p class="source-code">                  external_stylesheets=[dbc.themes.COSMO])</p><p class="source-code">app.layout = html.Div([</p><p class="source-code">    component_1,</p><p class="source-code">    component_2</p><p class="source-code">    …</p><p class="source-code">])</p></li>
				<li>Create an empty <a id="_idIndexMarker521"/>div that will contain the success message:<p class="source-code">html.Div(id='feedback')</p></li>
				<li>Create a <strong class="source-inline">Label</strong> component, telling the user how to interact with the app:<p class="source-code">dbc.Label("Create your own dropdown, add options one per line:")</p></li>
				<li>Create an empty <strong class="source-inline">Textarea</strong> component. Note that this is also available and similar to the component of the same name, belonging to Dash Core Components:<p class="source-code">dbc.Textarea(id='text', cols=40, rows=5)</p></li>
				<li>Add a button for generating the dropdown and its options:<p class="source-code">dbc.Button("Set options", id='button')</p></li>
				<li>Create an empty <strong class="source-inline">Dropdown</strong>:<p class="source-code">dcc.Dropdown(id='dropdown')</p></li>
				<li>Create an empty <strong class="source-inline">Graph</strong> component:<p class="source-code">dcc.Graph(id=chart')</p></li>
			</ol>
			<p>This should be enough for the visual elements of our app. We now need two functions to create the interactivity we want:</p>
			<ol>
				<li value="1"><strong class="source-inline">set_dropdown_options</strong>: This function will take the lines from <strong class="source-inline">Textarea</strong> as input and return a list of options to be fed to the <strong class="source-inline">Dropdown</strong> component.</li>
				<li><strong class="source-inline">create_population_chart</strong>: This function takes its input from the <strong class="source-inline">Dropdown</strong> component and generates a population chart below it.</li>
			</ol>
			<p>We now start with the first one:</p>
			<ol>
				<li value="1">Create the callback with the appropriate <strong class="source-inline">Output</strong>, <strong class="source-inline">Input</strong>, and <strong class="source-inline">State</strong> arguments. We have two outputs that this function affects. The first is the <strong class="source-inline">options</strong> property of the <strong class="source-inline">Dropdown</strong> component. The second is the div containing the success message. For our <strong class="source-inline">Input</strong>, we will have the button, and our <strong class="source-inline">State</strong> will be the <strong class="source-inline">Textarea</strong> component: <p class="source-code">@app.callback(Output('dropdown', 'options'),</p><p class="source-code">              Output('feedback', 'children'),</p><p class="source-code">              Input('button', 'n_clicks'),</p><p class="source-code">              State('text', 'value'))</p></li>
				<li>Create the <a id="_idIndexMarker522"/>function signature with appropriate argument names:<p class="source-code">def set_dropdown_options(n_clicks, options):</p></li>
				<li>Create a variable holding the text provided as a list. We achieve that by splitting the incoming text from <strong class="source-inline">Textarea</strong>. We also make sure to check for the case of not having any clicks and use <strong class="source-inline">raise PreventUpdate</strong> in that case:<p class="source-code">if not n_clicks:</p><p class="source-code">    raise PreventUpdate</p><p class="source-code">text = options.split()</p></li>
				<li>Create the success message as an <strong class="source-inline">Alert</strong> component, which is available from Dash Bootstrap Components. Note that we also color it with a "color" called "success." Naturally, you can also think of additional functionality that checks for valid inputs, and if it doesn't get one, the color of the message would be "warning" or "danger," for example. Note that the text also dynamically adds the comma-separated options that were provided by the user. We also set <strong class="source-inline">dismissable=True</strong> to allow users to remove it from the page if they want to:<p class="source-code">message = dbc.Alert(f"Success! you added the options: {', '.join(text)}",</p><p class="source-code">                    color='success',</p><p class="source-code">                    dismissable=True)</p></li>
				<li>Create the options list that<a id="_idIndexMarker523"/> will set the <strong class="source-inline">options</strong> property of the currently empty <strong class="source-inline">Dropdown</strong> component. We use the <strong class="source-inline">text</strong> variable for that:<p class="source-code">options = [{'label': t, 'value': t} for t in text]</p></li>
				<li>Return the tuple of <strong class="source-inline">options</strong> and <strong class="source-inline">message</strong>:<p class="source-code">return options, message</p></li>
			</ol>
			<p>Let's now turn to our other function, which will take the selected country code, and use it to generate the chart:</p>
			<ol>
				<li value="1">Create the callback with the required <strong class="source-inline">Output</strong> and <strong class="source-inline">Input</strong>:<p class="source-code">@app.callback(Output('chart', 'figure'),</p><p class="source-code">              Input('dropdown', 'value'))</p></li>
				<li>Create the function signature as well as the check for the availability of a value from the dropdown: <p class="source-code">def create_population_chart(country_code):</p><p class="source-code">    if not country_code:</p><p class="source-code">        raise PreventUpdate</p></li>
				<li>Create the required DataFrame subset based on the input value:<p class="source-code">df = poverty[poverty['Country Code']==country_code]</p></li>
				<li>Return a chart with the appropriate values:<p class="source-code">return px.line(df,</p><p class="source-code">               x='year',</p><p class="source-code">               y='Population, total',</p><p class="source-code">               title=f"Population of {country_code}")</p></li>
			</ol>
			<p>We can now run the preceding code and create the desired app.</p>
			<p>To better understand the structure <a id="_idIndexMarker524"/>of our app, and to get used to inspecting our callback chains, we can run the app in debug mode by running <strong class="source-inline">app.run_server(debug=True)</strong> and see how inputs and outputs relate to one another in <em class="italic">Figure 10.5</em>:</p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B16780_10_5.jpg" alt="Figure 10.5 – App callback graph"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – App callback graph</p>
			<p>You can easily see the<a id="_idIndexMarker525"/> names of the components and their IDs as specified in our code. You can easily trace the sequence of events, starting from the bottom left, following the arrows to the top right of the diagram.</p>
			<p>We saw how we can create dynamic options in certain components that depend on other components for their values. Dash neatly handled the behavior of components and properly triggered the right functions when their inputs were available.</p>
			<p>Let's take things to an even more abstract and powerful level. Let's now allow users to add full components by clicking a button.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Allowing users to add dynamic components to the app</h1>
			<p>Not only will <a id="_idIndexMarker526"/>users be able to add components to the app's layout, but the components' contents will also be dynamically generated. Take a look at <em class="italic">Figure 10.6</em> for the simplest example that we will start with:</p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B16780_10_6.jpg" alt="Figure 10.6 – An app allowing users to add components to the app's layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – An app allowing users to add components to the app's layout</p>
			<p>Although extremely simple, the charts in this app have different dynamic names, as you can see in the chart titles. This was based on the dynamic value of <strong class="source-inline">n_clicks</strong>, which changes on every click.</p>
			<p>The amount of code required to generate this is similar to any simple app; there isn't much complexity involved. We just need to look at it with fresh eyes. Let's start by coding the layout, which will consist of two simple components:</p>
			<ol>
				<li value="1">Create a button to trigger the addition of new charts: <p class="source-code">dbc.Button("Add Chart", id='button')</p></li>
				<li>Create an empty div, with its <strong class="source-inline">children</strong> attribute set to an empty list. The empty list is the key element that we will be working with: <p class="source-code">html.Div(id='output', <strong class="bold">children=[]</strong>)</p></li>
			</ol>
			<p>When this app loads<a id="_idIndexMarker527"/> for the first time, the user only sees a button that they can use to add a chart. The area below it gets populated with an additional chart every time they click the button.</p>
			<p>Let's now create the callback function for this app:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">Output</strong>, <strong class="source-inline">Input</strong>, and <strong class="source-inline">State</strong> arguments as usual. The interesting part to notice here is that the <strong class="source-inline">children</strong> property of the empty div acts both as <strong class="source-inline">Output</strong> and as <strong class="source-inline">State</strong>. We usually take some component's value and use it to influence or change another component in the app. Who said we can't take a component, make a change to it, and return it back to where it came from in its new state? This is exactly what we will do:<p class="source-code">@app.callback(<strong class="bold">Output('output', 'children')</strong>,</p><p class="source-code">              Input('button', 'n_clicks'),</p><p class="source-code">              <strong class="bold">State('output', 'children')</strong>)</p></li>
				<li>Create the function signature and check for <strong class="source-inline">n_clicks</strong>. Note here that <strong class="source-inline">children</strong> is acting as <strong class="source-inline">State</strong> in this case:<p class="source-code">def add_new_chart(n_clicks, <strong class="bold">children</strong>):</p><p class="source-code">    if not n_clicks:</p><p class="source-code">        raise PreventUpdate</p></li>
				<li>Create an empty bar chart with a dynamic title, using the <strong class="source-inline">n_clicks</strong> property:<p class="source-code">new_chart = dcc.Graph(figure=px.bar(title=f"Chart {<strong class="bold">n_clicks</strong>}"))</p></li>
				<li>Append the new chart to the <strong class="source-inline">children</strong> component. If you remember, we set the initial value of <strong class="source-inline">children</strong> in the empty div as an empty list. The following line will take this list and append <strong class="source-inline">new_chart</strong> to it. There is nothing special about this; we are simply using Python's <strong class="source-inline">list.append</strong> method:<p class="source-code">children.append(new_chart)</p></li>
				<li>Now that <a id="_idIndexMarker528"/>our <strong class="source-inline">children</strong> list has been mutated by appending a new item to it, we simply return it. Keep in mind that the return value of the callback function will go to the div, and so now it is acting as an output:<p class="source-code">return children</p></li>
			</ol>
			<p>Note that this functionality was created by the application of simple principles. We aren't using any new features here. The first technique was passing <strong class="source-inline">children</strong> to our callback, and receiving it from the other side. The second one was using the <strong class="source-inline">n_clicks</strong> property to dynamically set the titles of the charts.</p>
			<p>The diagram in <em class="italic">Figure 10.7</em> shows the relationship between the elements we created:</p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B16780_10_7.jpg" alt="Figure 10.7 – A callback function graph where a function returned a component that it received and mutated"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – A callback function graph where a function returned a component that it received and mutated</p>
			<p>This diagram will remain the same regardless of the number of charts that were added to the app. This means you don't have to worry about managing as many callback functions as there are clicks.</p>
			<p>If you are ready to take this even further, we can add another component under each chart, for example, a <strong class="source-inline">Dropdown</strong> component. And we can let the dropdown's selected value produce a chart. Each dropdown value will be independent of the others (if added by the user) and will only<a id="_idIndexMarker529"/> modify the chart it belongs to. The good news is that all this will also be managed with one additional callback function utilizing pattern-matching callbacks.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Introducing pattern-matching callbacks</h1>
			<p>Mastering this feature, and here we<a id="_idIndexMarker530"/> are dealing with a truly new feature, will allow you to take your apps to a new level of interactivity and power. The most important feature of this capability is that it allows us to handle the interactivity of components that didn't exist before. As we've done so far, when we allowed users to create new charts by clicking a button, those components did not exist before in the app. The more interesting thing is that the callback function that handles them all is as simple as any other callback that takes values from a dropdown and produces a chart. The trick is in slightly changing the <strong class="source-inline">id</strong> attribute of our components.</p>
			<p>So far, we have set the <strong class="source-inline">id</strong> attributes as strings, and the only requirement was that they be unique. We will now introduce a new way of creating this attribute, which is by using dictionaries. Let's first take a look at the end goal, then modify the layout, the callbacks, and finally, discuss the new way of handling the <strong class="source-inline">id</strong> property. <em class="italic">Figure 10.8</em> shows what our app will look like:</p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B16780_10_8.jpg" alt="Figure 10.8 – An app allowing users to add interactive components to the app's layout"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – An app allowing users to add interactive components to the app's layout</p>
			<p>In the previous app, we<a id="_idIndexMarker531"/> were able to let the user generate new components on the fly, and their content could be dynamic as well. We demonstrated this with chart titles, using the <strong class="source-inline">n_clicks</strong> property to set the title dynamically. But after adding those charts, the user couldn't interact with them. In other words, they are dynamically generated, with potentially dynamic content, but once generated, they are static, and we cannot interact with them.</p>
			<p>The improvement we are now introducing is that we are making those charts interactive (using the dropdowns) and having each of them linked to a single component, a dropdown in this case. As you can see in <em class="italic">Figure 10.8</em>, each chart comes with its own dropdown, and the user can independently generate multiple charts on top of one another and compare. After that, they can do even more, by selecting different countries on different charts. Of course, you can imagine a more involved set of apps where users can do many other things. </p>
			<p>The new additions to<a id="_idIndexMarker532"/> create this new functionality will be done in three steps:</p>
			<ol>
				<li value="1">Modify the <strong class="source-inline">add_new_chart</strong> function: This will simply consist of adding a dropdown under each chart and appending two components, instead of one. Note that the layout is exactly the same. We simply have a button and an empty div underneath it.</li>
				<li>Create a new callback function: This will link the newly generated pairs of charts and dropdowns to determine their behavior.</li>
				<li>Modify the <strong class="source-inline">id</strong> attributes in the app: This is where we introduce the new functionality and is the main feature that allows us to manage as many additional components and their interactivity using a single callback function.</li>
			</ol>
			<p>We first start by modifying the <strong class="source-inline">add_new_chart</strong> callback function:</p>
			<ol>
				<li value="1">We defined <strong class="source-inline">new_chart</strong> in the function, and this remains the same. Right under that, we want to add <strong class="source-inline">new_dropdown</strong> for users to select the country that they want to visualize:<p class="source-code">new_chart = dcc.Graph(figure=px.bar(title=f"Chart {n_clicks}"))</p><p class="source-code"><strong class="bold">countries = poverty[poverty['is_country']]['Country Name'].drop_duplicates().sort_values()</strong></p><p class="source-code"><strong class="bold">new_dropdown = dcc.Dropdown(options=[{'label': c, 'value': c}</strong></p><p class="source-code"><strong class="bold">                            for c in countries])</strong></p></li>
				<li>Append the new components. In the first example, we appended <strong class="source-inline">new_chart</strong>, but this time, we want to append the two items. The only thing to modify is to put the two new components in a new div and append the new div. This way, we are effectively appending one element (the div that contains two elements):<p class="source-code">children.append(html.Div([</p><p class="source-code">    <strong class="bold">new_chart,</strong></p><p class="source-code"><strong class="bold">    new_dropdown</strong></p><p class="source-code">]))</p></li>
			</ol>
			<p>This is enough to cause the button to<a id="_idIndexMarker533"/> append two items for each click. As you can see, the change was very simple. However, we will later come to set the <strong class="source-inline">id</strong> attributes for these components in order to make them dynamically interactive.</p>
			<p>Now we have pairs of components added with every click on our button. One of them has to be an <strong class="source-inline">Output</strong> element (<strong class="source-inline">Graph</strong>), and the other has to be an <strong class="source-inline">Input</strong> element (<strong class="source-inline">Dropdown</strong>). As with every other interactivity feature, they need to be linked with a callback function. We will create this now, and after that, we will take a look at how to link those dynamic IDs together and manage how the two callbacks interact with each other. The function is as simple as any callback that we have created so far. Here it is, but without the decorator, which we will discuss right after: </p>
			<p class="source-code">def create_population_chart(<strong class="bold">country</strong>):</p>
			<p class="source-code">    if not <strong class="bold">country</strong>:</p>
			<p class="source-code">        raise PreventUpdate</p>
			<p class="source-code">    df = poverty[poverty['Country Name']==<strong class="bold">country</strong>]</p>
			<p class="source-code">    fig = px.line(df, </p>
			<p class="source-code">                  x='year', y='Population, total',</p>
			<p class="source-code">                  title=f'Population of {<strong class="bold">country</strong>}')</p>
			<p class="source-code">    return fig</p>
			<p><em class="italic">Figure 10.9</em> contains a diagram showing our pattern-matching callback function:</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B16780_10_9.jpg" alt="Figure 10.9 – The callback graph of a pattern-matching callback"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – The callback graph of a pattern-matching callback</p>
			<p>The top graph in <em class="italic">Figure 10.9</em> is exactly the<a id="_idIndexMarker534"/> same as the one in <em class="italic">Figure 10.7</em>. It is for the simple function that adds new charts by appending them to the children of the empty div. Note that the <strong class="source-inline">id</strong> attributes are labeled above each box representing a component. Here they are <strong class="bold">button</strong> and <strong class="bold">output</strong>.</p>
			<p>The graph for the second callback, <strong class="source-inline">create_population_chart</strong>, shows a similar structure, but the IDs are dictionaries and not strings.</p>
			<p>Pattern-matching callbacks use those dictionaries to map the different elements together. Let's unpack those dictionaries and then see how they fit into the callbacks.</p>
			<p>The first one is <strong class="source-inline">{"index": MATCH, "type": "dropdown"}</strong>. I believe the <strong class="bold">type</strong> key is clear. We use it to make it easy to identify other components whose "type" is "dropdown." It's important to note that these names could be anything, but obviously we would want meaningful and helpful names. The other dictionary has <strong class="bold">chart</strong> for its <strong class="bold">type</strong> key. Again, this is also flexible, but I think it's clear here which elements we are referring to.</p>
			<p>Now we want to have independent functionality for each pair of components. In other words, we want the user to be able to modify the second dropdown, generating whatever chart they want, without that action affecting any other components in the app. How do we achieve that? We simply tell Dash to match them, with <strong class="source-inline">MATCH</strong>. This again belongs to an arbitrarily named key, <strong class="bold">index</strong> in this case. But <strong class="source-inline">MATCH</strong> is a wildcard object that is available in the <strong class="source-inline">dash.dependencies</strong> module. There are also <strong class="source-inline">ALL</strong> and <strong class="source-inline">ALLSMALLER</strong>, which work in a similar way with slight differences, but we will mainly focus on <strong class="source-inline">MATCH</strong>. Now let's take a look at how the updated functions need to be specified to cater to those IDs. The good news is that the only things we have to change are the <strong class="source-inline">id</strong> attributes of the relevant components and pass them to the relevant callback function arguments.</p>
			<p>We are now ready to add the<a id="_idIndexMarker535"/> proper <strong class="source-inline">id</strong> attributes to complete the pattern-matching callbacks. The first function, <strong class="source-inline">add_new_chart</strong>, takes the new dictionary <strong class="source-inline">id</strong> attributes for the inner components that we allow the user to add to the app. Note here that the "index" key takes <strong class="source-inline">n_clicks</strong> as its value. This value, as we saw several times, is dynamic and changes every time the user clicks the button. This means that every time the user clicks the button, we have a new unique ID with which we can identify this component:</p>
			<p class="source-code">def add_new_chart(n_clicks, children):</p>
			<p class="source-code">    new_chart = dcc.Graph(<strong class="bold">id={'type': 'chart',</strong></p>
			<p class="source-code">                              <strong class="bold">'index': n_clicks}</strong>,</p>
			<p class="source-code">                          figure=px.bar())</p>
			<p class="source-code">    new_dropdown = dcc.Dropdown(<strong class="bold">id={'type': 'dropdown',</strong></p>
			<p class="source-code">                                    <strong class="bold">'index': n_clicks}</strong>,</p>
			<p class="source-code">                                options=[option_1, option_2, …])</p>
			<p>Now we have to map those IDs properly in the second function that is responsible for managing their interactivity. The "<strong class="source-inline">type</strong>" key will be used to map "<strong class="source-inline">chart</strong>" to "<strong class="source-inline">chart</strong>" and "<strong class="source-inline">dropdown</strong>" to "<strong class="source-inline">dropdown</strong>". As for <strong class="source-inline">n_clicks</strong>, since it is dynamic, we match it with <strong class="source-inline">MATCH</strong>:</p>
			<p class="source-code">@app.callback(Output(<strong class="bold">{'type': 'chart', 'index': MATCH}</strong>, 'figure'),</p>
			<p class="source-code">              Input(<strong class="bold">{'type': 'dropdown', 'index': MATCH}</strong>, 'value'))</p>
			<p class="source-code">def create_population_chart(country):</p>
			<p class="source-code">    …</p>
			<p>Here you can find the full code for the<a id="_idIndexMarker536"/> two functions as a reference to get the full picture: </p>
			<p class="source-code">from dash.dependencies import Output, Input, State, MATCH</p>
			<p class="source-code">@app.callback(Output('output', 'children'),</p>
			<p class="source-code">              Input('button', 'n_clicks'),</p>
			<p class="source-code">              State('output', 'children'))</p>
			<p class="source-code">def add_new_chart(n_clicks, children):</p>
			<p class="source-code">    if not n_clicks:</p>
			<p class="source-code">        raise PreventUpdate</p>
			<p class="source-code">    new_chart = dcc.Graph(id={'type': 'chart',</p>
			<p class="source-code">                              'index': n_clicks},</p>
			<p class="source-code">                          figure=px.bar(title=f"Chart {n_clicks}"))</p>
			<p class="source-code">    countries = poverty[poverty['is_country']]['Country Name'].drop_duplicates().sort_values()</p>
			<p class="source-code">    new_dropdown = dcc.Dropdown(id={'type': 'dropdown',</p>
			<p class="source-code">                                    'index': n_clicks},</p>
			<p class="source-code">                                options=[{'label': c, 'value': c}</p>
			<p class="source-code">                                         for c in countries])</p>
			<p class="source-code">    children.append(html.Div([</p>
			<p class="source-code">        new_chart, new_dropdown</p>
			<p class="source-code">    ]))</p>
			<p class="source-code">    return children</p>
			<p class="source-code">@app.callback(Output({'type': 'chart', </p>
			<p class="source-code">                      'index': MATCH}, 'figure'),</p>
			<p class="source-code">              Input({'type': 'dropdown',</p>
			<p class="source-code">                     'index': MATCH}, 'value'))</p>
			<p class="source-code">def create_population_chart(country):</p>
			<p class="source-code">    if not country:</p>
			<p class="source-code">        raise PreventUpdate</p>
			<p class="source-code">    df = poverty[poverty['Country Name']==country]</p>
			<p class="source-code">    fig = px.line(df,</p>
			<p class="source-code">                  x='year',</p>
			<p class="source-code">                  y='Population, total',</p>
			<p class="source-code">                  title=f'Population of {country}')</p>
			<p class="source-code">    return fig</p>
			<p>You can easily <a id="_idIndexMarker537"/>imagine how flexible and extensible our apps can become with such functionality, not to mention the ease of managing callbacks. Yet they are not straightforward and might need some time to get used to, which I believe is worth it.</p>
			<p>We introduced many new concepts around callbacks, utilized some tricks, and introduced new functionality. So, let's review what was covered in the chapter.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Summary</h1>
			<p>We first introduced the optional <strong class="source-inline">State</strong> argument to callback function decorators. We saw how by combining it with <strong class="source-inline">Input</strong>, we can defer the execution of functions until the user decides to execute them. We also ran several examples that added buttons to invoke the execution. We then created a simple app where the user's inputs to a certain component were used to dynamically populate options of another component that was "waiting." Those new options were in turn used to create another component.</p>
			<p>Another interesting application of simple principles was allowing users to add new components having dynamic content.</p>
			<p>We finally introduced the most powerful and flexible feature, the pattern-matching callbacks. We created an app where users are able to add as many charts as they want. Furthermore, those charts acted independently from one another, and users were empowered to customize their own dashboard.</p>
			<p>That was a lot to cover, and we turn next to another feature that allows us to extend and expand our apps. We can only have so many components on a page until it becomes cluttered. In many cases, it makes sense to create separate pages/URLs for separate functionality, which is the topic of the next chapter.</p>
		</div>
	</body></html>