- en: Chapter 3. Numerical Computing with IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although IPython's powerful shell and extended console can be advantageously
    used by any Python programmer, this package was originally a tool designed *for
    scientists by scientists*. It was indeed meant to provide a convenient way of
    doing *interactive scientific computing* with Python.
  prefs: []
  type: TYPE_NORMAL
- en: IPython does not really provide scientific computing features *per se*, but
    rather offers an interactive interface to powerful external libraries, such as
    NumPy, SciPy, Pandas, Matplotlib, and the like. Together, these tools provide
    a framework for scientific computing, which can compete with widespread commercial
    tools in the scientific community such as Matlab or Mathematica.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy provides a multidimensional array object that supports optimized vector
    operations. SciPy offers a wide variety of scientific algorithms (signal processing,
    optimization, and so on) that are based on NumPy. Pandas proposes convenient data
    structures for tabular data coming from real-world data set. Matplotlib allows
    to plot graphical figures easily so as to visualize interactively any form of
    data, and to generate publication-quality figures. IPython provides the adequate
    interactive framework for using all these tools in a streamlined way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the interactive computing possibilities offered by NumPy and Pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand why multidimensional arrays are well adapted to high-performance
    computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how arrays can be used in practical applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find some references containing more advanced examples and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A primer to vector computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will introduce the notion of **vectorized computations**.
    It is an absolutely crucial notion since it is the easiest way to achieve high
    performance with a high-level language such as Python.
  prefs: []
  type: TYPE_NORMAL
- en: An example of computation with Python loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today's science and engineering are all about numbers. Most data processing
    and numerical simulations are nothing else but a succession of elementary operations
    on large amounts of numerical data, and computers are extremely good at it. However,
    data has to be structured in some rational way. The generic structure of numerical
    data is that of *vectors* and *matrices*, and more generally *multidimensional
    arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explain in more detail what a numerical array is, let's take a look
    at an example motivating the introduction of these objects. Let's suppose we have
    retrieved geographical data with the coordinates (latitude and longitude) of a
    large number of locations, and we need to find the location that is the closest
    to a given position of interest. For example, we may want to find the closest
    restaurant from the GPS position of a smartphone user.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the positions are stored in a Python list of tuples, we can write something
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we loop through all positions. The variable `i` keeps the index of the
    current position, whereas `(x, y)` contains the coordinates of this position.
    The position of interest is `position=(x0, y0)`. At the first iteration, the current
    position is recorded as the best so far, and at the next iterations, the closest
    position is updated only if the current position is closer than the closest one
    so far. At the end of the loop, the index of the closest location is `ibest`,
    the corresponding position is `positions[ibest]`, and the squared distance from
    the position of interest to the closest position is in `dbest`. To compute the
    distances, we use here the squared Euclidean distance formula, *D = (x - x0)²
    + (y - y0)²*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a standard and basic algorithm. Let''s evaluate its performance on
    a large dataset. We first generate a list of 10 million random positions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined a list named `positions` with pairs of coordinates, each number
    being a random number between zero and one. Now, let''s set some benchmark using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm took 16.4 seconds to process 10 million positions. Let's see
    if that is close to the theoretical maximum performance of a CPU. This code was
    executed on a 2 GHz single core processor. It can theoretically process four floating
    point operations per cycle, corresponding to eight billion operations per second.
    In our algorithm, each iteration involves five mathematical operations and a comparison,
    for a total of 50 million floating point operations (taking only the mathematical
    operations into account). The theoretical maximum performance should have been
    6.25 ms. This means that our algorithm performed about 2,600 times worse than
    the theoretical maximum performance!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a very naive estimation, and the theoretical maximum performance
    is always far from being reached, but a discrepancy factor of 2,600 seems particularly
    bad. Can we do better? We will find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What an array is
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, the same computation (computing the distance to a
    fixed point) was performed on a lot of numbers. NumPy provides a new type that
    is perfectly adapted to this situation: the **multidimensional array**. So, what
    is an array?'
  prefs: []
  type: TYPE_NORMAL
- en: An array is a block of data organized into several dimensions. A one-dimensional
    array is a vector, which is an ordered sequence of elements (typically numbers)
    that are indexed with a single integer. A two-dimensional array is a matrix, containing
    elements indexed by a pair of integers, that is, the row index and the column
    index. More generally, an *n*-dimensional array is a set of elements with the
    same data type that are indexed by a tuple of *n* integers.
  prefs: []
  type: TYPE_NORMAL
- en: '![What an array is](img/9932OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Schematic of a multidimensional NumPy array
  prefs: []
  type: TYPE_NORMAL
- en: 'All elements in an array must have the same type: it is called the **data type**
    (`dtype`). There are multiple possible types in NumPy: Booleans, signed/unsigned
    integers, single-precision/double-precision floating point numbers, complex numbers,
    strings, and so on. Custom data types can also be defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Elements in an array are stored internally in a contiguous block of memory.
    For example, the elements in a vector of size 10 possess 10 consecutive memory
    addresses. When the dimension of the array is two or more, there is more than
    a unique choice for the ordering of the elements. For a matrix, the elements can
    be stored in **row-major order** (also known a **C-order**)or **column-major order**
    (also known as **Fort** **an-order**),depending on which index among the horizontal
    or vertical indexes moves the fastest as one goes along all elements in the array.
    This notion generalizes in three or more dimensions. The default order in NumPy
    is the C-order, but that can be changed when creating an array, typically with
    the `order` keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![What an array is](img/9932OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Difference between row-major and column-major order in multidimensional arrays
  prefs: []
  type: TYPE_NORMAL
- en: This notion can be extended to any number of dimensions. The **stride** defines
    the number of steps in each dimension that are made as one goes through all elements.
    NumPy handles all these low-level details automatically and provides convenient
    ways of creating, manipulating, and computing on these arrays. Most of the time,
    we do not need to bother about these details and we can think about our variables
    as multidimensional arrays. However, knowing how things work internally allows
    us to fix certain bugs and to optimize some portions of the code that involve
    very large arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of arrays compared with native Python types is that it is possible
    to perform very efficient computations on arrays instead of relying on Python
    loops. The difference is that the loop is implemented internally in C by NumPy
    instead of Python, so that there is no longer the cost of interpretation within
    the loop. Indeed, Python being an interpreted, dynamically-typed language, each
    iteration involves various low-level operations performed by Python (type checking
    and so on). Those operations generally take negligible time, but they become noxious
    to performance when they are repeated millions of times.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, modern CPUs implement vectorized instructions (SSE, AVX, XOP, and
    so on) that use large registers (128 bits or 256 bits) and can contain several
    single-precision or double-precision floating points. If NumPy is compiled with
    the adequate options, array computations can benefit from these vectorized CPU
    instructions and can be more than two or four times faster.
  prefs: []
  type: TYPE_NORMAL
- en: These are the main reasons why vectorized computations with NumPy can potentially
    be much more efficient than Python loops. One refers to the **Single Instruction,
    Multiple** **Data** (**SIMD**) paradigm of computation, since the same computation
    is performed on multiple items in an array operation with NumPy. We will demonstrate
    this with the help of our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the example with arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rewrite our example using arrays. First, we need to import NumPy. In
    IPython, we can use the `%pylab` magic command (or start IPython with `ipython
    --pylab`), which loads NumPy and Matplotlib within the interactive namespace (available
    as `np` for `numpy` and `plt` for `matplotlib.pyplot`). It is the most convenient
    way of using NumPy in an IPython interactive session. The other possibility is
    to import NumPy with `import numpy` (or `import numpy as np` for the lazy ones)
    or `from numpy import *`. The former syntax is to be preferred in a script, while
    the latter can be used in an interactive session. Here, and in all the following
    chapters, we will always assume that the `pylab` mode has been activated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to generate some random data. NumPy provides an efficient way
    of doing this as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `positions` array is a two-dimensional array with 10 million rows and two
    columns containing independent uniform random numbers between zero and one. We
    note that we do not use a `for` loop for the array creation. Loops should be avoided
    every time it is possible to use a NumPy operation instead. Let''s look at some
    properties of this object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shape` attribute contains the array shape as a tuple of integers. Other
    important attributes of an array include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndim`: The number of dimensions, which is also `len(positions.shape)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: The total number of elements (the product of all values in `positions.shape`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemsize`: The size in bytes of each element (four for an `int32` data type,
    eight for `float64`, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will compute the squared distance of each position to our position
    of interest in two steps. We first enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `x` and `y` contain the *x* and *y* coordinates of all positions. Indeed,
    the variable `positions[:,0]` refers to the first column of `positions` (indexing
    is zero-based in Python). This is a special Python/NumPy syntax for indexing.
    The brackets `[]` allow to access elements from a Python-container object. Inside
    the brackets, the notation `:,0` refers to all pairs of indices with any first
    element (the colon `:`) and a second element equal to zero. Since, in NumPy, the
    first dimension always refers to the row and the second dimension to the column,
    we are precisely referring to the first column here. Similarly, `positions[:,1]`
    refers to the second column, with the *y* coordinates of all positions. The variables
    `x` and `y` are one-dimensional vectors. Let''s compute the `distances` variable
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we compute the vector of distances from the position of interest (0.5,
    0.5) to all positions. Indeed, the `x - .5` expression subtracts 0.5 from all
    elements in the first column of positions. The reason is that `x` is a one-dimensional
    vector with 10 million elements, and `0.5` is simply a floating point number.
    The convention in NumPy follows the mathematical convention in vector calculus,
    that is, the subtraction is performed on all elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, `(x - .5) ** 2` computes the square of all elements in the
    vector appearing inside the parentheses. Finally, the `+` operator performs the
    point-wise operations of two 10 milion-long vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that NumPy allows to perform vector operations with a really simple
    syntax. Computing with arrays is a very specific way of programming and requires
    some time to master. It is quite different to the standard sequential way of programming
    in most languages, but it is far more efficient in Python, as we can see in the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When computing the `distances` variable again with the `%timeit` magic function,
    we find that the computation is much faster than the pure Python version. Even
    if we add the computation of the smallest element, which is also easy with NumPy,
    we still find a total time that is *30 times faster than the pure Python version*,
    as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, the *raison d'être* of multidimensional arrays is to avoid Python
    loops as much as possible when performing numerical computations on large amounts
    of data. Vectorizing computations in an algorithm can sometimes be difficult,
    but it is always worth it in terms of performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and loading arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how we can create and load arrays either from scratch
    or from existing data. This is the first step when analyzing data with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways of creating an array. We will review them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: From scratch, element by element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we can create an array by manually specifying its coefficients. This
    is the most direct way of creating an array, but it is not used very often in
    practice. The NumPy function `array` takes a list of elements and returns a corresponding
    NumPy array, as shown in the following example (the `pylab` mode of IPython needs
    to be activated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a one-dimensional array (that is, a vector) with three 32-bit
    integers (the default type of integers on 32-bit systems). The data type of the
    created array is automatically inferred from the elements provided in `array`.
    We can force the data type with the `dtype` keyword argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To create to-dimensional arrays (matrices), we need to provide a nested list
    of lists, each inner list containing one row, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an *n*-dimensional array, we need to provide a nested list of lists
    of lists with *n* levels of recursion. For example, let''s create a multiplication
    table using two nested Python lists comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes the table size as a parameter, and creates the multiplication
    table as an array from a list of rows, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will see later more efficient ways of creating this multiplication table.
  prefs: []
  type: TYPE_NORMAL
- en: From scratch, using predefined templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating arrays by specifying the individual coefficients manually is rarely
    practical. One can use any of the several convenient functions defined in NumPy
    to create typical arrays with the desired shape. For example, to create a vector
    filled with 100 zeros, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a 2D matrix, we need to provide a tuple with the desired shape as
    an argument, hence the double parentheses in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The default data type is `float64`. Similarly, the `ones` function creates an
    array filled with the value `1`. The functions `identity`, `eye`, and `diag` allow
    to create diagonal matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also several convenient functions that create vectors with regularly
    spaced numbers, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a vector of numbers linearly spaced between `2` and `10` with
    a step of two. Note that the first number is *included* (the first `2`), but the
    last number in the sequence (`10`) is *excluded*. This is a general convention
    in Python that is actually more intuitive than what it looks like. Another related
    function is `linspace`, which is similar to `arange`, except that the *size* of
    the output vector, and not the step, is provided as a third argument. This time,
    the first and last elements of the sequence are included.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Function signatures**'
  prefs: []
  type: TYPE_NORMAL
- en: The function signatures, including the parameter order and the list of keyword
    arguments, can be obtained in IPython with `?` or `help()`. In addition, in the
    Qt console and in the notebook, typing `linspace(` will automatically open a tooltip
    with `linspace(` function's signature. The tooltip can then be expanded by pressing
    *Tab*.
  prefs: []
  type: TYPE_NORMAL
- en: From random values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NumPy provides various random sampling routines for generating arrays with
    independent random values following different probability distributions. For example,
    to create a 2 x 5 array with random floating numbers uniformly sampled between
    `0` and `1`, we can use the `rand` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice the absence of double parentheses when specifying the shape of the array
    in `rand` (NumPy oddity).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Number formatting in IPython**'
  prefs: []
  type: TYPE_NORMAL
- en: The way numbers are displayed in IPython can be specified with the `%precision`
    magic command. For example, to display exactly three decimals for floating point
    numbers, we can type `%precision 3` in IPython. Actually, any formatting string
    can be provided, as explained in the documentation %`precision?`.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions include `randn` (random values sampled from a Gaussian distribution),
    `randint` (random integers), `exponential` (exponential distribution), and so
    on. Related functions include `shuffle` and `permutation`, which randomly permute
    existing arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Loading arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main interest of the array structure is the possibility to load existing
    data from Python or from an external source. NumPy provides efficient and convenient
    ways of loading multidimensional arrays from text (Python strings or text/CSV
    files) or from binary buffers or files. In addition, the Pandas package is particularly
    useful when loading tabular data, that is, tables that contain heterogeneous data
    types instead of just numbers.
  prefs: []
  type: TYPE_NORMAL
- en: From a native Python object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is quite common to have data in some native Python object and to want to
    convert it into a NumPy array. The standard method is to use the `array` function.
    When we created arrays by directly specifying their values, we actually converted
    Python lists of numbers into arrays.
  prefs: []
  type: TYPE_NORMAL
- en: From a buffer or an external file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common way of creating an array is to load data from a memory buffer
    or from a file, with either binary or string elements. From a Python buffer object,
    which we know the exact data type of, we can obtain a NumPy array with the function
    `frombuffer`. Similarly, the `fromstring` function accepts either ASCII text with
    values separated by any delimiter or binary data in any data type, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions `fromfile`, `loadtxt`, and `genfromtxt` allow to load data from
    text files or binary files and convert them into NumPy arrays. The function `loadtxt`
    is a simplified version of `genfromtxt`, useful when the file format is straightforward.
    The `fromfile` function is highly efficient with binary data. For example, to
    import data contained in the text files of the Facebook dataset, we can enter
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, saving arrays in files is as easy as loading NumPy arrays. There are
    basically two functions, `save` and `savetxt`, which save an array into a binary
    and text file, respectively. Relatedly, the `loadz` and `savez` functions are
    also conveniently used to save *dictionaries* of variables of any type (including
    NumPy arrays). All these functions use platform-independent file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pandas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pandas is another, more recent Python package that provides convenient and efficient
    ways of loading and manipulating data sets from heterogeneous sources. It is particularly
    useful when dealing with tabular data sets, in opposition to purely numerical
    data (matrices or arrays of numbers). It can handle missing values and data alignment
    issues (for example, with time series). The loaded data sets can be used with
    NumPy for efficient numerical computations. In brief, Pandas provides high-level
    access to tabular data, whereas NumPy provides lower-level access to raw homogeneous
    multidimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The future of NumPy**'
  prefs: []
  type: TYPE_NORMAL
- en: Travis Oliphant, the creator of NumPy, is currently working on its successor,
    Blaze. This project will unify many of the features currently offered by NumPy,
    Pandas, SciPy, Numba, Theano, and so on within a single framework.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of how we can load a data set with Pandas. We will download
    and analyze a data set about a large number of cities around the world and their
    population. This data set has been created by **MaxMind** and is available for
    free from [http://www.maxmind.com](http://www.maxmind.com).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Online public data sets**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the open data movement, more and more data is becoming publicly available.
    Analyzing interesting data is a good way to gain experience with the tools described
    in this book, which are particularly well adapted for this task. However, it is
    not always obvious to find good data sets online. The following are some links
    containing pointers to high quality data sets, often maintained by government
    agencies, international organizations, universities, or research institutes, and
    so on:'
  prefs: []
  type: TYPE_NORMAL
- en: Research-quality data sets, maintained by Hilary Mason, are available at [https://bitly.com/bundles/hmason/1](https://bitly.com/bundles/hmason/1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public data, maintained by Google, is available at [http://www.google.com/publicdata/](http://www.google.com/publicdata/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data catalogs are available at [http://datacatalogs.org/dataset](http://datacatalogs.org/dataset).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We first download the ZIP file and uncompress it in a folder, as shown in the
    following commands (the ZIP file is about 40 MB large, so downloading it may take
    a while):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we can create an alias to the newly-created folder with the
    command `%bookmark citiesdata data`. Now, we are going to load the CSV file that
    has been extracted with Pandas. The `read_csv` function of Pandas can open any
    CSV file, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s explore the newly created `dat` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` object is a `DataFrame` object, a Pandas type consisting of a two-dimensional
    labeled data structure with columns of potentially different types (like an Excel
    spreadsheet). Like a NumPy array, the `shape` attribute returns the shape of the
    table. But unlike NumPy, the `DataFrame` object has a richer structure, and, in
    particular, the `keys` method returns the names of the different columns, as shown
    in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `data` has more than three million lines and seven columns
    including the country, city, population, and geographical coordinates of each
    city. The `head` and `tail` methods allow to take a quick look at the beginning
    and the end of the table respectively. Note that, when using Pandas from the IPython
    notebook, the displayed data can be formatted as an HTML table for more convenient
    reading, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the example table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Pandas](img/9932OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying a Pandas table in the IPython notebook
  prefs: []
  type: TYPE_NORMAL
- en: We can see that some cities have **NaN** (**Not a Number**) values as populations.
    The reason is that the population is not available for all cities in the data
    set, and Pandas handles those missing values transparently.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in the next sections what manipulations and computations we can
    actually perform with this data set to get useful information about it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once NumPy arrays are created or loaded, there are basically three things that
    we can do with them:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selection consists of accessing one or several elements within an array. It
    can be done with NumPy or Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pandas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s continue with our example data opened with Pandas. Each column of the
    `data` object of `DataFrame` can be accessed through its name. In IPython, tab
    completion proposes the different columns of the data. In the following example,
    we get the names of all cities (`AccentCity` is the full name of the city, with
    uppercase characters and accents):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This column is an instance of the `Series` class. We can access certain rows
    using indexing. In the following example, we get the name of the 30,001th city
    (remembering that indexing is zero-based):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, we can access an element using its index. But how can we obtain a city from
    its name? For example, we would like to obtain the population and GPS coordinates
    of New York. A possibility might be to loop through all cities and check their
    names, but it would be extremely slow because the Python loops on millions of
    elements are not optimized at all. Pandas and NumPy offer a much more elegant
    and efficient way called **Boolean** **indexing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps that typically occur on the same line of code. First, we
    create an array with Boolean values indicating, for each element, whether it satisfies
    a condition or not (here, whether the city name is `New York`). Then, we pass
    this array of Booleans as an index to our original array. The result is then a
    subpart of the full array with only the elements corresponding to `True`, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The same syntax works in NumPy and Pandas. Here, we find a dozen cities named
    `New York`, but only one happens to be in the New York state. To access a single
    element with Pandas, we can use the `.ix` attribute (`ix` for index) as shown
    in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s turn this series object into a pure NumPy array. We go from the
    Pandas world to NumPy (keeping in mind that Pandas is built on top of NumPy).
    We will mostly work with the population count of all cities as shown in the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `population` array is a one-dimensional vector with the populations of
    all cities (or `NaN` if the population is not available). The population of New
    York can be accessed in NumPy with basic indexing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s find out how many cities do have an actual population count. To do this,
    we will select all elements in the population array that have a value different
    from NaN. We can use the NumPy function `isnan` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that `~_` contains the negative values of `isnan(population)`. We find
    that there are roughly 48,000 cities, corresponding to 1.5 percent of all cities
    in this data set, which have an actual population count.
  prefs: []
  type: TYPE_NORMAL
- en: More indexing possibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More generally, indexing allows us to take any portion of an array. We saw in
    the previous section how to filter an array with a Boolean condition. We can also
    specify directly the list of indices we want to keep. For instance, if `x` is
    a one-dimensional NumPy array, `x[i:j:k]` represents a view on `x` with only those
    elements having indices between `i` (included) and `j` (excluded) with a step
    of `k`. If `i` is omitted, it is assumed to be zero. If `j` is omitted, it is
    assumed to be the length of the array in that dimension. Negative values mean
    we count from the end. Finally, the default value for `k` is one. This notation
    is also valid in multiple dimensions; for example, `M[i:j,k:l]` creates a submatrix
    view on a 2D array `M`. Also, we can use `x[::-1]` to get `x` in the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: These conventions, with `i` included and `j` excluded, are convenient when working
    with consecutive portions of an array. For example, the first and second halves
    of `x`, assuming a size `2n`, are simply `x[:n]` and `x[n:]`. In addition, the
    length of `x[i:j]` is simply `j - i`. In the end, there should not be `+1` or
    `-1` values hanging around in indices in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to consider with array views is that they point to the same
    location in memory. So a view on a large array does not imply memory allocation,
    and changing the values of elements in the view also changes the corresponding
    values in the original array, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `y` contains all elements in `x` with even indices (here, indices
    zero, two, and four). Changing the value of `y[0]` changes both `y[0]` and `x[0]`,
    since `y[0]` refers to the first element of `x`. If this behavior is unwanted,
    it is possible to force the creation of a new array with `y = x.copy()` or `y
    = array(x)`. In the latter case, it is also possible to change the data type of
    `x`, with the `dtype` keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, another way of selecting a portion of an array consists in passing
    an array with explicit integer values for indices. This is called **fancy indexing**.
    If `x` is a one-dimensional vector, and `indices` is another one-dimensional vector
    (or a list) with positive integers, then `x[indices]` returns a vector containing
    `x[indices[0]]`, `x[indices[1]]`, and so on. Therefore, the length of `x[indices]`
    is equal to the length of `indices` and not the length of `x`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that a given index can be repeated several times in the index array.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays can be manipulated and reshaped, which can sometimes be useful when performing
    vectorized computations. It is also possible to construct a new array from identical
    copies of an original array. The complete list of routines can be found in the
    NumPy reference guide at [http://docs.scipy.org/doc/numpy/reference/routines.html](http://docs.scipy.org/doc/numpy/reference/routines.html).
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the `reshape` method allows to change the shape of an array if the total
    number of elements is kept constant, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to use `-1` in at most one dimension in the argument of `reshape`
    to specify that its value must be automatically inferred; for example, `x.reshape((2,
    -1))` instead of `x.reshape((2, 3))`.
  prefs: []
  type: TYPE_NORMAL
- en: The number of dimensions can also be changed with `ravel` (to remove all multidimensional
    structures in an array and return a flattened vector), `squeeze` (to remove all
    single-dimensional entries from the shape of an array), and `expand_dims` (to
    insert a new axis in an array).
  prefs: []
  type: TYPE_NORMAL
- en: Repeating and concatenating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `til` and `repeat` functions allow to create copies of an array, either
    by concatenating identical copies of it along a specified axis, or by copying
    every coefficient any number of times, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first create an array with a vertical stack of two identical copies
    of `x`, and we create a new array with each element of `x` repeated three times.
    The second argument of repeat can also be a list `reps`, in which case the coefficient
    `x[i]` is repeated `reps[i]` times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a multiplication table using `reshape` and `tile`.
    The idea is to first define one row vector and one column vector with all integers
    between `1` and `n`, tile them, and multiply them, knowing that the multiplication
    occurs element-wise as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s time the execution of this function using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This function is about 27 times faster than the previous version `mul1`, which
    used nested Python loops.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can use `hstack`, `vstack`, `dstack`, or `concatenate` to join several
    arrays into a single array along the first, second, third, or any dimension, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `hsplit`, `vsplit`,`dsplit`, or `split` functions allow to split
    an array into several consecutive subarrays along any dimension, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The second argument of `split` is either an integer, `n`, in which case the
    array is split into *n* equal arrays, or a list with the indices where the array
    should be split (that is, the indices of the first element in each subarray except
    the first).
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous multiplication table example, we had to repeat identical copies
    of a row and a column so that we could multiply the two arrays with identical
    shapes `(n, n)`. Actually, the `repeat` step is unnecessary, as arrays with different
    shapes can still be compatible under specific conditions; this is called **broadcasting**.
    The general rule is that *two dimensions are compatible when they are equal, or
    when one of them is 1*. For example, two arrays, `M` and `N`, of the shape `(1,
    n)` and `(n, 1)` can be multiplied together, because in the first dimension, `M`
    array's shape is `1`, whereas `N` array's shape is `1` in the second dimension.
    The dimension equal to one is transparently and silently stretched to match the
    other dimension, and this operation does not involve memory copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can get rid of the `tile` operation in the multiplication table
    example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `mul3` is about 2.6 times faster than `mul2`, and about 70 times faster
    than `mul1`! The reason is that `tile` involves array copying and memory allocation,
    whereas only multiplications happen in `mul3`.
  prefs: []
  type: TYPE_NORMAL
- en: Permuting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several functions allow to permute the axes in an array. For example, the `transpose`
    function permutes the dimensions of an array. The indices describing the permutation
    can be provided in the `axes` keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: Other transposition functions that may be useful include `fliplr` and `flipud`
    to flip an array in the left/right or up/down direction, `roll` to perform a circular
    permutation of the elements along a given axis, and `rot90` to rotate an array
    by 90 degrees in he counter-clockwise direction.
  prefs: []
  type: TYPE_NORMAL
- en: Computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The whole point of creating and manipulating arrays is to perform efficient
    vectorized computations with them. The four elementary operations work between
    arrays under the condition that they have compatible shapes. In addition, a lot
    of mathematical functions are available in the vectorized form for NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: If `A` and `B` are two NumPy arrays with compatible shapes, `A + B`, `A - B`,
    `A x B`, and `A / B` are element-wise operations. In particular, when `A` and
    `B` are two-dimensional matrices, `A x B` is *not* the matrix product. The matrix
    product is rather provided by the `dot` function, which more generally computes
    the dot product of two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Common unary operations include `-A`, `A ** x` (coefficients to power `x`),
    `abs(A)` (absolute value), `sign(A)` (an array with `-1`, `0`, or `1` depending
    on the sign of each element), `floor(A)` (floor of each element), `sqrt(A)` (square
    root), `log(A)` (natural logarithm), `exp(A)` (exponential), and a lot of other
    mathematical functions (trigonometric, hyperbolic, arithmetic functions, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: NumPy also provides functions to compute the sum (`sum`) or product (`prod`)
    of all elements in an array or in a given dimension. The `axis` keyword argument
    specifies the dimensions on which the sum is to be performed. This function returns
    an array with one dimension less than the original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max` and `min` functions return the largest and lowest values in an array
    or in a given dimension. The `argmin` and `argmax` functions return the index
    of the smallest or largest element of the array. For example, continuing with
    our `cities` example we can have the following commands for the `locate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `locate` function takes two coordinates with a position's latitude and longitude,
    and returns the closest city's name. The `argmin` function returns the index of
    the city with the smallest distance to the specified position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, statistical functions such as `mean`, `median`, `std`, and `var` compute
    the mean, median, standard deviation, and variance of the elements along a given
    dimension or across the whole array. Also, the `describe` method of Pandas objects
    gives several useful statistics (including the mean, standard deviation, the 50
    percent quantile or median, and the 25 precent and 75 percent quantiles) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Related functions that can be useful when simulating mathematical models include
    `diff` (discrete difference), `cumsum` (cumulative sum), and `cumprod` (cumulative
    product). The `diff` function allows to compute a discrete *derivative* of a signal
    (up to a scalar coefficient), whereas `cumsum` computes a discrete *indefinite
    integral* of a signal.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced mathematical processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy provides all necessary types and routines for doing efficient numerical
    computations with Python. SciPy is built on top of NumPy and implements a large
    variety of higher-level mathematical processing algorithms. These algorithms span
    several areas of numerical computing, such as optimization, linear algebra, signal
    processing, statistics, and the like. Also, the various **SciKits** packages (`scikit-learn`,
    `scikit-image`, and so on) are yet more advanced packages implementing highly
    specialized algorithms in specific domains (machine learning, image processing,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'We give here a short overview of the scientific computing features provided
    by SciPy and a few other packages. The full list of features can be found on the
    official reference guide: [http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/).
    Giving practical examples and applications is beyond the scope of this book, and
    the interested reader can find a wide variety of examples in the *NumPy Cookbook*,
    *Ivan Idris*, *Packt Publishing*, and *Learning SciPy for Numerical and Scientific
    Computing*, *Francisco Blanco-Silva*, *Packt Publishing*, both by Packt Publishing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear algebra** routines are provided by the `scipy.linalg` subpackage:
    solvers of linear equations, matrix routines, eigenvalue problems, matrix decomposition,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimization routines** are provided by the `scipy.optimize` subpackage:
    unconstrained or constrained minimization of real-valued functions, global optimization,
    curve fitting, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical integrators** are provided by the `scipy.integrate` subpackage.
    It can be used to solve differential equations, for example, in physics simulation
    engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal processing** algorithms are implemented in the `scipy.signal` subpackage:
    convolutions, linear filters, wavelets, and so on. The `scipy.fftpack` subpackage,
    which implements Fourier transforms routines, and the `scipy.ndimage` subpackage,
    which implements several image processing algorithms. Finally, other image processing
    packages of interest include `scikit-image`, `PIL`, and `OpenCV` (computer vision).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statistical routines** are provided by the `scipy.stats` subpackage: probability
    distributions, descriptive statistics and statistical tests, and so on. `SciPy.cluster`
    implements clustering algorithms that can be useful to find categories in unstructured
    data. Other statistical packages of interest include `Pandas` and `scikit-learn`
    (machine learning).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the multidimensional array object offered by NumPy,
    and we showed how it can be used for efficient computations on numerical data
    sets. In particular, it is well adapted for loading any sort of data, and the
    Pandas package makes this task straightforward, even with complex data files.
    Using advanced algorithms is possible with IPython with the help of powerful external
    packages, such as NumPy, SciPy, and the SciKit libraries. However, this subject
    is beyond the scope of this book, and the interested reader can find a variety
    of examples in the *NumPy Cookbook, Ivan Idris, Packt Publishing* and *Learning
    SciPy for Numerical and Scientific Computing, Francisco Blanco-Silva, Packt Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will present the visualization-related possibilities
    offered by IPython and Matplotlib, which are very often used in conjunction with
    NumPy for interactive visualization of data.
  prefs: []
  type: TYPE_NORMAL
