- en: Chapter 3. Numerical Computing with IPython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用 IPython 进行数值计算
- en: Although IPython's powerful shell and extended console can be advantageously
    used by any Python programmer, this package was originally a tool designed *for
    scientists by scientists*. It was indeed meant to provide a convenient way of
    doing *interactive scientific computing* with Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 IPython 强大的 shell 和扩展控制台可以被任何 Python 程序员充分利用，但这个软件包最初是为 *科学家设计的工具*。它的确旨在为科学计算提供一种方便的方式，进行
    *互动式科学计算*。
- en: IPython does not really provide scientific computing features *per se*, but
    rather offers an interactive interface to powerful external libraries, such as
    NumPy, SciPy, Pandas, Matplotlib, and the like. Together, these tools provide
    a framework for scientific computing, which can compete with widespread commercial
    tools in the scientific community such as Matlab or Mathematica.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 本身并不提供科学计算功能 *本身*，而是提供了一个与强大外部库（如 NumPy、SciPy、Pandas、Matplotlib 等）互动的接口。这些工具共同提供了一个科学计算框架，能够与科学界广泛使用的商业工具如
    Matlab 或 Mathematica 竞争。
- en: NumPy provides a multidimensional array object that supports optimized vector
    operations. SciPy offers a wide variety of scientific algorithms (signal processing,
    optimization, and so on) that are based on NumPy. Pandas proposes convenient data
    structures for tabular data coming from real-world data set. Matplotlib allows
    to plot graphical figures easily so as to visualize interactively any form of
    data, and to generate publication-quality figures. IPython provides the adequate
    interactive framework for using all these tools in a streamlined way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了一个支持优化向量操作的多维数组对象。SciPy 提供了多种科学算法（如信号处理、优化等），这些算法基于 NumPy。Pandas 提供了便于处理来自现实数据集的表格数据的结构。Matplotlib
    允许轻松绘制图形，从而交互式地可视化各种数据，并生成出版质量的图表。IPython 提供了一个合适的交互框架，使得使用这些工具更加高效。
- en: 'In this section, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将：
- en: Explore the interactive computing possibilities offered by NumPy and Pandas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 NumPy 和 Pandas 提供的互动计算可能性
- en: Understand why multidimensional arrays are well adapted to high-performance
    computations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么多维数组适合进行高性能计算
- en: See how arrays can be used in practical applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数组如何在实际应用中使用
- en: Find some references containing more advanced examples and applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找一些包含更高级示例和应用的参考资料
- en: A primer to vector computing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量计算简介
- en: In this section we will introduce the notion of **vectorized computations**.
    It is an absolutely crucial notion since it is the easiest way to achieve high
    performance with a high-level language such as Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍**向量化计算**的概念。这是一个至关重要的概念，因为它是使用像 Python 这样的高级语言实现高性能的最简便方法。
- en: An example of computation with Python loops
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个使用 Python 循环进行计算的示例
- en: Today's science and engineering are all about numbers. Most data processing
    and numerical simulations are nothing else but a succession of elementary operations
    on large amounts of numerical data, and computers are extremely good at it. However,
    data has to be structured in some rational way. The generic structure of numerical
    data is that of *vectors* and *matrices*, and more generally *multidimensional
    arrays*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的科学和工程都围绕数字展开。大多数数据处理和数值模拟不过是对大量数值数据进行一系列基本操作，计算机在这方面非常擅长。然而，数据必须以某种合理的方式进行结构化。数值数据的一般结构是
    *向量* 和 *矩阵*，更一般地说是 *多维数组*。
- en: Before we explain in more detail what a numerical array is, let's take a look
    at an example motivating the introduction of these objects. Let's suppose we have
    retrieved geographical data with the coordinates (latitude and longitude) of a
    large number of locations, and we need to find the location that is the closest
    to a given position of interest. For example, we may want to find the closest
    restaurant from the GPS position of a smartphone user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地解释什么是数值数组之前，让我们先看一个激励引入这些对象的示例。假设我们已经获取了大量位置的地理数据，包括它们的坐标（纬度和经度），并且我们需要找出最靠近给定兴趣点的位置。例如，我们可能想找出离智能手机用户
    GPS 位置最近的餐馆。
- en: 'If the positions are stored in a Python list of tuples, we can write something
    like the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些位置存储在 Python 的元组列表中，我们可以写出如下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we loop through all positions. The variable `i` keeps the index of the
    current position, whereas `(x, y)` contains the coordinates of this position.
    The position of interest is `position=(x0, y0)`. At the first iteration, the current
    position is recorded as the best so far, and at the next iterations, the closest
    position is updated only if the current position is closer than the closest one
    so far. At the end of the loop, the index of the closest location is `ibest`,
    the corresponding position is `positions[ibest]`, and the squared distance from
    the position of interest to the closest position is in `dbest`. To compute the
    distances, we use here the squared Euclidean distance formula, *D = (x - x0)²
    + (y - y0)²*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有位置。变量`i`保持当前位置信息的索引，而`(x, y)`则包含该位置的坐标。我们关注的位置是`position=(x0, y0)`。在第一次迭代中，当前的位置被记录为最优位置，在接下来的迭代中，只有当前的位置比最优位置更接近时，才会更新最优位置。循环结束时，最接近位置的索引是`ibest`，对应的位置是`positions[ibest]`，而从目标位置到最接近位置的平方距离存储在`dbest`中。为了计算距离，我们使用的是平方欧几里得距离公式，*D
    = (x - x0)² + (y - y0)²*。
- en: 'This is a standard and basic algorithm. Let''s evaluate its performance on
    a large dataset. We first generate a list of 10 million random positions as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准且基础的算法。让我们在一个大型数据集上评估它的性能。我们首先生成一个包含1000万个随机位置的列表，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We defined a list named `positions` with pairs of coordinates, each number
    being a random number between zero and one. Now, let''s set some benchmark using
    the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`positions`的列表，其中包含坐标对，每个数字都是0和1之间的随机数。现在，使用以下命令设置一些基准：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This algorithm took 16.4 seconds to process 10 million positions. Let's see
    if that is close to the theoretical maximum performance of a CPU. This code was
    executed on a 2 GHz single core processor. It can theoretically process four floating
    point operations per cycle, corresponding to eight billion operations per second.
    In our algorithm, each iteration involves five mathematical operations and a comparison,
    for a total of 50 million floating point operations (taking only the mathematical
    operations into account). The theoretical maximum performance should have been
    6.25 ms. This means that our algorithm performed about 2,600 times worse than
    the theoretical maximum performance!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法处理1000万个位置用了16.4秒。我们来看看这是否接近CPU的理论最大性能。该代码是在一颗2 GHz单核处理器上执行的。理论上，它每个周期可以处理四个浮点操作，相当于每秒80亿次操作。在我们的算法中，每次迭代涉及五个数学操作和一次比较，总共50百万次浮点操作（仅计算数学操作）。理论最大性能应该是6.25毫秒。这意味着我们的算法表现比理论最大性能差了大约2600倍！
- en: Of course, this is a very naive estimation, and the theoretical maximum performance
    is always far from being reached, but a discrepancy factor of 2,600 seems particularly
    bad. Can we do better? We will find out in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个非常粗略的估算，理论上的最大性能通常是远未达到的，但2600倍的差异显得特别严重。我们能做得更好吗？我们将在下一节中找出答案。
- en: What an array is
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是什么
- en: 'In the previous example, the same computation (computing the distance to a
    fixed point) was performed on a lot of numbers. NumPy provides a new type that
    is perfectly adapted to this situation: the **multidimensional array**. So, what
    is an array?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，同样的计算（计算与一个固定点的距离）在大量数字上进行。NumPy提供了一种新的类型，完美适应这种情况：**多维数组**。那么，数组是什么？
- en: An array is a block of data organized into several dimensions. A one-dimensional
    array is a vector, which is an ordered sequence of elements (typically numbers)
    that are indexed with a single integer. A two-dimensional array is a matrix, containing
    elements indexed by a pair of integers, that is, the row index and the column
    index. More generally, an *n*-dimensional array is a set of elements with the
    same data type that are indexed by a tuple of *n* integers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个组织成多个维度的数据块。一维数组是一个向量，它是一个元素（通常是数字）有序的序列，使用一个整数进行索引。二维数组是一个矩阵，包含通过一对整数索引的元素，即行索引和列索引。更一般地说，*n*维数组是一个由相同数据类型的元素组成的集合，通过一个*n*个整数的元组进行索引。
- en: '![What an array is](img/9932OS_03_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![数组是什么](img/9932OS_03_01.jpg)'
- en: Schematic of a multidimensional NumPy array
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多维NumPy数组的示意图
- en: 'All elements in an array must have the same type: it is called the **data type**
    (`dtype`). There are multiple possible types in NumPy: Booleans, signed/unsigned
    integers, single-precision/double-precision floating point numbers, complex numbers,
    strings, and so on. Custom data types can also be defined.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Elements in an array are stored internally in a contiguous block of memory.
    For example, the elements in a vector of size 10 possess 10 consecutive memory
    addresses. When the dimension of the array is two or more, there is more than
    a unique choice for the ordering of the elements. For a matrix, the elements can
    be stored in **row-major order** (also known a **C-order**)or **column-major order**
    (also known as **Fort** **an-order**),depending on which index among the horizontal
    or vertical indexes moves the fastest as one goes along all elements in the array.
    This notion generalizes in three or more dimensions. The default order in NumPy
    is the C-order, but that can be changed when creating an array, typically with
    the `order` keyword argument.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![What an array is](img/9932OS_03_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Difference between row-major and column-major order in multidimensional arrays
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: This notion can be extended to any number of dimensions. The **stride** defines
    the number of steps in each dimension that are made as one goes through all elements.
    NumPy handles all these low-level details automatically and provides convenient
    ways of creating, manipulating, and computing on these arrays. Most of the time,
    we do not need to bother about these details and we can think about our variables
    as multidimensional arrays. However, knowing how things work internally allows
    us to fix certain bugs and to optimize some portions of the code that involve
    very large arrays.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of arrays compared with native Python types is that it is possible
    to perform very efficient computations on arrays instead of relying on Python
    loops. The difference is that the loop is implemented internally in C by NumPy
    instead of Python, so that there is no longer the cost of interpretation within
    the loop. Indeed, Python being an interpreted, dynamically-typed language, each
    iteration involves various low-level operations performed by Python (type checking
    and so on). Those operations generally take negligible time, but they become noxious
    to performance when they are repeated millions of times.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In addition, modern CPUs implement vectorized instructions (SSE, AVX, XOP, and
    so on) that use large registers (128 bits or 256 bits) and can contain several
    single-precision or double-precision floating points. If NumPy is compiled with
    the adequate options, array computations can benefit from these vectorized CPU
    instructions and can be more than two or four times faster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: These are the main reasons why vectorized computations with NumPy can potentially
    be much more efficient than Python loops. One refers to the **Single Instruction,
    Multiple** **Data** (**SIMD**) paradigm of computation, since the same computation
    is performed on multiple items in an array operation with NumPy. We will demonstrate
    this with the help of our previous example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing the example with arrays
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s rewrite our example using arrays. First, we need to import NumPy. In
    IPython, we can use the `%pylab` magic command (or start IPython with `ipython
    --pylab`), which loads NumPy and Matplotlib within the interactive namespace (available
    as `np` for `numpy` and `plt` for `matplotlib.pyplot`). It is the most convenient
    way of using NumPy in an IPython interactive session. The other possibility is
    to import NumPy with `import numpy` (or `import numpy as np` for the lazy ones)
    or `from numpy import *`. The former syntax is to be preferred in a script, while
    the latter can be used in an interactive session. Here, and in all the following
    chapters, we will always assume that the `pylab` mode has been activated as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we need to generate some random data. NumPy provides an efficient way
    of doing this as shown in the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `positions` array is a two-dimensional array with 10 million rows and two
    columns containing independent uniform random numbers between zero and one. We
    note that we do not use a `for` loop for the array creation. Loops should be avoided
    every time it is possible to use a NumPy operation instead. Let''s look at some
    properties of this object as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `shape` attribute contains the array shape as a tuple of integers. Other
    important attributes of an array include:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '`ndim`: The number of dimensions, which is also `len(positions.shape)`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: The total number of elements (the product of all values in `positions.shape`)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemsize`: The size in bytes of each element (four for an `int32` data type,
    eight for `float64`, and so on)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will compute the squared distance of each position to our position
    of interest in two steps. We first enter the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, `x` and `y` contain the *x* and *y* coordinates of all positions. Indeed,
    the variable `positions[:,0]` refers to the first column of `positions` (indexing
    is zero-based in Python). This is a special Python/NumPy syntax for indexing.
    The brackets `[]` allow to access elements from a Python-container object. Inside
    the brackets, the notation `:,0` refers to all pairs of indices with any first
    element (the colon `:`) and a second element equal to zero. Since, in NumPy, the
    first dimension always refers to the row and the second dimension to the column,
    we are precisely referring to the first column here. Similarly, `positions[:,1]`
    refers to the second column, with the *y* coordinates of all positions. The variables
    `x` and `y` are one-dimensional vectors. Let''s compute the `distances` variable
    with the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we compute the vector of distances from the position of interest (0.5,
    0.5) to all positions. Indeed, the `x - .5` expression subtracts 0.5 from all
    elements in the first column of positions. The reason is that `x` is a one-dimensional
    vector with 10 million elements, and `0.5` is simply a floating point number.
    The convention in NumPy follows the mathematical convention in vector calculus,
    that is, the subtraction is performed on all elements in the array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, `(x - .5) ** 2` computes the square of all elements in the
    vector appearing inside the parentheses. Finally, the `+` operator performs the
    point-wise operations of two 10 milion-long vectors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that NumPy allows to perform vector operations with a really simple
    syntax. Computing with arrays is a very specific way of programming and requires
    some time to master. It is quite different to the standard sequential way of programming
    in most languages, but it is far more efficient in Python, as we can see in the
    following commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When computing the `distances` variable again with the `%timeit` magic function,
    we find that the computation is much faster than the pure Python version. Even
    if we add the computation of the smallest element, which is also easy with NumPy,
    we still find a total time that is *30 times faster than the pure Python version*,
    as shown in the following commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In conclusion, the *raison d'être* of multidimensional arrays is to avoid Python
    loops as much as possible when performing numerical computations on large amounts
    of data. Vectorizing computations in an algorithm can sometimes be difficult,
    but it is always worth it in terms of performance improvement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Creating and loading arrays
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how we can create and load arrays either from scratch
    or from existing data. This is the first step when analyzing data with Python.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways of creating an array. We will review them in this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: From scratch, element by element
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we can create an array by manually specifying its coefficients. This
    is the most direct way of creating an array, but it is not used very often in
    practice. The NumPy function `array` takes a list of elements and returns a corresponding
    NumPy array, as shown in the following example (the `pylab` mode of IPython needs
    to be activated):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we create a one-dimensional array (that is, a vector) with three 32-bit
    integers (the default type of integers on 32-bit systems). The data type of the
    created array is automatically inferred from the elements provided in `array`.
    We can force the data type with the `dtype` keyword argument as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create to-dimensional arrays (matrices), we need to provide a nested list
    of lists, each inner list containing one row, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To create an *n*-dimensional array, we need to provide a nested list of lists
    of lists with *n* levels of recursion. For example, let''s create a multiplication
    table using two nested Python lists comprehensions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 *n* 维数组，我们需要提供一个具有 *n* 层递归的嵌套列表。举例来说，我们可以使用两个嵌套的 Python 列表推导式来创建一个乘法表：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function takes the table size as a parameter, and creates the multiplication
    table as an array from a list of rows, as shown in the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将表格大小作为参数，并从行列表中创建乘法表数组，如以下示例所示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will see later more efficient ways of creating this multiplication table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将看到更高效的创建此乘法表的方法。
- en: From scratch, using predefined templates
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始，使用预定义模板
- en: 'Creating arrays by specifying the individual coefficients manually is rarely
    practical. One can use any of the several convenient functions defined in NumPy
    to create typical arrays with the desired shape. For example, to create a vector
    filled with 100 zeros, we can use the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 手动指定每个系数来创建数组通常不太实用。可以使用 NumPy 中定义的多种便捷函数来创建具有所需形状的典型数组。例如，要创建一个填充 100 个零的向量，可以使用以下命令：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a 2D matrix, we need to provide a tuple with the desired shape as
    an argument, hence the double parentheses in the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 2D 矩阵，我们需要提供一个包含所需形状的元组作为参数，因此以下命令中使用了双括号：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The default data type is `float64`. Similarly, the `ones` function creates an
    array filled with the value `1`. The functions `identity`, `eye`, and `diag` allow
    to create diagonal matrices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的数据类型是 `float64`。类似地，`ones` 函数创建一个填充了 `1` 的数组。函数 `identity`、`eye` 和 `diag`
    用于创建对角矩阵。
- en: 'There are also several convenient functions that create vectors with regularly
    spaced numbers, as shown in the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些便捷的函数可以创建具有规律间隔数字的向量，如以下示例所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we create a vector of numbers linearly spaced between `2` and `10` with
    a step of two. Note that the first number is *included* (the first `2`), but the
    last number in the sequence (`10`) is *excluded*. This is a general convention
    in Python that is actually more intuitive than what it looks like. Another related
    function is `linspace`, which is similar to `arange`, except that the *size* of
    the output vector, and not the step, is provided as a third argument. This time,
    the first and last elements of the sequence are included.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个从 `2` 到 `10` 之间按步长为 2 线性间隔的数字向量。请注意，第一个数字是 *包括* 在内的（第一个 `2`），但序列中的最后一个数字（`10`）是
    *排除* 在外的。这是 Python 中的一个通用约定，实际上比它看起来的更直观。另一个相关的函数是 `linspace`，它与 `arange` 类似，只不过输出向量的
    *大小*，而不是步长，是作为第三个参数提供的。这一次，序列的第一个和最后一个元素都会被包括在内。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Function signatures**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数签名**'
- en: The function signatures, including the parameter order and the list of keyword
    arguments, can be obtained in IPython with `?` or `help()`. In addition, in the
    Qt console and in the notebook, typing `linspace(` will automatically open a tooltip
    with `linspace(` function's signature. The tooltip can then be expanded by pressing
    *Tab*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 中，可以通过 `?` 或 `help()` 获取函数签名，包括参数顺序和关键字参数列表。此外，在 Qt 控制台和笔记本中，输入 `linspace(`
    会自动弹出 `linspace(` 函数的签名提示框。然后，可以通过按 *Tab* 键展开该提示框。
- en: From random values
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从随机值生成
- en: 'NumPy provides various random sampling routines for generating arrays with
    independent random values following different probability distributions. For example,
    to create a 2 x 5 array with random floating numbers uniformly sampled between
    `0` and `1`, we can use the `rand` function as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了多种随机采样方法，用于生成具有不同概率分布的独立随机值数组。例如，要创建一个 2 x 5 的数组，里面的随机浮点数均匀分布在 `0`
    和 `1` 之间，可以使用 `rand` 函数，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the absence of double parentheses when specifying the shape of the array
    in `rand` (NumPy oddity).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `rand` 中指定数组形状时没有使用双括号（NumPy 的一个特性）。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Number formatting in IPython**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPython 中的数字格式化**'
- en: The way numbers are displayed in IPython can be specified with the `%precision`
    magic command. For example, to display exactly three decimals for floating point
    numbers, we can type `%precision 3` in IPython. Actually, any formatting string
    can be provided, as explained in the documentation %`precision?`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `%precision` 魔法命令指定在 IPython 中显示数字的方式。例如，要将浮点数显示为精确到三位小数，可以在 IPython 中输入
    `%precision 3`。实际上，可以提供任何格式化字符串，具体请参见文档 %`precision?`。
- en: Other functions include `randn` (random values sampled from a Gaussian distribution),
    `randint` (random integers), `exponential` (exponential distribution), and so
    on. Related functions include `shuffle` and `permutation`, which randomly permute
    existing arrays.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数包括`randn`（从高斯分布中采样的随机值）、`randint`（随机整数）、`exponential`（指数分布）等。相关函数包括`shuffle`和`permutation`，它们随机排列现有的数组。
- en: Loading arrays
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数组
- en: The main interest of the array structure is the possibility to load existing
    data from Python or from an external source. NumPy provides efficient and convenient
    ways of loading multidimensional arrays from text (Python strings or text/CSV
    files) or from binary buffers or files. In addition, the Pandas package is particularly
    useful when loading tabular data, that is, tables that contain heterogeneous data
    types instead of just numbers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组结构的主要兴趣在于能够从Python或外部源加载现有数据。NumPy提供了高效便捷的方式来从文本（Python字符串或文本/CSV文件）或二进制缓冲区或文件中加载多维数组。此外，Pandas包在加载表格数据时尤为有用，即包含异构数据类型的表格，而不仅仅是数字。
- en: From a native Python object
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从原生Python对象
- en: It is quite common to have data in some native Python object and to want to
    convert it into a NumPy array. The standard method is to use the `array` function.
    When we created arrays by directly specifying their values, we actually converted
    Python lists of numbers into arrays.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据常常以某种原生Python对象的形式存在，我们希望将其转换为NumPy数组。标准方法是使用`array`函数。当我们通过直接指定值来创建数组时，我们实际上是将Python数字列表转换为了数组。
- en: From a buffer or an external file
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从缓冲区或外部文件
- en: 'Another common way of creating an array is to load data from a memory buffer
    or from a file, with either binary or string elements. From a Python buffer object,
    which we know the exact data type of, we can obtain a NumPy array with the function
    `frombuffer`. Similarly, the `fromstring` function accepts either ASCII text with
    values separated by any delimiter or binary data in any data type, as shown in
    the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的另一种常见方式是从内存缓冲区或文件中加载数据，无论是二进制数据还是字符串元素。从一个Python缓冲区对象（我们知道它的确切数据类型）中，我们可以使用`frombuffer`函数获得一个NumPy数组。同样，`fromstring`函数接受ASCII文本，值由任意分隔符分隔，或者接受任何数据类型的二进制数据，如下例所示：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The functions `fromfile`, `loadtxt`, and `genfromtxt` allow to load data from
    text files or binary files and convert them into NumPy arrays. The function `loadtxt`
    is a simplified version of `genfromtxt`, useful when the file format is straightforward.
    The `fromfile` function is highly efficient with binary data. For example, to
    import data contained in the text files of the Facebook dataset, we can enter
    the following commands:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`fromfile`、`loadtxt`和`genfromtxt`函数允许从文本文件或二进制文件加载数据，并将其转换为NumPy数组。`loadtxt`函数是`genfromtxt`的简化版本，适用于文件格式简单的情况。`fromfile`函数在处理二进制数据时效率很高。例如，要导入Facebook数据集的文本文件中的数据，我们可以输入以下命令：'
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, saving arrays in files is as easy as loading NumPy arrays. There are
    basically two functions, `save` and `savetxt`, which save an array into a binary
    and text file, respectively. Relatedly, the `loadz` and `savez` functions are
    also conveniently used to save *dictionaries* of variables of any type (including
    NumPy arrays). All these functions use platform-independent file formats.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将数组保存到文件中和加载NumPy数组一样简单。基本上有两个函数，`save`和`savetxt`，分别将数组保存为二进制文件和文本文件。相关的，`loadz`和`savez`函数也非常方便，用于保存*字典*类型的变量（包括NumPy数组）。所有这些函数使用平台无关的文件格式。
- en: Using Pandas
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Pandas
- en: Pandas is another, more recent Python package that provides convenient and efficient
    ways of loading and manipulating data sets from heterogeneous sources. It is particularly
    useful when dealing with tabular data sets, in opposition to purely numerical
    data (matrices or arrays of numbers). It can handle missing values and data alignment
    issues (for example, with time series). The loaded data sets can be used with
    NumPy for efficient numerical computations. In brief, Pandas provides high-level
    access to tabular data, whereas NumPy provides lower-level access to raw homogeneous
    multidimensional arrays.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas是另一个较新的Python包，提供了便捷高效的方式来加载和操作来自异构源的数据集。它特别适用于处理表格数据集，而不是纯粹的数值数据（矩阵或数字数组）。它能够处理缺失值和数据对齐问题（例如，时间序列）。加载的数据集可以与NumPy一起用于高效的数值计算。简而言之，Pandas提供了对表格数据的高层次访问，而NumPy则提供了对原始同质多维数组的低层次访问。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The future of NumPy**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy的未来**'
- en: Travis Oliphant, the creator of NumPy, is currently working on its successor,
    Blaze. This project will unify many of the features currently offered by NumPy,
    Pandas, SciPy, Numba, Theano, and so on within a single framework.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的创始人Travis Oliphant目前正在开发它的继任者Blaze。这个项目将把NumPy、Pandas、SciPy、Numba、Theano等当前提供的许多功能统一到一个框架中。
- en: Here is an example of how we can load a data set with Pandas. We will download
    and analyze a data set about a large number of cities around the world and their
    population. This data set has been created by **MaxMind** and is available for
    free from [http://www.maxmind.com](http://www.maxmind.com).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用Pandas加载数据集的一个示例。我们将下载并分析一个关于世界各地大量城市及其人口的数据集。这个数据集由**MaxMind**创建，并可以免费从[http://www.maxmind.com](http://www.maxmind.com)获得。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Online public data sets**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**在线公共数据集**'
- en: 'With the open data movement, more and more data is becoming publicly available.
    Analyzing interesting data is a good way to gain experience with the tools described
    in this book, which are particularly well adapted for this task. However, it is
    not always obvious to find good data sets online. The following are some links
    containing pointers to high quality data sets, often maintained by government
    agencies, international organizations, universities, or research institutes, and
    so on:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开放数据运动的推进，越来越多的数据变得公开可用。分析有趣的数据是使用本书中描述的工具的好方法，这些工具特别适合执行此类任务。然而，在线找到好的数据集并不总是那么显而易见。以下是一些链接，其中包含指向高质量数据集的指示，这些数据集通常由政府机构、国际组织、大学或研究机构等维护：
- en: Research-quality data sets, maintained by Hilary Mason, are available at [https://bitly.com/bundles/hmason/1](https://bitly.com/bundles/hmason/1).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Hilary Mason维护的研究质量数据集可以在[https://bitly.com/bundles/hmason/1](https://bitly.com/bundles/hmason/1)找到。
- en: Public data, maintained by Google, is available at [http://www.google.com/publicdata/](http://www.google.com/publicdata/).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Google维护的公共数据可在[http://www.google.com/publicdata/](http://www.google.com/publicdata/)上获取。
- en: Data catalogs are available at [http://datacatalogs.org/dataset](http://datacatalogs.org/dataset).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据目录可以在[http://datacatalogs.org/dataset](http://datacatalogs.org/dataset)上找到。
- en: 'We first download the ZIP file and uncompress it in a folder, as shown in the
    following commands (the ZIP file is about 40 MB large, so downloading it may take
    a while):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先下载ZIP文件并将其解压到一个文件夹中，如以下命令所示（ZIP文件约为40 MB，因此下载可能需要一些时间）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For convenience, we can create an alias to the newly-created folder with the
    command `%bookmark citiesdata data`. Now, we are going to load the CSV file that
    has been extracted with Pandas. The `read_csv` function of Pandas can open any
    CSV file, as shown in the following commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们可以使用命令`%bookmark citiesdata data`创建对新建文件夹的别名。现在，我们将加载已提取的CSV文件，使用Pandas的`read_csv`函数可以打开任何CSV文件，如以下命令所示：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s explore the newly created `dat` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索新创建的`dat`对象：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `data` object is a `DataFrame` object, a Pandas type consisting of a two-dimensional
    labeled data structure with columns of potentially different types (like an Excel
    spreadsheet). Like a NumPy array, the `shape` attribute returns the shape of the
    table. But unlike NumPy, the `DataFrame` object has a richer structure, and, in
    particular, the `keys` method returns the names of the different columns, as shown
    in the following commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`对象是一个`DataFrame`对象，这是Pandas的一种类型，包含一个二维的标签化数据结构，其列可能具有不同的数据类型（如Excel电子表格）。像NumPy数组一样，`shape`属性返回表格的形状。但与NumPy不同，`DataFrame`对象具有更丰富的结构，特别是`keys`方法返回不同列的名称，如以下命令所示：'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see that `data` has more than three million lines and seven columns
    including the country, city, population, and geographical coordinates of each
    city. The `head` and `tail` methods allow to take a quick look at the beginning
    and the end of the table respectively. Note that, when using Pandas from the IPython
    notebook, the displayed data can be formatted as an HTML table for more convenient
    reading, as shown in the following example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`data`有超过三百万行，并且包括国家、城市、人口和每个城市的地理坐标在内的七个列。`head`和`tail`方法分别允许我们快速查看表格的开头和结尾。请注意，当在IPython笔记本中使用Pandas时，显示的数据可以格式化为HTML表格，方便阅读，如以下示例所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the example table:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例表格：
- en: '![Using Pandas](img/9932OS_03_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![使用Pandas](img/9932OS_03_03.jpg)'
- en: Displaying a Pandas table in the IPython notebook
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython笔记本中显示Pandas表格
- en: We can see that some cities have **NaN** (**Not a Number**) values as populations.
    The reason is that the population is not available for all cities in the data
    set, and Pandas handles those missing values transparently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: We will see in the next sections what manipulations and computations we can
    actually perform with this data set to get useful information about it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once NumPy arrays are created or loaded, there are basically three things that
    we can do with them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Selection
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulation
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selection consists of accessing one or several elements within an array. It
    can be done with NumPy or Pandas.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Using Pandas
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s continue with our example data opened with Pandas. Each column of the
    `data` object of `DataFrame` can be accessed through its name. In IPython, tab
    completion proposes the different columns of the data. In the following example,
    we get the names of all cities (`AccentCity` is the full name of the city, with
    uppercase characters and accents):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This column is an instance of the `Series` class. We can access certain rows
    using indexing. In the following example, we get the name of the 30,001th city
    (remembering that indexing is zero-based):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, we can access an element using its index. But how can we obtain a city from
    its name? For example, we would like to obtain the population and GPS coordinates
    of New York. A possibility might be to loop through all cities and check their
    names, but it would be extremely slow because the Python loops on millions of
    elements are not optimized at all. Pandas and NumPy offer a much more elegant
    and efficient way called **Boolean** **indexing**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps that typically occur on the same line of code. First, we
    create an array with Boolean values indicating, for each element, whether it satisfies
    a condition or not (here, whether the city name is `New York`). Then, we pass
    this array of Booleans as an index to our original array. The result is then a
    subpart of the full array with only the elements corresponding to `True`, as shown
    in the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The same syntax works in NumPy and Pandas. Here, we find a dozen cities named
    `New York`, but only one happens to be in the New York state. To access a single
    element with Pandas, we can use the `.ix` attribute (`ix` for index) as shown
    in the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using NumPy
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s turn this series object into a pure NumPy array. We go from the
    Pandas world to NumPy (keeping in mind that Pandas is built on top of NumPy).
    We will mostly work with the population count of all cities as shown in the following
    commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `population` array is a one-dimensional vector with the populations of
    all cities (or `NaN` if the population is not available). The population of New
    York can be accessed in NumPy with basic indexing, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s find out how many cities do have an actual population count. To do this,
    we will select all elements in the population array that have a value different
    from NaN. We can use the NumPy function `isnan` as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `~_` contains the negative values of `isnan(population)`. We find
    that there are roughly 48,000 cities, corresponding to 1.5 percent of all cities
    in this data set, which have an actual population count.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: More indexing possibilities
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More generally, indexing allows us to take any portion of an array. We saw in
    the previous section how to filter an array with a Boolean condition. We can also
    specify directly the list of indices we want to keep. For instance, if `x` is
    a one-dimensional NumPy array, `x[i:j:k]` represents a view on `x` with only those
    elements having indices between `i` (included) and `j` (excluded) with a step
    of `k`. If `i` is omitted, it is assumed to be zero. If `j` is omitted, it is
    assumed to be the length of the array in that dimension. Negative values mean
    we count from the end. Finally, the default value for `k` is one. This notation
    is also valid in multiple dimensions; for example, `M[i:j,k:l]` creates a submatrix
    view on a 2D array `M`. Also, we can use `x[::-1]` to get `x` in the reverse order.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: These conventions, with `i` included and `j` excluded, are convenient when working
    with consecutive portions of an array. For example, the first and second halves
    of `x`, assuming a size `2n`, are simply `x[:n]` and `x[n:]`. In addition, the
    length of `x[i:j]` is simply `j - i`. In the end, there should not be `+1` or
    `-1` values hanging around in indices in general.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to consider with array views is that they point to the same
    location in memory. So a view on a large array does not imply memory allocation,
    and changing the values of elements in the view also changes the corresponding
    values in the original array, as shown in the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, `y` contains all elements in `x` with even indices (here, indices
    zero, two, and four). Changing the value of `y[0]` changes both `y[0]` and `x[0]`,
    since `y[0]` refers to the first element of `x`. If this behavior is unwanted,
    it is possible to force the creation of a new array with `y = x.copy()` or `y
    = array(x)`. In the latter case, it is also possible to change the data type of
    `x`, with the `dtype` keyword argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, another way of selecting a portion of an array consists in passing
    an array with explicit integer values for indices. This is called **fancy indexing**.
    If `x` is a one-dimensional vector, and `indices` is another one-dimensional vector
    (or a list) with positive integers, then `x[indices]` returns a vector containing
    `x[indices[0]]`, `x[indices[1]]`, and so on. Therefore, the length of `x[indices]`
    is equal to the length of `indices` and not the length of `x`, as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that a given index can be repeated several times in the index array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Manipulation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays can be manipulated and reshaped, which can sometimes be useful when performing
    vectorized computations. It is also possible to construct a new array from identical
    copies of an original array. The complete list of routines can be found in the
    NumPy reference guide at [http://docs.scipy.org/doc/numpy/reference/routines.html](http://docs.scipy.org/doc/numpy/reference/routines.html).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the `reshape` method allows to change the shape of an array if the total
    number of elements is kept constant, as shown in the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is possible to use `-1` in at most one dimension in the argument of `reshape`
    to specify that its value must be automatically inferred; for example, `x.reshape((2,
    -1))` instead of `x.reshape((2, 3))`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The number of dimensions can also be changed with `ravel` (to remove all multidimensional
    structures in an array and return a flattened vector), `squeeze` (to remove all
    single-dimensional entries from the shape of an array), and `expand_dims` (to
    insert a new axis in an array).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Repeating and concatenating
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `til` and `repeat` functions allow to create copies of an array, either
    by concatenating identical copies of it along a specified axis, or by copying
    every coefficient any number of times, as shown in the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we first create an array with a vertical stack of two identical copies
    of `x`, and we create a new array with each element of `x` repeated three times.
    The second argument of repeat can also be a list `reps`, in which case the coefficient
    `x[i]` is repeated `reps[i]` times.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s create a multiplication table using `reshape` and `tile`.
    The idea is to first define one row vector and one column vector with all integers
    between `1` and `n`, tile them, and multiply them, knowing that the multiplication
    occurs element-wise as shown in the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s time the execution of this function using the following commands:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function is about 27 times faster than the previous version `mul1`, which
    used nested Python loops.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can use `hstack`, `vstack`, `dstack`, or `concatenate` to join several
    arrays into a single array along the first, second, third, or any dimension, respectively.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `hsplit`, `vsplit`,`dsplit`, or `split` functions allow to split
    an array into several consecutive subarrays along any dimension, as shown in the
    following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The second argument of `split` is either an integer, `n`, in which case the
    array is split into *n* equal arrays, or a list with the indices where the array
    should be split (that is, the indices of the first element in each subarray except
    the first).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous multiplication table example, we had to repeat identical copies
    of a row and a column so that we could multiply the two arrays with identical
    shapes `(n, n)`. Actually, the `repeat` step is unnecessary, as arrays with different
    shapes can still be compatible under specific conditions; this is called **broadcasting**.
    The general rule is that *two dimensions are compatible when they are equal, or
    when one of them is 1*. For example, two arrays, `M` and `N`, of the shape `(1,
    n)` and `(n, 1)` can be multiplied together, because in the first dimension, `M`
    array's shape is `1`, whereas `N` array's shape is `1` in the second dimension.
    The dimension equal to one is transparently and silently stretched to match the
    other dimension, and this operation does not involve memory copy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we can get rid of the `tile` operation in the multiplication table
    example as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following commands are used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, `mul3` is about 2.6 times faster than `mul2`, and about 70 times faster
    than `mul1`! The reason is that `tile` involves array copying and memory allocation,
    whereas only multiplications happen in `mul3`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Permuting
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several functions allow to permute the axes in an array. For example, the `transpose`
    function permutes the dimensions of an array. The indices describing the permutation
    can be provided in the `axes` keyword argument.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Other transposition functions that may be useful include `fliplr` and `flipud`
    to flip an array in the left/right or up/down direction, `roll` to perform a circular
    permutation of the elements along a given axis, and `rot90` to rotate an array
    by 90 degrees in he counter-clockwise direction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Computation
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The whole point of creating and manipulating arrays is to perform efficient
    vectorized computations with them. The four elementary operations work between
    arrays under the condition that they have compatible shapes. In addition, a lot
    of mathematical functions are available in the vectorized form for NumPy arrays.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If `A` and `B` are two NumPy arrays with compatible shapes, `A + B`, `A - B`,
    `A x B`, and `A / B` are element-wise operations. In particular, when `A` and
    `B` are two-dimensional matrices, `A x B` is *not* the matrix product. The matrix
    product is rather provided by the `dot` function, which more generally computes
    the dot product of two arrays.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Common unary operations include `-A`, `A ** x` (coefficients to power `x`),
    `abs(A)` (absolute value), `sign(A)` (an array with `-1`, `0`, or `1` depending
    on the sign of each element), `floor(A)` (floor of each element), `sqrt(A)` (square
    root), `log(A)` (natural logarithm), `exp(A)` (exponential), and a lot of other
    mathematical functions (trigonometric, hyperbolic, arithmetic functions, and so
    on).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: NumPy also provides functions to compute the sum (`sum`) or product (`prod`)
    of all elements in an array or in a given dimension. The `axis` keyword argument
    specifies the dimensions on which the sum is to be performed. This function returns
    an array with one dimension less than the original array.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max` and `min` functions return the largest and lowest values in an array
    or in a given dimension. The `argmin` and `argmax` functions return the index
    of the smallest or largest element of the array. For example, continuing with
    our `cities` example we can have the following commands for the `locate` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `locate` function takes two coordinates with a position's latitude and longitude,
    and returns the closest city's name. The `argmin` function returns the index of
    the city with the smallest distance to the specified position.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, statistical functions such as `mean`, `median`, `std`, and `var` compute
    the mean, median, standard deviation, and variance of the elements along a given
    dimension or across the whole array. Also, the `describe` method of Pandas objects
    gives several useful statistics (including the mean, standard deviation, the 50
    percent quantile or median, and the 25 precent and 75 percent quantiles) as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Related functions that can be useful when simulating mathematical models include
    `diff` (discrete difference), `cumsum` (cumulative sum), and `cumprod` (cumulative
    product). The `diff` function allows to compute a discrete *derivative* of a signal
    (up to a scalar coefficient), whereas `cumsum` computes a discrete *indefinite
    integral* of a signal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Advanced mathematical processing
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy provides all necessary types and routines for doing efficient numerical
    computations with Python. SciPy is built on top of NumPy and implements a large
    variety of higher-level mathematical processing algorithms. These algorithms span
    several areas of numerical computing, such as optimization, linear algebra, signal
    processing, statistics, and the like. Also, the various **SciKits** packages (`scikit-learn`,
    `scikit-image`, and so on) are yet more advanced packages implementing highly
    specialized algorithms in specific domains (machine learning, image processing,
    and so on).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'We give here a short overview of the scientific computing features provided
    by SciPy and a few other packages. The full list of features can be found on the
    official reference guide: [http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/).
    Giving practical examples and applications is beyond the scope of this book, and
    the interested reader can find a wide variety of examples in the *NumPy Cookbook*,
    *Ivan Idris*, *Packt Publishing*, and *Learning SciPy for Numerical and Scientific
    Computing*, *Francisco Blanco-Silva*, *Packt Publishing*, both by Packt Publishing.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear algebra** routines are provided by the `scipy.linalg` subpackage:
    solvers of linear equations, matrix routines, eigenvalue problems, matrix decomposition,
    and so on.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimization routines** are provided by the `scipy.optimize` subpackage:
    unconstrained or constrained minimization of real-valued functions, global optimization,
    curve fitting, and so on.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numerical integrators** are provided by the `scipy.integrate` subpackage.
    It can be used to solve differential equations, for example, in physics simulation
    engines.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal processing** algorithms are implemented in the `scipy.signal` subpackage:
    convolutions, linear filters, wavelets, and so on. The `scipy.fftpack` subpackage,
    which implements Fourier transforms routines, and the `scipy.ndimage` subpackage,
    which implements several image processing algorithms. Finally, other image processing
    packages of interest include `scikit-image`, `PIL`, and `OpenCV` (computer vision).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statistical routines** are provided by the `scipy.stats` subpackage: probability
    distributions, descriptive statistics and statistical tests, and so on. `SciPy.cluster`
    implements clustering algorithms that can be useful to find categories in unstructured
    data. Other statistical packages of interest include `Pandas` and `scikit-learn`
    (machine learning).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the multidimensional array object offered by NumPy,
    and we showed how it can be used for efficient computations on numerical data
    sets. In particular, it is well adapted for loading any sort of data, and the
    Pandas package makes this task straightforward, even with complex data files.
    Using advanced algorithms is possible with IPython with the help of powerful external
    packages, such as NumPy, SciPy, and the SciKit libraries. However, this subject
    is beyond the scope of this book, and the interested reader can find a variety
    of examples in the *NumPy Cookbook, Ivan Idris, Packt Publishing* and *Learning
    SciPy for Numerical and Scientific Computing, Francisco Blanco-Silva, Packt Publishing*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will present the visualization-related possibilities
    offered by IPython and Matplotlib, which are very often used in conjunction with
    NumPy for interactive visualization of data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
