["```py\nfor s in ['a', 'b', 'c']:\n    print(s) # a b c\n```", "```py\nfor iteration in range(n): # repeat the following code n times\n    ...\n```", "```py\nfor k in range(...):\n    ...\n    element = my_list[k]\n```", "```py\nfor element in my_list:\n    ...\n```", "```py\nfor k, element in enumerate(my_list):\n    ...\n```", "```py\na=ones((3,5))\nfor k,el in ndenumerate(a):\n    print(k,el)       \n# prints something like this:  (1, 3) 1.0\n```", "```py\nmaxIteration = 10000\nfor iteration in range(maxIteration):\n    residual = compute() # some computation\n    if residual < tolerance:\n        break\nelse: # only executed if the for loop is not broken\n    raise Exception(\"The algorithm did not converge\")\nprint(f\"The algorithm converged in {iteration + 1} steps\")\n```", "```py\nfor element in obj:\n    ...\n```", "```py\nL = ['A', 'B', 'C']\nfor element in L:\n    print(element)\n```", "```py\nfor iteration in range(100000000):\n    # Note: the 100000000 integers are not created at once\n    if iteration > 10:\n        break\n```", "```py\nl=list(range(100000000))\n```", "```py\nl=[1,2] \nli=l.__iter__() \nli.__next__() # returns 1 \nli.__next__() # returns 2 \nli.__next__() # raises StopIteration exception \n```", "```py\ndef odd_numbers(n): \n    \"generator for odd numbers less than n\" \n    for k in range(n): \n        if k % 2 == 1: \n           yield k\n```", "```py\ng = odd_numbers(10)\nfor k in g:\n    ...    # do something with k\n```", "```py\nfor k in odd_numbers(10):\n    ... # do something with k\n```", "```py\nL = ['a', 'b', 'c']\niterator = iter(L)\nlist(iterator) # ['a', 'b', 'c']\nlist(iterator) # [] empty list, because the iterator is exhausted\n\nnew_iterator = iter(L) # new iterator, ready to be used\nlist(new_iterator) # ['a', 'b', 'c']\n```", "```py\ng = odd_numbers(10)\nfor k in g:\n    ... # do something with k\n\n# now the iterator is exhausted:\nfor k in g: # nothing will happen!!\n    ...\n\n# to loop through it again, create a new one:\ng = odd_numbers(10)\nfor k in g:\n    ...\n```", "```py\nA = ['a', 'b', 'c']\nfor iteration, x in enumerate(A):\n    print(iteration, x)     # result: (0, 'a') (1, 'b') (2, 'c')\n```", "```py\nA = [0, 1, 2]\nfor elt in reversed(A):\n    print(elt)      # result: 2 1 0\n```", "```py\nfor iteration in itertools.count():\n    if iteration > 100:\n       break # without this, the loop goes on forever\n       print(f'integer: {iteration}')\n       # prints the 100 first integer\n```", "```py\nfrom itertools import count, islice\nfor iteration in islice(count(), 10): \n     # same effect as range(10)\n          ...\n```", "```py\ndef odd_numbers():\n    k=-1\n    while True:  # this makes it an infinite generator\n        k+=1\n        if k%2==1:\n           yield k\n```", "```py\nlist(itertools.islice(odd_numbers(),10,30,8)) \n# returns [21, 37, 53]\n```", "```py\ndef fibonacci(u0, u1):\n    \"\"\"\n    Infinite generator of the Fibonacci sequence.\n    \"\"\"\n    yield u0\n    yield u1\n    while True:\n        u0, u1 = u1, u1 + u0  \n        # we shifted the elements and compute the new one\n        yield u1\n```", "```py\n# sequence of the 100 first Fibonacci numbers:\nlist(itertools.islice(fibonacci(0, 1), 100))\n```", "```py\ndef arithmetic_geometric_mean(a, b):\n    \"\"\"\n    Generator for the arithmetic and geometric mean\n    a, b initial values\n    \"\"\" \n    while True:    # infinite loop\n         a, b = (a+b)/2, sqrt(a*b)\n         yield a, b\n```", "```py\ndef elliptic_integral(k, tolerance=1.e-5):\n    \"\"\"\n    Compute an elliptic integral of the first kind.\n    \"\"\"\n    a_0, b_0 = 1., sqrt(1-k**2)\n    for a, b in arithmetic_geometric_mean(a_0, b_0):\n        if abs(a-b) < tolerance:\n            return pi/(2*a)\n```", "```py\nfrom itertools import islice\ndef elliptic_integral(k, tolerance=1e-5, maxiter=100):\n    \"\"\"\n    Compute an elliptic integral of the first kind.\n    \"\"\"\n    a_0, b_0 = 1., sqrt(1-k**2)\n    for a, b in islice(arithmetic_geometric_mean(a_0, b_0), maxiter):\n        if abs(a-b) < tolerance:\n            return pi/(2*a)\n    else:\n        raise Exception(\"Algorithm did not converge\")\n```", "```py\ndef pendulum_period(L, theta, g=9.81):\n    return 4*sqrt(L/g)*elliptic_integral(sin(theta/2))\n```", "```py\ndef Euler_accelerate(sequence):\n    \"\"\"\n    Accelerate the iterator in the variable `sequence`.\n    \"\"\"\n    s0 = sequence.__next__() # Si\n    s1 = sequence.__next__() # Si+1\n    s2 = sequence.__next__() # Si+2\n    while True:\n        yield s0 - ((s1 - s0)**2)/(s2 - 2*s1 + s0)\n  s0, s1, s2 = s1, s2, sequence.__next__()\n```", "```py\ndef pi_series():\n    sum = 0.\n    j = 1\n    for i in itertools.cycle([1, -1]):\n        yield sum\n        sum += i/j\n        j += 2\n```", "```py\nEuler_accelerate(pi_series())\n```", "```py\nlist(itertools.islice(Euler_accelerate(pi_series()), N))\n```", "```py\nL = []\nfor k in range(n):\n    # call various functions here\n    # that compute \"result\"\n    L.append(result)\n```", "```py\ndef result_iterator():\n    for k in itertools.count(): # infinite iterator\n        # call various functions here\n        # that t lists compute \"result\"\n        ...\n        yield result\n```", "```py\nL = list(itertools.islice(result_iterator(), n)) # no append needed!\n```", "```py\n# make sure that you do not use numpy.sum here\ns = sum(itertools.islice(result_iterator(), n))\n```", "```py\nL=list(itertools.takewhile(lambda x: abs(x) > 1.e-8, result_iterator()))\n```", "```py\nL = [some_function(k) for k in range(n)]\n```", "```py\nimport itertools\ndef power_sequence(u0):\n    u = u0\n    while True:\n        yield u\n        u = u**2\n```", "```py\nlist(itertools.islice(power_sequence(2.), 20))\n```", "```py\ngenerator = power_sequence(2.)\nL = []\nfor iteration in range(20):\n    try:\n        L.append(next(generator))\n    except Exception:\n        break\n```", "```py\ng = (n for n in range(1000) if not n % 100)\n# generator for  100, 200, ... , 900\n```", "```py\nsum(n for n in range(1000) if not n % 100) \n# returns 4500 (sum is here the built-in function)\n```", "```py\nsum(1/n**s for n in itertools.islice(itertools.count(1), N))\n```", "```py\ndef generate_zeta(s):\n    for n in itertools.count(1):\n        yield 1/n**s\n```", "```py\ndef zeta(N, s):\n    # make sure that you do not use the scipy.sum here\n    return sum(itertools.islice(generate_zeta(s), N))\n```", "```py\nxg = x_iterator()  # some iterator\nyg = y_iterator()  # another iterator\n\nfor x, y in zip(xg, yg):\n    print(x, y)\n```", "```py\nclass OdeStore:\n    \"\"\"\n    Class to store results of ode computations\n    \"\"\"\n    def __init__(self, data):\n        \"data is a list of the form [[t0, u0], [t1, u1],...]\"\n        self.data = data\n\n    def __iter__(self):\n        \"By default, we iterate on the values u0, u1,...\"\n        for t, u in self.data:\n            yield u\n\nstore = OdeStore([[0, 1], [0.1, 1.1], [0.2, 1.3]])\nfor u in store:\n    print(u)\n# result: 1, 1.1, 1.3\nlist(store) # [1, 1.1, 1.3]\n```", "```py\n>>> list(3)\nTypeError: 'int' object is not iterable\n```", "```py\n>>> for iteration in 3: pass\nTypeError: 'int' object is not iterable\n```", "```py\nwhile condition:\n    <code>\n```", "```py\nfor iteration in itertools.count():\n    if not condition:\n        break\n    <code>\n```", "```py\nmaxit = 100\nfor nb_iterations in range(maxit):\n    ...\nelse:\n    raise Exception(f\"No convergence in {maxit} iterations\")\n```", "```py\ndef f(N):\n    if N == 0: \n        return 0\n    return f(N-1)\n```", "```py\nimport sys \nsys.setrecursionlimit(1000)\n```", "```py\nfor iteration in range(10000000):\n    pass\n```"]