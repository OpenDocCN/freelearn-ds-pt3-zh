<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Time Series and Plotting Using Matplotlib</h1>
                </header>
            
            <article>
                
<p class="mce-root">Time series data is generated by a variety of processes, including the <strong><span>Internet of Things</span></strong> (<strong>IoT</strong>) sensors, machine/server logs, and monthly sales data from <strong>Customer Relationship Management</strong> (<strong>CRM</strong>) system. Some common characteristics of time series data is that the data points are generated at a fixed frequency and that there is an inherent trend and seasonality associated with the data.</p>
<p>In this chapter, we will take a tour of some topics that are necessary to develop expertise in using pandas. Knowledge of these topics is very useful for the preparation of data as input to programs for data analysis, prediction, or visualization.</p>
<p>The topics that we'll discuss in this chapter are as follows:</p>
<ul>
<li>Handling time series data and dates</li>
<li>Manipulation of time series data—rolling, resampling, shifting, lagging, and time element separation</li>
<li>Formatting—changing the date format and converting text to a date</li>
<li>Plotting time series using <kbd>matplotlib</kbd></li>
</ul>
<p>By the end of this chapter, you should be proficient in these critical areas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling time series data</h1>
                </header>
            
            <article>
                
<p>In this section, we show you how to handle time series data. Handling involves reading, creating, resampling, and reindexing timestamp data. These tasks need to be performed on timestamp data to make it usable. We will start by showing you how to create time series data using the data read in from a <kbd>csv</kbd> file.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading in time series data</h1>
                </header>
            
            <article>
                
<p>In this section, we demonstrate the various ways to read in time series data, starting with the simple <kbd>read_csv</kbd> method:</p>
<pre>    In [7]: ibmData=pd.read_csv('ibm-common-stock-closing-prices-1959_1960.csv')
      ibmData.head()
    Out[7]:   TradeDate  closingPrice
    0   1959-06-29   445
    1   1959-06-30   448
    2   1959-07-01   450
    3   1959-07-02   447
    4   1959-07-06   451
    5 rows 2 columns</pre>
<p>The source of this information can be found at <a href="http://datamarket.com"><span class="URLPACKT">http://datamarket.com</span></a>.</p>
<p>We would like the <kbd>TradeDate</kbd> column to be a series of <kbd>datetime</kbd> values so that we can index it and create a time series:</p>
<ol>
<li>
<p>Let's first check the type of values in the <kbd>TradeDate</kbd> series:</p>
</li>
</ol>
<pre>    In [16]: type(ibmData['TradeDate'])
    Out[16]: pandas.core.series.Series
    In [12]: type(ibmData['TradeDate'][0])
    Out[12]: str</pre>
<ol start="2">
<li>Next, we convert these values to a <kbd>Timestamp</kbd> type:</li>
</ol>
<pre>    In [17]: ibmData['TradeDate']=pd.to_datetime(ibmData['TradeDate'])
            type(ibmData['TradeDate'][0])
    Out[17]: pandas.tslib.Timestamp  </pre>
<ol start="3">
<li>We can now use the <kbd>TradeDate</kbd> column as an index:</li>
</ol>
<pre style="padding-left: 60px">In [113]: #Convert DataFrame to TimeSeries
              #Resampling creates NaN rows for weekend dates, <br/>             hence use dropna
             ibmTS=ibmData.set_index('TradeDate').resample('D'                      ['closingPrice'].dropna()
        ibmTS
    Out[113]: TradeDate
             1959-06-29    445
             1959-06-30    448
             1959-07-01    450
             1959-07-02    447
      1959-07-06    451
      ...
      Name: closingPrice, Length: 255    </pre>
<p>In the next section, we will learn how to assign a date column as an index and then perform subsetting based on the index. For this section, we will use the <kbd>Object Occupancy</kbd> dataset where some room parameters were observed every few minutes for several weeks and the corresponding room occupancy was observed. This dataset is present as three separate files. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assigning date indexes and subsetting in time series data</h1>
                </header>
            
            <article>
                
<p><span>Let's read them and concatenate them to make a single file:</span></p>
<pre>import pandas as pd <br/>import os os.chdir(' ') <br/>ts1=pd.read_csv('datatraining.txt') <br/>ts2=pd.read_csv('datatest.txt') <br/>ts3=pd.read_csv('datatest2.txt') <br/>ts=pd.concat([ts1,ts2,ts3] </pre>
<p>Before using the date column as an index, we will convert it to a <kbd>datetime</kbd> format and drop the actual date column:</p>
<pre>ts['datetime'] = pd.to_datetime(ts['date'])
ts = ts.set_index('datetime')
ts.drop(['date'], axis=1, inplace=True)</pre>
<p>Once the new <kbd>datetime</kbd> column is set to an index, it can be used for subsetting. For example, for filtering all the records for a particular day, we can just enclose the data inside the subsetting (square, <kbd>[]</kbd>) brackets:</p>
<pre>ts['2015-02-05']</pre>
<p>The output is similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><strong><img src="assets/8acdc469-d177-4f1c-8511-9e479596289b.png" style="width:33.75em;height:15.50em;"/></strong></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Filtering all records for a particular day</div>
<p class="mce-root">To filter all the records for a particular hour across all days, the following snippet will do the job:</p>
<pre>   ts[ts.index.hour==4]</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><strong><img src="assets/a7dbe9a1-b3f1-41d0-93b7-67de1a672bc5.png" style="width:34.08em;height:13.83em;"/></strong></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Filtering all records for a particular hour</div>
<p>We can also filter out all the records between two timestamps by using the following snippet: </p>
<pre>     ts['2015-02-05':'2015-02-06']</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><strong><img src="assets/e28e9cb3-69b6-4c1e-aa92-beb5afef08a3.png" style="width:35.17em;height:12.50em;"/></strong></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Filtering all records between two timestamps</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Plotting the time series data</h1>
                </header>
            
            <article>
                
<p>To better understand the trends and any seasonality present in the data, it can be plotted using a basic plot function. Here, the humidity and CO<sub>2</sub> variables of the dataset have been plotted:</p>
<pre>    ts.plot(y="Humidity",style='.',figsize=(15,1))
    ts.plot(y="CO2",style='.',figsize=(15,1))</pre>
<p>The following is the output:</p>
<div class="CDPAlignCenter CDPAlign"><strong><img src="assets/25071ff0-694a-4ad7-9012-482ff022599b.png" style="width:51.25em;height:14.75em;"/></strong></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Plotting humidity and CO2 levels across time in the same graph using matplotlib</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resampling and rolling of the time series data</h1>
                </header>
            
            <article>
                
<p>Resampling means changing the frequency of the observed time series. For example, in this dataset, a data point is observed every few seconds. This dataset can be resampled to an hourly frequency where all the data points for an hour will be aggregated using an aggregation function of choice to result in one data point for an hour. It can be done at a daily level as well, where all the data points in a day will be aggregated. Resampling can also be thought of as data smoothing as it smooths or averages out the bumps in data.</p>
<p>In pandas, it is easy to resample time series data as there is a built-in function for that. Let's see how we can use that.</p>
<p>For example, to resample at an hourly level, we write the following code:</p>
<pre>ts[["Humidity"]].resample("1h").median().plot(figsize=(15,1)) </pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3f93f85-a726-4c49-96d8-a0e87fb1a0c8.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Resampling the data at an hourly level using the median as the aggregate measure</div>
<p>Similarly, to resample at a daily level, we write the following code: </p>
<pre>    ts[["Humidity"]].resample("1d").median().plot(figsize=(15,1))
  </pre>
<p>The following is the output:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/bbde9823-3ad5-41c6-85e3-42c7f2479aab.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"> Resampling the data at a daily level using the median as the aggregate measure</div>
<p>Please note how data sampled at an hourly level has more variations than the daily one, which is smoother. </p>
<p class="mce-root"/>
<p>Rolling is also a similar concept for aggregating data points, although it is more flexible. A rolling window, that is, the number of data points that are aggregated can be provided to control the level of aggregation or smoothing.</p>
<p>If you look at the <kbd>datetime</kbd> column carefully, you can see that a data point has been observed every minute. Hence, 60 such points constitute an hour. Let's see how we can use the rolling method to aggregate the data.</p>
<p>For rolling 60 data points, starting from each data point as one record, we provide 60 as the rolling window, which is shown as follows. This should return a plot similar to the hourly resampling previously obtained:</p>
<pre>    ts[["Humidity"]].rolling(60).median().plot(figsize=(15,1))  </pre>
<p>The following is the output:</p>
<div class="CDPAlignCenter packt_figref CDPAlign"><img src="assets/37f46407-9043-45da-be80-c267de613b0d.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Rolling every consecutive 60 points and aggregating them to give the median as the final value</div>
<p>For rolling at a day level, the rolling window should be <em>60 x 24</em>:</p>
<pre class="mce-root">    ts[["Humidity"]].rolling(60*24).median().plot(figsize=(15,1))  </pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/06283f03-667e-4846-894d-f5c8fefb263f.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Rolling every consecutive 60*24 points and aggregating them to give their median as the final value; this amounts to finding daily aggregate values for minute-level data</div>
<div class="packt_infobox">Note that the median has been used for aggregation. You can also use any other function such as mean or sum.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Separating timestamp components</h1>
                </header>
            
            <article>
                
<p>A timestamp object is made of several components, namely, year, month, day, hour, minute, and second. For many time series analyses, it is important to segregate these components and keep them as new columns for later usage.</p>
<p>Since we have made the date column our index, it becomes a lot easier. A separate column for each component can be created as follows:</p>
<pre>ts['Year']=ts.index.year<br/>ts['Month']=ts.index.month<br/>ts['Day']=ts.index.day<br/>ts['Hour']=ts.index.hour<br/>ts['Minute']=ts.index.minute<br/>ts['Second']=ts.index.second</pre>
<p>The following is the output:</p>
<div class="CDPAlignCenter packt_figref CDPAlign"><strong><img src="assets/0c99ae6f-a5b8-4684-9a77-5efe6f1c9140.png" style="width:50.25em;height:11.83em;"/></strong></div>
<div class="CDPAlignCenter packt_figref CDPAlign">Time series components created as separate columns</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DateOffset and TimeDelta objects</h1>
                </header>
            
            <article>
                
<p>A <kbd>DateOffset</kbd> object represents a change or offset in time. The key features of a <kbd>DateOffset</kbd> object are as follows:</p>
<ul>
<li>This can be added to/subtracted from a <kbd>datetime</kbd> object to obtain a shifted date.</li>
<li>This can be multiplied by an integer (positive or negative) so that the increment can be applied multiple times.</li>
<li>This has the <kbd>rollforward</kbd> and <kbd>rollback</kbd> methods to move a date forward to the next offset date or backward to the previous offset date.</li>
</ul>
<p>Let's create some date objects using the <kbd>datetime</kbd> method in <kbd>pandas</kbd>:</p>
<pre>    In [371]: xmasDay=pd.datetime(2014,12,25)
              xmasDay
    Out[371]: datetime.datetime(2014, 12, 25, 0, 0)
    
    In [373]: boxingDay=xmasDay+pd.DateOffset(days=1)
              boxingDay
    Out[373]: Timestamp('2014-12-26 00:00:00', tz=None)
    
    In [390}: today=pd.datetime.now()
              today
    Out[390]: datetime.datetime(2014, 5, 31, 13, 7, 36, 440060)  </pre>
<p>Note that <kbd>datetime.datetime</kbd> is different from <kbd>pd.Timestamp</kbd>. The former is a Python class and is inefficient, while the latter is based on the <kbd>numpy.datetime64</kbd> datatype.</p>
<p>The <kbd>pd.DateOffset</kbd> object works with <kbd>pd.Timestamp</kbd>, and adding it to a <kbd>datetime.datetime</kbd> function casts that object into a <kbd>pd.Timestamp</kbd> object.</p>
<p>The following illustrates the command for 1 week from today:</p>
<pre>    In [392]: today+pd.DateOffset(weeks=1)
    Out[392]: Timestamp('2014-06-07 13:07:36.440060', tz=None)  </pre>
<p> </p>
<p>The following illustrates the command for 5 years from today:</p>
<pre>    In [394]: today+2*pd.DateOffset(years=2, months=6)
    Out[394]: Timestamp('2019-05-30 13:07:36.440060', tz=None) </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Here is an example of using the <kbd>rollforward</kbd> functionality. <kbd>QuarterBegin</kbd> is a <kbd>DateOffset</kbd> object that is used to increment a given <kbd>datetime</kbd> object to the start of the next calendar quarter:</p>
<pre>    In [18]: lastDay=pd.datetime(2013,12,31)
    In [24]: from pandas.tseries.offsets import QuarterBegin
            dtoffset=QuarterBegin()
            lastDay+dtoffset
    Out[24]: Timestamp('2014-03-01 00:00:00', tz=None)
    
    In [25]: dtoffset.rollforward(lastDay)
    Out[25]: Timestamp('2014-03-01 00:00:00', tz=None)
  </pre>
<p>Thus, we can see that the next quarter after December 31, 2013 starts on March 1, 2014. <kbd>Timedelta</kbd> <span><span>is</span></span> similar to <kbd>DateOffset</kbd> but works with <kbd>datetime.datetime</kbd> objects. The use of these objects is explained with the following command:</p>
<pre>    In [40]: weekDelta=datetime.timedelta(weeks=1)
             weekDelta
    Out[40]: datetime.timedelta(7)
    
    In [39]: today=pd.datetime.now()
             today
    Out[39]: datetime.datetime (2014, 6, 2, 3, 56, 0, 600309)
    
    In [41]: today+weekDelta
    Out[41]: datetime.datetime (2014, 6, 9, 3, 56,0, 600309)  </pre>
<p>We have learned about datatypes, conversions between datatypes, date offsets, separating time components from timestamps, and so on, up to now. Next, we will see how we can apply some mathematical operators such as lagging, shifting, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time series-related instance methods</h1>
                </header>
            
            <article>
                
<p>In this section, we explore various methods for time series objects such as shifting, frequency conversion, and resampling.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shifting/lagging</h1>
                </header>
            
            <article>
                
<p>Sometimes, we may wish to shift the values in a time series backward or forward in time. One possible scenario is when a dataset contains the list of start dates of the new employees in a firm, and the company's HR program wishes to shift these dates forward by one year so that the employees' benefits can be activated. We can do this by using the <kbd>shift()</kbd> function as follows:</p>
<pre>    In [117]: ibmTS.shift(3)
    Out[117]: TradeDate
        1959-06-29    NaN
        1959-06-30    NaN
        1959-07-01    NaN
        1959-07-02    445
        1959-07-06    448
        1959-07-07    450
        1959-07-08    447
        ...  </pre>
<p>This shifts all the calendar days. However, if we wish to shift only business days, we must use the following command:</p>
<pre>    In [119]: ibmTS.shift(3, freq=pd.datetools.bday)
    Out[119]: TradeDate
        1959-07-02    445
        1959-07-03    448
        1959-07-06    450
        1959-07-07    447
        1959-07-09    451
  </pre>
<p>In the preceding snippet, we have specified the <kbd>freq</kbd> argument to shift; this tells the function to shift only the business days. The <kbd>shift</kbd> function has a <kbd>freq</kbd> argument whose value can be a <kbd>DateOffset</kbd> class, <kbd>TimeDelta</kbd>-like object, or an offset alias. Thus, using <kbd>ibmTS.shift(3, freq='B')</kbd> would also produce the same result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Frequency conversion</h1>
                </header>
            
            <article>
                
<p>Time series usually comes with a fixed frequency, for example, every microsecond, every second, every minute, and so on. These frequencies can be changed from one to another. </p>
<p class="mce-root"/>
<p>We can use the <kbd>asfreq</kbd> function to change frequencies, as shown in the following snippet:</p>
<pre>    In [131]: # Frequency conversion using asfreq
              ibmTS.asfreq('BM')
    Out[131]: 1959-06-30    448
        1959-07-31    428
        1959-08-31    425
        1959-09-30    411
        1959-10-30    411
        1959-11-30    428
        1959-12-31    439
        1960-01-29    418
        1960-02-29    419
        1960-03-31    445
        1960-04-29    453
        1960-05-31    504
        1960-06-30    522
        Freq: BM, Name: closingPrice, dtype: float64
  </pre>
<p>In this case, we just obtain the values corresponding to the last day of the month from the <kbd>ibmTS</kbd> time series. Here, <kbd>bm</kbd> stands for business month end frequency. For a list of all possible frequency aliases, go to <a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases">http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases</a>.</p>
<p>If we specify a frequency that is smaller than the granularity of the data, the gaps will be filled in with <kbd>NaN</kbd> values:</p>
<pre>    In [132]: ibmTS.asfreq('H')
    Out[132]: 1959-06-29 00:00:00    445
        1959-06-29 01:00:00    NaN
        1959-06-29 02:00:00    NaN
        1959-06-29 03:00:00    NaN
        ...
        1960-06-29 23:00:00    NaN
        1960-06-30 00:00:00    522
        Freq: H, Name: closingPrice, Length: 8809
  </pre>
<p>We can also apply the <kbd>asfreq</kbd> method to the <kbd>Period</kbd> and <kbd>PeriodIndex</kbd> objects, similar to how we do it for the <kbd>datetime</kbd> and <kbd>Timestamp</kbd> objects. <kbd>Period</kbd> and <kbd>PeriodIndex</kbd> are introduced later and are used to represent time intervals.</p>
<p class="mce-root"/>
<p>The <kbd>asfreq</kbd> method accepts a method argument that allows you to forward fill (<kbd>ffill</kbd>) or back fill the gaps, similar to <kbd>fillna</kbd>:</p>
<pre>    In [140]: ibmTS.asfreq('H', method='ffill') Out[140]: 1959-06-29 00:00:00 445 1959-06-29 01:00:00 445 1959-06-29 02:00:00 445 1959-06-29 03:00:00 445 ... 1960-06-29 23:00:00 522 1960-06-30 00:00:00 522 Freq: H, Name: closingPrice, Length: 8809</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resampling of data</h1>
                </header>
            
            <article>
                
<p>The <kbd>TimeSeries.resample</kbd> function enables us to summarize/aggregate more granular data, based on a sampling interval and a sampling function.</p>
<p>Downsampling is a term that originates from digital signal processing and refers to the process of reducing the sampling rate of a signal. In the case of data, we use it to reduce the amount of data that we wish to process.</p>
<p>The opposite process is upsampling, which is used to increase the amount of data to be processed and requires interpolation to obtain the intermediate data points.</p>
<div class="packt_infobox">For more information on downsampling and upsampling, refer to <em>Practical Applications of Upsampling and Downsampling</em> at <a href="http://bit.ly/1JC95HD"><span class="URLPACKT">http://bit.ly/1JC95HD</span></a> and <em>Downsampling Time Series for Visual Representation</em> at <a href="http://bit.ly/1zrExVP"><span class="URLPACKT">http://bit.ly/1zrExVP</span></a>.</div>
<p>Here, we examine some tick data for use in resampling. Before we examine the data, we need to prepare it. In doing so, we will learn some useful techniques for time series data, which are as follows:</p>
<ul>
<li>Epoch timestamps</li>
<li>Time zone handling</li>
</ul>
<p>Here is an example that uses tick data for the stock prices of Google for Tuesday, May 27, 2014:</p>
<pre>    In [150]: googTickData=pd.read_csv('./GOOG_tickdata_20140527.csv')
    In [151]: googTickData.head()
    Out[151]: Timestamp  close    high     low       open   volume
       0    1401197402  555.008 556.41  554.35 556.38   81100
       1    1401197460  556.250 556.30  555.25 555.25   18500
       2    1401197526  556.730 556.75  556.05 556.39   9900
       3    1401197582  557.480 557.67  556.73 556.73   14700
       4    1401197642  558.155 558.66  557.48  557.59   15700
    5 rows 6 columns</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The source for the preceding data can be found at <a href="http://chartapi.finance.yahoo.com/instrument/1.0/GOOG/chartdata;type=quote;range=1d/csv"><span class="URLPACKT">http://chartapi.finance.yahoo.com/instrument/1.0/GOOG/chartdata;type=quote;range=1d/csv</span></a>.</p>
<p>As you can see in the preceding code, we have a <kbd>Timestamp</kbd> column along with the columns for the closing, high, low, and opening prices, and the volume of trades of the Google stock.</p>
<p>So, why does the <kbd>Timestamp</kbd> column seem a bit strange? Well, tick data timestamps are generally expressed in epoch time (for more information, refer to <a href="http://en.wikipedia.org/wiki/Unix_epoch"><span class="URLPACKT">http://en.wikipedia.org/wiki/Unix_epoch</span></a>) as a more compact means of storage. We'll need to convert this into a more human-readable time format, and we can do this as follows:</p>
<pre>    In [201]: googTickData['tstamp']=pd.to_datetime(googTickData['Timestamp'],unit='s',utc=True)
    
    In [209]: googTickData.head()
    Out[209]:
       Timestamp   close   high   low    open  volume tstamp
    0  14011974020 555.008 556.41 554.35 556.38 81100 2014-05-27 13:30:02
    1   1401197460 556.250 556.30 555.25 555.25 18500 2014-05-27 13:31:00
    2   1401197526 556.730 556.75 556.05 556.39  9900 2014-05-27 13:32:06
    3   1401197582 557.480 557.67 556.73 556.73 14700 2014-05-27 13:33:02
    4   1401197642 558.155 558.66 557.48 557.59 15700 2014-05-27 13:34:02
    5 rows 7 columns  </pre>
<p>We would now like to make the <kbd>tstamp</kbd> column the index and eliminate the epoch <kbd>Timestamp</kbd> column:</p>
<pre>    In [210]: googTickTS=googTickData.set_index('tstamp')
              googTickTS=googTickTS.drop('Timestamp',axis=1)
              googTickTS.head()
    Out[210]:                      close  high  low  open  volume
            tstamp
            2014-05-27 13:30:02    555.008  556.41  554.35  556.38   811000
      2014-05-27 13:31:00    556.250  556.30  555.25  555.25   18500
      2014-05-27 13:32:06    556.730  556.75  556.05  556.39   9900
      2014-05-27 13:33:02    557.480  557.67  556.73  556.73   14700
      2014-05-27 13:34:02    558.155  558.66  557.48  557.59   15700
      5 rows 5 columns</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Note that the <kbd>tstamp</kbd> index column has the times in <strong>Universal Time Coordinated</strong> (<strong><span>UTC</span></strong>), and we can convert these times to US/Eastern Time using two operators: <kbd>tz_localize</kbd> and <kbd>tz_convert</kbd>:</p>
<pre>    In [211]: googTickTS.index=googTickTS.index.tz_localize('UTC').tz_convert('US/Eastern')
    
    In [212]: googTickTS.head()
    Out[212]:                        close    high    low    open    volume
    tstamp
    2014-05-27 09:30:02-04:00      555.008  556.41  554.35  556.38  81100
    2014-05-27 09:31:00-04:00      556.250  556.30  555.25  555.25  18500
    2014-05-27 09:32:06-04:00      556.730  556.75  556.05  556.39   9900
    2014-05-27 09:33:02-04:00      557.480  557.67  556.73  556.73  14700
    2014-05-27 09:34:02-04:00      558.155  558.66  557.48  557.59  15700
    5 rows 5 columns
    
    In [213]: googTickTS.tail()
    Out[213]:
             close     high    low   open   volume
    tstamp
    2014-05-27 15:56:00-04:00      565.4300  565.48 565.30 565.385  14300
    2014-05-27 15:57:00-04:00      565.3050  565.46 565.20 565.400  14700
    2014-05-27 15:58:00-04:00      565.1101  565.31 565.10 565.310  23200
    2014-05-27 15:59:00-04:00      565.9400  566.00 565.08 565.230  55600
    2014-05-27 16:00:00-04:00      565.9500  565.95 565.95 565.950 126000
    5 rows 5 columns
    
    In [214]: len(googTickTS)
    Out[214]: 390  </pre>
<p>From the preceding output (<kbd><strong>Out[213]</strong></kbd>), we can see ticks for every minute of the trading day—from 9:30 a.m., when the stock market opens, to 4:00 p.m., when it closes. This results in 390 rows in the dataset since there are 390 minutes between 9:30 a.m. and 4:00 p.m.</p>
<p>Suppose we want to obtain a snapshot every 5 minutes instead of every minute? We can achieve this using downsampling as follows:</p>
<pre>    In [216]: googTickTS.resample('5Min').head(6)
    Out[216]:                 close      high   low    open       volume
    tstamp
    2014-05-27 09:30:00-04:00 556.72460 557.15800 555.97200 556.46800 27980
    2014-05-27 09:35:00-04:00 556.93648 557.64800 556.85100 557.34200  24620
    2014-05-27 09:40:00-04:00 556.48600 556.79994 556.27700 556.60678   8620
    2014-05-27 09:45:00-04:00 557.05300 557.27600 556.73800 556.96600   9720
    2014-05-27 09:50:00-04:00  556.66200  556.93596  556.46400  556.80326  14560
    2014-05-27 09:55:00-04:00  555.96580  556.35400  555.85800  556.23600  12400
    6 rows 5 columns</pre>
<p>The default function used for resampling is the mean. However, we can also specify other functions, such as the minimum, and we can do this using the <kbd>how</kbd> parameter to resample:</p>
<pre>    In [245]: googTickTS.resample('10Min', how=np.min).head(4)
    Out[245]:         close   high      low  open  volume
    tstamp
    2014-05-27 09:30:00-04:00   555.008  556.3000  554.35  555.25   9900
    2014-05-27 09:40:00-04:00   556.190  556.5600  556.13  556.35   3500
    2014-05-27 09:50:00-04:00   554.770  555.5500  554.77  555.55   3400
    2014-05-27 10:00:00-04:00   554.580  554.9847  554.45  554.58   1800  </pre>
<p>Various function names can be passed to the <kbd>how</kbd> parameter, such as <kbd>sum</kbd>, <kbd>ohlc</kbd>, <kbd>max</kbd>, <kbd>min</kbd>, <kbd>std</kbd>, <kbd>mean</kbd>, <kbd>median</kbd>, <kbd>first</kbd>, and <kbd>last</kbd>.</p>
<p>The <kbd>ohlc</kbd> function returns open-high-low-close values on time series data, which are the first, maximum, minimum, and last values. To specify whether the left or right interval is closed, we can pass the <kbd>closed</kbd> parameter as follows:</p>
<pre>   In [254]: pd.set_option('display.precision',5)  googTickTS.resample('5Min', closed='right').tail(3) Out[254]: close high low open volume tstamp 2014-05-27 15:45:00-04:00 564.3167 564.3733 564.1075 564.1700 12816.6667 2014-05-27 15:50:00-04:00 565.1128 565.1725 565.0090 565.0650 13325.0000 2014-05-27 15:55:00-04:00 565.5158 565.6033 565.3083 565.4158 40933.3333 3 rows 5 columns </pre>
<p>Thus, in the preceding command, we can see that the last row shows the tick at 15:55 instead of 16:00.</p>
<p>For upsampling, we need to specify a fill method to determine how the gaps should be filled through the <kbd>fill_method</kbd> parameter:</p>
<pre>    In [263]: googTickTS[:3].resample('30s', fill_method='ffill')
    Out[263]:                   close    high     low    open  volume
    tstamp
    2014-05-27 09:30:00-04:00   555.008  556.41  554.35  556.38   81100
    2014-05-27 09:30:30-04:00   555.008  556.41  554.35  556.38   81100
    2014-05-27 09:31:00-04:00   556.250  556.30  555.25  555.25   18500
    2014-05-27 09:31:30-04:00   556.250  556.30  555.25  555.25   18500
    2014-05-27 09:32:00-04:00   556.730  556.75  556.05  556.39   9900
    5 rows 5 columns
    
    
    In [264]: googTickTS[:3].resample('30s', fill_method='bfill')
    Out[264]:
                               close     high    low  open  volume
    tstamp
    2014-05-27 09:30:00-04:00  555.008   556.41  554.35  556.38   81100
    2014-05-27 09:30:30-04:00  556.250   556.30  555.25  555.25   18500
    2014-05-27 09:31:00-04:00  556.250   556.30  555.25  555.25   18500
    2014-05-27 09:31:30-04:00  556.730   556.75  556.05  556.39   9900
    2014-05-27 09:32:00-04:00  556.730   556.75  556.05  556.39   9900
    5 rows 5 columns  </pre>
<p>The <kbd>fill_method</kbd> parameter currently supports only two methods—<kbd>forwardfill</kbd> and <kbd>backfill.</kbd> An interpolation method can also be supported, though, which would be vary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Aliases for time series frequencies</h1>
                </header>
            
            <article>
                
<p>To specify offsets, a number of aliases are available; some of the most commonly used ones are as follows:</p>
<ul>
<li><strong>B, BM</strong>: This stands for business day, business month. These are the working days of the month, that is, any day that is not a holiday or a weekend.</li>
<li><strong>D, W, M, Q, A</strong>: This stands for calendar day, week, month, quarter, and year end.</li>
<li><strong>H, T, S, L, U</strong>: This stands for hour, minute, second, millisecond, and microsecond.</li>
</ul>
<p>These aliases can also be combined. In the following case, we resample every 7 minutes and 30 seconds:</p>
<pre>    In [267]: googTickTS.resample('7T30S').head(5)
    Out[267]:
                               close     high   low   open    volume  
    tstamp
    2014-05-27 09:30:00-04:00 556.8266 557.4362 556.3144 556.8800 28075.0
    2014-05-27 09:37:30-04:00 556.5889 556.9342 556.4264 556.7206 11642.9
    2014-05-27 09:45:00-04:00 556.9921 557.2185 556.7171 556.9871  9800.0
    2014-05-27 09:52:30-04:00 556.1824 556.5375 556.0350 556.3896 14350.0
    2014-05-27 10:00:00-04:00 555.2111 555.4368 554.8288 554.9675 12512.5
    5 rows x 5 columns</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Suffixes can be applied to the frequency aliases to specify when in frequency period to start. These are known as anchoring offsets:</p>
<ul>
<li><strong>W – SUN, MON, ... example</strong>: W-TUE indicates a weekly frequency starting on a Tuesday.</li>
<li><strong>Q – JAN, FEB, ... DEC example</strong>: Q-MAY indicates a quarterly frequency with the year end in May.</li>
<li><strong>A – JAN, FEB, ... DEC example</strong>: A-MAY indicates an annual frequency with the year end in May.</li>
</ul>
<p>These offsets can be used as arguments for the <kbd>date_range</kbd> and <kbd>bdate_range</kbd> functions, as well as constructors for index types such as <kbd>PeriodIndex</kbd> and <kbd>DatetimeIndex</kbd>. A comprehensive discussion on this can be found in the pandas documentation at <a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#"><span class="URLPACKT">http://pandas.pydata.org/pandas-docs/stable/timeseries.html#</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time series concepts and datatypes</h1>
                </header>
            
            <article>
                
<p>When dealing with time series, there are two main concepts that you have to consider: points in time ranges, and time spans. In pandas, the former is represented by the <kbd>Timestamp</kbd> datatype, which is equivalent to the Python <kbd>datatime.datetime</kbd> (<kbd>datetime</kbd>) datatype and is interchangeable with it. The latter (time span) is represented by the <kbd>Period</kbd> datatype, which is specific to pandas.</p>
<p>Each of these datatypes has index datatypes associated with them: <kbd>DatetimeIndex</kbd> for <kbd>Timestamp</kbd>/<kbd>Datetime</kbd> and <kbd>PeriodIndex</kbd> for <kbd>Period</kbd>. These index datatypes are basically subtypes of <kbd>numpy.ndarray</kbd> that contain the corresponding <kbd>Timestamp</kbd> and <kbd>Period</kbd> datatypes and can be used as indexes for the <kbd>Series</kbd> and <kbd>DataFrame</kbd> objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Period and PeriodIndex</h1>
                </header>
            
            <article>
                
<p>The <kbd>Period</kbd> datatype is used to represent a range or span of time. Here are a few examples:</p>
<pre>    # Period representing May 2014
    In [287]: pd.Period('2014', freq='A-MAY')
    Out[287]: Period('2014', 'A-MAY')
    
    # Period representing specific day - June 11, 2014
    In [292]: pd.Period('06/11/2014')
    Out[292]: Period('2014-06-11', 'D')
    
    # Period representing 11AM, Nov 11, 1918 
    In [298]: pd.Period('11/11/1918 11:00',freq='H')
    Out[298]: Period('1918-11-11 11:00', 'H')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We can add integers to the <kbd>Period</kbd> datatypes to advance the period by the requisite number of frequency units:</p>
<pre>    In [299]: pd.Period('06/30/2014')+4
    Out[299]: Period('2014-07-04', 'D')
    
    In [303]: pd.Period('11/11/1918 11:00',freq='H') - 48
    Out[303]: Period('1918-11-09 11:00', 'H')  </pre>
<p>We can also calculate the difference between two the <kbd>Period</kbd> datatypes and return the number of units of frequency between them:</p>
<pre>    In [304]: pd.Period('2014-04', freq='M')-pd.Period('2013-02', freq='M')
    Out[304]: 14
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PeriodIndex</h1>
                </header>
            
            <article>
                
<p>A <kbd>PeriodIndex</kbd> function, which is an <kbd>index</kbd> type for a <kbd>Period</kbd> object, can be created in two ways:</p>
<ol>
<li><span>You can do it from a </span>series of Period objects using the <kbd>period_range</kbd> function to create an analogue of <kbd>date_range</kbd>: </li>
</ol>
<pre>    In [305]: perRng=pd.period_range('02/01/2014','02/06/2014',freq='D')
              perRng
    Out[305]: &lt;class 'pandas.tseries.period.PeriodIndex'&gt;
              freq: D
              [2014-02-01, ..., 2014-02-06]
              length: 6
    
    In [306]: type(perRng[:2])
    Out[306]: pandas.tseries.period.PeriodIndex
    
    In [307]: perRng[:2]
    Out[307]: &lt;class 'pandas.tseries.period.PeriodIndex'&gt;
              freq: D
             [2014-02-01, 2014-02-02]
  </pre>
<p style="padding-left: 60px">As we can confirm from the preceding command, when you pull the covers, a <kbd>PeriodIndex</kbd> function is really an <kbd>ndarray</kbd> of <kbd>Period</kbd> objects.</p>
<ol start="2">
<li>It can also be done through a direct call to the <kbd>Period</kbd> constructor:</li>
</ol>
<pre class="mce-root">    In [312]: JulyPeriod=pd.PeriodIndex(['07/01/2014','07/31/2014'], freq='D')
        JulyPeriod
    Out[312]: &lt;class 'pandas.tseries.period.PeriodIndex'&gt;
        freq: D
        [2014-07-01, 2014-07-31]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre class="mce-root">  </pre>
<p>The difference between the two approaches, as can be seen from the preceding output, is that <kbd>period_range</kbd> fills in the resulting <kbd>ndarray</kbd>, but the <kbd>Period</kbd> constructor does not, and you have to specify all the values that should be in the index.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conversion between time series datatypes</h1>
                </header>
            
            <article>
                
<p>We can convert the <kbd>Period</kbd> and <kbd>PeriodIndex</kbd> datatypes to the <kbd>Datetime</kbd>/<kbd>Timestamp</kbd> and <kbd>DatetimeIndex</kbd> datatypes through the <kbd>to_period</kbd> and <kbd>to_timestamp</kbd> functions, as follows:</p>
<pre>    In [339]: worldCupFinal=pd.to_datetime('07/13/2014', 
                                           errors='raise')
             worldCupFinal
       Out[339]: Timestamp('2014-07-13 00:00:00')
    
    In [340]: worldCupFinal.to_period('D')
       Out[340]: Period('2014-07-13', 'D')
    
    In [342]: worldCupKickoff=pd.Period('06/12/2014','D')
             worldCupKickoff
    Out[342]: Period('2014-06-12', 'D')
    In [345]: worldCupKickoff.to_timestamp()
    Out[345]: Timestamp('2014-06-12 00:00:00', tz=None)
    
    In [346]: worldCupDays=pd.date_range('06/12/2014',periods=32,   
                                          freq='D')
             worldCupDays
    Out[346]: &lt;class 'pandas.tseries.index.DatetimeIndex'&gt;
        [2014-06-12, ..., 2014-07-13]
        Length: 32, Freq: D, Timezone: None
    
    In [347]: worldCupDays.to_period()
    Out[347]: &lt;class 'pandas.tseries.period.PeriodIndex'&gt;
        freq: D
        [2014-06-12, ..., 2014-07-13]
        length: 32
  </pre>
<p>In the preceding examples, note how periods are converted into timestamps and vice versa.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A summary of time series-related objects</h1>
                </header>
            
            <article>
                
<p>There are many time series-related objects in pandas that are used for manipulating, creating, and processing timestamp data. The following table gives a summary of time series-related objects:</p>
<table style="border-collapse: collapse" class="table" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Object</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Summary</strong></p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>datetime.datetime</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>This is a standard Python <kbd>datetime</kbd> class.</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>Timestamp</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>This is a <kbd>pandas</kbd> class derived from. <kbd>datetime.datetime</kbd>.</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>DatetimeIndex</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>This is a <kbd>pandas</kbd> class and is implemented as an immutable <kbd>numpy.ndarray</kbd> of the <kbd>Timestamp</kbd>/<kbd>datetime</kbd> object type.</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>Period</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>This is a <kbd>pandas</kbd> class representing a time period.</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>PeriodIndex</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>This is a <kbd>pandas</kbd> class and is implemented as an immutable <kbd>numpy.ndarray</kbd> of the <kbd>Period</kbd> object type.</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>DateOffset</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>DataOffset</kbd> is used to move forward a date by a given number of valid dates (days, weeks, months, and so on).</p>
</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>timedelta</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>Timedelta</kbd> calculates the difference in time between two dates.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interconversions between strings and timestamps</h1>
                </header>
            
            <article>
                
<p>Consider the following <kbd>DataFrame</kbd> with a column containing strings representing dates and a column containing numeric values:</p>
<pre>ts_df = pd.DataFrame({"ts_col": ["2013-01-01", "2015-02-10", "2016-10-24"], "value": [5, 6, 9]})
ts_df</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bdd565b-0582-4426-9c33-008102116533.png" style="width:10.25em;height:7.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Creating a DataFrame with a date column</div>
<p>The datatype of the time series column can be seen to be an object and not a timestamp. The following code and its output confirms that:</p>
<pre>ts_df.dtypes</pre>
<p> The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6604fc4c-1dfc-4498-9edb-545c717c878c.png" style="width:12.83em;height:5.92em;"/></p>
<p>The <kbd>to_datetime</kbd> function helps in converting the string to <kbd>datetime</kbd>:</p>
<pre class="mce-root">                    ts_df["ts_col"] = pd.to_datetime(ts_df["ts_col"], format = "%Y-%m-%d")
    ts_df.dtypes</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/766f3bd6-abc8-48b6-a585-e4bbb61eb554.png" style="width:14.67em;height:4.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Converting the string format date column to a datetime format</div>
<p>The pandas <kbd>to_datetime</kbd> function converts a column of strings into <kbd>datetime</kbd>, given the format of the string. The <kbd>infer_datetime_format</kbd> argument of this function automatically detects the format and parses the string into <kbd>datetime</kbd>. The <kbd>exact</kbd> argument, when set to <kbd>False</kbd>, looks for the closest matching format and helps to overcome cases where there is not an exact match to the specified format.</p>
<p>The conversion shown can also be done using the <kbd>strptime</kbd> function from the <kbd>datetime</kbd> library:</p>
<pre>import datetime as dt
ts_df["ts_col"] = ts_df["ts_col"].apply(lambda x:<br/>dt.datetime.strptime(x,'%Y-%m-%d'))</pre>
<p class="mce-root"/>
<p>The conversion from <kbd>datetime</kbd> to a string is aided by the <kbd>strftime</kbd> function, which accepts the format for the resulting string:</p>
<pre>ts_df["ts_col"] = ts_df["ts_col"].dt.strftime("%d/%m/%Y")
ts_df  </pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e3983b78-e499-4916-ace1-8fd56f743eec.png" style="width:11.08em;height:8.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Converting the datetime format date column to a string format</div>
<p>Here, the original <kbd>datetime</kbd> value was in the <kbd>%Y-%m-%d</kbd> format. However, the <kbd>strftime</kbd> function allowed a change in format.</p>
<p>Interconversion between the string and <kbd>datetime</kbd> can also be achieved through the <kbd>astype()</kbd> method, as follows:</p>
<pre class="mce-root">ts_df["ts_col"] = ts_df["ts_col"].astype("datetime64[ns]")
ts_df["ts_col"] = ts_df["ts_col"].astype("object")  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data-processing techniques for time series data</h1>
                </header>
            
            <article>
                
<p>This section deals with common data manipulation or feature engineering techniques used with time series data before applying machine learning techniques.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data transformation</h1>
                </header>
            
            <article>
                
<p>Consider the following pieces of a single dataset:</p>
<pre> ts_complete_df = pd.read_csv("sensor_df.csv")</pre>
<p> </p>
<p>The following screenshot shows the head of sensor data that contains the time series components of unequal length:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fee3fe00-8e18-4b45-9b88-c9063e610620.png" style="width:31.50em;height:12.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Head of sensor data containing time series components of unequal length</div>
<p>The following screenshot shows the tail of sensor data that contains the time series components of unequal length:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2fc2a5d7-ada6-4945-bb5e-93b52c307a6b.png" style="width:30.50em;height:11.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Tail of sensor data containing time series components of unequal length</div>
<p>The dataset here consists of time series data in 10-minute intervals for 314 different devices. All these 314 devices have data captured for different durations. Let's examine the duration for which data has been captured in each device:</p>
<pre>ts_complete_df.groupby("ID").size().describe()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/505b227b-c76c-463d-b5de-2e9a7dd85ae7.png" style="width:11.50em;height:10.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Summary of sensor data</div>
<p>The lengths of data for each device vary drastically. Several time series problems such as Shapelet transformation and <strong>Long-Short Term Memory</strong> (<strong>LSTM</strong>) require the length of data for each device to be the same. The following code snippet truncates each device to the highest possible length:</p>
<pre class="mce-root">truncate_df = pd.DataFrame()
min_len = ts_complete_df.groupby("ID").size().min()
for i in range(1,315):
df = ts_complete_df[ts_complete_df["ID"] == i].iloc[0:min_len, :]
truncate_df = truncate_df.append(df)  </pre>
<p>After truncating, the length can be seen to be uniform. It can be checked by running the following:</p>
<pre>truncate_df.groupby("ID").size().describe()  </pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1655 image-border" src="assets/4cf564c0-479f-4a63-a45b-070775bdf62a.png" style="width:6.92em;height:8.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Summary of sensor data after all the time series components have been made  equal in length</div>
<p>Let's perform feature extraction for the following univariate time series data:</p>
<pre> ts = pd.read_csv("D:datatest.txt").iloc[:,0:2].set_index("date") ts</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1656 image-border" src="assets/5fc244c0-36bd-42a8-8245-d940e8f00af7.png" style="width:17.92em;height:17.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Reading the occupancy data and setting the datetime column as an index</div>
<p>Feature extraction is vital for performing machine learning with time series data in order to obtain better performance metrics. Here, let's extract the rolling mean, rolling standard deviation, and gradient for the temperature data:</p>
<pre>    feat_ext = pd.concat([ts.rolling(5).mean(), ts.rolling(5).std(), (ts - ts.shift(-5))/ts], axis=1).iloc[5:,:]
    feat_ext.columns = ['5_day_mean', '5_day_std', '5_day_gradient']
    feat_ext.head(5)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1657 image-border" src="assets/6016b1a5-e00f-4334-a740-2df6ad4bfe4f.png" style="width:24.25em;height:12.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Feature (5_day_mean, 5_day_std) generation using rolling functions</div>
<p>The first 5 rows with <kbd>NA</kbd> values have been dropped in the feature extraction process. Here, the features have been extracted for a rolling window of 5 days. Using a similar method, it is possible to extract hundreds of features from a time series variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Plotting using matplotlib</h1>
                </header>
            
            <article>
                
<p>This section provides a brief introduction to plotting in <kbd>pandas</kbd> using <kbd>matplotlib</kbd>. The <kbd>matplotlib</kbd> API is imported using the standard convention, as shown in the following command:</p>
<pre>In [1]: import matplotlib.pyplot as plt </pre>
<p><kbd>Series</kbd> and <kbd>DataFrame</kbd> have a plot method, which is simply a wrapper around <kbd>plt.plot</kbd>. Here, we will examine how we can do a simple plot of a sine and cosine function. Suppose we wished to plot the following functions over the interval pi to pi:</p>
<ul>
<li>f(x) = cos(x) + sin (x)</li>
<li>g(x) = cos (x) - sin (x)</li>
</ul>
<p>This gives the following interval:</p>
<pre>    In [51]: import numpy as np
    In [52]: X = np.linspace(-np.pi, np.pi, 256,endpoint=True)
    
    In [54]: f,g = np.cos(X)+np.sin(X), np.sin(X)-np.cos(X)
    In [61]: f_ser=pd.Series(f)
             g_ser=pd.Series(g)
    
    
    In [31]: plotDF=pd.concat([f_ser,g_ser],axis=1)
             plotDF.index=X
             plotDF.columns=['sin(x)+cos(x)','sin(x)-cos(x)']
             plotDF.head()
    Out[31]:  sin(x)+cos(x)  sin(x)-cos(x)
    -3.141593  -1.000000   1.000000
    -3.116953  -1.024334   0.975059
    -3.092313  -1.048046   0.949526
    -3.067673  -1.071122   0.923417
    -3.043033  -1.093547   0.896747
    5 rows × 2 columns</pre>
<p>We can now plot the DataFrame using the <kbd>plot()</kbd> command and the <kbd>plt.show()</kbd> command to display it:</p>
<pre>    In [94]: plotDF.plot()
             plt.show()
    
    We can apply a title to the plot as follows:
    In [95]: plotDF.columns=['f(x)','g(x)']
             plotDF.plot(title='Plot of f(x)=sin(x)+cos(x), \n         g(x)=sinx(x)-cos(x)')
             plt.show()</pre>
<p>The following is the output of the preceding command:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1658 image-border" src="assets/d0e5ea2c-63ff-427d-b75d-6284324de2ed.png" style="width:32.00em;height:26.83em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"> Plotting time series data using matplotlib</div>
<p>We can also plot the two series (functions) separately in different subplots, using the following command:</p>
<pre>In [96]: plotDF.plot(subplots=True, figsize=(6,6))
           plt.show()</pre>
<p class="mce-root"/>
<p>The following is the output of the preceding command:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1659 image-border" src="assets/6c66a11d-0623-4c75-966d-87f52a41c6f4.png" style="width:28.17em;height:27.67em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Plotting some more time series data using matplotlib</div>
<p>There is a lot more to using the plotting functionality of <kbd>matplotlib</kbd> within pandas. For more information, take a look at the documentation at <span class="URLPACKT"><a href="http://pandas.pydata.org/pandas-docs/dev/visualization.html">http://pandas.pydata.org/pandas-docs/dev/visualization.html</a></span>.</p>
<p class="mce-root"/>
<p>It is often quite useful to visualize all the variables of a multivariate time series data. Let's plot all the variables of the following data in a single plot. Note that the <kbd>date</kbd> column is the index here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/835188e4-e7f5-4bdd-bc95-0a2bcc444ec5.png" style="width:40.83em;height:16.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Occupancy dataset</div>
<p>The subplot feature in matplotlib lets us plot all of the variables at once:</p>
<pre>    axes = plot_ts.plot(figsize=(20,10), title='Timeseries Plot', subplots=True, layout=(plot_ts.shape[1],1), xticks = plot_ts.index)
    # Get current axis from plot
    ax = plt.gca()
    import matplotlib.dates as mdates
    # Set frequency of xticks
    ax.xaxis.set_major_locator(mdates.DayLocator(interval = 1))
    # Format dates in xticks 
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
    plt.show()</pre>
<p class="mce-root"/>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea11a97f-7055-4c48-a0f6-3a2a02556819.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Time series plot for all the variables in the occupancy dataset</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed time series data and the steps you can take to process and manipulate it. A <kbd>date</kbd> column can be assigned as an index for <kbd>Series</kbd> or <kbd>DataFrame</kbd> and can then be used for subsetting them based on the index column. Time series data can be resampled—to either increase or decrease the frequency of the time series. For example, data generated every millisecond can be resampled to capture the data only every second or can be averaged for 1,000 milliseconds for each second. Similarly, data generated <span>every</span> minute can be resampled to have data every second by backfilling or forward filling (filling in the same value as the last or next minute value for all the seconds in that minute).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>String to datetime conversion can be done via the <kbd>datetime</kbd>, <kbd>strptime</kbd>, and <kbd>strftime</kbd> packages , and each type of date entry (for example, 22<sup>nd</sup> July, 7/22/2019, and so on) needs to be decoded differently based on a convention. pandas has the following types of time series objects—<kbd>datetime.datetime</kbd>, <kbd>Timestamp</kbd>, <kbd>DateIndex</kbd>, <kbd>Period</kbd>, <kbd>PeriodIndex</kbd>, <kbd>timedelta</kbd>, and so on. Certain algorithms for time series classification such as shapelets and LSTM require time series components (one separable data entity containing multiple entries of time series data) to be of the same length. This can be done either by truncating all the components to the smallest length or expanding them to the longest length and imputing with zeros or some other value. Matplotlib can be used to plot basic time series data. Shifting, lagging, and rolling functions are used to calculate moving averages, detecting behavioral change at time series component change points.</p>
<p>In the next chapter, we will learn how to use the power of pandas in Jupyter Notebooks to make powerful and interactive reports.</p>


            </article>

            
        </section>
    </body></html>