<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Interacting with the Operating System
                </header>
            
            <article>
                
<p class="mce-root">This section is an add-on to the introduction to Python. It puts Python into the context of the operating system on your computer and shows how Python is used in a command window, also called a console. We demonstrate how system commands and a Python command interact with each other and how you make a new application.</p>
<p>Among many other operating systems and various <em>dialects</em>, there are three main operating systems in use on desktop computers and notebooks: Windows 10, macOS, and Linux. In this chapter, we discuss how to use Python within the Linux world. All examples are tested in the widely distributed Ubuntu environment. The principles presented here apply also to the other big operating systems. The presentation is nevertheless restricted to Linux as a completely freely accessible environment.</p>
<p>First, we assume we have written and tested a Python program and want to run it now from a console window directly instead of from a Python shell such as IPython.</p>
<p>In this chapter, we cover the following topics:</p>
<ul>
<li class="mce-root">Running a Python program in a Linux shell</li>
<li>The module <kbd>sys</kbd></li>
<li>How to execute Linux commands from Python</li>
</ul>
<h1 id="uuid-2aec8091-8771-4c34-bb80-81ad6c8148b7">17.1 Running a Python program in a <span><span>Linux</span></span> shell</h1>
<p>When you open a terminal window with the terminal app, you obtain a window with a command prompt; see <em>Figure 17.1</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9fe516c1-353a-4ac3-834d-099f2709f28d.png" style="width:31.50em;height:16.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 17.1: A terminal window in Ubuntu 20.04</div>
<p>The terminal windows come with a command prompt, often prefixed by the username and the computer's name followed by the directory name. This depends on the individual settings.</p>
<p>To execute the Python commands written in a file named <kbd>myprogram.py</kbd>, you have two choices:</p>
<ul>
<li>Executing the command <kbd>python myprogram.py</kbd></li>
<li>Executing the command <kbd>myprogram.py</kbd> directly</li>
</ul>
<p>The second variant needs some preparation. First, you have to give permission to execute that file, and secondly, you have to tell the system which command is needed to execute that file. The permission to execute that file is given by the command:</p>
<pre class="mce-root">chmod myprogram.py o+x</pre>
<p><kbd>chmod</kbd> stands for changing the file mode. The command is followed by the filename and finally the desired new modes, here <kbd>o+x</kbd>.</p>
<p>The modes that are given in that example stand for "give (<kbd>+</kbd>) the owner (<kbd>o</kbd>) rights to execute (<kbd>x</kbd>) that file." We suppose that you are the owner of the file and that it is in the current directory.</p>
<p>Then, we have to find the location of the command <kbd>python</kbd> on our computer. This is done by running the command:</p>
<pre>which python</pre>
<p> </p>
<p>If you installed Python via Anaconda as described in <a href="cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml">Section 1.1</a>: <em>Installation and configuration instructions</em>, you will get information about the location of the command <kbd>python</kbd> on your system, for example, <kbd>/home/claus/anaconda3/bin/python</kbd>.</p>
<p>This information has to be written in the first line of a Python script to tell the system by which program the text file can be transformed into an executable. Here is an example:</p>
<pre>#! /home/claus/anaconda3/bin/python<br/>a=3<br/>b=4<br/>c=a+b<br/>print(f'Summing up {a} and {b} gives {c}')</pre>
<p>The first line in Python's view is just a comment and ignored. But Linux takes the rest of the first line after the so-called <em>shebang</em> combination, <kbd>#!</kbd>, as the command needed to transform the file into an executable. Here, it learns to use the command <kbd>python</kbd> located in the directory <kbd>/home/claus/anaconda3/bin/</kbd> for that purpose.</p>
<p>Instead of defining the location of the Python interpreter by an absolute path, we can define it also by a logical path, which would make the code more portable. You can give it to a colleague on a Linux system without any modification:</p>
<pre>#! /usr/bin/env  python   # a logical path to Python (mind the blank)</pre>
<p> </p>
<p>Now you can execute the example code in the console directly; see <em>Figure 17.2</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3f3e3e9d-b6e2-48b8-bd74-e9e4387fe99f.png" style="width:15.58em;height:2.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 17.2: Executing the example file example.py in a Linux terminal</div>
<p>We have to prefix the command with <kbd>./</kbd>, which tells the operating system that it should look in the current directory to find that command. If this prefix is not present, Linux expects the file <kbd>example.py</kbd> in one of the directories listed in the search path.</p>
<p>In the next section, we will show how to provide a Python program with arguments given directly from the command line.</p>
<h1 id="uuid-edff599b-0188-47a5-9ab6-6eb8186985c9">17.2 The module sys</h1>
<p>The module <kbd>sys</kbd> provides tools to communicate from a Python script with system commands. We can provide the Python script as a command directly from the command line with arguments and we can output the results to the console.</p>
<h2 id="uuid-c8c39622-51ba-4a02-affb-28251120b8e9">17.2.1 Command-line arguments</h2>
<p>To illustrate the use of command-line arguments, we consider the following piece of code, which we save in a file called <kbd>demo_cli.py</kbd>:</p>
<pre>#! /usr/bin/env  python <br/>import sys<br/>text=f"""<br/>You called the program{sys.argv[0]}<br/>with the {len(sys.argv)-1} arguments, namely {sys.argv[1:]}"""<br/>print(text)</pre>
<p>After giving execution permissions to the file by <kbd>chmod o+x demo_cli.py</kbd>, we can execute it in the shell with arguments; see <em>Figure 17.3</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/31c103d2-92cc-40dc-9de2-7f30adc91fe0.png" style="width:23.50em;height:7.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 17.3: Executing a Python script with three arguments on a terminal command line</div>
<p>The three arguments given in the console are accessible in the Python script via the list <kbd>sys.argv</kbd>. The first element in this list—the element with index <kbd>0</kbd>—is the name of the script. The other elements are the given arguments as strings.</p>
<p>Arguments are given to the call of the Python script. They should not be confounded with user input during the execution of a script. </p>
<h2 id="uuid-f7abfa77-bd3c-426d-800a-842350875ea5">17.2.2 Input and output streams</h2>
<p>In the preceding example, we used the command <kbd>print</kbd> to display the generated message in the terminal (or even in the Python shell). A priory input to the script is obtained via arguments and the variable <kbd>sys.argv</kbd>. The counterpart to <kbd>print</kbd> is the command <kbd>input</kbd>, which prompts for data from the terminal (or from the Python shell).</p>
<p>In <a href="f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml">Section 14.1</a>: <em>File handling</em>, we saw how to provide a script with data and how to output data from a script by the use of file objects and related methods. The module <kbd>sys</kbd> makes it possible to treat the keyboard as a file object for input (for example, <kbd>readline</kbd>, <kbd>readlines</kbd>) and the console as a file object for output (for example, <kbd>write</kbd>, <kbd>writelines</kbd>).</p>
<p>The information flow is organized in UNIX by three streams:</p>
<ul>
<li><span>The standard input stream: </span><kbd>STDIN</kbd><span>  </span></li>
<li><span>The standard output stream: </span><kbd>STDOUT</kbd></li>
<li><span>The standard error stream: </span><kbd>STDERR</kbd></li>
</ul>
<p><span>These streams correspond to file objects that can be accessed in Python by </span><kbd>sys.stdin</kbd>, <kbd>sys.stdout</kbd>, and <kbd>sys.stderr</kbd>.</p>
<p>To have an example, we consider a little script, <kbd>pyinput.py</kbd>, which sums up some numbers:</p>
<pre>#!/usr/bin/env python3<br/>from numpy import *<br/>import sys<br/><br/># Terminate input by CTRL+D<br/>a=array(sys.stdin.readlines()).astype(float)<br/>print(f'Input: {a}, Sum {sum(a)}'</pre>
<p>The statement <kbd>sys.stdin.readlines()</kbd> establishes a generator. The command <kbd>array</kbd> iterates this generator until the user inputs an end-of-input symbol, which is <kbd>CTRL-D</kbd> on Linux systems or <kbd>CTRL-Z</kbd> on Windows systems. See the screenshot in <em>Figure 17.4</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2912df2b-e88e-4910-84d6-349e3d736b04.png" style="width:20.50em;height:9.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 17.4: Screenshot of the terminal execution of a script using sys.stdin.<br/>
Note, the given end-of-input symbol CTRL-D is not visible</div>
<h3 id="uuid-7574de56-f3a4-4b44-9e48-f4e794386da3">Redirecting streams</h3>
<p>The standard input is expecting a data stream from the keyboard. But the input can be redirected from a file instead. This is done by using the redirection symbol <kbd>&lt;</kbd> in Linux. We demonstrate this by using the same script as previously, but now a data file, <kbd>intest.txt</kbd>, provides the script with data; see <em>Figure 17.5</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/52af1605-6205-48c6-83b6-7a35b7ff0861.png" style="width:27.75em;height:3.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 17.5: Screenshot to demonstrate the redirection of input (sys.stdin)</div>
<p>No modification in the script itself is required. It can be used in either way.</p>
<p>The same holds for outputs. By default the output is displayed in the terminal, but also here there is the option to redirect the output to a file. In that case, the redirect symbol is <kbd>&gt;</kbd>; see <em>Figure 17.6</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/088761b9-9929-4da9-a8e6-5a48d3981eaa.png" style="width:31.08em;height:1.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 17.6: Screenshot of a redirected input and redirected output</div>
<p>Now, a file with the name <kbd>result.txt</kbd> is created and the output of the script is written to it. If there was already a file with this name, its content is overwritten. If instead the output should be appended to an already-existing file, the redirection symbol <kbd>&gt;&gt;</kbd> has to be used.</p>
<p>Finally, it might sometimes <span>be</span><span> </span><span>desired to separate the output from an error or warning message. That is the reason why Linux provides two stream channels for output,</span> <kbd>sys.stdout</kbd> <span>and</span> <kbd>sys.stderr</kbd><span>. By default, both refer to the same place, the terminal. But with the use of redirection symbols, error messages can, for example, be written into a file while the main output is displayed on the screen or vice versa.</span></p>
<p>To demonstrate this, we modify the example <kbd>pyinput.py</kbd> to generate an error message in case no input was provided:</p>
<pre>#!/usr/bin/env python3<br/>from numpy import *<br/>import sys<br/><br/># Terminate input by CTRL+D<br/>a=array(sys.stdin.readlines()).astype(float)<br/>print(f'Input: {a}, Sum {sum(a)}')<br/>if a.size == 0:<br/>    sys.stderr.write('No input given\n')</pre>
<p>A typical call of this script in a terminal window with redirected input and error output is presented in <em>Figure 17.7</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5b7acb2-75d1-4fee-a747-a8b659caad9d.png" style="width:43.42em;height:4.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 17.7: Screenshot of a terminal window with redirection of stdin and stderr</div>
<p>In the case of an empty input file, an error message is written into the file <kbd>error.txt</kbd> while the output is in the terminal window.</p>
<p>Error messages are those from uncaught exceptions, even syntax errors and text explicitly written to <kbd>sys.stderr</kbd>.</p>
<p>In <em>Table 17.1</em>, the different redirection situations are summarized:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p><strong>Task</strong></p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><strong>Python Object</strong></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p><strong>Redirect Symbol</strong></p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign">
<p><strong>Alt. Symbol</strong></p>
</td>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>Data input</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stdin</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p> &lt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign"/>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>Data output</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stdout</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p>&gt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign">
<p>1&gt;</p>
</td>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>Data output append to file</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stdout</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p>&gt;&gt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign">
<p>1&gt;&gt;</p>
</td>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>Error output</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stderr</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p>2&gt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign"/>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>Error output append to file</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stderr</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p>2&gt;&gt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign"/>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>All output</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stdout</kbd>, <kbd>sys.stderr</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p>&amp;&gt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign"/>
</tr>
<tr>
<td style="width: 274.333px" class="CDPAlignCenter CDPAlign">
<p>All output append to file</p>
</td>
<td style="width: 274.433px" class="CDPAlignCenter CDPAlign">
<p><kbd>sys.stdout</kbd>, <kbd>sys.stderr</kbd></p>
</td>
<td style="width: 185.683px" class="CDPAlignCenter CDPAlign">
<p>&amp;&gt;&gt;</p>
</td>
<td style="width: 118.4px" class="CDPAlignCenter CDPAlign">
<p class="mce-root"/>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 17.1: Summary of different redirection scenarios</div>
<h3 id="uuid-bdcb9847-f96a-40c8-a6c2-0aae625e1f98">Building a pipe between a Linux command and a Python script</h3>
<p>In the last section, we saw how to redirect the input and output of Python programs to files. The data flow between different Python programs or between a Python program and a Linux command goes, in that case, via a file. If the data is not used elsewhere or should be saved for later use, this is a tedious process: creating, naming, and deleting a file just for directly passing information from one piece of code to another. The alternative is to use a Linux <strong>pipe</strong> that lets the data flow in a direct stream from one command to another.</p>
<p>Let's start with a pure Linux example and then apply the pipe construction to Python.</p>
<p>The Linux command <kbd>ifconfig</kbd> displays a lot of information about the actual network configuration of a Linux computer. Among this information, you find the IP number(s), which are the current network addresses in use. To automatically find out whether a computer, for example, a notebook, is connected via a certain network unit to the home network instead of to a foreign network, you would like to scan the output of <kbd>ifconfig</kbd> for a line containing the identifier for the network card, for example, <kbd>wlp0s20f3</kbd>, and some lines below for a string with the network prefix, for example, <kbd>192.168</kbd>. If this string is found, the output should be just the line with this string; that is, a line count would return <kbd>1</kbd>. If the computer is not connected to the home network, the line count returns <kbd>0</kbd>.</p>
<p>We use three commands:</p>
<ul>
<li><kbd>ifconfig</kbd> for the entire lengthy network information.</li>
<li><kbd>grep</kbd> for finding lines containing a certain pattern. The line and, if required by the parameter <kbd>-A</kbd>, some following lines are displayed.</li>
<li><kbd>wc</kbd> for doing various countings on a file. The argument <kbd>-l</kbd> specifies that lines should be counted.</li>
</ul>
<p>The output of these commands is directly piped into the next command. This is done by using the pipe symbol <kbd>|</kbd>:</p>
<pre class="mce-root">ifconfig|grep -A1 wlp0s20f3 | grep 192.168|wc -l</pre>
<p class="mce-root">This command line displays just <kbd>1</kbd> on the screen when executed in the home network. All the intermediate output is passed directly to the next command without displaying anything and without the use of any files to park temporarily the information until the next command reads it. The standard output, <kbd>stdout</kbd>, of one command becomes the standard input, <kbd>stdin</kbd>, of the next.</p>
<p>This <span>also</span><span> </span><span>applies directly to Python scripts.</span></p>
<p>We continue the previous example by demonstrating a Python script in the pipe. Here we simply use Python to generate a nice message:</p>
<pre>#!/usr/bin/env python3<br/><br/>import sys<br/><br/>count = sys.stdin.readline()[0]<br/>status = '' if count == '1' else 'not'<br/><br/>print(f"I am {status} at home")</pre>
<p>Now, we can extend the pipe by adding this script; see the screenshot in <em>Figure 17.8</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc1a59e2-9485-4ef0-802a-70c614b04370.png" style="width:48.25em;height:3.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 17.8: A command chain with five pipes and a Python script</div>
<p>In this example, we executed a chain of Linux programs and a Python script in the terminal window. Alternatively, it is possible to let the Python script call the UNIX commands. That will be demonstrated in the next section.</p>
<h1 id="uuid-f32795b1-f33c-4308-8747-1981bea05927">17.3 How to execute Linux commands from Python</h1>
<p>We saw in the last section how to execute a Python command from the Linux terminal. In this section, we consider the important case of how to execute Linux commands within a Python program.</p>
<h2 id="uuid-4de57e0e-81eb-4369-9cc1-a0c52afc42a1">17.3.1 The modules subprocess and shlex</h2>
<p>To execute system commands within Python, we need to import the module <kbd>subprocess</kbd> first. The high-level tool provided by this module is <kbd>run</kbd>. With this tool, you quickly access Linux commands within Python and can process their output.</p>
<p>The more sophisticated tool is <kbd>Popen</kbd>, which we will shortly present when explaining how to mimic Linux pipes in Python.</p>
<h3 id="uuid-748dce1a-0836-4fc8-80ce-127b579d6ee5">A complete process: subprocess.run</h3>
<p>We demonstrate this tool with the most standard and simple UNIX command, <kbd>ls</kbd>—the command for listing the content of a directory. It comes with various optional arguments; for example, <kbd>ls -l</kbd> displays the list with extended information.</p>
<p>To execute this command within a Python script, we use <kbd>subprocess.run</kbd>. The simplest usage is using only one argument, a list with the Linux command split into several text strings:</p>
<pre>import subprocess as sp<br/>res = sp.run(['ls','-l'])</pre>
<p>The module <kbd>shlex</kbd> provides a special tool for performing this split: </p>
<pre>_import shlex<br/>command_list = shlex.split('ls -l') # returns ['ls', '-l']</pre>
<p><span>It also respects empty spaces in filenames and does not use those as separators.</span></p>
<p>The command <kbd>run</kbd> displays the result of the Linux command and the <kbd>subprocess.CompletedProcess</kbd> object <kbd>res</kbd>.</p>
<p>To execute UNIX commands in this way is quite useless. Mostly, you want to process the output. Therefore, the output has to be made available to the Python script. For this, the optional parameter <kbd>capture_output</kbd> has to be set to <kbd>True</kbd>. By this, the <kbd>stdout</kbd> and <kbd>stderr</kbd> streams of the UNIX command become available as attributes of the return object:</p>
<pre>import subprocess as sp<br/>import shlex<br/>command_list = shlex.split('ls -l') # returns ['ls', '-l']<br/>res = sp.run(command_list, capture_output=True)<br/>print(res.stdout.decode())</pre>
<p>Note, the method <kbd>decode</kbd> is used here to decode a byte string to a standard string format.</p>
<p>If the Linux command returns an error, the attribute <kbd>res.returncode</kbd> gets a nonzero value, and <kbd>res.stderr</kbd> contains the error message.</p>
<p>The Python way would be that an error is raised instead. This can be achieved by setting the optional parameter <kbd>check</kbd> to <kbd>True</kbd>:</p>
<pre>import subprocess as sp<br/>import shlex<br/>command ='ls -y'<br/>command_list = shlex.split(command) # returns ['ls', '-y'] <br/>try:<br/>    res = sp.run(command_list, capture_output=True, check=True)<br/>    print(res.stdout.decode())<br/>except sp.CalledProcessError:<br/> print(f"{command} is not a valid command")</pre>
<h3 id="uuid-4619f970-5f72-4751-a3c8-8db3cae5c9ca">Creating processes: subprocess.Popen</h3>
<p>What happens when you apply <kbd>subprocess.run</kbd> on a Linux command that starts a process that requires user input to terminate?</p>
<p>A simple example of such a program is <kbd>xclock</kbd>. It opens a new window displaying a clock until the window is closed by the user.</p>
<p>As the command <kbd>subprocess.run</kbd> creates a <kbd>CompletedProcess</kbd> object, the following Python script:</p>
<pre>import subprocess as sp<br/>res=sp.run(['xclock'])</pre>
<p>starts a process and waits until it ends, that is, until somebody closes the window with the clock; see <em>Figure 17.9</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/48e32eb1-a323-4ac4-b52e-04911dcedb91.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 17.9: The xclock window</div>
<p>This makes a difference to <kbd>subprocess.Popen</kbd>. It creates a _<kbd>Popen</kbd> object. The process itself becomes a Python object. It need not be completed to become an accessible Python object:</p>
<pre>import subprocess as sp<br/>p=sp.Popen(['xclock'])</pre>
<p class="mce-root"/>
<p>The process is completed by either a user action on the clock window or by explicitly terminating the process with:</p>
<pre>p.terminate()</pre>
<p>With <kbd>Popen</kbd>, we can construct Linux pipes in Python. The following script:</p>
<pre>import subprocess as sp_<br/>p1=sp.Popen(['ls', '-l'],stdout=sp.PIPE)<br/>cp2=sp.run(['grep','apr'], stdin=p1.stdout, capture_output=True)<br/>print(cp2.stdout.decode())</pre>
<p>Corresponds to the UNIX pipe:</p>
<pre>ls -l |grep 'apr</pre>
<p>It displays all files in a directory last accessed in April.</p>
<p>The module <kbd>subprocess</kbd> has an object <kbd>PIPE</kbd> that takes the output of the first process <kbd>p1</kbd>. It is then passed as <kbd>stdin</kbd> to the command <kbd>run</kbd>. This command then returns a <kbd>CompletedProcess</kbd> object <kbd>cp2</kbd> with the attribute <kbd>stdout</kbd> of type <kbd>bytes</kbd>. Finally, calling the <span>method</span><span> </span><kbd>decode</kbd><span> allows a nice print of the results.</span></p>
<p>Alternatively, the same could be achieved by using two <kbd>Popen</kbd> processes. The second <span>also</span><span> </span><span>uses a pipe that can be displayed through the</span><span> </span><span>method </span><kbd>communicate</kbd><span>:</span></p>
<pre>import subprocess as sp<br/>p1=sp.Popen(['ls', '-l'],stdout=sp.PIPE)<br/>p2=sp.Popen(['grep','apr'], stdin=p1.stdout, stdout=sp.PIPE)<br/>print(p2.communicate()[0].decode)</pre>
<p>The method <kbd>communicate</kbd> returns a tuple with the output on <kbd>stdout</kbd> and <kbd>stderr</kbd>.</p>
<h1 id="uuid-6e52ece1-9c97-47e0-a69e-ce76920ad23a">17.4 Summary</h1>
<p>In this chapter, we demonstrated the interaction of a Python script with system commands. Either a Python script can be called in a way as if it would be a system command or a Python script can itself create system processes. The chapter is based on Linux systems such as Ubuntu and serves only as a demonstration of concepts and possibilities. It allows putting scientific computing tasks in an application context, where often different software have to be combined. Even hardware components might come into play. </p>


            </article>

            
        </section>
    </body></html>