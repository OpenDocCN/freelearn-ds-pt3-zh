- en: Special Data Operations in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pandas has an array of special operators for generating, aggregating, transforming,
    reading, and writing data from and to a variety of data types, such as number,
    string, date, timestamp, and time series. The basic operators in pandas were introduced
    in the previous chapter. In this chapter, we will continue that discussion and
    elaborate on the methods, syntax, and usage of some of these operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading this chapter will allow you to perform the following tasks with confidence:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom functions and applying them on a column or an entire DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the nature of missing values and handling them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming and performing calculations on series using functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous numeric operations on data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's delve into it right away. For the most part, we will generate our own
    data to demonstrate the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and applying one-liner custom functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling missing values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A survey of methods on series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas string methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary operations on DataFrames and series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binning values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mathematical methods on DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and applying one-liner custom functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides lambda functions, which are a way to write one-liner custom
    functions so that we can perform certain tasks on a DataFrame's column(s) or the
    entire DataFrame. Lambda functions are similar to the traditional functions that
    are defined using the `def` keyword but are more elegant, are more amenable to
    apply on DataFrame columns, and have lucid and crisp syntax, much like a list
    comprehension for implementing for loops on lists. Let's look at how lambda functions
    are defined and applied.
  prefs: []
  type: TYPE_NORMAL
- en: lambda and apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to see how the `lambda` keyword can be used, we need to create some
    data. We'll create data containing date columns. Handling date columns is a topic
    in itself, but we'll get a brief glimpse of this process here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are creating two date columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start Date**: A sequence of 300 consecutive days starting from 2016-01-15'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End Date**: A sequence of 300 days taken randomly from any day between 2010
    and 2025'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some date/time methods have been used to create these dates in the following
    code block. Please take note of them and ensure that you understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output DataFrame has two columns, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68717efc-f9b8-48fd-ad2f-4b567e9d8b07.png)'
  prefs: []
  type: TYPE_IMG
- en: Output DataFrame with **Start Date** and **End** **Date**
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this data, we will create some lambda functions to find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of days between today and start date or end date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of days between the start date and end date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days in the start date or end date that come before a given date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code block, we have written the lambda functions carry out
    these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note how `x` and `y` have been used as placeholder arguments, that is, the parameters
    of the functions. While applying these functions to a column of data, these placeholders
    are replaced with the column name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda just helps to define a function. We need to call these functions with
    the actual arguments to execute these functions. Let''s see how this is done.
    For example, to execute the functions we defined previously, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99793a3c-26f8-4d1a-a585-27f467c880d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Output DataFrame with calculated fields on the date columns
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that these functions can be called like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Like simple functions**: With a function name and required argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**With the apply method**: The DataFrame column name for this to be applied
    on, followed by `apply`, which takes a function name as an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of `apply`, in this case, `map` would also work. Try the following
    and compare the results of `diff1` and `diff3`. They should be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three related methods that perform similar kinds of work with subtle
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **What does it do?** |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | Applies a function over a column or a list of columns. |'
  prefs: []
  type: TYPE_TB
- en: '| `apply` | Applies a function over a column, row, or a list of columns or
    rows. |'
  prefs: []
  type: TYPE_TB
- en: '| `applymap` | Applies a function over the entire DataFrame, that is, each
    cell. Will work if the function is executable on each column. |'
  prefs: []
  type: TYPE_TB
- en: Some use cases where these methods are very useful are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose each row in a dataset represents daily sales of an SKU for a retail
    company for a year. Each column represents an SKU. We''ll call this data `sku_sales`.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the annual sales of each SKU, we will use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the daily sales across each SKU for each day, we will use the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the mean daily sales for `SKU1` and `SKU2`, we will use the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the mean and standard deviation of daily sales for all SKUs, we will
    use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will be able to write and apply one-liner custom Lambda functions.
    Now, we'll look into how missing values can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Handling missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Missing values and NANs are commonplace occurrences in a dataset and need to
    be taken care of before data can be put to any use. We will look into various
    sources of missing values and the different types, as well as how to handle them
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sources of missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A missing value can enter a dataset because of or during the following processes.
  prefs: []
  type: TYPE_NORMAL
- en: Data extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This entails the data that''s available but we missed during its extraction
    from a source. It deals with engineering tasks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scraping from a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying from a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting from flat files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There can be many sources of missing values, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions resulting in the wrong or non-unique results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrong query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A different data type storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incomplete download
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incomplete processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This entails the data points that are not available or are difficult to collect.
    Suppose you are surveying 100,000 people for the type of electric car they own.
    In this case, if we encounter someone who doesn't own an electric car, we would
    have a missing value for that person's car type.
  prefs: []
  type: TYPE_NORMAL
- en: Missing values originating because of data extraction, in theory, can be rectified
    if we are able to identify the issue that led to the missing value and rerun the
    extraction process. Missing values originating from data collection issues are
    difficult to rectify.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you know your data has missing values? The easiest way to find this
    out is to run a summary of the dataset, which gives a count of rows as well. Since
    the rows containing missing values don''t get counted, this count will be lower
    for columns containing a missing value. Take a look at the following diagram,
    which shows a summary of the famous `titanic` dataset, for an illustration of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00decef1-d9b5-4618-b122-43a23572fc8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Data summary table showing the differences in the count of columns, indicating
    missing values
  prefs: []
  type: TYPE_NORMAL
- en: The **age** and **body** columns have missing values as they have fewer rows
    than the others.
  prefs: []
  type: TYPE_NORMAL
- en: It is of prime importance to take care of missing values because they propagate
    the missing values to the results of numeric operations and can lead to incorrect
    interpretations of data. They don't allow many numeric computations to run. They
    may also lead to an incorrect hypothesis if only a sample of the data gets used.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways in which the origin of missing values can be classified.
    Let's go over them now.
  prefs: []
  type: TYPE_NORMAL
- en: Data missing at random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, there is no particular reason why the data may be missing. Taking the
    previous example of electric cars, a missing car type is the case of data missing
    at random.
  prefs: []
  type: TYPE_NORMAL
- en: Data not missing at random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, there may be a particular reason why data may be missing. Continuing
    with the same example, suppose among the people who have cars, we have some license
    plate numbers missing in a certain pocket where they use a fancy font on their
    license plate and the OCR software is unable to decipher it properly and returns
    a missing value. This is a case of data not missing at random.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are different types of missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not a Number** (**NaN**): NaN is a placeholder for missing values for any
    data type. These can be created using `numpy.nan`. NaNs that are created using
    `numpy.nan` can be assigned to a nullable integer datatype. The missing value
    of an integer type is saved as a NaN. It is the default identifier of a missing
    value in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NA**: NA comes mostly from R, where NA is an identifier for a missing value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NaT**: This is equivalent to a NaN for timestamp data points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: This represents missing values of data types other than numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Null**: This originates when a function doesn''t return a value or if the
    value is undefined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inf**: **Inf** is **infinity**—a value that is greater than any other value.
    `inf` is, therefore, smaller than any other value. It is generated by all the
    calculations, leading to very large or very small values. Often, we need to treat
    `inf` as a missing value. This can be done by specifying the following options
    in `pandas`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A placeholder infinity variable can also be generated for comparison purposes,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous analysis of missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a sense of how mad the missing value problem is, you may want to find
    out about the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: How many cells in a column have a missing value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which cells in a column have a missing value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many columns have missing values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These tasks can be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding cells that have missing values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding the number of missing values in a column:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The third one has been left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for handling missing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are the major strategies for handling missing values.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This will delete the entire row or column that contains the missing value.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion leads to data loss and is not recommended unless there is no other
    way out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deletion can be performed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dropping all the rows where all the cells have missing values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Dropping all the rows where any of the cells have missing values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Imputation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This replaces the missing value with a number that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways in which imputation can be performed. Some of them are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imputing all the missing values in a dataset with 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Imputing all the missing values with specified text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Imputing only the missing values in the `body` column with 0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Imputing with a mean of non-missing values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Imputing with a forward fill – this works especially well for time series data.
    Here, a missing value is replaced with the value in the previous row (period):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/347e1fb1-2255-4b2b-9b33-601c5c077b8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Output DataFrame with missing values imputed with the forward fill method
  prefs: []
  type: TYPE_NORMAL
- en: 'Imputing with a backward fill – this works especially well for time series
    data. Here, a missing value is replaced with the value in the previous row (period).
    You can control the number of rows that get filled after the first NaN using `pad`
    options. `Pad=1` means only 1 row will be filled forward or backward:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c03ad3b9-4d2a-47d6-8170-f63193c5a7fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Output DataFrame with missing values imputed with the backward fill method
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interpolation is a technique that uses two endpoints at the extremes of consecutive
    missing values to create a rough mathematical relationship to fill the missing
    values. By default, it does a linear interpolation (which assumes a linear relationship
    between data points), but there are many more methods, such as polynomial, spline,
    quadratic, and Akima (which assumes a polynomial or piece-wise polynomial relationship).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `interpolate` method can be applied to a series or all the columns of a
    DataFrame directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f3d54e8-c4af-4915-8f49-f2d5f005c013.png)'
  prefs: []
  type: TYPE_IMG
- en: Output DataFrame with missing values filled using simple interpolation
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, other methods, such as `spline`, can be used, which assume a piece-wise
    polynomial relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9a24e57-a9a7-4da8-bb6b-a92e7c1bfc4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Output DataFrame with missing values filled using spline interpolation
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, polynomial interpolation can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A different column can be created for each interpolation method in the same
    DataFrame to compare their results, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d5242e9-dccb-4806-8ca4-ba91c5ece93c.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparing mean values after interpolating using different methods
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the means are slightly different for each column because separate
    interpolation methods were used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the values where interpolations were made to see how different/similar
    they are. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: KNN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**K-nearest neighbors** (**KNN**) is an unsupervised locality-based regression
    and classification method. It considers each row of data as a point in n-dimensional
    space and finds k similar (neighboring) points based on their distance (for example,
    Euclidean for numeric data and Hamming for categorical data). To find the value
    for that row and that column of data, it takes an average of all its neighboring
    rows for that column and assigns the average as a value.'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, it can be said that it defines a locality around a point and calculates
    a local average instead of a global average. This makes sense most of the time
    and is used instead of the global average because neighborhood behavior is a better
    approximator of the behavior of a sample point.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this property, KNN can be used for imputing missing values. The intuition
    is that missing value should have a value similar to its neighboring points. It
    is a local imputation method, in contrast with the `fillna` method, which is a
    global method.
  prefs: []
  type: TYPE_NORMAL
- en: '`kNeighborsClassifier` or `kNeighborsRegressor` from scikit-learn can be used
    for KNN and using the results for imputation. The following is an illustrated
    example where the following occurs, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Sample training data is generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NaNs are introduced in the same data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A KNN model is fit on the sample training data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fitted model is used to predict/impute the missing values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is represented in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can print `A` and `imputed_values` to see the difference between them or
    to assess how accurately the values were imputed. The following screenshot shows
    the actual values of column A:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bddb164e-43c2-423e-aacf-99917397f62e.png)'
  prefs: []
  type: TYPE_IMG
- en: Actual values of column A
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows `imputed_values` of column A:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c113b7b4-23c5-4733-b36c-6ae72fa8fe93.png)'
  prefs: []
  type: TYPE_IMG
- en: Imputed values of column A
  prefs: []
  type: TYPE_NORMAL
- en: A survey of methods on series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the following DataFrame to understand some methods and functions
    that can be used with a series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2408e589-827a-49b0-b191-f7018e0a3c4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample DataFrame—IMDB database
  prefs: []
  type: TYPE_NORMAL
- en: The items() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `items()` method provides a means of iteratively accessing each row in
    a series or DataFrame. It performs a lazy evaluation to store each value in a
    row, along with the index in the form of a tuple. The results of this lazy evaluation
    can be obtained through an iterative process such as a `for` loop. Let''s apply
    the `items` method on the `Wins` column of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34949d59-83f7-47eb-b1d5-d203718593c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Looping with the items method
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iteritems()` method behaves in a similar way to the `items()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3f362b59-358d-4eb6-b9ff-c4545df8d482.png)'
  prefs: []
  type: TYPE_IMG
- en: Looping with the iteritems method
  prefs: []
  type: TYPE_NORMAL
- en: 'The `items` and iteritems methods return a zip type object. We need an iterative
    process to unzip the object. Applying the `items` or `iteritems` methods on a
    DataFrame give different results. In this case, each column is stacked within
    a tuple, along with the column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d003c701-a757-48e0-aecd-43503c6b8e93.png)'
  prefs: []
  type: TYPE_IMG
- en: Items method used on a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: The keys() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When used with a series, the `keys()` method returns the row-labels or index
    of the series and serves the same function it does when accessing the index attribute
    of a DataFrame or series. The `keys()` method shows different behaviors when used
    with a DataFrame and with a series; it returns the column labels when used on
    a DataFrame and the row index when used with a series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The pop() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with lists in Python, the `pop()` method will ring a bell.
    The `pop()` method in series and DataFrames behaves exactly the same as it does
    with lists. It helps remove entire columns from DataFrames or specific rows from
    series. Upon being called, the `pop()` method returns the popped out entity (row
    or column).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates the use of `pop()` with a series. Let''s
    pop the item with row index 2 from the `"Wins"` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s print the `Wins` series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66128494-9754-452d-a267-2cbcc4b59b4d.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the `pop` method
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be seen that index 2 is no longer present in the series. The same method
    can be applied to a DataFrame as well. Let''s pop the `Nominations` column to
    understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1860777-0ae1-4fca-b74d-6c3e43359175.png)'
  prefs: []
  type: TYPE_IMG
- en: Pop applied on the DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is used to show the DataFrame result after popping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec436cc9-02d0-421a-aa6c-90decc73b3c5.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame result after popping
  prefs: []
  type: TYPE_NORMAL
- en: The apply() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `apply()` method provides us with a fast and efficient way to apply a function
    to all the values in a series. The function could be a built-in function such
    as a NumPy function or a user-defined function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `apply()` has been used to find the exponential value
    of all the rows in the `Wins` series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a110368-2a66-46b0-b139-dd97bc9e1c89.png)'
  prefs: []
  type: TYPE_IMG
- en: Apply method on series
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define your own function and apply it to a series. Let''s demonstrate
    this with a simple function to divide values by 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b499660-15aa-4ca2-bc1a-878a436a8bbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Apply for user-defined functions
  prefs: []
  type: TYPE_NORMAL
- en: The map() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `map()` method is similar to the `apply` method as it helps in making elementwise
    changes that have been defined by functions. However, in addition, the `map` function
    also accepts a series or dictionary to define these elementwise changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the map function, let''s change some of the values in the `"Wins"` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0205330f-3da8-4262-89cf-070657f823a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Map method used on a series
  prefs: []
  type: TYPE_NORMAL
- en: Values for which the mapping is not defined are replaced with NAs.
  prefs: []
  type: TYPE_NORMAL
- en: The drop() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `drop()` method is another useful method that removes entire rows or columns
    from a DataFrame or a series. Indices can be dropped along any axis – row indices
    can be dropped along axis 0 and column indices can be dropped along axis 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s drop indices 0 and 2 from the `Wins` series. The indices to be removed
    can be defined through a list. The default setting for the axis is 0, and hence
    no change is needed in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8a54d51-7aaa-484d-aaac-33d47e826477.png)'
  prefs: []
  type: TYPE_IMG
- en: Drop method used on a series
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the result does not have 0 and 2 and indexes. The following
    snippet shows the use of the `drop` method to remove columns from DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72725fd0-1417-4b06-a3b6-10fd33ed57ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the drop method on a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'Indices can also be effectively removed when there is multi-level indexing.
    The level parameter of drop helps us do this. Consider the following DataFrame
    with multi-level indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32f81cd2-5039-43cf-87a8-c92ec9a34bde.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-level indexed DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a specific movie from the `Movie` column, the `level` parameter should
    be set to 1\. By default, `level` is set to 0\. The following snippet removes
    the movie `Matrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1468418b-8e50-486c-be4d-3ffe2f0d30b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Dropping index for a hierarchical index
  prefs: []
  type: TYPE_NORMAL
- en: The equals() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `equals()` method checks whether two series or DataFrames are equal in
    terms of values, datatype, and shape. The column headers could be of different
    data types. The output is a Boolean. A practical application of this function
    is shown here. Let''s create a new series that we can compare with the existing `sample_df`
    DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function can be applied this way to compare two DataFrames or two series
    within the same DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: The sample() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sample()` method can be used for the random sampling of a DataFrame or
    series. The parameters of the `sample` function support sampling across either
    axis and also sampling with and without replacement. For sampling, either the
    number of records to be sampled or the fraction of records to be sampled must
    be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sample three records from the `Movie` series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fea04d34-f602-475d-a39e-890c0d470872.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample function for series
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s sample 50% of the columns from the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82cefaaf-9cfe-484e-b4fe-d8912594c8bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Column sampling with the fraction parameter
  prefs: []
  type: TYPE_NORMAL
- en: The replace parameter can be set to `True` or `False` so that we can sample
    with or without replacement; the default is `False`. The random state parameter
    helps in setting the seed of the random number generator and it depends on the
    `Random` module of the NumPy package.
  prefs: []
  type: TYPE_NORMAL
- en: The ravel() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ravel()` function flattens out a series into a one-dimensional array.
    It is fundamentally similar to the `numpy.ravel` function. The `ravel` function
    cannot be applied on DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The value_counts() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `value_counts()` function works only on series, and not DataFrames. It
    counts the number of times each variable occurs and provides a frequency table-like
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/759c18ec-05a9-4b26-a066-66e28e74ef3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Frequency count for categorical series
  prefs: []
  type: TYPE_NORMAL
- en: 'The `value_counts()` function can also be applied to a numeric column. It results
    in a count of each time a value occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3e40a26-c972-46de-a42d-f8c951490c7a.png)'
  prefs: []
  type: TYPE_IMG
- en: The value_counts function used on the numeric column
  prefs: []
  type: TYPE_NORMAL
- en: 'It is more useful to count the occurrence of numeric values within the range
    of bins. The `bins` parameter of `value_counts` groups data into bins before counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9842f0d0-801d-4955-84f6-b835d8541e0a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `value_counts` function with binning for the `numeric` columns
  prefs: []
  type: TYPE_NORMAL
- en: The interpolate() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `interpolate()` function provides an efficient way to handle missing data.
    Through this method, the NaNs can be replaced with a value through linear interpolation
    or polynomial interpolation, or even simple padding. This function fits the series
    to a function such as a `spline` or `quadratic` and then computes the possible
    missing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the values are all equally spaced apart, linear interpolation is the
    most suitable method here. Linear interpolation is the default value of the `method`
    parameter of the `interpolate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98d37fb5-735c-43ed-948d-df9a1ce1c368.png)'
  prefs: []
  type: TYPE_IMG
- en: Linear interpolation
  prefs: []
  type: TYPE_NORMAL
- en: 'The direction in which interpolation should take place can be specified. Let''s
    consider the preceding example and fill in the NaNs through backward padding,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9aad3f3b-5bf7-4648-a650-3397a5b7558d.png)'
  prefs: []
  type: TYPE_IMG
- en: Backward interpolation with padding
  prefs: []
  type: TYPE_NORMAL
- en: The align() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `align()` function takes two objects, reindexes both objects based on a
    `join` condition (inner, outer, and so on), and returns a tuple with both objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86de389c-c622-497e-a162-44dd849e1bde.png)'
  prefs: []
  type: TYPE_IMG
- en: Align with outer join
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the alignment was based on an outer join, the indexes that were found
    in both series are found in the output. For an inner join, only the common indexes
    are returned, such as `a`, `b`, and `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28fdb72a-bc1b-42fa-82fe-d7f57ef14414.png)'
  prefs: []
  type: TYPE_IMG
- en: Align with inner join
  prefs: []
  type: TYPE_NORMAL
- en: pandas string methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section talks about the pandas string methods. These methods are useful
    when dealing with messy text data. These methods clean the text data, structure
    it, segment it, and search important chunks of it. Let's look into these methods
    and find out what each of them contains.
  prefs: []
  type: TYPE_NORMAL
- en: upper(), lower(), capitalize(), title(), and swapcase()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'String methods such as `upper()`, `lower()`, `capitalize()`, `title()`, and
    `swapcase()` help when we wish to convert all the string elements into an entire
    series. The `upper` and `lower` methods convert the entire string into uppercase
    or lowercase. The following command shows converting a series into uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b9dabc7-2a14-4708-885f-6f00ca566f9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Converting a series into uppercase
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows converting a series into lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a6c0566-ef4d-45e6-9654-14653dc46d68.png)'
  prefs: []
  type: TYPE_IMG
- en: Converting a series into lowercase
  prefs: []
  type: TYPE_NORMAL
- en: 'The `capitalize()` method converts the first letter into uppercase and the
    rest into lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6f4fe24-6945-45d6-83b1-5fd4892e579c.png)'
  prefs: []
  type: TYPE_IMG
- en: Capitalize function for a series
  prefs: []
  type: TYPE_NORMAL
- en: 'The `title()` method ensures that the first letter of each word of a string
    is capitalized while the rest are in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f01cafb0-1108-49d1-a12b-8ae89b43c19f.png)'
  prefs: []
  type: TYPE_IMG
- en: Title case conversion for a string
  prefs: []
  type: TYPE_NORMAL
- en: 'The `swapcase()` method switches uppercase to lowercase and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b903886d-a9fb-44b6-be72-9bdcebd6604c.png)'
  prefs: []
  type: TYPE_IMG
- en: The swapcase() function
  prefs: []
  type: TYPE_NORMAL
- en: contains(), find(), and replace()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `contains()` method returns checks for the presence of a substring or pattern
    in all the elements of the series and returns a series of Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f2b731d-58e5-4d89-9c05-b9910c482099.png)'
  prefs: []
  type: TYPE_IMG
- en: Contains function for string type series
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `Matrix` is the only movie that contains the `atr` substring, `True`
    is returned at index `2`. The substring can also be a regex pattern. To use a
    regex pattern for string matching, the `regex` parameter should be set to `True`.
    For example, let''s identify a string that contains either `atr` or `der`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e456ffe7-21e8-45c0-9424-0efad202619a.png)'
  prefs: []
  type: TYPE_IMG
- en: Contains function with a regex
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, two matches have been identified. Setting the `case` parameter
    to `True` ensures case sensitivity when pattern matching is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c8e55b7-5c27-4c1a-901c-6a1b826b8ed2.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling case sensitivity in the contains function
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flags` parameter can be used to indicate any regex condition, such as
    ignoring case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586354c1-6d40-42c6-b8df-4a1f8381bb74.png)'
  prefs: []
  type: TYPE_IMG
- en: Regex flags for the contains function
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `re` package should be imported before defining any regex flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find` function returns the lowest index at which the substring could be
    found. Consider the following series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `find` function to get the index of the `ra` substring from
    the previous series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0742189-4baa-4254-8bec-5d12b1812173.png)'
  prefs: []
  type: TYPE_IMG
- en: Find function for a series
  prefs: []
  type: TYPE_NORMAL
- en: In the first element, `abracadabra`, the first occurrence of `ra` was at index
    position `2`. Hence, `2` is returned. The second element, `mad man`, did not show
    a string match, and so `-1` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find` function has a `start` parameter that can be used to specify the
    left-most index to begin the search from. Equivalently, there is an `end` parameter
    to define the right-most index until which search is permissible. `start` is set
    to `0` and `end` is set to `None` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b73f4b6-4b63-4103-a142-1dc0c7cb15f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The find function with a start limit specified
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we can see that by specifying the starting index,
    `a`, index 0 and 1 are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `replace` function can be considered as an extension of the `contains`
    function since most of the parameters are similar. Functionally, `replace` finds
    a substring within a string in a series and substitutes it with a replacement
    string. Parameters such as `flags`, `case`, and `regex`, which are found in the
    `contains` function, are also found here, and they serve the same purpose. Let''s
    replace the letter `I` in the series with the `rep` substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5211976-e7e0-45de-95ca-43394c185071.png)'
  prefs: []
  type: TYPE_IMG
- en: The replace function for a series
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in cases where there is more than one occurrence of `i`, multiple
    replacements are made. The number of replacements can be controlled with the `n`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36a7d778-1b44-45fc-b53d-3addc6672878.png)'
  prefs: []
  type: TYPE_IMG
- en: The replace function with the number of replacements specified
  prefs: []
  type: TYPE_NORMAL
- en: strip() and split()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `strip()` function can come in quite handy in data cleaning. It removes trailing
    whitespaces or any specific pattern of a string from textual content in series.
    If the substring to be removed is not specified, trailing whitespaces are trimmed
    by default. The following example demonstrates an application of the `strip` function
    with stray whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/186be31b-2115-435c-b8b6-be4df7f46122.png)'
  prefs: []
  type: TYPE_IMG
- en: Series with stray whitespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates an application of the `strip()` function
    with trailing whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15fe8b2f-58ec-438a-9493-0efb5efa0b7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Stripping trailing whitespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows that `strip()` only removes trailing whitespaces and not those in
    the middle. Now, let''s use `strip()` to remove a specific string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce382c0-e1fc-43c0-9010-d1c7a7476dca.png)'
  prefs: []
  type: TYPE_IMG
- en: The strip function for removing string sequences
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `strip()` function strips out any of the characters
    of the substring found in the trailing ends of the series elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split()` function splits a string at specified delimiters. Consider the
    following series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da181a01-a186-4737-9cca-ebed82dc3187.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample series for the split function
  prefs: []
  type: TYPE_NORMAL
- en: 'Each element has two to three items separated by `,`. Let''s use this as a
    delimiter to separate the items stacked together in each row of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1ea22bf-0079-4ed2-81c5-22142aec804e.png)'
  prefs: []
  type: TYPE_IMG
- en: Splitting as a list
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a list of items in each row. The `expand()` parameter creates
    a separate column for each item. By default, `expand` is set to `False`, which
    leads to a list being created in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/393771c4-bae4-4575-9dbd-18f85f9fd98e.png)'
  prefs: []
  type: TYPE_IMG
- en: Splitting multiple columns
  prefs: []
  type: TYPE_NORMAL
- en: startswith() and endswith()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `contains()` function helps evaluate whether a substring is present
    in each element of a series, the `startswith()` and `endswith()` functions specifically
    look for the presence of the substring at the start and the end of strings, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a633eb2e-d188-47f8-bfcb-056411e9d359.png)'
  prefs: []
  type: TYPE_IMG
- en: The `startswith` function
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `endswith` can be used as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aaa09de-958c-4e09-b9cc-45a1fcf07d65.png)'
  prefs: []
  type: TYPE_IMG
- en: The `endswith` function
  prefs: []
  type: TYPE_NORMAL
- en: However, unlike `contains()`, these functions do not accept regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The is...() functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table lists a group of functions that help ascertain other properties
    of the string elements of a series. For example, the `isupper` function returns
    `True` if all the characters of a string are in uppercase. These functions return
    a Boolean output corresponding to each row in the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Returns true when all characters are...** |'
  prefs: []
  type: TYPE_TB
- en: '| `isalnum()` | Alphanumeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isalpha()` | Alphabetic |'
  prefs: []
  type: TYPE_TB
- en: '| `isdigit()` | Digits |'
  prefs: []
  type: TYPE_TB
- en: '| `isspace()` | Whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `islower()` | Lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| `isupper()` | Uppercase |'
  prefs: []
  type: TYPE_TB
- en: '| `istitle()` | Title case |'
  prefs: []
  type: TYPE_TB
- en: '| `isnumeric()` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isdecimal()` | Decimal |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples of the preceding functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13c6abee-f0e4-47c1-b37a-5bb31f029f60.png)'
  prefs: []
  type: TYPE_IMG
- en: The isalpha function
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a example of the `isalnum` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd5ae6ea-6396-47a9-8c64-4b78be246383.png)'
  prefs: []
  type: TYPE_IMG
- en: The isalnum function
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of the `isnumeric` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e397795-5ed4-4686-ac0a-36040579326b.png)'
  prefs: []
  type: TYPE_IMG
- en: The isnumeric function
  prefs: []
  type: TYPE_NORMAL
- en: These functions are only applicable to strings and not to other data types.
    Using these with other data types results in `NaN` being returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the `isdigit()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b19fc19a-9970-49cc-86b0-5c2c41a919ec.png)'
  prefs: []
  type: TYPE_IMG
- en: The isdigit function
  prefs: []
  type: TYPE_NORMAL
- en: Binary operations on DataFrames and series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some binary functions such as, `add`, `sub`, `mul`, `div`, `mod`, and `pow`,
    perform common arithmetic operations involving two DataFrames or series.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the addition of two DataFrames. One of the DataFrames
    has the shape (2,3) while the other has the shape (1,3). The add function performs
    an elementwise addition. When a corresponding element is missing in any of the
    DataFrames, the missing values are filled with NaNs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0659c30-48e4-4d2e-835d-7c5f104164d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding two DataFrames elementwise
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using NaNs, we can choose to fill it with any value using the `fill_value`
    argument. Let''s explore this through the `mul` function for multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/476387db-1077-4054-94bd-caf32aaf0cee.png)'
  prefs: []
  type: TYPE_IMG
- en: The fill_value parameter in binary operators in pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'The second value that''s used for the arithmetic operation doesn''t necessarily
    need be a DataFrame or series; it can also be a scalar, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ee09dee-6899-4ac0-90a6-777ffb3425a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary operation with a scalar
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding cases, the two DataFrames were uniformly indexed. Elements
    are compatible for operations that are across the same index labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f43c4c20-d308-4435-9854-8d21f9d05f6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary operations being used on a series with different indexes
  prefs: []
  type: TYPE_NORMAL
- en: 'For indexes that aren''t in both series, `NaN` is returned. Similar behavior
    will be seen with respect to column labels. Only elements sharing a similar column
    name can be used together. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55468323-1ca2-43e2-8b9f-fbd0f11f3d64.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary operations used on DataFrames with different columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the following two DataFrames, one of which shows hierarchical
    indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20cd2e42-4df4-452e-97a1-9ecc541b3622.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is an example of a multi-indexed DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efe5edcf-5c00-40b8-a2e8-749eef7f518f.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-indexed DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'To divide `df` by the elements of `df_multi`, or to perform any of the aforementioned
    binary operations, the level parameter can be used to specify the `level` of the
    index that is shared by both DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d1431ec-4b7c-4688-b749-7849b158a1f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Binary operations used for DataFrames with a hierarchical index
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lt`, `le`, `gt`, and `ge` functions help with DataFrame comparisons by
    establishing the truth of *less than*, *less than or equal to*, *greater than*,
    and *greater than or equal to* comparisons. They have the same parameters as the
    functions we discussed previously and show similar behaviors in all those scenarios.
    Let''s compare `df` and `df_multi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d80bc522-99b0-43cf-bd6d-33c6aa2bef61.png)'
  prefs: []
  type: TYPE_IMG
- en: Less than function
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block shows the `le` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f0460c6-9f7e-4709-8a67-1f283920e2bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Less than or equal to function
  prefs: []
  type: TYPE_NORMAL
- en: 'The `round` function rounds decimals to the desired number of places, as specified
    by the `decimals` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88f9bee5-8b96-40fa-8eff-d4793c1818e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The round function
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, rounding off takes place to make the input a whole number (`decimals
    = 0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a6e2ed8-144a-41c1-96e0-0641ebe00fa9.png)'
  prefs: []
  type: TYPE_IMG
- en: The round function with a number of places set
  prefs: []
  type: TYPE_NORMAL
- en: 'The `combine` function takes two overlapping DataFrames and executes the function
    defined within them. Let''s combine two series and find the maximum of the two.
    Note that a comparison takes place, with the index as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99c8ea57-7ad6-4044-b7a1-188fff0b269d.png)'
  prefs: []
  type: TYPE_IMG
- en: The combine function
  prefs: []
  type: TYPE_NORMAL
- en: Binning values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pandas `cut()` function bins values in a 1-dimensional array. Consider
    the following 1-dimensional array with 10 values. Let''s group it into three bins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75641e12-5a07-462d-8231-ff5fef914d71.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas cut function with three bins
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the 10 elements is mapped to one of the three bins. The `cut` function
    maps the items to a bin and provides information about each bin. Instead of specifying
    the number of bins, the boundaries of the bins could also be provided in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/600f7098-daa5-42e6-930a-c5eb88b32d15.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas cut function with bin values
  prefs: []
  type: TYPE_NORMAL
- en: 'The intervals for binning can be directly defined using the pandas `interval_range`
    function. Consider the following example, demonstrating the creation of a pandas
    `IntervalIndex` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd09961d-6c76-4904-8e4a-2aced11cb297.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas IntervalIndex
  prefs: []
  type: TYPE_NORMAL
- en: 'This interval can be directly passed to the `cut` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04a60603-87d5-401d-91e3-86e26339ebf9.png)'
  prefs: []
  type: TYPE_IMG
- en: pandas cut function with the interval index
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the `right` parameter to `True` includes the right interval in the
    bin, while setting the `right` parameter to `False` excludes it from the bin range.
    The default setting is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62348564-86f6-414e-8434-54a16ef80c9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Open right interval
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalently, the `include_lowest` parameter decides whether the lowest interval
    should be included. By default, it is set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0513d85e-5958-44a7-ab53-5c0e498129ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Including the lowest value in the left range
  prefs: []
  type: TYPE_NORMAL
- en: 'The function returns the bins when `retbins` is set to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec0a959d-585d-4eb3-9f6f-80888af2be29.png)'
  prefs: []
  type: TYPE_IMG
- en: Returning bins
  prefs: []
  type: TYPE_NORMAL
- en: The second value in the output tuple is an array of the bin values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bins can be assigned labels by passing a list of label names to the `labels`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c5f8005-9ddd-4f60-aeaa-81997e6b845c.png)'
  prefs: []
  type: TYPE_IMG
- en: Label bins
  prefs: []
  type: TYPE_NORMAL
- en: 'When the bins that are passed contain duplicates, an error is raised by default.
    This is because the duplicates parameter is set to `raise` by default. Setting
    it to `drop` will drop the duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaf56718-eddb-48ca-997d-6d05d2ef079f.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling duplicates in bins
  prefs: []
  type: TYPE_NORMAL
- en: 'The precision of digits up to which the bins are created and stored can be
    set by the `precision` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bdc0653-e4dd-49d6-b2b8-7031195e36cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting precision in bins
  prefs: []
  type: TYPE_NORMAL
- en: 'The `qcut` function is similar to the `cut` function, with the exception that
    bins can be created by specifying the number of quantiles based on which the bins
    are to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7af0fc2c-9a4f-4af1-b34a-65150bc474d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The qcut function
  prefs: []
  type: TYPE_NORMAL
- en: Using mathematical methods on DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computations such as sum, mean, and median can be performed with ease on pandas
    DataFrames using the built-in mathematical methods in the pandas library. Let''s
    make use of a subset of the sales data to explore the mathematical functions and
    methods in pandas. While applying these mathematical functions, it should be ensured
    that the selected columns are numeric. The following screenshot shows the data
    with five rows and three columns, all of which will be used in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6a8b8b8-2173-42bb-a910-35849975f88c.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample sales data
  prefs: []
  type: TYPE_NORMAL
- en: The abs() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `abs()` function returns the absolute values of records in the DataFrame.
    For columns with complex values in the form x+yj, the absolute value is computed
    as ![](img/eda1f3fa-ea77-4427-a19f-b174c53d7584.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa02a787-d40f-4a8a-8029-7a52fe83a414.png)'
  prefs: []
  type: TYPE_IMG
- en: The abs() function
  prefs: []
  type: TYPE_NORMAL
- en: corr() and cov()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `corr()` function returns the correlation coefficient of each combination
    of variables in the DataFrame. If any NAs are present, they are excluded for correlation
    computation. The `corr()` function accepts the Pearson, Kendall, and Spearman
    methods. By default, the Pearson correlation coefficient is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/909bfd77-7725-42a9-928c-01dafea21849.png)'
  prefs: []
  type: TYPE_IMG
- en: The corr() function
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the correlation function, the `cov()` function returns the covariance
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4590bcbf-8146-4093-a6fe-d96c3790afb1.png)'
  prefs: []
  type: TYPE_IMG
- en: The cov() function
  prefs: []
  type: TYPE_NORMAL
- en: The `min_periods` argument in `corr()` and `cov()` decides the minimal presence
    of non-NA values in the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: cummax(), cumin(), cumsum(), and cumprod()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cummax()`, `cummin()`, `cumsum()`, and `cumprod()` functions compute the
    maximum, minimum, sum, and product on a cumulative basis, respectively. Let''s
    understand this by applying the `cummax()` function on the sample DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/064a2bf2-bb86-498c-98e2-ce8485760f7e.png)'
  prefs: []
  type: TYPE_IMG
- en: The cummax() function
  prefs: []
  type: TYPE_NORMAL
- en: 'The `skipna` parameter in these functions provides control over handling NAs.
    It is set to `True` by default, and NAs are excluded. Consider the following DataFrame
    with NAs to understand the function of this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9776827-9504-4cc5-8eb1-52646a3d74f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample data with NAs
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cumsum()` method can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1112b092-89d2-4947-aef7-59eafea31094.png)'
  prefs: []
  type: TYPE_IMG
- en: The cumsum() function
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose to not ignore NAs while doing a cumulative sum by setting `skipna`
    to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38c77232-e746-4f4b-8fa6-0d1798d42bfd.png)'
  prefs: []
  type: TYPE_IMG
- en: The cumulative function with skipna
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the aggregation is performed across the row axis since the `axis`
    parameter is set to `0` by default. Using the `axis` parameter, cumulative aggregation
    can also be performed across columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a511ae4a-d276-406a-be33-3e8d76c352f8.png)'
  prefs: []
  type: TYPE_IMG
- en: The cumprod() function
  prefs: []
  type: TYPE_NORMAL
- en: The describe() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `describe()` function provides a representation of the distribution of
    data and computes some useful summary statistics. It serves quite useful for **exploratory
    data analysis** (**EDA**) techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/030729c7-6d6d-4e33-b683-d07e19b76981.png)'
  prefs: []
  type: TYPE_IMG
- en: The describe() function
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe()` function can be applied to numeric and categorical variables.
    The `include` and `exclude` parameters of the `describe` function set the data
    type of the function it should evaluate. By default, `include` is set to `numeric`.
    Hence, any categorical variables in the Dataframe will be ignored. Let''s apply
    `describe` on the following DataFrame by setting the `include` parameter to the
    `object` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a3deecc-a6d6-4b50-85f0-1b38e9dd1c06.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample data with mixed datatypes
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/337bc1ad-b82f-4401-95e7-e7f120b0f962.png)'
  prefs: []
  type: TYPE_IMG
- en: The describe() function for categorical variables
  prefs: []
  type: TYPE_NORMAL
- en: All the datatypes can be included by setting `include` to `all`. Similarly,
    the `exclude` parameter can also be used to exclude certain datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For numeric variables, `describe` evaluates the percentiles at 0.25, 0.5, 0.75,
    and 1\. This can be customized like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/017a1dc1-3e58-4534-b588-cce4cb6dc905.png)'
  prefs: []
  type: TYPE_IMG
- en: Custom percentiles in the describe function
  prefs: []
  type: TYPE_NORMAL
- en: The diff() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `diff()` function computes the difference between subsequent rows in the
    same column or subsequent columns in the same row. `diff()` can be evaluated along
    a row or column by setting the `axis` parameter, which is set to 0 by default.
    Therefore, computation takes place by row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aab6fa7e-2546-42c6-825c-f24ab052feae.png)'
  prefs: []
  type: TYPE_IMG
- en: The diff() function
  prefs: []
  type: TYPE_NORMAL
- en: 'The `diff` method can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e3e20e0-c8d7-4d14-9442-1705a24ed8f8.png)'
  prefs: []
  type: TYPE_IMG
- en: The diff() function applied along axis 1
  prefs: []
  type: TYPE_NORMAL
- en: 'The `periods()` parameter can be used to find the difference of the nth previous
    row. A negative value would allow us to find the difference from the nth row that
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/001f6e9f-cfc2-4ebb-8874-d79826c23b62.png)'
  prefs: []
  type: TYPE_IMG
- en: diff() being used at different periodic intervals
  prefs: []
  type: TYPE_NORMAL
- en: The rank() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `rank()` function returns a DataFrame with the rank of each value that
    was estimated along the specified axis. Ranking takes place in ascending order
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70dab829-f10d-43fa-99b9-2d543d2f0dfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Ranking function result
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rank()` method can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea5b41be-b19e-432a-b012-8970e77d519c.png)'
  prefs: []
  type: TYPE_IMG
- en: Ranking in descending order
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranking can also be obtained as a percentage, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3070fb9d-8481-4e11-97b3-fc6465effa57.png)'
  prefs: []
  type: TYPE_IMG
- en: Ranking with percentiles
  prefs: []
  type: TYPE_NORMAL
- en: 'The `method()` argument helps settle ties. By default, the average of the range
    of ranks that could possibly be occupied by items in a tie is shown in the result.
    It can also be modified to show the minimum rank, maximum rank, the order in which
    values appear, or dense ranking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1e18e41-4d28-4689-b2b9-998e5c02b5bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the ranking method to find the minimum value for a tiebreaker
  prefs: []
  type: TYPE_NORMAL
- en: The quantile() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `quantile()` function returns the value for every column for the specified
    quantiles. It accepts a single quantile value or an array of quantile values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2ebabbc-b3fc-4466-851b-9cae14407fc6.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the quantiles for a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantiles can also be computed for timestamps. We can achieve this by setting
    the `numeric_only` parameter to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6374dfd5-754f-4174-af75-5a2a7cf85095.png)'
  prefs: []
  type: TYPE_IMG
- en: Quantiles for the datetime value
  prefs: []
  type: TYPE_NORMAL
- en: The round() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `round()` function helps in rounding off decimals. By default, the values
    are rounded off to a whole number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff14f7fd-af30-44f4-86e6-6f4c49b73fcd.png)'
  prefs: []
  type: TYPE_IMG
- en: The `round()` function's results
  prefs: []
  type: TYPE_NORMAL
- en: 'The `round` function can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad4f15c5-ade2-426b-b79b-0e9891992189.png)'
  prefs: []
  type: TYPE_IMG
- en: The `round()` function for `decimals = 10`
  prefs: []
  type: TYPE_NORMAL
- en: The pct_change() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pct_change()` function works similar to the `diff` function and computes
    the percentage of the difference between two different values in the DataFrame.
    Just like in `diff()`, the `periods` parameter provides flexibility so that we
    can evaluate between different elements that are spaced apart by a few rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77c376d-0209-425e-b664-090c9017ed1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Percentage change across rows
  prefs: []
  type: TYPE_NORMAL
- en: The `fill_method` parameter allows NAs to be handled by methods such as padding
    prior to computation. The `limit` parameter helps set a threshold on a permissible
    number of NAs.
  prefs: []
  type: TYPE_NORMAL
- en: min(), max(), median(), mean(), and mode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These functions accept a similar set of parameters and compute the aggregates
    (min, max, median, or mode) for each column or row based on the axis parameter
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b3c5db-ba68-4348-99f5-63cf87bbe5ee.png)'
  prefs: []
  type: TYPE_IMG
- en: The `min()` result
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max` method can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3f5c0f1-f20b-4883-807c-140ae916f5c6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `max()` result
  prefs: []
  type: TYPE_NORMAL
- en: 'The `skipna` parameter helps us handle NAs. Consider the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/132d2fd7-32c9-411a-980e-20d08f5ddcb1.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame with NAs
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the NAs are skipped during evaluation, as the `skipna` parameter
    is set to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d09307e-9c2a-4c9d-bfe2-f1b8dc47e93d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `median()` function
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, NAs are ignored in mean calculations. If `skipna` is set to `False`,
    the calculation also result to NA if there is a missing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73773c33-7696-459e-87d9-b38ea0d72767.png)'
  prefs: []
  type: TYPE_IMG
- en: The `median()` function with `skipna`
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following multi indexed DataFrame. Let''s compute the mean for
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8528079d-141d-4743-9f5f-f8425394041c.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi indexed DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The mean of this multi-index dataset can be obtained as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dafe3a03-8403-463b-a734-151464b11488.png)'
  prefs: []
  type: TYPE_IMG
- en: The mean of the multi indexed DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The `level` parameter computes the aggregate across any level of index in a
    multi-indexed DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dc322d1-d642-4662-962b-61fa46cc92ce.png)'
  prefs: []
  type: TYPE_IMG
- en: '`mean()` for a specific index level'
  prefs: []
  type: TYPE_NORMAL
- en: all() and any()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `all()` and `any()` functions help us test for the presence of `False`
    values or zeros in a DataFrame. If all the values along the chosen axis are `True`,
    then the `all()` function returns `True`. The `any()` function requires at least
    a single value to be `True` to return `True`. Let''s apply `all()` and `any()`
    on the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f96a54f-450f-4a4e-b01e-af421bb45fb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'All the values are `True` in columns B, C, and D. Hence, `all()` returns `True`
    for these columns. Column E, which has no `True` values, returns `False` with
    `any()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b58a4e51-fd8e-4b81-a41f-8e7075f9423f.png)'
  prefs: []
  type: TYPE_IMG
- en: The `all()` result
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `any()` can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e5a67cf-7e0f-48b5-aec1-4c08cb8f2191.png)'
  prefs: []
  type: TYPE_IMG
- en: The `any()` result
  prefs: []
  type: TYPE_NORMAL
- en: 'The `all()` and `any()` functions have the `axis`, `skipna`, and `level` parameters,
    just like some of the functions we discussed previously. The `bool_only` parameter
    can be used to include or exclude datatypes other than Booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b9ad684-efac-4446-9c4b-3bd247439657.png)'
  prefs: []
  type: TYPE_IMG
- en: The bool_only parameter
  prefs: []
  type: TYPE_NORMAL
- en: The clip() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `clip()` function specifies a lower limit and upper limit. Values in the
    DataFrame exceeding the upper limit, are reduced to the upper limit and values
    under the lower limit are raised to this lower limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0014d934-58e5-4bbe-9f08-6166593f4fc5.png)'
  prefs: []
  type: TYPE_IMG
- en: clip() result
  prefs: []
  type: TYPE_NORMAL
- en: The count() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `count()` function helps count the total non-NA values in the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ef7d318-a7cc-45d8-b4fa-811385cc1921.png)'
  prefs: []
  type: TYPE_IMG
- en: DataFrame with NA
  prefs: []
  type: TYPE_NORMAL
- en: 'The count method can be applied as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d374bae-d1ba-43e6-b154-6522a932961a.png)'
  prefs: []
  type: TYPE_IMG
- en: count() result
  prefs: []
  type: TYPE_NORMAL
- en: The `count()` function has the `axis`, `level`, and `numeric_only` parameters,
    just like several other functions we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a collection of special methods that show the flexibility
    and usefulness of pandas. This chapter has been like an illustrated glossary in
    which each function serves a very unique purpose. Now, you should have an idea
    of how to create and apply one-liner functions in pandas, and you should understand
    the concepts of missing values and the methods that take care of them. This is
    also a compendium of all the miscellaneous methods that can be applied to a series
    and the numeric methods that can be applied to any kind of Python data structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at how we can handle time series data
    and plot it using `matplotlib`. We will also have a look into the manipulation
    of time series data by looking at rolling, resampling, shifting, lagging, and
    time element separation.
  prefs: []
  type: TYPE_NORMAL
