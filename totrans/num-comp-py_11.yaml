- en: Boolean Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtering data from a dataset is one of the most common and basic operations.
    There are numerous ways to filter (or subset) data in pandas with **b****oolean
    indexing**. Boolean indexing (also known as **boolean selection**) can be a confusing
    term, but for the purposes of pandas, it refers to selecting rows by providing
    a boolean value (`True` or `False`) for each row. These boolean values are usually
    stored in a Series or NumPy `ndarray` and are usually created by applying a boolean
    condition to one or more columns in a DataFrame. We begin by creating boolean
    Series and calculating statistics on them and then move on to creating more complex
    conditionals before using boolean indexing in a wide variety of ways to filter
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating boolean statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing multiple boolean conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering with boolean indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating boolean indexing with index selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting with unique and sorted indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining perspective on stock prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating SQL WHERE clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the normality of stock market returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving readability of boolean indexing with the query method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving Series with the `where` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking DataFrame rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting with booleans, integer location, and labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating boolean statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When first getting introduced to boolean Series, it can be informative to calculate
    basic summary statistics on them. Each value of a boolean series evaluates to
    0 or 1 so all the Series methods that work with numerical values also work with
    booleans.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we create a boolean Series by applying a condition to a column
    of data and then calculate summary statistics from it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the `movie` dataset, set the index to the movie title, and inspect
    the first few rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/db52f01e-a8cc-453c-8c12-16c0634faaba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Determine whether the duration of each movie is longer than two hours by using
    the greater than comparison operator with the `duration` Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this Series to determine the number of movies that are longer
    than two hours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the percentage of movies in the dataset longer than two hours, use
    the `mean` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the output from step 4 is misleading. The `duration` column
    has a few missing values. If you look back at the DataFrame output from step 1,
    you will see that the last row is missing a value for `duration`. The boolean
    condition in step 2 returns `False` for this. We need to drop the missing values
    first, then evaluate the condition and take the mean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `describe` method to output a few summary statistics on the boolean
    Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most DataFrames will not have columns of booleans like our movie dataset. The
    most straightforward method to produce a boolean Series is to apply a condition
    to one of the columns using one of the comparison operators. In step 2, we use
    the greater than operator to test whether or not the duration of each movie was
    more than two hours (120 minutes). Steps 3 and 4 calculate two important quantities
    from a boolean Series, its sum and mean. These methods are possible as Python
    evaluates `False`/`True` as 0/1.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prove to yourself that the mean of a boolean Series represents the
    percentage of `True` values. To do this, use the `value_counts` method to count
    with the `normalize` parameter set to `True` to get its distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 alerts us to the incorrect result from step 4\. Even though the `duration`
    column had missing values, the boolean condition evaluated all these comparisons
    against missing values as `False`. Dropping these missing values allows us to
    calculate the correct statistic. This is done in one step through method chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 shows that pandas treats boolean columns similarly to how it treats object
    data types by displaying frequency information. This is a natural way to think
    about boolean Series, rather than display quantiles like it does with numeric
    data.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to compare two columns from the same DataFrame to produce a
    boolean Series. For instance, we could determine the percentage of movies that
    have actor 1 with more Facebook likes than actor 2\. To do this, we would select
    both of these columns and then drop any of the rows that had missing values for
    either movie. Then we would make the comparison and calculate the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Constructing multiple boolean conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, boolean expressions use the built-in logical operators `and`, `or`,
    and `not`. These keywords do not work with boolean indexing in pandas and are
    respectively replaced with `&`, `|`, and `~`. Additionally, each expression must
    be wrapped in parentheses or an error will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing a precise filter for your dataset might have you combining multiple
    boolean expressions together to extract an exact subset. In this recipe, we construct
    multiple boolean expressions before combining them together to find all the movies
    that have an `imdb_score` greater than 8, a `content_rating` of PG-13, and a `title_year`
    either before 2000 or after 2009.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load in the movie dataset and set the index as the title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a variable to hold each set of criteria independently as a boolean Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine all the criteria together into a single boolean Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All values in a Series can be compared against a scalar value using the standard
    comparison operators( `<`, `>`, `==`, `!=`, `<=`, `>=`). The expression `movie.imdb_score
    > 8` yields a Series of booleans where all `imdb_score` values prices exceeding
    8 are `True` and those less than or equal to 8 are `False`. The index of this
    boolean Series retains the same index as the original and in this case, is the
    title of the movie.
  prefs: []
  type: TYPE_NORMAL
- en: The `criteria3` variable is created by two independent boolean expressions.
    Each expression must be enclosed in parentheses to function properly. The pipe
    character, `|`, is used to create a logical `or` condition between each of the
    values in both Series.
  prefs: []
  type: TYPE_NORMAL
- en: All three criteria need to be `True` to match the requirements of the recipe.
    They are each combined together with the ampersand character, `&`, which creates
    a logical `and` condition between each Series value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A consequence of pandas using different syntax for the logical operators is
    that operator precedence is no longer the same. The comparison operators have
    a higher precedence than `and`, `or`, and `not`. However, the new operators for
    pandas (the bitwise operators `&`, `|`, and `~`) have a higher precedence than
    the comparison operators, thus the need for parentheses. An example can help clear
    this up. Take the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding expression, `5 < 10` evaluates first, followed by `3 < 4`,
    and finally, the `and` evaluates. Python progresses through the expression as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at what would happen if the expression in `criteria3` was
    written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As the bitwise operators have higher precedence than the comparison operators,
    `2000 | movie.title_year` is evaluated first, which is nonsensical and raises
    an error. Therefore, parentheses are needed to have the operations evaluated in
    the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Why can't pandas use `and`, `or`, and `not`? When these keywords are evaluated,
    Python attempts to find the **truthiness** of the objects as a whole. As it does
    not make sense for a Series as a whole to be either True or False--only each element--pandas
    raises an error.
  prefs: []
  type: TYPE_NORMAL
- en: Many objects in Python have boolean representation. For instance, all integers
    except 0 are considered `True`. All strings except the empty string are `True`.
    All non-empty sets, tuples, dictionaries, and lists are `True`. An empty DataFrame
    or Series does not evaluate as True or False and instead an error is raised. In
    general, to retrieve the truthiness of a Python object, pass it to the `bool`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python operator precedence ([http://bit.ly/2vxuqSn](https://docs.python.org/3/reference/expressions.html#operator-precedence))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering with boolean indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean selection for Series and DataFrame objects is virtually identical. Both
    work by passing a Series of booleans indexed identically to the object being filtered
    to the indexing operator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe constructs two complex and independent boolean criteria for different
    sets of movies. The first set of movies comes from the previous recipe and consists
    of those with an `imdb_score` greater than 8, a `content_rating` of PG-13, and
    a `title_year` either before 2000 or after 2009\. The second set of movies consists
    of those with `imdb_score` less than 5, a `content_rating` of R, and a `title_year`
    between 2000 and 2010.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the `movie` dataset, set the index to the `movie_title`, and create
    the first set of criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create criteria for the second set of movies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine the two sets of criteria using the pandas `or` operator. This yields
    a boolean Series of all movies that are members of either set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your boolean Series, you simply pass it to the indexing operator
    to filter the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/20f2408c-8036-4718-b24d-414396bf1b93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have successfully filtered the data and all the columns of the DataFrame.
    We can''t easily perform a manual check to determine whether the filter worked
    correctly. Let''s filter both rows and columns with the `.loc` indexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/45dd3c6c-983d-48ac-a195-cf04a3d34701.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1 and step 2, each set of criteria is built from simpler boolean expressions.
    It is not necessary to create a different variable for each boolean expression
    as done here, but it does make it far easier to read and debug any logic mistakes.
    As we desire both sets of movies, step 3 uses the pandas logical `or` operator
    to combine them.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 shows the exact syntax of how boolean indexing works. You simply pass
    the Series of booleans created from step 3 directly to the indexing operator.
    Only the movies with `True` values from `final_crit_all` are selected.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing also works with the `.loc` indexer as seen in step 5 by simultaneously
    doing boolean indexing and individual column selection. This slimmed DataFrame
    is far easier to check manually whether the logic was implemented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing does not quite work with the `.iloc` indexing operator. If
    you pass in a boolean series to it, an exception will get raised. However, if
    you pass in a boolean ndarray it will the same as it does in this recipe with
    the other indexers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As was stated earlier, it is possible to use one long boolean expression in
    place of several other shorter ones. To replicate the `final_crit_a` variable
    from step 1 with one long line of code, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation on *boolean indexing* ([http://bit.ly/2v1xK77](http://pandas.pydata.org/pandas-docs/stable/indexing.html#boolean-indexing))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the truth of a Python object ([http://bit.ly/2vn8WXX](https://docs.python.org/3/library/stdtypes.html#truth))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating boolean indexing with index selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to replicate specific cases of boolean selection by taking advantage
    of the index. Selection through the index is more intuitive and makes for greater
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use the `college` dataset to select all institutions from
    a particular state with both boolean indexing and index selection and then compare
    each of their performance against one another.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the `college` dataset and use boolean indexing to select all institutions
    from the state of Texas (TX):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Pandas official documentation on
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5e22aa2-e86e-4927-afeb-4f898a718bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To replicate this using index selection, we need to move the `STABBR` column
    into the index. We can then use label-based selection with the `.loc` indexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7500adf0-77c4-4a09-84bd-047e03cb3a84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s compare the speed of both methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean indexing takes three times as long as index selection. As setting the
    index does not come for free, let''s time that operation as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 1 creates a boolean Series by determining which rows of data have `STABBR`
    equal to `TX`. This Series is passed to the indexing operator, which subsets the
    data. This process may be replicated by moving that same column to the index and
    simply using basic label-based index selection with `.loc`. Selection via the
    index is much faster than boolean selection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe only selects a single state. It is possible to select multiple
    states with both boolean and index selection. Let''s select **Texas** (**TX**),
    **California** (**CA**), and **New York** (**NY**). With boolean selection, you
    can use the `isin` method but with indexing, just pass a list to `.loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a bit more to the story than what this recipe explains. Pandas
    implements the index differently based on whether the index is unique or sorted.
    See the following recipe for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting with unique and sorted indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Index selection performance drastically improves when the index is unique or
    sorted. The prior recipe used an unsorted index that contained duplicates, which
    makes for relatively slow selections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we use the `college` dataset to form unique or sorted indexes
    to increase the performance of index selection. We will continue to compare the
    performance to boolean indexing as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset, create a separate DataFrame with `STABBR` as the
    index, and check whether the index is sorted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort the index from `college2` and store it as another object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Time the selection of the state of Texas (TX) from all three DataFrames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The sorted index performs nearly an order of magnitude faster than boolean
    selection. Let''s now turn towards unique indexes. For this, we use the institution
    name as the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s select Stanford University with boolean indexing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/54c9850e-c00d-43fb-887c-ccbfdc6b81f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s select Stanford University with index selection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'They both produce the same data, just with different objects. Let''s time each
    approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the index is not sorted and contains duplicates, as with `college2`, pandas
    will need to check every single value in the index in order to make the correct
    selection. When the index is sorted, as with `college3`, pandas takes advantage
    of an algorithm called **binary search** to greatly improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of the recipe, we use a unique column as the index. Pandas
    implements unique indexes with a hash table, which makes for even faster selection.
    Each index location can be looked up in nearly the same time regardless of its
    length.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boolean selection gives much more flexibility than index selection as it is
    possible to condition on any number of columns. In this recipe, we used a single
    column as the index. It is possible to concatenate multiple columns together to
    form an index. For instance, in the following code, we set the index equal to
    the concatenation of the city and state columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7cbcb510-cb15-4633-9a23-6f3c6f53aa59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From here, we can select all colleges from a particular city and state combination
    without boolean indexing. Let''s select all colleges from `Miami, FL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ee559ed9-bef7-426a-9337-2dc405de57c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can compare the speed of this compound index selection with boolean indexing.
    There is more than an order of magnitude difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Binary search algorithm* ([http://bit.ly/2wbMq20](https://en.wikipedia.org/wiki/Binary_search_algorithm))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining perspective on stock prices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Investors who have purchased long stock positions would obviously like to sell
    stocks at or near their all-time highs. This, of course, is very difficult to
    do in practice, especially if a stock price has only spent a small portion of
    its history above a certain threshold. We can use boolean indexing to find all
    points in time that a stock has spent above or below a certain value. This exercise
    may help us gain perspective as to what a common range for some stock to be trading
    within.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we examine Schlumberger stock from the start of 2010 until mid-2017\.
    We use boolean indexing to extract a Series of the lowest and highest ten percent
    of closing prices during this time period. We then plot all points and highlight
    those that are in the upper and lower ten percent.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the Schlumberger stock data, put the `Date` column into the index,
    and convert it to a `DatetimeIndex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9c889d58-52eb-4eec-8b73-39db375c7b89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the closing price as a Series and use the `describe` method to return
    summary statistics as a Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using boolean selection, select all closing prices in the upper or lower tenth
    percentile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Plot the resulting filtered Series in light gray on top of all closing prices
    in black. Use the `matplotlib` library to draw horizontal lines at the tenth and
    ninetieth percentiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/787b6fa6-65a8-4550-a293-05ed4e625cdc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result of the `describe` method in step 2 is itself a Series with the identifying
    summary statistic as its index labels. This summary Series is used to store the
    tenth and ninetieth percentiles as their own variables. Step 3 uses boolean indexing
    to select only those values in the upper and lower tenth of the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Both Series and DataFrames have direct plotting capabilities through the `plot`
    method. This first call to the `plot` method comes from the `slb_close` Series,
    which contains all the SLB closing prices. This is the black line in the plot.
    The points from `slb_filtered` are plotted as gray markers directly on top of
    the closing prices. The `style` parameter is set to a single blank space so that
    no line is drawn. The `ms` parameter sets the marker size.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib comes with a convenience function, `hlines`, that plots horizontal
    lines. It takes a list of `y` values and plots them from `xmin` to `xmax`.
  prefs: []
  type: TYPE_NORMAL
- en: Judging from our new perspective from the plots that we created, it's clear
    to see that although SLB's all-time high is close to $120 per share, only 10%
    of the trading days in the last seven years have been above $93 per share.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of plotting red points (black points) over the closing prices to indicate
    the upper and lower tenth percentiles, we can use matplotlib''s `fill_between`
    function. This function fills in all the areas between two lines. It takes an
    optional `where` parameter that accepts a boolean Series, alerting it to exactly
    which locations to fill in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1b04de13-e7d7-4d60-ab2d-38b1afc0daef.png)'
  prefs: []
  type: TYPE_IMG
- en: Translating SQL WHERE clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many pandas users will have a background processing data directly from databases
    using the ubiquitous **Structured Query Language** (**SQL**). SQL is a standardized
    language to define, manipulate, and control data stored in a database. The `SELECT`
    statement is the most common way to use SQL to select, filter, aggregate, and
    order data. Pandas has the ability to connect to databases and send SQL statements
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is a very important language to know for data scientists. Much of the world's
    data is stored in databases that necessitate SQL to retrieve, manipulate, and
    perform analyses on. SQL syntax is fairly simple and easy to learn. There are
    many different SQL implementations from companies such as Oracle, Microsoft, IBM,
    and more. Although the syntax is not compatible between the different implementations,
    the core of it will look very much the same.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within a SQL SELECT statement, the WHERE clause is very common and filters data.
    This recipe will write pandas code that is equivalent to a SQL query that selects
    a certain subset of the employee dataset.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to understand any SQL syntax to make use of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we are given a task to find all the female employees that work in the
    police or fire departments that have a base salary between 80 and 120 thousand
    dollars. The following SQL statement would answer this query for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the `employee` dataset as a DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Before filtering out the data, it is helpful to do some manual inspection of
    each of the filtered columns to know the exact values that will be used in the
    filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a single statement for each of the criteria. Use the `isin` method to
    test equality to one of many values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine all the boolean Series together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Use boolean indexing to select only the rows that meet the final criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5cf310ad-c04c-4212-b5c5-03e9459468cf.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before any filtering is actually done, you will obviously need to know the exact
    string names that will be used. The Series `value_counts` method is an excellent
    way to get both the exact string name and number of occurrences of that value.
  prefs: []
  type: TYPE_NORMAL
- en: The `isin` Series method is equivalent to the SQL `IN` operator and accepts
    a list of all possible values that you would like to keep. It is possible to use
    a series of `OR` conditions to replicate this expression but it would not be as
    efficient or idiomatic.
  prefs: []
  type: TYPE_NORMAL
- en: The criteria for salary, `criteria_sal`, is formed by combining two simple inequality
    expressions. All the criteria are finally combined together with the pandas `and`
    operator, `&`, to yield a single boolean Series as the filter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For many operations, pandas has multiple ways to do the same thing. In the
    preceding recipe, the criteria for salary uses two separate boolean expressions.
    Similarly to SQL, Series have a `between` method, with the salary criteria equivalently
    written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful application of `isin` is to provide a sequence of values automatically
    generated by some other pandas statements. This would avoid any manual investigating
    to find the exact string names to store in a list. Conversely, let''s try to exclude
    the rows from the top five most frequently occurring departments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL equivalent of this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of the pandas not operator, `~`, which negates all boolean values
    of a Series.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation of the `isin` ([http://bit.ly/2v1GPfQ](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html))
    and `between` ([http://bit.ly/2wq9YPF](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.between.html))
    Series methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Connecting to SQL databases recipe* in [Chapter 15](40ba859e-6517-458e-8fd5-f3bcaf55a4fc.xhtml),
    *Combining Pandas Objects*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic introduction to SQL from W3 schools ([http://bit.ly/2hsq8Wp](https://www.w3schools.com/sql/DEfaULT.asP))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL IN operator ([http://bit.ly/2v3H7Bg](https://www.w3schools.com/sql/sql_in.asp))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQL BETWEEN operator ([http://bit.ly/2vn5UTP](https://www.w3schools.com/sql/sql_between.asp))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the normality of stock market returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In elementary statistics textbooks, the normal distribution is heavily relied
    upon to describe many different populations of data.  Although many random processes
    do appear to look like normal distributions most of the time, real-life tends
    to be more complex. Stock market returns are a prime example of a distribution
    that can look fairly normal but in actuality be quite far off.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes how to find daily stock market returns of the internet
    retail giant Amazon and informally test whether they follow a normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load Amazon stock data and set the date as the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/32cbff6f-8e7f-45ec-b066-abff676c389b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a Series by selecting only the closing price and then using the `pct_change`
    method to get the daily rate of return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Drop the missing value and plot a histogram of the returns to visually inspect
    the distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d34eaba2-c6be-4b31-9f20-a1517c225a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Normal distributions approximately follow the 68-95-99.7 rule--meaning that
    68% of the data falls between 1 standard deviation of the mean, 95% between 2,
    and 99.7% between 3\. We will now calculate the percentage of daily returns that
    fall between 1, 2, and 3 standard deviations from the mean. For this, we will
    need the mean and standard deviation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the absolute value of the `z-score` for each observation. The `z-score`
    is the number of standard deviations away from the mean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the percentage of returns that are within 1, 2, and 3 standard deviations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `pct_change` Series method calculates the percentage change
    between the current element and the previous element. This transforms the raw
    stock closing prices into daily percentage returns. The first element of the returned
    Series is a missing value as there is no previous price.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms are fantastic plots to summarize and visualize one-dimensional numeric
    data. It is clear from the plot that the distribution is symmetrical but it remains
    difficult to determine whether it is normal or not. There are formal statistical
    procedures to determine the normality of a distribution but we will simply find
    how close the data matches the 68-95-99.7 rule.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 calculates the number of standard deviations away from the mean for each
    observation which is referred to as the `z-score`. This step uses the methods
    and not the symbols (`-` and `/`) to do subtraction and division. The method for
    less than is also used in favor of the symbols in step 6.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem odd that the mean is being taken in step 6\. The result of the `abs_z_score.lt(1)`
    expression is a Series of booleans. As booleans evaluate to 0 or 1, taking the
    mean of this Series returns the percentage of elements that are `True`, which
    is what we desired.
  prefs: []
  type: TYPE_NORMAL
- en: We can now more easily determine the normality of the returns by comparing the
    resulting numbers (78.7-95.7-98.5) to the 68-95-99.7 rule. The percentages deviate
    greatly from the rule for 1 and 3 standard deviations, and we can conclude that
    Amazon daily stock returns do not follow a normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To automate this process, we can write a function that accepts stock data in
    the and outputs the histogram of daily returns along with the percentages that
    fall within 1, 2, and 3 standard deviations from the mean. The following function
    does this and replaces the methods with their symbol counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9401919f-736c-480a-ba3a-d67a05852b7e.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation of the `pct_change` Series method ([http://bit.ly/2wcjmqT](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.pct_change.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving readability of boolean indexing with the query method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean indexing is not necessarily the most pleasant syntax to read or write,
    especially when using a single line to write a complex filter. Pandas has an alternative
    string-based syntax through the DataFrame `query` method that can provide more
    clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The `query` DataFrame method is experimental and not as capable as boolean indexing
    and should not be used for production code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe replicates the earlier recipe in this chapter, *Translating SQL
    WHERE clauses,* but instead takes advantage of the `query` DataFrame method. The
    goal here is to filter the employee data for female employees from the police
    or fire departments that earn a salary between 80 and 120 thousand dollars.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the employee data, assign the chosen departments, and import columns
    to variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the query string and execute the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/594a1364-103c-4ce5-be63-1f12a5cc7b17.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings passed to the `query` method are going to look more like plain English
    than normal pandas code. It is possible to reference Python variables using the
    at symbol (`@`) as with `depts`. All DataFrame column names are available in the
    query namespace by simply referencing their name without inner quotes. If a string
    is needed, such as `Female`, inner quotes will need to wrap it.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice feature of the `query` syntax is the ability to write a double
    inequality in a single expression and its ability to understand the verbose logical
    operators `and`, `or`, and `not` instead of their bitwise equivalents as with
    boolean indexing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of manually typing in a list of department names, we could have programmatically
    created it. For instance, if we wanted to find all the female employees that were
    not a member of the top 10 departments by frequency, we can run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/04c5bb6f-52a6-44d6-9cc7-862e08c0bc15.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation on the `query` method ([http://bit.ly/2vnlwXk](http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-query))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving Series with the where method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean indexing necessarily filters your dataset by removing all the rows that
    don't match the criteria. Instead of dropping all these values, it is possible
    to keep them using the `where` method. The `where` method preserves the size of
    your Series or DataFrame and either sets the values that don't meet the criteria
    for missing or replaces them with something else.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we pass the `where` method boolean conditions to put a floor
    and ceiling on the minimum and maximum number of Facebook likes for actor 1 in
    the `movie` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the `movie` dataset, set the movie title as the index, and select all
    the values in the `actor_1_facebook_likes` column that are not missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `describe` method to get a sense of the distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we may plot a histogram of this Series to visually inspect the
    distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/18859e7b-eebe-49f7-aed5-c7511b01f94f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is quite a bad visualization and very difficult to get a sense of the
    distribution. On the other hand, the summary statistics from step 2 appear to
    be telling us that it is highly skewed to the right with many observations more
    than an order of magnitude greater than the median. Let''s create criteria to
    test whether the number of likes is less than 20,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'About 91% of the movies have an actor 1 with fewer than 20,000 likes. We will
    now use the `where` method, which accepts a boolean condition. The default behavior
    is to return a Series the same size as the original but which has all the `False`
    locations replaced with a missing value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter to the `where` method, `other`, allows you to control
    the replacement value. Let''s change all the missing values to 20,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can create criteria to put a floor on the minimum number of likes.
    Here, we chain another `where` method and replace the values not meeting with
    the condition to `300`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of the original Series and modified Series is the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make a histogram with the modified Series. With the data in a much tighter
    range, it should produce a better plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7322581b-6241-4bb8-a3b4-b24ea9bf7644.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `where` method again preserves the size and shape of the calling object
    and does not modify the values where the passed boolean is `True`. It was important
    to drop the missing values in step 1 as the `where` method would have eventually
    replaced them with a valid number in future steps.
  prefs: []
  type: TYPE_NORMAL
- en: The summary statistics in step 2 give us some intuition where it would make
    sense to cap our data. The histogram from step 3, on the other hand, appears to
    clump all the data into one bin. The data has too many outliers for a plain histogram
    to make a good plot. The `where` method allows us to place a ceiling and floor
    on our data, which results in a histogram with many more visible bars.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pandas actually has built-in methods `clip`, `clip_lower`, and `clip_upper`
    that replicate this operation. The `clip` method can set a floor and ceiling at
    the same time. We also check whether this alternate method produces the exact
    same Series, which it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation on the `where` method ([http://bit.ly/2vmW2cv](http://bit.ly/2vmW2cv))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking DataFrame rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `mask` method performs the exact opposite operation that the `where` method
    does. By default, it creates missing values wherever the boolean condition is
    `True`. In essence, it is literally masking, or covering up, values in your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will mask all rows of the movie dataset that were made after
    2010 and then filter all the rows with missing values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the `movie` dataset, set the movie title as the index, and create the
    criteria:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `mask` method on a DataFrame to make all the values in rows with movies
    that were made from 2010 onward missing. Any movie that originally had a missing
    value for `title_year` is also masked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d7b0fdac-c4b2-4d31-9594-7c8d776fb964.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how all the values in the third, fourth, and fifth rows from the preceding
    DataFrame are missing. Chain the `dropna` method to remove rows that have all
    values missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d9027ba6-fe62-4ba4-971f-70bfc54f599b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The operation in step 3 is just a complex way of doing basic boolean indexing.
    We can check whether the two methods produce the same DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equals` method is telling us that they aren''t equal. Something is wrong.
    Let''s do some sanity checking and see if they are the same shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'When we used the preceding `mask` method, it created many missing values. Missing
    values are `float` data types so any previous integer column is now a float. The
    `equals` method returns `False` if the data types of the columns are different,
    even if the values are the same. Let''s check the equality of the data types to
    see whether this scenario happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that a couple of columns don''t have the same data type. Pandas
    has an alternative for these situations. In its testing module, which is primarily
    used by developers, there is a function, `assert_frame_equal`, that allows you
    to check the equality of Series and DataFrames without also checking the equality
    of the data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `mask` method covers up data with missing values. The first
    parameter to the `mask` method is the condition which is often a boolean Series
    such as `criteria`. Because the `mask` method is called from a DataFrame, all
    the values in each row where the condition is `False` change to missing. Step
    3 uses this masked DataFrame to drop the rows that contain all missing values.
    Step 4 shows how to do this same procedure with boolean indexing.
  prefs: []
  type: TYPE_NORMAL
- en: During a data analysis, it is very important to continually validate results.
    Checking the equality of Series and DataFrames is an extremely common approach
    to validation. Our first attempt, in step 4, yielded an unexpected result. Some
    basic sanity checking, such as ensuring that the number of rows and columns are
    the same or that the row and column names are the same, are good checks before
    going deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 compares the two Series of data types together. It is here where we uncover
    the reason why the DataFrames were not equivalent. The `equals` method checks
    that both the values and data types are the same. The `assert_frame_equal` function
    from step 7 has many available parameters to test equality in a variety of ways.
    Notice that there is no output after calling `assert_frame_equal`. This method
    returns None when the two passed DataFrames are equal and raises an error when
    they are not.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s compare the speed difference between masking and dropping missing rows
    and boolean indexing. Boolean indexing is about an order of magnitude faster in
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation on `assert_frame_equal` ([http://bit.ly/2u5H5Yl](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.testing.assert_frame_equal.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python official documentation of the `assert` statement ([http://bit.ly/2v1YKmY](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting with booleans, integer location, and labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 10](3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml), *Selecting Subsets
    of Data*, covered a wide range of recipes on selecting different subsets of data
    through the `.iloc` and `.loc` indexers. Both these indexers select rows and columns
    simultaneously by either integer location or label. Both these indexers can also
    do data selection through boolean indexing, even though booleans are not integers
    and not labels.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will filter both rows and columns with boolean indexing for
    both the `.iloc` and `.loc` indexers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the movie dataset, set the index as the title, and then create a boolean
    Series matching all movies with a content rating of `G` and an IMDB score less
    than `4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first pass these criteria to the `.loc` indexer to filter the rows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c1f67118-c501-4567-898e-2955ae52f71b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether this DataFrame is exactly equal to the one generated directly
    from the indexing operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s attempt the same boolean indexing with the `.iloc` indexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that we cannot directly use a Series of booleans because of the
    index. We can, however, use ndarray of booleans. To extract the array, use the
    `values` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Although not very common, it is possible to do boolean indexing to select particular
    columns. Here, we select all the columns that have a data type of 64-bit integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3d5a5522-27c6-4a1f-8c09-ea6f01ac522f.png)'
  prefs: []
  type: TYPE_IMG
- en: As `criteria_col` is a Series, which always has an index, you must use the underlying
    ndarray to make it work with `.iloc`. The following produces the same result as
    step 6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'A boolean Series may be used to select rows and then simultaneously select
    columns with either integers or labels. Remember, you need to put a comma between
    the row and column selections. Let''s keep the row criteria and select `content_rating`,
    `imdb_score`, `title_year`, and `gross`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/dadc8ffc-c00e-4c21-9dbe-756c1ca4294b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same operation may be replicated with `.iloc`, but you need to get the
    integer location of all the columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boolean indexing may be accomplished with both the `.iloc` and `.loc` indexers
    with the caveat that `.iloc` cannot be passed a Series but the underlying ndarray.
    Let''s take a look at the one-dimensional ndarray underlying the criteria Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The array is the same length as the Series, which is the same length as the
    movie DataFrame. The integer location for the boolean array aligns with the integer
    location of the DataFrame and the filter happens as expected. These arrays also
    work with the `.loc` operator as well but they are a necessity for `.iloc`.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 6 and 7 show how to filter by columns instead of by rows. The colon, `:`,
    is needed to indicate the selection of all the rows. The comma following the colon
    separates the row and column selections. There is actually a much easier way to
    select columns with integer data types and that is through the `select_dtypes`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 8 and 9 show a very common and useful way to do boolean indexing on the
    row and column selections simultaneously. You simply place a comma between the
    row and column selections. Step 9 uses a list comprehension to loop through all
    the desired column names to find their integer location with the index method `get_loc`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is actually possible to pass arrays and lists of booleans to Series objects
    that are not the same length as the DataFrame you are doing the indexing on. Let''s
    look at an example of this by selecting the first and third rows, and the first
    and fourth columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/07c9bc12-0cc4-4402-bc01-fda1e8ee7958.png)'
  prefs: []
  type: TYPE_IMG
- en: Both of the boolean lists are not the same length as the axis they are indexing.
    The rest of the rows and columns not explicitly given a boolean value in the lists
    are dropped.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Selecting data with both integers and labels* recipe from [Chapter
    10](3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml), *Selecting Subsets of Data*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
