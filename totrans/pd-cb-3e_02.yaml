- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection and Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to create a `pd.Series` and `pd.DataFrame`,
    and we also looked at their relationship to the `pd.Index`. With a foundation
    in *constructors*, we now shift focus to the crucial processes of *selection*
    and *assignment*. Selection, also referred to as *indexing*, is considered a *getter*;
    i.e., it is used to retrieve values from a pandas object. Assignment, by contrast,
    is a *setter* that is used to update values.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter start out by showing you how to retrieve values
    from `pd.Series` and `pd.DataFrame` objects, with ever-increasing complexity.
    We will eventually introduce the `pd.MultiIndex`, which can be used to select
    data hierarchically, before finally ending with an introduction to the assignment
    operators. The pandas API takes great care to reuse many of the same methods for
    selection and assignment, which ultimately allows you to be very expressive in
    how you would like to interact with your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be adept at efficiently retrieving data
    from and updating values within your pandas objects. We are going to cover the
    following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic selection from a Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic selection from a DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Position-based selection of a Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Position-based selection of a DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Label-based selection from a Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Label-based selection from a DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing position-based and label-based selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame.filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection by data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection/filtering via Boolean arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection with a MultiIndex – A single level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection with a MultiIndex – Multiple levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection with a MultiIndex – a DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item assignment with .loc and .iloc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame column assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic selection from a Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection from a `pd.Series` involves accessing elements either by their position
    or by their label. This is akin to accessing elements in a list by their index
    or in a dictionary by their key, respectively. The versatility of the `pd.Series`
    object allows intuitive and straightforward data retrieval, making it an essential
    tool for data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: The `pd.Series` is considered a *container* in Python, much like the built-in
    `list`, `tuple`, and `dict` objects. As such, for simple selection operations,
    the first place users turn to is the Python index operator, using the `[]` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To introduce the basics of selection, let’s start with a very simple `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, you’ve already discovered that the `[]` operator can be used to
    select elements from a *container*; i.e., `some_dictionary[0]` will give you the
    value associated with a key of 0\. With a `pd.Series`, basic selection behaves
    similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the expression `ser[3]`, pandas tries to find the label 3 in the index
    of the `pd.Series` and, assuming only one match, returns the value associated
    with that label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of selecting the associated value from the `pd.Series`, alternatively,
    you may want a `pd.Series` returned, as doing so helps you keep the label 3 associated
    with the data element “a.” With pandas, you can do this by providing a list argument
    that contains a single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Expanding on the usage of a list argument, you can select multiple values from
    the `pd.Series` if your list contains multiple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you use the default index, you can use slice arguments that work very
    similarly to slicing a Python list. For example, to get up to (but not including)
    the element at position 3 of a `pd.Series`, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative slice indexers are not a problem for pandas. The following code will
    select the last four elements of the `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even provide slices with *start* and *stop* arguments. The following
    code will retrieve all elements of the `pd.Series`, starting in position 2 and
    up to (but not including) position 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This final example on slices uses *start*, *stop* and *step* arguments to grab
    every third element, starting at position 1 and stopping when position 8 is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Selection still works when providing your own `pd.Index` values. Let’s create
    a small `pd.Series` with string index labels to illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Selection via `ser["Jill"]` will scan the index for the string `Jill` and return
    the corresponding element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, providing a single-element list argument will ensure that you receive
    a `pd.Series` in return instead of a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common pitfall when using the `[]` operator is to assume that selection with
    integer arguments works the same as when selecting from a Python list. This is
    *only* true when you use the default `pd.Index`, which is auto-numbered, starting
    at 0 (this is technically called a `pd.RangeIndex`).
  prefs: []
  type: TYPE_NORMAL
- en: 'When not using a `pd.RangeIndex`, extra attention must be paid to the behavior.
    To illustrate, let’s start with a small `pd.Series`, which still uses integers
    in its `pd.Index`, but does not use an auto-incrementing sequence that starts
    at 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that an integer argument selects by *label* and not
    by *position*; i.e., the following code will return the value associated with
    a label of 2, not the value in position 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While the integer argument matches by label and not by position, slicing still
    works positionally. The following example does not stop when encountering the
    number 2 and, instead, gives the first two elements back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Users should also be familiar with selection behavior when working with a non-unique
    `pd.Index`. Let’s create a small `pd.Series` where the number 1 appears twice
    in our row index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this `pd.Series`, attempting to select the number 1 will *not* return
    a single value and, instead, return another `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The fact that a selection like `ser[1]` can be thought to be done by position
    or label interchangeably when using the default `pd.RangeIndex` but, in actuality,
    selects by label with other `pd.Index` types can be the source of subtle bugs
    in user programs. Many users may *think* they are selecting the *n*^(th) element,
    only to have that assumption break when their data changes. To resolve the ambiguity
    between wanting to select by *label* or by *position* with an integer argument,
    it is **highly recommended** to leverage the `.loc` and `.iloc` methods introduced
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Basic selection from a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the `[]` operator with a `pd.DataFrame`, simple selection typically
    involves selecting data from the *column index* rather than the *row index*. This
    distinction is crucial for effective data manipulation and analysis. Columns in
    a `pd.DataFrame` can be accessed by their labels, making it easy to work with
    named data from a `pd.Series` within the larger `pd.DataFrame` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding this fundamental difference in selection behavior is key to utilizing
    the full power of a `pd.DataFrame` in pandas. By leveraging the `[]` operator,
    you can efficiently access and manipulate specific columns of data, setting the
    stage for more advanced operations and analyses.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a simple 3x3 `pd.DataFrame`. The values of the `pd.DataFrame`
    are not important, but we are intentionally going to provide our own column labels
    instead of having pandas create an auto-numbered column index for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To select a single column, use the `[]` operator with a scalar argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To select a single column but still get back a `pd.DataFrame` instead of a
    `pd.Series`, pass a single-element list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple columns can be selected using a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In all of these examples, the arguments for `[]` have been selected from the
    columns, but providing a slice argument exhibits different behavior and will actually
    select from rows. Note that the following example selects all columns and the
    first two rows of data, not the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using a list argument for the `[]` operator, you have the flexibility
    to specify the order of columns in the output. This allows you to customize the
    `pd.DataFrame` to suit your needs. The order of columns in the output will exactly
    match the order of labels provided as input. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Swapping the order of the elements in the list as an argument to `[]` will
    swap the order of the columns in the resulting `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This feature is particularly useful when you need to reorder columns for presentation
    purposes, or when preparing data for export to CSV or Excel formats where a specific
    column order is required (see *Chapter 4*, *The pandas I/O System,* for more on
    the pandas I/O system).
  prefs: []
  type: TYPE_NORMAL
- en: Position-based selection of a Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed back in the *Basic selection from a DataFrame* section, using `[]`
    as a selection mechanism does not signal the clearest intent and can sometimes
    be downright confusing. The fact that `ser[42]` selects from a *label* matching
    the number 42 and not the 42^(nd) row of a `pd.Series` is a common mistake for
    new users, and such an ambiguity can grow even more complex as you start trying
    to select two dimensions with the `[]` operator from a `pd.DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: To clearly signal that you are trying to select by *position* instead of by
    *label*, you should use `pd.Series.iloc`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.Series` where we have an index using integral labels that
    are also non-unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To select a scalar, you can use `pd.Series.iloc` with an integer argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same patterns we have seen before, turning that integer argument
    into a list containing a single element will return a `pd.Series` instead of a
    scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple integers in the list argument will select multiple elements of the
    `pd.Series` by position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Slices are a natural way of expressing a range of elements that you would select,
    and they pair very nicely as an argument to `pd.Series.iloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Position-based selection of a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much like with a `pd.Series`, integers, lists of integers, and slice objects
    are all valid arguments to `DataFrame.iloc`. However, with a `pd.DataFrame`, two
    arguments are required. The first argument handles selecting from the *rows*,
    and the second is responsible for the *columns*.
  prefs: []
  type: TYPE_NORMAL
- en: In most use cases, users reach for position-based selection when retrieving
    rows and label-based selection when retrieving columns. We will cover the latter
    in the *Label-based selection from a DataFrame* section and will show you how
    to combine both in the *Mixing position-based and label-based selection* section.
    However, when your row index uses the default `pd.RangeIndex` and the order of
    columns is significant, the techniques shown in this section will be of immense
    value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.DataFrame` with five rows and four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing two integer arguments to `pd.DataFrame.iloc` will return a scalar from
    that row and column position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may not want to select individual values from a particular
    axis, opting instead for everything that axis has to offer. An empty slice object,
    `:`, allows you to do this; i.e., if you wanted to select *all* rows of data from
    the first column of a `pd.DataFrame`, you would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Flipping the order of the arguments to `pd.DataFrame.iloc` will change behavior.
    Instead of grabbing all rows for the first column, the below code selects all
    columns and only the first row of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the preceding examples only return one dimension of data, they implicitly
    attempt to *squeeze* the return value from a `pd.DataFrame` down to a `pd.Series`.
    Following the patterns we have seen many times already in this chapter, you can
    prevent that implicit dimensionality reduction by passing a single-element list
    argument for the axis, which is not an empty slice. For example, to select all
    rows for the first column but still get back a `pd.DataFrame`, you would opt for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Reversing those arguments gives us the first row and all columns back as a
    `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists can be used to select multiple elements from both the rows and columns.
    If we wanted the first and second rows paired with the last and second-to-last
    columns of our `pd.DataFrame`, you could opt for an expression like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Empty slices are valid arguments to `.iloc`. Both `ser.iloc[:]` and `df.iloc[:,
    :]` will return everything from each axis, essentially giving you a copy of the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Label-based selection from a Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In pandas, `pd.Series.loc` is used to perform selection by label instead of
    by position. This method is particularly useful when you consider the `pd.Index`
    of your `pd.Series` to contain lookup values, much like the key in a Python dictionary,
    rather than giving importance to the order or position of data in your `pd.Series`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.Series` where we have a row index using integral labels
    that are also non-unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.Series.loc` will select all rows where the index has a label of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you are not limited to integral labels in pandas. Let’s see what
    this looks like with a `pd.Index` composed of string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.Series.loc` can select all rows where the index has a label of `"dog"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all rows where the index has a label of `"dog"` or `"cat"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to select all rows up to and including the label `"cat"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding label-based selection with `pd.Series.loc` provides powerful capabilities
    to access and manipulate data in a `pd.Series`. While this method may seem straightforward,
    it offers nuances and behaviors that are important to grasp for effective data
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: A very common mistake for users of all experience levels with pandas is to overlook
    the differences in behavior that slicing with `pd.Series.loc` has, compared to
    slicing in standard Python and the `pd.Series.iloc` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To walk through this, let’s create a small Python list and a `pd.Series` with
    the same data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have already seen with lists and other containers built into the Python
    language, slicing returns values up to *but not including* the provided position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing with `pd.Series.iloc` matches this behavior, returning a `pd.Series`
    with the same exact length and elements as the Python list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'But slicing with `pd.Series.loc` actually produces a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'What is going on here? To try and get a grasp on this, it is important to remember
    that `pd.Series.loc` matches by label, not by position. The pandas library does
    something akin to a loop over each element in the `pd.Series` and its accompanying
    `pd.Index`, stopping at the point where it finds the value of 2 in the index.
    However, pandas cannot guarantee that there is only one value in the `pd.Index`
    with the value of 2, so it must continue going until it finds *something else*.
    You can see that in action if you try the same selection with a `pd.Series` that
    repeats the index label 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This can seem downright devious if you expect your row index to contain integers,
    but the main use case for `pd.Series.loc` is for working with a `pd.Index` where
    position/ordering is not important (for that, use `pd.Series.iloc`). Taking string
    labels as a more practical example, the slicing behavior of `pd.Series.loc` becomes
    more natural. The following code can essentially be thought of as asking pandas
    to loop over the `pd.Series` until the label `"xxx"` is found in the row index,
    continuing until a new label is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In certain cases where you try to slice with `pd.Series.loc` but the index
    labels have no determinate ordering, pandas will end up raising an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Label-based selection from a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed back in the *Position-based selection of a DataFrame* section,
    the most common use case with a `pd.DataFrame` is to use label-based selection
    when referring to columns and position-based selection when referring to rows.
    However, this is not an absolute requirement, and pandas allows you to use label-based
    selection from both the rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: When compared to other data analysis tools, the ability to select by label from
    the rows of a `pd.DataFrame` is a unique advantage to pandas. For users familiar
    with SQL, there is no real equivalent to this provided by the language; columns
    are very easy to select when placed in a `SELECT` clause, but rows can only be
    filtered via a `WHERE` clause. For users adept at Microsoft Excel, you could create
    two-dimensional structures using a pivot table, with both row labels and column
    labels, but your ability to select or refer to data within that pivot table is
    effectively limited.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will introduce selection for very small `pd.DataFrame` objects to
    get a feel for the syntax. In *Chapter 8*, *Reshaping Data Frames*, we will explore
    ways that you can create meaningful `pd.DataFrame` objects where row and column
    labels are significant. Combined with the knowledge introduced in this section,
    you will come to appreciate how unique this type of selection is to pandas, as
    well as how it can help you explore data in meaningful ways that other tools cannot
    express.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.DataFrame` where we have indices composed of strings in
    both the rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.DataFrame.loc` can select by the row and column label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all rows from the column with the label `"age"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all columns from the row with the label `"Jack"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all rows from the column with the label `"age"`, maintaining the
    `pd.DataFrame` shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all columns from the row with the label `"Jack"`, maintaining the
    `pd.DataFrame` shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'To select both rows and columns using lists of labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Mixing position-based and label-based selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `pd.DataFrame.iloc` is used for position-based selection and `pd.DataFrame.loc`
    is for label-based selection, users must take an extra step if attempting to select
    by label in one dimension and by position in another. As mentioned in previous
    sections, the majority of `pd.DataFrame` objects constructed will place heavy
    significance on the labels used for the columns, with little care for how those
    columns are ordered. The inverse is true for the rows, so being able to effectively
    mix and match both styles is of immense value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a `pd.DataFrame` that uses the default auto-numbered `pd.RangeIndex`
    in the rows but has custom string labels for the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pd.Index.get_indexer` method can help us convert a label or list of labels
    into their corresponding positions in a `pd.Index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This can subsequently be used as an argument to `.iloc`, ensuring that you
    use position-based selection across both the rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using `pd.Index.get_indexer`, you can split this expression up into
    a few steps, with one of the steps performing index-based selection and the other
    performing label-based selection. And if you did this, you’d end up getting the
    exact same result as shown above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: There’s a strong argument to be made that this is more expressive than using
    `pd.Index.get_indexer`, which developers of all experience levels with pandas
    would agree with. So why even bother with `pd.Index.get_indexer`?
  prefs: []
  type: TYPE_NORMAL
- en: 'While these appear the same on the surface, how pandas computes the result
    is drastically different. Adding some timing benchmarks to the various methods
    should highlight this. While the exact numbers will vary on your machine, compare
    the timing output of the idiomatic approach described in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'to the approach with separate steps to select by label and then by position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The `pd.Index.get_indexer` approach clocks in faster and should scale better
    to larger datasets. The reason for this is that pandas evaluates its expressions
    *eagerly* or, more specifically, it will do *what you say, when you say it*. The
    expression `df[["age", "eye_color"]].iloc[[0, 1]]` first runs `df[["age", "eye_color"]]`,
    which creates an intermediate `pd.DataFrame`, to which the `.iloc[[0, 1]]` gets
    applied. By contrast, the expression `df.iloc[[0, 1], col_idxer]` performs the
    label-based and position-based selection all in one go, avoiding the creation
    of any intermediate `pd.DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: The contrasting approach to the *eager execution* approach that pandas takes
    is often called *lazy execution*. If you’ve used SQL before, the latter is a good
    example of that; you typically do not instruct the SQL engine on what steps to
    take exactly to produce the desired result. Instead, you *declare* what you want
    your result to look like and leave it up to the SQL database to optimize and execute
    your query.
  prefs: []
  type: TYPE_NORMAL
- en: Will pandas ever support lazy evaluation and optimization? I would posit yes,
    as it would help pandas scale to larger datasets and take the onus away from the
    end user to write optimal queries. However, that capability does not exist today,
    so it is still important for you as a user of the library to understand if the
    code you produce will be processed efficiently or inefficiently.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth considering the context of your data analysis when deciding
    if it is worth trying to combine position/label-based selection in one step, or
    if they are fine as separate steps. In our trivial example, the runtime difference
    of `df.iloc[[0, 1], col_idxer]` versus `df[["age", "eye_color"]].iloc[[0, 1]]`
    is probably not worth caring about in the grander scheme of things, but if you
    were dealing with larger datasets and bottlenecked by performance, the former
    approach could be a lifesaver.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame.filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pd.DataFrame.filter` is a specialized method that allows you to select from
    either the rows or columns of a `pd.DataFrame`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.DataFrame` where we have indices composed of strings in
    both the rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `pd.DataFrame.filter` will select columns matching the label argument(s),
    similar to `pd.DataFrame[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `pd.DataFrame.filter` also accepts an `axis=` argument, which allows
    you to change the axis being selected from. To select rows instead of columns,
    pass `axis=0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not limited to exact string matches against labels. If you would like
    to select any label containing a string, use the `like=` parameter. This example
    will select any column containing an underscore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'If simple string containment is not enough, you can also use regular expressions
    to match index labels with the `regex=` parameter. The following example will
    select any row labels that start with a `"Ja"` but do not end with `"e"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Selection by data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this cookbook, we have *seen* data types, but we have not talked too
    much in depth about what they are. We still aren’t quite there; a deep dive into
    the type system of pandas is reserved for *Chapter 3*, *Data Types*. However,
    for now, you should be aware that the column type provides metadata that `pd.DataFrame.select_dtypes`
    can use for selection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a `pd.DataFrame` that uses integral, floating point, and string
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `pd.DataFrame.select_dtypes` to select only integral columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple types can be selected if you pass a list argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The default behavior is to include the data types you pass in as an argument.
    To exclude them, use the `exclude=` parameter instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Selection/filtering via Boolean arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Boolean lists/arrays (also referred to as *masks*) is a very common method
    to select a subset of rows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a mask of `True=/=False` values alongside a simple `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the mask as an argument to `pd.Series[]` will return each row where the
    corresponding mask entry is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.Series.loc` will match the exact same behavior as `pd.Series[]` in this
    particular case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, whereas `pd.DataFrame[]` usually tries to select from the columns
    when provided a list argument, its behavior with a sequence of Boolean values
    is different. Using the mask we have already created, `df[mask]` will actually
    match along the rows rather than the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to mask the columns alongside the rows, `pd.DataFrame.loc` will
    accept two mask arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commonly, you will manipulate your masks using some combination of the OR,
    AND, or INVERT operators. To see these in action, let’s start with a slightly
    more complicated `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'If our goal was to filter this only to users with blue or green eyes, we could
    first identify which users have blue eyes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we figure out who has green eyes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'and combine those together into one Boolean *mask* using the OR operator, `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'before passing that mask in as an indexer of our `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the OR operator, `|`, you will often commonly use the AND
    operator, `&`. For example, let’s create a filter for records with an age less
    than 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'And also, a height greater than 170:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'These can be ANDed together to only select records that meet both conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The INVERT operator is useful to think of as a NOT operator; i.e., in the context
    of a mask, it will make any `True` value `False` and any `False` value `True`.
    Continuing with our example above, if we wanted to find records that did not satisfy
    the condition of having an age under 40 and a height over 170, we could simply
    invert our mask using `~`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Selection with a MultiIndex – A single level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `pd.MultiIndex` is a subclass of a `pd.Index` that supports hierarchical labels.
    Depending on who you ask, this can be one of the best or one of the worst features
    of pandas. After reading this cookbook, I hope you consider it one of the best.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the derision toward the `pd.MultiIndex` comes from the fact that the
    syntax used to select from it can easily become ambiguous, especially when using
    `pd.DataFrame[]`. The examples below exclusively use the `pd.DataFrame.loc` method
    and avoid `pd.DataFrame[]` to mitigate confusion.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pd.MultiIndex.from_tuples` can be used to construct a `pd.MultiIndex` from
    a list of tuples. In the following example, we create a `pd.MultiIndex` with two
    levels – `first_name` and `last_name`, sequentially. We will pair this alongside
    a very simple `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `pd.Series.loc` with a `pd.MultiIndex` and a scalar argument will match
    against the first level of the `pd.MultiIndex`. The output will not include this
    first level in its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The behavior that drops the first level of the `pd.MultiIndex` in the above
    example is also referred to as *partial slicing*. This concept is similar to the
    dimensionality reduction we saw with `.loc` and `.iloc` in the previous sections,
    with the exception that instead of reducing *dimensions*, pandas here tries to
    reduce the number of *levels* in a `pd.MultiIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this implicit level reduction from occurring, we can once again
    provide a list argument containing a single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Selection with a MultiIndex – Multiple levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things would not be that interesting if you could only select from the first
    level of a `pd.MultiIndex`. Fortunately, `pd.DataFrame.loc` will scale out to
    more than just the first level through the creative use of tuple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s recreate the `pd.Series` from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all records where the first index level uses the label `"Jane"` and
    the second uses `"Doe"`, pass the following tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all records where the first index level uses the label `"Jane"` and
    the second uses `"Doe"`, while maintaining the `pd.MultiIndex` shape, place a
    single element list in the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all records where the first index level uses the label `"John"` and
    the second uses the label `"Smith"`, OR the first level is `"Jane"` and the second
    is `"Doe"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all records where the second index level is `"Doe"`, use an empty
    slice as the first tuple element. Note that this drops the second index level
    and reconstructs the result with a simple `pd.Index` from the first index level
    that remains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all records where the second index level is `"Doe"` while maintaining
    the `pd.MultiIndex` shape, pass a single-element list as the second tuple element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you might be asking yourself the question, what the heck does
    `slice(None)` mean? This rather cryptic expression actually creates a slice object
    without a *start*, *stop*, or *step* value, which is easier to illustrate with
    a simpler Python list – note that the behavior here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'is exactly the same as with `slice(None)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: When a `pd.MultiIndex` expects a tuple argument but doesn’t get one, this issue
    is caused by a slice within a tuple, similar to how `(:,)` is a syntax error in
    Python. The more explicit `(slice(None),)` fixes the issue.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find the `slice(None)` syntax to be unwieldy, pandas provides a convenient
    object called the `pd.IndexSlice` that acts like a tuple but allows you to use
    the more natural `:` notation for slicing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'thus can become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Selection with a MultiIndex – a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `pd.MultiIndex` can be used both as a row index and a column index, and selection
    via `pd.DataFrame.loc` works with both.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.DataFrame` that uses a `pd.MultiIndex` in both the rows
    and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all rows where the second level is `"Smith"` and all columns where
    the second level is `"favorite"`, you will need to pass two tuples where the second
    element in each is the desired label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.DataFrame.loc` always requires two arguments – the first to specify how
    the rows should be indexed and the second to specify how the columns should be
    indexed. When you have a `pd.DataFrame` with a `pd.MultiIndex` in both the rows
    and the columns, you may find it stylistically easier to create separate variables
    for the indexers. The above code could have also been written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Although you could argue that this is more difficult to interpret. As the old
    saying goes, beauty is in the eye of the beholder.
  prefs: []
  type: TYPE_NORMAL
- en: Item assignment with .loc and .iloc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pandas library is optimized for reading, exploring, and evaluating data.
    Operations that try to *mutate* or change data are far less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you must mutate your data, you can use `.loc` and `.iloc` to do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a very small `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.Series.loc` is useful when you want to assign a value by matching against
    the label of an index. For example, if we wanted to store the value `42` where
    our row index contained a value of `"b"`, we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.Series.iloc` is used when you want to assign a value positionally. To assign
    the value `-42` to the second element in our `pd.Series`, we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The cost of mutating data through pandas can depend largely on two factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of array backing a pandas `pd.Series` (*Chapter 3*, *Data Types*, will
    cover data types in more detail)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many objects reference a `pd.Series`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deep dive into those factors is far beyond the scope of this book. For the
    first point above, my general guidance is that the *simpler* an array type is,
    the better your odds are of being able to mutate it without the array contents
    having to be copied, which for larger datasets may be prohibitively expensive.
  prefs: []
  type: TYPE_NORMAL
- en: For the second bullet, a lot of **Copy on Write** (**CoW**) work was involved
    in the pandas 2.x series. CoW is the default behavior in pandas 3.0, and it tries
    to make the behavior of what does and does not get copied when mutating data more
    predictable. For advanced users, I highly encourage giving the pandas CoW documentation
    a read.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame column assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While assigning to *data* can be a relatively expensive operation in pandas,
    assigning columns to a `pd.DataFrame` is a common operation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a very simple `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'New columns can be assigned using the `pd.DataFrame[]` operator. The simplest
    type of assignment can take a scalar value and *broadcast* it to every row of
    the `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also assign a `pd.Series` or sequence as long as the number of elements
    matches the number of rows in the `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new sequence does not match the number of rows in the existing `pd.DataFrame`,
    the assignment will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Assignment can also be done to a `pd.DataFrame` with a `pd.MultiIndex` in the
    columns. Let’s take a look at such a `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign a new column under the `"art"` hierarchy for the number of museums
    seen, pass a tuple argument to `pd.DataFrame.loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Assignment with a `pd.DataFrame` follows the same patterns we saw when selecting
    values with `pd.DataFrame[]` and `pd.DataFrame.loc[]`. The main difference is
    that during selection, you would use `pd.DataFrame[]` and `pd.DataFrame.loc[]`
    on the right-hand side of an expression, whereas with assignment, they appear
    on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pd.DataFrame.assign` method can be used to allow *method chaining* during
    assignment. Let’s start with a simple `pd.DataFrame` to illustrate the utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '*Method chaining* refers to the ability of pandas to apply many algorithms
    in succession to a pandas data structure (algorithms and how to apply them will
    be covered in more detail in *Chapter 5*, *Algorithms and How to Apply Them*).
    So, to take our `pd.DataFrame`, double it, and add 42 to each element, we could
    do something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'But what happens if we want to add a new column as part of this chain of events?
    Unfortunately, with the standard assignment operators, you would have to break
    that chain of events and usually assign a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'But with `pd.DataFrame.assign`, you can continue chaining along. Simply pass
    the desired column label as a keyword to `pd.DataFrame.assign`, whose argument
    is the values you would like to see in the new `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you are limited to using labels that meet Python’s syntax requirements
    for parameter names, and this, unfortunately, does not work with a `pd.MultiIndex`.
    Some users think method chaining makes debugging harder, while others argue that
    method chaining like this makes code easier to read. Ultimately, there is no right
    or wrong answer, and the best advice I can give you for now is to use the form
    you feel most comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/pandas](https://packt.link/pandas)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code5040900042138312.png)'
  prefs: []
  type: TYPE_IMG
