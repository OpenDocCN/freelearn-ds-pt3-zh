["```py\nimport numpy as np #numerical computation\nimport pandas as pd #data wrangling\nimport matplotlib.pyplot as plt #plotting package\n#Next line helps with rendering plots\n%matplotlib inline\nimport matplotlib as mpl #add'l plotting functionality\nimport seaborn as sns #a fancy plotting package\nmpl.rcParams['figure.dpi'] = 400 #high res figures\ndf = pd.read_csv('../../Data/Chapter_1_cleaned_data.csv')\n```", "```py\nitems_to_remove = ['ID', 'SEX',\\\n                   'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', 'PAY_6',\\\n                   'EDUCATION_CAT',\\\n                   'graduate school', 'high school', 'none',\\\n                   'others', 'university']\n```", "```py\nsns.heatmap(corr,\n            xticklabels=corr.columns.values,\n            yticklabels=corr.columns.values,\n            center=0)\n```", "```py\n    X = df[features_response].iloc[:,:-1].values\n    y = df[features_response].iloc[:,-1].values\n    print(X.shape, y.shape)\n    ```", "```py\n    (26664, 17) (26664, )\n    ```", "```py\n    from sklearn.feature_selection import f_classif\n    [f_stat, f_p_value] = f_classif(X, y)\n    ```", "```py\n    f_test_df = pd.DataFrame({'Feature':features_response[:-1],\n                              'F statistic':f_stat,\n                              'p value':f_p_value})\n    f_test_df.sort_values('p value')\n    ```", "```py\n    from sklearn.feature_selection import SelectPercentile\n    ```", "```py\n    selector = SelectPercentile(f_classif, percentile=20)\n    ```", "```py\n    selector.fit(X, y)\n    ```", "```py\n    SelectPercentile(percentile=20)\n    ```", "```py\n    best_feature_ix = selector.get_support()\n    best_feature_ix\n    ```", "```py\n    array([ True, False, False, False, True, False, False, False, False,\n               False, False, True, True, False, False, False, False])\n    ```", "```py\n    features = features_response[:-1]\n    ```", "```py\n    best_features = [features[counter]\n                     for counter in range(len(features))\n                     if best_feature_ix[counter]]\n    best_features\n    ```", "```py\n    ['LIMIT_BAL', 'PAY_1', 'PAY_AMT1', 'PAY_AMT2']\n    ```", "```py\n    overall_default_rate = df['default payment next month'].mean()\n    overall_default_rate\n    ```", "```py\n    0.2217971797179718\n    ```", "```py\n    group_by_pay_mean_y = df.groupby('PAY_1').agg(\n    ```", "```py\n    group_by_pay_mean_y \n    ```", "```py\n    axes = plt.axes()\n    ```", "```py\n    axes.axhline(overall_default_rate, color='red')\n    ```", "```py\n    group_by_pay_mean_y.plot(marker='x', legend=False, ax=axes)\n    ```", "```py\n    axes.set_ylabel('Proportion of credit defaults')\n    axes.legend(['Entire dataset', 'Groups of PAY_1'])\n    ```", "```py\n    pos_mask = y == 1\n    neg_mask = y == 0\n    ```", "```py\n    axes = plt.axes()\n    axes.hist(df.loc[neg_mask, 'LIMIT_BAL'],\\\n              edgecolor='black', color='white')\n    axes.hist(df.loc[pos_mask, 'LIMIT_BAL'],\\\n              alpha=0.5, edgecolor=None, color='black')\n    axes.tick_params(axis='x', labelrotation=45)\n    axes.set_xlabel('Credit limit (NT$)')\n    axes.set_ylabel('Number of accounts')\n    axes.legend(['Not defaulted', 'Defaulted'])\n    axes.set_title('Credit limits by response variable')\n    ```", "```py\n    df['LIMIT_BAL'].max()\n    ```", "```py\n    bin_edges = list(range(0,850000,50000))\n    print(bin_edges)\n    ```", "```py\n    [0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 40000, 450000,\n    500000, 550000, 600000, 650000, 700000, 750000, 800000]\n    ```", "```py\n    mpl.rcParams['figure.dpi'] = 400 \n    axes = plt.axes()\n    axes.hist(\n        df.loc[neg_mask, 'LIMIT_BAL'],\n        bins=bin_edges, density=True,\n        edgecolor='black', color='white')\n    axes.hist(\n        df.loc[pos_mask, 'LIMIT_BAL'],\n        bins=bin_edges, density=True, alpha=0.5,\n        edgecolor=None, color='black')\n    axes.tick_params(axis='x', labelrotation=45)\n    axes.set_xlabel('Credit limit (NT$)')\n    axes.set_ylabel('Proportion of accounts')\n    y_ticks = axes.get_yticks()\n    axes.set_yticklabels(np.round(y_ticks*50000,2))\n    axes.legend(['Not defaulted', 'Defaulted'])\n    axes.set_title('Normalized distributions of '\\\n                   'credit limits by response variable')\n    ```", "```py\nnp.mean([1, 2, 3, 4, 5])\n3.0\n```", "```py\ndef my_mean(input_argument):\n    output = sum(input_argument)/len(input_argument)\n    return(output)\n```", "```py\nmy_mean([1, 2, 3, 4, 5])\n3.0\n```", "```py\nmy_mean(input_argument=[1, 2, 3])\n2.0\n```", "```py\nnp.exp(1)\n2.718281828459045\nnp.exp(0)\n1.0\n```", "```py\n    plt.plot(X_exp, Y_exp)\n    plt.title('Plot of $e^X$')\n    ```", "```py\n    Y_exp = np.exp(-X_exp)\n    plt.plot(X_exp, Y_exp)\n    plt.title('Plot of $e^{-X}$')\n    ```", "```py\n    def sigmoid(X):\n        Y = 1 / (1 + np.exp(-X))\n        return Y\n    ```", "```py\n    X_sig = np.linspace(-7,7,141)\n    Y_sig = sigmoid(X_sig)\n    plt.plot(X_sig,Y_sig)\n    plt.yticks(np.linspace(0,1,11))\n    plt.grid()\n    plt.title('The sigmoid function')\n    ```", "```py\n    group_by_pay_mean_y\n    ```", "```py\n    p = group_by_pay_mean_y['default payment next month'].values\n    ```", "```py\n    q = 1-p\n    print(p)\n    print(q)\n    ```", "```py\n    odds_ratio = p/q\n    log_odds = np.log(odds_ratio)\n    log_odds\n    ```", "```py\n    group_by_pay_mean_y.index\n    ```", "```py\n    Int64Index([-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8], dtype='int64', name='PAY_1')\n    ```", "```py\n    plt.plot(group_by_pay_mean_y.index, log_odds, '-x')\n    plt.ylabel('Log odds of default')\n    plt.xlabel('Values of PAY_1')\n    ```", "```py\n    from numpy.random import default_rng\n    rg = default_rng(4)\n    X_1_pos = rg.uniform(low=1, high=7, size=(20,1))\n    print(X_1_pos[0:3])\n    X_1_neg = rg.uniform(low=3, high=10, size=(20,1))\n    print(X_1_neg[0:3])\n    X_2_pos = rg.uniform(low=1, high=7, size=(20,1))\n    print(X_2_pos[0:3])\n    X_2_neg = rg.uniform(low=3, high=10, size=(20,1))\n    print(X_2_neg[0:3])\n    ```", "```py\n    plt.scatter(X_1_pos, X_2_pos, color='red', marker='s')\n    plt.scatter(X_1_neg, X_2_neg, color='blue', marker='x')\n    plt.xlabel(‚$X_1$')\n    plt.ylabel(‚$X_2$')\n    plt.legend(['Positive class', 'Negative class'])\n    ```", "```py\n    X = np.block([[X_1_pos, X_2_pos], [X_1_neg, X_2_neg]])\n    print(X.shape)\n    print(X[0:3])\n    ```", "```py\n    (40, 2)\n    [[6.65833663 5.15531227]\n     [4.06796532 5.6237829  ]\n     [6.85746223 2.14473103]]\n    ```", "```py\n    y = np.vstack((np.ones((20,1)), np.zeros((20,1)))).reshape(40,)\n    print(y[0:5])\n    print(y[-5:])\n    ```", "```py\n    [1\\. 1\\. 1\\. 1\\. 1.]\n    [0\\. 0\\. 0\\. 0\\. 0.]\n    ```", "```py\n    from sklearn.linear_model import LogisticRegression\n    ```", "```py\n    example_lr = LogisticRegression(solver='liblinear')\n    example_lr\n    ```", "```py\n    LogisticRegression(solver='liblinear')\n    ```", "```py\n    example_lr.fit(X, y)\n    ```", "```py\n    y_pred = example_lr.predict(X)\n    positive_indices = [counter for counter in range(len(y_pred))\n                        if y_pred[counter]==1]\n    negative_indices = [counter for counter in range(len(y_pred))\n                        if y_pred[counter]==0]\n    positive_indices\n    ```", "```py\n    [2, 3, 4, 5, 6, 7, 9, 11, 13, 15, 16, 17, 18, 19, 26, 34, 36]\n    ```", "```py\n    plt.scatter(X_1_pos, X_2_pos, color='red', marker='s')\n    plt.scatter(X_1_neg, X_2_neg, color='blue', marker='x')\n    plt.scatter(X[positive_indices,0], X[positive_indices,1],\n                s=150, marker='s',\n                edgecolors='red', facecolors='none')\n    plt.scatter(X[negative_indices,0], X[negative_indices,1],\n                s=150, marker='o',\n                edgecolors='blue', facecolors='none')\n    plt.xlabel('$X_1$')\n    plt.ylabel('$X_2$')\n    plt.legend(['Positive class', 'Negative class',\\\n                'Positive predictions', 'Negative predictions'])\n    ```", "```py\n    theta_1 = example_lr.coef_[0][0]\n    theta_2 = example_lr.coef_[0][1]\n    print(theta_1, theta_2)\n    ```", "```py\n    -0.16472042583006558 -0.25675185949979507\n    ```", "```py\n    theta_0 = example_lr.intercept_\n    ```", "```py\n    X_1_decision_boundary = np.array([0, 10])\n    X_2_decision_boundary = -(theta_1/theta_2)*X_1_decision_boundary\\\n                            - (theta_0/theta_2)\n    ```", "```py\n    pos_true = plt.scatter(X_1_pos, X_2_pos,\n                           color='red', marker='s',\n                           label='Positive class')\n    neg_true = plt.scatter(X_1_neg, X_2_neg,\n                           color='blue', marker='x',\n                           label='Negative class')\n    pos_pred = plt.scatter(X[positive_indices,0],\n                           X[positive_indices,1],\n                           s=150, marker='s',\n                           edgecolors='red', facecolors='none',\n                           label='Positive predictions')\n    neg_pred = plt.scatter(X[negative_indices,0],\n                           X[negative_indices,1],\n                           s=150, marker='o',\n                           edgecolors='blue', facecolors='none',\n                           label='Negative predictions')\n    dec = plt.plot(X_1_decision_boundary, X_2_decision_boundary,\n                   'k-', label='Decision boundary')\n    plt.xlabel('$X_1$')\n    plt.ylabel('$X_2$')\n    plt.legend(loc=[0.25, 1.05])\n    ```"]