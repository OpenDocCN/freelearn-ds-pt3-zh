<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer112">
    <h1 class="chapterNumber">7</h1>
    <h1 class="chapterTitle" id="_idParaDest-83">Exploring Streamlit Components</h1>
    <p class="normal">So far in this book, we have explored features that have been developed by the Streamlit core development team, who works full-time on these new and exciting features. This chapter, however, will focus on community-driven development, through Streamlit Components. While building Streamlit, the team created an established method for other developers to create additional features on top of all the existing Streamlit open-source magic we have already seen. This method is called Components! Streamlit Components allow developers the flexibility to go out and make features that are crucial to their workflows or are just simply fun and interesting. </p>
    <p class="normal">As Streamlit has become increasingly popular as a framework, so have its Components. It feels like every day, I see a new and interesting component that I want to try out on my own apps! This chapter will be focused on how to both find and use community-made Streamlit Components. </p>
    <p class="normal">In this chapter, we will cover the following six Streamlit Components:</p>
    <ul>
      <li class="bulletList">Adding editable DataFrames with <code class="inlineCode">streamlit-aggrid</code> </li>
      <li class="bulletList">Creating drill-down graphs with <code class="inlineCode">streamlit-plotly-events</code></li>
      <li class="bulletList">Creating beautiful GIFs with <code class="inlineCode">streamlit-lottie</code> </li>
      <li class="bulletList">Automated analysis with <code class="inlineCode">pandas-profiling</code></li>
      <li class="bulletList">Interactive maps with <code class="inlineCode">st-folium</code> </li>
      <li class="bulletList">Helpful mini-functions with <code class="inlineCode">streamlit-extras</code></li>
      <li class="bulletList">Finding more Components</li>
    </ul>
    <p class="normal">Let’s look at the technical requirements in the next section.</p>
    <h1 class="heading-1" id="_idParaDest-84">Technical requirements</h1>
    <p class="normal">Before we can work with new Streamlit Components, we need to download them first. We can download each using <code class="inlineCode">pip</code> (or any other package manager), just as we did with Streamlit in <em class="chapterRef">Chapter 1, </em><em class="italic">An Introduction to Streamlit</em>. These are the Components to be downloaded:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">streamlit-aggrid </code></li>
      <li class="bulletList"><code class="inlineCode">streamlit-plotly-events</code></li>
      <li class="bulletList"><code class="inlineCode">streamlit-lottie </code></li>
      <li class="bulletList"><code class="inlineCode">streamlit-pandas-profiling</code></li>
      <li class="bulletList"><code class="inlineCode">streamlit-folium</code></li>
      <li class="bulletList"><code class="inlineCode">streamlit-extras</code></li>
    </ul>
    <p class="normal">To try out all of these libraries, we’re going to create a multi-page app with each library as a self-contained Streamlit app. We will try this out in a new folder, which we’ll call <code class="inlineCode">components_example</code>. For our multi-page app, we need a folder called <code class="inlineCode">pages</code>, and for our first library (<code class="inlineCode">streamlit-aggrid</code>), we will need to add a Python file called <code class="inlineCode">aggrid.py</code> inside the <code class="inlineCode">pages</code> folder. We’ll be using data from both the penguins and trees datasets that we have already used, so copy those into the folder as well. </p>
    <p class="normal">At the end of all that, your <code class="inlineCode">components_example</code> folder should look like this: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_01.png"/></figure>
    <p class="packt_figref">Figure 7.1: Folder Structure</p>
    <p class="normal">Within <code class="inlineCode">streamlit_app.py</code>, we can add the following code to inform the user that all the examples live within the rest of the multi-page app: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"Streamlit Components Examples"</span>)
st.write(
    <span class="hljs-string">"""This app contains examples of </span>
<span class="hljs-string">    Streamlit Components, find them </span>
<span class="hljs-string">    all in the sidebar!"""</span>
)
</code></pre>
    <p class="normal">Now, onto <code class="inlineCode">streamlit-aggrid</code>! </p>
    <h1 class="heading-1" id="_idParaDest-85">Adding editable DataFrames with streamlit-aggrid </h1>
    <p class="normal">We have <a id="_idIndexMarker262"/>already used a few methods for <a id="_idIndexMarker263"/>showing DataFrames in our Streamlit apps, such as the built-in <code class="inlineCode">st.write</code> and <code class="inlineCode">st.dataframe</code> functions. We also covered the experimental editable DataFrame that Streamlit released in version 1.19, which is not as feature-rich in comparison to <code class="inlineCode">streamlit-aggrid</code> but is significantly easier to use! <code class="inlineCode">streamlit-aggrid</code> essentially creates a beautiful, interactive, and editable version of <code class="inlineCode">st.dataframe</code>, and is <a id="_idIndexMarker264"/>built on top of a JavaScript product called <code class="inlineCode">AgGrid</code> (<a href="https://www.ag-grid.com/"><span class="url">https://www.ag-grid.com/</span></a>).</p>
    <p class="normal">The best way to understand this library is to give it a shot! Let’s start by using the example of the penguins dataset, with the desire to make an interactive and editable DataFrame, which <code class="inlineCode">AgGrid</code> is so good at. </p>
    <p class="normal">Within <code class="inlineCode">aggrid.py</code>, we can pull in the penguins data, and use the central function in <code class="inlineCode">streamlit-aggrid</code> called <code class="inlineCode">AgGrid</code> to display the data in our Streamlit app. The code looks like this: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> st_aggrid <span class="hljs-keyword">import</span> AgGrid
st.title(<span class="hljs-string">"Streamlit AgGrid Example: Penguins"</span>)
penguins_df = pd.read_csv(<span class="hljs-string">"penguins.csv"</span>)
AgGrid(penguins_df)
</code></pre>
    <p class="normal">This gets us to 80% of our desired solution. It creates an app with a whole host of features! This app looks like this as of now:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_02.png"/></figure>
    <p class="packt_figref">Figure 7.2: AgGrid Example</p>
    <p class="normal">If you click<a id="_idIndexMarker265"/> on each column it comes with<a id="_idIndexMarker266"/> an auto-filtering mechanism, the ability to sort by value, show and hide columns, etc. For example, we can filter the <strong class="screenText">species</strong> column in our dataset to only include the <strong class="screenText">Chinstrap</strong> value, and the DataFrame responds as shown in the following screenshot: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_03.png"/></figure>
    <p class="packt_figref">Figure 7.3: First Filter</p>
    <p class="normal">I would<a id="_idIndexMarker267"/> encourage you to play around with the <a id="_idIndexMarker268"/>features in <code class="inlineCode">AgGrid</code> to see the full set of possibilities. One thing that you might notice is that it shows the entire DataFrame by default. I find this to be a little bit jarring for a Streamlit app, but luckily, there is a <code class="inlineCode">height</code> parameter in <code class="inlineCode">streamlit-aggrid</code> to force the DataFrame to fit within a specific height. See the following code for how to ensure this: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> st_aggrid <span class="hljs-keyword">import</span> AgGrid
st.title(<span class="hljs-string">"Streamlit AgGrid Example: Penguins"</span>)
penguins_df = pd.read_csv(<span class="hljs-string">"penguins.csv"</span>)
AgGrid(penguins_df, height=<span class="hljs-number">500</span>)
</code></pre>
    <p class="normal">The last feature that we have already discussed but have not shown off yet is the ability to edit DataFrames within AgGrid. Again, it is as easy as adding a parameter to the AgGrid function. The function returns the edited DataFrame, which we can use in the rest of our app. This means that the component is bidirectional, just like all the Streamlit input widgets we have already used. This next bit of code adds the edit functionality and also shows how we can access the edited DataFrame: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> st_aggrid <span class="hljs-keyword">import</span> AgGrid
st.title(<span class="hljs-string">"Streamlit AgGrid Example: Penguins"</span>)
penguins_df = pd.read_csv(<span class="hljs-string">"penguins.csv"</span>)
st.write(<span class="hljs-string">"AgGrid DataFrame:"</span>)
response = AgGrid(penguins_df, height=<span class="hljs-number">500</span>, editable=<span class="hljs-literal">True</span>)
df_edited = response[<span class="hljs-string">"data"</span>]
st.write(<span class="hljs-string">"Edited DataFrame:"</span>)
st.dataframe(df_edited)
</code></pre>
    <p class="normal">From this code, we can see the following app:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_04.png"/></figure>
    <p class="packt_figref">Figure 7.4: Editable DataFrames</p>
    <p class="normal">The above <a id="_idIndexMarker269"/>app is shown after I went in and edited<a id="_idIndexMarker270"/> a single row of the DataFrame, changing the value from <code class="inlineCode">Adelie</code> to <code class="inlineCode">Adelie_example</code>. We can then use that DataFrame in the rest of our app and can do anything from showing a graph based on the edited DataFrame to saving the DataFrame back to a CSV file; the possibilities here are enormous. <code class="inlineCode">streamlit-aggrid</code> is one of the most popular Streamlit Components, and hopefully, you now see why! There are dozens of other features in the library; you can find more of<a id="_idIndexMarker271"/> them at <a href="https://streamlit-aggrid.readthedocs.io/"><span class="url">https://streamlit-aggrid.readthedocs.io/</span></a>. Now, onto drill-down graphs with the next component, <code class="inlineCode">streamlit-plotly-events</code>! </p>
    <h1 class="heading-1" id="_idParaDest-86">Creating drill-down graphs with streamlit-plotly-events </h1>
    <p class="normal">One of the most popular <a id="_idIndexMarker272"/>advanced features in any <a id="_idIndexMarker273"/>plotting library is the ability to drill down into sections or parts of graphs. The users of your apps will often have questions about your data that you have not anticipated in advance! Instead of creating new Streamlit inputs around graphs, users often will want to click on items in your graphs like points or bars, and get more information about that point. For example, in our penguins scatterplot graph, a user might want to see all the data available for a penguin, which is represented by a point being scrolled over in a DataFrame. </p>
    <p class="normal"><code class="inlineCode">streamlit-plotly-events</code> turns the unidirectional <code class="inlineCode">st.plotly_chart</code> function into a bidirectional one, where we can receive events like clicks or hovers back into our Streamlit app. To test this out, we will create another app inside the <code class="inlineCode">pages</code> folder, this one called <code class="inlineCode">plotly_events</code> and will create a graph based on the penguins dataset. </p>
    <p class="normal">To start out, we can import the libraries, read in the data, and make a familiar graph in Plotly: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> streamlit_plotly_events <span class="hljs-keyword">import</span> plotly_events
st.title(<span class="hljs-string">"</span><span class="hljs-string">Streamlit Plotly Events Example: Penguins"</span>)
df = pd.read_csv(<span class="hljs-string">"penguins.csv"</span>)
fig = px.scatter(df, x=<span class="hljs-string">"bill_length_mm"</span>, y=<span class="hljs-string">"bill_depth_mm"</span>, color=<span class="hljs-string">"species"</span>)
plotly_events(fig)
</code></pre>
    <p class="normal">Instead of calling <code class="inlineCode">st.plotly_chart</code>, we replaced it with the <code class="inlineCode">plotly_events</code> function call instead. Other than that, there is no difference between this and our regular use of Plotly. At the moment, this does nothing special, and our app should look fairly standard: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_05.png"/></figure>
    <p class="packt_figref">Figure 7.5: Plotly Chart Original</p>
    <p class="normal">The <code class="inlineCode">plotly_events</code> function<a id="_idIndexMarker274"/> takes an argument <a id="_idIndexMarker275"/>called <code class="inlineCode">click_event</code>, which, if we set it to <code class="inlineCode">true</code>, will return all the click events back to Streamlit as a variable. The next script uses this parameter and writes the click event back to Streamlit: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> streamlit_plotly_events <span class="hljs-keyword">import</span> plotly_events
 
st.title(<span class="hljs-string">"Streamlit Plotly Events Example: Penguins"</span>)
df = pd.read_csv(<span class="hljs-string">"penguins.csv"</span>)
fig = px.scatter(df, x=<span class="hljs-string">"bill_length_mm"</span>, y=<span class="hljs-string">"bill_depth_mm"</span>, color=<span class="hljs-string">"species"</span>)
selected_point = plotly_events(fig, click_event=<span class="hljs-literal">True</span>)
st.write(<span class="hljs-string">"Selected point:"</span>)
st.write(selected_point)
</code></pre>
    <p class="normal">Now <a id="_idIndexMarker276"/>when we run this app and click on <a id="_idIndexMarker277"/>points, we can see the clicked-on value! </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_06.png"/></figure>
    <p class="packt_figref">Figure 7.6: Click Event</p>
    <p class="normal">This is not incredibly special just yet, because Plotly has these points on hover already. We can improve on this by showing all the data we have on the clicked-on point, as shown in the following code (I removed the imports for brevity). We need to stop the app if there are no <a id="_idIndexMarker278"/>points selected; otherwise, the <a id="_idIndexMarker279"/>app will error out!</p>
    <pre class="programlisting code"><code class="hljs-code">st.title(<span class="hljs-string">"Streamlit Plotly Events Example: Penguins"</span>)
df = pd.read_csv(<span class="hljs-string">"penguins.csv"</span>)
fig = px.scatter(df, x=<span class="hljs-string">"bill_length_mm"</span>, y=<span class="hljs-string">"bill_depth_mm"</span>, color=<span class="hljs-string">"species"</span>)
selected_point = plotly_events(fig, click_event=<span class="hljs-literal">True</span>)
<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(selected_point) == <span class="hljs-number">0</span>:
    st.stop()
selected_x_value = selected_point[<span class="hljs-number">0</span>][<span class="hljs-string">"x"</span>]
selected_y_value = selected_point[<span class="hljs-number">0</span>][<span class="hljs-string">"y"</span>]
df_selected = df[
    (df[<span class="hljs-string">"bill_length_mm"</span>] == selected_x_value)
    &amp; (df[<span class="hljs-string">"bill_depth_mm"</span>] == selected_y_value)
]
st.write(<span class="hljs-string">"Data for selected point:"</span>)
st.write(df_selected)
</code></pre>
    <p class="normal">Now, our final app looks like the following: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_07.png"/></figure>
    <p class="packt_figref">Figure 7.7: Drill-Down Dashboard</p>
    <p class="normal">It really is that easy to turn Plotly charts into drill-down, bidirectional dashboards! In this example, users can see info like the sex and flipper length of the penguins they have selected, and we theoretically could use this selection event however we’d like in the rest of the app. </p>
    <p class="normal">The <code class="inlineCode">streamlit-plotly-events</code> library<a id="_idIndexMarker280"/> has two other events (<code class="inlineCode">select_event</code> and <code class="inlineCode">hover_event</code>), which can be useful as well and are returned<a id="_idIndexMarker281"/> in the same fashion. If you’ve used one of them, you can easily pick up the others when it is necessary. With drill-down dashboards done, let’s move over to adding beautiful animations to our app using <code class="inlineCode">streamlit-lottie</code>!</p>
    <h1 class="heading-1" id="_idParaDest-87">Using Streamlit Components – streamlit-lottie</h1>
    <p class="normal"><strong class="keyWord">Lottie</strong> is a <a id="_idIndexMarker282"/>web-native, open-source library created by <em class="italic">Airbnb </em>to make putting animations on your website just<a id="_idIndexMarker283"/> as easily as putting static images on it. It is very common for large, profitable tech companies to put out open-source software as a way of giving back to the developer community (or, more likely, to recruit developers who think their software is cool), and this is no exception. In this case, <code class="inlineCode">streamlit-lottie</code> wraps around <code class="inlineCode">lottie</code> files and places them directly into our Streamlit apps. </p>
    <p class="normal">Before we try this out for ourselves, we first need to import the <code class="inlineCode">streamlit-lottie</code> library, and then point the <code class="inlineCode">st_lottie()</code> function to our <code class="inlineCode">lottie</code> file. We can either import a local <code class="inlineCode">lottie</code> file or, more likely, we can find a useful animation file on the free site (<a href="https://lottiefiles.com/"><span class="url">https://lottiefiles.com/</span></a>) and load <a id="_idIndexMarker284"/>it from there into our app. </p>
    <p class="normal">To test this out, we can add a cute penguin animation (<a href="https://lottiefiles.com/39646-cute-penguin"><span class="url">https://lottiefiles.com/39646-cute-penguin</span></a>) to the top of the Penguins app that we created earlier in this chapter. To keep everything organized, let’s copy the <code class="inlineCode">plotly_events.py</code> file in its current state to a new file called <code class="inlineCode">penguin_animated.py</code>, also in the <code class="inlineCode">pages</code> folder. We can run the following code from the <code class="inlineCode">components_example</code> folder, or just copy the file over manually: </p>
    <pre class="programlisting con"><code class="hljs-con">cp pages/plotly_events.py pages/penguin_animated.py
</code></pre>
    <p class="normal">Then, in this new file, we can make some changes to the older app. The following code block makes a function, as shown in the example from the <code class="inlineCode">streamlit-lottie</code> library (<a href="https://github.com/andfanilo/streamlit-lottie"><span class="url">https://github.com/andfanilo/streamlit-lottie</span></a>), which allows us to load <code class="inlineCode">lottie</code> files from the URL and then loads this animation at the top of the application: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-comment"># add streamlit lottie</span>
<span class="hljs-keyword">from</span> streamlit_lottie <span class="hljs-keyword">import</span> st_lottie
<span class="hljs-keyword">from</span> streamlit_plotly_events <span class="hljs-keyword">import</span> plotly_events
<span class="hljs-keyword">def</span> <span class="hljs-title">load_lottieurl</span>(<span class="hljs-params">url: </span><span class="hljs-built_in">str</span>):
    r = requests.get(url)
    <span class="hljs-keyword">if</span> r.status_code != <span class="hljs-number">200</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
    <span class="hljs-keyword">return</span> r.json()
lottie_penguin = load_lottieurl(
    <span class="hljs-string">"https://assets9.lottiefiles.com/private_files/lf30_lntyk83o.json"</span>
)
st_lottie(lottie_penguin, height=<span class="hljs-number">200</span>)
st.title(<span class="hljs-string">"Streamlit Plotly Events + Lottie Example: Penguins"</span>)
</code></pre>
    <p class="normal">The remainder of the app will stay the same as with the Plotly events library section. Now when we run the<a id="_idIndexMarker285"/> Streamlit app, we see the animation at the top:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_08.png"/></figure>
    <p class="packt_figref">Figure 7.8: Cute Penguin</p>
    <p class="normal">The previous section of code uses the <code class="inlineCode">requests</code> library to define a function that we can use to load <code class="inlineCode">lottie</code> files from a link. In this case, I have pre-filled a link that takes us to a cute penguin animation. We then loaded our file and called that file using the <code class="inlineCode">st_lottie()</code> function we imported from our <code class="inlineCode">streamlit-lottie</code> library. And as you can see, we have an animation at the top! </p>
    <p class="normal"><code class="inlineCode">streamlit-lottie</code> also allows us to change the animation speed, width, and height through the <code class="inlineCode">speed</code>, <code class="inlineCode">width</code>, and <code class="inlineCode">height</code> parameters, respectively. If the animation goes too slowly for your taste, increase the speed to a number such as <code class="inlineCode">1.5</code> or <code class="inlineCode">2</code>, which will increase the speed by 50% or 100%. The <code class="inlineCode">height</code> and <code class="inlineCode">width</code> parameters, however, are the pixel height/width of the animation and default to the native size of the animation. </p>
    <p class="normal">I would strongly encourage<a id="_idIndexMarker286"/> running this app, as the penguin animation is really quite adorable. And that completes our tour of <code class="inlineCode">streamlit-lottie</code>! I have started getting into the habit of putting a nice animation at the top of each and every Streamlit app I create—it creates a sense of design that makes Streamlit apps feel more purposeful, and immediately alerts the user to the fact that this is not a static document but instead a dynamic and interactive application. </p>
    <h1 class="heading-1" id="_idParaDest-88">Using Streamlit Components – streamlit-pandas-profiling</h1>
    <p class="normal"><code class="inlineCode">pandas-profiling</code> is a very powerful Python library that automates some of the EDA, which is often the first step in any data analysis, modeling, or even data engineering task. Before a data scientist begins almost any data work, they want to start with a good understanding of the distributions of their underlying data, the number of missing rows, correlations between <a id="_idIndexMarker287"/>variables, and many other basic pieces of information. As we mentioned before, this library automates the process and then places this interactive analytics document into a Streamlit app for the user. </p>
    <p class="normal">Behind the Streamlit component called <code class="inlineCode">pandas-profiling</code>, there is a full Python library with the same name, which the component imports its functions from. The Streamlit component here actually renders the output from the <code class="inlineCode">pandas-profiling</code> Python library in a way that becomes very easy to integrate. For this segment, we will first learn how to implement the library, and then explore the generated output. </p>
    <p class="normal">For our example, we will continue with our code from the previous section on Palmer Penguins and add our automatically generated profile to the bottom of the app. The code for this is only a few lines—we need to generate a report for our dataset and then use the Streamlit component to add the generated report to our app. Again, as we did before, copy the code from the <code class="inlineCode">streamlit-lottie</code> section into a new file called <code class="inlineCode">penguin_profiled.py</code>: </p>
    <pre class="programlisting con"><code class="hljs-con">cp pages/penguin_animated.py pages/penguin_profiled.py
</code></pre>
    <p class="normal">The next code block imports the necessary libraries for our profiling! </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> pandas_profiling <span class="hljs-keyword">import</span> ProfileReport
<span class="hljs-keyword">from</span> streamlit_lottie <span class="hljs-keyword">import</span> st_lottie
<span class="hljs-keyword">from</span> streamlit_pandas_profiling <span class="hljs-keyword">import</span> st_profile_report
<span class="hljs-keyword">from</span> streamlit_plotly_events <span class="hljs-keyword">import</span> plotly_events
</code></pre>
    <p class="normal">The middle <a id="_idIndexMarker288"/>section of the app stays the same, so we will not copy all the code here. The end, however, uses the functions that we imported earlier to get a profile of the DataFrame: </p>
    <pre class="programlisting code"><code class="hljs-code">fig = px.scatter(df, x=<span class="hljs-string">"bill_length_mm"</span>, y=<span class="hljs-string">"bill_depth_mm"</span>, color=<span class="hljs-string">"species"</span>)
selected_point = plotly_events(fig, click_event=<span class="hljs-literal">True</span>)
st.subheader(<span class="hljs-string">"Pandas Profiling of Penguin Dataset"</span>)
penguin_profile = ProfileReport(df, explorative=<span class="hljs-literal">True</span>)
st_profile_report(penguin_profile)
</code></pre>
    <p class="normal">Now, we get an entire profile of the penguins dataset, which looks like the following: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_09.png"/></figure>
    <p class="packt_figref">Figure 7.9: The penguin dataset profile</p>
    <p class="normal">This has an <a id="_idIndexMarker289"/>overview section that warns us about variables that are highly correlated or missing data, and even allows us to drill down into specific columns incredibly easily. We could remake this entire library in Streamlit (I’ll leave that as a very advanced exercise to the reader!), but it is nice to have an automated exploratory analysis like this. </p>
    <p class="normal">This is also a good lesson about composability—we can treat Streamlit Components as unique Lego blocks, combining them at will to create new and interesting Streamlit applications. </p>
    <p class="normal">This is another component that you should try out on your own, to see all the information that it <a id="_idIndexMarker290"/>can show the user. Now on to bidirectional apps with <code class="inlineCode">st-folium</code>! </p>
    <h1 class="heading-1" id="_idParaDest-89">Interactive maps with st-folium </h1>
    <p class="normal">Earlier in this chapter, we learned how critical it could be to add bidirectionality to visualizations through <code class="inlineCode">streamlit-plotly-events</code>. Drilling down into graphs is an oft requested <a id="_idIndexMarker291"/>feature by business users, and maps are no exception to that! <code class="inlineCode">st-folim</code> is very<a id="_idIndexMarker292"/> similar to <code class="inlineCode">streamlit-plotly-events</code>, but for geospatial maps.</p>
    <p class="normal">This example focuses on the trees dataset that we have used time and time again in this book, so go ahead and create a new file in the <code class="inlineCode">pages</code> folder called <code class="inlineCode">folium_map.py</code>, and we can get started. The following section of code loads the libraries, adds the data, creates a <code class="inlineCode">folium</code> map, and adds that map to our Streamlit app. This is mostly a repeat of our previous graph, which maps the trees in SF but adds the Folium library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> folium
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> streamlit_folium <span class="hljs-keyword">import</span> st_folium
st.title(<span class="hljs-string">"SF Trees Map"</span>)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">"longitude"</span>, <span class="hljs-string">"latitude"</span>])
trees_df = trees_df.head(n=<span class="hljs-number">100</span>)
lat_avg = trees_df[<span class="hljs-string">"latitude"</span>].mean()
lon_avg = trees_df[<span class="hljs-string">"longitude"</span>].mean()
m = folium.Map(
location=[lat_avg, lon_avg], 
zoom_start=<span class="hljs-number">12</span>)
st_folium(m)
</code></pre>
    <p class="normal">This code will create the following app, which, as of now, is just a map of San Fransisco! But you will notice that we can scroll around, zoom in and out, and make use of all the normal features we would expect from a map:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_10.png"/></figure>
    <p class="packt_figref">Figure 7.10: Our first Folium map</p>
    <p class="normal">On top of this, we<a id="_idIndexMarker293"/> want to add a little marker for each of the points that <a id="_idIndexMarker294"/>we have in our trees dataset, to replicate the trees map we have already created. We can use a basic <code class="inlineCode">for</code> loop to do this!</p>
    <pre class="programlisting code"><code class="hljs-code">lat_avg = trees_df[<span class="hljs-string">"latitude"</span>].mean()
lon_avg = trees_df[<span class="hljs-string">"longitude"</span>].mean()
m = folium.Map(location=[lat_avg, lon_avg], zoom_start=<span class="hljs-number">12</span>)
<span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> trees_df.iterrows():
    folium.Marker(
        [row[<span class="hljs-string">"latitude"</span>], row[<span class="hljs-string">"longitude"</span>]],
    ).add_to(m)
st_folium(m)
</code></pre>
    <p class="normal">Now, our app will have our 100 trees as markers, like this: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_11.png"/></figure>
    <p class="packt_figref">Figure 7.11: Adding points to Folium</p>
    <p class="normal">This is not that <a id="_idIndexMarker295"/>special just yet! Cool, but is not that different from any <a id="_idIndexMarker296"/>other map that we can make. The interesting part comes when we realize that the <code class="inlineCode">st_folium</code> function returns the click events made on the map by default! So now, we can receive those events and print them back to the Streamlit app with the following code: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> trees_df.iterrows():
    folium.Marker(
        [row[<span class="hljs-string">"latitude"</span>], row[<span class="hljs-string">"longitude"</span>]],
    ).add_to(m)
events = st_folium(m)
st.write(events)
</code></pre>
    <p class="normal">Our app now<a id="_idIndexMarker297"/> prints out the click events to our Streamlit app, and<a id="_idIndexMarker298"/> we can then use them programmatically in the same way as in <code class="inlineCode">streamlit-plotly-events</code>! </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_12.png"/></figure>
    <p class="packt_figref">Figure 7.12: Bidirectional Maps</p>
    <p class="normal">This is<a id="_idIndexMarker299"/> the magic of Streamlit, and of <code class="inlineCode">st-folium</code>! Interactivity is<a id="_idIndexMarker300"/> straightforward, and dynamic apps that delight users are just around each corner. </p>
    <p class="normal">Now for our last library of this chapter, a library created by the Streamlit data product team called <code class="inlineCode">streamlit-extras</code>! </p>
    <h1 class="heading-1" id="_idParaDest-90">Helpful mini-functions with streamlit-extras</h1>
    <p class="normal">I have personally been a part of the Streamlit data product team since the beginning of 2022, and that work<a id="_idIndexMarker301"/> unsurprisingly centers around creating Streamlit apps about the business that is Streamlit. The team creates dozens of apps for dozens of business partners, and as a part of that work has created dozens of helper functions that make it more fun and efficient to create Streamlit apps. </p>
    <p class="normal">Every team has functions like these. At Streamlit, it is encouraged to open-source as much of your work as possible, so we decided to turn these functions into a Python package and release it out to the community. </p>
    <p class="normal">For example, we had a problem where users of our apps would accidentally just select one date in a date range, and then the entire app would not run correctly. In response to this, we built a mandatory date range picker that will not run the app until two dates are selected! It can be used like this: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> streamlit_extras.mandatory_date_range <span class="hljs-keyword">import</span> date_range_picker
result = date_range_picker(<span class="hljs-string">"Select a date range"</span>)
st.write(<span class="hljs-string">"</span><span class="hljs-string">Result:"</span>, result)
</code></pre>
    <p class="normal">Or for another example, we wanted to have an input that looked like the toggles in our favorite document management software, Notion. So we built a small one! It can be used like so: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> streamlit_extras.stoggle <span class="hljs-keyword">import</span> stoggle
stoggle(
    <span class="hljs-string">"Click me!"</span>,
    <span class="hljs-string">"""<img alt="" role="presentation" src="../Images/B18444_07_14.png"/> Surprise! Here's some additional content"""</span>,
)
</code></pre>
    <p class="normal">Now, we can create toggles that look like this! </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_07_13.png"/></figure>
    <p class="packt_figref">Figure 7.13: Toggle!</p>
    <p class="normal">All of these features, and<a id="_idIndexMarker302"/> dozens more, exist in one little library. A huge percent of this work can be attributed to my teammates Arnaud Miribel (<a href="https://github.com/arnaudmiribel"><span class="url">https://github.com/arnaudmiribel</span></a>) and Zachary Blackwood (<a href="https://github.com/blackary"><span class="url">https://github.com/blackary</span></a>)! They built and released this library and are great Streamlit developers to follow on GitHub. You can find the rest of Streamlit extras at (<a href="https://extras.streamlit.app/"><span class="url">https://extras.streamlit.app/</span></a>), so <code class="inlineCode">pip</code> <code class="inlineCode">install</code> and give it a shot! </p>
    <h1 class="heading-1" id="_idParaDest-91">Finding more Components</h1>
    <p class="normal">These Components<a id="_idIndexMarker303"/> are a tiny percentage of all the Components the Streamlit community has created, and by the time you may be reading this, I am sure the number of Components out there will be dramatically higher. The best place to find new and interesting Components is on either the Streamlit website at <a href="https://streamlit.io/gallery?type=components&amp;category=featured"><span class="url">https://streamlit.io/gallery?type=components&amp;category=featured</span></a> or the discussion<a id="_idIndexMarker304"/> forums at <a href="https://discuss.streamlit.io/c/streamlit-components/18"><span class="url">https://discuss.streamlit.io/c/streamlit-components/18</span></a>. </p>
    <p class="normal">When you find a Component that you think is interesting, try it out by downloading it with <code class="inlineCode">pip</code> as we did earlier, and read enough documentation to get started!</p>
    <h1 class="heading-1" id="_idParaDest-92">Summary </h1>
    <p class="normal">At this point, I hope you feel very comfortable downloading and using Streamlit Components, which you have learned about here, as well as comfortable with finding new Streamlit Components created by the community. You should really understand how to find, download, and use Streamlit Components to bolster the apps that you build.</p>
    <p class="normal">In the next chapter, we will dive more deeply into deploying your own Streamlit apps with a cloud provider such as <strong class="keyWord">Heroku</strong> or <strong class="keyWord">Hugging Face</strong>! </p>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/sl"><span class="url">https://packt.link/sl</span></a></p>
    <p class="normal"><img alt="" role="presentation" src="../Images/QR_Code13440134443835796.png"/></p>
  </div>
</body></html>