- en: Namespaces, Scopes, and Modules
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll cover Python modules. Modules are files containing functions
    and class definitions. The concept of a namespace and the scope of variables across
    functions and modules are also explained in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.1 Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Names of Python objects, such as the names of variables, classes, functions,
    and modules, are collected in namespaces. Modules and classes have their own named namespaces
    with the same name as these objects. These namespaces are created when a module
    is imported or a class is instantiated. The lifetime of a namespace of a module
    is as long as the current Python session. The lifetime of a namespace of a class
    instance is until the instance is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Functions create a local namespace when they are executed (invoked). It is deleted
    when the function stops the execution with a regular return or an exception. Local
    namespaces are unnamed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of namespaces puts a variable name in its context. For example,
    there are several functions with the name `sin` and they are distinguished by
    the namespace they belong to, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'They are indeed different, as `numpy.sin` is a universal function accepting
    lists or arrays as input, while `math.sin` takes only floats. A list with all
    the names in a particular namespace can be obtained with the command `dir(<name
    of the namespace>)`. It contains two special names, `__name__` and `__doc__`.
    The former refers to the name of the module and the latter to its docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a special namespace, `__builtin__`, which contains names that are
    available in Python without any `import`. It is a named namespace but its name
    needs not be given when referring to a built-in object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's learn about the scope of a variable in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 The scope of a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable defined in one part of a program does not need to be known in other
    parts. All program units to which a certain variable is known are called the *scope* of
    that variable. We''ll first give an example. Let''s consider the two nested functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of `my_function(3)` results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The variable `e` is in the namespace of the program unit that encloses the function `my_function`.
    The variable `a` is in the namespace of this function, which itself encloses the
    innermost function `other_function`. For the two functions, `e` is a global variable,
    that is, it is not in the local namespace and not listed by `dir()` but its value
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good practice to pass information to a function only by its parameter
    list and not use the construction from the preceding example. An exception can
    be found in [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Anonymous
    functions*, where global variables are used for closures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By assigning it a value, a variable automatically becomes a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be seen when executing the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code gives shows us the local variables of `my_function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, `e` became a local variable. In fact, this piece of code now has two variables `e` belonging
    to different namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `global` declaration statement, a variable defined in a function
    can be made global, that is, its value will be accessible even outside this function.
    The use of a `global` declaration is demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It would be advisable to avoid using this construct and the use of `global`.
    Code using `global` is hard to debug and maintain. The use of classes makes the
    use of `global` mainly obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3 Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a module is simply a file containing classes and functions. By importing
    the file in your session or script, the functions and classes become usable.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1 Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python comes with many different libraries by default. You may also want to
    install more of those for specific purposes, such as optimization, plotting, reading/writing
    file formats, image handling, and so on. NumPy and SciPy are two important examples
    of such libraries, Matplotlib for plotting is another one. At the end of this
    chapter, we will list some useful libraries.
  prefs: []
  type: TYPE_NORMAL
- en: To use a library, you may either
  prefs: []
  type: TYPE_NORMAL
- en: 'load only certain objects from a library, for example, from NumPy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'load the entire library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'or give access to an entire library by creating a namespace with the library
    name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Prefixing a function from the library with the namespace gives access to this
    function and distinguishes this function from other objects with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the name of a namespace can be specified together with the `import` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Which of these alternatives you use affects the readability of your code as well as
    the possibilities for mistakes. A common mistake is shadowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A way to avoid this unintended effect is to use `import` instead of `from` and
    then access the command by referring to the namespace, here `sl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout this book, we have used many commands, objects, and functions. These
    were imported into the local namespace by statements such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing objects in this manner does not make the module from which they are
    imported evident. Some examples are given in the following table (*Table 13.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Libraries** | **Methods** |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy` | `array`, `arange`, `linspace`, `vstack`, `hstack`, `dot`, `eye`, `identity`,
    and `zeros`. |'
  prefs: []
  type: TYPE_TB
- en: '| `scipy.linalg` | `solve`, `lstsq`, `eig`, and `det`. |'
  prefs: []
  type: TYPE_TB
- en: '| `matplotlib.pyplot` | `plot`, `legend`, and `cla`. |'
  prefs: []
  type: TYPE_TB
- en: '| `scipy.integrate` | `quad`. |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | `copy` and `deepcopy`. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.1: Examples of modules and corresponding imported functions'
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.2 Modules in IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython is used in code development. A typical scenario is that you work on
    a file with some function or class definitions that you change within a development
    cycle. To load the contents of such a file into the shell, you may use `import` but
    the file is loaded only once. Changing the file has no effect on later imports.
    That is where IPython's *magic command* `run` enters the stage.
  prefs: []
  type: TYPE_NORMAL
- en: The IPython magic command – run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IPython has a special *magic command* named `run` that executes a file as if
    you were running it directly in Python. This means that the file is executed independently
    of what is already defined in IPython. This is the recommended method to execute
    files from within IPython when you want to test a script intended as a standalone
    program. You must import all you need in the executed file in the same way as
    if you were executing it from the command line. A typical example of running code
    in `myfile.py` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This script file is executed in Python by `exec(open('myfile.py').read())`.
    Alternatively, in IPython the *magic command *`run myfile` can be used if you
    want to make sure that the script runs independently of the previous imports.
    Everything that is defined in the file is imported into the IPython workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3 The variable __name__
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In any module, the special variable `__name__` is defined as the name of the
    current module. In the command line (in IPython), this variable is set to `__main__`.
    This fact allows the following trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The tests will be run only when the file is directly run, *not* when it is imported
    as, when imported, the variable `__name__` takes the name of the module instead
    of `__main__`.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4 Some useful modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The list of useful Python modules is vast. In the following table, we have
    given a very short segment of such a list, focused on modules related to mathematical
    and engineering applications (*Table 13.2)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `scipy` | Functions used in scientific computing |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy` | Support arrays and related methods |'
  prefs: []
  type: TYPE_TB
- en: '| `matplotlib` | Plotting and visualization  |'
  prefs: []
  type: TYPE_TB
- en: '| `functools` | Partial application of functions |'
  prefs: []
  type: TYPE_TB
- en: '| `itertools` | Iterator tools to provide special capabilities, such as slicing
    to generators |'
  prefs: []
  type: TYPE_TB
- en: '| `re` | Regular expressions for advanced string handling |'
  prefs: []
  type: TYPE_TB
- en: '| `sys` | System-specific functions |'
  prefs: []
  type: TYPE_TB
- en: '| `os` | Operating system interfaces such as directory listing and file handling
    |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | Representing dates and date increments |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | Returning wall clock time |'
  prefs: []
  type: TYPE_TB
- en: '| `timeit` | Measuring execution time |'
  prefs: []
  type: TYPE_TB
- en: '| `sympy` | Computer arithmetic package (symbolic computations) |'
  prefs: []
  type: TYPE_TB
- en: '| `pickle` | Pickling, a special file input and output format |'
  prefs: []
  type: TYPE_TB
- en: '| `shelves` | Shelves, a special file input and output format |'
  prefs: []
  type: TYPE_TB
- en: '| `contextlib` | Tools for context managers |'
  prefs: []
  type: TYPE_TB
- en: 'Table 13.2: A non-exhaustive list of useful Python packages for engineering
    applications'
  prefs: []
  type: TYPE_NORMAL
- en: We advise against the use of the mathematics module `math` and favor `numpy`
    instead. The reason for this is that many of NumPy's functions, such as `sin`
    operate on arrays, while the corresponding functions in `math` don't.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started the book by telling you that you had to import SciPy and other useful
    modules. Now you fully understand what importing means. We introduced namespaces
    and discussed the difference between `import` and `from ... import *`. The scope
    of a variable was already introduced in [Section 7.2.3](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Access to variables defined outside the local*'
  prefs: []
  type: TYPE_NORMAL
- en: '*namespace**,* but now you have a more complete picture of the importance of
    that concept.'
  prefs: []
  type: TYPE_NORMAL
