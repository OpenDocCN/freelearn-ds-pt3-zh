- en: '*Chapter 11*: URLs and Multi-Page Apps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been building everything on one page. We kept adding new charts
    and interactive components to a single div and incorporated them as we saw fit.
    Adding new URLs can be useful for space-saving purposes, so that we don't end
    up having too many components on a single page. URLs also serve as a tool for
    classifying content and providing context, so users know "where" they are and
    what they are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Even more interesting is the ability to programmatically generate many additional
    pages to your app, simply by displaying content based on the URL (or any part
    of it). This is what we will do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get to know how the **Location** and **Link** components work, we will
    then make a slight change to the structure of the app, by making and isolating
    new layouts. Then, it will be clear how easy it is to make a multi-page app. We
    will have a general layout with an empty area in the middle, and using a simple
    rule, content will be displayed based on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: All the functionality we have built was mainly based on indicators. We created
    many charts for those indicators, showing how they vary in time and across countries.
    Our users might also be interested in country-oriented reports. So, we will create
    a page for each country, where users can check whichever indicator they want for
    the country of interest and optionally compare with other countries. With a few
    simple changes, we will add 169 new pages to our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the `Location` and `Link` components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting and using attributes of URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing URLs and using their components to modify parts of the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restructuring your app to cater to multiple layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding dynamically generated URLs to the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating the new URL interactivity into the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the new components that we will introduce, we will still be using the same
    tools. Dash, Dash Core Components, Dash HTML Components, and Dash Bootstrap Components
    will be used to build our new functionality and add it to our app. We will also
    be using pandas for data manipulation, JupyterLab and `jupyter_dash` for experimenting
    with isolated functionality, and Plotly and Plotly Express for data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The main topic of this chapter will be manipulating parts of the URLs and using
    them as inputs to modify other components. This is the same as using any other
    element of our app to create the functionality that we want. Let's start by getting
    to know the two components that make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3eks3GI](https://bit.ly/3eks3GI).
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Location and Link components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These components are part of Dash Core Components, and their names make quite
    clear what they are and what they might do. The `Location` component refers to
    the browser''s location bar. It is also referred to as the address bar or the
    URL bar. We typically place a `Location` component in the app, and it doesn''t
    produce anything visible. We mainly use it to discover where we are in the app,
    and based on that, we induce some functionality. Let''s create a simple example
    to see how it can be used in its simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a simple layout for the app containing a `Location` component and, right
    underneath it, an empty `div`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a callback function that takes the `href` attribute of the `Location`
    component and prints it to the empty div:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the app and observe its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's quite straightforward and clear. We simply ask the `Location` component
    to tell us where it is, and we display it in the empty div. In this example, we
    asked for the `href` attribute, and we got the full URL of the current page. For
    various reasons, we might be interested in other attributes, for more nuanced
    functionality. Let's build another simple app to extract the other available attributes
    of the `Location` component and get to know how to use the `Link` component as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Link component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, this component produces links. Another way of creating
    links is by using the HTML `<a>` tag, which is available in the Dash HTML Components
    package. While `<a>` is more suitable for external links, `Link` is better suited
    for internal ones. A nice advantage is that it simply changes the pathname attribute
    and does so without refreshing the page. So, it is fast and responsive, just like
    changing the value in any other interactive component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the update to our simple app, we will add an `<a>` link, as well as a few
    `Link` component links, so you can experience the difference in refreshing and
    also get to know both types of link. Our `Location` component will now get the
    location of the current page, but we will also use it to extract all the available
    attributes and discuss some ideas about how they might be used. Let''s create
    the elements that will go into our app''s layout:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Location` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an `<a>` component through Dash HTML Components, pointing to an internal
    page using a relative path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `Link` component pointing to a page with a search attribute (query parameters):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `Link` component pointing to a page with a hash, which is also
    known as a fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an empty div where the output will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is similar to the previous app, as you can see; we only added a few links.
    These will be displayed as regular links on the page. We will now extract and
    display the parts that we are interested in, using a new callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the decorator of the function, adding a separate `Input` element for
    each attribute of the `Location` component. As you will see, the location is the
    full URL, but each part gets automatically extracted for us depending on what
    we specify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the signature of the callback function, taking each of the `Location`
    component''s attributes as `Input` elements. Note that we append an underscore
    to the `hash` argument, to make it clear that we are not using the built-in Python
    function of the same name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the different attributes of the URL we are in, in the empty div:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code and clicking on the links we have created shows
    different URL attributes shown in the div, as you can see in *Figure 11.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The Location component showing various URL parts for different
    URLs](img/B16780_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The Location component showing various URL parts for different
    URLs
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have used the `Link` component to change the URL and used
    `Location` to extract whichever attribute we wanted. You can easily see how this
    might be used in other types of callback functions that do more than just display
    those attributes. Let''s take a look at how we can parse and extract query parameters
    and their values using Python''s `parse_qs` (parse query string) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now do whatever we want with those values. A more practical application,
    taking our dataset as an example, is that you can create specific and shareable
    URLs, where users can share a specific chart with a certain set of options, simply
    by providing a URL for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once you get a country name, a year, and an indicator, you can easily take this
    as an input to a callback function and produce the desired chart based on those
    selections. You can also imagine making it easier for your users, where the selections
    they make in the interactive components change the `Location` component, making
    it very easy to share those URLs. The great thing about this, as mentioned already,
    is that it works without refreshing the page, so it won't slow down the process
    in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works in a practical application, using our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing URLs and using their components to modify parts of the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having established some working knowledge about how `Location` and `Link` components
    work, we want to use this in our app. The plan is to add 169 new pages using three
    callbacks and adding a few new layout elements. The user will have a drop-down
    menu of countries to choose from. Selecting a country modifies the URL, which
    will render the country layout. This layout will include a heading, a chart, and
    a table about the country in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.2* shows a sample of a country page that we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – A sample country page showing a chart including other countries
    as well](img/B16780_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – A sample country page showing a chart including other countries
    as well
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we now have a template for a country page. This was triggered
    because the URL contained a country that is one of the available countries in
    the dataset. Otherwise, it will display the main app, containing all the components
    that we have built so far. Users can also click on the **Home** link to go there.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first see how to restructure our app.
  prefs: []
  type: TYPE_NORMAL
- en: Restructuring your app to cater to multiple layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this stage, we haven''t moved from the basic structure that we discussed
    in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview of
    the Dash Ecosystem*, and as a reminder, *Figure 11.3* shows a simplified representation
    of the current structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The structure of a Dash app](img/B16780_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The structure of a Dash app
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything will remain the same, with the exception of the layout part. Right
    now, we only have one layout attribute, and everything was added to the main div.
    We used tabs to efficiently utilize space in some cases, and from Dash Bootstrap
    Components we used the `Row` and `Col` components to flexibly manage how components
    are displayed. To create the new layout structure, we need to create one main
    layout, which will serve as the skeleton of our app. In this layout, we will have
    an empty div, which will get populated with the appropriate content, depending
    on the URL we are on. *Figure 11.4* shows how this skeleton might look. This is
    just to make it easy to visualize; it would never show an empty page like this.
    Note that we also added a navigation bar, to which we can add several other elements,
    and this can be thought of as another addition to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – The new skeleton layout of the app showing an empty main content
    area](img/B16780_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The new skeleton layout of the app showing an empty main content
    area
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As you can see on the skeleton page with the empty body, you can use Dash for
    very fast prototyping and designing apps. Before you start coding, you can quickly
    build the layout you want, share with other stakeholders, get feedback, and only
    then start coding the interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the same figure, you can also isolate or remove certain elements,
    to make it easier for your audience to understand the structure of the app you
    are building.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now code the different parts that we need to upgrade our app with country
    URLs and a navigation bar. We start by first creating a few separate layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NavbarSimple` component and discuss its details in the following section.
    Our layout will also contain the footer that has tabs, which we previously created.
    The body of this layout, like our simple app at the beginning of the chapter,
    will have a `Location` component, as well as an empty div that will display the
    required layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`main_content` div when the right condition is met (if the URL does not contain
    a country name):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Country dashboard**: This will also be saved to a variable and displayed
    when its condition is met, which is when there is a country name in the URL. The
    content of this layout (chart and table) will be for the country in the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`validation_layout` attribute solves this issue for us. It''s also a nice and
    easy way to know and manage the layout of our app as a whole. This can come in
    handy with more complex apps that have many more layouts. You can think of it
    as the app''s table of contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We still need to specify the app''s `layout` attribute, so Dash knows which
    one to use as the default layout. This is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's now see how to manage the content that will be displayed in the `main_layout`
    part.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying content based on the URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once our layouts have been set up the way we did, we need a very simple function
    to manage the content.
  prefs: []
  type: TYPE_NORMAL
- en: The function checks if the path name attribute of the `Location` component is
    one of the available countries or not. If it is, it returns the `country_dashboard`
    layout. Otherwise, it returns `indicators_layout`. Note that the second condition
    includes anything other than a country from the available countries. Since we
    don't have any other functionality in this app, and to catch any URL errors, it's
    good to send anything else to the home page. In more elaborate apps, though, it
    might be better to create error pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to take note of two simple points. First, that the pathname attribute
    returns the path which contains `"/<country_name>"`, so we need to extract everything
    but the first character. Second, when we change the URL, if it contains special
    characters, such as spaces, they are automatically URL-encoded. This can be easily
    handled with the `unquote` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Choosing a country with spaces, as in this case, converts spaces to their URL-encoded
    equivalent `%20`, so we need to use `unquote` on the name to be able to handle
    it as normal text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that creates a `countries` list, containing all available
    countries, and the simple callback that manages the display of the content, based
    on the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We just went through a high-level description of the new layout and structure
    of the app, and we now need to fill in some blanks and discuss some details about
    how to create the navigation bar, the drop-down menu, and its links.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamically generated URLs to the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now want to complete our main layout with a navigation bar, a home page link,
    as well as a drop-down menu for the countries. To achieve that, we introduce the
    `NavbarSimple` component from Dash Bootstrap Components and see how we can use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NavbarSimple` component will take a few elements to create the structure
    we want as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create the navigation bar and give it `brand` and `brand_href` arguments,
    to indicate what the name would be and where it would link to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For its `children` argument, we will add a `dbc.DropdownMenu` component. We
    will also give it a `label` value so users know what to expect when they click
    on the menu. We will fill its `children` argument in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to supply a list of `dbc.DropdownMenuItem` components to the drop-down
    menu. Those items will each get `children` and `href` arguments. Both of these
    will be for a country from the list of countries we created in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Putting together the code for the full `NavbarSimple` component, you can see
    it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have implemented our navigation bar, and we can also add the `Tabs`
    component to the same layout, which we implemented in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*. Now it is very easy to modify or add any navigational
    elements you want, whenever you want, which will take effect on the website as
    a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the children of the navigation bar contained links that act the same
    way as the `Link` component, so we also have this option when needed.
  prefs: []
  type: TYPE_NORMAL
- en: With the full layout of the whole app ready and the correct layout being loaded
    based on the URL, we are now ready to implement the last two callback functions
    that will generate the `country_dashboard` layout for us.
  prefs: []
  type: TYPE_NORMAL
- en: But here is the situation. I, your former colleague, wrote the code and created
    the functionality. I left the company without explaining anything, and you cannot
    get in touch with me. You need to figure out the structure for yourself, and you
    want to make some changes to my code.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical situation that you will probably face, so let's see how we
    can approach it.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the new URL interactivity into the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having created a dropdown that automatically changes the URL based on the selected
    value, we have allowed our users to go from page to page as they please. We now
    need to manage the display of the right content based on the selected country.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code was already written, one thing you can do is run the app in debug
    mode and get a visual representation of all the available components and see how
    they are connected with callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.5* shows the graph of the callbacks that have been created. Let''s
    use it to understand how this functionality was implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – The various components and callbacks managing the URL functionality](img/B16780_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – The various components and callbacks managing the URL functionality
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the figure from left to right and see what is going on here.
    You can refer to *Figure 11.2* to see how this graph corresponds to visible components
    in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything starts with the **pathname** attribute of the component with the
    ID **location**. This can be induced by the user selecting a country from the
    drop-down menu, directly entering the full URL containing a country name, or clicking
    on a link from a web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL (its pathname attribute) influences three components, as you can see.
    Most importantly, it determines what goes into the `country_dashboard` layout
    will be displayed, using the **display_content** callback. This would display
    certain components that would make the two other callbacks relevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming a country was selected, our second callback, **set_dropdown_values**,
    will take this country and use it to populate the dropdown that selects the country
    to plot on this page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<h1>` component that says `"<country name> Poverty Data"`. `dbc.Table`
    component showing various details about the country, extracted from the country
    CSV file that contains data about each country in the dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this, you get the code from the repository to see how this was implemented,
    and you see two callbacks that you want to review and eventually change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By now, it should be easy for you to figure out how to read new code, even code
    that contains components that you have never seen before. The general structure
    of apps has been covered and modified so many times, with so many components,
    and I think you are now comfortable with figuring this out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last coding exercise in the book, and the last functionality that
    we will add. It doesn't mean that the app is complete. On the contrary, there
    are many things that can be modified and added. One thing you might consider doing
    is implementing a special URL for each indicator and having a special page for
    it, just like we did with countries. The difference is that this may not be as
    straightforward as the case with countries. We have some indicators that are percentages
    and others that are simple numbers. Some indicators should be taken together as
    a group, such as the ones showing different income quantiles. You can really get
    creative with what you want to change and how.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now recap what we covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first got to know the two main components that are responsible for modifying,
    reading, and parsing URLs, the **Location** and **Link** components. We created
    two simple apps in which we saw how to extract the part of the URL that we are
    interested in and experimented with several options for what can be done with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how to modify parts of an app by taking values from parsed URLs.
    With this knowledge, we were able to restructure our app. We created a skeleton
    layout with an empty div, in which the right content would then be displayed based
    on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: We then incorporated the new functionality into our app. We were left with a
    final exercise that you can expect to go through in real life, which is a colleague
    handing you some code that you have to figure out and modify yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored many options, layouts, components, and functionality,
    the next natural step is to deploy our app on a public server, so we can share
    it with the world.
  prefs: []
  type: TYPE_NORMAL
- en: This will be the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
