<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer019">
    <h1 class="chapterNumber">1</h1>
    <h1 class="chapterTitle" id="_idParaDest-16">An Introduction to Streamlit</h1>
    <p class="normal">Streamlit is the <a id="_idIndexMarker000"/>fastest way to make data apps. It is an open-source Python library that helps you build web applications to be used for sharing analytical results, building complex interactive experiences, and iterating on top of new machine learning models. On top of that, developing and deploying Streamlit apps is incredibly fast and flexible, often reducing the application development time from days to hours.</p>
    <p class="normal">In this chapter, we will start out with the Streamlit basics. We will learn how to download and run demo Streamlit apps, how to edit demo apps using our own text editor, how to organize our Streamlit apps, and finally, how to make our very own apps. Then, we will explore the basics of data visualization in Streamlit. We will learn how to accept some initial user input, and then add some finishing touches to our own apps with text. By the end of this chapter, you should be comfortable with starting to make your own Streamlit apps!</p>
    <p class="normal">In particular, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Why Streamlit?</li>
      <li class="bulletList">Installing Streamlit</li>
      <li class="bulletList">Organizing Streamlit apps</li>
      <li class="bulletList">Streamlit plotting demo</li>
      <li class="bulletList">Making an app from scratch</li>
    </ul>
    <p class="normal">Before we begin, we will start with the technical requirements to make sure we have everything we need to get started.</p>
    <h1 class="heading-1" id="_idParaDest-17">Technical requirements</h1>
    <p class="normal">Here are the installations and setup required for this chapter:</p>
    <ul>
      <li class="bulletList">The requirements for this book are to have Python 3.9 (or later) downloaded (<a href="https://www.python.org/downloads/"><span class="url">https://www.python.org/downloads/</span></a>) and have a text editor to edit Python files in. Any text editor will do. I use VS Code (<a href="https://code.visualstudio.com/download"><span class="url">https://code.visualstudio.com/download</span></a>).</li>
      <li class="bulletList">Some sections of this book use GitHub, and a GitHub account is recommended (<a href="https://github.com/join"><span class="url">https://github.com/join</span></a>). Understanding how to use Git is not necessary for this book but is always useful. If you want to get started, this link has a useful tutorial: <a href="https://guides.github.com/activities/hello-world/"><span class="url">https://guides.github.com/activities/hello-world/</span></a>.</li>
      <li class="bulletList">A basic understanding of Python is also very useful for this book. If you are not there yet, feel free to spend some time getting to know Python better using this tutorial (<a href="https://docs.python.org/3/tutorial/"><span class="url">https://docs.python.org/3/tutorial/</span></a>) or any other of the freely and readily available tutorials out there, and come back here when you are ready. We also need to have the Streamlit library installed, which we will do in a later section called <em class="italic">Installing Streamlit</em>.</li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-18">Why Streamlit?</h1>
    <p class="normal">Data scientists<a id="_idIndexMarker001"/> have become an increasingly valuable resource for companies and nonprofits over the course of the past decade. They help make data-driven decisions, make processes more efficient, and implement machine learning models to improve these decisions at scale. One pain point for data scientists is the process just after they have found a new insight or made a new model. What is the best way to show a dynamic result, a new model, or a complicated piece of analytics to a data scientist’s colleagues? They can send a static visualization, which works in some cases but fails for complicated analyses that build on each other or on anything that requires user input. They can create a Word document (or export their Jupyter notebook as a document) that combines text and visualizations, which also doesn’t incorporate user input and makes reproducible results much harder. Another option still is to build out an entire web application from scratch using a framework such as Flask or Django, and then figure out how to deploy the entire app in AWS or another cloud provider. </p>
    <p class="normal">None of these options really work that well. Many are slow, don’t take user input, or are suboptimal for informing the decision-making process so fundamental to data science.</p>
    <p class="normal">Enter Streamlit. Streamlit is <a id="_idIndexMarker002"/>all about speed and interaction. It is a web application framework that helps you build and develop Python web applications. It has built-in and convenient methods for everything from taking in user inputs like text and dates to showing interactive graphs using the most popular and powerful Python graphing libraries. </p>
    <p class="normal">I have spent the past two years building Streamlit apps of all different flavors, from data projects for my personal portfolio to building quick applications for data science take-home problems to even building mini-apps for repeatable analysis at work. When I started this journey, I worked at Meta (then Facebook), but after the first edition of this book was published, I loved working on Streamlit apps so much that I went to work for the Streamlit team. Soon after I moved over, the Data Cloud company Snowflake purchased Streamlit. None of this is book is sponsored by Snowflake, and I certainly do not speak for Snowflake, but I truly believe that Streamlit could be as valuable to you and your work as it has been to mine. </p>
    <p class="normal">I wrote this book to bring you quickly up to speed so you can accelerate your learning curve and get to building web applications in minutes and hours instead of days. If this is for you, read on!</p>
    <p class="normal">We will work in three sections, starting with an introduction to Streamlit, and ramping you up to building your own basic Streamlit applications. In <em class="italic">Part 2</em>, we’ll extend this knowledge to more advanced topics such as production deployment methods and using Components created by the Streamlit community for increasingly beautiful and usable Streamlit apps. And in the last part, we’ll focus heavily on interviews with power users who use Streamlit at work, in academia, and for learning data science techniques. Before we begin, we need to get Streamlit set up and discuss how this book’s examples will be structured.</p>
    <h1 class="heading-1" id="_idParaDest-19">Installing Streamlit</h1>
    <p class="normal">In order <a id="_idIndexMarker003"/>to run any Streamlit apps, you must first install Streamlit. I’ve used a package manager called <code class="inlineCode">pip</code> to do this, but you can install it using any package manager you choose (for example, <code class="inlineCode">brew</code>). This book uses Streamlit version 1.13.0 and Python 3.9, but it should work on newer versions as well.</p>
    <p class="normal">Throughout this book, we’ll be using a mix of both terminal commands and code written in Python scripts. We will signpost in which location to run the code to make this as clear as possible. To install Streamlit, run the following code in a terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">pip install streamlit
</code></pre>
    <p class="normal">Now that we<a id="_idIndexMarker004"/> have Streamlit downloaded, we can call it directly from our command line using the preceding code to kick off Streamlit’s demo using the following: </p>
    <pre class="programlisting con"><code class="hljs-con">streamlit hello 
</code></pre>
    <p class="normal">Take some time to explore Streamlit’s demo and take a glance at any code that you find interesting! We’re going to borrow and edit the code behind the plotting demo, which illustrates a combination of plotting and animation with Streamlit. Before we dive in, let’s take a second and talk about how to organize Streamlit apps.</p>
    <h2 class="heading-2" id="_idParaDest-20">Organizing Streamlit apps</h2>
    <p class="normal">Each<a id="_idIndexMarker005"/> Streamlit app we create in this book should be contained in its own folder. It is tempting to create new files for each Streamlit app, but this promotes a bad habit that will bite us later when we talk about deploying Streamlit apps and deal with permissions and data for Streamlit.</p>
    <p class="normal">I would recommend that you have a dedicated individual folder that will house all the apps you’ll create throughout this book. I have named mine <code class="inlineCode">streamlit_apps</code>. The following command will make a new folder called <code class="inlineCode">streamlit_apps</code> and make it our current working directory:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir streamlit_apps
cd streamlit_apps
</code></pre>
    <p class="normal">All the code for this book is housed at <a href="https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science"><span class="url">https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science</span></a>, but I would highly recommend coding by hand for practice. Later in this book, we’ll talk about how to create multi-page apps, which essentially allow us to have many mini-data apps within our central monoapp. Ensuring that our Streamlit apps are well organized will help us with that! </p>
    <h2 class="heading-2" id="_idParaDest-21">Streamlit plotting demo</h2>
    <p class="normal">First, we’re going to start to learn how to make Streamlit apps by reproducing the plotting demo we <a id="_idIndexMarker006"/>saw before in the Streamlit demo with a Python file that we’ve made ourselves. In order to do that, we will do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Make a Python file where we will house all our Streamlit code.</li>
      <li class="numberedList">Use the plotting code given in the demo.</li>
      <li class="numberedList">Make small edits for practice.</li>
      <li class="numberedList">Run our file locally.</li>
    </ol>
    <p class="normal">Our first step is to create a folder called <code class="inlineCode">plotting_app</code>, which will house our first example. The following code makes this folder when run in the terminal, changes our working directory to <code class="inlineCode">plotting_app</code>, and creates an empty Python file we’ll call <code class="inlineCode">plot_demo.py</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir plotting_app
cd plotting_app
touch plot_demo.py
</code></pre>
    <p class="normal">Now that we’ve made a file called <code class="inlineCode">plot_demo.py</code>, open it with any text editor (if you don’t have one already, I’m partial to VS Code (<a href="https://code.visualstudio.com/download"><span class="url">https://code.visualstudio.com/download</span></a>)). When you open it up, copy and paste the following code in to your <code class="inlineCode">plot_demo.py</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
progress_bar = st.sidebar.progress(<span class="hljs-number">0</span>)
status_text = st.sidebar.empty()
last_rows = np.random.randn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
chart = st.line_chart(last_rows)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):
    new_rows = last_rows[-<span class="hljs-number">1</span>, :] + np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>).cumsum(axis=<span class="hljs-number">0</span>)
    status_text.text(<span class="hljs-string">"%i%% Complete"</span> % i)
    chart.add_rows(new_rows)
    progress_bar.progress(i)
    last_rows = new_rows
    time.sleep(<span class="hljs-number">0.05</span>)
progress_bar.empty()
<span class="hljs-comment"># Streamlit widgets automatically run the script from top to bottom. Since</span>
<span class="hljs-comment"># this button is not connected to any other logic, it just causes a plain</span>
<span class="hljs-comment"># rerun.</span>
st.button(<span class="hljs-string">"Re-run"</span>)
</code></pre>
    <p class="normal">This code<a id="_idIndexMarker007"/> does a few things. First, it imports all the libraries needed and creates a line chart in Streamlit’s native graphing framework that starts at a random number sampled from a normal distribution with mean 0 and variance 1. And then it runs a <code class="inlineCode">for</code> loop that keeps sampling new random numbers in bunches of 5 and adding that to the sum we had before while waiting for a twentieth of a second so we can see the graph change, simulating an animation.</p>
    <p class="normal">By the end of this book, you will be able to make apps like this extremely quickly. But for now, let’s run this locally by typing the following code in our terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">streamlit run plot_demo.py
</code></pre>
    <p class="normal">This should open a new tab with your app in your default web browser. We should see our app run as shown in the following figure. Your app will not show this exact line, as random numbers are being generated during each run, but other than that, the app should look the same!</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_01.png"/></figure>
    <p class="packt_figref">Figure 1.1: Plotting demo output</p>
    <p class="normal">This is how we will run every Streamlit app, by first<a id="_idIndexMarker008"/> calling <code class="inlineCode">streamlit</code> <code class="inlineCode">run</code> and then pointing Streamlit toward the Python script that houses our app’s code. Now let’s change something small within the app so we better understand how Streamlit works. The following code changes how many random numbers we plot on our graph, but feel free to make any changes you’d like. Make your changes using the following code, save your changes in<a id="_idIndexMarker009"/> your text editor of choice, and run the file again:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
progress_bar = st.sidebar.progress(<span class="hljs-number">0</span>)
status_text = st.sidebar.empty()
last_rows = np.random.randn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
chart = st.line_chart(last_rows)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):
    new_rows = last_rows[-<span class="hljs-number">1</span>, :] + np.random.randn(<span class="hljs-number">50</span>, <span class="hljs-number">1</span>).cumsum(axis=<span class="hljs-number">0</span>)
    status_text.text(<span class="hljs-string">"%i%% Complete"</span> % i)
    chart.add_rows(new_rows)
    progress_bar.progress(i)
    last_rows = new_rows
    time.sleep(<span class="hljs-number">0.05</span>)
progress_bar.empty()
<span class="hljs-comment"># Streamlit widgets automatically run the script from top to bottom. Since</span>
<span class="hljs-comment"># this button is not connected to any other logic, it just causes a plain</span>
<span class="hljs-comment"># rerun.</span>
st.button(<span class="hljs-string">"</span><span class="hljs-string">Re-run"</span>)
</code></pre>
    <p class="normal">You should notice that Streamlit detected a change to the source file and is prompting you to rerun the file if you’d like. Click <strong class="screenText">Rerun </strong>(or <strong class="screenText">Always rerun</strong> if you want this behavior to be the default, which I almost always do), and watch your app change.</p>
    <p class="normal">Feel free to try making some other changes to the plotting app to get the hang of it! Once you are ready, let’s move on to making our own apps.</p>
    <h1 class="heading-1" id="_idParaDest-22">Making an app from scratch</h1>
    <p class="normal">Now that we’ve tried <a id="_idIndexMarker010"/>out the apps others have made, let’s make our own! This app is going to focus on using the central limit theorem, which is a fundamental theorem of statistics that says that if we randomly sample with replacement enough from any distribution, then the distribution of the mean of our samples will approximate the normal distribution.</p>
    <p class="normal">We are not going to prove this with our app, but instead, let’s try to generate a few graphs that help explain the power of the central limit theorem. First, let’s make sure that we’re in the correct directory (in this case, the <code class="inlineCode">streamlit_apps</code> folder that we created earlier), make a new folder called <code class="inlineCode">clt_app</code>, and toss in a new file.</p>
    <p class="normal">The following code <a id="_idIndexMarker011"/>makes a new folder called <code class="inlineCode">clt_app</code>, and again creates an empty Python file, this time called <code class="inlineCode">clt_demo.py</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir clt_app
cd clt_app
touch clt_demo.py
</code></pre>
    <p class="normal">Whenever we start a new Streamlit app, we want to make sure to import Streamlit (often aliased in this book and elsewhere as <code class="inlineCode">st</code>). Streamlit has unique functions for each type of content (text, graphs, pictures, and other media) that we can use as building blocks for all of our apps. The first one we’ll use is <code class="inlineCode">st.write()</code>, which is a function that takes a string (and as we’ll see later, almost any Pythonic object, such as a dictionary) and writes it directly into our web app in the order that it is called. As we are calling a Python script, Streamlit sequentially looks through the file and, every time it sees one of the functions, designates a sequential slot for that piece of content. This makes it very easy to use, as you can write all the Python you’d like, and when you want something to appear on the app you’ve made, you can simply use <code class="inlineCode">st.write()</code> and you’re all set.</p>
    <p class="normal">In our <code class="inlineCode">clt_demo.py</code> file, we can start with the basic <code class="inlineCode">'Hello World'</code> output using <code class="inlineCode">st.write()</code>, using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.write(<span class="hljs-string">'Hello World'</span>)
</code></pre>
    <p class="normal">Now we can test this by running the following code in the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">streamlit run clt_demo.py
</code></pre>
    <p class="normal">We should see the string <code class="inlineCode">'</code><code class="inlineCode">Hello World'</code> printed on our app, so all is good so far. The following figure is a screenshot of our app in Safari:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_02.png"/></figure>
    <p class="packt_figref">Figure 1.2: Hello World app</p>
    <p class="normal">There are three<a id="_idIndexMarker012"/> items to note in this screenshot. First, we see the string as we wrote it, which is great. Next, we see that the URL points to <strong class="screenText">localhost:8501</strong>, which is just telling us that we’re hosting this locally (that is, it’s not on the internet anywhere) through port <strong class="screenText">8501</strong>. We don’t need to understand almost anything about the port system on computers, or the <strong class="keyWord">Transmission Control Protocol</strong> (<strong class="keyWord">TCP</strong>). The<a id="_idIndexMarker013"/> important thing here is that this app is local to your computer. Later in this book, we’ll learn how to take the local apps we create and share them with anyone via a link! The third important item to note is the hamburger icon at the top right. The following screenshot shows us what happens when we click the icon:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_03.png"/></figure>
    <p class="packt_figref">Figure 1.3: Icon options</p>
    <p class="normal">This is the <a id="_idIndexMarker014"/>default options panel for Streamlit apps. Throughout this book, we’ll discuss each of these options in depth, especially the non-self-explanatory ones such as <strong class="screenText">Clear cache</strong>. All we have to know for now is that if we want to rerun the app or find settings or the documentation, we can use this icon to find almost whatever we need.</p>
    <p class="normal">When we host applications so that others can use them, they’ll see this same icon but have some different options (for example, users will not be able to clear the cache). We’ll discuss this in greater detail later as well. Now back to our central limit theorem app!</p>
    <p class="normal">The next step is going to be generating a distribution that we want to sample from with replacement. I’m choosing the binomial here. We can read the following code as simulating 1,000 coin flips using the Python package <code class="inlineCode">NumPy</code>, and printing out the mean number of heads from those 1,000 coin flips:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">100</span>)
st.write(np.mean(binom_dist))
</code></pre>
    <p class="normal">Now, given what we know about the central limit theorem, we would expect that if we sampled from <code class="inlineCode">binom_dist</code> enough times, the mean of those samples would approximate the normal distribution.</p>
    <p class="normal">We’ve already discussed the <code class="inlineCode">st.write()</code> function. Our next foray into writing content to the Streamlit app is through graphs. <code class="inlineCode">st.pyplot()</code> is a function that lets us use all the power of the popular <code class="inlineCode">matplotlib</code> library and push our <code class="inlineCode">matplotlib</code> graph to Streamlit. Once we create a figure in <code class="inlineCode">matplotlib</code>, we can explicitly tell Streamlit to write that to our app with the <code class="inlineCode">st.pyplot()</code> function. So, all together now! This app simulates 1,000 coin flips and stores those values in a list we call <code class="inlineCode">binom_dist</code>. We then sample (with replacement) 100 from that list, take the mean, and store that mean in the cleverly named variable <code class="inlineCode">list_of_means</code>. We do that 1,000 times (which is overkill – we could do this even with dozens of samples), and then plot the histogram. After we do this, the result of the following code should show a bell-shaped distribution:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
     list_of_means.append(np.random.choice(binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
fig, ax = plt.subplots()
ax = plt.hist(list_of_means)
st.pyplot(fig)
</code></pre>
    <p class="normal">Each run of<a id="_idIndexMarker015"/> this app will create a new bell curve. When I ran it, my bell curve looked like the following figure. If your graph isn’t exactly what you see in the next figure (but is still a bell!), that’s totally fine because of the random sampling used in our code:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_04.png"/></figure>
    <p class="packt_figref">Figure 1.4: Bell curve</p>
    <p class="normal">As you probably noticed, we first created an empty figure and empty axes for that figure by calling <code class="inlineCode">plt.subplots()</code>, and then assigned the histogram we created to the <code class="inlineCode">ax</code> variable. Because of this, we were able to explicitly tell Streamlit to show the figure in our Streamlit app.</p>
    <p class="normal">This is an <a id="_idIndexMarker016"/>important step, as in Streamlit versions, we can also skip this step, not assign our histogram to any variable, and then call <code class="inlineCode">st.pyplot()</code> directly afterward. The following code takes this approach:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
     list_of_means.append(np.random.choice(binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
plt.hist(list_of_means)
st.pyplot()
</code></pre>
    <p class="normal">I don’t recommend this method, as it can give you some unexpected results. Take this example, where we want to first make our histogram of means, and then make another histogram of a new list filled only with the number 1.</p>
    <p class="normal">Take a second and guess what the following code would do. How many graphs would we get? What would the output be?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
     list_of_means.append(np.random.choice(binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
plt.hist(list_of_means)
st.pyplot()
plt.hist([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])
st.pyplot()
</code></pre>
    <p class="normal">I would expect this to show two histograms, the first one of <code class="inlineCode">list_of_means</code>, and the second one of the lists of <code class="inlineCode">1s</code>:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_05.png"/></figure>
    <p class="packt_figref">Figure 1.5: A tale of two histograms</p>
    <p class="normal">What we <a id="_idIndexMarker017"/>actually get is different! The second histogram has data from the first and the second list! When we call <code class="inlineCode">plt.hist()</code> without assigning the output to anything, <code class="inlineCode">matplotlib</code> tacks the new histogram onto the old graph, which is stored globally, and Streamlit pushes that new one to our app. You may also get a <code class="inlineCode">PyplotGlobalUseWarning</code> when you run the preceding code, depending on your matplotlib version. Don’t worry, we will fix this in the next section! </p>
    <p class="normal">Here’s a solution to this issue. If we instead explicitly created two graphs, we could call the <code class="inlineCode">st.pyplot()</code> function wherever we liked after the graph was generated, and have greater control over where exactly our graphs were placed. The following code separates the two graphs explicitly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, <span class="hljs-number">.5</span>, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
     list_of_means.append(np.random.choice(binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
fig1, ax1 = plt.subplots()
ax1 = plt.hist(list_of_means)
st.pyplot(fig1)
fig2, ax2 = plt.subplots()
ax2 = plt.hist([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])
st.pyplot(fig2)
</code></pre>
    <p class="normal">The preceding <a id="_idIndexMarker018"/>code plots both histograms separately by first defining separate variables for each figure and axis using <code class="inlineCode">plt.subplots()</code> and then assigning the histogram to the appropriate axis. After this, we can call <code class="inlineCode">st.pyplot()</code> using the created figure, which produces the following app:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_06.png"/></figure>
    <p class="packt_figref">Figure 1.6: Fixed histograms</p>
    <p class="normal">We can clearly <a id="_idIndexMarker019"/>see in the preceding figure that the two histograms are now separated, which is the desired behavior. We will very often plot multiple visualizations in Streamlit and will use this method for the rest of the book. </p>
    <p class="normal">Matplotlib is an extremely popular library for data visualization but has some serious flaws when used within data apps. It is not interactive by default, it is not particularly pretty, and it also can slow down very large apps. Later in this book, we’ll switch over to more performant and interactive libraries.</p>
    <p class="normal">Now, on to accepting user input!</p>
    <h2 class="heading-2" id="_idParaDest-23">Using user input in Streamlit apps</h2>
    <p class="normal">As of now, our<a id="_idIndexMarker020"/> app is just a fancy way to show our visualizations. But most web apps take some user input or are dynamic, not static visualizations. Luckily for us, Streamlit has many functions for accepting inputs from users, all differentiated by the object that we want to input. There are freeform text inputs with <code class="inlineCode">st.text_input()</code>; radio buttons, <code class="inlineCode">st.radio()</code>; numeric inputs with <code class="inlineCode">st.number_input()</code>; and a dozen more that are extremely helpful for making Streamlit apps. We will explore most of them in detail throughout this book, but we’ll start with numeric input.</p>
    <p class="normal">From the previous example, we assumed that the coins we were flipping were fair coins and had a 50/50 chance of being heads or tails. Let’s let the user decide what the percentage chance of heads is, assign that to a variable, and use that as an input in our binomial distribution. The number input function takes a label, a minimum and maximum value, and a default value, which I have filled in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
perc_heads = st.number_input(label = <span class="hljs-string">'</span><span class="hljs-string">Chance of Coins Landing on Heads'</span>, min_value = <span class="hljs-number">0.0</span>, max_value = <span class="hljs-number">1.0</span>, value = <span class="hljs-number">.5</span>)
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, perc_heads, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
     list_of_means.append(np.random.choice(binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
fig, ax = plt.subplots()
ax = plt.hist(list_of_means, <span class="hljs-built_in">range</span>=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])
st.pyplot(fig)
</code></pre>
    <p class="normal">The preceding code uses the <code class="inlineCode">st.number_input()</code> function to collect our percentage, assigns the user input to a variable (<code class="inlineCode">perc_heads</code>), then uses that variable to change the inputs to the binomial distribution function that we used before. It also sets our histogram’s <em class="italic">x</em> axis to always be between 0 and 1, so we can better notice changes as our input changes. Try and play around with this app for a bit; change the number input and notice how the app responds whenever a user input is changed. For example, here is a result from when we set the numeric input to <code class="inlineCode">.25</code>:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_07.png"/></figure>
    <p class="packt_figref">Figure 1.7: An example of a result from when we set the numeric input to .25</p>
    <p class="normal">As you<a id="_idIndexMarker021"/> probably noticed, every time that we changed the input of our script, Streamlit re-ran the entire application. This is the default behavior and is very important to understanding Streamlit performance; we will explore a few ways that allow us to change this default later in the book, such as adding caching or forms! We can also accept text input in Streamlit using the <code class="inlineCode">st.text_input()</code> function, just as we did with the numeric input. The next bit of code takes a text input and assigns it to the title of our graph:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st  
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
perc_heads = st.number_input(label=<span class="hljs-string">'</span><span class="hljs-string">Chance of Coins Landing on Heads'</span>, min_value=<span class="hljs-number">0.0</span>,  max_value=<span class="hljs-number">1.0</span>, value=<span class="hljs-number">.5</span>)
graph_title = st.text_input(label=<span class="hljs-string">'Graph Title'</span>)
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, perc_heads, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
list_of_means.append(np.random.choice(binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
fig, ax = plt.subplots()
plt.hist(list_of_means, <span class="hljs-built_in">range</span>=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])
plt.title(graph_title)
st.pyplot(fig)
</code></pre>
    <p class="normal">This<a id="_idIndexMarker022"/> creates a Streamlit app with two inputs, both a numeric input and a text input, and uses them both to change our Streamlit app. Finally, this results in a Streamlit app that looks like the next figure, with dynamic titles and probabilities:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_08.png"/></figure>
    <p class="packt_figref">Figure 1.8: A Streamlit app with dynamic titles and probabilities</p>
    <p class="normal">Now that <a id="_idIndexMarker023"/>we have worked a bit with user input, let’s talk about text and Streamlit apps more deeply.</p>
    <h1 class="heading-1" id="_idParaDest-24">Finishing touches – adding text to Streamlit</h1>
    <p class="normal">Our app is functional, but it is missing <a id="_idIndexMarker024"/>a lot of nice touches. We talked earlier about the <code class="inlineCode">st.write()</code> function, which the Streamlit docs call the Swiss Army knife of Streamlit commands. Almost whatever we wrap <code class="inlineCode">st.write()</code> around will work by default and it should be our go-to function if we’re not sure of the best path forward.</p>
    <p class="normal">Other<a id="_idIndexMarker025"/> than <code class="inlineCode">st.write()</code>, we also can utilize other built-in functions that format our text for us, such as <code class="inlineCode">st.title()</code>, <code class="inlineCode">st.header()</code>, <code class="inlineCode">st.markdown()</code>, and <code class="inlineCode">st.subheader()</code>. Using these five functions helps to format text in our Streamlit apps easily and keeps sizing consistent for bigger apps.</p>
    <p class="normal">More specifically, <code class="inlineCode">st.title()</code> will place a large block of text in our app, <code class="inlineCode">st.header()</code> uses a slightly smaller font than <code class="inlineCode">st.title()</code>, and <code class="inlineCode">st.subheader()</code> uses an even smaller one. Other than those three, <code class="inlineCode">st.markdown()</code> will allow anyone already familiar with Markdown to use the popular markup language in our Streamlit apps. Let’s try a couple of them in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
st.title(<span class="hljs-string">'Illustrating the Central Limit Theorem with Streamlit'</span>)
st.subheader(<span class="hljs-string">'</span><span class="hljs-string">An App by Tyler Richards'</span>)
st.write((<span class="hljs-string">'This app simulates a thousand coin flips using the chance of heads input below,'</span>
     <span class="hljs-string">'and then samples with replacement from that population and plots the histogram of the'</span>
     <span class="hljs-string">' means of the samples in order to illustrate the central limit theorem!'</span>))
perc_heads = st.number_input(
    label=<span class="hljs-string">'Chance of Coins Landing on Heads'</span>, min_value=<span class="hljs-number">0.0</span>, max_value=<span class="hljs-number">1.0</span>, value=<span class="hljs-number">.5</span>)
binom_dist = np.random.binomial(<span class="hljs-number">1</span>, perc_heads, <span class="hljs-number">1000</span>)
list_of_means = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
    list_of_means.append(np.random.choice(
        binom_dist, <span class="hljs-number">100</span>, replace=<span class="hljs-literal">True</span>).mean())
fig, ax = plt.subplots()
ax = plt.hist(list_of_means)
st.pyplot(fig)
</code></pre>
    <p class="normal">The preceding code adds a large title (<code class="inlineCode">st.title()</code>), adds a smaller subheader below (<code class="inlineCode">st.subheader()</code>), and then adds some even smaller text below the subheader (<code class="inlineCode">st.write()</code>). We also separated the long string of text in the preceding code block into three smaller strings for readability and to make it easier to edit in our text editor. It should look like the following screenshot. Note that because we are using randomly generated data for this histogram, it is OK (and expected!) if your histogram looks slightly <a id="_idIndexMarker026"/>different:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_01_09.png"/></figure>
    <p class="packt_figref">Figure 1.9: The central limit theorem application</p>
    <p class="normal">And that concludes our illustration of the central limit theorem. Go ahead and try out the other options that Streamlit has for writing text (like <code class="inlineCode">st.markdown()</code>, which interprets and writes Markdown-style text in your Streamlit app) to further explore app creation.</p>
    <h1 class="heading-1" id="_idParaDest-25">Summary</h1>
    <p class="normal">In this chapter, we started by learning how to organize our files and folders for the remainder of this book and quickly moved on to instructions for downloading Streamlit. We then built our first Streamlit application, Hello World, and learned how to run our Streamlit applications locally. Then, we started building out a more complicated application to show the implications of the central limit theorem from the ground up, going from a simple histogram to accepting user input and formatting different types of text within our app for clarity and beautification.</p>
    <p class="normal">By now, you should be comfortable with subjects such as basic data visualization, editing Streamlit apps in a text editor, and locally running Streamlit apps. We’re going to dive more deeply into data manipulation in our next chapter.</p>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/sl"><span class="url">https://packt.link/sl</span></a></p>
    <p class="normal"><img alt="" role="presentation" src="../Images/QR_Code13440134443835796.png"/></p>
  </div>
</body></html>