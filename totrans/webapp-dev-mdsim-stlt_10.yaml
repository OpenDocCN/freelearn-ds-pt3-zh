- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing Pretrained Models to Create Specialized and Personalized Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used Streamlit’s components and libraries, made in Python, to
    create and build up our web application. However, with Streamlit, we can do even
    more.
  prefs: []
  type: TYPE_NORMAL
- en: This incredible framework is extremely powerful when used with **artificial
    intelligence** (**AI**) models to make predictions. Developing **machine learning**
    (**ML**) models or neural networks is something very complex and outside the scope
    of this book, but considering that there are a lot of pretrained models available
    that perform well to provide solutions for many different use cases, knowing how
    to use them in our web application to increase their effectiveness and usefulness
    is something very important.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, importing and using pretrained ML models in Streamlit is an advanced
    technique for creating very powerful web applications. Users can import any kind
    of pretrained model and use it to make predictions on new data within their Streamlit
    web apps. This opens a world of new, more customized, and specialized applications
    tailored to any kind of specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of pretrained ML models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating customized web apps to improve user experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing predictions from ML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpenCV`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pillow
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numpy`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tensorflow`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/7c29f4eca8b189b4f711cc8f724c6dee9dba60ab/Chapter10](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/7c29f4eca8b189b4f711cc8f724c6dee9dba60ab/Chapter10).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the benefits of pretrained ML models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short section, I will try to clarify why using pretrained ML models
    inside our web applications can be a very good and valuable idea.
  prefs: []
  type: TYPE_NORMAL
- en: ML has rapidly evolved in recent years, offering unprecedented opportunities
    to enhance web applications with intelligent and predictive features. Streamlit,
    a popular Python library for creating interactive web applications, has gained
    immense popularity due to its simplicity and flexibility. When combined with pretrained
    ML models, Streamlit can empower developers to build web applications that leverage
    the vast potential of AI.
  prefs: []
  type: TYPE_NORMAL
- en: Pretrained ML models are models that have been trained on large datasets for
    various tasks, such as image recognition, natural language processing, and more.
    These models have learned rich data representations and can be fine-tuned for
    specific applications. Incorporating pretrained models into Streamlit web applications
    can significantly enhance their capabilities and provide a seamless user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the key benefits associated with using pretrained AI models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Efficient development**: One of the primary benefits of using pretrained
    models is the reduction in development time. Instead of starting from scratch
    and training a model from the ground up, developers can leverage existing pretrained
    models, saving both time and resources. Streamlit’s straightforward interface
    complements this efficiency by enabling developers to quickly integrate these
    models into their applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved user experience**: Pretrained models bring state-of-the-art capabilities
    to web applications, enabling features such as image recognition, sentiment analysis,
    and language translation. Users can interact with the application more naturally,
    making it more engaging and user-friendly. For example, a product recommendation
    system powered by a pretrained model can enhance the shopping experience on an
    e-commerce website built with Streamlit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability and performance**: Pretrained models are often designed to handle
    complex tasks, making them suitable for a wide range of applications. Streamlit’s
    ability to efficiently serve web applications makes it a perfect companion for
    pretrained models. Whether it’s processing large datasets or performing real-time
    predictions, the combination of Streamlit and pretrained models ensures high scalability
    and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization and fine-tuning**: While pretrained models provide a solid
    foundation, developers can fine-tune these models to adapt them to specific requirements.
    Streamlit’s flexibility allows for the easy integration of customized models and
    tailored user interfaces. This combination empowers developers to create unique
    and highly specialized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The potential applications of pretrained ML models within Streamlit-based web
    applications are vast and diverse. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Healthcare**: Streamlit applications can utilize pretrained models for medical
    image analysis, disease diagnosis, and patient risk prediction, providing valuable
    tools for healthcare professionals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E-commerce**: Recommender systems powered by pretrained models can enhance
    product discovery, boosting sales and user satisfaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Natural language processing**: Sentiment analysis, chatbots, and language
    translation can improve user interactions in various applications, from customer
    support to social media platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finance**: Fraud detection, credit scoring, and stock market prediction can
    benefit from the predictive power of pretrained models, helping businesses make
    informed decisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the fusion of pretrained ML models and Streamlit-based web applications
    represents a promising frontier in the world of AI-driven development. This synergy
    allows developers to create intelligent and interactive web applications quickly
    and efficiently. As technology advances, this combination’s potential applications
    are limited only by our imagination. By harnessing the power of pretrained models
    within Streamlit, we can deliver cutting-edge solutions that transform the way
    we interact with web applications, making them smarter, more engaging, and more
    useful to users across various domains.
  prefs: []
  type: TYPE_NORMAL
- en: Creating customized web apps to improve user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it’s time to complete our *Covid-19 Detection Tool* web application. So
    far, we have implemented several features, such as **Image Enhancement** and **Disclaimer
    and Info**, but we are still missing the **Diagnosis** section. *Figure 10**.1*
    shows what we have completed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The Covid-19 Detection Tool web app we’ve developed so far](img/B21147_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The Covid-19 Detection Tool web app we’ve developed so far'
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned in [*Chapter 9*](B21147_09.xhtml#_idTextAnchor099), the task
    of **Diagnosis** is to understand from a picture, specifically from an X-ray of
    the chest, whether or not a patient has Covid-19.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of prediction can be performed using a pretrained AI model, which
    in our case is a **convolutional neural network** (**CNN**). A CNN is a neural
    network with a peculiar structure or shape that performs very well regarding tasks
    related to computer vision. **Computer vision**, in a few words, means to make
    computers understand what’s going on with a picture, its content, the objects
    represented inside it, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s see how it is possible to use a pretrained AI model inside Streamlit
    to perform, in this case, a computer vision task, but more generally, a prediction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start from the point where we stopped in [*Chapter 9*](B21147_09.xhtml#_idTextAnchor099):
    the `if` clause related to the **Diagnosis** voice of the menu, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The “Diagnosis” voice of the menu](img/B21147_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The “Diagnosis” voice of the menu'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to add a button in the sidebar. In this way, when the user
    clicks on this button (its label will be **Diagnosis**), the tool will perform
    a binary classification while leveraging the pretrained model to predict whether
    or not the X-ray image represents a case of Covid-19.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the button, as we know, is very easy – it’s just a matter of typing
    the following immediately after `choice==''Diagnosis''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The CNN we are going to use was trained with black and white images. So, first
    of all, when the user clicks on the `numpy`, a library that we’ve already imported.
    The three lines of code we need are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code in the first line changes the image into an array, the second line
    converts the image into a grayscale domain, and the final one converts it into
    a pure black and white image. Please note that we are leveraging `cv2`, the Python
    library for computer vision that was imported at the beginning of the file.
  prefs: []
  type: TYPE_NORMAL
- en: This black and white image is saved in a variable named `gray`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Studying the several Python packages we are importing and using is outside the
    scope of this book; however, having a look at the `cv2` (OpenCV) official website
    [https://opencv.org/](https://opencv.org/)) can be a very interesting activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'After converting the uploaded image, we are ready to write some text on the
    screen (`"Chest X-Ray"`) to give our operation some context and print the black
    and white image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code we’ve added so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: The code we’ve added to the Diagnosis menu](img/B21147_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: The code we’ve added to the Diagnosis menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the browser’s point of view, you should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: The Diagnosis button and the black and white image](img/B21147_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The Diagnosis button and the black and white image'
  prefs: []
  type: TYPE_NORMAL
- en: Since the CNN was trained with black and white images in a specific format in
    terms of size and values, before performing the prediction, we must pre-process
    the image we are interested in to get the same format that the neural network
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: The neural network was trained with images that had a size of 200 pixels by
    200 pixels and their values went from 0 up to 1, where 0 was black and 1 was white.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we need to write to make sure the image we uploaded will be in the
    format needed by the neural network is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line is just an image size definition that is saved in a constant.
    The second line performs image equalization, an operation that potentially increases
    the clarity of our image. The third line resizes the image according to the `IMG_SIZE`
    dimension saved in the constant, and the final instruction normalizes the image
    (usually, the values of gray tones go from 0 (black) to 255 (white); dividing
    everything by 255, we have values from 0 to 1, which are black and white, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.5* shows the lines of code we just explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Pre-processing the X-ray image](img/B21147_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Pre-processing the X-ray image'
  prefs: []
  type: TYPE_NORMAL
- en: 'The library we are using to manage neural networks is named `tensorflow` and
    it requires the images in a precise format (`n,m,p,q`), where `n`, `m`, `p`, and
    `q` are integers. Unfortunately, the shape of our image is only `(200,200)`. So,
    before we use it for prediction, we must resize it; this is the instruction we
    should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By processing the image in this way, we have a very good input for ML classifiers.
    We’ll learn how to deal with this task in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing predictions from ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, everything is ready. Now, to be able to perform predictions about
    Covid-19 from an X-ray image, we need to load our pretrained model (available
    in this chapter’s GitHub repository; the link can be found in the *Technical requirements*
    section) and use it with the uploaded picture (pre-processed according to the
    code we wrote in the *Creating customized web apps to improve user experience*
    section). As explained in the *Understanding the benefits of pretrained ML models*
    section, using a pretrained model is an easy and fast way to solve a problem without
    spending time developing an AI model by ourselves. In our specific case, we can
    predict the presence of Covid-19 from an image just by loading and using a model
    developed and made available by others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `tf` is the alias of `tensorflow`, and `keras` is a module
    inside it. So, we just pass to the `load_model` method the path to our pretrained
    model (please note that the file type of `tensorflow` models is `h5`) and save
    it into a variable named `model`. Please note that the pretrained CNN was put
    in a directory named `models`, so if you changed its position, please update the
    path in the code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code we’ve implemented so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Image reshaping and model loading](img/B21147_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Image reshaping and model loading'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our model variable has a method named `predict` that returns the probability
    of the prediction in a list containing two elements: the probability of no Covid
    and the probability of Covid. Since we are performing a binary classification
    (true or false, so no Covid or Covid) we want to know whether or not the picture
    represents a case of Covid; we can do this using the `argmax` method of `np` (`numpy`).
    `argmax` checks the values of a list and provides the index of the maximum value,
    which in our case is `0` or `1` (`0` in the case of no Covid and `1` in the case
    of Covid). So, if the prediction result is a list such as [`0.70`, `0.30`], `argmax`
    will return `0`; the first index starts from `0` (because `0.70` is greater than
    `0.30`), which means that the diagnosis is no Covid since the probability of no
    Covid is `70%`, while the probability of Covid is `30%`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the **Diagnosis** voice of the menu, we can add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code we implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: How we get the prediction](img/B21147_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: How we get the prediction'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have everything we need to display the result on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as the first frontend element, we must create a progress bar in the sidebar
    that indicates the status of the diagnosis prediction. For this, we can write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A progress bar always works with a timer, so we should *import time* at the
    very beginning of our Python file. This is the reason we did this when we started
    this project (see *Figure 8**.4* in [*Chapter 8*](B21147_08.xhtml#_idTextAnchor091)).
    Let’s continue by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we create a `for` loop that sleeps for `0.05` seconds and then
    activates the progress bar, extending it by `1` unit (the progress bar was instantiated
    with a value of `0`), repeating this operation `100` times since our progress
    bar’s range goes from `0` up to `100` units.
  prefs: []
  type: TYPE_NORMAL
- en: This progress bar indicates that the prediction is ongoing until it reaches
    its maximum value and stops extending.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the progress bar is completely extended, we can print the diagnosis on
    the screen, explaining what kind of prediction we are dealing with. For this,
    we can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code we added for the frontend part – that is, the part that is
    visualized in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: How we get the prediction and visualize it on the screen](img/B21147_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: How we get the prediction and visualize it on the screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result in the browser in the case of a no Covid prediction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: No Covid diagnosis](img/B21147_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: No Covid diagnosis'
  prefs: []
  type: TYPE_NORMAL
- en: Since the model we are using to perform the prediction is just a *toy model*
    and there is no clinical value in the diagnosis that’s made using it, it’s better
    to add a final disclaimer to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final code for the **Diagnosis** voice of the menu is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Complete code for the “Diagnosis” voice of the menu](img/B21147_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Complete code for the “Diagnosis” voice of the menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is the disclaimer on the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Prediction with the disclaimer](img/B21147_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Prediction with the disclaimer'
  prefs: []
  type: TYPE_NORMAL
- en: Please remember that the point here is not to get a very well-performing model
    to predict cases of Covid-19 but to understand how to integrate AI models inside
    Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive deeper into what we achieved in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, in addition to `tensorflow`, as in the case of our web application,
    AI models can be trained with other packages such as `scikit-learn`. Due to this,
    it’s very important that before loading the model into your Streamlit web application,
    you carefully read the documentation of the specific package that was used to
    train the model. Different packages usually adopt different syntaxes to load their
    models. This means that according to the model you decide to adopt, you must use
    a different syntax in your code.
  prefs: []
  type: TYPE_NORMAL
- en: The second and most important point is that the web application we just implemented
    is quite powerful since it performs several complex tasks, such as image enhancements,
    diagnosis, and more. Even though it’s complex, when we count the lines of code
    we wrote down, we will see that from the very beginning to the end, we wrote just
    about 130 lines of Python, comments included. This is the real power of Python
    and Streamlit together. In a few lines of code, we implemented a web application
    that performs several complex tasks, even leveraging AI. On top of that, we have
    all the typical widgets that are typically included in very professional applications,
    such as different kinds of text, buttons, progress bars, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, and considering that this time the code is even more complex, here
    are some screenshots of the complete transcript of the web application we just
    completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: Part 1 of the Covid-19 Detection Tool web app](img/B21147_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Part 1 of the Covid-19 Detection Tool web app'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we imported the libraries and defined the main function. The main function
    starts by creating a beautiful title and then continues with the presence of a
    `file_uploader` widget. After that, there is a menu containing three voices –
    **Image Enhancement**, **Diagnosis**, and **Disclaimer** **and Info**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Part 2 of the Covid-19 Detection Tool web app](img/B21147_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Part 2 of the Covid-19 Detection Tool web app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we mainly dealt with the **Image Enhancement** feature and completed
    the **Diagnosis** part. In this part, we pre-processed the image, prepared it
    for the ML model, loaded the classification model and a pretrained CNN, executed
    the prediction, and introduced some nice widgets, such as the progress bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Part 3 of the Covid-19 Detection Tool web app](img/B21147_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Part 3 of the Covid-19 Detection Tool web app'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we just suggested simple text for the **Disclaimer and Info** section
    and created the **About the Author** information page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was very important since we learned how to integrate AI into our
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: AI is a highly disruptive technology that can completely change the game when
    managed and leveraged properly in our applications. In this chapter, we learned
    that it is possible to include AI models developed and trained separately in Streamlit.
    Several packages and tools can create AI models, and almost all these models can
    be included in Streamlit; it’s only a matter of checking the proper documentation
    and following the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Loading AI models into our web applications is only one part of the process
    since each model needs to be fed information in a specific format. For this reason,
    all the data we provide as input to the model that we decide to use must be pre-processed
    so that it’s compliant with that specific format. This is the reason why we spent
    a good amount of our time manipulating and transforming the image of the X-ray
    we uploaded in a format that’s compatible with the CNN model we used. The uploaded
    image was converted into black and white, then resized and reshaped.
  prefs: []
  type: TYPE_NORMAL
- en: Having the input in the proper format is extremely important; otherwise, the
    model will not understand what to do and will generate a runtime error. After
    pre-processing the image, we focused on the prediction; we learned how to perform
    predictions and interpret them. Finally, we covered the frontend part and took
    care of visualizing the predictions in the web browser using beautiful effects
    such as the progress bar. We observed that when dealing with sensitive topics
    such as health, it’s good practice to include a disclaimer to avoid potential
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Having a working application is a very good starting point but it is not the
    real conclusion of our job. As we already did with the natural language processing
    web application, we still have to deploy our new tool to the cloud because only
    with deployment is it possible to build a well-done and well-performing application
    available to a very wide customer base. This is exactly what we are going to do
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
