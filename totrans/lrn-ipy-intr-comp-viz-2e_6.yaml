- en: Chapter 6. Customizing IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'IPython can be customized and extended for advanced uses. At the end of this
    chapter, you will know:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create and use custom profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use IPython extensions for advanced purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use different languages in the notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create your own extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use rich representations in the frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to embed IPython in your Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPython profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A profile is specific to a user on the local computer, and contains IPython
    preferences as well as the history, temporary and log files, and so on. By default,
    there is a single profile called the **default profile**. To create it manually,
    we can run the following command in the system shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To specify a profile's name, we can use `ipython profile create name`.
  prefs: []
  type: TYPE_NORMAL
- en: Profile locations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Profiles are typically stored in `~/.ipython` or `~/.config/ipython`, where
    `~` is the current user's home directory. This directory is typically called the
    **IPython directory** and is sometimes referred to as `IPYTHONDIR`. To find the
    exact location of the profiles, we can run the `ipython locate` command for the
    IPython configuration directory, or `ipython locate profile default` for a specific
    profile directory, where `default` is the profile's name. A profile name is typically
    stored in a folder named `profile_name` within the IPython configuration folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, IPython starts with the default profile. To specify a different
    profile when running IPython, we can use the `--profile` command-line argument,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The IPython configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In each profile, there is a special configuration file named `ipython_config.py`.
    This Python script is a placeholder for specifying various options. It contains
    a full template containing most possible options and it is fully documented, so
    that it should be straightforward to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to enable the **pylab** mode automatically in a profile, as well
    as the `qt` event loop integration system, the following lines should appear in
    the corresponding `ipython_config.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Loading scripts when IPython starts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can have some Python scripts automatically loaded whenever IPython starts,
    just put them in `IPYTHONDIR/startup/`. This can be useful if you want to load
    modules or execute some scripts every time IPython starts.
  prefs: []
  type: TYPE_NORMAL
- en: IPython extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPython extensions allow to implement entirely customized behaviors in IPython.
    They can be loaded manually with a simple magic command, or automatically when
    IPython starts.
  prefs: []
  type: TYPE_NORMAL
- en: Several extensions are natively included in IPython. They essentially allow
    to execute non-Python code from IPython. For example, the `cythonmagic` extension
    provides the `%%cython` cell magic for writing Cython code directly in IPython,
    as we saw in [Chapter 5](ch05.html "Chapter 5. High-Performance and Parallel Computing"),
    *High Performance and Parallel Computing*. Similar built-in extensions include
    `octavemagic` and `rmagic` for executing Octave and R code in IPython. They are
    particularly useful in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party modules can also implement their own extensions, as we will see
    in this section with line-by-line profiling modules. Finally, we will show how
    to create new extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Example – line-by-line profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `line_profiler` and `memory_profiler` packages are line-by-line profilers
    that provide very precise details about the exact portions of the code that take
    too long or use too much memory. They provide magic commands that can be manually
    integrated with IPython. First, we need to install these packages, for example,
    using `easy_install`, `pip`, or Christoph Gohlke's web page for Windows users.
    The `psutil` package is required on Windows, and can be found on the same web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the magic commands implemented in these two packages, we need to
    edit the IPython configuration file and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, the `lprun`, `mprun`, and `memit` magic commands are available. The line-by-line
    profilers work best when the function to profile is defined in a file rather than
    in the interactive session, because the profilers are then able to show the contents
    of each line in the profiling report.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s create a script, `myscript.py`, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function simulates 10,000 random walks (Brownian motions) with 1,000 steps
    and plots a histogram of the particle position at the end of the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to load this function in IPython and profile it. The `%lprun`
    magic command accepts a Python statement as well as a list of functions to profile
    line by line, specified with a `-f` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can observe that most of the execution time happens in the creation of the
    `dx` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `%mprun` magic command can be used similarly for memory profiling.
  prefs: []
  type: TYPE_NORMAL
- en: These line-by-line profilers are particularly useful when profiling complex
    Python applications. It is particularly convenient to do that interactively from
    IPython with those simple magic commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create an extension, we need to create a Python module in a directory, which
    is in the Python path. A possibility is to put it in the current directory, or
    in `IPYTHONDIR/extensions/`.
  prefs: []
  type: TYPE_NORMAL
- en: An extension implements a `load_ipython_extension(ipython)` function, which
    takes the current `InteractiveShell` instance as an argument (and possibly `unload_ipython_extension(ipython)`,
    which is called when the extension is unloaded). This instance can be used to
    register new magic commands, access the user namespace, execute code, and so on.
    This loading function is called when the extension is loaded, which happens when
    the `%load_ext` or `%reload_ext` magic command is executed. To automatically load
    a module when IPython starts, we need to add the module name to the `c.TerminalIPythonApp.extensions`
    list in the IPython configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The InteractiveShell instance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InteractiveShell` instance represents the active IPython interpreter.
    Useful methods and attributes include `register_magics()`, to create new magic
    commands, and `user_ns`, to access the user namespace. You can explore all the
    instance''s attributes interactively from IPython with tab completion. For that,
    you need to execute the following command to get the current instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example – executing C++ code in IPython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we will create a new extension to execute C++ code directly
    from IPython. This is only a pedagogical example, and in a real-world project,
    it might be a better idea to use Cython or SciPy.weave.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extension defines a new cell magic named `cpp`. The idea is that one will
    be able to write C++ code directly in the cell, and it will be automatically compiled
    and executed. The cell output will contain the standard output of the code. Here
    is an explanation of how this extension works:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new class derived from `IPython.core.magic.Magics`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this class, we create a new method with a `cell_magic` decorator: it will
    implement the `cpp` cell magic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method accepts the cell's code as input, writes this C++ code in a temporary
    file, and calls the g++ compiler to create an executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method then calls the newly created executable and returns the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `load_ipython_extension` function, we register this magic class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code should be written in a `cppmagic.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how this extension can be conveniently used
    to write C++ code in the IPython notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example – executing C++ code in IPython](img/9932_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Executing C++ code in the IPython notebook
  prefs: []
  type: TYPE_NORMAL
- en: This code works on Windows and can be easily adapted to Unix systems.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Improving this example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example could be improved in many ways: temporary files could have unique
    names and could be stored in a special temporary directory, compilation errors
    could be nicely handled and redirected to IPython, and so on. The interested reader
    can take a look at the built-in Cython, Octave, and R magic extensions in `IPython/extensions/`
    that are somewhat similar to this example. More generally, the same techniques
    can be used to run non-Python code in IPython. It may even be possible to share
    variables between Python and the other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: The IPython extensions are particularly powerful in the context of the notebook,
    because they notably allow the implementation of arbitrarily complex behaviors
    to the cells' code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Extensions index**'
  prefs: []
  type: TYPE_NORMAL
- en: An index of IPython extensions created by IPython users can be found at [https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index).
    If you have developed your own extension, do not hesitate to add it here!
  prefs: []
  type: TYPE_NORMAL
- en: Rich representations in the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The notebook and the Qt console can display richer representations of objects.
    Both can display bitmap and SVG images, and the notebook also supports videos,
    HTML code, and mathematical equations in LaTeX. It is particularly easy to display
    rich objects with classes: one just needs to implement a method called `_repr_*_`
    with `*` being `svg`, `png`, `jpeg`, `html`, `json`, `pretty`, or `latex`. For
    instance, let''s define a class, `Disc`, with a SVG representation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of this class accepts a radius size in pixels and a color as
    a string. Then, when an instance of this class is directed on the standard output,
    the SVG representation is automatically shown in the cell''s output as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rich representations in the frontend](img/9932_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SVG representation in the IPython notebook
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of displaying rich representations of objects is to use the `IPython.display`
    module. You can interactively obtain the list of all supported representations
    with tab completion. For example, the following screenshot shows how LaTeX equations
    can be rendered in the notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rich representations in the frontend](img/9932_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: LaTeX equations in the IPython notebook
  prefs: []
  type: TYPE_NORMAL
- en: The rich display features of the notebook make it particularly adapted to the
    creation of pedagogical contents, presentations, blog posts, books, and so on,
    as notebooks can be exported in formats such as HTML or PDF.
  prefs: []
  type: TYPE_NORMAL
- en: Yet richer interactive representations will probably be possible in a future
    version of IPython with the support of custom JavaScript extensions and widgets
    in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to launch IPython from any Python script, even when the standard
    Python interpreter runs the script. It can be useful in some occasions when you
    need to interact with a complex Python program at some point, and where using
    the IPython interpreter for the whole program is not possible or unwanted. For
    example, in a scientific computing context, you may want to pause the program
    after some automatic, computationally-intensive algorithms to look at the data,
    draw some plots, and so on, before resuming the program. Another possible use
    case is the integration of a widget in a graphical user interface to let the user
    interact with the Python environment through the IPython command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to integrate IPython in a program is to call `IPython.embed()`
    at any point in your Python program (after `import IPython`). You can also specify
    custom options, including the input/output templates in the command-line interface,
    the startup/exit messages, and so on. You can find more information at [http://ipython.org/ipython-doc/stable/interactive/reference.html#embedding-ipython](http://ipython.org/ipython-doc/stable/interactive/reference.html#embedding-ipython).
  prefs: []
  type: TYPE_NORMAL
- en: Final words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be convinced about the great power and flexibility
    of IPython. Not only does IPython natively offer an impressive number of useful
    features, it also lets you extend and customize it in virtually any aspect. It
    should be noted, however, that this project is still evolving. Although it was
    created more than 10 years ago, Version 1.0 has still not been released at the
    time of writing. The core features of IPython are now quite stable and mature.
    The notebook, which is the most recent feature, is expected to evolve importantly
    in the coming years. The possibility to create custom interactive widgets in the
    notebook is planned and is likely to be a major feature of the whole project.
    More information about the upcoming developments can be found at [https://github.com/ipython/ipython/wiki/Roadmap:-IPython](https://github.com/ipython/ipython/wiki/Roadmap:-IPython)
    and [http://ipython.org/_static/sloangrant/sloan-grant.html](http://ipython.org/_static/sloangrant/sloan-grant.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, IPython is an active open source project, meaning that anyone is welcome
    to contribute. Contributing can be as simple as reporting or fixing a bug, but
    it is always highly useful and greatly appreciated! Relatedly, anyone is welcome
    to request some help online, in respect of the common etiquette rules, of course.
    The developers and the most active users are always willing to help. Here are
    some useful links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub project page: [https://github.com/ipython/ipython](https://github.com/ipython/ipython)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wiki: [https://github.com/ipython/ipython/wiki](https://github.com/ipython/ipython/wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User mailing list: [http://mail.scipy.org/mailman/listinfo/ipython-user](http://mail.scipy.org/mailman/listinfo/ipython-user)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chat room: [https://www.hipchat.com/ghSp7E1uY](https://www.hipchat.com/ghSp7E1uY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we described how IPython can be customized and extended, notably
    through extensions. Non-Python languages can also be called from IPython, which
    is particularly convenient in the notebook where any code can be copied and pasted
    in a cell and transparently compiled and evaluated in the current Python namespace.
    The notebook also supports rich display features and, soon, interactive widgets,
    making it the most advanced tool to date for interactive programming and computing
    in Python.
  prefs: []
  type: TYPE_NORMAL
