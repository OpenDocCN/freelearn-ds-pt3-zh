- en: Appendix C. NumPy Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are the fundamental data structure introduced by `NumPy`, and they are
    the base of all libraries for scientific computing and data analysis we discussed
    in this book. This appendix will give a brief overview of the following array
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Array creation and member access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing and slicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array creation and member access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NumPy` arrays are objects of the `ndarray` class, which represents a fixed-size
    multidimensional collection of homogeneous data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will assume that the `NumPy` library has been imported using the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done that, we can create `ndarray` (from now on, informally called
    **array object** or simply **array**) from a list of lists as indicated in the
    following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Contrary to Python lists and tuples, all entries of an array object must be
    of the same type. The types themselves are represented by `NumPy` objects and
    are referred to as `dtype` (from data type) of the array. In the preceding example,
    we explicitly specify `dtype` as `float64`, which represents a 64-bit floating-point
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays have several attributes that give information about the data layout.
    The more commonly used ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shape of the array is computed using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command returns the tuple `(3, 4)`, since this is a two-dimensional
    array with three rows and four columns. Somewhat surprisingly, the shape attribute
    is not read-only and we can use it to *reshape* the array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running the preceding example, run `a.shape(3,4)` to return to the original
    dimensions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The number of dimensions of the array is obtained using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This, of course, returns `2`. An important notion in `NumPy` is the idea of
    *axes* of an array. A two dimensional array has two axes, numbered 0 and 1\. If
    we think of the array as representing a mathematical matrix, axis 0 is vertical
    and points down, and axis 1 is horizontal and points to the right. Certain array
    methods have an optional `axis` keyword argument that lets the user specify along
    which axis the operation is performed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get the number of elements in the array, we can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the output returned is `12`, as expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One final attribute of arrays is computing the *transpose* of an array. This
    can be done using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An important thing that this creates is a *view* of the array `a`. The `NumPy`
    package is designed to work efficiently with very large arrays, and in most cases,
    avoids making copies of data unless absolutely necessary, or is explicitly directed
    to do so.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following lines of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the entry `2, 1` of the array `a` is changed, demonstrating that both
    variables, `a` and `b`, point to the same area in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An array with uninitialized data can be created with the `empty()` function
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using uninitialized data is not recommended, so it is perhaps preferable to
    use either the `zeros()` or `ones()` function as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the `zeros()` function, execute the following command lines:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the `ones()` function, execute the following command lines:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'There are also functions that create new arrays with the same shape and data
    type of an existing array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The functions `ones_like()` and `empty_like()` produce arrays of ones and uninitialized
    data with the same shape as a given array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumPy` also has the `eye()` function that returns an identity array of the
    given dimension and `dtype`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The number of rows and columns do not have to be the same. In this case, the
    resulting matrix will only be a left- or right- identity, as applicable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arrays can also be created from existing data. The `copy()` function clones
    an array as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `frombuffer()` function creates an array from an object that exposes the
    (one-dimensional) buffer interface. Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `arange()` function is a `NumPy` extension of the Python range. It has a
    similar syntax, but allows ranges of floating-point values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `loadtxt()` function reads an array from a text file. Suppose the text
    file `matrix.txt` contains the following data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can read the data with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arrays can also be saved and loaded in the `.npy` format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Indexing and Slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate indexing, let''s first create an array with random data using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This creates an array of dimension `(6,5)` that contains random data. Individual
    elements of the array are accessed with the usual index notation, for example,
    `a[2,4]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important technique to manipulate data in `NumPy` is the use of **slices**.
    A slice can be thought of as a subarray of an array. For example, let''s say we
    want to extract a subarray with the middle two rows and first two columns of the
    array `a`. Consider the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make a very important observation. *A slice is simply a view of
    an array, and no data is actually copied*. This can be seen by running the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, changes in `b` affect the array `a`! If we really need a copy, we need
    to explicitly say we want one. This can be done using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the slice notation `i:j`, we can omit either `i` or `j`, in which case the
    slice refers to the beginning or end of the corresponding axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting both `i` and `j` refers to a whole axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the notation `i:j:k` to specify a stride `k` in the slice.
    In the following example, we first create a larger random array to illustrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now consider slices of higher dimensional arrays. We will start by creating
    a really large three-dimensional array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to extract all elements with index `1` in the last axis. This
    can be done easily using an ellipsis object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command line is equivalent to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to augment the matrix along an axis when slicing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the output of the preceding command line with the output of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
