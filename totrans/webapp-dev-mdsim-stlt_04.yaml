- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streamlit Essentials – Configuring the Environment, Managing Packages, and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the basics of building a Python web application using the
    Streamlit framework. It is designed for beginners who want to learn how to develop
    a web application from scratch and covers several important topics, including
    setting up a virtual environment, installing and managing packages, creating an
    app skeleton, and adding a menu and decoration to the app.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is the first of a section consisting of four more chapters. In
    these chapters, we will learn how to build basic web applications while developing
    essential Streamlit skills. We are adopting a *learning-by-doing* approach, so
    we are going to build, test, and deploy a real working web app – a **natural language
    processing** (**NLP**) app – from scratch. So, let’s make it!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts by recalling the concept of virtual environments and explains
    why they are important for Python development. Once the development environment
    has been set up, the focus moves on to creating the application skeleton, which
    involves defining the structure and layout of the app. This kind of skeleton is
    a very valuable resource to be used for future web app development. After that,
    we’ll cover how to add a menu and decoration to the app to create a nice, good-looking,
    and user-friendly web interface.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a basic understanding of how to
    build a Python web application using Streamlit and be able to create an app with
    custom menus and decorations while leveraging the skeleton that you’ve created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and importing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: App skeleton building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the menu and adding decorations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streamlit`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textblob`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spacy`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neattext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wordcloud`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/4306036e2ddf9a714f2f058f76363aac5b402d5b/Chapter04](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/4306036e2ddf9a714f2f058f76363aac5b402d5b/Chapter04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are finally here and building our first web application from scratch! From
    scratch means working from the beginning, even before an empty Python file. The
    approach is easy – we start by sitting and coding together. Let’s start by creating
    our virtual environment, which is dedicated exclusively to this new app we will
    develop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve already learned in previous chapters, we must fire up our Terminator
    terminal and create an empty directory named `web_app1` with the following instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must enter the following instruction in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last instruction, as we saw previously and already know, will create the
    virtual environment with `pipenv`, as shown in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Creating a virtual environment in pipenv](img/B21147_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Creating a virtual environment in pipenv'
  prefs: []
  type: TYPE_NORMAL
- en: Since it will help us a lot in managing code and Streamlit’s execution, let’s
    divide our Terminator terminal into two parts, splitting it horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following line in the lower tile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 4.2: Selecting a virtual environment](img/B21147_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Selecting a virtual environment'
  prefs: []
  type: TYPE_NORMAL
- en: Once you are inside the virtual environment, in your terminal prompt, you will
    see its name in parentheses (in our case, `web_app1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are inside `web_app1`, so we can open our editor, Sublime Text, by typing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware of the point (`.`) after the blank space; in other words, there
    is a blank space between `subl` and the point (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, Sublime Text will fire up from our working folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Launching Sublime Text from the virtual environment](img/B21147_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Launching Sublime Text from the virtual environment'
  prefs: []
  type: TYPE_NORMAL
- en: With that, our virtual environment is working, and our editor is ready. This
    means that it’s time to deal with all the packages that are required by the web
    application. We need to install these packages to make the web app work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and importing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make our web application work properly, we need the following Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`streamlit`: This is the core – that is, the framework that makes the magic
    happen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textblob`: This is a nice package for basic sentiment analysis and some other
    basic NLP tasks (NLP is how computers understand human language, its meaning,
    its syntax, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spacy`: This is quite an advanced package; it’s state of the art and can be
    used for almost any NLP task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neattext`: A very simple package for text cleaning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib`: Python’s most famous package for plotting graphs, diagrams, and
    so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wordcloud`: A package dedicated to nice word cloud creation and visualizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can install all these packages in our virtual environment (so we must already
    be inside the virtual environment) by typing the following unique instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that this operation can take a few minutes to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Package installation](img/B21147_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Package installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the Pipfile from Sublime Text, you will see that all the packages
    have been installed correctly, as reported in *Figure 4**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Pipfile with the installed packages](img/B21147_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Pipfile with the installed packages'
  prefs: []
  type: TYPE_NORMAL
- en: '*spaCy* is a very powerful package for NLP and requires a dedicated language
    model for each language we want to manage. So, before we start coding, we need
    to download the English language model. Let’s write the following instruction
    in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction will download the `en_core_web_sm` English language model,
    whose size is 12.8 MB. The file’s name is quite self-explanatory: `en` means English,
    `core_web` means that the model has been trained on a dataset containing text
    coming from the web, and `sm` stands for small (if you want to get an idea of
    all languages, models, and their size, you can check spaCy’s official website):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Downloading the spaCy language model](img/B21147_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Downloading the spaCy language model'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have everything we need to start coding. There’s just one thing missing:
    the Python file! Without it, we cannot code. Let’s create it by typing a simple
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: The app.py file](img/B21147_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: The app.py file'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, everything is ready: our environment is OK, our packages have been
    installed, and our empty `app.py` file is there.'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to start writing the code for our first working web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to open the `app.py` file in Sublime Text and import all
    the libraries we have installed so that we can write the code, as shown in *Figure
    4**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Importing the necessary libraries](img/B21147_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Importing the necessary libraries'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code imports `streamlit` with the `st` alias and imports all NLP
    packages (`textblob`, `spacy`, and `neattext`) and all the visualization libraries.
    Please note that for `matplotlib`, we are using the `Agg` engine since, with Streamlit,
    it works better than the default one.
  prefs: []
  type: TYPE_NORMAL
- en: After importing, we are finally ready to write all the code for our first real
    web application. Let’s do it right now!
  prefs: []
  type: TYPE_NORMAL
- en: App skeleton building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need a main function – a function that contains all the business
    logic of our app and the frontend too. This is the power of Streamlit – building
    the frontend directly inside Python code. There’s no need for different programming
    languages, files, and so on; everything is in one place using the same language.
    Writing this function is very easy – we can add the code shown in *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Importing the necessary libraries and the main function](img/B21147_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Importing the necessary libraries and the main function'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the code is quite self-explanatory – we are just importing
    all the libraries that were introduced a couple of pages before. Just note that
    when we import `matplotlib` (the library needed for plotting), we are specifying
    that we wish to use the `Agg` engine (without this instruction, `matplotlib` would
    use its default engine). With Streamlit’s initial versions, this `Agg` engine
    used to work better, but with the very recent versions, `matplotlib`’s standard
    engine performs well too. So, the suggestion is to try with and without this instruction
    and to use it only in the case of a real improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, thanks to `def`, we can create a function named `main`. At the moment,
    this function just prints a title on the screen (`st.title`): *NLP* *Web App*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it – we are ready to launch the web application we’ve made with Streamlit.
    In our browser, we’ll see our beautiful title: *NLP* *Web App*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the app in our terminal, we should write `streamlit run app.py`. However,
    since we are inside a `pipenv` environment, we have to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This instruction starts a web server that runs our Streamlit app on port `8501`.
    Our Streamlit app is the code contained in the `app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately, the browser will open up on `localhost port 8501` and we will
    see the web app, as shown in *Figure 4**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Web app running on localhost:8501](img/B21147_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Web app running on localhost:8501'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, the web application is doing nothing but showing the *NLP Web
    App* title, together with the *hamburger menu* at the top right. Please explore
    all the options contained in this menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is important to understand now is that usually, all applications perform
    a set of tasks, let’s say three or four or *N* (any number), and for this reason,
    all applications have the same *skeleton*, a common structure or backbone that
    enables each task. These tasks can be included in an application menu and built
    up by a *selectbox*, allowing the user to choose what to do. We can put this selectbox
    on the left-hand side of our app. So, assuming that the tasks of *NLP Web App*
    will be `st.title` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save the `app.py` file and click on **Always rerun** in the web app (in
    the top-right corner); in this way, all the new lines of code will be immediately
    executed as soon as we save them. As shown in *Figure 4**.11*, we have added the
    menu on the left-hand side of our web app. This menu contains the four tasks we
    included in the *activity* list. If you want, you can click on the **x** button
    to minimize the left-hand side column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Left-hand side menu](img/B21147_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Left-hand side menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'To let our menu do something, we have to add some logic for each of its items.
    We can do this by adding the following code in the main function. At the moment,
    we are just displaying some sub-headers any time we select a specific option on
    the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Adding some logic to the main menu](img/B21147_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Adding some logic to the main menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in *Figure 4**.12* is quite easy: we create a list of four items (the
    `activity` variable) and use it to populate a *selectbox* on the sidebar. This
    means that this selectbox will show only four options. When we select one of these
    options (for example, `if`s (four ifs because we have four options) to understand
    the value of the selection in the selectbox. Simply put, we check `if` our selection
    in the selectbox is *equal to* any of the items in the menu; if so, we just print
    a subheader (for now, the related action is only printing a subheader; we’ll write
    a more complex action in the future) with the item’s name and a blank line. So,
    if we select **Sentiment Analysis**, we print a **Sentiment Analysis** subheader
    on the screen, as displayed in *Figure 4**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: “Sentiment Analysis” selection from the left-hand side menu](img/B21147_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: “Sentiment Analysis” selection from the left-hand side menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it should be clear that any kind of logic has to be applied
    in the `main` function inside its specific `if` clause. For example, if we want
    the **About** section to do something more than just display a subheader containing
    the **About** text, we can write the code for its business logic in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Business logic inside the “About” section](img/B21147_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Business logic inside the “About” section'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, when the `choice` variable is *equal to* `st.write("")`), and
    then some text formatted with the Markdown language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we wrote with the `st.markdown` instruction is quite self-explanatory;
    we are just printing (using the Markdown format) some information on the screen
    about our web application and a clickable link to Streamlit’s website, considering
    that the `[streamlit](`[https://streamlit.io](https://streamlit.io)`)` instruction
    is just the Markdown syntax to include hyperlinks in the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: The “About” section of our web app](img/B21147_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: The “About” section of our web app'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve created a very neat skeleton (that is, a structure) for our web
    application, imported all the libraries we are going to use, created a main function
    where we created a menu (..., which will be displayed on the left-hand side of
    the app and is collapsible) containing all the tasks our web application is going
    to cover, and created the `if` clause.
  prefs: []
  type: TYPE_NORMAL
- en: It’s incredible, but this simple skeleton can be applied to all the web applications
    we are going to build from now on. All we need to change or adapt is the list
    of tasks (the list inside the menu on the left-hand side) and the business logic
    for each of these items.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that, even if the web app is working well now, it is not very appealing.
    So, let’s try adding some decorations.
  prefs: []
  type: TYPE_NORMAL
- en: Building the menu and adding decorations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*NLP Web App* might be a good title for our application, but to be honest,
    it’s just some black text on a white background, so it’s not very appealing at
    the moment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the greatest features of Streamlit is that we can use HTML very easily.
    So, let’s add some simple HTML code to our `main` function just to make everything
    much more stylish! We can change the old `st.title("NLP Web App")` first line
    of code that sits after the main function declaration with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Adding some HTML to our title](img/B21147_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Adding some HTML to our title'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `title_template`, we are specifying the *background color* (blue), the *padding
    size*, and the *text style* (h1) and its *color* (cyan). With the `st.markdown`
    instruction, as we learned previously, we are just visualizing the HTML; you can
    play around and customize it as you want by changing the background and text color,
    padding, text, and more. This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: A colored title for our app](img/B21147_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: A colored title for our app'
  prefs: []
  type: TYPE_NORMAL
- en: The effect is very nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a subtitle. To do this, we can use a subheader and use more
    or less the same HTML code. We just need to add another couple of lines of code,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: The final code for the title and subheader](img/B21147_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: The final code for the title and subheader'
  prefs: []
  type: TYPE_NORMAL
- en: 'We approached this the same way we approached `title_template` in *Figure 4**.16*:
    we defined some HTML in a variable (in this case, `subheader_template`) and then
    visualized it using `st.markdown` and by setting the `unsafe_allow_html` argument
    to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, everything is fully customizable according to your
    ideas. This is the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: The final colored title and subheader](img/B21147_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: The final colored title and subheader'
  prefs: []
  type: TYPE_NORMAL
- en: Since we put these decorations at the very beginning of the main function –
    that is, before creating the left-hand side menu and the `if` clauses that are
    in charge of selecting various tasks – the colored HTML title and header will
    not change when we switch the various menu items since they are fixed on the top
    of the screen and give our web application a very good *style consistency*. In
    short, since we put this HTML code at the beginning of the main function, it will
    be applied to the entire web application and not to any specific task – everything
    will be affected by this title. The title will be a fixed element of our web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our web application’s panel in the browser, we will see that
    the icon and the title are the default ones since the icon is Streamlit’s, and
    the title is just the name of our Python file (`app.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: The web app’s default icon and title in the browser](img/B21147_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: The web app’s default icon and title in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s customize these two very important features. In Streamlit, there is an
    instruction dedicated exactly to this purpose, but – and this is very important
    – it has to be placed immediately after the `streamlit import` line. This instruction
    is `set_page_config`. Let’s add it to our `app.py` file and then explain how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: The set_page_config instruction](img/B21147_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: The set_page_config instruction'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_page_config` accepts a certain number of arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`page_title`: The title of our page; this is a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page_icon`: An icon (an image file) or an emoji (the emoji itself or its code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout`: This can be `centered` or `wide`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial_sidebar_state`: This can be `wide`, `expanded`, or `collapsed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can experiment with different configurations and easily find information
    on how to use each instruction in Streamlit’s **Documentation** section, which
    includes input arguments and output results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot explains the `set_page_config()` instruction. As you
    can see, there are several different configurations that we didn’t explore, and
    it’s possible to combine them to fully customize your web application. So, please
    don’t forget to carefully check the official Streamlit documentation to get the
    most value out of this incredible framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Streamlit’s official documentation](img/B21147_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Streamlit’s official documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve looked at Streamlit’s official documentation, let’s have a look
    at our web application with the new page title and icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Icon and title customization in the browser panel](img/B21147_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Icon and title customization in the browser panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in the browser tile related to our web application, we have
    a full set of customizations: an icon representing a thumb and a personalized
    title stating *NLP Web App*. This is the result of the code we saw in *Figure
    4**.21*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to, you can see what happens upon changing the 👍 emoji we used as
    an icon with an image, such as a PNG file that you like. You can also check how
    the web application behaves when we set `initial_sidebar_state` to `wide`, `expanded`,
    or `collapsed` and `layout` to wide.
  prefs: []
  type: TYPE_NORMAL
- en: The decorations we added to our web app skeleton are clean, neat, and good-looking
    but up until now, excluding the **About** section, which can be considered closed,
    the rest need to be completed with some business logic to make the various **Text
    Analysis**, **Translation**, and **Sentiment Analysis** tasks work properly. This
    is exactly what we are going to do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows all the code we wrote. It’s quite interesting to
    point out how, in only 64 lines of code, including empty lines and comments, we
    have built up a working web application that lives on the web and can be used
    by a browser and that contains a menu, some sections, HTML, titles, and decorations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21147_04_24.jpg)![](img/B21147_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: The app.py file'
  prefs: []
  type: TYPE_NORMAL
- en: The best part is that you can reuse it as you wish!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began from scratch. First of all, we prepared our `pipenv`
    environment, installed all packages needed for the web application, and finally
    created an empty Python file.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we built up a *skeleton* that can be reused any time we want to
    develop a new web application. This skeleton is made up of an initial part where
    we import all the packages we need and a *main* function that is dedicated to
    containing all the business logic of our web app.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of the main function, some features must be applied to the
    entire web application, such as its title and subtitle, which we created with
    very beautiful and colorful HTML, and the web browser’s panel icon and title.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the main function, we created a menu that will be shown
    on the left-hand side of our web application and that lets the user choose from
    the various tasks our web application can perform. Upon selecting one of the tasks
    in the menu, the web application will show its specific section performing its
    specific task. We implemented this because we wanted to start with a very easy
    case. The **About** section now performs well, showing the name/title of the web
    application and some useful information – in this case, the working link to Streamlit’s
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is working well and has been customized according to our willingness
    and future needs. This shows that this skeleton is a great weapon in our developer’s
    toolkit!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start building the complete business logic of our
    application by using and learning about some very powerful widgets such as columns
    and expanders, as well as some NLP techniques!
  prefs: []
  type: TYPE_NORMAL
