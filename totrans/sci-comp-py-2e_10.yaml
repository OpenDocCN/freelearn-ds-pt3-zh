- en: Series and Dataframes - Working with Pandas
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we give a brief introduction to pandas—the central tool in
    Python for data analysis and data handling. You will learn how to work with various
    time series in Python, the concept of dataframes, and how to access and visualize
    data. You will also find examples that demonstrate how smoothly pandas interacts
    with the other central modules in this book, namely NumPy and Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: But please note, this chapter can, within the scope of this book, only serve
    as an *appetizer*. Its purpose is to equip you with the basic concepts. The full
    range of visualization, data analysis, and data conversion tools in pandas is
    impressive.
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers many ways of importing data. Some of them will be presented together
    with guiding examples throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A guiding example: Solar cells'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy arrays and pandas DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and modifying dataframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dataframes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10\. 1 A guiding example: Solar cells'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To describe pandas in the best way, we need data. Thus, in this chapter, we
    will use production data from solar cell panels on the roof of a private house
    in the south of Sweden.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file `solarWatts.dat` there is data about the electricity production
    in watts per minute. A semicolon is used as a data separator and the first line
    in the file is a header line, explaining the content of the data columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In another file, `price.dat`, we find the hourly electricity production price
    in Swedish crowns. The file is otherwise organized as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in a third file, `rates.dat`, we find the daily conversion rates from
    Swedish crowns to Euros (€):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We want to extract from this data information about the maximal and minimal
    production per day, the number of hours of sun per month, the sunniest day so
    far, information about sunrise and sunset, and some economic information. We also aim
    to graphically present data.
  prefs: []
  type: TYPE_NORMAL
- en: Note, the data is not collected at the same time points and there might be missing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Each file contains a so-called time-series, that is, data depending on time or
    a discrete sampling of a time-depending function.
  prefs: []
  type: TYPE_NORMAL
- en: We now introduce the concept of dataframes in pandas and compare it to NumPy
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 NumPy arrays and pandas dataframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by just looking at an example of a [![](img/6bc9c04c-a8b4-41ae-82b5-1760f08e0e9d.png)] NumPy
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is displayed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And its elements are accessed by using indexes generated simply by counting
    rows and columns, for example, `A[0,1]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This matrix can be converted to the pandas datatype `DataFrame` by keeping
    the same data and order but representing and accessing it in a different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `DataFrame` object, which we will explain in more detail in this chapter,
    is displayed as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We see that a pandas dataframe has extra labels for the rows and columns called *index*
    and *columns*. These are the metadata of a dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, they coincide with NumPy''s indexing, but that is not always so. The index
    and columns metadata allows the pandas dataframe to label the data in a way that''s
    known from classical table design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will see now how to work with these labels to address a subframe or just
    a value in the dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.1 Indexing rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the way dictionaries use keys to address a value, pandas dataframes
    use row labels—the dataframe index—and column labels to access individual values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to generate a subframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Resulting in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also address a complete row by using the index label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a pandas `Series` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If `loc` or `iloc` are called with list arguments or slices, the result is a
    dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that way, an individual dataframe element can also be addressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An entire column is addressed directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This again returns a pandas `Series` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, the column label can be used as an attribute, `AF.C1`.
  prefs: []
  type: TYPE_NORMAL
- en: A single column is an instance of the pandas datatype, `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note, a pandas series has no column label. It is just a single column corresponding
    to a single type of measured data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, you can use classical indexing by applying the dataframe method `iloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If `loc` or `iloc` are called with list arguments or slices, the result is
    a dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'While calling with a pair of single labels just gives an element of the dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is in full agreement with the way NumPy handles the indexing of arrays.
    Recall that indexing with slices returns an array, while indexing with single
    integers returns a single element of the indexed array.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that `loc` and `iloc` are not dataframe methods. Rather,
    they are attributes that have `__getitem__` method; see also [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods*. That explains the use of brackets instead of parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Creating and modifying dataframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We return now to the solar cell data and explain how to create a dataframe from
    a data file. The format of the file with the given data is CSV. Each line in the
    file contains one data record with a comma or another character string as a data
    separator. Here, we used a semicolon as a separator because in many countries
    the comma is used instead of a decimal separator.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1 Creating a dataframe from imported data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to organize the dataframe in such a way that the dates are used as
    the index of the dataframe. To be better prepared for operating with dates, we
    also want that the data import process automatically converts date strings to
    a pandas `Timestamp` object. Finally, you might have noted that the way the date
    is written in the data files is in the ISO-format `YY-MM-DD` format and not in
    the American `MM-DD-YY` or the European `DD-MM-YY` format. We can put on our wishlist
    that pandas automatically recognizes the date format and performs the correct
    conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The pandas command `read_csv` is the central tool. It has many more parameters
    than we used here and carefully studying their functionalities saves a lot of
    programming effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a pandas dataframe, `solarWatts`, with more than 200,000 data records.
    Let''s directly check the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also ask for the last date. To this end, we use the attribute `index` of
    the dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This returns a pandas `Timestamp` object `Timestamp('2020-06-27 17:54:00')`.
    This object or its string representation can be used for indexing.
  prefs: []
  type: TYPE_NORMAL
- en: '`Timestamp` objects make it easy to perform calculations with dates, define
    time ranges, and compare dates. We can check how much time passed between the
    measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The resulting object `Timedelta` tells us that the time elapsed between the
    first and second records is one minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'But is all data collected every minute? As pandas is compatible with NumPy,
    we can apply Numpy''s command `diff`, which returns an array with the datatype
    `timedelta64[ns]`, that is, the differences are given in nanoseconds. We convert
    the result directly to minutes and ask for the maximal difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With `numpy.argmax`, we find the corresponding date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we first form an array with the time differences (`timedelta`).
    We use this as an index to locate the data record in the pandas dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.2 Setting the index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default index of a dataframe is the row numbers. These are generated automatically
    when a dataframe is created and no index is specified. Here is an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a dataframe from a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a dataframe with rows labeled by their row numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change this by choosing a column to be the index. The column can be
    duplicated—one serving as the index and the other belonging to the data section
    of the dataframe—or it can be moved to replace the default index column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A *new* dataframe is generated, which looks like this when the `drop` parameter
    was set to `True` (default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The additional parameter `inplace` enables to change the dataframe directly,
    that is, *in place*, without generating a new object.
  prefs: []
  type: TYPE_NORMAL
- en: pandas is not restricted to one index only; indeed, several columns can be chosen
    as an index. Such a multi-index opens for **hierarchical indexing**, a feature
    of pandas which we will meet again in [Section 10.4.3](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml): *Grouping
    data**.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Several indexes are specified by a list of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the dataframe is displayed now: the first index, `Country`, is taken
    as the one with higher hierarchy level than the second index, `City`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can address all Swedish towns in the frame as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even address a particular one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 10.3.3 Deleting entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entries in a dataframe are deleted by the method `drop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we use the dataframe from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'An entire row is deleted by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter `axis` specifies here that we look for a row. Deleting a row
    requires the column label and the correct parameter `axis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 10.3.4 Merging dataframes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the three datafiles we provided for this chapter we used the first one,
    `solarwatts.dat`, to set up a dataframe `solarWatts`; see [Section 10.3.1](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml),
    *Creating a dataframe from imported data*. In a similar way, we can create dataframes
    `price` and `rates` from the other two files.
  prefs: []
  type: TYPE_NORMAL
- en: We show now how to merge these three dataframes into one and to treat rows with
    missing data in the resulting dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we merge `solarWatts` with `price`. For this, we use the pandas command
    `merge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It sets the column `Date`, which exists in both dataframes as the index of the
    new frame. The parameter `how` defines how to set up the new index column. By
    specifying `outer` we decided to choose the union of both index columns. Finally,
    we want to sort the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'As `solarWatts` has data for every minute and the price changes on an hourly
    basis, we obtain in the new dataframe lines like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The missing data is automatically filled with `NaN` (which means *not a number*; see
    [Section 2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml): *Numeric types*).'
  prefs: []
  type: TYPE_NORMAL
- en: We will study now how to treat missing data.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.5 Missing data in a dataframe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw in the last section that missing data is often indicated by `NaN`. The
    way missing data is indicated depends on the datatype of the column. Missing timestamps
    are indicated by the pandas object `NaT`, while missing data with another non-numeric
    datatype is indicated by `None`.
  prefs: []
  type: TYPE_NORMAL
- en: The dataframe method `isnull` returns a Boolean dataframe with the entry `True`
    at all places with missing data.
  prefs: []
  type: TYPE_NORMAL
- en: We will study various methods for treating missing data before returning to
    the solar cell data example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate these methods on a small dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This dataframe is displayed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Dataframes with missing data can be handled in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drop all rows containing missing data, `frame.dropna(axis=0)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Drop all columns containing missing data, `frame.dropna(axis=1)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the missing data by padding data from previous the row, `frame.fillna(method=''pad'',axis=0)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if there is no data to pad with, `NaN` remains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpolate numeric data column-wise, `frame.interpolate(axis=0, method=''linear'')`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Again, values that cannot be computed by interpolation remain as `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: The way we used the method interpolate assumes that data is collected on an
    equidistant grid. If the index is numeric or a datetime object it can be used
    as the ![](img/8cf5b441-997d-4736-ace9-01b5b1b415c8.png)-axis. This is achieved,
    for example, by using the parameter value `method='polynomial'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use different methods on different columns is possible by using the parameter
    inplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We return now to the solar cell example. Electricity prices change on an hourly
    basis, valuta exchange rates on a daily basis, and the energy production by the
    solar panels is recorded every minute during daylight times. This is the reason
    why the dataframe merging step introduced many NaN (see [Section 10.3.4](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml),
    Merging dataframes).
  prefs: []
  type: TYPE_NORMAL
- en: 'We replace these missing values by padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are still `NaN` values in the table. The solar cells produce only energy
    during the daytime with sufficient light. Outside these periods, the column Watt
    contains the value `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we visualize the data with pandas' dataframe plot functionality
    and we will see that `NaN` values are simply ignored in the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Working with dataframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to create and modify a dataframe. Now, we turn to data
    interpretation. We will look at examples of visualization, show how to make simple
    calculations, and see how to group data. These are all stepping stones into the
    world of pandas. The strength of this module is in its large range of statistical
    tools. We leave the presentation of these tools to textbooks on practical statistics,
    while we focus here on the basic principles of pandas programming. We do not aim
    for completeness. Again, let's serve an appetizer.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.1 Plotting from dataframes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the plotting functionality, we plot the energy price changes
    on May 16, 2020\. For this, we construct a subframe of the data from that day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we indexed here with the full day. This is a short form of
    slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The resulting plot, Figure 10.1, shows the hourly variation of electricity prices
    in Swedish crowns on a typical day of the year.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/179951bd-d922-48f3-9ebd-c446adc48dee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Plotting one column of a dataframe; the hourly price in Swedish
    crowns (SEK) per kWh on May 16, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: pandas' plot command is built upon plot from the module matplotlib.pyplot, which
    we met in [Chapter 6](86c61820-e645-486c-9418-10079ffac7f8.xhtml), Plotting.
  prefs: []
  type: TYPE_NORMAL
- en: It accepts the same parameters, for example, linestyle or marker.
  prefs: []
  type: TYPE_NORMAL
- en: The data for the x axis is taken from the dataframe index if not otherwise specified.
    Alternatively, you can plot one dataframe column versus another.
  prefs: []
  type: TYPE_NORMAL
- en: Line plots leave gaps where data is missing. You see this in the next figure
    that displays the solar cell's power in the first week of June 2020\. As there
    is no solar cell data outside daylight time, the plot has gaps. See Figure 10.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85f3638d-5375-42c4-8f13-3d79b12ae54d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: A plot of a data series with missing data (`NaN`): the power in
    Watts of the solar cells in the first week of June 2020\. You can clearly see
    the periods where no energy was produced'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command we used for this plot is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the advantage of working with an axis object, ax1 in this
    case. This allows us to modify the axis labels or the legend, for example, ax1.legend(['Power
    [W]').
  prefs: []
  type: TYPE_NORMAL
- en: We give more plot examples in the next sections, when we see how to do some
    calculations within dataframes and how to group data.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.2 Calculations within dataframes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do simple calculations on dataframe columns by applying functions on
    every element of the column, that is, elementwise application of functions. These
    functions can be built-in Python functions, NumPy functions, or user-defined functions,
    such as lambda functions (see [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml),
    Anonymous functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way is to operate on the columns directly. In the following example,
    we convert watts into kilowatts and Swedish crowns (SEK) into Euros by using the
    conversion rate, which was the actual rate on the day of the measurement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tacitly, we also adjusted the column labels to the converted units.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command `solar_converted.loc[''2020-07-01 7:00'':''2020-07-01 7:04'']` then
    returns the converted data for July, 1st 2020:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply NumPy''s (universal) functions to entire rows or columns.
    The following example computes the maximal power supplied by the solar cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To print the corresponding date, we use the function argmax :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed date is then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding examples, one can see that missing data marked by NaN is
    treated really as missing data, that is, as if it was not there. As not all computational
    methods have this property, it might be safer to replace NaN with 0 in these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: For the application of general user-defined functions, there is a dataframe
    method apply. It performs row- or column-wise operations on the entire dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4.3 Grouping data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to group data is one of the essential features for pandas' dataframes.
    In the solar cell example, you saw that we had a data frequency of one measurement
    per minute. What if you want to report on an hourly or daily basis instead? We
    just form groups and aggregate the data in a prescribed way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example forms a new dataframe with the two columns labeled Watt
    and SEK reporting the peak solar cell power per day and the average price in SEK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can visualize the results by using the dataframe method plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, we created an axis object, ax, in order to change the tick labels on
    the ![](img/82a1cecf-66e2-4cc1-8b3f-f212f89db8fb.png)-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in Figure 10.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e5178b2-1f65-46fa-a11c-48e1267f916c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Peak solar cell power per day in June 2020'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we grouped all days within a month.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also jump hierarchies when grouping: In the preceding example we grouped
    days within a month but we can also group by hours within a month or even from
    the entire set. For example, to see if the price for electrical energy normally
    has two peaks per day, we can group the data by hour and form the mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands result in Figure 10.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ca5b399-dd25-445e-ac3d-cee442b937af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: The result of data grouping hour-wise'
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping data is often a starting point for getting answers to special questions
    that require computational steps on grouped data. For instance, in our example,
    we have the minute-wise power (in Watts) of the solar cells, but what is the hourly
    energy output in kWh of this system? To answer this question, we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Group the data hour-wise in a hierarchical way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form the discrete integral of the data on 60 minute intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store this in a new dataframe or series object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first task, we make use of pandas'' ability to make a hierarchical
    indexer. We group hierarchically by year, month, day, and hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Integration can be done in this case, as we started with the per-minute data,
    just by summing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we visualize the result in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us Figure 10.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11a87d19-fc4e-44d6-92b6-86a901817dd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: An example plot of a dataframe produced by hierarchical grouping'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we could have used the command scipy.integrate.simps for the
    integration of discrete data as a parameter of the aggregate method, agg. As this
    function does not treat missing data, the remark at the end of [Section 10.4.2](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml),
    Calculations within dataframes, applies, and we would have to replace all NaN values
    with 0 before we start.
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you got a brief introduction to pandas and saw how the concept
    of NumPy arrays is extended to dataframes. Instead of a never-complete explanation
    of the possibilities of dataframes, we guided you using an example of solar cell
    energy data through the first steps with pandas: setting up a dataframe from a
    file, merging frames, grouping data, and making calculations.'
  prefs: []
  type: TYPE_NORMAL
