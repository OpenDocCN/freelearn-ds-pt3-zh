<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Testing
                </header>
            
            <article>
                
<p>In this chapter, we'll focus on two aspects of testing for scientific programming. The first aspect is the often difficult topic of <em>what to test</em> in scientific computing. The second aspect covers the question of <em>how to test</em>. We will distinguish between manual and automated testing. Manual testing is what is done by every programmer to quickly check that a program is doing what it should or should not. Automated testing is the refined, automated variant of that idea. We will introduce some tools available for automatic testing in general, with a view of the particular case of scientific computing.</p>
<h1 id="uuid-01d8bfaa-ec20-4b2f-be64-b29348d6a003">15.1 Manual testing</h1>
<p>During code development, you do a lot of small tests in order to test its functionality. This could be called manual testing. Typically, you would test if a given function does what it is supposed to do, by manually testing the function in an interactive environment. For instance, suppose that you implement the bisection algorithm. It is an algorithm that finds a zero (root) of a scalar non-linear function. To start the algorithm, an interval has to be given with the property that the function takes different signs on the interval boundaries (see Exercise 4 in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.10</a>: Exercises, for more information).</p>
<p>You will then test an implementation of that algorithm, typically by checking that:</p>
<ul>
<li>A solution is found when the function has opposite signs at the interval boundaries.</li>
<li>An exception is raised when the function has the same sign at the interval boundaries.</li>
</ul>
<p>Manual testing, as necessary as it may seem to be, is unsatisfactory. Once you have convinced yourself that the code does what it is supposed to do, you formulate a relatively small number of demonstration examples to convince others of the quality of the code. At that stage, you often lose interest in the tests made during development, and they are forgotten or even deleted. As soon as you change a detail and things no longer work correctly, you might regret that your earlier tests are no longer available.</p>
<h1 id="uuid-b75cad25-4a5e-479a-b45a-81c6e66c1171">15.2 Automatic testing</h1>
<p>The correct way to develop any piece of code is to use automatic testing. The advantages are:</p>
<ul>
<li>The automated repetition of a large number of tests after every code refactoring and before any new versions are launched.</li>
<li>Silent documentation of the use of the code.</li>
<li>Documentation of the test coverage of your code: Did things work before a change or was a certain aspect never tested?</li>
</ul>
<p class="mce-root">Changes in the program and in particular in its structure that do not affect its functionality are called code refactoring.</p>
<p>We suggest developing tests in parallel to coding. Good design of tests is an art of its own and there is rarely an investment that guarantees such a good pay-off in development time savings as the investment in good tests.</p>
<p>Now we will go through the implementation of a simple algorithm with the automated testing methods in mind.</p>
<h2 id="uuid-da11c403-9acd-49de-945f-9b8fda0ed1b0">15.2.1 Testing the bisection algorithm</h2>
<p>Let's examine automated testing for the bisection algorithm. With this algorithm, a zero of a real-valued function is found. It is described in <em>Exercise 4</em><span> </span>in<span> <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.10</a>: <em>Exercises</em></span>. An implementation of the algorithm can have the following form:</p>
<pre>def bisect(f, a, b, tol=1.e-8):
    """
    Implementation of the bisection algorithm 
    f real valued function
    a,b interval boundaries (float) with the property 
    f(a) * f(b) &lt;= 0
    tol tolerance (float)
    """
    if f(a) * f(b)&gt; 0:
        raise ValueError("Incorrect initial interval [a, b]") 
    for i in range(100):
        c = (a + b) / 2.
        if f(a) * f(c) &lt;= 0:
            b = c
        else:
            a = c
        if abs(a - b) &lt; tol:
            return (a + b) / 2
    raise Exception('No root found within the given tolerance {tol}')</pre>
<p>We assume this to be stored in a file named <kbd>bisection.py</kbd>. As the first test case, we test that the zero of the function <span><img class="fm-editor-equation" src="assets/73d8d9ce-c997-4f58-b10d-293373566190.png" style="width:3.67em;height:1.08em;"/></span><span> </span>is found:</p>
<pre>def test_identity(): <br/>   result = bisect(lambda x: x, -1., 1.) <br/>   expected = 0. <br/>   assert allclose(result, expected),'expected zero not found' <br/>test_identity()</pre>
<p>In this code, you meet the Python keyword<span> </span><kbd>assert</kbd><span> </span>for the first time. It raises the <span>exception</span> <kbd>AssertionError</kbd><span> </span>if its first argument returns the <span>value</span><span> </span><kbd>False</kbd>. Its optional second argument is a string with additional information. We use the function<span> </span><kbd>allclose</kbd><span> </span>in order to test for equality of floats.</p>
<p>Let's comment on some of the features of the test function. We use an assertion to make sure that an exception will be raised if the code does not behave as expected. We have to manually run the test in the line<span> </span><kbd>test_identity()</kbd>.</p>
<p>There are many tools to automate this kind of call; we will see one of those in <a href="dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml">Section 15.2.2</a>: <em>Using the unittest module</em>.</p>
<p>Let's now set up a second test that checks if<span> </span><kbd>bisect</kbd><span> </span>raises an exception when the function has the same sign on both ends of the interval. For now, we will suppose that the exception raised is<span> </span><kbd>ValueError</kbd>. In the following example, we will check the initial interval <img class="fm-editor-equation" src="assets/94594833-3513-47cc-922c-b6e7d33b41bb.png" style="width:2.17em;height:1.25em;"/>. For the bisection algorithm, it should fulfill the sign condition:</p>
<pre>def test_badinput():
    try:
        bisect(lambda x: x,0.5,1)
    except ValueError:
        pass
    else:
        raise AssertionError()

test_badinput()</pre>
<p>In this case, an<span> </span><kbd>AssertionError</kbd><span> </span>is raised if the exception is not of the <span>type</span> <kbd>ValueError</kbd>. There are tools to simplify the preceding construction to check that an exception is raised.</p>
<p>Another useful test is the edge case test. Here we test arguments or user input, which are likely to create mathematically undefined situations or states of the program not foreseen by the programmer. For instance, what happens if both bounds are equal? What happens if <img class="fm-editor-equation" src="assets/d002cedc-dd50-438b-ba03-6b7658b83e07.png" style="width:2.67em;height:1.00em;"/> ?</p>
<p> </p>
<p>The following code is an example for such an edge test:</p>
<pre>def test_equal_boundaries():
    result = bisect(lambda x: x, 0., 0.)
    expected = 0.
    assert allclose(result, expected), \
                   'test equal interval bounds failed'

def test_reverse_boundaries():
    result = bisect(lambda x: x, 1., -1.)
    expected = 0.
    assert allclose(result, expected),\
                 'test reverse int_erval bounds failed'
 
test_equal_boundaries()
test_reverse_boundaries()<br/><br/><br/><br/></pre>
<p class="mce-root">A test checks that the program unit does what is demanded by its specification. In the preceding example, we assumed that the specifications state that in the case <img class="fm-editor-equation" src="assets/093d5afe-63f2-4229-ab93-0aa2be3c9dae.png" style="width:3.58em;height:1.33em;"/> the two values should tacitly be interchanged. And that is what was tested. An alternative way would be to specify that this situation would be considered as wrong input, which the user has to correct. There, we would have tested for an appropriate exception, for example, <kbd>ValueError</kbd>.</p>
<h2 id="uuid-77069172-2a6b-4d86-bf88-a1e2c6999c5c">15.2.2 Using the unittest module</h2>
<p>The Python module <kbd>unittest</kbd> greatly facilitates automated testing. This module requires that we rewrite our previous tests to be compatible. </p>
<p>The first test would have to be rewritten in a<span> </span><kbd>class</kbd>, as follows:</p>
<pre>from bisection import bisect
import unittest

class TestIdentity(unittest.TestCase):
    def test(self):
        result = bisect(lambda x: x, -1.2, 1.,tol=1.e-8)
        expected = 0.
        self.assertAlmostEqual(result, expected)

if __name__=='__main__':
    unittest.main()</pre>
<p>Let's examine the differences from the previous implementation. First, the test is now a method and a part of a class. The class must inherit from<span> </span><kbd>unittest.TestCase</kbd>. The test method's name must start with<span> </span><kbd>test</kbd>. Note that we may now use one of the assertion tools of the<span> </span><kbd>unittest</kbd><span> </span>package, namely<span> </span><kbd>assertAlmostEqual</kbd>. Finally, the tests are run using<span> </span><kbd>unittest.main</kbd>. We recommend writing the tests in a file separate from the code to be tested. That is why it starts with an<span> </span><kbd>import</kbd>. The test passes and returns as follows: </p>
<pre>Ran 1 test in 0.002s

OK</pre>
<p>If we run it with a loose tolerance parameter, for example,<span> </span><kbd>1.e-3</kbd>, a failure of the test will be reported:</p>
<pre>F
======================================================================
FAIL: test (__main__.TestIdentity)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "&lt;ipython-input-11-e44778304d6f&gt;", line 5, in test
    self.assertAlmostEqual(result, expected)
AssertionError: 0.00017089843750002018 != 0.0 within 7 places
----------------------------------------------------------------------
Ran 1 test in 0.004s
FAILED (failures=1)</pre>
<p>Tests can and should be grouped together as methods of a test class, as given in the following example:</p>
<pre>import unittest
from bisection import bisect

class TestIdentity(unittest.TestCase):
    def identity_fcn(self,x):
        return x
    def test_functionality(self):
        result = bisect(self.identity_fcn, -1.2, 1.,tol=1.e-8)
        expected = 0.
        self.assertAlmostEqual(result, expected)
    def test_reverse_boundaries(self):
        result = bisect(self.identity_fcn, 1., -1.)
        expected = 0.
        self.assertAlmostEqual(result, expected)
    def test_exceeded_tolerance(self):
        tol=1.e-80
        self.assertRaises(Exception, bisect, self.identity_fcn,
                                               -1.2, 1.,tol)
if __name__=='__main__':
    unittest.main()</pre>
<p>Here, in the last test we used the method<span> </span><kbd>unittest.TestCase.assertRaises</kbd>. It tests whether an exception is correctly raised. Its first parameter is the exception type, for example,<span> </span><kbd>ValueError</kbd>,<span> </span><kbd>Exception</kbd>, and its second argument is the name of the function, which is expected to raise the exception. The remaining arguments are the arguments for this function.</p>
<p>The command<span> </span><kbd>unittest.main()</kbd><span> </span>creates an instance of the class <kbd>TestIdentity</kbd> and executes those methods starting with <kbd>test</kbd>.</p>
<h2 id="uuid-31b92172-12c4-4675-bc4b-a9e3e9acea01">15.2.3 Test setUp and tearDown methods</h2>
<p>The class<span> </span><kbd>unittest.TestCase</kbd><span> </span>provides two special methods,<span> </span><kbd>setUp</kbd><span> </span>and<span> </span><kbd>tearDown</kbd>, which run before and after every call to a test method. This is needed when testing generators, which are exhausted after every test. We demonstrate this by testing a program that checks the line in a file in which a given string occurs for the first time:</p>
<pre>class StringNotFoundException(Exception):
    pass

def find_string(file, string):
    for i,lines in enumerate(file.readlines()):
        if string in lines:
            return i
    raise StringNotFoundException(<br/>          f'String {string} not found in File {file.name}.')</pre>
<p>We assume that this code is saved in a file named <kbd>find_in_file.py</kbd>.</p>
<p>A test has to prepare a file and open it and remove it after the test as given in the following example:</p>
<pre>import unittest
import os # used for, for example, deleting files

from find_in_file import find_string, StringNotFoundException

class TestFindInFile(unittest.TestCase):
    def setUp(self):
        file = open('test_file.txt', 'w')
        file.write('bird')
        file.close()
        self.file = open('test_file.txt', 'r')
    def tearDown(self):
        self.file.close()
        os.remove(self.file.name)
    def test_exists(self):
        line_no=find_string(self.file, 'bird')
        self.assertEqual(line_no, 0)
    def test_not_exists(self):
        self.assertRaises(StringNotFoundException, find_string,
                                              self.file, 'tiger')

if __name__=='__main__':
    unittest.main()</pre>
<p>Before each test<span> </span><kbd>setUp</kbd><span> </span>is run and after each test <kbd>tearDown</kbd><span> </span>is executed.</p>
<h3 id="uuid-45607aaa-e67c-409c-91f1-546a3ac38414">Setting up testdata when a test case is created</h3>
<p>The <span>methods</span> <kbd>setUp</kbd> and <kbd>tearDown</kbd> are executed before and after any test method of a test case. This is necessary when the test methods change the data. They guarantee that the test data is restored before the next test is executed.</p>
<p>However, there is also often a situation where your tests do not change the test data and you want to save time by only once setting up the data. This is done by the class method <kbd>setUpClass</kbd>.</p>
<p>The following code block schematically illustrates how the method <kbd>setUpClass</kbd> is used. You might also want to check <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.4</a>: <em>Class attributes and class methods</em> again.</p>
<p> </p>
<pre class="mce-root">import unittest<br/><br/>class TestExample(unittest.Testcase):<br/>     @classmethod<br/>     def setUpClass(cls):<br/>         cls.A=....<br/>     def Test1(self):<br/>         A=self.A<br/>         # assert something<br/>         ....<br/>     def Test2(self):<br/>         A=self.A<br/>         # assert something else</pre>
<h2 id="uuid-68417153-e8fb-4e1a-8d29-f82d54d82357">15.2.4 Parameterizing tests</h2>
<p>We frequently want to repeat the same test<span> </span>with different datasets. When using the functionalities of<span> </span><kbd>unittest</kbd>, this requires us to automatically generate test cases with the corresponding methods injected<span><span>.</span></span></p>
<p>To this end, we first construct a test case with one or several methods that will be used, when we later set up test methods. We'll consider the bisection method again and let's check if the values it returns are really zeros of the given function.</p>
<p>We first build the test case and the method that we will use for the tests as follows:</p>
<pre>class Tests(unittest.TestCase):
    def checkifzero(self,fcn_with_zero,interval):
        result = bisect(fcn_with_zero,*interval,tol=1.e-8)
        function_value=fcn_with_zero(result)
        expected=0.
        self.assertAlmostEqual(function_value, expected)</pre>
<p>Then we dynamically create test functions as attributes of this class:</p>
<pre>test_data=[
           {'name':'identity', 'function':lambda x: x,
                                     'interval' : [-1.2, 1.]},
           {'name':'parabola', 'function':lambda x: x**2-1,
                                        'interval' :[0, 10.]},
           {'name':'cubic', 'function':lambda x: x**3-2*x**2,
                                       'interval':[0.1, 5.]},
               ] 
def make_test_function(dic):
    return lambda self :\
        self.checkifzero(dic['function'],dic['interval'])
for data in test_data:
    setattr(Tests, f"test_{data['name']}", make_test_function(data))<br/><br/>if __name__=='__main__': <br/>    unittest.main()</pre>
<p>In this example, the data is provided as a list of dictionaries. The function <kbd>make_test_function</kbd> dynamically generates a test function, which uses a particular data dictionary to perform the test with the previously defined method<span> </span><kbd>checkifzero</kbd>. Finally, the command<span> </span><kbd>setattr</kbd><span> </span>is used to make these test functions methods of the class<span> </span><kbd>Tests</kbd>.</p>
<h2 id="uuid-393fcbd4-7ebc-4475-b7f4-0bf55cb743f5">15.2.5 Assertion tools</h2>
<p>In this section, we collect the most important tools for raising an<span> </span><kbd>AssertionError</kbd>. We saw the command<span> </span><kbd>assert</kbd><span> </span>and three tools from<span> </span><kbd>unittest</kbd>, namely<span> </span><kbd>assertAlmostEqual</kbd>, <kbd>assertEqual</kbd>, and <kbd>assertRaises</kbd>. The following table (Table 15.1) summarizes the most important assertion tools and the related modules:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Assertion tool and application example</strong></p>
</td>
<td>
<p><strong>Module</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assert 5==5</kbd></p>
</td>
<td>
<p>–</p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertEqual(5.27, 5.27)</kbd></p>
</td>
<td>
<p><kbd>unittest.TestCase</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertAlmostEqual(5.24, 5.2,places = 1)</kbd></p>
</td>
<td>
<p> <kbd>unittest.TestCase</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertTrue(5 &gt; 2)</kbd></p>
</td>
<td>
<p><kbd>unittest.TestCase</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertFalse(2 &lt; 5)</kbd></p>
</td>
<td>
<p><kbd>unittest.TestCase</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertRaises(ZeroDivisionError,lambda x: 1/x,0.)</kbd></p>
</td>
<td>
<p><kbd>unittest.TestCase</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assertIn(3,{3,4})</kbd></p>
</td>
<td>
<p><kbd>unittest.TestCase</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assert_array_equal(A,B)</kbd></p>
</td>
<td>
<p><kbd>numpy.testing</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assert_array_almost_equal(A, B, decimal=5)</kbd></p>
</td>
<td>
<p><kbd>numpy.testing</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>assert_allclose(A, B, rtol=1.e-3,atol=1.e-5)</kbd></p>
</td>
<td>
<p><kbd>numpy.testing</kbd></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 15.1: Assertion tools in Python, unittest, and NumPy</div>
<h2 id="uuid-f4247556-6919-4b2b-878c-c2c342ff60d5">15.2.6 Float comparisons</h2>
<p>Two floating-point numbers should not be compared with the<span> </span><kbd>==</kbd><span> </span>comparison, because the result of a computation is often slightly off due to rounding errors. There are numerous tools to test the equality of floats for testing purposes.</p>
<p>First,<span> </span><kbd>allclose</kbd><span> </span>checks that two arrays are almost equal. It can be used in a test function, as shown:</p>
<pre>self.assertTrue(allclose(computed, expected))</pre>
<p>Here,<span> </span><kbd>self</kbd><span> </span>refers to a<span> </span><kbd>unittest.Testcase</kbd><span> </span>instance. There are also testing tools in the<span> </span><kbd>numpy</kbd><span> </span>package<span> </span><kbd>testing</kbd>. These are imported by using:</p>
<pre>import numpy.testing</pre>
<p>Testing that two scalars or two arrays are equal is done using <kbd>numpy.testing.assert_array_allmost_equal</kbd> or <kbd>numpy.testing.assert_allclose</kbd>. These methods differ in the way they describe the required accuracy, as shown in the preceding table, <em>Table 15.1.</em></p>
<p><img class="fm-editor-equation" src="assets/561e22e7-9410-4f8e-98c0-5f5472a83c2e.png" style="width:1.17em;height:0.83em;"/> factorization decomposes a given matrix into a product of an orthogonal matrix <span><img class="fm-editor-equation" src="assets/3ec22240-f164-4c4c-91e2-08c4baac3ee3.png" style="width:0.67em;height:0.92em;"/></span><span> </span>and an upper triangular matrix <span><img class="fm-editor-equation" src="assets/79db8e65-2824-4d59-8a3a-731f50166e27.png" style="width:0.83em;height:1.00em;"/></span><span> </span>as given in the following example:</p>
<pre>import scipy.linalg as sl
A=rand(10,10)
[Q,R]=sl.qr(A)</pre>
<p>Is the method applied correctly? We can check this by verifying that <span><img class="fm-editor-equation" src="assets/daa3b63f-d531-4c68-af13-88bd2340ad86.png" style="width:0.83em;height:1.08em;"/></span><span> </span>is indeed an orthogonal matrix:</p>
<pre>import numpy.testing as npt 
npt.assert_allclose(
               Q.T @ self.Q,identity(Q.shape[0]),atol=1.e-12)</pre>
<p>Furthermore, we might perform a sanity test by checking if <span><img class="fm-editor-equation" src="assets/93b48b98-bfcb-48d8-863c-e9a6af4c7585.png" style="width:4.00em;height:1.17em;"/></span>:</p>
<pre>import numpy.testing as npt
npt.assert_allclose(Q @ R,A))</pre>
<p>All this can be collected into the test case<span> </span><kbd>unittest</kbd><span> </span>as follows:</p>
<pre>import unittest
import numpy.testing as npt
from scipy.linalg import qr
from scipy import *

class TestQR(unittest.TestCase):
    def setUp(self):
        self.A=rand(10,10)
        [self.Q,self.R]=qr(self.A)
    def test_orthogonal(self):
        npt.assert_allclose(
            self.Q.T @ self.Q,identity(self.Q.shape[0]),
            atol=1.e-12)
    def test_sanity(self):
            npt.assert_allclose(self.Q @ self.R,self.A)

if __name__=='__main__':
    unittest.main()</pre>
<p>Note in<span> </span><kbd>assert_allclose</kbd><span> </span>the parameter<span> </span><kbd>atol</kbd><span> </span>defaults to zero, which often causes problems when working with matrices having small elements.</p>
<h2 id="uuid-13e181c9-b255-41e2-913b-e52df9aea1cc">15.2.7 Unit and functional tests</h2>
<p>Up to now, we have only used functional tests. A functional test checks whether the functionality is correct. For the bisection algorithm, this algorithm actually finds a zero when there is one. In that simple example, it is not really clear what a unit test is. Although it might seem slightly contrived, it is still possible to make a unit test for the bisection algorithm. It will demonstrate how unit testing often leads to more compartmentalized implementation.</p>
<p>So, in the bisection method, we would like to check, for instance, that at each step the interval is chosen correctly. How to do that? Note that it is absolutely impossible with the current implementation because the algorithm is hidden inside the function. One possible remedy is to run only one step of the bisection algorithm. Since all the steps are similar, we might argue that we have tested all the possible steps. We also need to be able to inspect the current bounds<span> </span><kbd>a</kbd><span> </span>and<span> </span><kbd>b</kbd><span> </span>at the current step of the algorithm. So we have to add the number of steps to be run as a parameter and change the return interface of the function. We will do that as shown:</p>
<pre>def bisect(f,a,b,n=100):
  ...
  for iteration in range(n):
    ...
  return a,b</pre>
<p>Note that we have to change the existing unit tests in order to accommodate that change. We may now add a unit test as shown:</p>
<pre>def test_midpoint(self):
  a,b = bisect(identity,-2.,1.,1)
  self.assertAlmostEqual(a,-0.5)
  self.assertAlmostEqual(b,1.)</pre>
<h2 id="uuid-565b2480-92c6-4880-8aed-7fa04fde7f10">15.2.8 Debugging</h2>
<p>Debugging is sometimes necessary while testing, in particular, if it is not immediately clear why a given test does not pass. In that case, it is useful to be able to debug a given test in an interactive session. This is, however, made difficult by the design of the <span>class</span><span> </span><kbd>unittest.TestCase</kbd>, which prevents easy instantiation of test case objects. The solution is to create a special instance for debugging purposes only.</p>
<p>Suppose that, in the previous example of the class<span> </span><kbd>TestIdentity</kbd>, we want to test the method<span> </span><kbd>test_functionality</kbd>. This would be achieved as follows:</p>
<pre>test_case = TestIdentity(methodName='test_functionality')</pre>
<p>Now this test can be run individually with:</p>
<pre>test_case.debug()</pre>
<p>This will run this individual test and it allows for debugging.</p>
<h2 id="uuid-7617e7a9-0f72-4fe1-8eca-06bee3550d43">15.2.9 Test discovery</h2>
<p>If you write a Python package, various tests might be spread out through the package. The module <kbd>discover </kbd>finds, imports, and runs these test cases. The basic call from the command line is:</p>
<pre>python -m unittest discover</pre>
<p>It starts looking for test cases in the current directory and recurses the directory tree downward to find Python objects with the<span> </span><kbd>'test'</kbd><span> </span>string contained in its name. The command takes optional arguments. Most important are<span> </span><kbd>-s</kbd><span> </span>to modify the start directory and<span> </span><kbd>-p</kbd><span> </span>to define the pattern to recognize the tests:</p>
<pre>python -m unittest discover -s '.' -p 'Test*.py'</pre>
<h1 id="uuid-8c367b14-5d09-4ff7-ab6a-562df7ceaf63">15.3 Measuring execution time</h1>
<p>In order to take decisions on<span> </span>code<span> </span>optimization, you often have to compare several code alternatives and decide which code should be preferred based on the execution time. Furthermore, discussing execution time is an issue when comparing different algorithms. In this section, we present a simple and easy way to measure execution time.</p>
<h2 id="uuid-34273f67-9c48-4d0a-bec3-a036364d3fbf">15.3.1 Timing with a magic function</h2>
<p>The easiest way to measure the execution time of a single statement is to use IPython’s magic function<span> </span><kbd>%timeit</kbd>.</p>
<p class="mce-root">The shell IPython adds additional functionality to standard Python. These extra functions are called magic functions.</p>
<p>As the execution time of a single statement can be extremely short, the statement is placed in a loop and executed several times. By taking the minimum measured time, you make sure that other tasks running on the computer do not influence the measured result too much.</p>
<p>Let's consider four alternative ways to extract nonzero elements from an array as follows:</p>
<pre>A=zeros((1000,1000))
A[53,67]=10

def find_elements_1(A):
    b = []
    n, m = A.shape
    for i in range(n):
        for j in range(m):
            if abs(A[i, j]) &gt; 1.e-10:
                b.append(A[i, j])
    return b

def find_elements_2(A):
    return [a for a in A.reshape((-1, )) if abs(a) &gt; 1.e-10]

def find_elements_3(A):
    return [a for a in A.flatten() if abs(a) &gt; 1.e-10]
 
def find_elements_4(A):
    return A[where(0.0 != A)]</pre>
<p>Measuring time with IPython’s magic function<span> </span><kbd>%timeit</kbd><span> </span>gives the following result:</p>
<pre>In [50]: %timeit -n 50 -r 3 find_elements_1(A)
50 loops, best of 3: 585 ms per loop

In [51]: %timeit -n 50 -r 3 find_elements_2(A)
50 loops, best of 3: 514 ms per loop

In [52]: %timeit -n 50 -r 3 find_elements_3(A)
50 loops, best of 3: 519 ms per loop

In [53]: %timeit -n 50 -r 3 find_elements_4(A)
50 loops, best of 3: 7.29 ms per loop</pre>
<p>The parameter<span> </span><kbd>-n</kbd><span> </span>controls how often the statement is executed before time is measured and the<span> </span><kbd>-r</kbd><span> </span>parameter controls the number of repetitions.</p>
<h2 id="uuid-1eca1be3-8878-4825-823d-7789566039b4">15.3.2 Timing with the Python module timeit</h2>
<p>Python provides the module <kbd>timeit</kbd>, which can be used to measure execution time. It requires that, first, a time object is constructed. It is constructed from two strings: a string with setup commands and a string with the commands to be executed.</p>
<p>We take the same four alternatives as in the preceding example. The array and function definitions are written now in a string called<span> </span><kbd>setup_statements</kbd><span> </span>and four timing objects are constructed as follows:</p>
<pre>import timeit
setup_statements="""
from scipy import zeros
from numpy import where
A=zeros((1000,1000))
A[57,63]=10.

def find_elements_1(A):
    b = []
    n, m = A.shape
    for i in range(n):
        for j in range(m):
            if abs(A[i, j]) &gt; 1.e-10:
               b.append(A[i, j])
    return b

def find_elements_2(A):
    return [a for a in A.reshape((-1,)) if abs(a) &gt; 1.e-10]

def find_elements_3(A):
    return [a for a in A.flatten() if abs(a) &gt; 1.e-10]

def find_elements_4(A):
    return A[where( 0.0 != A)]
"""
experiment_1 = timeit.Timer(stmt = 'find_elements_1(A)',
                            setup = setup_statements)
experiment_2 = timeit.Timer(stmt = 'find_elements_2(A)',
                            setup = setup_statements)
experiment_3 = timeit.Timer(stmt = 'find_elements_3(A)',
                            setup = setup_statements)
experiment_4 = timeit.Timer(stmt = 'find_elements_4(A)',
                            setup = setup_statements)</pre>
<p>The timer objects have a method <kbd>repeat</kbd>. It takes the two parameters <kbd>repeat</kbd><span> </span>and<span> </span><kbd>number</kbd>. It executes the statement of the timer object in a loop, measures the time, and repeats this experiment corresponding to the <span>parameter</span><span> </span><kbd>repeat</kbd>.</p>
<p>We continue the preceding example and measure execution times as shown:</p>
<pre>t1 = experiment_1.repeat(3,5) 
t2 = experiment_2.repeat(3,5) 
t3 = experiment_3.repeat(3,5) 
t4 = experiment_4.repeat(3,5) 
# Results per loop in ms
min(t1)*1000/5 # 615 ms
min(t2)*1000/5 # 543 ms
min(t3)*1000/5 # 546 ms
min(t4)*1000/5 # 7.26 ms</pre>
<p>In contrast to the method in the example using <kbd>timeit</kbd>, we obtain lists of all the obtained measurements. As the computing time may vary depending on the overall load of the computer, the minimal value in such a list can be considered a good approximation to the computation time necessary to execute the statement.</p>
<h2 id="uuid-d2aa799c-044e-476b-97d3-f7cb1139c58d">15.3.3 Timing with a context manager</h2>
<p>Finally, we present the third method. It serves to show another application of a context manager. We first construct a context manager object for measuring the elapsed time as shown:</p>
<pre>import time
class Timer:
    def __enter__(self):
        self.start = time.time()
        # return self
    def __exit__(self, ty, val, tb):
        end = time.time()
        self.elapsed=end-self.start
        print(f'Time elapsed {self.elapsed} seconds') <br/>        return False</pre>
<p>Recall that the<span> </span><kbd>__enter__</kbd><span> </span>and<span> </span><kbd>__exit__</kbd><span> </span>methods make this class a context manager. The<span> </span><kbd>__exit__</kbd><span> </span>method's parameters<span> </span><kbd>ty</kbd>,<span> </span><kbd>val</kbd>, and<span> </span><kbd>tb</kbd><span> </span>are in the normal case<span> </span><kbd>None</kbd>. If an exception is raised during execution, they take the exception type, its value, and traceback information. The<span> </span>return value <kbd>False</kbd><span> </span>indicates that the exception has not been caught so far.</p>
<p>We'll now show the use of the context manager to measure the execution time of the four alternatives in the previous example:</p>
<pre>with Timer(): find_elements_1(A)</pre>
<p>This will then display a message like<span> </span><kbd>Time elapsed 15.0129795074 ms</kbd>.</p>
<p>If the timing result should be accessible in a variable, the<span> </span><kbd>enter</kbd> method must return the<span> </span><kbd>Timer</kbd><span> </span>instance (uncomment the<span> </span><kbd>return</kbd><span> </span>statement) and a<span> </span><kbd>with ... as ...</kbd><span> </span>construction has to be used:</p>
<pre>with Timer() as t1:
    find_elements_1(A)
t1.elapsed # contains the result</pre>
<h1 id="uuid-66278163-7b5c-4a8d-bf78-9af88a024060">15.4 Summary</h1>
<p>No program development without testing! We showed the importance of well-organized and documented tests. Some professionals even start development by first specifying tests. A useful tool for automatic testing is the module<span> </span><kbd>unittest</kbd>, which we explained in detail. While testing improves the reliability of code, profiling is needed to improve the performance. Alternative ways to code may result in large performance differences. We showed how to measure computation time and how to localize bottlenecks in your code.</p>
<h1 id="uuid-75edec93-4583-43d3-8898-c32a4e019a6b">15.5 Exercises</h1>
<p><strong>Ex. 1:</strong> Two matrices <img class="fm-editor-equation" src="assets/2d8e6f34-43b2-4e70-82aa-0403dfc9d4e9.png" style="width:1.83em;height:1.00em;"/> are called similar if there exists a matrix <img class="fm-editor-equation" src="assets/2a9104de-2907-4372-acd8-224c1bc3e52c.png" style="width:0.67em;height:0.92em;"/>, such that <img class="fm-editor-equation" src="assets/9eb00513-26a8-4b51-bc70-69e23ce0e356.png" style="width:5.17em;height:1.08em;"/>. The matrices <span><img class="fm-editor-equation" src="assets/bda68266-6133-47e1-af9f-7ceb31af3bb3.png" style="width:0.92em;height:1.00em;"/></span> and<span> </span><em><img class="fm-editor-equation" src="assets/b1ee0969-d1f6-4ca0-b59e-952e73467c51.png" style="width:0.75em;height:0.83em;"/></em> have the same eigenvalues. Write a test checking that two matrices are similar, by comparing their eigenvalues. Is it a functional or a unit test?</p>
<p><strong>Ex. 2:</strong> Create two vectors of large dimensions. Compare the execution time of various ways to compute their<span> </span>dot<span> </span>product:</p>
<ul>
<li>SciPy function: <kbd>v @ w<br/></kbd></li>
<li>Generator and sum:<span> </span><kbd>sum((x*y for x,y in zip(v,w)))</kbd></li>
<li>Comprehensive list and sum:<span> </span><kbd>sum([x*y for x,y in zip(v,w)])</kbd></li>
</ul>
<p><strong>Ex. 3:</strong> Let <span><img class="fm-editor-equation" src="assets/3526771a-a59b-41d5-83c6-f33e83a0e3cb.png" style="width:0.92em;height:1.00em;"/></span> be a vector. The vector<span> </span><img class="fm-editor-equation" src="assets/bc63c3f4-50dc-4b1c-be52-85d26cfad5bb.png" style="width:0.83em;height:1.08em;"/> with components</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/084b74cc-dc2c-42bf-a28c-da33c7175588.png" style="width:11.67em;height:2.58em;"/></p>
<p> is called a moving average of <img class="fm-editor-equation" src="assets/8ac291cf-4704-4bef-8bc3-988982c3b547.png" style="width:1.00em;height:1.08em;"/>. Determine which of the two alternatives to compute<span> </span><img class="fm-editor-equation" src="assets/76df3e80-0678-45d1-9303-c3644ca27e70.png" style="width:0.83em;height:1.08em;"/> is faster:</p>
<pre>v = (u[:-2] + u[1:-1] + u[2:]) / 3</pre>
<p>or</p>
<pre>v = array([(u[i] + u[i + 1] + u[i + 2]) / 3
  for i in range(len(u)-3)])</pre>


            </article>

            
        </section>
    </body></html>