- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Secure Login and Signup Process for Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s continue our exploration of advanced techniques to make our web applications
    look professional and work well.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to implement a login and signup page
    made with **Secure Hash Algorithm 256** (**SHA-256**) encryption and connected
    to a database in a secure and user-friendly way. By adopting this approach, we
    will be able to authenticate our web app users and store their credentials permanently.
    The login and signup page typically consists of a form where users can enter their
    username and password to access the web application. When a user logs in, their
    credentials are hashed using SHA-256 and compared to the stored hash in the database
    (in this context, we are using **SQLite3**). If the hashes match, the user is
    authenticated and granted access to the application. The signup page allows new
    users to create an account by entering their desired username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the logic behind the login and signup page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is SHA-256 and why should we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a relational database and interacting with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving or saving credentials from and to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll use the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pillow
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sqlite3`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/main/Chapter13](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/main/Chapter13).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the logic behind the login and signup page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user creates an account on a website or application, they are typically
    asked to provide a username and password. The username is a unique identifier
    for the user, while the password is a secret that only the user should know.
  prefs: []
  type: TYPE_NORMAL
- en: The website or application then stores the username and password in a database.
    However, the password is not stored in plain text. Instead, it’s converted into
    a **hash**. A hash is a one-way function, meaning that it is easy to calculate
    the hash of a password, but it is very difficult to reverse the process and calculate
    the password from the hash.
  prefs: []
  type: TYPE_NORMAL
- en: This is done for security reasons. If a hacker were to gain access to the database,
    they would not be able to read the passwords in plain text. They would only be
    able to read the hashes. Even if the hacker knew the hashing algorithm used, it
    would still be very difficult for them to crack the password.
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs in, they are asked to enter their username and password. The
    website or application then calculates the hash of the password that the user
    entered and compares it to the hash that is stored in the database. If the two
    hashes match, then the user is successfully logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a step-by-step explanation of the logic behind the login and signup
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: The user enters their username and password on the signup page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website or application converts the password into a hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website or application saves the username and password hash in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user enters their username and password on the login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The website or application calculates the hash of the password that the user
    entered and compares it to the hash that is stored in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the two hashes match, then the user is successfully logged in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the two hashes do not match, then the user is not successfully logged in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a few reasons it is important to store the username and password
    hashes permanently in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow users to log into their accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow users to recover their passwords if they forget them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To prevent unauthorized access to user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the username and password hashes were not stored permanently in a database,
    then users would not be able to log into their accounts or recover their passwords
    if they forgot them. Additionally, unauthorized users would be able to gain access
    to user accounts simply by guessing the correct username and password.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that even though passwords are stored as hashes in the
    database, it is still possible for hackers to crack them. However, it is much
    more difficult to crack a hash than it is to crack a plain text password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips for creating strong passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a mix of uppercase and lowercase letters, numbers, and symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your password at least 12 characters long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using common words or phrases in your password such as `qwerty`, `12345678`,
    `user`, `admin`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use your name, birthday, or other personal information in your password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a different password for each website or application that you use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the importance of a signup/login page should be clear, as well
    as the importance of avoiding weak passwords. It’s time to understand what a secure
    hash algorithm is.
  prefs: []
  type: TYPE_NORMAL
- en: What is SHA-256 and why should we use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SHA-256 is a cryptographic hash function that produces a 256-bit hash value
    from a data input. It is part of the *SHA-2 family of hash functions* (for more
    details, please check out [https://justcryptography.com/sha-2/](https://justcryptography.com/sha-2/))
    that were designed by the **National Security Agency** (**NSA**) and published
    by the **National Institute of Standards and Technology** (**NIST**) in 2001.
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA-256 is a widely used hash function for a variety of applications, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password storage**: SHA-256 is used to store passwords securely. When a user
    creates an account on a website or application, their password is converted into
    an SHA-256 hash and stored in the database. When the user logs in, their password
    is converted into an SHA-256 hash and compared to the hash stored in the database.
    If the two hashes match, then the user is successfully logged in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digital signatures**: SHA-256 can be used to create digital signatures. A
    **digital signature** is a cryptographic technique that allows the sender of a
    message to verify their identity and the integrity of the message. To create a
    digital signature, the sender calculates the SHA-256 hash of the message and then
    encrypts the hash with their private key. The sender then sends the message and
    the encrypted hash to the recipient. The recipient calculates the SHA-256 hash
    of the message and then decrypts the encrypted hash with the sender’s public key.
    If the two hashes match, then the recipient can be sure that the message is authentic
    and has not been tampered with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File integrity verification**: SHA-256 can be used to verify the integrity
    of files. To do this, the SHA-256 hash of the file is calculated and then stored.
    When the file is needed, the SHA-256 hash of the file is calculated again and
    compared to the stored hash. If the two hashes match, then the file is known to
    be intact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SHA-256 is considered to be a very secure hash function. It is resistant to
    collision attacks, meaning that it is very difficult to find two different inputs
    that produce the same hash value. It is also resistant to preimage attacks, meaning
    that it is very difficult to find the input that produces a given hash value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some reasons why you should use SHA-256:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a very secure hash function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is widely used and supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is relatively easy to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is free to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a secure way to store passwords, create digital signatures, or verify
    the integrity of files, then SHA-256 is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the information we need, let’s start coding. As usual,
    we have to follow some typical steps to set up a new virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `Login_Skeleton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter this directory and write `pipenv shell` to create a new virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `streamlit` and `pillow` packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty Python file named `app.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch your IDE (Sublime Text).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 13**.1* shows all these steps, from creating the new directory to installing
    the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Virtual environment and app.py file preparation](img/B21147_12_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Virtual environment and app.py file preparation'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to edit the Python code in the `app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Sublime Text, we can start writing the code for our new login/signup
    web app, as shown in *Figure 13**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: Starting code](img/B21147_12_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: Starting code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code should be quite familiar. Here’s a breakdown of what we
    did:'
  prefs: []
  type: TYPE_NORMAL
- en: At the very beginning, on *lines 1* and *2*, we import the necessary libraries
    – in this case, `streamlit` and `Pillow`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After that, on *line 5*, we create a `main()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main()` function, we write some HTML code in the `html_temp` variable
    (*line 8*) to set a big title in the web app that specifies the background color,
    the padding, and the text color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we visualize the HTML code using the `st.markdown` instruction (*line
    14*)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create a list on *line 16* that contains the voices of the menu we
    want to visualize and add a selectbox in the sidebar on the left-hand side of
    the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we check the selection (*line 19*) and if it is `Home`, we do something:
    at the moment, we just write some text in the `subheader` format. Meanwhile, if
    the selection is `Login` *(line 25*), we pass (we will develop the code for this
    in the *Creating the Login menu* subsection); the same goes for `Signup` (*line
    28*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add an `About` section (*line 32*), where we are free to write anything
    we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that in the `st.image` instruction. This image, named `login.png`,
    must be present in the same directory as the `app.py` file, as shown in the `Folder`
    section of the editor in *Figure 13**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, when we execute the following command, the web application will be
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result in the browser is quite simple and clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: The login/signup web app in the browser](img/B21147_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: The login/signup web app in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: On the left, we have the sidebar with the menu, while in the middle, there is
    the **Home** section with a beautiful picture.
  prefs: []
  type: TYPE_NORMAL
- en: The skeleton is ready. Now, it’s time to connect our web app to a database so
    that we can save all username/password data and use it at the proper time.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a relational database and interacting with it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explained in the *Understanding the logic behind the login and signup page*
    section, we want to save the accounts in a database. So, we have to import the
    database libraries. As mentioned previously, we are using a **SQLite3** database.
    So, first of all, let’s install its Python library by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, simply import the library by writing `import sqlite3` in our `app.py`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Making a SQLite3 database work for us is a quite simple task. For this, we need
    to open a *connection* to the database by specifying its name (in our case, `userdata.db`)
    as an argument and creating a *cursor* to execute operations in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On *lines 6* and *7* in *Figure 13**.4*, the connection and cursor are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: The connection to the database and its cursor](img/B21147_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: The connection to the database and its cursor'
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, the *connection* (`conn`) opens a connection to the database while
    the *cursor* (`c`) makes it possible to operate inside the database. Essentially,
    we need three different operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Table creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data insertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data retrieval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to implement these operations is to create a specific function
    dedicated to each of these operations, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: The database functions](img/B21147_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: The database functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at these three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is named `create_table`. Simply put, this function creates a table
    named `userstable`, but only if this table is not already present in the database.
    The `userstable` table has two columns named `username` and `password`, each of
    which contains text. It’s important to understand that the `CREATE TABLE` instruction
    is given to the database using the cursor we created in *Figure 13**.4*. So, the
    cursor, leveraging the opened connection, makes it possible to *deliver* operations
    (or functions) to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second function is named `add_data` because it oversees data insertion
    or values inside the `userstable` table we created with the `create_table` function.
    So, we pass two values to the `add_data` function – a username and a password
    – as an argument and it inserts these two values in the `userstable` table in
    the following order: the username value in the `username` column and the password
    value in the `password` column. Once again, the cursor oversees carrying out the
    instruction. `conn.commit()` is extremely important because, without this *commit*,
    the new username and values won’t be stored in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third function is named `login_user` and, similar to the `add_data` function,
    has two arguments: `username` and `password`. It takes these two values and looks
    for them inside the `userstable` table, then retrieves (`fetchall`) all the results
    and puts them in a variable named `data`. This `data` variable is returned as
    the final output of the function. In this way, it is possible to check when a
    username and a password are present in the database. Once again, the cursor oversees
    carrying out the commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these three functions ready, we can move on to the `app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Login menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need a couple of text inputs, one for the username and one for the
    password, after which we can put them in the sidebar. So, let’s add two new lines,
    as shown on *lines 46* and *47* in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Text input for username and password](img/B21147_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Text input for username and password'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon specifying `type=''password''` on *line 47*, the password we type will
    be hidden; by clicking on the *eye* icon, we can see the password clearly in the
    browser, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: The password is hidden](img/B21147_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: The password is hidden'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the logic behind the login should be quite clear: we insert
    a username and a password and look for them in the database to understand whether
    a specific user is allowed to log into our app or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, let’s have a look at the code that performs this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: The “Login” section’s code](img/B21147_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: The “Login” section’s code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of what the code in *Figure* *13**.8* does:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 49*, we added a checkbox; when it is selected, a new subheading is
    printed in the `main` section of the web app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, on *line 51*, the `create_table` function, which we described previously,
    is executed. In this way, a new table named `userstable` will be created in the
    database, but only if it doesn’t exist already.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 53*, the `login_user` function is executed, with the username and password
    that were inputted using the two `text_inputs` widgets on *lines 46* and *47*
    as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the result of the data fetching is positive, we print the **Logged in...**
    message with *success* and show a selectbox with a couple of tasks (just some
    placeholders); otherwise, we print a *warning* stating the **Incorrect** **Username/Password**
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try to log in now, you’ll get the **Incorrect Username/Password** message
    since no data is present in the database.
  prefs: []
  type: TYPE_NORMAL
- en: To populate the database, we must implement the `SignUp` function. Let’s see
    how.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Sign Up menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic is the same as that for the `Login` function but we must make a couple
    of changes, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: The “SignUp” section code](img/B21147_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: The “SignUp” section code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: On *lines 66* and *67*, we have two `text_input` widgets to collect the username
    and the password, but this time, we are putting them in the `main` section of
    the web app and not in the sidebar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, on *line 68*, we add a button with a label of `Sign Up`. When this
    button is pushed, we execute the `create_table` function (we must ensure that
    the `userstable` table exists; otherwise, we will get a runtime error).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 71*, we execute the `add_data` function. We’ve already explained this
    function (see *Figure 13**.5*), so we know that by passing the username and password
    that have been inputted by the `text_input` widgets to it, we create a new record
    in the database. This new record will contain the new username and password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on *line 73*, we print a beautiful *success* message to confirm the
    creation of the account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see the web application in action.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the menu, select `user1`, and a password, such as `12345` (please remember
    that during real usage, you should use a stronger password):'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.10: \uFEFFUsing Sign Up to create a new account](img/B21147_13_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: Using Sign Up to create a new account'
  prefs: []
  type: TYPE_NORMAL
- en: Then, click on the **Sign Up** button; you’ll get a **You have successfully
    created an** **Account** message.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have inserted our first account into our database. This means
    we can try to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Login** from the menu, type the username (**user1**) and password
    (**12345**), and enter the web application. We’ll get a **Logged in as: user1**
    message and the list of tasks (I repeat, these are just placeholders):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: Using “Login” to enter the web application](img/B21147_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Using “Login” to enter the web application'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to log in with an incorrect username or password, we get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: Logging in with the wrong username/password](img/B21147_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Logging in with the wrong username/password'
  prefs: []
  type: TYPE_NORMAL
- en: We typed `user100`, but this username is not present in the database, so it
    is not possible to log in. We cannot enter the web application and for this reason,
    we cannot see the list of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The web application is working very well. Next, we’ll add a nice graphical user
    interface to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a graphical user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the command line, please install **DB Browser for SQLite**, a very nice
    graphical interface for managing SQLite databases. Type the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation has finished, please launch the application; a graphical
    user interface, as shown in the following figure, should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: DB Browser for SQLite](img/B21147_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: DB Browser for SQLite'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we are ready to open the database we created in our web app:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **File** | **Open Database**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the `Login_Skeleton` directory, there is a file named `userdata.db`.
    Select it and open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14: Opening the userdata.db database](img/B21147_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Opening the userdata.db database'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see your database’s structure, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15: The database’s structure](img/B21147_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: The database’s structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the database has a table named `userstable`, and this table has
    two text columns: `username` and `password`.'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Browse` `Data` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the following figure, the `userstable` table contains the account
    we created previously – the one where the username is equal to **user1** and the
    password is equal to **12345**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.16: The account saved in our table](img/B21147_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: The account saved in our table'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one big problem related to security here: the password is in *plain
    text*. Anybody that can access the `userdata.db` file in our database can read
    it. This is the reason why we must introduce hashing encryption in our code –
    to make it almost impossible for anybody to discover our passwords in such an
    easy way. We’ll see how in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving or saving credentials from and to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a theoretical point of view, we have already discussed what a hash is and
    why we should use one. From a practical point of view, there are many Python packages
    available (for example, `sha256` and `pycrypto`), but one of the easiest to use
    that’s also very effective is `hashlib`. This library is installed in Python by
    default, so we don’t have to install it in our virtual environment; all we have
    to do is import it into our `app.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: While leveraging `hashlib`, all we need to do is use its `sha256` method to
    create the hash encryption of the password. Once again, let me highlight that
    *SHA-256* is a very strong form of encryption from a security perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the new lines of code we need for the hashing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17: The make_hashes function](img/B21147_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: The make_hashes function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 5*, we imported `hashlib`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On *lines 12* and *13*, we created a new function named `make_hashes`. This
    function has just one input argument: the password. This password is passed to
    the `sha256` method, which creates a hashing from it. This hashing is converted
    into hexadecimal and returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we know, there is no way to decode a hashing. This means that once we convert
    the password into a hash, we cannot convert it back again. So, to complete the
    authentication/login of a user, we must type the password into `text_input`, convert
    it into its hashing, and compare the result with the hashing stored in the database.
    If the two hash codes are the same, this means that the inputted password is correct;
    otherwise, it is different from the saved one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this procedure requires us to make a few modifications to our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must convert the inputted password into a hashing. This can be done
    using the `make_hashes` function we just discussed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to compare this hashing with the one saved in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first code change affects the **Login** section, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18: The hashing of the inputted password](img/B21147_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: The hashing of the inputted password'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we are doing in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 60*, we make a hash of the inputted password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 61*, leveraging the `check_hashes` `function`, we compare the hashed
    password with the one (with the hashing) saved in the database. If they are the
    same, then the login process is successful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s write the `check_hashes` function; the code is very short, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19: The “check_hashes” function](img/B21147_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: The “check_hashes” function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we are doing in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On *line 15*, we define the new function, which has only two arguments: a password
    (clear text) and the hashed text (the hashing of the password saved in the database).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 16*, we can see that if the hashing of the password (which we get using
    the `make_hashes` function) is the same as the one stored in the database, we
    return the hashed text (the hashed version of the password); otherwise, we return
    `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, moving back to *line 61* of the code shown in *Figure 13**.18*, when `check_hashes`
    returns the hashed password, the `result` variable is `True` and the code enters
    the `success` part of the `if` cycle. Otherwise, when `check_hashes` returns `False`,
    the `result` variable is `False` as well, and the code enters in the `else` part
    of the `if` cycle, denying the login.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we try to log into the web application using the account we saved previously
    (**user1**, **12345**), we’ll fail and get a warning. The reason is that in our
    database, we saved the password without introducing the hashing, so the password
    is stored in clear text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete all the login/signup web application coding, we must change the
    **SignUp** section a little bit, making sure that the passwords of the accounts
    are saved in their own hashing version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20: The final “SignUp” section](img/B21147_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: The final “SignUp” section'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we are doing in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 84*, we create the hashing of the inputted password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 85*, we save it in the database, together with its related username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, we’ve finished coding. We can try out the entire set of features
    of the web application, starting with creating a new account with a username of
    `user2` and a password of `09876`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21: Creating a new account](img/B21147_13_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: Creating a new account'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, in the database browser, the new password has been saved as
    a hashing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22: The new password in its hashing version](img/B21147_13_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: The new password in its hashing version'
  prefs: []
  type: TYPE_NORMAL
- en: Anybody who gets the database file can read its content but cannot understand
    what the password is since getting the plain text from the hashing is quite impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23: Logging in with the new account](img/B21147_13_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: Logging in with the new account'
  prefs: []
  type: TYPE_NORMAL
- en: 'The inputted password is converted into its hash and compared with the one
    stored in the database; since the two hashes match, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24: The login was successful](img/B21147_13_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.24: The login was successful'
  prefs: []
  type: TYPE_NORMAL
- en: The login process has been completed with success, and the user can access the
    application’s tasks.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very interesting to understand that even if the given text differs in a
    very small element from another, its hashing will be completely different. Add
    another account to the database, this time with a password such as `09875`, and
    check how different its hashing is from the one coming from the `09876` password.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter was full of complex information, but the result we got is very
    valuable: a complete app skeleton that can be used in all our web applications
    that need to manage signing up, logging in, hashing, and saving data permanently
    in a database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, here is all the code we developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25: Signup/login skeleton – part 1](img/B21147_13_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.25: Signup/login skeleton – part 1'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of the code, we started importing the libraries (*lines 1-5*)
    and then created the connection and the cursor to the database (*lines 6-7*).
    After that, we imported the `hashlib` library (*line 10*) and created the `make_hashes`
    and `check_hashes` functions (*lines 12* and *15*). On *lines 22* and *26*, we
    defined two functions to create new tables and add data to the database, and on
    *line 31*, we defined the function that manages user login.
  prefs: []
  type: TYPE_NORMAL
- en: 'On *line 37*, we defined the `main` function, introduced some HTML code just
    to make the app more beautiful, and implemented the application menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26: Signup/login skeleton – part 2](img/B21147_13_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.26: Signup/login skeleton – part 2'
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the code, we managed the menu. So, if the user selects
    **Login**, we implement the proper code (*lines 57-74*). When the user selects
    **Sign Up**, we implement the code dedicated to this function (*lines 77-87*).
    Finally, on *line 90*, we have the **About** section.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is very important because an application almost always needs to
    manage accounts and therefore usernames and passwords. To accomplish this task
    properly, encrypting the password very securely is the key.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the logic behind login and signup pages and learned
    a very solid way of implementing and managing accounts according to the best practices
    summarized here.
  prefs: []
  type: TYPE_NORMAL
- en: When users sign up on our web apps, they provide a username and a password.
    The username serves as their unique identifier, while the password is a secret
    known only to them. For security, these credentials are stored in a database,
    but the passwords are not kept as plain text. Instead, they are converted into
    a hash, a one-way function that is easy to compute from a password but hard to
    reverse. This ensures that even if a hacker accesses the database, they can’t
    easily decipher the passwords.
  prefs: []
  type: TYPE_NORMAL
- en: During login, the user’s entered password is hashed and compared with the stored
    hash; if they match, the user is granted access. Storing these hashes is crucial
    for allowing users to log in and recover passwords. Although hacking these hashes
    is possible, it is much more difficult than cracking plain text passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing robust business code is the main target of any web application
    since by doing this, it is possible to address any kind of problem that the code
    is supposed to solve. Giving customers more beautiful interfaces, well-designed
    applications, and very customized tools is another key skill that a real web application
    designer should have. This is exactly what we are going to discuss in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
