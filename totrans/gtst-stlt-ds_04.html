<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-36"><em class="italic"><a id="_idTextAnchor036"/>Chapter 3</em>: Data Visualization</h1>
			<p>Visualization is fundamental to the modern data scientist. It is often the central lens used to understand items such as statistica<a id="_idTextAnchor037"/>l models (for example, via an AUC chart), the distribution of a crucial variable (via a histogram), or even important business metrics. </p>
			<p>In the last two chapters, we used the most popular<a id="_idIndexMarker074"/> Python graphing<a id="_idIndexMarker075"/> libraries (<strong class="bold">Matplotlib</strong> and <strong class="bold">Seaborn</strong>) in our examples. This chapter will focus on extending that ability to a broad range of Python graphing libraries, along with including some graphing functions native to Streamlit. </p>
			<p>By the end of this chapter, you should feel comfortable with using Streamlit's native graphing functions, and also using Streamlit's visualization functions to place graphs made from major Python visualization libraries in your own Streamlit app. </p>
			<p>In this chapter, we will cover the following topics: </p>
			<ul>
				<li>San Francisco Trees – A new dataset</li>
				<li>Streamlit's built-in graphing functions</li>
				<li>Streamlit's built-in visualization options</li>
				<li>Importing Python visualization libraries into Streamlit. In this section, we will cover the following libraries: <p>(a) <strong class="bold">Plotly</strong> (for interactive visualizations)</p><p>(b) <strong class="bold">Seaborn+Matplotlib</strong> (for classic statistical visualizations)</p><p>(c) <strong class="bold">Bokeh</strong> (for interactive visualization in web browsers)</p><p>(d) <strong class="bold">Altair</strong> (for declarative, interactive visualizations)</p><p>(e) <strong class="bold">PyDeck</strong> (for interactive map-based visualizations)</p></li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>For this chapter, we will be working with a new dataset that can be found at <a href="https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv">https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv</a>. A further explanation of the dataset can be found in the following section. </p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>San Francisco Trees – A new dataset</h1>
			<p>We're going to be working with all sorts of graphs in this chapter, so we're going to need a new dataset that has much more info, especially dates and locations. Enter <em class="italic">SF Trees</em>. The department of public works in San Francisco has a dataset (cleaned by the wonderful<a id="_idIndexMarker076"/> folks in the R community<a id="_idIndexMarker077"/> who run Tidy Tuesday, a weekly event where people publish interesting visualizations of new data each week) of every tree planted and maintained in the city of San Francisco. They cleverly call this dataset <em class="italic">EveryTreeSF – Urban Forest map</em>, and update this dataset every day. I have selected a random 10,000 trees with complete info and placed this data in the main GitHub repository under the <strong class="source-inline">trees</strong> folder (I'm not as clever as the data engineer in SF's DPW, I know). The GitHub repo can be found at <a href="https://github.com/tylerjrichards/streamlit_apps">https://github.com/tylerjrichards/streamlit_apps</a>. If you would like to<a id="_idIndexMarker078"/> download the full dataset, the link is here: <a href="https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq">https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq</a>. </p>
			<p>From the main <strong class="source-inline">streamlit_apps</strong> folder we've been using throughout this book, start by making a new folder, making a new Python file, and then downloading our data into the folder, the same thing as we did in <a href="B16864_02_Final_VK_ePub.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Uploading, Downloading, and Manipulating Data</em>, but just adding some new data! You can run the following code in your terminal to set this up:</p>
			<p class="source-code">mkdir trees_app</p>
			<p class="source-code">cd trees_app</p>
			<p class="source-code">touch trees.py</p>
			<p class="source-code">curl https://raw.githubusercontent.com/tylerjrichards/streamlit_apps/main/trees_app/trees.csv &gt; trees.csv</p>
			<p>I'll note here that if this does not work, or if you are on an operating system without these commands (such as Windows, for example), you can always go and download the CSV file directly by going<a id="_idIndexMarker079"/> to the GitHub repo mentioned in the preceding paragraph (<a href="https://github.com/tylerjrichards/streamlit_apps">https://github.com/tylerjrichards/streamlit_apps</a>).  </p>
			<p>Now that we have our setup, our next step is to open our <strong class="source-inline">trees.py</strong> file in our favorite editor and get<a id="_idIndexMarker080"/> to making our Streamlit app. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">We will follow these exact same steps at the beginning of the rest of the chapters, so in the future, we will not cover these explicitly.</p>
			<p>Let's start by titling our app and printing out some example rows using the following code: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> st.write(trees_df.head())</p>
			<p>We can then run the following command in our terminal and see the resulting Streamlit app in our browser:</p>
			<p class="source-code">streamlit run trees.py</p>
			<p>Note that this is neither the easiest nor the best way to see the first few rows of a dataset, but we can do this purely because we already know that we're going to build a Streamlit app using this data. The general workflow usually begins with some data exploration outside of Streamlit (in Jupyter notebooks, through SQL queries, or whatever the preferred workflow<a id="_idIndexMarker081"/> is for you as a data scientist or analyst). That said, let's continue looking at our dataset by looking at the output of the preceding code in the new Streamlit app in our browser:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B16864_03_01.jpg" alt="Figure 3.1 – The first few rows of trees&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The first few rows of trees</p>
			<p>This dataset contains<a id="_idIndexMarker082"/> a huge amount of info about the trees in SF, from their width (<strong class="source-inline">dbh</strong>) to the longitude and latitude points, the species, their address, and even the date they were planted. Before we get started with graphing, let's talk a bit about the visualization options in front of us. </p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Streamlit visualization use cases</h1>
			<p>Some Streamlit<a id="_idIndexMarker083"/> users are relatively experienced Python developers with well-tested workflows in visualization libraries of their choice. For these users, the best path forward is the one we've taken so far, which is to create our graphs in our library of choice (Seaborn, Matplotlib, Bokeh, and so on) and then use the appropriate Streamlit function to write this to the app. </p>
			<p>Other Streamlit users will have less experience in Pythonic graphing, and especially for these users, Streamlit offers a few built-in functions. We'll start with built-in libraries and move on to learning how to import the most popular and powerful libraries for our Streamlit apps. </p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor041"/>Streamlit's built-in graphing functions</h1>
			<p>There are three built-in functions for graphing – <strong class="source-inline">st.line_chart()</strong>, <strong class="source-inline">st.bar_chart()</strong>, and <strong class="source-inline">st.area_chart()</strong>. They all work similarly by trying to figure out what variables you're already trying to graph, and then put them into a line, bar, or area chart, respectively. In our dataset, we have a variable called <strong class="source-inline">dbh</strong>, which is the width<a id="_idIndexMarker084"/> of the tree at chest height. First, we can group our DataFrame by <strong class="source-inline">dbh</strong>, and then push that directly to the line chart, bar chart, and area chart. The following code should group our dataset by width, count the unique trees of each width, and then make a line, bar, and area chart of each:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> df_dbh_grouped = pd.DataFrame(trees_df.groupby(['dbh']).count()['tree_id'])</p>
			<p class="source-code"> df_dbh_grouped.columns = ['tree_count']</p>
			<p class="source-code"> st.line_chart(df_dbh_grouped)</p>
			<p class="source-code"> st.bar_chart(df_dbh_grouped)</p>
			<p class="source-code"> st.area_chart(df_dbh_grouped)</p>
			<p>The preceding code should show our three graphs right after one another, as is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B16864_03_02.jpg" alt="Figure 3.2 – Lines, bars, area, and tree height&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Lines, bars, area, and tree height</p>
			<p>We gave the function nothing except for the DataFrame, and it was able to guess correctly which<a id="_idIndexMarker085"/> items should be on the <em class="italic">x</em> and <em class="italic">y</em> axes and plot those to our Streamlit chart. Each of these charts is interactive by default! We can zoom in or out, roll out the mouse over points/bars/lines to see each data point, and even view fullscreen out of the box. These Streamlit functions are actually calling another popular graphing library<a id="_idIndexMarker086"/> called <strong class="bold">Altair</strong>, which we will learn how to use in more depth later in this chapter. </p>
			<p>Now that we see the basics of the built-in (it's clear that the term <em class="italic">built-in</em> is fairly loose here, as Streamlit is built to be a great and convenient web application library, not a great visualization library) functions, let's push these functions to see how they handle more data. First, we're going<a id="_idIndexMarker087"/> to make a new column of random numbers between -500 and 500 in our <strong class="source-inline">df_dbh_grouped</strong> DataFrame using the <strong class="source-inline">numpy</strong> library and use the same plotting code that we used before. The following code plots two line charts, one before we added the new column, and one after: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> df_dbh_grouped = pd.DataFrame(trees_df.groupby(['dbh']).count()['tree_id'])</p>
			<p class="source-code"> df_dbh_grouped.columns = ['tree_count']</p>
			<p class="source-code">st.line_chart(df_dbh_grouped)</p>
			<p class="source-code"> df_dbh_grouped['new_col'] = np.random.randn(len(df_dbh_grouped)) * 500</p>
			<p class="source-code">st.line_chart(df_dbh_grouped)</p>
			<p>This code should produce an app that looks like the following screenshot:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B16864_03_03.jpg" alt="Figure 3.3 – Two sequential line charts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Two sequential line charts</p>
			<p>Again, these functions put whatever is on the index as the <em class="italic">x</em> axis and use all the columns they can as variables on the <em class="italic">y</em> axis. These built-in functions are very useful if we have an incredibly straightforward graphing problem in front of us (as in the example). However, these visualization functions are, overall, less flexible in comparison to libraries with the sole purpose of visualization and it may be difficult to debug the behavior behind these functions. The recommendation<a id="_idIndexMarker088"/> here is that if you are working with data that is easy to massage into a format where the index of the DataFrame belongs on the <em class="italic">x</em> axis, and the rest of the columns are plotted on the <em class="italic">y</em> axis, these functions will work well. For more complicated tasks, we should use other graphing libraries. </p>
			<p>There is one more built-in Streamlit graphing function that we should discuss here, <strong class="source-inline">st.map()</strong>. Just like the preceding functions, this wraps around another Python graphing library, this time <strong class="bold">PyDeck</strong> instead<a id="_idIndexMarker089"/> of <strong class="bold">Altair</strong>, and<a id="_idIndexMarker090"/> finds columns that it thinks are longitude and latitude points by searching the DataFrame for columns with titles such as <strong class="bold">longitude</strong>, <strong class="bold">long</strong>, <strong class="bold">latitude</strong>, or <strong class="bold">lat</strong>. Then, it plots each row as its own point on a map, auto-zooms and focuses the map, and writes it to our Streamlit app. We should note that visualizing detailed maps is much more computationally intensive in comparison to the other<a id="_idIndexMarker091"/> forms of visualization that we have used so far, so we are going to sample 1,000 random rows from our DataFrame, remove null values, and try out <strong class="source-inline">st.map()</strong> using the following code: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">t.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> trees_df = trees_df.dropna(subset=['longitude', 'latitude'])</p>
			<p class="source-code"> trees_df = trees_df.sample(n = 1000)</p>
			<p class="source-code"> st.map(trees_df)</p>
			<p>This works perfectly well, right out of the box! We get a beautiful interactive map of the trees in San Francisco, as we can see in the following screenshot:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B16864_03_04.jpg" alt="Figure 3.4 – Default SF map of trees&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Default SF map of trees</p>
			<p>As with the other functions, we don't have many options for customization here other than an optional zoom parameter, but this works very well for a quick visualization. </p>
			<p>As we've seen, these built-in functions can be useful for making Streamlit apps quickly, but we trade off speed for customizability. In practice, I rarely use these functions when I produce Streamlit<a id="_idIndexMarker092"/> apps, but often use these when doing quick visualizations of data already in Streamlit. In production, more<a id="_idIndexMarker093"/> powerful<a id="_idIndexMarker094"/> libraries, such as <strong class="bold">Matplotlib</strong>, <strong class="bold">Seaborn</strong>, and <strong class="bold">PyDdeck</strong>, give us the flexibility and customizability we want. The rest of this chapter will walk through six different popular Python visualization libraries.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor042"/>Streamlit's built-in visualization options</h1>
			<p>For the rest<a id="_idIndexMarker095"/> of this chapter, we're going to run through the rest of<a id="_idIndexMarker096"/> the Streamlit<a id="_idIndexMarker097"/> visualization options, which are <strong class="bold">Plotly</strong>, <strong class="bold">Matplotlib</strong>, <strong class="bold">Seaborn</strong>, <strong class="bold">Bokeh</strong>, <strong class="bold">Altair</strong>, and <strong class="bold">PyDeck</strong>. </p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Plotly</h2>
			<p>Plotly<a id="_idIndexMarker098"/> is an interactive visualization library that<a id="_idIndexMarker099"/> many data scientists use for visualizing data in Jupyter, in the browser locally, or even hosting these graphs to be viewed on a platform for visualizations and dashboards created by the Plotly team<a id="_idIndexMarker100"/> called <strong class="bold">Dash</strong>. This library is very similar to Streamlit in its intent and is primarily used for internal or external dashboards (hence, the name Dash). </p>
			<p>Streamlit allows us to call <strong class="source-inline">plotly</strong> graphs from within Streamlit apps using the <strong class="source-inline">st.plotly_chart()</strong> function, which makes it a breeze to port any Plotly or Dash dashboards. We'll test this out by making a histogram of the height of the trees in SF, essentially the same graph that we've made before. The following code makes our Plotly histogram:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import plotly.express as px</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> st.subheader('Plotly Chart')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> </p>
			<p class="source-code">fig = px.histogram(trees_df['dbh'])</p>
			<p class="source-code"> st.plotly_chart(fig)</p>
			<p>As we'll notice, all the interactivity native to Plotly works by default in Streamlit. The user can scroll over the histogram bars and get the exact info about each one. There are a few other useful built-in features to Plotly<a id="_idIndexMarker101"/> that port over to Streamlit, such as the ability to zoom in and out, download the plot as a <strong class="source-inline">png</strong>, and select a group of data points/bars/lines. The full features can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B16864_03_05.jpg" alt="Figure 3.5 – First Plotly chart &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – First Plotly chart </p>
			<p>Now that we're comfortable with<a id="_idIndexMarker102"/> Plotly, we can move on to other popular visualization libraries, <strong class="bold">Matplotlib</strong> and <strong class="bold">Seaborn</strong>. </p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Matplotlib and Seaborn</h2>
			<p>Earlier in this book, we learned how to use the Matplotlib and Seaborn visualization libraries inside<a id="_idIndexMarker103"/> Streamlit, so we will<a id="_idIndexMarker104"/> just go over them briefly<a id="_idIndexMarker105"/> here. There is a column called <strong class="bold">date</strong> in the trees<a id="_idIndexMarker106"/> dataset that corresponds to the date that the tree was planted. We can use the datetime library to figure out the age of each tree in days, and plot that histogram using Seaborn and Matplotlib, respectively. The following code creates<a id="_idIndexMarker107"/> a new column called age, which is the difference in days between the tree<a id="_idIndexMarker108"/> planting date and today, and then graphs the histogram of the age<a id="_idIndexMarker109"/> using both<a id="_idIndexMarker110"/> Seaborn and Matplotlib:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">import seaborn as sns</p>
			<p class="source-code">import datetime as dt</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code">st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code">trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code">trees_df['age'] = (pd.to_datetime('today') -</p>
			<p class="source-code">                   pd.to_datetime(trees_df['date'])).dt.days</p>
			<p class="source-code">st.subheader('Seaborn Chart')</p>
			<p class="source-code">fig_sb, ax_sb = plt.subplots()</p>
			<p class="source-code">ax_sb = sns.histplot(trees_df['age'])</p>
			<p class="source-code">plt.xlabel('Age (Days)')</p>
			<p class="source-code">st.pyplot(fig_sb)</p>
			<p class="source-code">st.subheader('Matploblib Chart')</p>
			<p class="source-code">fig_mpl, ax_mpl = plt.subplots()</p>
			<p class="source-code">ax_mpl = plt.hist(trees_df['age'])</p>
			<p class="source-code">plt.xlabel('Age (Days)')</p>
			<p class="source-code">st.pyplot(fig_mpl)</p>
			<p>In the preceding code, we defined unique subplots for each graph, created a Seaborn or Matplotlib<a id="_idIndexMarker111"/> graph for each, and then used the <strong class="source-inline">st.pyplot()</strong> function to insert each graph in order onto our<a id="_idIndexMarker112"/> Streamlit app. The preceding code should show an app<a id="_idIndexMarker113"/> similar<a id="_idIndexMarker114"/> to the following screenshot (I say similar because, depending on when you run this, the age of the trees will be different as <strong class="source-inline">pd.to_datetime</strong> ('today') will return your current date:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B16864_03_06.jpg" alt="Figure 3.6 – Seaborn and Matplotlib histograms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Seaborn and Matplotlib histograms</p>
			<p>Whether you<a id="_idIndexMarker115"/> use Seaborn<a id="_idIndexMarker116"/> or Matplotlib, you'll use<a id="_idIndexMarker117"/> the <strong class="source-inline">st.pyplot()</strong> function<a id="_idIndexMarker118"/> in the same way. Now that we're more comfortable with these libraries, we should learn about another interactive visualization library – <strong class="bold">Bokeh</strong>. </p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Bokeh</h2>
			<p>Bokeh is another web-based interactive visualization library<a id="_idIndexMarker119"/> that also has dashboarding products built on top of it. It is a direct competitor to Plotly, but is more focused on the Python ecosystem, whereas Plotly is built on top of <strong class="source-inline">Plotly.js</strong>. Either way, Bokeh is an extremely popular Python visualization package that Python users may be very comfortable using. </p>
			<p>We can call Bokeh graphs using the same format as Plotly. First, we create the Bokeh graph, and then we use the <strong class="source-inline">st.bokeh_chart()</strong> function to write the app to Streamlit. In Bokeh, we have to first instantiate a Bokeh figure object, and then change aspects of that figure before we plot it out. The important lesson here is that if we change an aspect<a id="_idIndexMarker120"/> of the Bokeh figure object after we call the <strong class="source-inline">st.bokeh_chart()</strong> function, we will not change the graph shown on the Streamlit app. For example, when we run the following code, we will not see a new <em class="italic">x</em> axis title at all:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from bokeh.plotting import figure</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> st.subheader('Bokeh Chart')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> </p>
			<p class="source-code">scatterplot = figure(title = 'Bokeh Scatterplot')</p>
			<p class="source-code"> scatterplot.scatter(trees_df['dbh'], trees_df['site_order'])</p>
			<p class="source-code"> st.bokeh_chart(scatterplot)</p>
			<p class="source-code"> scatterplot.xaxis.axis_label = "dbh"</p>
			<p>Instead, we'll have<a id="_idIndexMarker121"/> to switch the order of the last two<a id="_idIndexMarker122"/> lines, which will now show up on our app. We'll add a <em class="italic">y</em> axis for good measure as well. </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from bokeh.plotting import figure</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> st.subheader('Bokeh Chart')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> </p>
			<p class="source-code">scatterplot = figure(title = 'Bokeh Scatterplot')</p>
			<p class="source-code"> scatterplot.scatter(trees_df['dbh'], trees_df['site_order'])</p>
			<p class="source-code"> scatterplot.yaxis.axis_label = "site_order"</p>
			<p class="source-code">scatterplot.xaxis.axis_label = "dbh"</p>
			<p class="source-code">st.bokeh_chart(scatterplot)</p>
			<p>The preceding code will create a Bokeh chart of <strong class="source-inline">dbh</strong> versus <strong class="source-inline">site_order</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B16864_03_07.jpg" alt="Figure 3.7 – Bokeh scatterplot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Bokeh scatterplot</p>
			<p>Now, onto<a id="_idIndexMarker123"/> our next<a id="_idIndexMarker124"/> visualization library – Altair!</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Altair</h2>
			<p>We've already used <strong class="bold">Altair</strong> in this chapter through Streamlit functions such as <strong class="source-inline">st.line_chart()</strong> or <strong class="source-inline">st.map()</strong>, but now we'll explore how to use Altair directly. Altair<a id="_idIndexMarker125"/> is a declarative<a id="_idIndexMarker126"/> visualization library, which loosely means that instead of explicitly writing out each feature in a graph (such as naming <em class="italic">x</em> axes), we pass the relationships between the columns as desired, and Altair takes care of the rest. </p>
			<p>We've made quite a few graphs with this dataset already, but why don't we explore a new column, the caretaker<a id="_idIndexMarker127"/> column? This bit of data defines who is in charge of the tree (public or private) and if public, what government organization is responsible for upkeep. Thrilling!</p>
			<p>The following<a id="_idIndexMarker128"/> code groups our DataFrame by caretaker, and then uses that grouped DataFrame within Altair:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import altair as alt</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> df_caretaker = trees_df.groupby(['caretaker']).count()['tree_id'].reset_index()</p>
			<p class="source-code">df_caretaker.columns = ['caretaker', 'tree_count']</p>
			<p class="source-code"> fig = alt.Chart(df_caretaker).mark_bar().encode(x = 'caretaker', y = 'tree_count')</p>
			<p class="source-code"> st.altair_chart(fig)</p>
			<p>Altair also allows us to summarize our data directly within the <strong class="source-inline">y</strong> value of <strong class="source-inline">mark_bar()</strong>, so we can simplify this by instead using the following code:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import altair as alt</p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> fig = alt.Chart(trees_df).mark_bar().encode(x = 'caretaker', y = 'count(*):Q')</p>
			<p class="source-code"> st.altair_chart(fig)</p>
			<p>The preceding code will create a Streamlit<a id="_idIndexMarker129"/> app showing<a id="_idIndexMarker130"/> the count of trees by caretaker in SF, shown in the following screenshot: </p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B16864_03_08.jpg" alt="Figure 3.8 – Altair bar chart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Altair bar chart</p>
			<p>This should be it for traditional visualization libraries, but Streamlit also allows us to use more complex visualization<a id="_idIndexMarker131"/> libraries such as <strong class="bold">PyDeck</strong> for geographic mapping. We have already used <strong class="bold">PyDeck</strong> through the native <strong class="source-inline">st.map()</strong> function and will explore this in more depth in the following section. </p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>PyDeck</h2>
			<p>PyDeck is a visualization library that plots visualizations as layers on top of <strong class="bold">Mapbox</strong> (a mapping company with a truly exceptional free tier) maps. Both Streamlit<a id="_idIndexMarker132"/> and PyDeck have<a id="_idIndexMarker133"/> a base set of limited features available without signing up for a Mapbox account, but greatly expand their free features when we get a <strong class="bold">Mapbox</strong> token, which we will do in this next section. </p>
			<h3>Configuration options</h3>
			<p>In order to set up your<a id="_idIndexMarker134"/> own <strong class="bold">Mapbox</strong> token, which is optional, first go to <a href="http://www.Mapbox.com">www.Mapbox.com</a> and sign up for an account. Once you have verified your account, you can find your token<a id="_idIndexMarker135"/> at <a href="https://www.Mapbox.com/install/">https://www.Mapbox.com/install/</a>. We will not pass our token directly to Streamlit<a id="_idIndexMarker136"/> because otherwise, we might accidentally push it to a public GitHub repository. Instead, Streamlit has a global configuration file called <strong class="source-inline">config.toml</strong>. To view our current settings, we can run the following command anywhere in the terminal: </p>
			<p class="source-code">streamlit config show</p>
			<p>There are four methods that Streamlit offers for changing our default configuration settings, I'll show you my recommended option and one of the other options, which should provide you with the majority of the use cases. If you find these options insufficient, the Streamlit<a id="_idIndexMarker137"/> documentation (<a href="https://docs.streamlit.io/">https://docs.streamlit.io/</a>) goes over all four options in great detail.</p>
			<p>The first option is to set global configuration options by directly editing the <strong class="source-inline">config.toml</strong> file. We can edit the file directly by opening it in our text editor. The following command will open the file in <strong class="source-inline">sublime</strong>. For other text editors (such as Vim and Atom), replace <strong class="source-inline">'sublime'</strong> with the appropriate command or open the file directly from the text editor:</p>
			<p class="source-code">sublime ~/.streamlit/config.toml</p>
			<p>If this fails, it likely means that we do not have the file generated already. We can either copy and paste the output of <strong class="bold">streamlit config show</strong> to a file at the location <strong class="source-inline">~/.streamlit/config.toml</strong>, or we can run the following shortcut for Mac/Linux:</p>
			<p class="source-code">streamlit config show &gt; ~/.streamlit/config.toml</p>
			<p>Now that we have the file opened in <strong class="source-inline">sublime</strong>, we can view and edit any of the options directly. This option is great<a id="_idIndexMarker138"/> for a config option such as a <strong class="bold">Mapbox</strong> token, as I will never have multiple <strong class="bold">Mapbox</strong> accounts with multiple tokens. However, some Streamlit apps may want to use, for example, different ports than the default <strong class="source-inline">8501 serverPort</strong>. It would not make sense to change a global option for a project-specific change, which leads us to the second option. </p>
			<p>The second option is to create and edit a project-specific <strong class="source-inline">config.toml</strong> file. Our previous config sets our default config options, while this option is specific per Streamlit app. Here is where our individual project<a id="_idIndexMarker139"/> folders within the <strong class="source-inline">streamlit_apps</strong> folder come in handy! </p>
			<p>Broadly speaking, we will do the following:</p>
			<ol>
				<li>Check our current working directory.</li>
				<li>Make a config file for our project.</li>
				<li>Use the config file within PyDeck.</li>
			</ol>
			<p>Our first step is to make sure our current working directory is the <strong class="source-inline">trees_app</strong> folder by running the <strong class="source-inline">pwd</strong> command in your terminal, which will show our current working directory and should end with <strong class="source-inline">trees_app</strong>' (for example, mine looks like <strong class="source-inline">Users/tyler/Documents/streamlit_apps/trees_app</strong>). </p>
			<p>Now, we need to make a config file just for our project. First, we will make a folder called <strong class="source-inline">.streamlit</strong>, and then we will repeat the Mac/Linux shortcut we used above:</p>
			<p class="source-code">mkdir .streamlit</p>
			<p class="source-code">streamlit config show &gt; .streamlit/config.toml </p>
			<p>We can then edit our config options just as we did before, but this will only be applicable to our Streamlit apps when we run Streamlit from that directory. </p>
			<p>Now, finally, we can go back to <strong class="bold">PyDeck</strong> graphing. Our first effort is going to be to get a base map of San Francisco, which has a city center of <strong class="source-inline">37.77, -122.4</strong>. We can do this using the following code, which first defines the initial state (where we want to start viewing the map), and then calls <strong class="source-inline">st.pydeck_chart()</strong> using that initial state:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import pydeck as pdk </p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code">st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code">trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code">sf_initial_view = pdk.ViewState(</p>
			<p class="source-code">     latitude=37.77,</p>
			<p class="source-code">     longitude=-122.4</p>
			<p class="source-code">     )</p>
			<p class="source-code">st.pydeck_chart(pdk.Deck(</p>
			<p class="source-code">     initial_view_state=sf_initial_view</p>
			<p class="source-code">     ))</p>
			<p>This code will produce a map of San Francisco, which we can use to layer on data points. We notice a couple of things here. First, that the black default map may be difficult to see, and second, that we need to spend<a id="_idIndexMarker140"/> time zooming in to San Francisco to get the view that we need. We can fix both these items by using the defaults suggested in the Streamlit<a id="_idIndexMarker141"/> documentation (<a href="https://docs.streamlit.io/">https://docs.streamlit.io/</a>), as seen in the following code:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import pydeck as pdk </p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> </p>
			<p class="source-code">sf_initial_view = pdk.ViewState(</p>
			<p class="source-code">     latitude=37.77,</p>
			<p class="source-code">     longitude=-122.4,</p>
			<p class="source-code">     zoom=9</p>
			<p class="source-code">     )</p>
			<p class="source-code"> </p>
			<p class="source-code">st.pydeck_chart(pdk.Deck(</p>
			<p class="source-code">     map_style='mapbox://styles/mapbox/light-v9',</p>
			<p class="source-code">     initial_view_state=sf_initial_view,</p>
			<p class="source-code">     ))</p>
			<p>The preceding code should<a id="_idIndexMarker142"/> create a map that looks like the following screenshot:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B16864_03_09.jpg" alt="Figure 3.9 – PyDeck mapping: SF base map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – PyDeck mapping: SF base map</p>
			<p>This is exactly what we want! We can see the entire <strong class="bold">SF Bay Area</strong>, and now we need to add our layer of trees. The <strong class="bold">PyDeck</strong> library has tooltips for interactivity, which do not deal well with null values in our dataset, so we will remove<a id="_idIndexMarker143"/> null values before we map these points in the following code. We'll also increase the zoom value to <strong class="source-inline">11</strong> so we can see each point better: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import pydeck as pdk </p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> trees_df.dropna(how='any', inplace=True)</p>
			<p class="source-code"> </p>
			<p class="source-code">sf_initial_view = pdk.ViewState(</p>
			<p class="source-code">     latitude=37.77,</p>
			<p class="source-code">     longitude=-122.4,</p>
			<p class="source-code">     zoom=11</p>
			<p class="source-code">     )</p>
			<p class="source-code"> </p>
			<p class="source-code">sp_layer = pdk.Layer(</p>
			<p class="source-code">     'ScatterplotLayer',</p>
			<p class="source-code">     data = trees_df,</p>
			<p class="source-code">     get_position = ['longitude', 'latitude'],</p>
			<p class="source-code">     get_radius=30) </p>
			<p class="source-code">st.pydeck_chart(pdk.Deck(</p>
			<p class="source-code">     map_style='mapbox://styles/mapbox/light-v9',</p>
			<p class="source-code">     initial_view_state=sf_initial_view,</p>
			<p class="source-code">     layers = [sp_layer]</p>
			<p class="source-code">     ))</p>
			<p>The best values for both the zoom and radius parameters are dependent on your visualization preferences. Try a few options<a id="_idIndexMarker144"/> out to see what looks the best. The preceding code will make the following map: </p>
			<p class="figure-caption"><img src="image/B16864_03_10.png" alt="Figure 3.10 – Mapping SF trees &#13;&#10;"/></p>
			<p class="figure-caption">Figure 3.10 – Mapping SF trees </p>
			<p>As with previous maps, this is interactive by default, so we can zoom into different parts of San Francisco to see where the places with the highest tree density are. For our next change to this map, we are going to add another layer, this time of hexagons, which will be colored based<a id="_idIndexMarker145"/> on the density of the trees in SF. We can use the same code as above, but change the scatterplot layer to a hexagon layer. We also will include the option to have the hexagon extrude vertically, which isn't necessary, but it is certainly a fun visualization style. </p>
			<p>Our last change is to change the pitch or the angle at which we are viewing the map. The default pitch, as we can see, is nearly directly down at the city, which will not work if we are trying to view vertical hexagons on our map. The following code implements each one of these changes: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import pydeck as pdk </p>
			<p class="source-code">st.title('SF Trees')</p>
			<p class="source-code"> st.write('This app analyses trees in San Francisco using'</p>
			<p class="source-code">         ' a dataset kindly provided by SF DPW')</p>
			<p class="source-code"> trees_df = pd.read_csv('trees.csv')</p>
			<p class="source-code"> trees_df.dropna(how='any', inplace=True)</p>
			<p class="source-code"> </p>
			<p class="source-code">sf_initial_view = pdk.ViewState(</p>
			<p class="source-code">     latitude=37.77,</p>
			<p class="source-code">     longitude=-122.4,</p>
			<p class="source-code">     zoom=11,</p>
			<p class="source-code">     pitch=30</p>
			<p class="source-code">     )</p>
			<p class="source-code"> </p>
			<p class="source-code">hx_layer = pdk.Layer(</p>
			<p class="source-code">     'HexagonLayer',</p>
			<p class="source-code">     data = trees_df,</p>
			<p class="source-code">     get_position = ['longitude', 'latitude'],</p>
			<p class="source-code">     radius=100,</p>
			<p class="source-code">     extruded=True)</p>
			<p class="source-code"> </p>
			<p class="source-code">st.pydeck_chart(pdk.Deck(</p>
			<p class="source-code">     map_style='mapbox://styles/mapbox/light-v9',</p>
			<p class="source-code">     initial_view_state=sf_initial_view,</p>
			<p class="source-code">     layers = [hx_layer]</p>
			<p class="source-code">     ))</p>
			<p>As with the previous map, the optimal radius and pitch parameters will change based on your visualizations. Try changing each<a id="_idIndexMarker146"/> one of these around a few times to see whether you can get the hang of it! The preceding code will produce the following app:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B16864_03_11.jpg" alt="Figure 3.11 – Final San Francisco Trees map&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Final San Francisco Trees map</p>
			<p>From this screenshot, we can see that <strong class="bold">PyDeck</strong> creates darker circles where there exists a higher density of trees in SF. We can observe from this many interesting details, such as the fact that the dataset seems to be missing trees from the famous Golden Gate Park on the west side of the city, and that the area around the Golden Gate Bridge also seems to have very few trees in the dataset.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor048"/>Summary</h1>
			<p>After this chapter, you hopefully have a solid understanding of how to leverage the incredible open source Python visualization libraries to make web apps in Streamlit. </p>
			<p>First, we learned how to use the default visualization options, such as <strong class="source-inline">st.line_chart()</strong> and <strong class="source-inline">st.map()</strong>, and then we dove into interactive libraries such as Plotly, mapping libraries such as PyDeck, and everything in between.</p>
			<p>In our next chapter, we will cover how to use machine learning in Streamlit. </p>
		</div>
	</body></html>