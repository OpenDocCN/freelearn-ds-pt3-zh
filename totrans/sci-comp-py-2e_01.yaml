- en: Getting Started
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will give a brief overview of the principal syntactical
    elements of Python. Readers who have just started learning programming are guided
    through the book in this chapter. Every topic is presented here in a *how-to* way and
    will be explained later in the book in a deeper conceptual manner and will also
    be enriched with many applications and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Readers who are already familiar with another programming language will, in
    this chapter, encounter the Python way of doing classical language constructs.
    This offers them a quick start to Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: Both types of readers are encouraged to refer to this chapter as a brief guideline
    when zigzagging through the book. However, before we start, we have to make sure
    that everything is in place and that you have the correct version of Python installed
    together with the main modules for scientific computing and tools, such as a good
    editor and a shell, which helps in code development and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program and program flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic data types in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating statements with loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating code with functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding scripts and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the following section, even if you already have access to a computer with
    Python installed. You might want to adjust things to have a working environment
    that conforms to the presentation in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Installation and configuration instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the subject of the book, you should have all the relevant
    tools installed on your computer. We give you some advice and recommend tools
    that you might want to use. We only describe public domain and free tools.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1 Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are currently two major versions of Python; the *2.x* branch and the new *3.x* branch.
    There are language incompatibilities between these branches and you have to be
    aware of which one to use. This book is based on the *3.x* branch, considering
    the language is up to release *3.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this book, you need to install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpreter: Python *3.7* (or later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The modules for scientific computing: SciPy with NumPy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The module for the graphical representation of mathematical results: matplotlib'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shell: IPython'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Python-related editor: preferably, Spyder (see *Figure 1.1*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation of these is facilitated by the so-called distribution packages.
    We recommend that you use Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.2 Anaconda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if you have Python pre-installed on your computer, we recommend that you
    create your personal Python environment that allows you to work without the risk
    of accidentally affecting the software on which your computer's functionality
    might depend. With a virtual environment, such as Anaconda, you are free to change
    language versions and install packages without the unintended side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the worst happens and you mess things up totally, just delete the Anaconda
    directory and start again. Running the Anaconda installer will install Python,
    a Python development environment and editor (Spyder), the shell (IPython), and
    the most important packages for numerical computations: SciPy, NumPy, and matplotlib.'
  prefs: []
  type: TYPE_NORMAL
- en: You can install additional packages with `conda install` within your virtual
    environment created by Anaconda (see also the official documentation*)*.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.3 Spyder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default screen of Spyder consists of an editor window on the left, a console
    window in the lower-right corner, which gives access to an IPython shell, and
    a help window in the upper-right corner, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7839f66d-8ddc-4d40-b53f-501e4ec3ae9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The default screen of Spyder'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.4 Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Python codes will be collected in files. We recommend that you use the
    following header in all your Python files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this, you make sure that all fundamental data types and functions used
    in this book for scientific computing purposes are imported. Without this step,
    most of the examples in the book would raise errors.
  prefs: []
  type: TYPE_NORMAL
- en: Spyder gives syntax warnings and syntax error indicators. Warnings are marked
    by a yellow triangle; see *Figure 1.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax warnings indicate statements that are correct but that you are discouraged
    from using for some reason. The preceding statement, `from`, causes such a warning.
    We will discuss the reasons for this later in this book. In this particular case,
    we ignore the warning.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ced60f7-2aab-4532-9fc9-2081297db711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2: Warning triangles in Spyder
  prefs: []
  type: TYPE_NORMAL
- en: Many editors, such as Spyder, provide the possibility to create a template for
    your files. Look for this feature and put the preceding header into a template.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.5 Python shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python shell is good, but not optimal, for interactive scripting. We therefore
    recommend using IPython instead [[25]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'IPython can be started in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In a terminal shell by running the following command: `ipython`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By directly clicking on an icon called Jupyter QT Console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/343292ea-b649-47e6-be9d-f81ce58f893d.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When working with Spyder, you should use an IPython console (see *Figure 1.1*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.1.6 Executing scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You often want to execute the contents of a file. Depending on the location
    of the file on your computer, it is necessary to navigate to the correct location
    before executing the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the command `cd` in IPython in order to move to the directory where your
    file is located.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To execute the contents of a file named `myfile.py`, just run the following
    command in the IPython shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 1.1.7 Getting help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some tips on how to use IPython:'
  prefs: []
  type: TYPE_NORMAL
- en: To get help on an object, just type `?` after the object's name and then press
    the *Return* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the arrow keys to reuse the last executed commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may use the *Tab* key for completion (that is, you write the first letter
    of a variable or method and IPython shows you a menu with all the possible completions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *Ctrl+D* to quit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use IPython's magic functions. You can find a list and explanations by applying `%magic` on
    the command prompt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about IPython in its online documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.8 Jupyter – Python notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Jupyter notebook is a fantastic tool for demonstrating your work. Students
    might want to use it to make and document homework and exercises and teachers
    can prepare lectures with it, even slides and web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have installed Python via Anaconda, you already have everything for
    Jupyter in place. You can invoke the notebook by running the following command
    in the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A browser window will open and you can interact with Python through your web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Program and program flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A program is a sequence of statements that are executed in top-down order.
    This linear execution order has some important exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: There might be a conditional execution of alternative groups of statements (blocks),
    which we refer to as branching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are blocks that are executed repetitively, which is called looping (see
    *Figure 1.3*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are function calls that are references to another piece of code, which
    is executed before the main program flow is resumed. A function call breaks the
    linear execution and pauses the execution of a program unit while it passes the
    control to another unit – a function. When this gets completed, its control is
    returned to the calling unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1ed8f89f-6bda-4978-9130-fc7d3e866737.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Program flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses a special syntax to mark blocks of statements: a keyword, a colon,
    and an indented sequence of statements, which belong to the block (see *Figure
    1.4*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81e339fa-269a-48a1-bcc8-e21e98312600.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Block command'
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a line in a program contains the symbol `#`, everything following on the
    same line is considered as a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 1.2.2 Line joining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A backslash `\` at the end of the line marks the next line as a continuation
    line, that is, *explicit line joining*. If the line ends before all the parentheses
    are closed, the following line will automatically be recognized as a continuation
    line, that is, *implicit line joining.*
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Basic data types in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go over the basic data types that you will encounter in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number may be an integer, a real number, or a complex number. The usual operations
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Addition and subtraction, `+` and `-`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication and division, `*` and `/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power, `**`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The symbol `j` denotes the imaginary part of a complex number. It is a syntactic
    element and should not be confused with multiplication by a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.2 Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings are sequences of characters, enclosed by single or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use triple quotes for strings that have multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 1.3.3 Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variable is a reference to an object. An object may have several references.
    You use the assignment operator = to assign a value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of a variable can be displayed by the `print` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 1.3.4 Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists are a very useful construction and one of the basic types in Python.
    A Python list is an ordered list of objects enclosed by square brackets. You can
    access the elements of a list using zero-based indexes inside square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The indexing of the elements starts at zero. You can put objects of any type
    inside a list, even other lists. Some basic list functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list(range(n))}` creates a list with `n` elements, starting with zero:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`len` gives the length of a list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`append` is used to append an element to a list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Operations on lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The operator `+` concatenates two lists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, multiplying a list by an integer concatenates the list
    with itself several times:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n*L` is equivalent to making *n* additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 1.3.6 Boolean expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Boolean expression is an expression that has the value `True` or `False`.
    Some common operators that yield conditional expressions are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal: `==`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not equal: `!=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictly less, less  or equal: `<`, `<=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictly greater, greater or equal: `>`, `>=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You combine different Boolean values with `or` and `and`. The keyword `not` gives
    the logical negation of the expression that follows. Comparisons can be chained
    so that, for example, `x < y < z` is equivalent to `x < y and y < z`. The difference
    is that `y` is only evaluated once in the first example. In both cases, `z` is
    not evaluated at all when the first condition, `x < y`, evaluates to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The binary operators `<`, `>`, `<=`, `>=`, `!=`, and `==` have a higher precedence
    than the unary operator, `not`. The operators `and` and `or` have the lowest precedence.
    Operators with higher precedence rules are evaluated before those with lower precedence
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Repeating statements with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loops are used to repetitively execute a sequence of statements while changing
    a variable from iteration to iteration. This variable is called the index variable.
    It is successively assigned to the elements of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The part to be repeated in the `for` loop has to be properly indented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 1.4.1 Repeating a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One typical use of a `for` loop is to repeat a certain task a fixed number
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 1.4.2 break and else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` statement has two important keywords: `break` and `else`. The keyword
    `break` quits the `for` loop even if the list we are iterating is not exhausted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The finalizing `else` checks whether the `for` loop was broken with the `break` keyword.
    If it was not broken, the block following the `else` keyword is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 1.5 Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers how to use conditions for branching, breaking, or otherwise
    controlling your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A conditional statement delimits a block that will be executed if the condition
    is true. An optional block starting with the keyword `else` will be executed if
    the condition is not fulfilled (see* Figure 1.4*). We demonstrate this by printing,
    ![](img/a3b7b1bd-67b2-41b9-a204-e4289a6af25a.png), the absolute value of ![](img/17c7560e-295e-4113-a19b-3d1e2d4a9d3a.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71821b53-43f9-4d55-add5-947474c3b35e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python equivalent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Any object can be tested for the truth value, for use in an `if` or `while` statement.
    The rules for how the truth values are obtained are explained in Section 2.3.2, *Boolean
    casting**.*
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Encapsulating code with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are useful for gathering similar pieces of code in one place. Consider
    the following mathematical function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0da88fa6-7f50-4fe1-92b6-52e2c1377527.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python equivalent is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 1.5,* the elements of a function block are explained:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `def` tells Python we are defining a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` is the name of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is the argument or input of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is after `return` is called the output of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c649bf58-2c2f-4e89-a109-7a909878de5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Anatomy of a function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the function is defined, it can be called using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 1.7 Understanding scripts and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A collection of statements in a file (which usually has a `py` extension) is called a
    script. Suppose we put the contents of the following code into a file named `smartscript.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In a Python or IPython shell, such a script can then be executed with the `exec` command
    after opening and reading the file. Written as a one-liner, it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The IPython shell provides the magic command `%run` as a handy alternative
    way to execute a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 1.7.1 Simple modules – collecting functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, you collect functions in a script. This creates a module with additional
    Python functionality. To demonstrate this, we create a module by collecting functions
    in a single file, for example, `smartfunctions.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These functions can now be used by any external script or directly in the IPython
    environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions within the module can depend on each other._
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping functions with a common theme or purpose gives modules that can be
    shared and used by others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, the command `exec(open('smartfunctions.py').read())` makes these functions
    available to your IPython shell (note that there is also the IPython magic function, `run`).
    In Python terminology, you say that they are put into the actual namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.2 Using modules and namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, the modules can be imported by the command `import`. This creates a
    namespace named after the filename*.* The command `from` puts the functions into
    the general namespace without creating a separate namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Import the commands `import` and `from`. Import the functions only once into
    the respective namespace. Changing the functions after the import has no effect
    on the current Python session.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python interpreter executes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it checks the syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it executes the code line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code inside a function or class declaration is *not* executed, but its
    syntax is checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can run the preceding program because there are no syntactical errors. You
    get an error only when you call the function `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, we speak about a *runtime error*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly addressed the main language elements of Python without
    going into detail. You should now be able to start playing with small pieces of
    code and test different program constructs. All this is intended as an appetizer
    for the chapters to follows, where we will provide you with the details, examples,
    exercises, and more background information.
  prefs: []
  type: TYPE_NORMAL
