- en: Chapter 4. Handling Data with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce **pandas**, a powerful and versatile Python
    library that provides tools for data handling and analysis. We will consider the
    two main pandas structures for storing data, the `Series` and `DataFrame` objects,
    in detail. You will learn how to create these structures and how to access and
    insert data into them. We also cover the important topic of **slicing**, that
    is, how to access portions of data using the different indexing methods provided
    by pandas. Next, we'll discuss the computational and graphics tools offered by
    pandas, and finish the chapter by demonstrating how to work with a realistic dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '*pandas* is an extensive package for data-oriented manipulation, and it is
    beyond the scope of this book to realistically cover all aspects of the package.
    We will cover only some of the most useful data structures and functionalities.
    In particular, we will not cover the `Panel` data structure and multi-indexes.
    However, we will provide a solid foundation for readers who wish to expand their
    knowledge by consulting the official package documentation. Throughout this chapter,
    we assume the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Series class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Series` object represents a one-dimensional, indexed series of data. It
    can be thought of as a dictionary, with one main difference: the indexes in a
    `Series` class are ordered. The following example constructs a `Series` object
    and displays it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the format of the constructor call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Both `data` and `indexes` are usually lists or `NumPy` arrays, but can be any
    Python iterable. The lists must have the same length. The `name` variable is a
    string that describes the data in the series. The `type` variable is a `NumPy`
    data type. The `indexes` and the `name` variables are optional (if `indexes` are
    omitted, they are set to integers—starting at 0). The data type is also optional,
    in which case it is inferred from the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Series` object supports the standard dictionary interface. As an example,
    run the following code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command lines is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the order of the output is exactly the same as the order in which
    each of the elements were inserted in the series. Contrary to a standard Python
    dictionary, the `Series` object keeps track of the order of the elements. In fact,
    elements can be accessed through an integer index, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, all of Python''s list-access interface is supported. For instance,
    we can use slices, which return `Series` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The indexing capabilities are even more flexible; this is illustrated in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to append new data to the series, by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the series now contains two entries corresponding to the key, `Theo`.
    This makes sense, since in real-life data there could be more than one data value
    associated to the same index. In our example, a student might be able to hand
    in more than one version of the assignment. What happens when we try to access
    this data? pandas conveniently returns a `Series` object so that no data is lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the `append()` method does not append the values to the existing `Series`
    object. Instead, it creates a new object that consists of the original `Series`
    object with the appended elements. This behavior is not the same as what happens
    when elements are appended to a Python list. Quite a few methods of the `Series`
    class display behavior that is different from their corresponding list counterparts.
    A little experimentation (or reading the documentation) may be required to understand
    the conventions that pandas uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a new series with the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to compute each student''s average in the two assignments, we can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The value `NaN` stands for **Not a number**, which is a special floating-point
    value that is used to indicate the result of an invalid operation, such as zero
    divided by zero. In pandas, it is used to represent a missing data value. We can
    locate the missing values in `Series` using the `isnull()` method. For example,
    run the following code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command line produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decide that the missing data can be safely removed from the series, we
    can use the `dropna()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command line produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this is another case in which the original series is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Series` class provides a series of useful methods for its instances. For
    example, we can sort both the values and the indexes. To sort the values in-place,
    we use the `sort()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort the indexes of a series, use the `sort_index()` method. For example,
    consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the sorting is *not* in-place this time, a new series object is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next examples, we will use data on maximum daily temperatures for the
    month of June from a weather station nearby the author''s location. The following
    command lines generates the series of temperatures for the days from June 6 to
    June 15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first compute the mean and standard deviation of the temperatures using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding computation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want a quick overview of the data in the series, we can use the `describe()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that the information is returned as a `Series` object, so it can be stored
    in case it is needed in further computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a plot of the series, we use the `plot()` method. If we just need a
    quick graphical overview of the data, we can just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it''s also possible to produce nicely formatted, production-quality
    plots of the data, since all matplotlib features are supported in pandas. The
    following code illustrates how some of the graph formatting options discussed
    in [Chapter 3](ch03.html "Chapter 3. Graphics with matplotlib"), *Graphics with
    matplotlib*,are being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines produce the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Series class](img/8341OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose we want to find the days in which the maximum temperature was above
    75 degrees. This can be achieved with the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command returns the following series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There are many more useful methods provided by the `Series` class. Remember
    that in order to see all the available methods, we can use the code completion
    feature of IPython. Start typing `temps.` and you will get the available methods.
  prefs: []
  type: TYPE_NORMAL
- en: Then press the *Tab* key. A window with a list of all available methods will
    pop up. You can then explore what is available.
  prefs: []
  type: TYPE_NORMAL
- en: The DataFrame class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DataFrame` class is used to represent two-dimensional data. To illustrate
    its use, let''s create a `DataFrame` class containing student data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code demonstrates one of the most straightforward ways to construct a `DataFrame`
    class. In the preceding case, the data can be specified as any two-dimensional
    Python data structure, such as a list of lists (as shown in the example) or a
    `NumPy` array. The `index` option sets the row names, which are integers representing
    student IDs here. Likewise, the `columns` option sets the column names. Both the
    `index` and `column` arguments can be given as any one-dimensional Python structure,
    such as lists, `NumPy` arrays, or a `Series` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the output of the `DataFrame` class, run the following statement
    in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command displays a nicely formatted table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataFrame class](img/8341OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `DataFrame` class features an extremely flexible interface for initialization.
    We suggest that the reader run the following command to know more about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display information about the construction options. Our goal here
    is not to cover all possibilities, but to give an idea of the offered flexibility.
    Run the following code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataFrame class](img/8341OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This example illustrates a useful way of thinking of a `DataFrame` object:
    it consists of a dictionary of `Series` objects with a common `Index` object labeling
    the rows of the table. Each element in the dictionary corresponds to a column
    in the table. Keep in mind that this is simply a way to conceptualize a `DataFrame`
    object, and this is not a description of its internal storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our student data example. Let''s add a column with the total
    score of each student, which is the average of the grades, with the final having
    weight two. This can be computed with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataFrame class](img/8341OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding command line, we used one of the following recommended methods
    of accessing elements from a `DataFrame` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.loc`: This method is label-based, that is, the element positions are interpreted
    as labels (of columns or rows) in the table. This method was used in the preceding
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.iloc`: This method is integer-based. The arguments must be integers and are
    interpreted as zero-based indexes for the rows and columns of the table. For example,
    `grades.iloc[0,1]` refers to the data in row 0 and column 1, which is Alice''s
    grade in Test 1 in the preceding example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.ix`: This indexing method supports mixed integer and label-based access.
    For example, both `grades.ix[17035, 4]` and `grades.ix[17035, ''Score'']` refer
    to Bob''s score in the course. Notice that pandas is smart enough to know that
    the row labels are integers, so that the index `17035` refers to a label, not
    a position in the table. Indeed, attempting to access the `grades.ix[1, 4]` element
    will flag an error because there is no row with label 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use any of these methods, the corresponding entry (or entries) in the `DataFrame`
    object must already exist. So, these methods cannot be used to insert or append
    new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that Bob does not have a grade in his second test, indicated by the
    `NaN` entry (he was probably sick on the day of the test). When he takes a retest,
    his grade can be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you will notice that Bob''s final score is not automatically
    updated. This is no surprise because a `DataFrame` object is not designed to work
    as a spreadsheet program. To perform the update, you must explicitly execute the
    cell that computes the score again. After you do that, the table will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataFrame class](img/8341OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to use regular indexing to access `DataFrame` entries, but
    that is frowned upon. For example, to refer to Samaly's grade in the final, we
    could use the **chained** **reference**, that is, by using `grades['Test 2'][17028]`.
    (Notice the order of the indexes!) We will avoid this usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The teacher is a little disappointed, because no student got an A grade (score
    above 90). So, students are given an extra credit assignment. To add a column
    with the new grade component beside the `Final` column, we can run the following
    command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we can also insert rows. To add a new student we could use the following
    command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the scores have to be updated as follows to take the extra credit
    into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to find all students who got an A and had a score of less
    than 78 in Test 1\. We can do this by using a Boolean expression as index, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important things should be noted from the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use the `&` operator instead of the `and` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parentheses are necessary due to the high precedence of the `&` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will return a subtable with the rows that satisfy the condition expressed
    by the Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want the names and scores of the students who have a score of at
    least 80, but less than 90 (these could represent the "B" students). The following
    command lines will be useful to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: The expression `grades[(80 <= grades['Score']) & grades['Score'] < 90]` creates
    a `DataFrame` class that contains all student data for students who have a score
    of at least 80 but less than 90.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `.loc[:,'Name', 'Score']` takes a slice of this `DataFrame` class, which
    consists of all rows in the columns labeled `Name` and `Score`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important point about pandas data structures is that whenever data is referred
    to, the returned object may be either a copy or a view of the original data. Let''s
    create a `DataFrame` class with pseudorandom data to see some examples. To make
    things interesting, each column will contain normal data with a given mean and
    standard deviation. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines create the data we need for the examples. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the Python lists, `means` and `sdevs`, which contain the mean and standard
    deviation values of the distributions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create a dictionary named `random_data`, with string keys that correspond
    to the column labels of the `DataFame` class that will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each entry in the dictionary corresponds to a list of size `nrows` containing
    the data, which is generated by the function call to the `normal()` function of
    `NumPy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list named `row_labels`, which contains row labels of the `DataFrame`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use both the data, that is, the `random_data` dictionary and the `row_labels`
    list, in the `DataFrame` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding code will generate a table of 30 rows and 8 columns. You can see
    the table, as usual, by evaluating `dframe` by itself in a cell. Notice that even
    though the table is of a moderately large size, the IPython notebook does a good
    job of displaying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now select a slice of the `DataFrame` class. For the purpose of demonstration,
    we will use the mixed indexing `.ix` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the ranges are specified:'
  prefs: []
  type: TYPE_NORMAL
- en: The expression `'Row 3':'Row 11'` represents a range specified by labels. Notice
    that, contrary to the usual assumptions in Python, the range includes the last
    element (`Row 11`, in this case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression `5:` (the number 5 followed by a colon) represents a range numerically,
    from the fifth column to the end of the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, run the following command lines in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line resamples a single cell in the data table, and the other two
    rows print the result. Notice that the printed values are the same! This shows
    that no copying has taken place, and the variable `dframe_slice` refers to the
    same objects (memory area) that already existed in the `DataFrame` class referred
    to by the `dframe` variable. (This is the analogous to pointers in languages such
    as C, where more than one pointer can refer to the same memory. It is, actually,
    the standard way variables behave in Python: there is no default copying.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we really want a copy? All pandas objects have a `copy()` method, so
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines will produce the same output as the previous example.
    However, notice what happens if we modify `dframe_slice_copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now the printed values are different, confirming that only the copy was modified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In certain cases, it is important to know if the data is copied or simply referred
    to during a slicing operation. Care should be taken, specially, with more complex
    data structures. Full coverage of this topic is beyond the scope of this book.
    However, using `.loc`, `.iloc`, and `.ix` as shown in the preceding examples is
    sufficient to avoid trouble. For an example where *chained indexing* can cause
    errors, see [http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy](http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever encounter a warning referring to `SettingWithCopy`, check if you
    are trying to modify an entry of a `DataFrame` object using chained indexing,
    such as in `dframe_object['a_column']['a_row']`. Changing the object access to
    use `.loc` instead, for example, will eliminate the warning.
  prefs: []
  type: TYPE_NORMAL
- en: To finish this section, let's consider a few more examples of slicing a `DataFrame`
    as follows. In all of the following examples, there is no copying; only a new
    reference to the data is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing with lists as indexes is performed using the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Slicing to reorder columns is performed using the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding example reverses the column order. To have an arbitrary reordering,
    use a list with a permutation of the column positions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that there is no actual reordering of columns in the `dframe` object, since
    there is no copying of the data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Slicing with Boolean operations is performed using the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command line selects the elements in the column labeled `Mean=1,
    sd=1` (that are positive), and returns a `Series` object (since the data is one-dimensional).
    If you are having trouble understanding the way this works, run the following
    command line in a cell by itself:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This statement will return a `Series` object with Boolean values. The previous
    command line selects the rows of `dframe` corresponding to the positions that
    result as `True` in the `Series` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Slicing will, in general, return an object with a different shape than the original.
    The `where()` method can be used, as follows, in cases where the shape has to
    be preserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command line returns a `DataFrame` class that has missing values
    (`NaN`) in the entries that correspond to non-negative values of the original
    `dframe` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also indicate a value to be replaced by the values that do not satisfy
    the given condition using the following command line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command line will replace the entries corresponding to non-negative values
    by 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Computational and graphics tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The objects of pandas have a rich set of built-in computational tools. To illustrate
    some of this functionality, we will use the random data stored in the `dframe`
    object defined in the previous section. If you discarded that object, here is
    how to construct it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Let's explore some of this functionality of the built-in computational tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of the methods available for the object, start typing the following
    command in a cell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, press the *Tab* key. The completion popup allows us to select a method
    by double clicking on it. For example, double click on `mean`. The cell text changes
    to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a question mark to the preceding command line and run the cell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will display information about the `mean` method (which, not surprisingly,
    computes the mean of the data).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using tab-completion and IPython's help features is an excellent way to learn
    about pandas' features. I recommend that you always display the documentation
    this way, at least the first few times a method is used. Learning about the features
    that pandas offers can be a real time-saver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue with the functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to compute the column means for our random data. This
    can be done by evaluating the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The standard deviation values can be computed with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the results for all of the immediately preceding command lines are
    returned as `Series` objects, which is the default object type that pandas uses
    for one-dimensional data. In particular, the column labels become the indexes
    of the objects. Let's say we want to create a `DataFrame` object containing the
    mean and standard deviation in two rows. pandas makes this a very easy task, using
    built-in conversions and constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we first compute the means and standard deviations and assign
    them to variables for clarity. Then, we call the `DataFrame` constructor that
    accepts a list of Python dictionaries. This is made easy because pandas allows
    conversion from a `Series` object to a dictionary in a convenient way: `dict(mean_series)`
    returns the representation of `mean_series` as a dictionary, using the indexes
    of the `Series` object as keys to the dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to standardize the data in all columns so that they all
    have a common mean value 100 and standard deviation value 20\. This can be achieved
    using the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines simply implement the definition of standardization:
    we subtract the means from the data, divide by the standard deviation, scale by
    the desired value of the deviation, and add the desired mean. To check that we
    get the expected results, run the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the possibilities, let''s do a two-sided test of the hypothesis
    that the mean of each column is 0\. We first compute the **Z-scores** for the
    columns. The Z-score of each column is just the deviation from the column mean
    to the model mean (0 in this case), properly scaled by the standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The scaling factor, `sqrt(len(dframe))`, is the square root of the number of
    data points, which is given by the number of rows in the table. The last step
    is to compute the **p-values** for each column. The p-values are simply a measure
    of the probability that the data deviates from the mean by more than the corresponding
    Z-score, given the assumed distribution. These values are obtained from a normal
    distribution (technically, we should use a **t-distribution**, since we are using
    the sample standard deviation, but in this example this does not really make any
    difference, since the data is normally generated, and the sample size is large
    enough). The following command lines use the normal distribution object, `norm`,
    from SciPy to compute the p-values as percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The line that computes the p-values is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We use the `cdf()` method, which computes the cumulative distribution function
    for the normal curve from the `norm` object. We then multiply it with `2`, since
    this is a two-sided test, and multiply by `100` to get a percentage.
  prefs: []
  type: TYPE_NORMAL
- en: The next line converts the p-values into a `Series` object. This is not necessary,
    but makes the results easier to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the results obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that in the preceding example, you will get different numbers, since
    the data is randomly generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are what we expect, given the way the data was generated: the p-values
    are all very small, except for the columns that have mean `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s explore some of the graphical capabilities provided by pandas.
    The pandas plots are produced using matplotlib, so the basic interface has already
    been discussed in [Chapter 3](ch03.html "Chapter 3. Graphics with matplotlib"),
    *Graphics with matplotlib*. In the examples that follow, we will assume that we
    are using the magic. Run the following command in the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Most of the plotting capabilities of pandas are implemented as methods of `Series`
    or `DataFrame` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the following data in our table to include more data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To display a grid of histograms of the data, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `hist()` method to generate the histograms and use the `color` option
    as well, which is passed to the matplotlib function calls that actually do the
    drawing. The second line of code adds spaces to the plots so that the axis labels
    do not overlap. You may find that some of the histograms do not look normal. To
    fix their appearance, it is possible to fiddle with the `bins` and `range` options
    of the `hist()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This will draw a histogram of the data in the column for a mean of `0` and standard
    deviation of `2`, with `40` bins in the range from `-10` to `10`. In other words,
    each bin will have a width of `0.5`. Note that the plot may not include all the
    range from `-10` to `10`, since pandas restricts the drawing to ranges that actually
    contain data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s generate data according to **Geometrical Brownian Motion**
    (**GBM**), which is a model used in mathematical finance to represent the evolution
    of stock prices. (For details, see [http://en.wikipedia.org/wiki/Geometric_Brownian_motion](http://en.wikipedia.org/wiki/Geometric_Brownian_motion).)
    This model is defined in terms of two parameters, representing the **percentage
    drift** and **percentage volatility** of the stock. We start by defining these
    two values in our model, as well as the initial value of the stock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The simulation should run from time `0.0` to the maximum time `20.0`, and we
    want to generate 200 data points. The following command lines define these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The stock model would naturally be represented by a time series (a `Series`
    object). However, to make the simulation simpler, we will use a `DataFame` object
    and build the simulation column by column. We will start with a very simple table
    containing only integer indexes and the simulation times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the first few rows of the table, we can use the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You might want to run this command after each column is added in order to get
    a better idea of how the simulation progresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basis for the GBM model is (unsurprisingly) a stochastic process called
    **Brownian Motion** (**BM**). This process has two parts. A deterministic component,
    called **drift**, is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The next component adds randomness. It is defined in terms of increments, which
    are normally distributed with mean zero and standard deviation given by the time
    interval multiplied by the percentage volatility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The BM component is then defined as the cumulative sum of the increments, as
    shown in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command lines, we add the second line because we want the process
    to start at `0`, which is not the convention adopted by the `cumsum()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to compute the stock simulation. It is calculated by taking
    the drift component, adding to the BM component, taking the exponential of the
    result, and finally, multiplying it by the initial value of the stock. This is
    all done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to plot the result of the simulation using the following command
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command lines produce the following graph. Obviously, the graph
    you will get will be different due to randomness.
  prefs: []
  type: TYPE_NORMAL
- en: '![Computational and graphics tools](img/8341OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example with a realistic dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will work with a realistic dataset of moderate size. We
    will use the **World Development Indicators** dataset, which is provided free
    of charge by the World Bank. This is a reasonably sized dataset that is not too
    large or complex to experiment with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any real application, we will need to read data from some source, reformat
    it to our purposes, and save the reformatted data back to some storage system.
    pandas offers facilities for data retrieval and storage in multiple formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comma-separated** **values** (**CSV**) in text files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipboard data in text format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python-pickled data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of formats supported by pandas keeps growing with each new update to
    the library. Please refer to [http://pandas.pydata.org/pandas-docs/stable/io.html](http://pandas.pydata.org/pandas-docs/stable/io.html)
    for a current list.
  prefs: []
  type: TYPE_NORMAL
- en: Treating all formats supported by pandas is not possible in a book with the
    current scope. We will restrict examples to CSV files, which is a simple text
    format that is widely used. Most software packages and data sources have options
    to format data as CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Curiously enough, CSV is not a formally described storage format. pandas does
    a good job of providing enough options to read the great majority of files. However,
    the format of the data may vary depending on the data source. Luckily, since CSV
    files are simply text files, we can open the files in a spreadsheet program or
    even a text editor to examine their structure.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset for this section can be downloaded from [http://data.worldbank.org/data-catalog/world-development-indicators](http://data.worldbank.org/data-catalog/world-development-indicators),
    and is also available in the book website. If you choose to download the data
    from the original website, make sure you choose the CSV file format. The file
    is in compressed ZIP format, and is about 40 MB in size. Once the archive is decompressed,
    we get the following files.
  prefs: []
  type: TYPE_NORMAL
- en: '`WDI_Country.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WDI_CS_Notes.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WDI_Data.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WDI_Description.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WDI_Footnotes.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WDI_Series.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WDI_ST_Notes.csv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As is typical of any realistic dataset, there's always a lot of ancillary information
    associated with the data. This is called **metadata** and is used to give information
    about the dataset, including things such as the labels used for rows and/or columns,
    data collection details, and explanations concerning the meaning of the data.
    The metadata is contained in the various files contained within the archive. The
    reader is encouraged to open the different files using spreadsheet software (or
    a text editor) to get a feel for the kind of information available. For us, the
    most important metadata file is `WDI_Series.csv`, which contains information on
    the meaning of data labels for the several time series contained in the data.
  prefs: []
  type: TYPE_NORMAL
- en: The actual data is in the `WDI_Data.csv` file. As this file contains some of
    the metadata information, we will be able to do all the work using this file only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the `WDI_Data.csv` file is in the same directory that contains your
    IPython notebook files, and run the following command in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This will read the file and store it in a `DataFrame` object that we assign
    to the variable, `wdi`. The first row in the file is assumed to contain the column
    labels by default. We can see the beginning of the table by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `DataFrame` class is indexed by integers by default. It is possible
    to choose one of the columns in the data file as the index by passing the `index_col`
    parameter to the `read_csv()` method. The index column can be specified either
    by its position or by its label in the file. The many options available to `read_csv()`
    are discussed in detail at [http://pandas.pydata.org/pandas-docs/stable/io.html#io-read-csv-table](http://pandas.pydata.org/pandas-docs/stable/io.html#io-read-csv-table).
  prefs: []
  type: TYPE_NORMAL
- en: 'An examination of the file shows that it will need some work to be put in a
    format that can be easily used. Each row of the file contains a time series of
    annual data corresponding to one country and economic indicator. One initial step
    is to get all the countries and economic indicators contained in the file. To
    get a list of unique country names, we can use the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how many countries are represented, run the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Some of the entries in the file actually correspond to groups of countries,
    such as Sub-Saharan Africa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for indicators, we can run the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more than 1300 different economic indicators in the file. This can
    be verified by running the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the different kinds of computation one might be interested in performing,
    let''s consider a single country, for example, Brazil. Let''s also suppose that
    we are only interested on the **Gross Domestic Product** (**GDP**) information.
    Now, we''ll see how to select the data we are interested in from the table. To
    make the example simpler, we will perform the selection in two steps. First, we
    select all rows for the country name `Brazil`, using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code preceding command line, consider the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This selects all the rows in which the country name string is equal to `Brazil`.
    For these rows, we want to select all columns of the table, as indicated by the
    colon in the first term of the slicing operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now select all the rows that refer to the GDP data. We start by defining
    a function that, given a string, determines if it contains the substring `GDP`
    (ignoring the case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We now want to select the rows in `wdi_br` that return `True` when `select_fcn`
    is applied to the `Indicator Code` column. This can be done with the following
    command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map()` method of the `Series` object does exactly what we want: it applies
    a function to all elements of a series. We assign the result of this call to the
    variable, `criterion`. Then, we use `criterion` in the slicing operation that
    defines `wdi_br_gdp`. To see how many rows were selected, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In the dataset used at the writing of this book, the preceding command returns
    `32`. This means that there are 32 GDP-related indicators for the country named
    `Brazil`. Since we now have a manageable amount of data, we can display a table
    that has the indicator codes and their meanings using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command line generates a nicely formatted table of the indicator
    and corresponding names, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example with a realistic dataset](img/8341OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say that we are interested only in four indicators: the GDP, annual
    GDP growth, GDP per capita, and GDP per capita growth. We can further trim the
    data with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This produces quite a manageable table with 4 rows and 58 columns. Each row
    contains a time series of the corresponding GDP data starting with the year 1960.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this table as it is laid out is that it is the "transpose"
    of what is the usual convention in pandas: the time series are across the rows
    of the table, instead of being down the columns. So, we still need to do a little
    more work with our table. We want the indexes of our table to be the years. We
    also want to have one column for each economic indicator and want to use the economic
    indicator names (not the codes) as the labels of the columns. Here is how this
    can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an explanation of what the preceding command lines do:'
  prefs: []
  type: TYPE_NORMAL
- en: We first define an `Index` object corresponding to the years in the table using
    the `columns` field of the `DataFrame` object. The object is stored in the variable
    `idx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create an object containing the column names. This is a `Series` object
    stored in the variable `cols`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we extract the data we are interested in, that is, the portion of the
    table corresponding to the years after 1960\. We use the `as_matrix()` method
    of the `DataFrame` object to convert the data to a `NumPy` array, and store it
    in the variable `data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call the `DataFrame` constructor to create the new table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the data we want in a nice format, it is a good time to save
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can open the `WDI_Brazil_GDP.csv` file in a spreadsheet program
    to view it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start playing with the data by creating a few plots. Let's first
    plot the GDP and GDP growth, starting in 1980\. Since the data is given in dollars,
    we scale to give values in billions of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines produce the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example with a realistic dataset](img/8341OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a final example, let''s draw a chart comparing the percent growth of per
    capita GDP for the **BRIC** (**Brazil, Russia, India, and China**) countries in
    the period 2000 to 2010\. Since we already have explored the structure of the
    data, the task is somewhat simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define a list with the names of the BRIC countries and a string with
    the indicator code for percent GDP growth per capita. Then, we define a selection
    function: a string is selected if it is one of the BRIC country names. The `map()`
    method is then used to apply the selection function to all entries of the `Country
    Name` column. The last command line performs the actual selection. Note the use
    of the Boolean operator `&` to combine the two criteria used in the row selection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now perform the reformatting of the data to have the relevant data series
    along the columns of the table. The command lines are similar to the ones in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, plotting the data is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lines result in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An example with a realistic dataset](img/8341OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the objects of pandas, `Series` and `DataFrame`,
    which are specialized containers for data-oriented computations. We discussed
    how to create, access, and modify these objects, including advanced indexing and
    slicing operations. We also considered the computational and graphical capabilities
    offered by pandas. We then discussed how these capabilities can be leveraged to
    work with a realistic dataset.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use SciPy to solve advanced mathematical
    problems of modeling, science, and engineering.
  prefs: []
  type: TYPE_NORMAL
