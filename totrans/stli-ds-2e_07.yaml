- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Streamlit Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have explored features that have been developed by the
    Streamlit core development team, who works full-time on these new and exciting
    features. This chapter, however, will focus on community-driven development, through
    Streamlit Components. While building Streamlit, the team created an established
    method for other developers to create additional features on top of all the existing
    Streamlit open-source magic we have already seen. This method is called Components!
    Streamlit Components allow developers the flexibility to go out and make features
    that are crucial to their workflows or are just simply fun and interesting.
  prefs: []
  type: TYPE_NORMAL
- en: As Streamlit has become increasingly popular as a framework, so have its Components.
    It feels like every day, I see a new and interesting component that I want to
    try out on my own apps! This chapter will be focused on how to both find and use
    community-made Streamlit Components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following six Streamlit Components:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding editable DataFrames with `streamlit-aggrid`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating drill-down graphs with `streamlit-plotly-events`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating beautiful GIFs with `streamlit-lottie`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated analysis with `pandas-profiling`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive maps with `st-folium`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful mini-functions with `streamlit-extras`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding more Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the technical requirements in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can work with new Streamlit Components, we need to download them
    first. We can download each using `pip` (or any other package manager), just as
    we did with Streamlit in *Chapter 1,* *An Introduction to Streamlit*. These are
    the Components to be downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '`streamlit-aggrid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streamlit-plotly-events`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streamlit-lottie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streamlit-pandas-profiling`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streamlit-folium`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streamlit-extras`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To try out all of these libraries, we’re going to create a multi-page app with
    each library as a self-contained Streamlit app. We will try this out in a new
    folder, which we’ll call `components_example`. For our multi-page app, we need
    a folder called `pages`, and for our first library (`streamlit-aggrid`), we will
    need to add a Python file called `aggrid.py` inside the `pages` folder. We’ll
    be using data from both the penguins and trees datasets that we have already used,
    so copy those into the folder as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of all that, your `components_example` folder should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Folder Structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `streamlit_app.py`, we can add the following code to inform the user
    that all the examples live within the rest of the multi-page app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, onto `streamlit-aggrid`!
  prefs: []
  type: TYPE_NORMAL
- en: Adding editable DataFrames with streamlit-aggrid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used a few methods for showing DataFrames in our Streamlit apps,
    such as the built-in `st.write` and `st.dataframe` functions. We also covered
    the experimental editable DataFrame that Streamlit released in version 1.19, which
    is not as feature-rich in comparison to `streamlit-aggrid` but is significantly
    easier to use! `streamlit-aggrid` essentially creates a beautiful, interactive,
    and editable version of `st.dataframe`, and is built on top of a JavaScript product
    called `AgGrid` ([https://www.ag-grid.com/](https://www.ag-grid.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand this library is to give it a shot! Let’s start by
    using the example of the penguins dataset, with the desire to make an interactive
    and editable DataFrame, which `AgGrid` is so good at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `aggrid.py`, we can pull in the penguins data, and use the central function
    in `streamlit-aggrid` called `AgGrid` to display the data in our Streamlit app.
    The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets us to 80% of our desired solution. It creates an app with a whole
    host of features! This app looks like this as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: AgGrid Example'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on each column it comes with an auto-filtering mechanism, the
    ability to sort by value, show and hide columns, etc. For example, we can filter
    the **species** column in our dataset to only include the **Chinstrap** value,
    and the DataFrame responds as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: First Filter'
  prefs: []
  type: TYPE_NORMAL
- en: 'I would encourage you to play around with the features in `AgGrid` to see the
    full set of possibilities. One thing that you might notice is that it shows the
    entire DataFrame by default. I find this to be a little bit jarring for a Streamlit
    app, but luckily, there is a `height` parameter in `streamlit-aggrid` to force
    the DataFrame to fit within a specific height. See the following code for how
    to ensure this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last feature that we have already discussed but have not shown off yet
    is the ability to edit DataFrames within AgGrid. Again, it is as easy as adding
    a parameter to the AgGrid function. The function returns the edited DataFrame,
    which we can use in the rest of our app. This means that the component is bidirectional,
    just like all the Streamlit input widgets we have already used. This next bit
    of code adds the edit functionality and also shows how we can access the edited
    DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From this code, we can see the following app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Editable DataFrames'
  prefs: []
  type: TYPE_NORMAL
- en: The above app is shown after I went in and edited a single row of the DataFrame,
    changing the value from `Adelie` to `Adelie_example`. We can then use that DataFrame
    in the rest of our app and can do anything from showing a graph based on the edited
    DataFrame to saving the DataFrame back to a CSV file; the possibilities here are
    enormous. `streamlit-aggrid` is one of the most popular Streamlit Components,
    and hopefully, you now see why! There are dozens of other features in the library;
    you can find more of them at [https://streamlit-aggrid.readthedocs.io/](https://streamlit-aggrid.readthedocs.io/).
    Now, onto drill-down graphs with the next component, `streamlit-plotly-events`!
  prefs: []
  type: TYPE_NORMAL
- en: Creating drill-down graphs with streamlit-plotly-events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most popular advanced features in any plotting library is the ability
    to drill down into sections or parts of graphs. The users of your apps will often
    have questions about your data that you have not anticipated in advance! Instead
    of creating new Streamlit inputs around graphs, users often will want to click
    on items in your graphs like points or bars, and get more information about that
    point. For example, in our penguins scatterplot graph, a user might want to see
    all the data available for a penguin, which is represented by a point being scrolled
    over in a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '`streamlit-plotly-events` turns the unidirectional `st.plotly_chart` function
    into a bidirectional one, where we can receive events like clicks or hovers back
    into our Streamlit app. To test this out, we will create another app inside the
    `pages` folder, this one called `plotly_events` and will create a graph based
    on the penguins dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start out, we can import the libraries, read in the data, and make a familiar
    graph in Plotly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of calling `st.plotly_chart`, we replaced it with the `plotly_events`
    function call instead. Other than that, there is no difference between this and
    our regular use of Plotly. At the moment, this does nothing special, and our app
    should look fairly standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Plotly Chart Original'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plotly_events` function takes an argument called `click_event`, which,
    if we set it to `true`, will return all the click events back to Streamlit as
    a variable. The next script uses this parameter and writes the click event back
    to Streamlit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now when we run this app and click on points, we can see the clicked-on value!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Click Event'
  prefs: []
  type: TYPE_NORMAL
- en: This is not incredibly special just yet, because Plotly has these points on
    hover already. We can improve on this by showing all the data we have on the clicked-on
    point, as shown in the following code (I removed the imports for brevity). We
    need to stop the app if there are no points selected; otherwise, the app will
    error out!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our final app looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Drill-Down Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: It really is that easy to turn Plotly charts into drill-down, bidirectional
    dashboards! In this example, users can see info like the sex and flipper length
    of the penguins they have selected, and we theoretically could use this selection
    event however we’d like in the rest of the app.
  prefs: []
  type: TYPE_NORMAL
- en: The `streamlit-plotly-events` library has two other events (`select_event` and
    `hover_event`), which can be useful as well and are returned in the same fashion.
    If you’ve used one of them, you can easily pick up the others when it is necessary.
    With drill-down dashboards done, let’s move over to adding beautiful animations
    to our app using `streamlit-lottie`!
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit Components – streamlit-lottie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lottie** is a web-native, open-source library created by *Airbnb* to make
    putting animations on your website just as easily as putting static images on
    it. It is very common for large, profitable tech companies to put out open-source
    software as a way of giving back to the developer community (or, more likely,
    to recruit developers who think their software is cool), and this is no exception.
    In this case, `streamlit-lottie` wraps around `lottie` files and places them directly
    into our Streamlit apps.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we try this out for ourselves, we first need to import the `streamlit-lottie`
    library, and then point the `st_lottie()` function to our `lottie` file. We can
    either import a local `lottie` file or, more likely, we can find a useful animation
    file on the free site ([https://lottiefiles.com/](https://lottiefiles.com/)) and
    load it from there into our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this out, we can add a cute penguin animation ([https://lottiefiles.com/39646-cute-penguin](https://lottiefiles.com/39646-cute-penguin))
    to the top of the Penguins app that we created earlier in this chapter. To keep
    everything organized, let’s copy the `plotly_events.py` file in its current state
    to a new file called `penguin_animated.py`, also in the `pages` folder. We can
    run the following code from the `components_example` folder, or just copy the
    file over manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in this new file, we can make some changes to the older app. The following
    code block makes a function, as shown in the example from the `streamlit-lottie`
    library ([https://github.com/andfanilo/streamlit-lottie](https://github.com/andfanilo/streamlit-lottie)),
    which allows us to load `lottie` files from the URL and then loads this animation
    at the top of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of the app will stay the same as with the Plotly events library
    section. Now when we run the Streamlit app, we see the animation at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Cute Penguin'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section of code uses the `requests` library to define a function
    that we can use to load `lottie` files from a link. In this case, I have pre-filled
    a link that takes us to a cute penguin animation. We then loaded our file and
    called that file using the `st_lottie()` function we imported from our `streamlit-lottie`
    library. And as you can see, we have an animation at the top!
  prefs: []
  type: TYPE_NORMAL
- en: '`streamlit-lottie` also allows us to change the animation speed, width, and
    height through the `speed`, `width`, and `height` parameters, respectively. If
    the animation goes too slowly for your taste, increase the speed to a number such
    as `1.5` or `2`, which will increase the speed by 50% or 100%. The `height` and
    `width` parameters, however, are the pixel height/width of the animation and default
    to the native size of the animation.'
  prefs: []
  type: TYPE_NORMAL
- en: I would strongly encourage running this app, as the penguin animation is really
    quite adorable. And that completes our tour of `streamlit-lottie`! I have started
    getting into the habit of putting a nice animation at the top of each and every
    Streamlit app I create—it creates a sense of design that makes Streamlit apps
    feel more purposeful, and immediately alerts the user to the fact that this is
    not a static document but instead a dynamic and interactive application.
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit Components – streamlit-pandas-profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pandas-profiling` is a very powerful Python library that automates some of
    the EDA, which is often the first step in any data analysis, modeling, or even
    data engineering task. Before a data scientist begins almost any data work, they
    want to start with a good understanding of the distributions of their underlying
    data, the number of missing rows, correlations between variables, and many other
    basic pieces of information. As we mentioned before, this library automates the
    process and then places this interactive analytics document into a Streamlit app
    for the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Behind the Streamlit component called `pandas-profiling`, there is a full Python
    library with the same name, which the component imports its functions from. The
    Streamlit component here actually renders the output from the `pandas-profiling`
    Python library in a way that becomes very easy to integrate. For this segment,
    we will first learn how to implement the library, and then explore the generated
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will continue with our code from the previous section on
    Palmer Penguins and add our automatically generated profile to the bottom of the
    app. The code for this is only a few lines—we need to generate a report for our
    dataset and then use the Streamlit component to add the generated report to our
    app. Again, as we did before, copy the code from the `streamlit-lottie` section
    into a new file called `penguin_profiled.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next code block imports the necessary libraries for our profiling!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The middle section of the app stays the same, so we will not copy all the code
    here. The end, however, uses the functions that we imported earlier to get a profile
    of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get an entire profile of the penguins dataset, which looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The penguin dataset profile'
  prefs: []
  type: TYPE_NORMAL
- en: This has an overview section that warns us about variables that are highly correlated
    or missing data, and even allows us to drill down into specific columns incredibly
    easily. We could remake this entire library in Streamlit (I’ll leave that as a
    very advanced exercise to the reader!), but it is nice to have an automated exploratory
    analysis like this.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a good lesson about composability—we can treat Streamlit Components
    as unique Lego blocks, combining them at will to create new and interesting Streamlit
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: This is another component that you should try out on your own, to see all the
    information that it can show the user. Now on to bidirectional apps with `st-folium`!
  prefs: []
  type: TYPE_NORMAL
- en: Interactive maps with st-folium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned how critical it could be to add bidirectionality
    to visualizations through `streamlit-plotly-events`. Drilling down into graphs
    is an oft requested feature by business users, and maps are no exception to that!
    `st-folim` is very similar to `streamlit-plotly-events`, but for geospatial maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example focuses on the trees dataset that we have used time and time again
    in this book, so go ahead and create a new file in the `pages` folder called `folium_map.py`,
    and we can get started. The following section of code loads the libraries, adds
    the data, creates a `folium` map, and adds that map to our Streamlit app. This
    is mostly a repeat of our previous graph, which maps the trees in SF but adds
    the Folium library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will create the following app, which, as of now, is just a map of
    San Fransisco! But you will notice that we can scroll around, zoom in and out,
    and make use of all the normal features we would expect from a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Our first Folium map'
  prefs: []
  type: TYPE_NORMAL
- en: On top of this, we want to add a little marker for each of the points that we
    have in our trees dataset, to replicate the trees map we have already created.
    We can use a basic `for` loop to do this!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our app will have our 100 trees as markers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Adding points to Folium'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not that special just yet! Cool, but is not that different from any
    other map that we can make. The interesting part comes when we realize that the
    `st_folium` function returns the click events made on the map by default! So now,
    we can receive those events and print them back to the Streamlit app with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our app now prints out the click events to our Streamlit app, and we can then
    use them programmatically in the same way as in `streamlit-plotly-events`!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Bidirectional Maps'
  prefs: []
  type: TYPE_NORMAL
- en: This is the magic of Streamlit, and of `st-folium`! Interactivity is straightforward,
    and dynamic apps that delight users are just around each corner.
  prefs: []
  type: TYPE_NORMAL
- en: Now for our last library of this chapter, a library created by the Streamlit
    data product team called `streamlit-extras`!
  prefs: []
  type: TYPE_NORMAL
- en: Helpful mini-functions with streamlit-extras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have personally been a part of the Streamlit data product team since the beginning
    of 2022, and that work unsurprisingly centers around creating Streamlit apps about
    the business that is Streamlit. The team creates dozens of apps for dozens of
    business partners, and as a part of that work has created dozens of helper functions
    that make it more fun and efficient to create Streamlit apps.
  prefs: []
  type: TYPE_NORMAL
- en: Every team has functions like these. At Streamlit, it is encouraged to open-source
    as much of your work as possible, so we decided to turn these functions into a
    Python package and release it out to the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we had a problem where users of our apps would accidentally just
    select one date in a date range, and then the entire app would not run correctly.
    In response to this, we built a mandatory date range picker that will not run
    the app until two dates are selected! It can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for another example, we wanted to have an input that looked like the toggles
    in our favorite document management software, Notion. So we built a small one!
    It can be used like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create toggles that look like this!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Toggle!'
  prefs: []
  type: TYPE_NORMAL
- en: All of these features, and dozens more, exist in one little library. A huge
    percent of this work can be attributed to my teammates Arnaud Miribel ([https://github.com/arnaudmiribel](https://github.com/arnaudmiribel))
    and Zachary Blackwood ([https://github.com/blackary](https://github.com/blackary))!
    They built and released this library and are great Streamlit developers to follow
    on GitHub. You can find the rest of Streamlit extras at ([https://extras.streamlit.app/](https://extras.streamlit.app/)),
    so `pip` `install` and give it a shot!
  prefs: []
  type: TYPE_NORMAL
- en: Finding more Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These Components are a tiny percentage of all the Components the Streamlit community
    has created, and by the time you may be reading this, I am sure the number of
    Components out there will be dramatically higher. The best place to find new and
    interesting Components is on either the Streamlit website at [https://streamlit.io/gallery?type=components&category=featured](https://streamlit.io/gallery?type=components&category=featured)
    or the discussion forums at [https://discuss.streamlit.io/c/streamlit-components/18](https://discuss.streamlit.io/c/streamlit-components/18).
  prefs: []
  type: TYPE_NORMAL
- en: When you find a Component that you think is interesting, try it out by downloading
    it with `pip` as we did earlier, and read enough documentation to get started!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, I hope you feel very comfortable downloading and using Streamlit
    Components, which you have learned about here, as well as comfortable with finding
    new Streamlit Components created by the community. You should really understand
    how to find, download, and use Streamlit Components to bolster the apps that you
    build.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive more deeply into deploying your own Streamlit
    apps with a cloud provider such as **Heroku** or **Hugging Face**!
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/sl](https://packt.link/sl)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code13440134443835796.png)'
  prefs: []
  type: TYPE_IMG
