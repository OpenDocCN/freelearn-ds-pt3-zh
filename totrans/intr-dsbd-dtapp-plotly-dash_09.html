<html><head></head><body>
		<div id="_idContainer137">
			<h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor106"/>Chapter 7</em>: Exploring Map Plots and Enriching Your Dashboards with Markdown</h1>
			<p>In this chapter, we are going to explore how to handle maps, one of the most engaging types of charts. There are many ways of creating and handling maps, as well as many types of map plots. There are also many specialized geographic and scientific applications for maps. We will mainly be focusing on two of the most common types of map plots: <strong class="bold">choropleth map plots</strong> and <strong class="bold">scatter map plots</strong>. Choropleth maps are the type of maps we are most familiar with. These are the types of maps where geographical areas are colored to indicate a country, state, district, or any arbitrary polygon on a map, and express variations in quantity among them. Most of the knowledge we established in the previous chapter can easily be adapted to scatter map plots, as they are essentially the same, with a few differences. Similar to the <em class="italic">x</em> and <em class="italic">y</em> axes, we have longitude and latitude instead, and we also have different map projections. We will also learn about a new component, <strong class="bold">Markdown</strong>, from Dash Core Component.</p>
			<p>Then, we will explore how to use <strong class="bold">Mapbox</strong>, which provides a rich interface with different layers, themes, and zoom levels. It also allows us to create choropleth and scatter map plots.</p>
			<p>We will mainly cover the following topics: </p>
			<ul>
				<li>Exploring choropleth maps</li>
				<li>Utilizing animation frames to add a new layer to your plots</li>
				<li>Using callback functions with maps</li>
				<li>Creating a <strong class="source-inline">Markdown</strong> component</li>
				<li>Understanding map projections</li>
				<li>Using scatter map plots</li>
				<li>Exploring Mapbox maps</li>
				<li>Exploring other map options and tools</li>
				<li>Incorporating an interactive map into our app</li>
			</ul>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>We will use similar tools to the ones we used in the previous chapter. We will mainly be using Plotly Express for creating our charts. The packages to use are Plotly, Dash, Dash Core Components, Dash HTML Components, Dash Bootstrap Components, pandas, and JupyterLab.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_07">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_07</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3sAY8z8">https://bit.ly/3sAY8z8</a>.</p>
			<p>We'll start by exploring how easy it is to create choropleth maps for countries.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Exploring choropleth maps</h1>
			<p>Choropleth maps are basically colored polygons representing a certain area on a map. Plotly ships with <a id="_idIndexMarker390"/>country maps included (as well as US states), and so it is very easy to plot maps if we have information about countries. We already have such information in our dataset. We have country names, as well as country codes, in every row. We also have the year, some metadata about the countries (region, income group, and so on), and all the indicator data. In other words, every data point is connected to a geographical location. So, let's start by choosing a year and an indicator, and see how the values of our chosen indicator vary across countries:</p>
			<ol>
				<li>Open the <strong class="source-inline">poverty</strong> file into a DataFrame and create the <strong class="source-inline">year</strong> and <strong class="source-inline">indicator</strong> variables:<p class="source-code">import pandas as pd</p><p class="source-code">poverty = pd.read_csv('data/poverty.csv')</p><p class="source-code">year = 2016</p><p class="source-code">indicator = 'GINI index (World Bank estimate)'</p></li>
				<li>Create a subset of <strong class="source-inline">poverty</strong> with values from the selected year and containing countries only:<p class="source-code">df = poverty[poverty['is_country'] &amp; poverty['year'].eq(year)]</p></li>
				<li>Create a choropleth map using the <strong class="source-inline">choropleth</strong> function from Plotly Express, by choosing the column that identifies the countries and the column that will be used for the colors:<p class="source-code">import plotly.express as px</p><p class="source-code">px.choropleth(df, locations="Country Code", color=indicator)</p></li>
			</ol>
			<p>You can <a id="_idIndexMarker391"/>see the result of the preceding code in <em class="italic">Figure 7.1</em>:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B16780_07_1.jpg" alt="Figure 7.1 – A choropleth map of countries"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A choropleth map of countries</p>
			<p>The country codes we provided were already included in Plotly, and are in the three-letter ISO format. As with scatter plots, you can see that since we provided a numeric column for the color, a continuous color scale was chosen. Otherwise, we would have gotten a discrete color sequence. For example, setting <strong class="source-inline">color='Income Group'</strong> would produce the chart in <em class="italic">Figure 7.2</em>:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B16780_07_2.jpg" alt="Figure 7.2 – A choropleth map of countries with a discrete color sequence"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – A choropleth map of countries with a discrete color sequence</p>
			<p>As you can see, and <a id="_idIndexMarker392"/>similar to what we saw in <a href="B16780_06_Final_NM_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Variables with Scatter Plots and Filtering Subsets with Sliders</em>, the color system works in a similar way.</p>
			<p>We can also use normal country names to plot them. To do that, we only need to set <strong class="source-inline">locationmode='country names'</strong> and the rest works the same. Here is an example with country names:</p>
			<p class="source-code">px.choropleth(df, </p>
			<p class="source-code">              locations=['Australia', 'Egypt', 'Chile'], </p>
			<p class="source-code">              color=[10, 20, 30], </p>
			<p class="source-code">              <strong class="bold">locationmode='country names'</strong>)</p>
			<p>This creates the chart in <em class="italic">Figure 7.3</em>:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B16780_07_3.jpg" alt="Figure 7.3 – A choropleth map of countries using country names"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – A choropleth map of countries using country names</p>
			<p>The title <a id="_idIndexMarker393"/>of the color bar is <strong class="source-inline">color</strong> because it is not clear what it is, and it is not a name of a column in a DataFrame. We can rename it by setting <strong class="source-inline">labels={'color': &lt;metric_name&gt;}</strong> to indicate what the metric is in our case. Let's now see how we can make the chart interactive (without using a callback).</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Utilizing animation frames to add a new layer to your plots</h1>
			<p>In the last examples, we set the year as a variable and got a snapshot of the desired indicator <a id="_idIndexMarker394"/>for that year. Since the years represent sequential values, and can also be used as a grouping variable, we can use the years in the <strong class="source-inline">animation_frame</strong> parameter and make the chart interactive. This would introduce a new handle underneath the chart, where users can either drag to the desired year or press the play button to watch how the respective indicator progresses throughout the years. It would be a sequence of frames, like watching a video. What this does is that for a selected year, we will get a subset of the DataFrame where the rows in the <strong class="source-inline">year</strong> column are equal to the selected year. The chart automatically updates with colors corresponding to the values of the year that was chosen. </p>
			<p>Here is the updated code to produce an animated chart (by year): </p>
			<p class="source-code">fig = px.choropleth(poverty[poverty['is_country']],|</p>
			<p class="source-code">                    <strong class="bold">color_continuous_scale='cividis'</strong>,</p>
			<p class="source-code">                    locations='Country Code',</p>
			<p class="source-code">                    color=indicator,</p>
			<p class="source-code">                    <strong class="bold">animation_frame='year'</strong>)</p>
			<p class="source-code">fig.show()</p>
			<p>We can <a id="_idIndexMarker395"/>now see the updated chart in <em class="italic">Figure 7.4</em>: </p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B16780_07_4.jpg" alt="Figure 7.4 – A choropleth map of countries with an animation frame"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – A choropleth map of countries with an animation frame</p>
			<p>As you can see, all we had to do is select a column name to use for <strong class="source-inline">animation_frame</strong>, and everything is handled for us. We used a DataFrame where we only have countries, which includes all years. The further sub-setting is done automatically by the argument given to <strong class="source-inline">animation_frame</strong>. We can drag the handle to a specific year or press the play button and watch how it changes over time. Note that we also changed the color scale to experiment with a different one. Both color scales used so far should also be readable on a grayscale version of the map.</p>
			<p>Now that we have a basic map in place, let's explore what options we have to control several aspects of the map. The <strong class="source-inline">layout</strong> attribute of map charts has a sub-attribute called <strong class="source-inline">geo</strong>, under <a id="_idIndexMarker396"/>which there are several useful geographic attributes that allow us to control many aspects of our maps. These attributes work the same way as other attributes.</p>
			<p>We basically set them by running <strong class="source-inline">fig.layout.geo.&lt;attribute&gt; = value</strong> to set the desired value. Let's explore some of these attributes and their effects on the previous chart:</p>
			<ul>
				<li>Remove the rectangular frame around the map:<p class="source-code">fig.layout.geo.showframe = False</p></li>
				<li>Show the country borders, even if/when we don't have data for some countries:<p class="source-code">fig.layout.geo.showcountries = True</p></li>
				<li>Use a different projection of the Earth. Select the <strong class="source-inline">natural earth</strong> projection type (more on this later):<p class="source-code">fig.layout.geo.projection.type = 'natural earth'</p></li>
				<li>Limit the vertical range of the chart to focus more on countries, by setting the minimum and maximum latitude values that the map should show:<p class="source-code">fig.layout.geo.lataxis.range = [-53, 76]</p></li>
				<li>Limit the horizontal range of the chart using the same technique: <p class="source-code">fig.layout.geo.lonaxis.range = [-137, 168]</p></li>
				<li>Change the color of the land to <strong class="source-inline">'white'</strong> to make it clear which countries have missing data:<p class="source-code">fig.layout.geo.landcolor = 'white'</p></li>
				<li>Set the background color of the map (the color of the oceans), as well as the "paper" background color of the figure as a whole. Use the same color that we are using for the app to have a consistent theme: <p class="source-code">fig.layout.geo.bgcolor = '#E5ECF6'</p><p class="source-code">fig.layout.paper_bgcolor = '#E5ECF6'</p></li>
				<li>Set the colors of the country borders as well as the coastlines to <strong class="source-inline">'gray'</strong>:<p class="source-code">fig.layout.geo.countrycolor = 'gray'</p><p class="source-code">fig.layout.geo.coastlinecolor = 'gray'</p></li>
				<li>Since the title of the color bar is taking up a lot of horizontal space, replace spaces with the <strong class="source-inline">&lt;br&gt;</strong> character, to split it to multiple lines:<p class="source-code">fig.layout.coloraxis.colorbar.title =\</p><p class="source-code">indicator.replace(' ', '&lt;br&gt;')</p></li>
			</ul>
			<p>As a <a id="_idIndexMarker397"/>result, we get the updated chart in <em class="italic">Figure 7.5</em>: </p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B16780_07_5.jpg" alt="Figure 7.5 – A choropleth map of countries with custom geo options"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – A choropleth map of countries with custom geo options</p>
			<p>With a few commands, we have transformed how our chart looks. We restricted the ranges to focus mainly on countries and land, as much as possible. We also set consistent background colors and displayed country borders. There are several other options that can easily be explored under the <strong class="source-inline">fig.layout.geo</strong> attribute. We are now ready to make the indicator selection dynamic; let's see how.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Using callback functions with maps</h1>
			<p>What we have done so far was done with one indicator, and we used this indicator to select the <a id="_idIndexMarker398"/>desired column from the dataset. We <a id="_idIndexMarker399"/>can easily create a dropdown to allow users to choose any of the available indicators and let them explore the whole dataset. The <strong class="source-inline">year</strong> variable is already interactive and part of the chart, as used by the <strong class="source-inline">animation_frame</strong> parameter. So, this can become the first exploratory interactive chart that users start with on our app, to help them get an overview of the available metrics and how they are changing in time.</p>
			<p>Setting this up is straightforward, as we did several times. We will implement it, and after that, we will see how to use the <strong class="source-inline">Markdown</strong> component to add context around/about the map chart and the chosen indicator.</p>
			<p>Let's do the necessary steps to implement this functionality independently in JupyterLab: </p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Dropdown</strong> component, where the available options are the column names of <strong class="source-inline">poverty</strong>, using the columns between the third and 54th columns:<p class="source-code">dcc.Dropdown(id='indicator_dropdown',</p><p class="source-code">             value='GINI index (World Bank estimate)',</p><p class="source-code">             options=[{'label': indicator, 'value': indicator}</p><p class="source-code">                      for indicator in poverty.columns[3:54]])</p></li>
				<li>Create an empty <strong class="source-inline">Graph</strong> component, right under the dropdown we just created: <p class="source-code">dcc.Graph(id='indicator_map_chart')</p></li>
				<li>The indicator names vary in length, and some of them are so long that they take up almost half the screen size. We can handle this in a similar way to what we did previously, by creating a simple function. The function takes a string, splits it into words, groups every three words together, and then joins them with the <strong class="source-inline">&lt;br&gt;</strong> character:<p class="source-code">def multiline_indicator(indicator):</p><p class="source-code">    final = []</p><p class="source-code">    split = indicator.split()</p><p class="source-code">    for i in range(0, len(split), 3):</p><p class="source-code">        final.append(' '.join(split[i:i+3]))</p><p class="source-code">    return '&lt;br&gt;'.join(final)</p></li>
				<li>Create <a id="_idIndexMarker400"/>a callback that links the dropdown with the map chart: <p class="source-code">@app.callback(Output('indicator_map_chart', 'figure'),</p><p class="source-code">              Input('indicator_dropdown', 'value'))</p></li>
				<li>Define <a id="_idIndexMarker401"/>the function that takes the selected indicator and returns the desired map chart. Note that we set the title of the figure by using the indicator as its value. We also used the <strong class="source-inline">Country Name</strong> column to set the hover name, which is the title of the box that appears when users hover over a certain country. The height was also set to <strong class="source-inline">650</strong> pixels. The remaining geo properties were omitted here to avoid repetition, but they are the same as we set them previously. We also modify the color bar title, using the <strong class="source-inline">multiline_indicator</strong> function we just created:<p class="source-code">def display_generic_map_chart(indicator):</p><p class="source-code">    df = poverty[poverty['is_country']]</p><p class="source-code">    fig = px.choropleth(df,</p><p class="source-code">                        locations='Country Code',</p><p class="source-code">                        color=indicator,</p><p class="source-code">                        <strong class="bold">title=indicator</strong>,</p><p class="source-code">                        <strong class="bold">hover_name='Country Name'</strong>,</p><p class="source-code">                        color_continuous_scale='cividis',</p><p class="source-code">                        animation_frame='year',</p><p class="source-code">                        <strong class="bold">height=650</strong>)</p><p class="source-code">    fig.layout.geo.showframe = False</p><p class="source-code">    …</p><p class="source-code">    fig.layout.coloraxis.colorbar.title =\</p><p class="source-code">multiline_indicator(indicator)</p></li>
			</ol>
			<p>Running <a id="_idIndexMarker402"/>the app in JupyterLab, you can explore <a id="_idIndexMarker403"/>the different metrics. <em class="italic">Figure 7.6</em> shows a few examples of charts produced by selecting different indicators and years:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B16780_07_6.jpg" alt="Figure 7.6 – Examples of map charts produced interactively"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Examples of map charts produced interactively</p>
			<p>Once given <a id="_idIndexMarker404"/>the option, users can search the dropdown <a id="_idIndexMarker405"/>for various keywords and select what they find interesting. It is still not very clear what exactly many of these indicators refer to and what their limitations might be. This is a good opportunity for us to display those details to users, to make it clear what they are looking at. As mentioned previously, the limitations in measurement are crucial to highlight, so users are aware of them. Let's see how we can add formatted text using the <strong class="source-inline">Markdown</strong> component.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/>Creating a Markdown component</h1>
			<p>Markdown is a way to produce HTML in a manner that is easy to write and also easy to read. The <a id="_idIndexMarker406"/>output would be displayed as any HTML document would, but the process of writing it and reading it is much easier. Compare the following two snippets, which result in the same HTML output: </p>
			<p>Using pure HTML, we would write the following: </p>
			<p class="source-code">&lt;h1&gt;This is the main text of the page&lt;/h1&gt;</p>
			<p class="source-code">&lt;h3&gt;This is secondary text&lt;/h2&gt;</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">  &lt;li&gt;first item&lt;/li&gt;</p>
			<p class="source-code">  &lt;li&gt;second item&lt;/li&gt;</p>
			<p class="source-code">  &lt;li&gt;third item&lt;/li&gt;</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>The same code can be written with Markdown as follows: </p>
			<p class="source-code"># This is the main text of the page</p>
			<p class="source-code">### This is secondary text</p>
			<p class="source-code">* first item</p>
			<p class="source-code">* second item</p>
			<p class="source-code">* third item</p>
			<p>I think it's clear that Markdown is much easier to write, as well as to read, especially when you have nested items such as the <strong class="source-inline">&lt;ul&gt;</strong> unordered list we have here.</p>
			<p>The <strong class="source-inline">Markdown</strong> component works the same way. The preceding code simply has to be passed to the <strong class="source-inline">children</strong> argument, which would render it as the HTML shown previously. Let's create <a id="_idIndexMarker407"/>a minimal app in JupyterLab to see how the <strong class="source-inline">Markdown</strong> component works:</p>
			<ol>
				<li value="1">Make the necessary imports and instantiate an app:<p class="source-code">from jupyter_dash import JupyterDash</p><p class="source-code">import dash_core_components as dcc</p><p class="source-code">app = JupyterDash(__name__)</p></li>
				<li>Create the layout attribute of the app:<p class="source-code">app.layout = html.Div([])</p></li>
				<li>Pass the <strong class="source-inline">Markdown</strong> component <a id="_idIndexMarker408"/>with the preceding text to the <strong class="source-inline">div</strong> just created. Note that it is easier to use triple quotes especially when using multiline text: <p class="source-code">dcc.Markdown("""</p><p class="source-code"><strong class="bold"># This is the main text of the page</strong></p><p class="source-code"><strong class="bold">### This is secondary text</strong></p><p class="source-code"><strong class="bold">* first item</strong></p><p class="source-code"><strong class="bold">* second item</strong></p><p class="source-code"><strong class="bold">* third item</strong></p><p class="source-code">""")</p></li>
				<li>Run the app:<p class="source-code">app.run_server(mode='inline')</p></li>
			</ol>
			<p>The preceding code creates a mini-app with its output shown in <em class="italic">Figure 7.7</em>:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B16780_07_7.jpg" alt="Figure 7.7 – A sample output of the Markdown component"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – A sample output of the Markdown component</p>
			<p>Markdown has several other ways of displaying text, such as numbered lists, tables, links, bold and italic text, and more. We will be covering some of these features, but they are easy to pick up in case you are not familiar with them. Keep in mind that there are various "flavors" of Markdown used by different platforms. You might come across slightly different markup/syntax rules but in general, there is a lot of overlap.</p>
			<p>We will now <a id="_idIndexMarker409"/>add some information to the map that the user generates after selecting the metric of their choice. Basically, we will add the important information right underneath the map and slider. <em class="italic">Figure 7.8</em> shows how this will look, in order to give you an idea of what we are working toward:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B16780_07_8.jpg" alt="Figure 7.8 – A sample of the Markdown component"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – A sample of the Markdown component</p>
			<p>All the text and formatting you see in the figure are produced by the <strong class="source-inline">Markdown</strong> component. </p>
			<p>In order to create a special area for it on the app, we simply add a <strong class="source-inline">Markdown</strong> component under the map, giving it a unique ID. </p>
			<p>Producing this component will happen in the same callback we created to generate the map. The callback should now take two <strong class="source-inline">Output</strong> elements instead of one, and when returning, it should return two elements as well (the figure, as well as the Markdown generated). To get the <a id="_idIndexMarker410"/>required content for this component, we need to open the file that contains all the details about the indicators. This has been done previously, but as a reminder, we can get it by running <strong class="source-inline">series = pd.read_csv('data/PovStatsSeries.csv')</strong>. Let's now implement these steps:</p>
			<ol>
				<li value="1">Right under the <strong class="source-inline">Graph</strong> component, add the new <strong class="source-inline">Markdown</strong> component (note that we <a id="_idIndexMarker411"/>also set its background color to be consistent with the map, as well as the whole app). The <strong class="source-inline">_md</strong> suffix is for <strong class="source-inline">Markdown</strong>: <p class="source-code">dcc.Markdown(id='indicator_map_details_md',</p><p class="source-code">             style={'backgroundColor': '#E5ECF6'})</p></li>
				<li>Update the callback function by including the new component: <p class="source-code">@app.callback(Output('indicator_map_chart', 'figure'),</p><p class="source-code">              <strong class="bold">Output('indicator_map_details_md', 'children')</strong>,</p><p class="source-code">              Input('indicator_dropdown', 'value'))</p></li>
				<li>After finishing the definition of the <strong class="source-inline">fig</strong> variable in the callback function, we now run the necessary steps for creating the <strong class="source-inline">Markdown</strong> output. Create the appropriate subset of <strong class="source-inline">series</strong>, by getting the row where the <strong class="source-inline">Indicator Name</strong> column is equal to the selected indicator:<p class="source-code">series_df =\</p><p class="source-code">series[series['Indicator Name'].eq(indicator)]</p></li>
				<li>Extract the value of the <strong class="source-inline">Limitations and exceptions</strong> columns from <strong class="source-inline">series_df</strong>. Note that since some values are missing and since missing values are not strings, we fill them with the string <strong class="source-inline">N/A</strong>, and we also replace any instances of two newline characters, <strong class="source-inline">\n\n</strong>, with a single space, if any. We then extract the first element under its <strong class="source-inline">values</strong> attribute:<p class="source-code">limitations =series_df['Limitations and\</p><p class="source-code">exceptions'].fillna('N/A').str.replace('\n\n',\</p><p class="source-code">' ').values[0]</p></li>
				<li>Now that we have defined two variables, <strong class="source-inline">series_df</strong> and <strong class="source-inline">limitations</strong>, we will use Python's f-string formatting to insert variables where they belong using curly braces: f'<strong class="source-inline">{&lt;variable_name&gt;}'</strong>. We first insert the indicator name using an <strong class="source-inline">&lt;h2&gt;</strong> element. Headings in Markdown correspond to their HTML equivalents, where the number <a id="_idIndexMarker412"/>of hash signs corresponds to the heading level. Here we use two signs for <strong class="source-inline">&lt;h2&gt;</strong>:<p class="source-code">## {series_df['Indicator Name'].values[0]}  </p></li>
				<li>Now we add the long description in regular text, without any hash signs before it: <p class="source-code">{series_df['Long definition'].values[0]}</p></li>
				<li>Next, we add the bullet points for <strong class="source-inline">Unit of measure</strong>, <strong class="source-inline">Periodicity</strong>, and <strong class="source-inline">Source</strong>. Bullet points can be created by adding a star at the beginning of the line for each bullet point. This is a simple process of getting the right element from the right column. Note that we fill missing values for <strong class="source-inline">Unit of measure</strong> by using the word <strong class="source-inline">count</strong>, which will replace the missing values where the indicator is a simple count and not a percentage. Population is one such example. In the case of <strong class="source-inline">Periodicity</strong>, we simply replace it with <strong class="source-inline">N/A</strong> wherever the respective value is missing. The stars before and after any text make it bold, similar to running <strong class="source-inline">&lt;b&gt;text&lt;/b&gt;</strong>:<p class="source-code">* **Unit of measure** {series_df['\</p><p class="source-code">Unit of measure'].fillna('count').values[0]}</p><p class="source-code">* **Periodicity**\</p><p class="source-code">{series_df['Periodicity'].fillna('N/A').values[0]}</p><p class="source-code">* **Source** {series_df['Source'].values[0]}</p></li>
				<li>Add the <strong class="source-inline">Limitations and exceptions</strong> subtitle in <strong class="source-inline">&lt;h3&gt;</strong>:<p class="source-code">### Limitations and exceptions:  </p></li>
				<li>Next, we <a id="_idIndexMarker413"/>add the already created <strong class="source-inline">limitations</strong> variable in regular text:<p class="source-code">{limitations}  </p></li>
			</ol>
			<p>Putting the preceding code together, here is the full code that creates our <strong class="source-inline">Markdown</strong> component, with its relative position in the callback function. Note that in some cases, there are <a id="_idIndexMarker414"/>a few indicators that don't have details in the <strong class="source-inline">series</strong> DataFrame. In this case, we set the <strong class="source-inline">Markdown</strong> variable to a string, indicating the lack of such details. This condition can be seen in the following code as well, in the check to <strong class="source-inline">series_df.empty</strong>; otherwise, everything runs as previously:</p>
			<p class="source-code">…</p>
			<p class="source-code">fig.layout.coloraxis.colorbar.title =\</p>
			<p class="source-code">multiline_indicator(indicator)</p>
			<p class="source-code"><strong class="bold">series_df = series[series['Indicator Name'].eq(indicator)]</strong></p>
			<p class="source-code"><strong class="bold">if series_df.empty:</strong></p>
			<p class="source-code"><strong class="bold">    markdown = "No details available on this indicator"</strong></p>
			<p class="source-code"><strong class="bold">else:</strong></p>
			<p class="source-code"><strong class="bold">    limitations = series_df['Limitations and exceptions'].fillna('N/A').str.replace('\n\n', ' ').values[0]</strong></p>
			<p class="source-code"><strong class="bold">    markdown = f"""</strong></p>
			<p class="source-code"><strong class="bold">    ## {series_df['Indicator Name'].values[0]}  </strong></p>
			<p class="source-code"><strong class="bold">    {series_df['Long definition'].values[0]}  </strong></p>
			<p class="source-code"><strong class="bold">    * **Unit of measure** {series_df['Unit of measure'].fillna('count').values[0]}</strong></p>
			<p class="source-code"><strong class="bold">    * **Periodicity**</strong></p>
			<p class="source-code"><strong class="bold">{series_df['Periodicity'].fillna('N/A').values[0]}</strong></p>
			<p class="source-code"><strong class="bold">    * **Source** {series_df['Source'].values[0]}</strong></p>
			<p class="source-code"><strong class="bold">    ### Limitations and exceptions:  </strong></p>
			<p class="source-code"><strong class="bold">    {limitations}</strong></p>
			<p class="source-code"><strong class="bold">"""</strong></p>
			<p class="source-code">return fig, markdown</p>
			<p>We finally return a tuple of <strong class="source-inline">fig, markdown</strong> instead of only <strong class="source-inline">fig</strong> as we did in the previous version. Adding <a id="_idIndexMarker415"/>this code to the app would add the respective Markdown to the map and give it much better context, as well as pointing out the limitations that our users need to keep in mind.</p>
			<p>We will now turn to see the different projections that maps can be displayed in, and how we can change them.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Understanding map projections</h1>
			<p>We used an example of one projection type in our map, and now we'll explore this topic in more detail. When we <a id="_idIndexMarker416"/>try to draw the Earth (or part of it) on a flat rectangle, the shape is inevitably distorted somehow. So, there are different ways, or projections, available that can be used. No projection is perfect, and there are trade-offs between accuracy in shape, area, relative position, and so on. The details of which projection is more appropriate depends on the application and is beyond the scope of this book. We will, however, explore how to change the projection being used and see how to get the available projections.</p>
			<p>With Plotly Express, we have a <strong class="source-inline">projection</strong> parameter in the map functions, which takes a string and can be used to set the desired projection type. Alternatively, we can also set it by assigning a value to <strong class="source-inline">fig.layout.geo.projection.type</strong> as we did previously.</p>
			<p><em class="italic">Figure 7.9</em> shows a few of the available options together with their respective names in the titles:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B16780_07_9.jpg" alt="Figure 7.9 – A sample of the available map projections"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – A sample of the available map projections</p>
			<p>As you can see, there are different ways of displaying the Earth. While <strong class="bold">orthographic</strong> might seem <a id="_idIndexMarker417"/>more realistic in its shape, its problem is that we can only see part of the Earth, so we lose perspective. The <strong class="bold">azimuthal equal area</strong> projection is actually quite realistic when you use it interactively and zoom into certain areas. Feel free to experiment with different projections and select what works for you.</p>
			<p>We have experimented with polygon or choropleth maps so far, and now we will be exploring another type of map, with which we are already generally familiar: the scatter map.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Using scatter map plots</h1>
			<p>The main <a id="_idIndexMarker418"/>difference between the <em class="italic">x</em> and <em class="italic">y</em> axes and longitude and latitude is due to the shape of the Earth. As we approach the equator, the vertical meridians are as far away from each other as possible, and as we approach the North and South poles, they are as close as possible to each other. <em class="italic">Figure 7.10</em> shows this: </p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B16780_07_10.jpg" alt="Figure 7.10 – A map of the Earth, showing longitude and latitude lines"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – A map of the Earth, showing longitude and latitude lines</p>
			<p>In other words, as we approach the equator, we have a more rectangular shape, because a unit of longitude is close to a unit of latitude. Close to the poles, the proportions are completely different, and the rectangles start to approximate triangles. This is in <a id="_idIndexMarker419"/>contrast to a rectangular plane, where a vertical unit of distance corresponds to the same horizontal unit of distance, regardless of where you are on the plane. This assumes a linear scale on both axes, of course. An exception to this is the logarithmic axis, which we covered in <a href="B16780_06_Final_NM_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Variables with Scatter Plots and Filtering Subsets with Sliders</em>. Map projections handle this for us, and we don't have to worry about this issue. So, we can simply think of them as we think about the <em class="italic">x</em> and <em class="italic">y</em> axes and select the projection that we want.</p>
			<p>Let's see how we can make a scatter map plot with Plotly Express using the <strong class="source-inline">scatter_geo</strong> function.</p>
			<p>We start with a very simple example:</p>
			<p class="source-code">df =\</p>
			<p class="source-code">poverty[poverty['year'].eq(2010) &amp; poverty['is_country']]</p>
			<p class="source-code">px.scatter_geo(df, locations='Country Code')</p>
			<p>First, we created <strong class="source-inline">df</strong>, where the year is equal to 2010, and we filtered out non-countries. Then, just like we did with choropleth maps, we selected the column to use for the <strong class="source-inline">locations</strong> parameter. This generates the simple chart in <em class="italic">Figure 7.11</em>: </p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B16780_07_11.jpg" alt="Figure 7.11 – A scatter map using the scatter_geo function"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – A scatter map using the scatter_geo function</p>
			<p>You can <a id="_idIndexMarker420"/>see how easy it is to do so. There is not much information in this chart, other than markers on countries, showing the <strong class="bold">Country Code</strong> value.</p>
			<p>The country names are supported by default by Plotly. Another interesting application might be to use the <strong class="source-inline">lat</strong> and <strong class="source-inline">lon</strong> parameters to plot arbitrary locations on the map, as you can see in the following code and <em class="italic">Figure 7.12</em>:</p>
			<p class="source-code">px.scatter_geo(lon=[10, 12, 15, 18], lat=[23, 28, 31, 40])</p>
			<p>This results in the following output:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B16780_07_12.jpg" alt="Figure 7.12 – A scatter map using latitude and longitude data"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – A scatter map using latitude and longitude data</p>
			<p>You can <a id="_idIndexMarker421"/>easily apply the concepts we covered in <a href="B16780_06_Final_NM_ePub.xhtml#_idTextAnchor090"><em class="italic">Chapter 6</em></a>, <em class="italic">Explore Exploring Variables with Scatter Plots and Filtering Subsets with Sliders</em>, to modify the size and map colors, set the opacity, and so on.</p>
			<p>We will now explore these options by introducing another richer way of producing maps, using Mapbox.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Exploring Mapbox maps</h1>
			<p>Mapbox is an open source library for maps. It is backed by a company with the same name that <a id="_idIndexMarker422"/>also provides additional services, layers, and themes to produce rich mapping applications. The options we will be using here can be used immediately with Plotly, but there are some other styles and services that require you to register for an account and use a token every time you generate a map. </p>
			<p>An example should make it easy to start with, as we are already very familiar with scatter plots: </p>
			<p class="source-code">px.scatter_mapbox(lon=[5, 10, 15, 20],</p>
			<p class="source-code">                  lat=[10, 7, 18, 5],</p>
			<p class="source-code">                  <strong class="bold">zoom=2</strong>,</p>
			<p class="source-code">                  <strong class="bold">center={'lon': 5, 'lat': 10}</strong>,</p>
			<p class="source-code">                  size=[5]*4,</p>
			<p class="source-code">                  color_discrete_sequence=['darkred'],</p>
			<p class="source-code">                  <strong class="bold">mapbox_style='stamen-watercolor'</strong>)</p>
			<p>The preceding code should be straightforward. The <strong class="source-inline">lon</strong> and <strong class="source-inline">lat</strong> parameters are the equivalents <a id="_idIndexMarker423"/>of the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> parameters for scatter plots. The <strong class="source-inline">size</strong> and <strong class="source-inline">color_discrete_sequence</strong> parameters have already been covered. An interesting new parameter is the <strong class="source-inline">zoom</strong> parameter, which we set to <strong class="source-inline">2</strong> here. This can take an integer value from <strong class="source-inline">0</strong> (the whole world) to <strong class="source-inline">22</strong> (building-level zoom), inclusive. We can also see how easy it is to set the center of a map, which we did using the first point's coordinates (5, 10). Finally, the <strong class="source-inline">mapbox_style</strong> parameter provides a set of interesting options to display maps in different styles. The <strong class="source-inline">stamen-watercolor</strong> style gives it an artistic look and can be seen in <em class="italic">Figure 7.13</em>:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B16780_07_13.jpg" alt="Figure 7.13 – A scatter map using Mapbox and a custom style"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – A scatter map using Mapbox and a custom style</p>
			<p>Hovering over the <strong class="bold">i</strong> on the map displays the sources of the tiles and data. As you can see, there are so many layers and work condensed into this simple function. Let's now use the same approach to plot some data from our dataset.</p>
			<p>Because <strong class="source-inline">scatter_mapbox</strong> mainly works with latitude and longitude data, and our dataset does not include any such data about the countries, we will obtain the data, merge it, and then plot the markers where they belong. </p>
			<p>There are <a id="_idIndexMarker424"/>many sources for such data, and a quick online search will lead to some good sources. We can use the pandas <strong class="source-inline">read_html</strong> function for that. It takes a URL, downloads all the <strong class="source-inline">&lt;table&gt;</strong> elements at that URL, and returns a list of DataFrame objects. We simply have to take the one that we want. In this case, it is the first one. The following code achieves this, and creates the <strong class="source-inline">lat_long</strong> variable, which is a DataFrame:</p>
			<p class="source-code">lat_long =\</p>
			<p class="source-code">pd.read_html('https://developers.google.com/public-data/docs/canonical/countries_csv')[0]</p>
			<p>If you remember our discussion in <a href="B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Manipulation and Preparation - Paving the Way to Plotly Express</em>, where we went through several data manipulation operations, we will utilize the <strong class="source-inline">merge</strong> function from <strong class="source-inline">pandas</strong> to merge <strong class="source-inline">lat_long</strong> into <strong class="source-inline">poverty</strong> using a left merge operation.</p>
			<p>We first take a look at the structure of the <strong class="source-inline">lat_long</strong> DataFrame by simply printing it in JupyterLab, and you can see the top and bottom five rows in <em class="italic">Figure 7.14</em>:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B16780_07_14.jpg" alt="Figure 7.14 – The lat_long DataFrame containing latitude and longitude data for countries"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – The lat_long DataFrame containing latitude and longitude data for countries</p>
			<p>The <strong class="bold">country</strong> column contains country codes using two letters for each. The <strong class="source-inline">poverty</strong> DataFrame <a id="_idIndexMarker425"/>also has a column called <strong class="source-inline">2-alpha code</strong>, which contains country codes using the same two-letter standard, so we merge using those columns as follows:</p>
			<p class="source-code">poverty = pd.merge(left=poverty, right=lat_long, how='left',</p>
			<p class="source-code">                   <strong class="bold">left_on='2-alpha code', right_on='country'</strong>)</p>
			<p>This will add the columns of <strong class="source-inline">lat_long</strong> to <strong class="source-inline">poverty</strong>, aligning the rows where they belong, as well as duplicating them where necessary. Remember, we are merging using the <strong class="source-inline">left</strong> method, which means the <strong class="source-inline">left</strong> argument is the basis for the merge. You can see a random sample of rows together with the important columns after merging in <em class="italic">Figure 7.15</em> to make it clear:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B16780_07_15.jpg" alt="Figure 7.15 – A subset of the poverty DataFrame merged with lat_long"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – A subset of the poverty DataFrame merged with lat_long</p>
			<p>Note that in the case where we didn't have values for the longitude and latitude, we have <strong class="bold">NaN</strong>. In the cases where the same country name exists, for example, <strong class="bold">Tajikistan</strong>, the longitude and latitude values are simply duplicated, to keep the mapping of those values to their respective country, regardless of which rows we choose.</p>
			<p>We are now <a id="_idIndexMarker426"/>ready to create a bubble chart (a scatter plot with the marker sizes reflecting a certain quantity). We just have to create a subset of <strong class="source-inline">poverty</strong> that contains only countries and removes any missing values for the required indicator, <strong class="source-inline">Population, total</strong>, in this case. This can be done with the following code: </p>
			<p class="source-code">df =\</p>
			<p class="source-code">poverty[poverty['is_country']].dropna(subset=['Population, total'])</p>
			<p>Creating a bubble chart requires you call to the <strong class="source-inline">scatter_mapbox</strong> function, but we will go through the given arguments one by one: </p>
			<ol>
				<li value="1">Call the function with the subset just created: <p class="source-code">px.scatter_mapbox(df, …)</p></li>
				<li>Select the columns that will be used for the longitude and latitude values:<p class="source-code">lon='longitude', lat='latitude'</p></li>
				<li>Set the desired zoom level, to show the whole Earth: <p class="source-code">zoom=1</p></li>
				<li>Map the value of the indicator to the size of the markers and set a suitable maximum size:<p class="source-code">size='Population, total', size_max=80</p></li>
				<li>Map the income group that the respective country belongs to, to the color of the marker (discrete variables in this case):<p class="source-code">color='Income Group'</p></li>
				<li>Choose the <strong class="source-inline">year</strong> column as the one used to animate the chart: <p class="source-code">animation_frame='year'</p></li>
				<li>Set a <a id="_idIndexMarker427"/>suitable opacity level, because we will definitely have overlapping markers:<p class="source-code">opacity=0.7</p></li>
				<li>Set a suitable height for the figure as a whole, in pixels:<p class="source-code">height=650</p></li>
				<li>Add more information to the hover box, by including two more columns' data to appear when users hover over markers: <p class="source-code">hover_data=['Income Group', 'Region']</p></li>
				<li>Select a custom color sequence to differentiate the income groups that the countries belong to: <p class="source-code">color_discrete_sequence=px.colors.qualitative.G10</p></li>
				<li>Set a custom style for the map: <p class="source-code">mapbox_style='stamen-toner'</p></li>
				<li>Set a title for the hover box, using the country name:<p class="source-code">hover_name=df['Country Name']</p></li>
				<li>Set a title for the figure: <p class="source-code">title="Population by Country"</p></li>
			</ol>
			<p>Running the preceding code produces the interactive chart in <em class="italic">Figure 7.16</em>:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B16780_07_16.jpg" alt="Figure 7.16 – A scatter_mapbox bubble chart for population by country using years as animation frames"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – A scatter_mapbox bubble chart for population by country using years as animation frames</p>
			<p>Here is <a id="_idIndexMarker428"/>the full code that we just discussed to make it clear: </p>
			<p class="source-code">px.scatter_mapbox(df,</p>
			<p class="source-code">                  lon='longitude',</p>
			<p class="source-code">                  lat='latitude',</p>
			<p class="source-code">                  zoom=1,</p>
			<p class="source-code">                  size='Population, total',</p>
			<p class="source-code">                  size_max=80,</p>
			<p class="source-code">                  color='Income Group',</p>
			<p class="source-code">                  animation_frame='year',</p>
			<p class="source-code">                  opacity=0.7,</p>
			<p class="source-code">                  height=650,</p>
			<p class="source-code">                  hover_data=['Income Group', 'Region'],</p>
			<p class="source-code">                  color_discrete_sequence=px.colors.qualitative.G10,</p>
			<p class="source-code">                  mapbox_style='stamen-toner',</p>
			<p class="source-code">                  hover_name=df['Country Name'],</p>
			<p class="source-code">                  title='Population by Country')</p>
			<p>You can see how straightforward it is to set all the options, and how little code is involved. We only have to know the options and how they work. </p>
			<p>Because this <a id="_idIndexMarker429"/>is an interactive chart, and users can zoom in and out, it is easy to handle the overlaps that we have, simply by zooming in one level. <em class="italic">Figure 7.17</em> shows the same chart after zooming (by the user):</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B16780_07_17.jpg" alt="Figure 7.17 – A scatter_mapbox chart zoomed in for a better view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.17 – A scatter_mapbox chart zoomed in for a better view</p>
			<p>One advantage of bubble charts over choropleth charts is that they show how the value relates to the geographic area of the country (or any location) visualized. For example, <em class="italic">Figure 7.16</em> shows three interesting cases of Canada, Russia, and Australia, which seem to have a population that is relatively small compared to their area. In other words, their population density is low. This gives more perspective on this metric.</p>
			<p>As you can see, there are so many options and ways to display and interact with maps, and we have barely scratched the surface of what can be done. We will now take a look at a few other options that are available, in case you are interested in learning more.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>Exploring other map options and tools</h1>
			<p>The following are a few pointers on what you can explore further with mapping, without getting into too much detail.</p>
			<p>You've probably <a id="_idIndexMarker430"/>thought about having custom polygons or areas to visualize as choropleth maps. What we have covered so far are standard countries only. Of course, you have the option of visualizing a custom area with arbitrary points.</p>
			<p>There is a standard GeoJSON format for representing such information. It mainly consists of points, lines, and polygons. Points are simply locations on the map, similar to what we used for scatter map plots. Lines are groups of connected points, in a certain sequence, where the first and last points are not the same. And as you can guess, a polygon is similar to a line, but with the condition that the first and last points are the same. Note that many countries consist of more than one polygon. Most Plotly map functions support GeoJSON, and you can use it for custom map plotting.</p>
			<p>This can be useful when you have custom data for custom locations and you need to obtain the relevant data.</p>
			<p>Another important and useful project to consider learning about is <strong class="source-inline">geopandas</strong>. As the name clearly suggests, it is a specialized library that works like <strong class="source-inline">pandas</strong>, and provides special data structures and techniques for geographic data, most notably <strong class="source-inline">GeoDataFrame</strong>. It is worth learning if you have more specialized mapping requirements, or if you frequently need to customize maps further.</p>
			<p>Let's now add the functionality we created to the app.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Incorporating an interactive map into our app</h1>
			<p>The map that we created, together with the <strong class="source-inline">Dropdown</strong> and <strong class="source-inline">Markdown</strong> components, can <a id="_idIndexMarker431"/>become the first exploratory tool in our app. We can remove the population bar chart now, and in its place, we can place the components we just created, for users to explore all the indicators, see them on the map, and scroll through the years, and for each indicator, get the full details, as well as seeing the limitations and potential issues. Once something catches the user's eye, they can then find another chart that gives more detail about the indicator they want if it exists.</p>
			<p>In order <a id="_idIndexMarker432"/>to fully incorporate the new functionality into our app, we need to go through the following steps:</p>
			<ol>
				<li value="1">Add the definition of <strong class="source-inline">series</strong> at the top of the <strong class="source-inline">app.py</strong> module:<p class="source-code">series = pd.read_csv('data/PovStatsSeries.csv')</p></li>
				<li>Add the definition of the <strong class="source-inline">multiline_indicator</strong> function, anywhere before <strong class="source-inline">app.layout</strong>:<p class="source-code">def multiline_indicator(indicator):</p><p class="source-code">    final = []</p><p class="source-code">    split = indicator.split()</p><p class="source-code">    for i in range(0, len(split), 3):</p><p class="source-code">        final.append(' '.join(split[i:i+3]))</p><p class="source-code">    return '&lt;br&gt;'.join(final)</p></li>
				<li>Add the <strong class="source-inline">Dropdown</strong>, <strong class="source-inline">Graph</strong>, and <strong class="source-inline">Markdown</strong> components at the top of the app, right under the top headings, where we previously had the population bar chart. The following code shows how, including the component IDs to make it clear, but the full definitions have been omitted. Note also the addition of a <strong class="source-inline">Col</strong> component as well as setting the width of another <strong class="source-inline">Col</strong> component, both using the <strong class="source-inline">lg</strong> (large) parameter. The first one introduces an empty column before displaying the content, and the second controls the width of the content in this column:<p class="source-code">app.layout = html.Div([</p><p class="source-code">    dbc.Col([</p><p class="source-code">        html.Br(),</p><p class="source-code">        html.H1('Poverty And Equity Database'),</p><p class="source-code">        html.H2('The World Bank'),</p><p class="source-code">    ], style={'textAlign': 'center'}),</p><p class="source-code">    html.Br(),</p><p class="source-code">    dbc.Row([</p><p class="source-code">        <strong class="bold">dbc.Col(lg=2)</strong>,</p><p class="source-code">        dbc.Col([</p><p class="source-code">            dcc.Dropdown(id='indicator_dropdown', ...),</p><p class="source-code">            dcc.Graph(id='indicator_map_chart', ...),</p><p class="source-code">            dcc.Markdown(id='indicator_map_details_md', ...)</p><p class="source-code">    ], <strong class="bold">lg=8</strong>)</p><p class="source-code">    ]),</p><p class="source-code">    html.Br()</p></li>
			</ol>
			<p>We have <a id="_idIndexMarker433"/>explored several new options in this chapter, so let's summarize what we did.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Summary</h1>
			<p>We started by exploring how to create choropleth maps, which are a type of map that we are all used to seeing. We also saw how to animate those maps if we have a sequential value, which in our case was viewing a certain indicator as it progressed throughout the available years. We then created a callback function and made the maps work with all the possible indicators that we have, so users could explore them all and then decide what they wanted to explore next.</p>
			<p>After that, we learned how to use Markdown to generate HTML content, and how to add it to a Dash app. We then explored the different ways of displaying maps, or projections, and saw how to select the projection that we want.</p>
			<p>We went through another type of map, which is a scatter map plot. Building on the knowledge we established in the previous chapter, it was fairly straightforward to adapt that knowledge to scatter maps. We also learned about the rich options that Mapbox provides and explored a few other topics for further exploration with maps. Finally, we integrated the new functionality into our app, which now contains a lot of explanatory text about almost all of the indicators, so users have a much better view of what they are analyzing.</p>
			<p>In the next chapter, we will tackle a different type of chart, one that helps in counting values and showing how they are distributed in our dataset, the <strong class="bold">histogram</strong>. We will also explore a new component, the Dash <strong class="bold">DataTable</strong>, which allows us to display tabular data in a rich way, with many options to filter, visualize, download, and more.</p>
		</div>
	</body></html>