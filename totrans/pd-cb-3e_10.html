<html><head></head><body>
  <div id="_idContainer126" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-262" class="chapterTitle">General Usage and Performance Tips</h1>
    <p class="normal">At this point in the book, we have covered a rather large part of the pandas library while walking through sample applications to reinforce good usage. Equipped with all of this knowledge, you are now well prepared to step into the real world and start applying everything you have learned to your data analysis problems.</p>
    <p class="normal">This chapter will offer some tips and tricks you should keep in mind as you go out on your own. The recipes presented in this chapter are common mistakes I see by pandas users of all experience levels. While well-intentioned, improper usage of pandas constructs can leave a lot of performance on the table. When your datasets are smaller in size that may not be a big issue, but data has the tendency to grow, not to retreat in size. Using proper idioms and avoiding the maintenance burden of inefficient code can yield significant time and money savings for your organization.</p>
    <p class="normal">We are going to cover the following recipes in this chapter:</p>
    <ul>
      <li class="bulletList">Avoid <code class="inlineCode">dtype=object</code></li>
      <li class="bulletList">Be cognizant of data sizes</li>
      <li class="bulletList">Use vectorized functions instead of loops</li>
      <li class="bulletList">Avoid mutating data</li>
      <li class="bulletList">Dictionary-encode low cardinality data</li>
      <li class="bulletList">Test-driven development features</li>
    </ul>
    <h1 id="_idParaDest-263" class="heading-1">Avoid dtype=object</h1>
    <p class="normal">Using <code class="inlineCode">dtype=object</code> to store strings is one of the most<a id="_idIndexMarker525"/> error-prone and inefficient things you can do in pandas. Unfortunately, for the longest time, <code class="inlineCode">dtype=object</code> was the only way to work with string data; this wasn’t “solved” until the 1.0 release.</p>
    <p class="normal">I intentionally put “solved” in quotes because, while pandas 1.0 did introduce the <code class="inlineCode">pd.StringDtype()</code>, it was not used by default by many construction and I/O methods until the 3.0 release. In effect, unless you told pandas otherwise, you would end up with <code class="inlineCode">dtype=object</code> for all your string data in the 2.x series. For what it’s worth, the <code class="inlineCode">pd.StringDtype()</code> that was<a id="_idIndexMarker526"/> introduced in 1.0 helped to assert you <em class="italic">only</em> stored strings, but it was never optimized for performance until the pandas 3.0 release.</p>
    <p class="normal">If you are using the 3.0 release of pandas and beyond, chances are you will still come across legacy code that reads like <code class="inlineCode">ser = ser.astype(object)</code>. More often than not, such calls should be replaced with <code class="inlineCode">ser = ser.astype(pd.StringDtype())</code>, unless you truly do need to store Python objects in a <code class="inlineCode">pd.Series</code>. Unfortunately, there is no true way to know the intent, so you as a developer should be aware of the pitfalls of using <code class="inlineCode">dtype=object</code> and how to identify if it can suitably be replaced with the <code class="inlineCode">pd.StringDtype()</code>.</p>
    <h2 id="_idParaDest-264" class="heading-2">How to do it</h2>
    <p class="normal">We already covered some of the issues with using <code class="inlineCode">dtype=object</code> back in <em class="chapterRef">Chapter 3</em>, <em class="italic">Data Types,</em> but it is worth restating and expanding upon some of those issues here.</p>
    <p class="normal">For an easy comparison, let’s create two <code class="inlineCode">pd.Series</code> objects with identical data, where one uses the <code class="inlineCode">object </code>data type and the other uses the <code class="inlineCode">pd.StringDtype</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser_obj = pd.Series(["foo", "bar", "baz"] * <span class="hljs-number">10_000</span>, dtype=<span class="hljs-built_in">object</span>)
ser_str = pd.Series(["foo", "bar", "baz"] * <span class="hljs-number">10_000</span>, dtype=pd.StringDtype())
</code></code></pre>
    <p class="normal">Attempting to assign a non-string value to <code class="inlineCode">ser_str</code> will fail:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser_str.iloc[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">TypeError: Cannot set non-string value 'False' into a StringArray.
</code></code></pre>
    <p class="normal">By contrast, the object-typed <code class="inlineCode">pd.Series</code> will gladly accept our <code class="inlineCode">Boolean</code> value:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser_obj.iloc[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>
</code></code></pre>
    <p class="normal">In turn, this just ends up obfuscating where issues with your data may occur. With <code class="inlineCode">pd.StringDtype</code>, the point of failure was very obvious when we tried to assign non-string data. With the object<a id="_idIndexMarker527"/> data type, you may not discover there is a problem until later in your code, when you try some string operation like capitalization:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser_obj.<span class="hljs-built_in">str</span>.capitalize().head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    NaN
1    Bar
2    Baz
3    Foo
4    Bar
dtype: object
</code></code></pre>
    <p class="normal">Instead of raising an error, pandas just decided to set our <code class="inlineCode">False</code> entry in the first row to a missing value. Odds are just silently setting things to missing values like that is not the behavior you wanted, but with the object data type, you lose a lot of control over your data quality.</p>
    <p class="normal">If you are working with pandas 3.0 and beyond, you will also see that, when PyArrow is installed, <code class="inlineCode">pd.StringDtype</code> becomes significantly faster. Let’s recreate our <code class="inlineCode">pd.Series</code> objects to measure this:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser_obj = pd.Series(["foo", "bar", "baz"] * <span class="hljs-number">10_000</span>, dtype=<span class="hljs-built_in">object</span>)
ser_str = pd.Series(["foo", "bar", "baz"] * <span class="hljs-number">10_000</span>, dtype=pd.StringDtype())
</code></code></pre>
    <p class="normal">For a quick timing comparison, let’s use the <code class="inlineCode">timeit</code> module, built into the standard library:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> timeit
timeit.timeit(ser_obj.<span class="hljs-built_in">str</span>.upper, number=<span class="hljs-number">1000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2.2286621460007154
</code></code></pre>
    <p class="normal">Compare that runtime to the same values but with the proper <code class="inlineCode">pd.StringDtype</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">timeit.timeit(ser_str.<span class="hljs-built_in">str</span>.upper, number=<span class="hljs-number">1000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2.7227514309997787
</code></code></pre>
    <p class="normal">Unfortunately, users prior to the 3.0 release will not see any performance difference, but the data validation alone is worth it to move away from <code class="inlineCode">dtype=object</code>.</p>
    <p class="normal">So what is the easiest way to avoid <code class="inlineCode">dtype=object</code>? If you are fortunate enough to be working with the 3.0 release<a id="_idIndexMarker528"/> and beyond of pandas, you will naturally not run into this data type as often, as a natural evolution in the library. Even still, and for users that may still be using the pandas 2.x series, I advise using the <code class="inlineCode">dtype_backend="numpy_nullable"</code> argument with I/O methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> io
data = io.StringIO("int_col,string_col\n0,foo\n1,bar\n2,baz")
data.seek(<span class="hljs-number">0</span>)
pd.read_csv(data, dtype_backend="numpy_nullable").dtypes
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">int_col                Int64
string_col    string[python]
dtype: object
</code></code></pre>
    <p class="normal">If you are constructing a <code class="inlineCode">pd.DataFrame</code> by hand, you can use <code class="inlineCode">pd.DataFrame.convert_dtypes</code> paired with the same <code class="inlineCode">dtype_backend="numpy_nullable"</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    [<span class="hljs-number">0</span>, "foo"],
    [<span class="hljs-number">1</span>, "bar"],
    [<span class="hljs-number">2</span>, "baz"],
], columns=["int_col", "string_col"])
df.convert_dtypes(dtype_backend="numpy_nullable").dtypes
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">int_col                Int64
string_col    string[python]
dtype: object
</code></code></pre>
    <p class="normal">Please note that the <code class="inlineCode">numpy_nullable</code> term is a bit of a misnomer. The argument would have probably been better named <code class="inlineCode">pandas_nullable</code> or even just <code class="inlineCode">pandas</code> or <code class="inlineCode">nullable</code>, but when it was first introduced, it was strongly tied to the NumPy system still. Over time, the term <code class="inlineCode">numpy_nullable</code> stuck, but the types moved away from using NumPy. Beyond the publication of this book, there may be a more suitable value to use to get the same behavior, which essentially asks for optimal data types in pandas that can support missing values.</p>
    <p class="normal">While using <code class="inlineCode">dtype=object</code> is most commonly <em class="italic">misused</em> for strings, it also exposes some rough edges with <a id="_idIndexMarker529"/>datetimes. I commonly see code like this from new users trying to create what they think is a <code class="inlineCode">pd.Series</code> of dates:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> datetime
ser = pd.Series([
    datetime.date(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),
    datetime.date(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
    datetime.date(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>),
])
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    2024-01-01
1    2024-01-02
2    2024-01-03
dtype: object
</code></code></pre>
    <p class="normal">While this is a logical way to try and accomplish the task at hand, the problem is that pandas does not have a true <em class="italic">date</em> type. Instead, these get stored in an <code class="inlineCode">object</code> data type array using the <code class="inlineCode">datetime.date</code> type from the Python standard library. This rather unfortunate usage of Python objects obfuscates the fact that you are trying to work with dates, and subsequently trying to use the <code class="inlineCode">pd.Series.dt</code> accessor will throw an error:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.dt.year
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">AttributeError: Can only use .dt accessor with datetimelike values
</code></code></pre>
    <p class="normal">Back in <em class="chapterRef">Chapter 3</em>, <em class="italic">Data Types</em>, we talked briefly about the PyArrow <code class="inlineCode">date32</code> type, which would be a more native solution to this problem:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> datetime
ser = pd.Series([
    datetime.date(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),
    datetime.date(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
    datetime.date(<span class="hljs-number">2024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>),
], dtype=pd.ArrowDtype(pa.date32()))
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    2024-01-01
1    2024-01-02
2    2024-01-03
dtype: date32[day][pyarrow]
</code></code></pre>
    <p class="normal">This will then unlock the <code class="inlineCode">pd.Series.dt</code> attributes for use:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.dt.year
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    2024
1    2024
2    2024
dtype: int64[pyarrow]
</code></code></pre>
    <p class="normal">I find this nuance rather unfortunate and hope future versions of pandas will be able to abstract these issues <a id="_idIndexMarker530"/>away, but nonetheless, they are present at the time of publication and may be for some time.</p>
    <p class="normal">In spite of all of the downsides that I have highlighted with respect to <code class="inlineCode">dtype=object</code>, it still does have its uses when dealing with messy data. Sometimes, you may not know anything about your data and just need to inspect it before making further decisions. The object data type gives you the flexibility to load essentially any data and apply the same pandas algorithms to it. While these algorithms may not be very efficient, they still give you a consistent way to interact with and explore your data, ultimately buying you time to figure out how to best cleanse it and store it in a more proper data form. For this reason, I consider <code class="inlineCode">dtype=object</code> best as a staging area – I would not advise keeping your types in it, but the fact that it buys you time to make assertions about your data types can be an asset.</p>
    <h1 id="_idParaDest-265" class="heading-1">Be cognizant of data sizes</h1>
    <p class="normal">As your datasets grow larger, you may find that you have to pick more optimal data types to ensure your <code class="inlineCode">pd.DataFrame</code> can<a id="_idIndexMarker531"/> still fit into memory.</p>
    <p class="normal">Back in <em class="chapterRef">Chapter 3</em>, <em class="italic">Data Types</em>, we discussed the<a id="_idIndexMarker532"/> different integral types and how they are a trade-off between memory usage and capacity. When dealing with untyped data sources like CSV and Excel files, pandas will err on the side of using too much memory as opposed to picking the wrong capacity. This conservative approach can lead to inefficient usage of your system’s memory, so knowing how to<a id="_idIndexMarker533"/> optimize that can make the difference between loading a file and receiving an <code class="inlineCode">OutOfMemory</code> error.</p>
    <h2 id="_idParaDest-266" class="heading-2">How to do it</h2>
    <p class="normal">To illustrate the impact of picking proper data types, let’s start with a relatively large <code class="inlineCode">pd.DataFrame</code> composed of Python integers:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame({
    "a": [<span class="hljs-number">0</span>] * <span class="hljs-number">100_000</span>,
    "b": [<span class="hljs-number">2</span> ** <span class="hljs-number">8</span>] * <span class="hljs-number">100_000</span>,
    "c": [<span class="hljs-number">2</span> ** <span class="hljs-number">16</span>] * <span class="hljs-number">100_000</span>,
    "d": [<span class="hljs-number">2</span> ** <span class="hljs-number">32</span>] * <span class="hljs-number">100_000</span>,
})
df = df.convert_dtypes(dtype_backend="numpy_nullable")
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    a    b       c          d
0   0  256  65536  4294967296
1   0  256  65536  4294967296
2   0  256  65536  4294967296
3   0  256  65536  4294967296
4   0  256  65536  4294967296
</code></code></pre>
    <p class="normal">With the integral types, determining how much memory each <code class="inlineCode">pd.Series</code> requires is a rather simple exercise. With a <code class="inlineCode">pd.Int64Dtype</code>, each record is a 64-bit integer that requires 8 bytes of memory. Alongside each record, the <code class="inlineCode">pd.Series</code> associates a single byte that is either 0 or 1, telling us if the record is missing or not. Thus, in total, we need 9 bytes for each record, and with 100,000 records per <code class="inlineCode">pd.Series</code>, our memory usage should come out to 900,000 bytes. <code class="inlineCode">pd.DataFrame.memory_usage</code> confirms that this math is correct:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.memory_usage()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Index       128
a        900000
b        900000
c        900000
d        900000
dtype: int64
</code></code></pre>
    <p class="normal">If you know what the types should be, you <a id="_idIndexMarker534"/>could explicitly pick better sizes for the <code class="inlineCode">pd.DataFrame</code> columns using <code class="inlineCode">.astype</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.assign(
    a=<span class="hljs-keyword">lambda</span> x: x["a"].astype(pd.Int8Dtype()),
    b=<span class="hljs-keyword">lambda</span> x: x["b"].astype(pd.Int16Dtype()),
    c=<span class="hljs-keyword">lambda</span> x: x["c"].astype(pd.Int32Dtype()),
).memory_usage()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Index       128
a        200000
b        300000
c        500000
d        900000
dtype: int64
</code></code></pre>
    <p class="normal">As a convenience, pandas can try and infer better sizes for you with a call <code class="inlineCode">pd.to_numeric</code>. Passing the <code class="inlineCode">downcast="signed"</code> argument will ensure that we continue to work with signed integers, and we will continue to pass <code class="inlineCode">dtype_backend="numpy_nullable"</code> to ensure we get proper missing value support:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes("number").assign(
    **{x: pd.to_numeric(
         y, downcast="signed", dtype_backend="numpy_nullable"
    ) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> df.items()}
).memory_usage()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Index       128
a        200000
b        300000
c        500000
d        900000
dtype: int64
</code></code></pre>
    <h1 id="_idParaDest-267" class="heading-1">Use vectorized functions instead of loops</h1>
    <p class="normal">Python as a language is<a id="_idIndexMarker535"/> celebrated <a id="_idIndexMarker536"/>for its looping prowess. Whether you are working with a list or a dictionary, looping over an object in Python is a relatively easy task to perform, and can allow you to write really clean, concise code.</p>
    <p class="normal">Even though pandas is a Python library, those same looping constructs are ironically an impediment to writing idiomatic, performant code. In contrast to looping, pandas offers <em class="italic">vectorized computations</em>, i.e, computations<a id="_idIndexMarker537"/> that work with all of the elements contained within a <code class="inlineCode">pd.Series</code> but which do not require you to explicitly loop.</p>
    <h2 id="_idParaDest-268" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start with a simple <code class="inlineCode">pd.Series</code> constructed from a range:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">100_000</span>), dtype=pd.Int64Dtype())
</code></code></pre>
    <p class="normal">We could use the built-in <code class="inlineCode">pd.Series.sum</code> method to easily calculate the summation:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.<span class="hljs-built_in">sum</span>()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">4999950000
</code></code></pre>
    <p class="normal">Looping over the <code class="inlineCode">pd.Series</code> and accumulating your own result will yield the same number:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">result = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ser:
    result += x
result
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">4999950000
</code></code></pre>
    <p class="normal">Yet the two code samples are nothing alike. With <code class="inlineCode">pd.Series.sum</code>, pandas performs the summation of elements in a lower-level language like C, avoiding any interaction with the Python runtime. In pandas speak, we would refer to this as a <em class="italic">vectorized</em> function.</p>
    <p class="normal">By contrast, the <code class="inlineCode">for</code> loop is handled by the Python runtime, and as you may or may not be aware, Python is a much slower language than C.</p>
    <p class="normal">To put some tangible numbers forth, we can run a simple timing benchmark using Python’s <code class="inlineCode">timeit</code> module. Let’s start with <code class="inlineCode">pd.Series.sum</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">timeit.timeit(ser.<span class="hljs-built_in">sum</span>, number=<span class="hljs-number">1000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0.04479526499926578
</code></code></pre>
    <p class="normal">Let’s compare that to the Python loop:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">loop_sum</span>():
    result = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ser:
        result += x
timeit.timeit(loop_sum, number=<span class="hljs-number">1000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">5.392715779991704
</code></code></pre>
    <p class="normal">That’s a huge slowdown with the loop!</p>
    <p class="normal">Generally, you should look to use the built-in vectorized functions of pandas for most of your analysis needs. For more complex applications, reach for the <code class="inlineCode">.agg</code>, <code class="inlineCode">.transform</code>, <code class="inlineCode">.map</code>, and <code class="inlineCode">.apply</code> methods, which <a id="_idIndexMarker538"/>were covered back in <em class="chapterRef">Chapter 5</em><em class="italic">, Algorithms and How to Apply Them</em>. You should be able to avoid using <code class="inlineCode">for</code><em class="italic"> </em>loops in 99.99% of your analyses; if you find yourself using them more often, you should rethink your design, more than likely after a thorough re-read of <em class="chapterRef">Chapter 5</em><em class="italic">, Algorithms and How to Apply Them</em>.</p>
    <p class="normal">The one exception to this rule where it may make sense to use a <code class="inlineCode">for</code><em class="italic"> </em>loop is when dealing with a <code class="inlineCode">pd.GroupBy</code> object, which can be efficiently iterated like a dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame({
    "column": ["a", "a", "b", "a", "b"],
    "value": [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>],
})
df = df.convert_dtypes(dtype_backend="numpy_nullable")
<span class="hljs-keyword">for</span> label, group <span class="hljs-keyword">in</span> df.groupby("column"):
    <span class="hljs-built_in">print</span>(f"The group <span class="hljs-keyword">for</span> label {label} <span class="hljs-keyword">is</span>:\n{group}\n")
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">The group for label a is:
 column  value
0      a      0
1      a      1
3      a      4
The group for label b is:
 column  value
2      b      2
4      b      8
</code></code></pre>
    <h1 id="_idParaDest-269" class="heading-1">Avoid mutating data</h1>
    <p class="normal">Although pandas allows you to mutate data, the cost impact of doing so varies by data type. In some cases, it <a id="_idIndexMarker539"/>can be prohibitively expensive, so<a id="_idIndexMarker540"/> you will be best served trying to minimize mutations you have to perform at all costs.</p>
    <h2 id="_idParaDest-270" class="heading-2">How to do it</h2>
    <p class="normal">When thinking about data mutation, a best effort should be made to mutate before loading into a pandas structure. We can easily illustrate a performance difference by comparing the time to mutate a record after loading it into a <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">mutate_after</span>():
    data = ["foo", "bar", "baz"]
    ser = pd.Series(data, dtype=pd.StringDtype())
    ser.iloc[<span class="hljs-number">1</span>] = "BAR"
timeit.timeit(mutate_after, number=<span class="hljs-number">1000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0.041951814011554234
</code></code></pre>
    <p class="normal">To the time it takes if the mutation was performed beforehand:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">mutate_before</span>():
    data = ["foo", "bar", "baz"]
    data[<span class="hljs-number">1</span>] = "BAR"
    ser = pd.Series(data, dtype=pd.StringDtype())
timeit.timeit(mutate_before, number=<span class="hljs-number">1000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0.019495725005981512
</code></code></pre>
    <h2 id="_idParaDest-271" class="heading-2">There’s more…</h2>
    <p class="normal">You can go down a technical rabbit hole trying to decipher the impact of mutating various data types in pandas, across all of the different versions. However, starting in pandas 3.0, the behavior started to become more consistent with the introduction of Copy-on-Write, which was proposed <a id="_idIndexMarker541"/>as part of PDEP-07. In essence, any time you try to mutate a <code class="inlineCode">pd.Series</code> or <code class="inlineCode">pd.DataFrame</code>, you end up with a copy of the original data.</p>
    <p class="normal">While this behavior is now easier to anticipate, it also means that mutations are potentially very expensive, especially if you try to mutate a large <code class="inlineCode">pd.Series</code> or <code class="inlineCode">pd.DataFrame</code>.</p>
    <h1 id="_idParaDest-272" class="heading-1">Dictionary-encode low cardinality data</h1>
    <p class="normal">Back in <em class="chapterRef">Chapter 3</em>, <em class="italic">Data Types</em>, we talked about the categorical data type, which can help to reduce memory usage by replacing occurrences of strings (or any data type really) with much smaller integral code. While <em class="italic">Chapter 3</em>,<em class="italic"> Data Types</em>, provides a good technical deep dive, it is worth restating this as a best practice here, given <a id="_idIndexMarker542"/>how significant of a saving this can represent when working with <em class="italic">low cardinality</em> data, i.e, data where the ratio of unique values to the overall record count is relatively low.</p>
    <h2 id="_idParaDest-273" class="heading-2">How to do it</h2>
    <p class="normal">Just to drive home the point<a id="_idIndexMarker543"/> about memory savings, let’s create a <em class="italic">low cardinality</em> <code class="inlineCode">pd.Series</code>. Our <code class="inlineCode">pd.Series</code> is going to have 300,000 rows of data, but only three unique values of <code class="inlineCode">"foo"</code>, <code class="inlineCode">"bar"</code>, and <code class="inlineCode">"baz"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">values = ["foo", "bar", "baz"]
ser = pd.Series(values * <span class="hljs-number">100_000</span>, dtype=pd.StringDtype())
ser.memory_usage()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2400128
</code></code></pre>
    <p class="normal">Simply changing this to a categorical data type will yield massive memory improvements:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">cat = pd.CategoricalDtype(values)
ser = pd.Series(values * <span class="hljs-number">100_000</span>, dtype=cat)
ser.memory_usage()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">300260
</code></code></pre>
    <h1 id="_idParaDest-274" class="heading-1">Test-driven development features</h1>
    <p class="normal"><strong class="keyWord">Test-driven development</strong> (or <strong class="keyWord">TDD</strong>, for short) is a popular software development practice that aims to improve <a id="_idIndexMarker544"/>code quality and maintenance. At a high level, TDD starts with a developer creating tests that describe the expected functionality of their change. The tests start in a failed state, and the developer can become confident that their implementation is correct when the tests finally pass.</p>
    <p class="normal">Tests are often the first thing code<a id="_idIndexMarker545"/> reviewers look at when considering code changes (when contributing to pandas, tests are a must!). After a change with an accompanying test has been accepted, that same test will be re-run for any subsequent code changes, ensuring that your code base continues to work as expected over time. Generally, properly constructed tests can help your code base scale out, while mitigating the risk of regressions as you develop new features.</p>
    <p class="normal">The pandas library exposes utilities that make writing tests for your <code class="inlineCode">pd.Series</code> and <code class="inlineCode">pd.DataFrame</code> objects possible through the <code class="inlineCode">pd.testing</code> module, which we will review in this recipe.</p>
    <h2 id="_idParaDest-275" class="heading-2">How it works</h2>
    <p class="normal">The Python standard library offers the <code class="inlineCode">unittest</code> module to declare and automate the execution of your tests. To create tests, you typically create a class that inherits from <code class="inlineCode">unittest.TestCase</code>, and create methods on that class that make assertions about your program behavior.</p>
    <p class="normal">In the following code sample, the <code class="inlineCode">MyTests.test_42</code> method is going to call <code class="inlineCode">unittest.TestCase.assertEqual</code> with two arguments, <code class="inlineCode">21 * 2</code> and <code class="inlineCode">42</code>. Since those arguments are logically equal, the test execution will pass:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> unittest
<span class="hljs-keyword">class</span> <span class="hljs-title">MyTests</span>(unittest.TestCase):
    <span class="hljs-keyword">def</span> <span class="hljs-title">test_42</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable">self</span>.assertEqual(<span class="hljs-number">21</span> * <span class="hljs-number">2</span>, <span class="hljs-number">42</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title">suite</span>():
    suite = unittest.TestSuite()
    suite.addTest(MyTests("test_42"))
    <span class="hljs-keyword">return</span> suite
runner = unittest.TextTestRunner()
runner.run(suite())
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">.
----------------------------------------------------------------------
Ran 1 test in 0.001s
OK
&lt;unittest.runner.TextTestResult run=1 errors=0 failures=0&gt;
</code></code></pre>
    <p class="normal">Now let’s try to follow that same execution framework with pandas, but instead of comparing <code class="inlineCode">21 * 2</code> to <code class="inlineCode">42</code>, we <a id="_idIndexMarker546"/>are going to try and compare two <code class="inlineCode">pd.Series</code> objects:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">some_cool_numbers</span>():
    <span class="hljs-keyword">return</span> pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int64Dtype())
<span class="hljs-keyword">class</span> <span class="hljs-title">MyTests</span>(unittest.TestCase):
    <span class="hljs-keyword">def</span> <span class="hljs-title">test_cool_numbers</span>(<span class="hljs-params">self</span>):
        result = some_cool_numbers()
        expected = pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int64Dtype())
        <span class="hljs-variable">self</span>.assertEqual(result, expected)
<span class="hljs-keyword">def</span> <span class="hljs-title">suite</span>():
    suite = unittest.TestSuite()
    suite.addTest(MyTests("test_cool_numbers"))
    <span class="hljs-keyword">return</span> suite
runner = unittest.TextTestRunner()
runner.run(suite())
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">E
======================================================================
ERROR: test_cool_numbers (__main__.MyTests)
----------------------------------------------------------------------
Traceback (most recent call last):
 File "/tmp/ipykernel_79586/2361126771.py", line 9, in test_cool_numbers
   self.assertEqual(result, expected)
 File "/usr/lib/python3.9/unittest/case.py", line 837, in assertEqual
   assertion_func(first, second, msg=msg)
 File "/usr/lib/python3.9/unittest/case.py", line 827, in _baseAssertEqual
   if not first == second:
 File "/home/willayd/clones/Pandas-Cookbook-Third-Edition/lib/python3.9/site-packages/pandas/core/generic.py", line 1577, in __nonzero__
   raise ValueError(
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
----------------------------------------------------------------------
Ran 1 test in 0.004s
FAILED (errors=1)
&lt;unittest.runner.TextTestResult run=1 errors=1 failures=0&gt;
</code></code></pre>
    <p class="normal">Well…that was surprising!</p>
    <p class="normal">The underlying issue here is that the call to <code class="inlineCode">self.assertEqual(result, expected)</code> executes the expression <code class="inlineCode">result == expected</code>. If the result of that expression were <code class="inlineCode">True</code>, the test would pass; an expression that returns <code class="inlineCode">False</code> would fail the test.</p>
    <p class="normal">However, pandas overloads the <a id="_idIndexMarker547"/>equality operator for a <code class="inlineCode">pd.Series</code>, so that instead of returning <code class="inlineCode">True</code> or <code class="inlineCode">False</code>, you actually get back another <code class="inlineCode">pd.Series</code> with an element-wise comparison:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">result = some_cool_numbers()
expected = pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int64Dtype())
result == expected
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    True
1    True
2    &lt;NA&gt;
dtype: boolean
</code></code></pre>
    <p class="normal">Since testing frameworks don’t know what to make of this, you will have to reach for custom functions in the <code class="inlineCode">pd.testing</code> namespace. For <code class="inlineCode">pd.Series</code> comparison, <code class="inlineCode">pd.testing.assert_series_equal</code> is the right tool for the job:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas.testing <span class="hljs-keyword">as</span> tm
<span class="hljs-keyword">def</span> <span class="hljs-title">some_cool_numbers</span>():
    <span class="hljs-keyword">return</span> pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int64Dtype())
<span class="hljs-keyword">class</span> <span class="hljs-title">MyTests</span>(unittest.TestCase):
    <span class="hljs-keyword">def</span> <span class="hljs-title">test_cool_numbers</span>(<span class="hljs-params">self</span>):
        result = some_cool_numbers()
        expected = pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int64Dtype())
        tm.assert_series_equal(result, expected)
<span class="hljs-keyword">def</span> <span class="hljs-title">suite</span>():
    suite = unittest.TestSuite()
    suite.addTest(MyTests("test_cool_numbers"))
    <span class="hljs-keyword">return</span> suite
runner = unittest.TextTestRunner()
runner.run(suite())
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">.
----------------------------------------------------------------------
Ran 1 test in 0.001s
 
OK
&lt;unittest.runner.TextTestResult run=1 errors=0 failures=0&gt;
</code></code></pre>
    <p class="normal">For completeness, let’s trigger <a id="_idIndexMarker548"/>an intentional failure and review the output:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">some_cool_numbers</span>():
    <span class="hljs-keyword">return</span> pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int64Dtype())
<span class="hljs-keyword">class</span> <span class="hljs-title">MyTests</span>(unittest.TestCase):
    <span class="hljs-keyword">def</span> <span class="hljs-title">test_cool_numbers</span>(<span class="hljs-params">self</span>):
        result = some_cool_numbers()
        expected = pd.Series([<span class="hljs-number">42</span>, <span class="hljs-number">555</span>, pd.NA], dtype=pd.Int32Dtype())
        tm.assert_series_equal(result, expected)
<span class="hljs-keyword">def</span> <span class="hljs-title">suite</span>():
    suite = unittest.TestSuite()
    suite.addTest(MyTests("test_cool_numbers"))
    <span class="hljs-keyword">return</span> suite
runner = unittest.TextTestRunner()
runner.run(suite())
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">F
======================================================================
FAIL: test_cool_numbers (__main__.MyTests)
----------------------------------------------------------------------
Traceback (most recent call last):
 File "/tmp/ipykernel_79586/2197259517.py", line 9, in test_cool_numbers
   tm.assert_series_equal(result, expected)
 File "/home/willayd/clones/Pandas-Cookbook-Third-Edition/lib/python3.9/site-packages/pandas/_testing/asserters.py", line 975, in assert_series_equal
   assert_attr_equal("dtype", left, right, obj=f"Attributes of {obj}")
 File "/home/willayd/clones/Pandas-Cookbook-Third-Edition/lib/python3.9/site-packages/pandas/_testing/asserters.py", line 421, in assert_attr_equal
   raise_assert_detail(obj, msg, left_attr, right_attr)
 File "/home/willayd/clones/Pandas-Cookbook-Third-Edition/lib/python3.9/site-packages/pandas/_testing/asserters.py", line 614, in raise_assert_detail
   raise AssertionError(msg)
AssertionError: Attributes of Series are different
Attribute "dtype" are different
[left]:  Int64
[right]: Int32
----------------------------------------------------------------------
Ran 1 test in 0.003s
FAILED (failures=1)
&lt;unittest.runner.TextTestResult run=1 errors=0 failures=1&gt;
</code></code></pre>
    <p class="normal">Within the test failure traceback, pandas is telling us that the data types of the compared objects are not the same. The result of a call to <code class="inlineCode">some_cool_numbers</code> returns a <code class="inlineCode">pd.Series</code> with a <code class="inlineCode">pd.Int64Dtype</code>, whereas our expectation was looking for a <code class="inlineCode">pd.Int32Dtype</code>.</p>
    <p class="normal">While these examples focused<a id="_idIndexMarker549"/> on using <code class="inlineCode">pd.testing.assert_series_equal</code>, the equivalent method for a <code class="inlineCode">pd.DataFrame</code> is <code class="inlineCode">pd.testing.assert_frame_equal</code>. Both of these functions know how to handle potentially different row indexes, column indexes, values, and missing value semantics, and will report back informative errors to the test runner if expectations are not met.</p>
    <h2 id="_idParaDest-276" class="heading-2">There’s more…</h2>
    <p class="normal">This recipe used the <code class="inlineCode">unittest</code> module because it is built into the Python language. However, many large Python projects, particularly in <a id="_idIndexMarker550"/>the scientific Python space, use the <code class="inlineCode">pytest</code> library to write and execute unit tests.</p>
    <p class="normal">In contrast to <code class="inlineCode">unittest</code>, <code class="inlineCode">pytest</code> abandons a class-based testing structure with <code class="inlineCode">setUp</code> and <code class="inlineCode">tearDown</code> methods, opting instead for a test fixture-based approach. A comparison of these two different testing paradigms can be found within the <em class="italic">pytest</em> documentation.</p>
    <p class="normal">The <code class="inlineCode">pytest</code> library also offers a <a id="_idIndexMarker551"/>rich set of plugins. Some plugins may aim to improve integration with third-party libraries (as is the case for <code class="inlineCode">pytest-django</code> and <code class="inlineCode">pytest-sqlalchemy</code>), whereas others may be focused on scaling your test suite to use all of your system’s resources (as is the case for <code class="inlineCode">pytest-xdist</code>). There are countless plugin use cases in between, so I strongly recommend giving <code class="inlineCode">pytest</code> and its plugin ecosystem a look for testing your Python code bases.</p>
    <h1 id="_idParaDest-277" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers:</p>
    <p class="normal"><a href="https://packt.link/pandas"><span class="url">https://packt.link/pandas</span></a></p>
    <p class="normal"><img src="../Images/QR_Code5040900042138312.png" alt=""/></p>
  </div>
</body></html>