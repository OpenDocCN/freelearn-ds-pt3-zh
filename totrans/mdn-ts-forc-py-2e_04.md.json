["```py\n#Does not support missing values, so using imputed ts instead\nres = seasonal_decompose(ts, period=7*48, model=\"additive\", extrapolate_trend=\"freq\") \n```", "```py\nstl = STL(seasonality_period=7*48, model = \"additive\")\nres_new = stl.fit(ts_df.energy_consumption) \n```", "```py\nstl = FourierDecomposition(seasonality_period=\"hour\", model = \"additive\", n_fourier_terms=5)\nres_new = stl.fit(pd.Series(ts.squeeze(), index=ts_df.index)) \n```", "```py\n#Making a custom seasonality term\nts_df[\"dayofweek\"] = ts_df.index.dayofweek\nts_df[\"hour\"] = ts_df.index.hour\n#Creating a sorted unique combination df\nmap_df = ts_df[[\"dayofweek\",\"hour\"]].drop_duplicates().sort_values([\"dayofweek\", \"hour\"])\n# Assigning an ordinal variable to capture the order\nmap_df[\"map\"] = np.arange(1, len(map_df)+1)\n# mapping the ordinal mapping back to the original df and getting the seasonality array\nseasonality = ts_df.merge(map_df, on=[\"dayofweek\",\"hour\"], how='left', validate=\"many_to_one\")['map']\nstl = FourierDecomposition(model = \"additive\", n_fourier_terms=50)\nres_new = stl.fit(pd.Series(ts, index=ts_df.index), seasonality=seasonality) \n```", "```py\nstl = MultiSeasonalDecomposition(seasonal_model=\"fourier\",seasonality_periods=[\"day_of_year\", \"day_of_week\", \"hour\"], model = \"additive\", n_fourier_terms=10)\nres_new = stl.fit(pd.Series(ts, index=ts_df.index)) \n```"]