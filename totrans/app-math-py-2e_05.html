<html><head></head><body>
		<div id="_idContainer743">
			<h1 class="chapter-number" id="_idParaDest-179"><a id="_idTextAnchor178"/>5</h1>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor179"/>Working with Trees and Networks</h1>
			<p>Networks<a id="_idIndexMarker474"/> are objects that<a id="_idIndexMarker475"/> contain <em class="italic">nodes</em> and <em class="italic">edges</em> between pairs of nodes. They<a id="_idIndexMarker476"/> can be used to represent a wide variety of real-world situations, such as distribution and scheduling. Mathematically, networks are useful for visualizing combinatorial problems and make for a rich and <span class="No-Break">fascinating theory.</span></p>
			<p>There are, of course, several different kinds of networks. We will mostly deal with simple networks, where edges<a id="_idIndexMarker477"/> connect two distinct nodes (so there are no self-loops), there is, at most, one edge between any two nodes, and all the edges are bidirectional. A <em class="italic">tree</em> is a special<a id="_idIndexMarker478"/> kind of network in which there are no cycles; that is, there are no lists of nodes in which each node is connected to the following node by an edge, and the final node is connected to the first. Trees are especially simple in terms of their theory because they connect several nodes with the fewest possible edges. A <em class="italic">complete network</em> is a<a id="_idIndexMarker479"/> network in which every node is connected to every other node by <span class="No-Break">an edge.</span></p>
			<p>Networks can be <a id="_idIndexMarker480"/>directed, where each edge has a source and a destination node or can carry additional attributes, such as weights. Weighted networks are<a id="_idIndexMarker481"/> especially useful in certain applications. There are also networks in which we allow multiple edges between two <span class="No-Break">given nodes.</span></p>
			<p>In this chapter, we will learn how to create, manipulate, and analyze networks, and then apply network algorithms to solve <span class="No-Break">various problems.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the literature, especially in <a id="_idIndexMarker482"/>mathematical texts, networks are more commonly called <em class="italic">graphs</em>. Nodes <a id="_idIndexMarker483"/>are sometimes<a id="_idIndexMarker484"/> called <em class="italic">vertices</em>. We favor the term network to avoid confusion with the more common usage of a graph to mean a plot of <span class="No-Break">a function.</span></p>
			<p>We will cover the following recipes in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Creating networks <span class="No-Break">in Python</span></li>
				<li><span class="No-Break">Visualizing networks</span></li>
				<li>Getting the basic characteristics <span class="No-Break">of networks</span></li>
				<li>Generating the adjacency matrix for <span class="No-Break">a network</span></li>
				<li>Creating directed and <span class="No-Break">weighted networks</span></li>
				<li>Finding the shortest paths in <span class="No-Break">a network</span></li>
				<li>Quantifying clustering in <span class="No-Break">a network</span></li>
				<li>Coloring <span class="No-Break">a network</span></li>
				<li>Finding minimal spanning trees and <span class="No-Break">dominating sets</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor180"/>Technical requirements</h1>
			<p>In this chapter, we will primarily use the NetworkX package for working with trees and networks. This package can be installed using your favorite package manager, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
python3.10 -m pip install networkx</pre>
			<p>We usually import this under the <strong class="source-inline">nx</strong> alias, following the conventions established in the official NetworkX (<a href="https://networkx.org/documentation/stable/">https://networkx.org/documentation/stable/</a>) documentation, using the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
import networkx as nx</pre>
			<p>The code for this chapter can be found in the <span class="No-Break"><strong class="source-inline">Chapter 05</strong></span> folder of this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005"><span class="No-Break">https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor181"/>Creating networks in Python</h1>
			<p>To<a id="_idIndexMarker485"/> solve the multitude of problems that can be expressed as network problems, we need a way of creating networks in Python. For this, we will make use of the NetworkX package and the routines and classes it provides to create, manipulate, and <span class="No-Break">analyze networks.</span></p>
			<p>In this recipe, we’ll create an object in Python that represents a network and add nodes and edges to <span class="No-Break">this object.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Getting ready</h2>
			<p>As we mentioned in the <em class="italic">Technical requirements</em> section, we need the NetworkX package to be imported under the <strong class="source-inline">nx</strong> alias. We can do this using the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
import networkx as nx</pre>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor183"/>How to do it...</h2>
			<p>Follow these steps to create a Python representation of a <span class="No-Break">simple graph:</span></p>
			<ol>
				<li>We need to create a new <strong class="source-inline">Graph</strong> object that will store the nodes and edges that constitute <span class="No-Break">the graph:</span><pre class="console">
G = nx.Graph()</pre></li>
				<li>Next, we need to add the nodes for the network using the <span class="No-Break"><strong class="source-inline">add_node</strong></span><span class="No-Break"> method:</span><pre class="console">
G.add_node(1)</pre><pre class="console">
G.add_node(2)</pre></li>
				<li>To avoid calling this method repetitively, we can use the <strong class="source-inline">add_nodes_from</strong> method to add nodes from an iterable, such as <span class="No-Break">a list:</span><pre class="console">
G.add_nodes_from([3, 4, 5, 6])</pre></li>
				<li>Next, we need to add edges between the nodes that we’ve added using either the <strong class="source-inline">add_edge</strong> or <strong class="source-inline">add_edges_from</strong> method, which adds either a single edge or a list of edges (as <span class="No-Break">tuples), respectively:</span><pre class="console">
G.add_edge(1, 2)  # edge from 1 to 2</pre><pre class="console">
G.add_edges_from([(2, 3),(3, 4)(3, 5),(3, 6),</pre><pre class="console">
    (4,5),(5,6)])</pre></li>
				<li>Finally, we must retrieve a view of the current nodes and edges in a graph by accessing the <strong class="source-inline">nodes</strong> and <strong class="source-inline">edges</strong> <span class="No-Break">attributes, respectively:</span><pre class="console">
print(G.nodes)</pre><pre class="console">
print(G.edges)</pre><pre class="console">
# [1, 2, 3, 4, 5, 6]</pre><pre class="console">
# [(1, 2), (2, 3), (3, 4), (3, 5), (3, 6), (4, 5), (5, 6)]</pre></li>
			</ol>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>How it works...</h2>
			<p>The <a id="_idIndexMarker486"/>NetworkX package<a id="_idIndexMarker487"/> adds several classes and routines for creating, manipulating, and analyzing networks using Python. The <strong class="source-inline">Graph</strong> class is the most basic class for representing networks that do not contain multiple edges between any given nodes and where their edges are <span class="No-Break">undirected (bidirectional).</span></p>
			<p>Once a blank <strong class="source-inline">Graph</strong> object has been created, we can add new nodes and edges using the methods described in this recipe. In this recipe, we created nodes that hold integer values. However, a node can hold any hashable Python object except <strong class="source-inline">None</strong>. Moreover, associated data can be added to a node via keyword arguments passed to the <strong class="source-inline">add_node</strong> method. Attributes can also be added when using the <strong class="source-inline">add_nodes_from</strong> method by supplying a list of tuples containing the node object and a dictionary of attributes. The <strong class="source-inline">add_nodes_from</strong> method is useful for adding nodes in bulk, while <strong class="source-inline">add_node</strong> is useful for attaching individual nodes to an <span class="No-Break">existing network.</span></p>
			<p>An edge in a network is a tuple containing two (distinct) nodes. In a simple network, such as the one represented by the basic <strong class="source-inline">Graph</strong> class, there can be, at most, one edge between any two given nodes. These edges are added via the <strong class="source-inline">add_edge</strong> or <strong class="source-inline">add_edges_from</strong> method, which adds either a single edge or a list of edges to the network, respectively. As for the nodes, edges can hold arbitrary associated data via an attributes dictionary. In particular, weights can be added by supplying the <strong class="source-inline">weight</strong> attribute when adding edges. We will provide more details about weighted graphs in the <em class="italic">Creating directed and weighted </em><span class="No-Break"><em class="italic">networks</em></span><span class="No-Break"> recipe.</span></p>
			<p>The <strong class="source-inline">nodes</strong> and <strong class="source-inline">edges</strong> attributes hold the nodes and edges that constitute the network, respectively. The <strong class="source-inline">nodes</strong> attribute returns a <strong class="source-inline">NodesView</strong> object, which is a dictionary-like<a id="_idIndexMarker488"/> interface to the nodes and their associated data. Similarly, the <strong class="source-inline">edges</strong> attribute returns an <strong class="source-inline">EdgeView</strong> object. This can be used to inspect individual edges and their <span class="No-Break">associated data.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>There’s more...</h2>
			<p>The <strong class="source-inline">Graph</strong> class represents <em class="italic">simple networks</em>, which <a id="_idIndexMarker489"/>are networks in which nodes are joined by, at most, one edge, and the edges are not directed. We will discuss directed networks in the <em class="italic">Creating directed and weighted networks</em> recipe. There is a separate class for representing networks in which there can be multiple edges between a pair of nodes called <strong class="source-inline">MultiGraph</strong>. All of the network types allow self-loops, which are sometimes not allowed in a <em class="italic">simple network</em> in the literature, where a simple network typically refers to an undirected network with <span class="No-Break">no self-loops.</span></p>
			<p>All network types offer various methods for adding nodes and edges, as well as inspecting the current nodes and edges. There are also methods for copying networks into some other kind of network or extracting subnetworks. There are also several utility routines in the NetworkX package for generating standard networks and adding subnetworks to an <span class="No-Break">existing network.</span></p>
			<p>NetworkX<a id="_idIndexMarker490"/> also provides various routines for reading and writing networks to different file formats, such as GraphML, JSON, and YAML. For example, we can write a network to a GraphML file using the <strong class="source-inline">nx.write_graphml</strong> routine and read it using the <span class="No-Break"><strong class="source-inline">nx.read_graphml</strong></span><span class="No-Break"> routine.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Visualizing networks</h1>
			<p>A common first step in <a id="_idIndexMarker491"/>analyzing a network is to draw the network, which can help us identify some of the prominent features of a network. (Of course, drawings can be misleading, so we should not rely on them too heavily in <span class="No-Break">our analysis.)</span></p>
			<p>In this recipe, we’ll describe how to use the network drawing facilities in the NetworkX package to visualize <span class="No-Break">a network.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>Getting ready</h2>
			<p>For this recipe, we<a id="_idIndexMarker492"/> will need to import the NetworkX package under the <strong class="source-inline">nx</strong> alias, as described in the <em class="italic">Technical requirements</em> section. We will also need the Matplotlib package. For this, as usual, we must import the <strong class="source-inline">pyplot</strong> module as <strong class="source-inline">plt</strong> using the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
import matplotlib.pyplot as plt</pre>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>How to do it...</h2>
			<p>The following steps outline how to draw a simple network object using the drawing routines <span class="No-Break">from NetworkX:</span></p>
			<ol>
				<li value="1">First, we will create a simple example network <span class="No-Break">to draw:</span><pre class="console">
G = nx.Graph()</pre><pre class="console">
G.add_nodes_from(range(1, 7))</pre><pre class="console">
G.add_edges_from([</pre><pre class="console">
    (1, 2), (2, 3), (3, 4), (3, 5),</pre><pre class="console">
    (3, 6), (4, 5), (5, 6)</pre><pre class="console">
])</pre></li>
				<li>Next, we will create new Matplotlib <strong class="source-inline">Figure</strong> and <strong class="source-inline">Axes</strong> objects for it, ready to plot the network using the <strong class="source-inline">subplots</strong> routine <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">:</span><pre class="console">
fig, ax = plt.subplots()</pre></li>
				<li>Now, we can create a layout that will be used to position the nodes on the figure. For this figure, we shall use a shell layout using the <span class="No-Break"><strong class="source-inline">shell_layout</strong></span><span class="No-Break"> routine:</span><pre class="console">
layout = nx.shell_layout(G)</pre></li>
				<li>We can use the <strong class="source-inline">draw</strong> routine to draw the network on the figure. Since we have already created a Matplotlib <strong class="source-inline">Figure</strong> and <strong class="source-inline">Axes</strong>, we can supply the <strong class="source-inline">ax</strong> keyword argument. We will also add labels to the nodes using the <strong class="source-inline">with_labels</strong> keyword argument and specify the layout that we just created using the <span class="No-Break"><strong class="source-inline">pos</strong></span><span class="No-Break"> argument:</span><pre class="console">
nx.draw(G, ax=ax, pos=layout, with_labels=True)</pre><pre class="console">
ax.set_title("Simple network drawing")</pre></li>
			</ol>
			<p>The resulting <a id="_idIndexMarker493"/>drawing can be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer705">
					<img alt="Figure 5.1 – A drawing of a simple network arranged using a shell layout&#13;&#10;" src="image/5.1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – A drawing of a simple network arranged using a shell layout</p>
			<p>Since the number of nodes in this example is relatively small, they are arranged in a single circle. The edges are indicated <span class="No-Break">by lines.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>How it works...</h2>
			<p>The <strong class="source-inline">draw</strong> routine is <a id="_idIndexMarker494"/>a specialized plotting routine specifically for drawing networks. The layout we created specifies the coordinates at which each of the nodes will be placed. We used a <em class="italic">shell layout</em>, which <a id="_idIndexMarker495"/>arranges the nodes in a concentric circle arrangement (only a single circle was used in this recipe), which is determined by the nodes and edges of the network. By default, the <strong class="source-inline">draw</strong> routine creates a <span class="No-Break">randomized layout.</span></p>
			<p>The <strong class="source-inline">draw</strong> routine has<a id="_idIndexMarker496"/> numerous keyword arguments for customizing the appearance of the plotted network. In this recipe, we added the <strong class="source-inline">with_labels</strong> keyword argument to label the nodes in the figure according to the objects they hold. The nodes hold integers, which is why the nodes in the preceding figure are labeled <span class="No-Break">by integers.</span></p>
			<p>We also created a <a id="_idIndexMarker497"/>set of axes separately using the <strong class="source-inline">plt.subplots</strong> routine. This isn’t strictly necessary since the <strong class="source-inline">draw</strong> routine will automatically create a new figure and new axes if they’re <span class="No-Break">not provided.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor190"/>There’s more...</h2>
			<p>The NetworkX package provides several layout-generating routines, similar to the <strong class="source-inline">shell_layout</strong> routine that we used in this recipe. This layout is simply a dictionary, indexed by the nodes, whose elements are the x and y coordinates of the position where the node should be plotted. The NetworkX routines for creating layouts represent common arrangements that will be useful for most cases, but you can also create custom layouts, should you need them. A full list of the different layout creation routines is provided in the NetworkX documentation. There are also shortcut drawing routines that will use a specific layout with the need to create the layout separately; for example, the <strong class="source-inline">draw_shell</strong> routine will draw the network with the shell layout that is equivalent to the <strong class="source-inline">draw</strong> call given in <span class="No-Break">this recipe.</span></p>
			<p>The <strong class="source-inline">draw</strong> routine<a id="_idIndexMarker498"/> takes several keyword arguments to customize the appearance of the figure. For example, there are keyword arguments to control the node’s size, color, shape, and transparency. We can also add arrows (for directed edges) and/or only draw a specific set of nodes and edges from <span class="No-Break">the network.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Getting the basic characteristics of networks</h1>
			<p>Networks have various basic characteristics<a id="_idIndexMarker499"/> beyond the number of nodes and edges that are useful for analyzing a graph. For example, the <em class="italic">degree</em> of a node is the number of edges that start (or end) at that node. A higher degree indicates that the node is better connected to the rest of <span class="No-Break">the network.</span></p>
			<p>In this recipe, we will learn how to access the basic attributes and compute various basic measures associated with <span class="No-Break">a network.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>Getting ready</h2>
			<p>As usual, we need to import the NetworkX package under the <strong class="source-inline">nx</strong> alias. We also need to import the Matplotlib <strong class="source-inline">pyplot</strong> module <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>How to do it...</h2>
			<p>Follow these steps to access <a id="_idIndexMarker500"/>the various basic characteristics of <span class="No-Break">a network:</span></p>
			<ol>
				<li value="1">Create the sample network that we will analyze in this recipe, <span class="No-Break">like so:</span><pre class="console">
G = nx.Graph()</pre><pre class="console">
G.add_nodes_from(range(10))</pre><pre class="console">
G.add_edges_from([</pre><pre class="console">
    (0, 1), (1, 2), (2, 3), (2, 4),</pre><pre class="console">
    (2, 5), (3, 4), (4, 5), (6, 7),</pre><pre class="console">
    (6, 8), (6, 9), (7, 8), (8, 9)</pre><pre class="console">
])</pre></li>
				<li>Next, it is good practice to draw the network and arrange the nodes in a <span class="No-Break">circular layout:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
nx.draw_circular(G, ax=ax, with_labels=True)</pre><pre class="console">
ax.set_title("Simple network")</pre></li>
			</ol>
			<p>The resulting plot can be seen in the following figure. As we can see, the network is split into two <span class="No-Break">distinct parts:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer706">
					<img alt="Figure 5.2 – A simple network drawn in a circular arrangement with two distinct components&#13;&#10;" src="image/5.2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A simple network drawn in a circular arrangement with two distinct components</p>
			<ol>
				<li value="3">Next, we must <a id="_idIndexMarker501"/>print the <strong class="source-inline">Graph</strong> object to display some basic information about <span class="No-Break">the network:</span><pre class="console">
print(G)</pre><pre class="console">
# Name:</pre><pre class="console">
# Type: Graph</pre><pre class="console">
# Number of nodes: 10</pre><pre class="console">
# Number of edges: 12</pre><pre class="console">
# Average degree: 2.4000</pre></li>
				<li>Now, we can use the <strong class="source-inline">degree</strong> property of the <strong class="source-inline">Graph</strong> object to retrieve the degree of a <span class="No-Break">specific node:</span><pre class="console">
for i in [0, 2, 7]:</pre><pre class="console">
    degree = G.degree[i]</pre><pre class="console">
    print(f"Degree of {i}: {degree}")</pre><pre class="console">
# Degree of 0: 1</pre><pre class="console">
# Degree of 2: 4</pre><pre class="console">
# Degree of 7: 2</pre></li>
				<li>We can get the connected components of the network using the <strong class="source-inline">connected_components</strong> routine, which returns a generator that we make into <span class="No-Break">a list:</span><pre class="console">
components = list(nx.connected_components(G))</pre><pre class="console">
print(components)</pre><pre class="console">
# [{0, 1, 2, 3, 4, 5}, {8, 9, 6, 7}]</pre></li>
				<li>We can <a id="_idIndexMarker502"/>compute the <strong class="bold">density</strong> of a network using the <a id="_idIndexMarker503"/>density routine, which returns a float between 0 and 1. This represents the proportion of edges meeting the node to the total number of possible edges at <span class="No-Break">the node:</span><pre class="console">
density = nx.density(G)</pre><pre class="console">
print("Density", density)</pre><pre class="console">
# Density 0.26666666666666666</pre></li>
				<li>Finally, we can determine whether a network is <em class="italic">planar</em> – meaning that no two edges need to be drawn crossing one another – by using the <span class="No-Break"><strong class="source-inline">check_planarity</strong></span><span class="No-Break"> routine:</span><pre class="console">
is_planar, _ = nx.check_planarity(G)</pre><pre class="console">
print("Is planar", is_planar)</pre><pre class="console">
# Is planar True</pre></li>
			</ol>
			<p>If we glance back at <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>, we can see that we can indeed draw this graph without having to cross two of <span class="No-Break">the edges.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>How it works...</h2>
			<p>The <strong class="source-inline">info</strong> routine<a id="_idIndexMarker504"/> generates a small summary of the network, including the type of the network (which is a simple <strong class="source-inline">Graph</strong> type in this recipe), the number of nodes and edges, and the average degrees of the nodes in the network. The actual degree of a node in the network can be accessed using the <strong class="source-inline">degree</strong> property, which offers a dictionary-like interface for finding the degree of <span class="No-Break">each node.</span></p>
			<p>A set of nodes is said to be <a id="_idIndexMarker505"/>connected if every node in the set is joined to the others by an edge or sequence of edges. The <em class="italic">connected components</em> of a network are the largest sets of nodes that are connected. Any two distinct connected components are disjointed. Every network<a id="_idIndexMarker506"/> can be decomposed into one or more connected components. The network we defined in this recipe has two connected components, <strong class="source-inline">{0, 1, 2, 3, 4, 5}</strong> and <strong class="source-inline">{8, 9, 6, 7}</strong>. These are visible in the preceding figure, where the first connected component is drawn above the second connected component. In this figure, we can trace a path along the edges of the network from any node in a component to any other; for example, from 0 <span class="No-Break">to 5.</span></p>
			<p>The <em class="italic">density</em> of a <a id="_idIndexMarker507"/>network measures the ratio of the number of edges in the network to the total possible number of edges given by the number of nodes in a network. The density of a complete network is 1, but in general, the density will be less <span class="No-Break">than 1.</span></p>
			<p>A network is <em class="italic">planar</em> if it can be<a id="_idIndexMarker508"/> drawn on a flat surface without crossing edges. The easiest example of a non-planar network is a complete network with five nodes. Complete networks with, at most, four nodes are planar. A little experimentation with the way you draw these networks on paper will reveal a drawing that doesn’t contain crossing edges. In addition, any network that contains a complete graph with at least five nodes is not planar. Planar networks are important in theory due to their relative simplicity, but they are<a id="_idIndexMarker509"/> less common in networks that arise <span class="No-Break">in applications.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>There’s more...</h2>
			<p>In addition to the methods on the network classes, there are several other routines in the NetworkX package that can be used to access the attributes of the nodes and edges in a network. For example, <strong class="source-inline">nx.get_node_attributes</strong> gets a named attribute from each node in <span class="No-Break">the network.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor196"/>Generating the adjacency matrix for a network</h1>
			<p>One <a id="_idIndexMarker510"/>potent tool for analyzing graphs is the <a id="_idIndexMarker511"/>adjacency matrix, which has entries <img alt="" src="image/Formula_05_003.png"/> if there is an edge from node <img alt="" src="image/Formula_05_004.png"/> to node <img alt="" src="image/Formula_05_005.png"/>, and 0 otherwise. For most networks, the adjacency matrix will be sparse (most of the entries are 0). For networks that are not directed, the matrix will also be symmetric (<img alt="" src="image/Formula_05_006.png"/>). Numerous other matrices can be associated with a network. We will briefly discuss these in the <em class="italic">There’s more...</em> section of <span class="No-Break">this recipe.</span></p>
			<p>In this recipe, we will generate the adjacency matrix for a network and learn how to get some basic properties of the network from <span class="No-Break">this matrix.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Getting ready</h2>
			<p>For this recipe, we will need the NetworkX package imported under the <strong class="source-inline">nx</strong> alias, and the NumPy module imported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">np</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>How to do it...</h2>
			<p>The following steps<a id="_idIndexMarker512"/> outline how to generate the adjacency <a id="_idIndexMarker513"/>matrix for a network and derive some simple properties of the network from <span class="No-Break">this matrix:</span></p>
			<ol>
				<li value="1">First, we will generate a network to work with throughout this recipe. We’ll generate a random network with five nodes and five edges while using a seed <span class="No-Break">for reproducibility:</span><pre class="console">
G = nx.dense_gnm_random_graph(5, 5, seed=12345)</pre></li>
				<li>To generate the adjacency matrix, we can use the <strong class="source-inline">adjacency_matrix</strong> routine from NetworkX. This returns a sparse matrix by default, so we will also convert this into a full NumPy array for this demonstration using the <span class="No-Break"><strong class="source-inline">todense</strong></span><span class="No-Break"> method:</span><pre class="console">
matrix = nx.adjacency_matrix(G).todense()</pre><pre class="console">
print(matrix)</pre><pre class="console">
# [[0 0 1 0 0]</pre><pre class="console">
#  [0 0 1 1 0]</pre><pre class="console">
#  [1 1 0 0 1]</pre><pre class="console">
#  [0 1 0 0 1]</pre><pre class="console">
#  [0 0 1 1 0]]</pre></li>
				<li>Taking the <img alt="" src="image/Formula_05_007.png"/>th power of the adjacency matrix gives us the number of paths of length <img alt="" src="image/Formula_05_007.png"/> from one node <span class="No-Break">to another:</span><pre class="console">
paths_len_4 = np.linalg.matrix_power(matrix, 4)</pre><pre class="console">
print(paths_len_4)</pre><pre class="console">
# [[ 3 5  0  0 5]</pre><pre class="console">
#  [ 5 9  0  0 9]</pre><pre class="console">
#  [ 0 0 13 10 0]</pre><pre class="console">
#  [ 0 0 10  8 0]</pre><pre class="console">
#  [ 5 9  0  0 9]]</pre></li>
			</ol>
			<p>Both the <a id="_idIndexMarker514"/>adjacency matrix from step 2 and the fourth<a id="_idIndexMarker515"/> power from step 3 are symmetric matrices. Also, notice that the non-zero entries of <strong class="source-inline">paths_len_4</strong> are located in the positions where 0 appears in the adjacency matrix. This is because there are two distinct groups of nodes, and paths of odd length swap between these two groups whereas paths of even length return to the <span class="No-Break">starting group.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>How it works...</h2>
			<p>The <strong class="source-inline">dense_gnm_random_graph</strong> routine generates a (dense) random network, chosen uniformly from the family of all networks with <img alt="" src="image/Formula_05_007.png"/> nodes and <img alt="" src="image/Formula_05_010.png"/> edges. In this recipe, <img alt="" src="image/Formula_05_011.png"/> and <img alt="" src="image/Formula_05_012.png"/>. The <strong class="source-inline">dense</strong> prefix indicates that this routine uses an algorithm that should be faster than the alternative <strong class="source-inline">gnm_random_graph</strong> for dense networks with a relatively large number of edges compared <span class="No-Break">to nodes.</span></p>
			<p>The adjacency matrix of a network is easy to generate, especially in sparse form, when the graph is relatively small. For larger networks, this can be an expensive operation, so it might not be practical, particularly if you convert it into a full matrix, as we saw in this recipe. You don’t need to do this in general, since we can simply use the sparse matrix generated by the <strong class="source-inline">adjacency_matrix</strong> routine and the sparse linear algebra tools in the SciPy <strong class="source-inline">sparse</strong> <span class="No-Break">module instead.</span></p>
			<p>The matrix powers<a id="_idIndexMarker516"/> provide information about the number of paths of a given length. This can easily be seen by tracing through the <a id="_idIndexMarker517"/>definitions of matrix multiplication. Remember that the entries of the adjacency matrix are 1 when there is an edge (path of length 1) between two <span class="No-Break">given nodes.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>There’s more...</h2>
			<p>The Eigenvalues of the adjacency matrix for a network provide some additional information about the structure of the network, such as the bounds for the chromatic number of the network. (See the <em class="italic">Coloring a network</em> recipe for more information about coloring a network.) There is a separate routine for computing the Eigenvalues of the adjacency matrix. For example, the <strong class="source-inline">adjacency_spectrum</strong> routine to generate the Eigenvalues of the adjacency matrix of a network. Methods involving the Eigenvalues of a matrix associated with a network are usually <a id="_idIndexMarker518"/>called <span class="No-Break"><em class="italic">spectral methods</em></span><span class="No-Break">.</span></p>
			<p>There are other matrices associated with networks, such <a id="_idIndexMarker519"/>as the <em class="italic">incidence matrix</em> and the <em class="italic">Laplacian matrix</em>. The <a id="_idIndexMarker520"/>incidence matrix of a network is an <img alt="" src="image/Formula_05_013.png"/> matrix, where <img alt="" src="image/Formula_05_014.png"/> is the number of nodes and <img alt="" src="image/Formula_05_015.png"/> is the number of edges. This has an <img alt="" src="image/Formula_05_016.png"/>th entry of 1 if node <img alt="" src="image/Formula_05_017.png"/> appears in edge <img alt="" src="image/Formula_05_018.png"/> and 0 otherwise. The Laplacian matrix of a network is defined to be the <img alt="" src="image/Formula_05_019.png"/> matrix, where <img alt="" src="image/Formula_05_020.png"/> is the diagonal matrix containing the degrees of the nodes in the network and <img alt="" src="image/Formula_05_021.png"/> is the adjacency matrix of the network. Both of these matrices are useful for <span class="No-Break">analyzing networks.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Creating directed and weighted networks</h1>
			<p>Simple networks, such as<a id="_idIndexMarker521"/> those described in the previous recipes, are useful for describing networks where the direction of an edge is unimportant and where the edges carry equal weight. In practice, most networks carry additional information, such as weights <span class="No-Break">or directions.</span></p>
			<p>In this recipe, we will create a directed and weighted network and explore some of the basic properties of <span class="No-Break">such networks.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Getting ready</h2>
			<p>For this recipe, we will need the NetworkX package, imported under the <strong class="source-inline">nx</strong> alias (as usual), the Matplotlib <strong class="source-inline">pyplot</strong> module imported as <strong class="source-inline">plt</strong>, and the NumPy package imported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">np</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>How to do it...</h2>
			<p>The following steps<a id="_idIndexMarker522"/> outline how to create a directed network with weights, as well as how to <a id="_idIndexMarker523"/>explore some of the properties and techniques we discussed in the <span class="No-Break">previous recipes:</span></p>
			<ol>
				<li value="1">To create a directed network, we can use the <strong class="source-inline">DiGraph</strong> class from NetworkX rather than the simple <span class="No-Break"><strong class="source-inline">Graph</strong></span><span class="No-Break"> class:</span><pre class="console">
G = nx.DiGraph()</pre></li>
				<li>As usual, we must add nodes to the network using the <strong class="source-inline">add_node</strong> or <span class="No-Break"><strong class="source-inline">add_nodes_from</strong></span><span class="No-Break"> method:</span><pre class="console">
G.add_nodes_from(range(5))</pre></li>
				<li>To add weighted edges, we can use either the <strong class="source-inline">add_edge</strong> method and provide the <strong class="source-inline">weight</strong> keyword argument, or use the <span class="No-Break"><strong class="source-inline">add_weighted_edges_from</strong></span><span class="No-Break"> method:</span><pre class="console">
G.add_edge(0, 1, weight=1.0)</pre><pre class="console">
G.add_weighted_edges_from([</pre><pre class="console">
    (1, 2, 0.5), (1, 3, 2.0), (2, 3, 0.3), (3, 2, 0.3),</pre><pre class="console">
    (2, 4, 1.2), (3, 4, 0.8)</pre><pre class="console">
])</pre></li>
				<li>Next, we must draw the <a id="_idIndexMarker524"/>network with arrows to indicate the direction of <a id="_idIndexMarker525"/>each edge. We must also provide positions for <span class="No-Break">this plot:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
pos = {0: (-1, 0), 1: (0, 0), 2: (1, 1), 3: (1, -1),</pre><pre class="console">
    4:(2, 0)}</pre><pre class="console">
nx.draw(G, ax=ax, pos=pos, with_labels=True)</pre><pre class="console">
ax.set_title("Weighted, directed network")</pre></li>
			</ol>
			<p>The resulting plot can be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer726">
					<img alt="Figure 5.3 – A weighted, directed network&#13;&#10;" src="image/5.3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – A weighted, directed network</p>
			<ol>
				<li value="5">The adjacency matrix of a directed matrix is created in the same way as a simple network, but the resulting matrix will not <span class="No-Break">be symmetric:</span><pre class="console">
adj_mat = nx.adjacency_matrix(G).todense()</pre><pre class="console">
print(adj_mat)</pre><pre class="console">
# [[0. 1. 0. 0. 0. ]</pre><pre class="console">
# [0. 0. 0.5 2. 0. ]</pre><pre class="console">
# [0. 0. 0. 0.3 1.2]</pre><pre class="console">
# [0. 0. 0.3 0. 0.8]</pre><pre class="console">
# [0. 0. 0. 0. 0. ]]</pre></li>
			</ol>
			<p>Rather than the number <a id="_idIndexMarker526"/>of edges between two given nodes, the adjacency matrix <a id="_idIndexMarker527"/>contains the sum of the weights of edges between <span class="No-Break">those nodes.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>How it works...</h2>
			<p>The <strong class="source-inline">DiGraph</strong> class<a id="_idIndexMarker528"/> represents a directed network, where the order of the nodes when adding an edge is important. In this recipe, we added two edges for connecting nodes 2 and 3, one in each direction. In a simple network (the <strong class="source-inline">Graph</strong> class), the addition of the second edge would not add another edge. However, for a directed network (the <strong class="source-inline">DiGraph</strong> class), the order that the nodes are given in when adding the edge determines <span class="No-Break">the direction.</span></p>
			<p>There is nothing special about weighted edges except for the addition of the <strong class="source-inline">weight</strong> attribute that’s attached to the edge. (Arbitrary data can be attached to an edge or node in a network via keyword arguments.) The <strong class="source-inline">add_weighted_edges_from</strong> method simply adds the corresponding weight value (the third value in the tuple) to the edge in question. Weights can be added to any edge in any network, not just the directed networks shown in <span class="No-Break">this recipe.</span></p>
			<p>The <strong class="source-inline">draw</strong> routine<a id="_idIndexMarker529"/> automatically adds arrows to edges when drawing a directed network. This behavior can be turned off by passing the <strong class="source-inline">arrows=False</strong> keyword argument. The adjacency matrix for a directed or weighted network also differs from that of a simple network. In a directed network, the matrix is not generally symmetrical, because edges may exist in one direction but not the other. For a weighted network, the entries can be different from 1 or 0, and will instead be the weight of the <span class="No-Break">corresponding edge.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>There’s more...</h2>
			<p>Weighted networks<a id="_idIndexMarker530"/> appear in lots of applications, such as when describing transportation networks with distances or speeds. You can also use networks to examine flow through a network by providing a <em class="italic">capacity</em> for edges in the network (as a weight or as another attribute). NetworkX has several tools for analyzing flow through a network, such as finding the maximum flow through a network via the <span class="No-Break"><strong class="source-inline">nx.maximum_flow</strong></span><span class="No-Break"> routine.</span></p>
			<p>Directed networks<a id="_idIndexMarker531"/> add directional information to a network. Many real-world applications give rise to networks that have unidirectional edges, such as those in industrial processes or supply chain networks. This additional directional information has consequences for many of the algorithms for working with networks, as we’ll see throughout <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor206"/>Finding the shortest paths in a network</h1>
			<p>A common problem where <a id="_idIndexMarker532"/>networks make an appearance is in the problem <a id="_idIndexMarker533"/>of finding the shortest – or perhaps more precisely, the highest reward – route between two nodes in a network. For instance, this could be the shortest distance between two cities, where the nodes represent the cities, and the edges are roads connecting pairs of cities. In this case, the weights of the edges would be <span class="No-Break">their lengths.</span></p>
			<p>In this recipe, we will find the shortest path between two nodes in a network <span class="No-Break">with weights.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>Getting ready</h2>
			<p>For this recipe, we <a id="_idIndexMarker534"/>will need the NetworkX package imported, as<a id="_idIndexMarker535"/> usual, under the <strong class="source-inline">nx</strong> alias, the Matplotlib <strong class="source-inline">pyplot</strong> module imported as <strong class="source-inline">plt</strong>, and a random number generator object <span class="No-Break">from NumPy:</span></p>
			<pre class="source-code">
from numpy.random import default_rng
rng = default_rng(12345) # seed for reproducibility</pre>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>How to do it...</h2>
			<p>Follow these steps to<a id="_idIndexMarker536"/> find the shortest path between two nodes in<a id="_idIndexMarker537"/> <span class="No-Break">a network:</span></p>
			<ol>
				<li value="1">First, we will create a random network using <strong class="source-inline">gnm_random_graph</strong> and a <strong class="source-inline">seed</strong> for <span class="No-Break">this demonstration:</span><pre class="console">
G = nx.gnm_random_graph(10, 17, seed=12345)</pre></li>
				<li>Next, we’ll draw the network with a circular arrangement to see how the <span class="No-Break">nodes connect:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
nx.draw_circular(G, ax=ax, with_labels=True)</pre><pre class="console">
ax.set_title("Random network for shortest path finding")</pre></li>
			</ol>
			<p>The resulting plot can be seen in the following figure. Here, we can see that there is no direct edge from node 7 to <span class="No-Break">node 9:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer727">
					<img alt="Figure 5.4 – A randomly generated network with 10 nodes and 17 edges&#13;&#10;" src="image/5.4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – A randomly generated network with 10 nodes and 17 edges</p>
			<ol>
				<li value="3">Now, we need to add a weight to each of the edges so that some routes are preferable to others in terms of the <span class="No-Break">shortest path:</span><pre class="console">
for u, v in G.edges:</pre><pre class="console">
    G.edges[u, v]["weight"] = rng.integers(5, 15)</pre></li>
				<li>Next, we<a id="_idIndexMarker538"/> will compute the shortest path from <a id="_idIndexMarker539"/>node 7 to node 9 using the <span class="No-Break"><strong class="source-inline">nx.shortest_path</strong></span><span class="No-Break"> routine:</span><pre class="console">
path = nx.shortest_path(G, 7, 9, weight="weight")</pre><pre class="console">
print(path)</pre><pre class="console">
# [7, 5, 2, 9]</pre></li>
				<li>We can find the length of this shortest path using <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">nx.shortest_path_</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">length</strong></span><span class="No-Break"> routine:</span><pre class="console">
length = nx.shortest_path_length(G, 7, 9,</pre><pre class="console">
    weight="weight")</pre><pre class="console">
print("Length", length)</pre><pre class="console">
# Length 32</pre></li>
			</ol>
			<p>Here the <em class="italic">length</em> of the path is the sum of the weights of the edges along the shortest path. If the network is not weighted, then this will be equal to the number of edges traversed along <span class="No-Break">this path.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor209"/>How it works...</h2>
			<p>The <strong class="source-inline">shortest_path</strong> routine<a id="_idIndexMarker540"/> computes the shortest path between each <a id="_idIndexMarker541"/>pair of nodes. Alternatively, when supplied with the source and destination node, which is what we did in this recipe, it computes the shortest path between the two specified nodes. We supplied the optional <strong class="source-inline">weight</strong> keyword argument, which makes the algorithm find the shortest path according to the <em class="italic">weight</em> attribute of the edge. This argument changes the meaning of <em class="italic">shortest</em>, with the default being the <span class="No-Break"><em class="italic">fewest edges</em></span><span class="No-Break">.</span></p>
			<p>The default algorithm for finding the shortest path between two nodes is Dijkstra’s algorithm, which is a staple of computer science and mathematics courses. It is a good general-purpose algorithm but is not particularly efficient. Other route-finding algorithms include the A* algorithm. Greater efficiency can be obtained by using the A* algorithm with additional heuristic information to guide <span class="No-Break">node selection.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>There’s more...</h2>
			<p>There are many algorithms for finding the shortest path between two nodes in a network. There are also variants for finding the maximum <span class="No-Break">weighted path.</span></p>
			<p>There are several related problems regarding<a id="_idIndexMarker542"/> finding the paths in a network, such as the <em class="italic">traveling salesperson problem</em> and the <em class="italic">route inspection problem</em>. In the traveling salesperson problem, we <a id="_idIndexMarker543"/>find a cycle (a path starting and ending at the same node) that visits every node in the network, with the smallest (or largest) total weight. In the route inspection problem, we seek the shortest cycle (by weight) that traverses every edge in the network and returns to the starting point. The traveling salesperson problem is known to be NP-hard, but the route inspection problem can be solved in <span class="No-Break">polynomial time.</span></p>
			<p>A famous problem in graph theory is the bridges at Königsberg, which asks to find a path in a network that traverses every edge in the network exactly once. It turns out, as proved by Euler, that finding such a path in the Königsberg bridges problem is impossible. A path that traverses every edge exactly once is called <a id="_idIndexMarker544"/>an <em class="italic">Eulerian circuit</em>. A network that admits an Eulerian circuit is <a id="_idIndexMarker545"/>called <em class="italic">Eulerian</em>. A network is Eulerian if and only if every node has an even degree. The network representation of the Königsberg bridge problem<a id="_idIndexMarker546"/> can be seen in the following figure. The edges in this figure represent the different bridges over the rivers, while the nodes represent the different land masses. We can see that all four of the nodes have an odd degree, which means that there cannot be a path that crosses every edge <span class="No-Break">exactly once:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer728">
					<img alt="Figure 5.5 – A network representing the Königsberg bridge problem&#13;&#10;" src="image/5.5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – A network representing the Königsberg bridge problem</p>
			<p>The edges represent the bridges between the different land masses represented by <span class="No-Break">the nodes.</span></p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Quantifying clustering in a network</h1>
			<p>There are <a id="_idIndexMarker547"/>various quantities associated with networks that <a id="_idIndexMarker548"/>measure the characteristics of the network. For example, the clustering coefficient of a node measures the interconnectivity between the nodes nearby (here, nearby means connected by an edge). In effect, it measures how close the neighboring nodes are to forming a complete network <span class="No-Break">or </span><span class="No-Break"><em class="italic">clique</em></span><span class="No-Break">.</span></p>
			<p>The clustering coefficient of a node measures the proportion of the adjacent nodes that are connected by an edge; that is, two adjacent nodes form a triangle with the given node. We count the number of triangles and divide this by the total number of possible triangles that could be formed, given the degree of the node. Numerically, the clustering coefficient at a node, <img alt="" src="image/Formula_05_022.png"/>, in a simple unweighted network is given by the <span class="No-Break">following equation:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer730">
					<img alt="" src="image/Formula_05_023.jpg"/>
				</div>
			</div>
			<p>Here, <img alt="" src="image/Formula_05_024.png"/> is the number of triangles at <img alt="" src="image/Formula_05_025.png"/> and the denominator is the total possible number of triangles at <img alt="" src="image/Formula_05_025.png"/>. If the degree of <img alt="" src="image/Formula_05_025.png"/> (the number of edges from <img alt="" src="image/Formula_05_025.png"/>) is 0 or 1, then we set <img alt="" src="image/Formula_05_029.png"/> <span class="No-Break">to 0.</span></p>
			<p>In this recipe, we will learn how to compute the clustering coefficient of a node in <span class="No-Break">a network.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>Getting ready</h2>
			<p>For this <a id="_idIndexMarker549"/>recipe, we will need the NetworkX package under the <strong class="source-inline">nx</strong> alias and the <a id="_idIndexMarker550"/>Matplotlib <strong class="source-inline">pyplot</strong> module imported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>How to do it...</h2>
			<p>The following<a id="_idIndexMarker551"/> steps show you how to compute the clustering <a id="_idIndexMarker552"/>coefficient of a node in <span class="No-Break">a network:</span></p>
			<ol>
				<li value="1">First, we need to create a sample network to <span class="No-Break">work with:</span><pre class="console">
G = nx.Graph()</pre><pre class="console">
complete_part = nx.complete_graph(4)</pre><pre class="console">
cycle_part = nx.cycle_graph(range(4, 9))</pre><pre class="console">
G.update(complete_part)</pre><pre class="console">
G.update(cycle_part)</pre><pre class="console">
G.add_edges_from([(0, 8), (3, 4)])</pre></li>
				<li>Next, we must draw the network so that we can compare the clustering coefficients that we’ll be calculating. This will allow us to see how these nodes appear in <span class="No-Break">the network:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
nx.draw_circular(G, ax=ax, with_labels=True)</pre><pre class="console">
ax.set_title("Network with different clustering behavior")</pre></li>
			</ol>
			<p>The resulting plot can be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer737">
					<img alt="Figure 5.6 – A sample network for testing clustering&#13;&#10;" src="image/5.6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – A sample network for testing clustering</p>
			<ol>
				<li value="3">Now, we <a id="_idIndexMarker553"/>can compute the clustering coefficients of the<a id="_idIndexMarker554"/> nodes in the network using the <span class="No-Break"><strong class="source-inline">nx.clustering</strong></span><span class="No-Break"> routine:</span><pre class="console">
cluster_coeffs = nx.clustering(G)</pre></li>
				<li>The output of the <strong class="source-inline">nx.clustering</strong> routine is a dictionary over the nodes in the network. So, we can print some selected nodes <span class="No-Break">as follows:</span><pre class="console">
for i in [0, 2, 6]:</pre><pre class="console">
    print(f"Node {i}, clustering {cluster_coeffs[i]}")</pre><pre class="console">
# Node 0, clustering 0.5</pre><pre class="console">
# Node 2, clustering 1.0</pre><pre class="console">
# Node 6, clustering 0</pre></li>
				<li>The average clustering coefficient for all the nodes in the network can be computed using the <span class="No-Break"><strong class="source-inline">nx.average_clustering</strong></span><span class="No-Break"> routine:</span><pre class="console">
av_clustering = nx.average_clustering(G)</pre><pre class="console">
print(av_clustering)</pre><pre class="console">
# 0.3333333333333333</pre></li>
			</ol>
			<p>This average clustering coefficient indicates that, on average, the nodes have approximately 1/3 of the total <span class="No-Break">possible connections.</span></p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>How it works...</h2>
			<p>The<a id="_idIndexMarker555"/> clustering coefficient of a node measures how close the<a id="_idIndexMarker556"/> neighborhood of that node is to being a complete network (all the nodes are connected). In this recipe, we have three different computed values: 0 has a clustering coefficient of 0.5, 2 has a clustering coefficient of 1.0, and 6 has a clustering coefficient of 0. This means that the nodes connected to node 2 form a complete network, which is because we designed our network in this way. (Nodes 0 to 4 form a complete network by design.) The neighborhood of node 6 is very far from being complete since there are no interconnecting edges between either of <span class="No-Break">its neighbors.</span></p>
			<p>The average clustering value is a simple average of the clustering coefficients over all the nodes in the network. It is not quite the same as the global clustering coefficient (computed using the <strong class="source-inline">nx.transitivity</strong> routine in NetworkX), but it does give us an idea of how close the network is to being a complete network as a whole. The global clustering coefficient measures the ratio of the number of triangles to the number of triplets – a collection of three nodes that are connected by at least two edges – over the <span class="No-Break">whole network.</span></p>
			<p>The difference between global clustering and average clustering is quite subtle. The global clustering <a id="_idIndexMarker557"/>coefficient measures the clustering of the network as a whole, but the average clustering coefficient measures how much, on average, the network is locally clustered. The <a id="_idIndexMarker558"/>difference is best seen in a windmill network, which consists of a single node surrounded by a circle of an even number of nodes. All the nodes are connected to the center, but the nodes on the circle are only connected in an alternating pattern. The outer nodes have a local clustering coefficient of 1, while the center node has a local clustering coefficient of <img alt="" src="image/Formula_05_030.png"/>, where <img alt="" src="image/Formula_05_031.png"/> denotes the number of triangles joining the center node. However, the global clustering coefficient <span class="No-Break">is <img alt="" src="image/Formula_05_032.png"/></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/>There’s more...</h2>
			<p>Clustering coefficients are related to <em class="italic">cliques</em> in a network. A clique <a id="_idIndexMarker559"/>is a subnetwork that is complete (all the nodes are connected by an edge). An important problem in network theory is finding the maximal cliques in a network, which is a very difficult problem in general (here, maximal means <em class="italic">cannot be </em><span class="No-Break"><em class="italic">made larger</em></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor216"/>Coloring a network</h1>
			<p>Networks are also useful in scheduling problems, where you need to arrange activities into different slots so that there are no conflicts. For example, we could use networks to schedule classes to make sure that students who are taking different options do not have to be in two classes at once. In this scenario, the nodes will represent the different classes and the edges will indicate that students are taking both classes. The process we use to solve these kinds of problems is <a id="_idIndexMarker560"/>called <em class="italic">network coloring</em>. This process involves assigning the fewest possible colors to the nodes in a network so that no two adjacent nodes have the <span class="No-Break">same color.</span></p>
			<p>In this recipe, we will learn how to color a network to solve a simple <span class="No-Break">scheduling problem.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>Getting ready</h2>
			<p>For this recipe, we need the NetworkX package imported under the <strong class="source-inline">nx</strong> alias and the Matplotlib <strong class="source-inline">pyplot</strong> module imported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/>How to do it...</h2>
			<p>Follow these steps to solve a network <span class="No-Break">coloring problem:</span></p>
			<ol>
				<li value="1">First, we will create a sample network to use in <span class="No-Break">this recipe:</span><pre class="console">
G = nx.complete_graph(3)</pre><pre class="console">
G.add_nodes_from(range(3, 7))</pre><pre class="console">
G.add_edges_from([</pre><pre class="console">
    (2, 3), (2, 4), (2, 6), (0, 3), (0, 6), (1, 6),</pre><pre class="console">
    (1, 5), (2, 5), (4, 5) ])</pre></li>
				<li>Next, we will draw the network so that we can understand the coloring when it is generated. For this, we will use the <span class="No-Break"><strong class="source-inline">draw_circular</strong></span><span class="No-Break"> routine:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
nx.draw_circular(G, ax=ax, with_labels=True)</pre><pre class="console">
ax.set_title("Scheduling network")</pre></li>
			</ol>
			<p>The resulting plot can<a id="_idIndexMarker561"/> be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer741">
					<img alt="Figure 5.7 – Example network for a simple scheduling problem&#13;&#10;" src="image/5.7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Example network for a simple scheduling problem</p>
			<ol>
				<li value="3">We will generate the coloring using the <span class="No-Break"><strong class="source-inline">nx.greedy_color</strong></span><span class="No-Break"> routine:</span><pre class="console">
coloring = nx.greedy_color(G)</pre><pre class="console">
print("Coloring", coloring)</pre><pre class="console">
# Coloring {2: 0, 0: 1, 1: 2, 5: 1, 6: 3, 3: 2, 4: 2}</pre></li>
				<li>To see the actual colors that were used in this coloring, we will generate a set of values from the <span class="No-Break"><strong class="source-inline">coloring</strong></span><span class="No-Break"> dictionary:</span><pre class="console">
different_colors = set(coloring.values())</pre><pre class="console">
print("Different colors", different_colors)</pre><pre class="console">
# Different colors {0, 1, 2, 3}</pre></li>
			</ol>
			<p>Notice that the number of colors in the coloring cannot be smaller since nodes 0, 1, 2, and 6 form a complete network – each of these nodes is connected to the others, so each of them requires a <span class="No-Break">separate color.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/>How it works...</h2>
			<p>The <strong class="source-inline">nx.greedy_color</strong> routine colors the network using one of several possible strategies. By default, it works in order of degree from largest to smallest. In our case, it started by assigning color 0 to node 2, which has a degree of 6, then color 1 to node 0, which has a degree of 4, and so on. The first available color is chosen for each node in this sequence. This is not necessarily the most efficient algorithm for coloring <span class="No-Break">a network.</span></p>
			<p>Any network can be colored by <a id="_idIndexMarker562"/>assigning every node a different color, but in most cases, fewer colors are necessary. In the recipe, the network has seven nodes, but only four colors are required. The smallest number of colors necessary is called<a id="_idIndexMarker563"/> the <strong class="bold">chromatic number</strong> of <span class="No-Break">the network.</span></p>
			<p>The problem we have described <a id="_idIndexMarker564"/>here is the <em class="italic">node coloring</em> problem. There is a related problem known <a id="_idIndexMarker565"/>as <em class="italic">edge coloring</em>. We can turn an edge coloring problem into a node coloring problem by considering the network whose nodes are the edges of the original network, with an edge between two of these notes added whenever the edges share a common node in the <span class="No-Break">original network.</span></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>There’s more...</h2>
			<p>There are several variations of the coloring problem for networks. One such variation is the <strong class="bold">list coloring problem</strong>, in which<a id="_idIndexMarker566"/> we seek a coloring for a network where each node is given a color from a predefined list of possible colors. This problem is more difficult than the general <span class="No-Break">coloring problem.</span></p>
			<p>The general coloring problem has surprising results. For example, every planar network can be colored by, at most, four different colors. This is a famous theorem from graph theory called the <strong class="bold">four-color theorem</strong>, which<a id="_idIndexMarker567"/> was proved by Appel and Haken in 1977. This theorem states that every planar graph has a chromatic number that is no larger <span class="No-Break">than 4.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor221"/>Finding minimal spanning trees and dominating sets</h1>
			<p>Networks have applications for a wide variety of problems. Two obvious areas that see many applications are communication and distribution. For example, we might wish to find a way of distributing goods to several cities (nodes) in a road network that covers the smallest distance from a particular point. For problems like this, we need to look at minimal spanning trees and <span class="No-Break">dominating sets.</span></p>
			<p>In this recipe, we <a id="_idIndexMarker568"/>will find a minimal spanning tree and a dominating set in <span class="No-Break">a network.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Getting ready</h2>
			<p>For this recipe, we need to import the NetworkX package under the <strong class="source-inline">nx</strong> alias and the Matplotlib <strong class="source-inline">pyplot</strong> module <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>How to do it...</h2>
			<p>Follow these steps to find a minimum spanning tree and dominating set for <span class="No-Break">a network:</span></p>
			<ol>
				<li value="1">First, we will create a sample network <span class="No-Break">to analyze:</span><pre class="console">
G = nx.gnm_random_graph(15, 22, seed=12345)</pre></li>
				<li>Next, as usual, we will draw the network before doing <span class="No-Break">any analysis:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
pos = nx.circular_layout(G)</pre><pre class="console">
nx.draw(G, pos=pos, ax=ax, with_labels=True, style="--")</pre><pre class="console">
ax.set_title("Network with minimum spanning tree overlaid")</pre></li>
				<li>The <a id="_idIndexMarker569"/>minimum spanning tree can be computed using the <span class="No-Break"><strong class="source-inline">nx.minimum_</strong></span><span class="No-Break"><strong class="source-inline">spanning_tree</strong></span><span class="No-Break"> routine:</span><pre class="console">
min_span_tree = nx.minimum_spanning_tree(G)</pre><pre class="console">
print(list(min_span_tree.edges))</pre><pre class="console">
# [(0, 13), (0, 7), (0, 5), (1, 13), (1, 11),</pre><pre class="console">
#    (2, 5), (2, 9), (2, 8), (2, 3), (2, 12),</pre><pre class="console">
#    (3, 4), (4, 6), (5, 14), (8, 10)]</pre></li>
				<li>Next, we will overlay the edges of the minimum spanning tree onto <span class="No-Break">the plot:</span><pre class="console">
nx.draw_networkx_edges(min_span_tree, pos=pos,</pre><pre class="console">
                       ax=ax,width=2.)</pre></li>
				<li>Finally, we will find a dominating set – a set where every node in the network is adjacent to at least one node from the set – for the network using the <span class="No-Break"><strong class="source-inline">nx.dominating_set</strong></span><span class="No-Break"> routine:</span><pre class="console">
dominating_set = nx.dominating_set(G)</pre><pre class="console">
print("Dominating set", dominating_set)</pre><pre class="console">
# Dominating set {0, 1, 2, 4, 10, 14}</pre></li>
			</ol>
			<p>A plot of the network with the minimum spanning tree overlaid can be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer742">
					<img alt="Figure 5.8 – The network drawn with the minimum spanning tree overlaid&#13;&#10;" src="image/5.8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The network drawn with the minimum spanning tree overlaid</p>
			<p>The <a id="_idIndexMarker570"/>edges used in the minimum spanning tree are the bold unbroken lines, and the edges from the original network are the dashed lines. The fact that the minimum spanning tree is indeed a tree is slightly obscured by the layout, but we can easily trace through and see that no two nodes connected to a single parent node <span class="No-Break">are connected.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>How it works...</h2>
			<p>The <em class="italic">spanning tree</em> of <a id="_idIndexMarker571"/>a network is a tree contained in the network that contains all the nodes. A <em class="italic">minimum</em> spanning tree<a id="_idIndexMarker572"/> is a spanning tree that contains the fewest edges possible – or has the lowest total weight. Minimum spanning trees are useful for distribution problems over a network. A simple algorithm for finding minimum spanning trees is to simply select the edges (of the smallest weight first, if the network is weighted) in such a way that it does not create cycles until this is no <span class="No-Break">longer possible.</span></p>
			<p>A <em class="italic">dominating set</em> for a network<a id="_idIndexMarker573"/> is a set of vertices where every node in the network is adjacent to at least one node in the dominating set. Dominating sets have applications in communication networks. We are often interested in finding minimal dominating sets, but this is computationally difficult. Testing whether there is a dominating set that’s smaller than a given size is NP-complete. However, there are some efficient algorithms for finding the smallest dominating sets for certain classes of graphs. Informally speaking, the problem is that once you’ve identified a candidate for a minimum-size dominating set, you have to verify that there are no dominating sets that are smaller in size. This is very difficult if you do not know all the possible dominating sets <span class="No-Break">in advance.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Further reading</h1>
			<p>There are several classical texts on graph theory, including books by Bollobás <span class="No-Break">and Diestel:</span></p>
			<ul>
				<li>Diestel, R., 2010. <em class="italic">Graph Theory</em>. 3rd ed. <span class="No-Break">Berlin: Springer.</span></li>
				<li>Bollobás, B., 2010. <em class="italic">Modern Graph Theory</em>. New York, <span class="No-Break">NY: Springer.</span></li>
			</ul>
		</div>
	</body></html>