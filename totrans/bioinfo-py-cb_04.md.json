["```py\n    from Bio import Entrez, SeqIO\n    Entrez.email = 'put@your.email.here'\n    ```", "```py\n    handle = Entrez.esearch(db='nucleotide', term='CRT[Gene Name] AND \"Plasmodium falciparum\"[Organism]')\n    rec_list = Entrez.read(handle)\n    if int(rec_list['RetMax']) < int(rec_list['Count']):\n        handle = Entrez.esearch(db='nucleotide', term='CRT[Gene Name] AND \"Plasmodium falciparum\"[Organism]', retmax=rec_list['Count'])\n        rec_list = Entrez.read(handle)\n    ```", "```py\n    id_list = rec_list['IdList']\n    hdl = Entrez.efetch(db='nucleotide', id=id_list, rettype='gb')\n    ```", "```py\n    recs = list(SeqIO.parse(hdl, 'gb'))\n    ```", "```py\n    for rec in recs:\n        if rec.name == 'KM288867':\n            break\n    print(rec.name)\n    print(rec.description)\n    ```", "```py\n    for feature in rec.features:\n         if feature.type == 'gene':\n             print(feature.qualifiers['gene'])\n         elif feature.type == 'exon':\n             loc = feature.location\n             print(loc.start, loc.end, loc.strand)\n         else:\n             print('not processed:\\n%s' % feature)\n    ```", "```py\n    for name, value in rec.annotations.items():\n        print('%s=%s' % (name, value))\n    ```", "```py\n    print(len(rec.seq))\n    ```", "```py\nfrom Bio import Medline\nrefs = rec.annotations['references']\nfor ref in refs:\n    if ref.pubmed_id != '':\n        print(ref.pubmed_id)\n        handle = Entrez.efetch(db='pubmed', id=[ref.pubmed_id], rettype='medline', retmode='text')\n        records = Medline.parse(handle)\n        for med_rec in records:\n            for k, v in med_rec.items():\n                print('%s: %s' % (k, v))\n```", "```py\nfrom Bio import Entrez, SeqIO, SeqRecord\nEntrez.email = \"your@email.here\"\nhdl = Entrez.efetch(db='nucleotide', id=['NM_002299'], rettype='gb') # Lactase gene\ngb_rec = SeqIO.read(hdl, 'gb')\n```", "```py\nfor feature in gb_rec.features:\n    if feature.type == 'CDS':\n        location = feature.location  # Note translation existing\ncds = SeqRecord.SeqRecord(gb_rec.seq[location.start:location.end], 'NM_002299', description='LCT CDS only')\n```", "```py\n    from Bio import SeqIO\n    w_hdl = open('example.fasta', 'w')\n    SeqIO.write([cds], w_hdl, 'fasta')\n    w_hdl.close()\n    ```", "```py\n    recs = SeqIO.parse('example.fasta', 'fasta')\n    for rec in recs:\n        seq = rec.seq\n        print(rec.description)\n        print(seq[:10])\n    ```", "```py\nNM_002299 LCT CDS only\n ATGGAGCTGT\n```", "```py\n    rna = seq.transcribe()\n    print(rna)\n    ```", "```py\n    prot = seq.translate()\n    print(prot)\n    ```", "```py\n@SRR003258.1 30443AAXX:1:1:1053:1999 length=51\n ACCCCCCCCCACCCCCCCCCCCCCCCCCCCCCCCCCCACACACACCAACAC\n +\n =IIIIIIIII5IIIIIII>IIII+GIIIIIIIIIIIIII(IIIII01&III\n```", "```py\n    import gzip\n    from Bio import SeqIO\n    recs = SeqIO.parse(gzip.open('SRR003265.filt.fastq.gz'),'rt', encoding='utf-8'), 'fastq')\n    rec = next(recs)\n    print(rec.id, rec.description, rec.seq)\n    print(rec.letter_annotations)\n    ```", "```py\nrecs = list(recs) # do not do it!\n```", "```py\n    from collections import defaultdict\n    recs = SeqIO.parse(gzip.open('SRR003265.filt.fastq.gz', 'rt', encoding='utf-8'), 'fastq')\n    cnt = defaultdict(int)\n    for rec in recs:\n        for letter in rec.seq:\n            cnt[letter] += 1\n    tot = sum(cnt.values())\n    for letter, cnt in cnt.items():\n        print('%s: %.2f %d' % (letter, 100\\. * cnt / tot, cnt))\n    ```", "```py\n    import seaborn as sns\n    import matplotlib.pyplot as plt\n    recs = SeqIO.parse(gzip.open('SRR003265.filt.fastq.gz', 'rt', encoding='utf-8'), 'fastq')\n    n_cnt = defaultdict(int)\n    for rec in recs:\n        for i, letter in enumerate(rec.seq):\n            pos = i + 1\n            if letter == 'N':\n                n_cnt[pos] += 1\n    seq_len = max(n_cnt.keys())\n    positions = range(1, seq_len + 1)\n    fig, ax = plt.subplots(figsize=(16,9))\n    ax.plot(positions, [n_cnt[x] for x in positions])\n    fig.suptitle('Number of N calls as a function of the distance from the start of the sequencer read')\n    ax.set_xlim(1, seq_len)\n    ax.set_xlabel('Read distance')\n    ax.set_ylabel('Number of N Calls')\n    ```", "```py\n    recs = SeqIO.parse(gzip.open('SRR003265.filt.fastq.gz', 'rt', encoding='utf-8'), 'fastq')\n    cnt_qual = defaultdict(int)\n    for rec in recs:\n        for i, qual in enumerate(rec.letter_annotations['phred_quality']):\n            if i < 25:\n                continue\n            cnt_qual[qual] += 1\n    tot = sum(cnt_qual.values())\n    for qual, cnt in cnt_qual.items():\n        print('%d: %.2f %d' % (qual, 100\\. * cnt / tot, cnt))\n    ```", "```py\n    recs = SeqIO.parse(gzip.open('SRR003265.filt.fastq.gz', 'rt', encoding='utf-8'), 'fastq')\n    qual_pos = defaultdict(list)\n    for rec in recs:\n        for i, qual in enumerate(rec.letter_annotations['phred_quality']):\n            if i < 25 or qual == 40:\n               continue\n            pos = i + 1\n            qual_pos[pos].append(qual)\n    vps = []\n    poses = list(qual_pos.keys())\n    poses.sort()\n    for pos in poses:\n        vps.append(qual_pos[pos])\n    fig, ax = plt.subplots(figsize=(16,9))\n    sns.boxplot(data=vps, ax=ax)\n    ax.set_xticklabels([str(x) for x in range(26, max(qual_pos.keys()) + 1)])\n    ax.set_xlabel('Read distance')\n    ax.set_ylabel('PHRED score')\n    fig.suptitle('Distribution of PHRED scores as a function of read distance')\n    ```", "```py\nf1 = gzip.open('X_1.filt.fastq.gz', 'rt, enconding='utf-8')\nf2 = gzip.open('X_2.filt.fastq.gz', 'rt, enconding='utf-8')\nrecs1 = SeqIO.parse(f1, 'fastq')\nrecs2 = SeqIO.parse(f2, 'fastq')\ncnt = 0\nfor rec1, rec2 in zip(recs1, recs2):\n    cnt +=1\nprint('Number of pairs: %d' % cnt)\n```", "```py\nconda install –c bioconda pysam\n```", "```py\n    import pysam\n    bam = pysam.AlignmentFile('NA18489.chrom20.ILLUMINA.bwa.YRI.exome.20121211.bam', 'rb')\n    headers = bam.header\n    for record_type, records in headers.items():\n        print (record_type)\n        for i, record in enumerate(records):\n            if type(record) == dict:\n                print('\\t%d' % (i + 1))\n                for field, value in record.items():\n                    print('\\t\\t%s\\t%s' % (field, value))\n            else:\n                print('\\t\\t%s' % record)\n    ```", "```py\n    for rec in bam:\n        if rec.cigarstring.find('M') > -1 and rec.cigarstring.find('S') > -1 and not rec.is_unmapped and not rec.mate_is_unmapped:\n        break\n    print(rec.query_name, rec.reference_id, bam.getrname(rec.reference_id), rec.reference_start, rec.reference_end)\n    print(rec.cigarstring)\n    print(rec.query_alignment_start, rec.query_alignment_end, rec.query_alignment_length)\n    print(rec.next_reference_id, rec.next_reference_start,rec.template_length)\n    print(rec.is_paired, rec.is_proper_pair, rec.is_unmapped, rec.mapping_quality)\n    print(rec.query_qualities)\n    print(rec.query_alignment_qualities)\n    print(rec.query_sequence)\n    ```", "```py\n    import seaborn as sns\n    import matplotlib.pyplot as plt\n    counts = [0] * 76\n    for n, rec in enumerate(bam.fetch('20', 0, 10000000)):\n        for i in range(rec.query_alignment_start, rec.query_alignment_end):\n            counts[i] += 1\n    freqs = [x / (n + 1.) for x in counts]\n    fig, ax = plt.subplots(figsize=(16,9))\n    ax.plot(range(1, 77), freqs)\n    ax.set_xlabel('Read distance')\n    ax.set_ylabel('PHRED score')\n    fig.suptitle('Percentage of mapped calls as a function of the position from the start of the sequencer read')\n    ```", "```py\n    from collections import defaultdict\n    import numpy as np\n    phreds = defaultdict(list)\n    for rec in bam.fetch('20', 0, None):\n        for i in range(rec.query_alignment_start, rec.query_alignment_end):\n            phreds[i].append(rec.query_qualities[i])\n    maxs = [max(phreds[i]) for i in range(76)]\n    tops = [np.percentile(phreds[i], 95) for i in range(76)]\n    medians = [np.percentile(phreds[i], 50) for i in range(76)]\n    bottoms = [np.percentile(phreds[i], 5) for i in range(76)]\n    medians_fig = [x - y for x, y in zip(medians, bottoms)]\n    tops_fig = [x - y for x, y in zip(tops, medians)]\n    maxs_fig = [x - y for x, y in zip(maxs, tops)]\n    fig, ax = plt.subplots(figsize=(16,9))\n    ax.stackplot(range(1, 77), (bottoms, medians_fig,tops_fig))\n    ax.plot(range(1, 77), maxs, 'k-')\n    ax.set_xlabel('Read distance')\n    ax.set_ylabel('PHRED score')\n    fig.suptitle('Distribution of PHRED scores as a function of the position in the read')\n    ```", "```py\ntabix -fh ftp://ftp-\ntrace.ncbi.nih.gov/1000genomes/ftp/release/20130502/supporting/vcf_with_sample_level_annotation/ALL.chr22.phase3_shapeit2_mvncall_integrated_v5_extra_anno.20130502.genotypes.vcf.gz 22:1-17000000 | bgzip -c > genotypes.vcf.gz\ntabix -p vcf genotypes.vcf.gz\n```", "```py\nconda install –c bioconda cyvcf2\n```", "```py\n    from cyvcf2 import VCF\n    v = VCF('genotypes.vcf.gz')\n    rec = next(v)\n    print('Variant Level information')\n    info = rec.INFO\n    for info in rec.INFO:\n        print(info)\n    print('Sample Level information')\n    for fmt in rec.FORMAT:\n        print(fmt)\n    ```", "```py\n    v = VCF('genotypes.vcf.gz')\n    samples = v.samples\n    print(len(samples))\n    variant = next(v)\n    print(variant.CHROM, variant.POS, variant.ID, variant.REF, variant.ALT, variant.QUAL, variant.FILTER)\n    print(variant.INFO)\n    print(variant.FORMAT)\n    print(variant.is_snp)\n    str_alleles = variant.gt_bases[0]\n    alleles = variant.genotypes[0][0:2]\n    is_phased = variant.genotypes[0][2]\n    print(str_alleles, alleles, is_phased)\n    print(variant.format('DP')[0])\n    ```", "```py\n    from collections import defaultdict\n    f = VCF('genotypes.vcf.gz')\n    my_type = defaultdict(int)\n    num_alts = defaultdict(int)\n    for variant in f:\n        my_type[variant.var_type, variant.var_subtype] += 1\n        if variant.var_type == 'snp':\n            num_alts[len(variant.ALT)] += 1\n    print(my_type)\n    ```", "```py\ntabix -fh ftp://ngs.sanger.ac.uk/production/ag1000g/phase1/preview/ag1000g.AC.phase1.AR1.vcf.gz 3L:1-200000 |bgzip -c > centro.vcf.gz\ntabix -fh ftp://ngs.sanger.ac.uk/production/ag1000g/phase1/preview/ag1000g.AC.phase1.AR1.vcf.gz 3L:21000001-21200000 |bgzip -c > standard.vcf.gz\ntabix -p vcf centro.vcf.gz\ntabix -p vcf standard.vcf.gz\n```", "```py\n    from collections import defaultdict\n    import functools\n    import numpy as np\n    import seaborn as sns\n    import matplotlib.pyplot as plt\n    from cyvcf2 import VCF\n    def do_window(recs, size, fun):\n        start = None\n        win_res = []\n        for rec in recs:\n            if not rec.is_snp or len(rec.ALT) > 1:\n                continue\n            if start is None:\n                start = rec.POS\n            my_win = 1 + (rec.POS - start) // size\n            while len(win_res) < my_win:\n                win_res.append([])\n            win_res[my_win - 1].extend(fun(rec))\n        return win_res\n    wins = {}\n    size = 2000\n    names = ['centro.vcf.gz', 'standard.vcf.gz']\n    for name in names:\n     recs = VCF(name)\n     wins[name] = do_window(recs, size, lambda x: [1])\n    ```", "```py\n    def apply_win_funs(wins, funs):\n        fun_results = []\n        for win in wins:\n            my_funs = {}\n            for name, fun in funs.items():\n                try:\n                    my_funs[name] = fun(win)\n                except:\n                    my_funs[name] = None\n            fun_results.append(my_funs)\n        return fun_results\n    stats = {}\n    fig, ax = plt.subplots(figsize=(16, 9))\n    for name, nwins in wins.items():\n        stats[name] = apply_win_funs(nwins, {'sum': sum})\n        x_lim = [i * size for i in range(len(stats[name]))]\n        ax.plot(x_lim, [x['sum'] for x in stats[name]], label=name)\n    ax.legend()\n    ax.set_xlabel('Genomic location in the downloaded segment')\n    ax.set_ylabel('Number of variant sites (bi-allelic SNPs)')\n    fig.suptitle('Number of bi-allelic SNPs along the genome', fontsize='xx-large')\n    ```", "```py\n    mq0_wins = {}\n    size = 5000\n    def get_sample(rec, annot, my_type):\n        return [v for v in rec.format(annot) if v > np.iinfo(my_type).min]\n    for vcf_name in vcf_names:\n        recs = vcf.Reader(filename=vcf_name)\n        mq0_wins[vcf_name] = do_window(recs, size, functools.partial(get_sample, annot='MQ0', my_type=np.int32))\n    ```", "```py\n    stats = {}\n    colors = ['b', 'g']\n    i = 0\n    fig, ax = plt.subplots(figsize=(16, 9))\n    for name, nwins in mq0_wins.items():\n        stats[name] = apply_win_funs(nwins, {'median':np.median, '75': functools.partial(np.percentile, q=75)})\n        x_lim = [j * size for j in range(len(stats[name]))]\n        ax.plot(x_lim, [x['median'] for x in stats[name]], label=name, color=colors[i])\n        ax.plot(x_lim, [x['75'] for x in stats[name]], '--', color=colors[i])\n        i += 1\n    ax.legend()\n    ax.set_xlabel('Genomic location in the downloaded segment')\n    ax.set_ylabel('MQ0')\n    fig.suptitle('Distribution of MQ0 along the genome', fontsize='xx-large')\n    ```", "```py\ndef get_sample_relation(recs, f1, f2):\n    rel = defaultdict(int)\n    for rec in recs:\n        if not rec.is_snp:\n             continue\n        for pos in range(len(rec.genotypes)):\n            v1 = f1(rec, pos)\n            v2 = f2(rec, pos)\n            if v1 is None or v2 == np.iinfo(type(v2)).min:\n                continue  # We ignore Nones\n            rel[(v1, v2)] += 1\n            # careful with the size, floats: round?\n        #break\n    return rel get_sample_relation(recs, f1, f2):\nrels = {}\nfor vcf_name in vcf_names:\n    recs = VCF(filename=vcf_name)\n    rels[vcf_name] = get_sample_relation(\n        recs,\n        lambda rec, pos: 1 if rec.genotypes[pos][0] != rec.genotypes[pos][1] else 0,\n        lambda rec, pos: rec.format('DP')[pos][0])\n```", "```py\n    def plot_hz_rel(dps, ax, ax2, name, rel):\n        frac_hz = []\n        cnt_dp = []\n        for dp in dps:\n            hz = 0.0\n            cnt = 0\n            for khz, kdp in rel.keys():\n                if kdp != dp:\n                    continue\n                cnt += rel[(khz, dp)]\n                if khz == 1:\n                    hz += rel[(khz, dp)]\n            frac_hz.append(hz / cnt)\n            cnt_dp.append(cnt)\n        ax.plot(dps, frac_hz, label=name)\n        ax2.plot(dps, cnt_dp, '--', label=name)\n    ```", "```py\n    fig, ax = plt.subplots(figsize=(16, 9))\n    ax2 = ax.twinx()\n    for name, rel in rels.items():\n        dps = list(set([x[1] for x in rel.keys()]))\n    dps.sort()\n    plot_hz_rel(dps, ax, ax2, name, rel)\n    ax.set_xlim(0, 75)\n    ax.set_ylim(0, 0.2)\n    ax2.set_ylabel('Quantity of calls')\n    ax.set_ylabel('Fraction of Heterozygote calls')\n    ax.set_xlabel('Sample Read Depth (DP)')\n    ax.legend()\n    fig.suptitle('Number of calls per depth and fraction of calls which are Hz', fontsize='xx-large')\n    ```", "```py\n    def get_variant_relation(recs, f1, f2):\n        rel = defaultdict(int)\n        for rec in recs:\n            if not rec.is_snp:\n                continue\n        try:\n            v1 = f1(rec)\n            v2 = f2(rec)\n            if v1 is None or v2 is None:\n                continue # We ignore Nones\n            rel[(v1, v2)] += 1\n        except:\n            pass\n        return rel\n    ```", "```py\naccepted_eff = ['INTERGENIC', 'INTRON', 'NON_SYNONYMOUS_CODING', 'SYNONYMOUS_CODING']\ndef eff_to_int(rec):\n    try:\n        annot = rec.INFO['EFF']\n        master_type = annot.split('(')[0]\n        return accepted_eff.index(master_type)\n    except ValueError:\n        return len(accepted_eff)\n```", "```py\n    eff_mq0s = {}\n    for vcf_name in vcf_names:\n        recs = VCF(filename=vcf_name)\n        eff_mq0s[vcf_name] = get_variant_relation(recs, lambda r: eff_to_int(r), lambda r: int(r.INFO['DP']))\n    ```", "```py\n    fig, ax = plt.subplots(figsize=(16,9))\n    vcf_name = 'standard.vcf.gz'\n    bp_vals = [[] for x in range(len(accepted_eff) + 1)]\n    for k, cnt in eff_mq0s[vcf_name].items():\n        my_eff, mq0 = k\n        bp_vals[my_eff].extend([mq0] * cnt)\n    sns.boxplot(data=bp_vals, sym='', ax=ax)\n    ax.set_xticklabels(accepted_eff + ['OTHER'])\n    ax.set_ylabel('DP (variant)')\n    fig.suptitle('Distribution of variant DP per SNP type', fontsize='xx-large')\n    ```", "```py\ntrack name=gene description=\"Gene information\"\n 2       135836529       135837180       ENSE00002202258 0       -\n 2       135833110       135833190       ENSE00001660765 0       -\n 2       135789570       135789798       NM_002299.2.16  0       -\n 2       135787844       135788544       NM_002299.2.17  0       -\n 2       135836529       135837169       CCDS2178.117    0       -\n 2       135833110       135833190       CCDS2178.116    0       -\n```", "```py\nconda install –c bioconda htseq\n```", "```py\n    from collections import defaultdict\n    import re\n    import HTSeq\n    lct_bed = HTSeq.BED_Reader('LCT.bed')\n    ```", "```py\n    feature_types = defaultdict(int)\n    for rec in lct_bed:\n        last_rec = rec\n        feature_types[re.search('([A-Z]+)', rec.name).group(0)] += 1\n    print(feature_types)\n    ```", "```py\ndefaultdict(<class 'int'>, {'ENSE': 27, 'NM': 17, 'CCDS': 17})\n```", "```py\n    print(last_rec)\n    print(last_rec.name)\n    print(type(last_rec))\n    interval = last_rec.iv\n    print(interval)\n    print(type(interval))\n    ```", "```py\n<GenomicFeature: BED line 'CCDS2178.11' at 2: 135788543 -> 135788322 (strand '-')>\n CCDS2178.11\n <class 'HTSeq.GenomicFeature'>\n 2:[135788323,135788544)/-\n <class 'HTSeq._HTSeq.GenomicInterval'>\n```", "```py\n    print(interval.chrom, interval.start, interval.end)\n    print(interval.strand)\n    print(interval.length)\n    print(interval.start_d)\n    print(interval.start_as_pos)\n    print(type(interval.start_as_pos))\n    ```", "```py\n2 135788323 135788544\n -\n 221\n 135788543\n 2:135788323/-\n <class 'HTSeq._HTSeq.GenomicPosition'>\n```", "```py\nexon_start = None\nexon_end = None\nsizes = []\nfor rec in lct_bed:\n    if not rec.name.startswith('CCDS'):\n        continue\n    interval = rec.iv\n    exon_start = min(interval.start, exon_start or interval.start)\n    exon_end = max(interval.length, exon_end or interval.end)\n    sizes.append(interval.length)\nsizes.sort()\nprint(\"Num exons: %d / Begin: %d / End %d\" % (len(sizes), exon_start, exon_end))\nprint(\"Smaller exon: %d / Larger exon: %d / Mean size: %.1f\" % (sizes[0], sizes[-1], sum(sizes)/len(sizes)))\n```", "```py\nNum exons: 17 / Begin: 135788323 / End 135837169\n Smaller exon: 79 / Larger exon: 1551 / Mean size: 340.2\n```"]