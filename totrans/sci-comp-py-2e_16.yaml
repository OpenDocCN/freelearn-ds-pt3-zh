- en: Symbolic Computations - SymPy
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will give a brief introduction to using Python for symbolic
    computations. There is powerful software on the market for performing symbolic
    computations, for example, Maple™ or Mathematica™. But sometimes, it might be
    favorable to make symbolic calculations in the language or framework you are used
    to. At this stage of the book, we assume that this language is Python, so we seek
    a tool in Python—the module SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: A complete description of SymPy, if even possible, would fill an entire book,
    and that is not the purpose of this chapter. Instead, we will stake out a path
    into this tool by examining some guiding examples, giving a flavor of the potential
    of this tool as a complement to NumPy and SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 What are symbolic computations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All computations we did so far in this book were so-called numeric computations.
    These were a sequence of operations mainly on floating-point numbers. It is the
    nature of numeric computations that the result is an approximation of the exact
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic computations operate on formulas or symbols by transforming them as
    taught in algebra or calculus into other formulas. The last step of these transformations
    might then require that numbers are inserted and a numeric evaluation is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We illustrate the difference by computing this definite integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e541523-3e99-444e-8518-72719cb7a212.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Symbolically this expression can be transformed by considering the primitive
    function of the integrand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/136a2183-869c-4bea-9ed8-7e88338f8fb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now obtain a formula for the definite integral by inserting the integral
    bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b24fc4d8-f270-4bff-ab7b-f80f61ec4949.png)'
  prefs: []
  type: TYPE_IMG
- en: This is called a closed-form expression for the integral. Very few mathematical
    problems have a solution that can be given in a closed-form expression. It is
    the exact value of the integral without any approximation. Also, no error is introduced
    by representing real numbers as floating-point numbers, which would otherwise
    introduce round-off errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Approximation and round-off come into play at the very last moment, when this
    expression needs to be evaluated. The square root and the *arctan* can only be
    evaluated approximately by numerical methods. Such an evaluation gives the final
    result up to a certain (often unknown) precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f38ec7ea-892d-4253-820e-8278a24de278.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, numerical computation would directly approximate the definite
    integral by some approximation method, for example, Simpson''s rule, and deliver
    a numeric result, often with an estimate of error. In Python, this is done by
    these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: They return the value [![](img/5cb34e56-2413-4cbf-a974-1d7aa4b7d1d1.png)] and
    an estimate for the error bound [![](img/4cbcec0e-c1e6-415f-b92e-40da53f782ea.png)]*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram (*Figure 16.1*) shows the comparison of the numeric and
    symbolic approximations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9bd0385-f8ad-4d45-9a0a-68c897d580fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Symbolic and numeric quadrature'
  prefs: []
  type: TYPE_NORMAL
- en: 16.1.1 Elaborating an example in SymPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, let's elaborate on the previous example in SymPy and explain
    the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command makes sure that formulas are presented in a graphical way,
    if possible. Then, we generate a symbol and define the integrand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`x` is now a Python object of type `Symbol` and `f` is a SymPy `Lambda` function
    (note the command starting with a capital letter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we start with the symbolic computation of the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your working environment, the result is presented in different
    ways; see the following screenshot (*Figure 16.2*), which represents two different
    results of a SymPy formula in different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61592d97-d85f-4fb2-bb2f-7c177778629d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Two screenshots of a SymPy presentation of formula in two different
    environments'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check by differentiation whether the result is correct. To this end,
    we assign a name to the primitive function and differentiate with respect to ![](img/1618222e-1bbe-4fb4-8342-4f4d2261bf0a.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result obtained will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99763022-847a-4874-84d2-f502ea8eb61e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Which can be simplified by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0acf16ff-1cf7-483e-aa59-4569326b1970.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the result we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definite integral is obtained by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the following output after simplification with `simplify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/879b6eed-a37e-405d-8375-9a5343e23cea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To obtain a numerical value, we finally evaluate this expression to a floating-point
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 16.2 Basic elements of SymPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we introduce the basic elements of SymPy. You will find it favorable to
    be already familiar with classes and data types in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.1 Symbols – the basis of all formulas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic construction element to build a formula in SymPy is the symbol. As
    we saw in the introductory example, a symbol is created by the command `symbols`.
    This SymPy command generates symbol objects from a given string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is actually a short form of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Followed by an unpacking step to obtain variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments of the command define the string representation of the symbol.
    The variable name of the symbol chosen is often identical to its string representation,
    but this is not required by the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we also defined that the symbol is assumed to be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An entire set of symbols can be defined in a very compact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, symbols for indexed variables can be defined by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a tuple of symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71f68d7f-b2f6-41b8-afe5-64ecdf84348d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The rules for the range of the indexes are those we saw earlier in this book
    when working with slices (see [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *Slicing**,* for more details).'
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.2 Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python evaluates operations on numbers directly and introduces unavoidable
    rounding errors. These would obstruct all symbolic calculations. This is avoided
    when we `sympify` numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `sympify` command converts an integer to an object of type `sympy.core.numbers.Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing **1/3** as an operation of two integers, it can also be represented
    directly as a rational number by `Rational(1,3)`.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2.3 Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy distinguishes between defined and undefined functions. The term undefined
    functions (which might be a bit misleading) refers to well-defined Python objects
    for generic functions that have no special properties.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a function with special properties is `atan` or the `Lambda` function
    used in the introductory example of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note the different names for the different implementations of the same mathematical
    function: `sympy.atan` and `scipy.arctan`.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A symbol for an undefined function is created by giving the `symbols` command
    an extra class argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved by using the constructor `Function` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With undefined functions, we can evaluate the general rules of calculus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s evaluate the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/689cb5c3-3743-4ad4-ad2d-696ebdb021f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is symbolically computed in Python by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the previous code returns the following as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df9fcf5-d204-48f3-8337-1d0270539196.png)'
  prefs: []
  type: TYPE_IMG
- en: This example shows how the product rule and the chain rule were applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use an undefined function as a function in several variables, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'which returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19994640-c42f-4bcf-92ac-f90628562304.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the use of the star operator to unpack a tuple to form *f* with arguments; see
    [Section 7.2.5](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Variable Number
    of Arguments*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using list comprehension, we can construct a list of all partial derivatives
    of [![](img/b097026c-fa3d-44d8-ae9c-b0e748c17a08.png)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a list with the elements of [![](img/90f569a5-38c2-4bf1-a20f-cecf98f7ef51.png)]
    (the gradient of ![](img/6b258487-c295-41cf-89ad-f94b0fef08e5.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/234a205a-53c2-4ff5-ba25-566ae553601e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The command can also be rewritten by using the method `diff` of the `Function` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method is Taylor series expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns Taylor''s formula, together with the rest term expressed by the
    Landau symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03334177-36ef-494b-bb9e-43a0984f1471.png)'
  prefs: []
  type: TYPE_IMG
- en: 16.2.4 Elementary functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Examples for elementary functions in SymPy are trigonometric functions and
    their inverses. The following example shows how `simplify` acts on an expression
    which includes elementary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of the use of elementary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use SciPy and SymPy together, we strongly recommend that you use them
    in different namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 16.2.5 Lambda functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Anonymous functions*,
    we saw how to define so-called anonymous functions in Python. The SymPy counterpart is
    the command `Lambda`. Note the difference; `lambda` is a keyword while `Lambda` is
    a constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: The command `Lambda` takes two arguments, the symbol of the function's independent
    variable, and a SymPy expression to evaluate the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that defines air resistance (also called drag) as a function
    of speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`f_drag` is displayed as a graphical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ae44672-2bd5-4ad4-9fd6-7c9023392d9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This function can be evaluated in the usual way by providing it with an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Which results in the expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c39440e8-bc2b-4de3-b2ee-bc078927e835.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to create functions in several variables by just providing
    the first parameter of `Lambda` with a tuple, as follows for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this function can be done in two ways, either by directly providing
    several arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or by unpacking a tuple or list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Matrix objects in SymPy even make it possible to define vector-valued functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables us to compute Jacobians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Which gives the following expression as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41952fb2-f56e-46dc-a96c-e271fadd03b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of more variables, it is convenient to use a more compact form
    to define the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 16.3 Symbolic linear algebra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbolic linear algebra is supported by SymPy's data type `matrix` which we
    will introduce first. Then we will present some linear algebra methods as examples
    for the broad spectrum of possibilities for symbolic computations in this field.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3.1 Symbolic matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly met the `matrix` data type when we discussed vector-valued functions.
    There, we saw it in its simplest form, which converts a list of lists into a matrix.
    To see an example, let''s construct a rotation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When working with SymPy matrices we have to note that the operator `*` performs
    matrix multiplications and is not acting as an elementwise multiplication, which
    is the case for NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previously defined rotation matrix can be checked for orthogonality by
    using this matrix multiplication and the transpose of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example shows how a matrix is transposed and how the identity
    matrix is created. Alternatively, we could have checked whether its inverse is
    its transpose, which can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to set up a matrix is by providing a list of symbols and a shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb71b0fa-f4bc-4b43-8b5d-bf5bf626e49d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A third way to create a matrix is by generating its entries by a given function.
    The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We exemplify the preceding matrix by considering a Toeplitz matrix. It is a
    matrix with constant diagonals. Given a [![](img/279a3df8-a97a-4ac5-89e4-d6c9bd841688.png)]data
    vector ![](img/296cf8da-ce9c-4a65-85c5-6acd0ae169c0.png), its elements are defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb66a951-698a-47f1-a2ed-7a237cbc8efb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In SymPy, the matrix can be defined by directly making use of this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the previous code gives `toeplitz(5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61377252-d6c9-4ef9-b650-9c3b81c933dd.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see clearly the desired structures; all elements along the subdiagonals
    and superdiagonals are the same. We can access matrix elements by the indexes
    and slices according to the Python syntax introduced in [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Slicing*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 16.3.2 Examples for linear algebra methods in SymPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic task in linear algebra is to solve linear equation systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c1fb4f9-24ee-4cbf-8466-2cb8d3a8ba0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s do this symbolically for a ![](img/980b1643-67ce-4e96-aa4e-5cfcf5d6595b.png) matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this relatively small problem is already merely readable, which
    can be seen in the following graphical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7dd2130-1af6-4fcf-8170-4800b3427a0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, the use of `simplify` command helps us to detect canceling terms and
    to collect common factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Which will result in the following output, which looks much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41ea66c8-111a-4300-aa55-af4eb092b947.png)'
  prefs: []
  type: TYPE_IMG
- en: Symbolic computations become very slow when increasing matrix dimensions. For
    dimensions bigger than 15, memory problems might even occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next figure (*Figure 16.3*) illustrates the differences in CPU time between
    symbolically and numerically solving a linear system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b5bcdaa-6bed-4e61-9c85-c5754b2d9381.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: CPU time for numerically and symbolically solving a linear system'
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Substitutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first consider a simple symbolic expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we set `x = 0` ? We observe that `b` did not change. What we
    did was that we changed the Python variable `x`. It now no longer refers to the
    symbol object but to the integer object `0`. The symbol represented by the string `'x'` remains
    unaltered, and so does `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, altering an expression by replacing symbols with numbers, other symbols,
    or expressions is done by a special substitution method, which can be seen in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes one or two arguments. The following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries as arguments allow us to make several substitutions in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As items in dictionaries have no defined order—we can never know which would
    be the first—there is a need for ensuring that permuting the items would not affect
    the substitution result. Therefore in SymPy, substitutions are first made within
    the dictionary and then on the expression. This is demonstrated by the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Both substitutions return the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/8a5144a8-5cbf-4da4-9869-c915a219a942.png)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'A third alternative to defining multiple substitutions is by using a list of
    old-value/new-value pairs instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to substitute entire expressions for others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate substitutions of matrix elements, we take the ![](img/3a72dcd0-f73c-4b62-8d90-2b07c3477916.png) Toeplitz
    matrix again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5babfd5f-3ae7-48a1-b6d2-f3532b0201fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Consider the substitution `T.subs(T[0,2],0)`. It changes the symbol object at
    position `[0, 2]`, which is the symbol ![](img/ac3eb574-96b2-42d8-9e91-627d68e3c16b.png).
    It also occurs at two other places, which are automatically affected by this substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The given expression is the resulting matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/981c6235-96e4-4a07-954d-66636e4e29fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can create a variable for this symbol and use it in the substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more complex example for substitution, let''s consider how to turn the
    Toeplitz matrix into a tridiagonal Toeplitz matrix*.* This can be done in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we generate a list of those symbols that we want to substitute; and
    then we use the `zip` command to generate a list of pairs. Finally, we substitute
    by giving a list of old-value/new-value pairs as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following matrix as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f3fc866-797d-4810-bffd-f77832bedc89.png)'
  prefs: []
  type: TYPE_IMG
- en: 16\. 5 Evaluating symbolic expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of scientific computing, there is often the need to first make
    symbolic manipulations and then convert the symbolic result into a floating-point
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The central tool for evaluating a symbolic expression is `evalf`. It converts
    symbolic expressions to floating-point numbers by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The data type of the resulting object is `Float` (note the capitalization),
    which is a SymPy data type that allows floating-point numbers with an arbitrary
    number of digits (arbitrary precision).
  prefs: []
  type: TYPE_NORMAL
- en: The default precision corresponds to 15 digits, but it can be changed by giving `evalf` an
    extra positive integer argument
  prefs: []
  type: TYPE_NORMAL
- en: 'specifying the desired precision in terms of the numbers of digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A consequence of working with arbitrary precision is that numbers can be arbitrarily
    small, that is, the limits of the classical floating-point representation are
    broken; see [Section 2.2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml): *Floating-point
    numbers*.'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough, evaluating a SymPy function with an input of type `Float` returns
    a `Float` with the same precision as the input. We demonstrate the use of this
    fact in a more elaborated example from numerical analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.1 Example: A study on the convergence order of Newton''s method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iterative method that iterates [*![](img/8038e264-c9a7-4d5f-b660-cd3997fc5d6c.png)*]
    is said to converge with order ![](img/e551ea10-3819-42ef-b8b1-3884edbf01bc.png) with
    ![](img/36ff2bdf-6ca2-4169-ab30-3f4ffcdaccb4.png)[,] if there exists a positive
    constant ![](img/d1e134fb-86be-4b63-ab18-e936219620fe.png) such that
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69ef133f-4f49-401c-a132-ee87c1697bba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Newton''s method, when started with a good initial value, has order ![](img/d5d4c2b0-7c21-4ae7-abe1-13d87cd15d2e.png),
    and for certain problems, even ![](img/3778c99a-3238-4758-81e5-ffa04d05c1e4.png).
    Newton''s method when applied to the problem ![](img/3e25a412-60af-451a-9075-b63f22edc726.png) gives
    the following iteration scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df5318b5-ae44-434b-8a96-8c55c1dccdab.png)'
  prefs: []
  type: TYPE_IMG
- en: Which converges cubically; that is, *q* = 3.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that the number of correct digits triples from iteration to iteration.
    To demonstrate cubic convergence and to numerically determine the constant [![](img/b1a781f0-07e6-4d0d-b5d1-0d40c1bb15fc.png)]
    is hardly possible with the standard 16-digit `float` data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses SymPy together with high-precision evaluation instead
    and takes the study on cubic convergence to the extreme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is depicted in the next figure (*Figure 16.4*), which shows that
    the number of correct digits triples from iteration to iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0944745e-3381-43e2-b3da-8ce9027d2364.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: A study on the convergence of Newton''s method applied to ![](img/188cd499-6f66-4039-bcfd-e039c4de31da.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This extreme precision requirement (3,000 digits!) enables us to evaluate seven
    terms of the preceding sequence to demonstrate cubic convergence in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list of seven terms that let us assume that ![](img/7282e682-14f4-42f1-b2da-f22d4a0db8bb.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 16.5.2 Converting a symbolic expression into a numeric function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, the numerical evaluation of symbolic expressions is done in
    three steps: first, we do some symbolic computations and then we substitute values
    by numbers and do an evaluation to a floating-point number with `evalf`.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for symbolic computations is often that we want to make parameter
    studies. This requires that the parameter is modified within a given parameter
    range. This requires that a symbolic expression is eventually turned into a numeric
    function.
  prefs: []
  type: TYPE_NORMAL
- en: A study on the parameter dependency of polynomial coefficients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We demonstrate a symbolic/ numeric parameter study by an interpolation example
    to introduce the SymPy command `lambdify`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the task to interpolate the data ![](img/1186c128-483c-4d51-8df7-207d483a2da8.png) and
    ![](img/58696cc5-47bd-4b9d-a3f5-0c0344b1abda.png). Here, ![](img/99eedf3c-a08b-4a54-85e3-061b29472f88.png) is
    a free parameter, which we will vary over the interval![](img/a32da2e1-a0f2-4cd7-aa5b-badedd42495b.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The quadratic interpolation polynomial has coefficients depending on this parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed52c599-8a50-410d-a261-02989af80625.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using SymPy and the monomial approach described in *Exercise 3* in [Section
    4.11](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Exercises* gives us the closed
    formula for these coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain a symbolic function for the leading coefficient [![](img/ebfc6511-9b09-49d3-b0a7-3cee878c7d64.png)]
    of the interpolation polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/958edc0c-d7a9-46bd-8e0f-65209f5dc4cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it is time to turn the expression into a numeric function, for example,
    to make a plot. This is done by the function `lamdify`. This function takes two
    arguments, the independent variable, and a SymPy function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example in Python, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can now be plotted, for example, by the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 16.5* is the result of this parameter study, we can clearly see the
    singularities due to multiple interpolation points (here at ![](img/97299a92-07c9-427b-943c-7dcf074dcf70.png) or
    ![](img/266b98d5-623e-4ca0-9e10-2a00f2f33642.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25c98c0b-464c-49ce-980f-bb827afc9a79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: The dependency of a polynomial coefficient on the location of
    an interpolation point'
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the world of symbolic computations and
    you got a glimpse of the power of SymPy. By following the examples, you learned
    how to set up symbolic expressions, how to work with symbolic matrices, and you
    saw how to make simplifications. Working with symbolic functions and transforming
    them into numerical evaluations, finally, established the link to scientific computing
    and floating-point results. You experienced the strength of SymPy as you used
    its full integration into Python with its powerful constructs and legible syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this last chapter as an appetizer rather than a complete menu. We hope
    you became hungry for future fascinating programming challenges in scientific
    computing and mathematics.
  prefs: []
  type: TYPE_NORMAL
