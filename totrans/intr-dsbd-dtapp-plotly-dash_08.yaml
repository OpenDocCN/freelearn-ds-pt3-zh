- en: '*Chapter 6*: Exploring Variables with Scatter Plots and Filtering Subsets with
    Sliders'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to tackle one of the most versatile, useful, and ubiquitous
    types of charts, the **scatter plot**. As its name implies, we basically scatter
    markers (which can be points, squares, circles, bubbles, or other symbols) on
    the Cartesian plane, where mainly their horizontal and vertical distances express
    the values they represent. Other visual attributes, such as size, color, and symbol,
    might be used to express other attributes, as we saw in some previous examples.
    As most of the fundamentals regarding figures and creating charts have been covered,
    we won''t be spending much time on that, focusing instead on the particular details
    and options available to scatter plots. We will also explore and work with **sliders**
    as a new interactive component. Let''s start right away, but first, here are the
    topics that we will be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning about the different ways of using scatter plots: markers, lines, and
    text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple scatter traces in a single plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping and setting colors with scatter plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling over-plotting and outlier values by managing opacity, symbols, and
    scales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing sliders and range sliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the marks and values of sliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same tools that we used in the previous chapter will be used here. We will
    also focus a little on Plotly's `graph_objects` module for creating scatter plots,
    because it provides other tools and is very useful when customizing our plots
    further. The packages to use are Plotly, Dash, Dash Core Components, Dash HTML
    Components, Dash Bootstrap Components, pandas, and JupyterLab.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3ancblu](https://bit.ly/3ancblu).
  prefs: []
  type: TYPE_NORMAL
- en: We start by exploring the different ways, or the different things, if you want,
    that we can plot with scatter plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning about the different ways of using scatter plots: markers, lines, and
    text'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a number of different options when using `graph_objects` to create
    scatter plots, as mentioned in the introduction, so we will be exploring it together
    with Plotly Express. To give you an idea of the versatility of the available scatter
    plots, the following code extracts all the `scatter` methods available to the
    `Figure` object, as well as those available in Plotly Express:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some overlaps in the available methods, and there
    are also some methods that aren't available in both modules. We won't go into
    all of them, but it's good to know them, because you can easily utilize your knowledge
    of regular scatter plots for the other types. Let's now take a look at some of
    the differences between using those options.
  prefs: []
  type: TYPE_NORMAL
- en: Markers, lines, and text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One interesting option that is available in the `go.Scatter` object is the
    `mode` parameter. This can take any combination of markers, lines, and/or text.
    You can specify one, two, or all three options together. When specifying more
    than one option, you have to specify them as a single string, where elements are
    separated by the plus sign, for example, `"markers+text"`. Let''s first get to
    know the indicators that we are going to focus on in this chapter, and immediately
    explore the plotting options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the required imports and create the `poverty` DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our dataset contains three levels of daily income at which poverty is measured.
    They measure "the mean shortfall in income or consumption from the poverty line
    – $1.90 a day". They also have the same measure for two other levels, $3.20 and
    $5.50\. They are also available as absolute counts in different columns, but we
    will focus on the percentages in this chapter. Their columns start with Poverty
    gap, which we can use as a pattern to extract the columns that we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make things simple, we will be starting all related variable names and objects
    with `perc_pov_` to make it clear that we are dealing with the poverty percentages.
    Keep in mind that we now have several objects and functions in the app, and we
    want to make sure we keep things simple, clear, and consistent. We now use the
    list we just created to create three variables, one for each poverty level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As usual, we need to look at the description of those indicators and, most
    importantly, at the limitations that they may have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The definitions are pretty much the same for the three indicators, and the
    limitations are also similar to what we saw in the previous chapter. Feel free
    to read the details, but keep in mind that these are not perfect numbers, and
    we have to be careful if we were to make any interpretations. We now create a
    variable for a country and use it to create a subset DataFrame containing the
    data for `country` and `perc_pov_19`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Figure` and then add a scatter plot to it, using the relevant method.
    The `mode` parameter should be given one of the options discussed previously,
    and it is shown here simply as `mode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 6.1* shows the effect of running the preceding code with each of the
    possible options for `mode`, with the figure titles showing how to set this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Different ways of setting the mode parameter for scatter plots](img/B16780_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Different ways of setting the mode parameter for scatter plots
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the other options in *Figure 6.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Other ways of setting the mode parameter for scatter plots](img/B16780_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Other ways of setting the mode parameter for scatter plots
  prefs: []
  type: TYPE_NORMAL
- en: Plotly Express has separate functions for scatter and line plots. You can plot
    text using the `scatter` function, which can be done by either choosing which
    column of your DataFrame contains the text to plot, or by providing a list of
    the text elements. The Plotly Express `scatter` function contains a `text` parameter
    that can be used for that.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how we can utilize this code to create multiple scatter
    plot traces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple scatter traces in a single plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will mostly be focusing on using Plotly Express as much as possible, because
    of its convenience, and the other advantages previously discussed in [*Chapter
    4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060), *Data Manipulation and Preparation
    - Paving the Way to Plotly Express*. It's still very important to know how to
    work with `Figure` objects as you will encounter many situations where you will
    need to work with them, especially when you have a lot of customizations to make.
    Also, keep in mind that although the most important chart types are supported
    by Plotly Express, not all of them are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the preceding chart with traces of other countries and compare
    the two approaches. We start with the `graph_objects` module''s `Figure` object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `countries` list to filter with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subset of `poverty`, which we will call `df`, where the values of
    the `Country Name` column are in the `countries` list (using the `isin` method).
    We then extract the `year`, `Country Name`, and `perc_pov_19` columns and drop
    the missing values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Figure` object, assigning it to a variable, `fig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now want to add a trace for each country that we want to plot. This can
    be done by looping over the countries and creating a sub-DataFrame that contains
    only data for the current country:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now add a new trace (within the same loop, and at the same level of indentation)
    by using the `add_scatter` method. Note that we set `mode=''markers+lines''` and
    we use the `name` attribute to set the title of this trace in the legend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add a title for the *y*-axis, and then we can easily show the
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the chart in *Figure 6.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Creating multiple scatter plots using the graph_objects module](img/B16780_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Creating multiple scatter plots using the graph_objects module
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compare that to how we would do it with Plotly Express. The code
    to produce it is so short, clear, and intuitive that it barely warrants an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We chose the value for the `data_frame` parameter and selected which columns
    we want for the `x`, `y`, and `color` parameters from `df`. The code then produces
    the chart in *Figure 6.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Creating multiple scatter plots using Plotly Express](img/B16780_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Creating multiple scatter plots using Plotly Express
  prefs: []
  type: TYPE_NORMAL
- en: We also get the axes labeled automatically and the legend labeled properly,
    and we even have a title for the legend, using the column name that we selected
    for the `color` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a minor issue though. The disconnected points are not as easy to read
    as in the previous chart. This is especially important in this case because we
    are expressing a sequence of events, and the lines make it much clearer. With
    interactive dashboards, we don''t know what our users are going to select, which
    means that they might produce charts that are even harder to read than this one.
    Plotly Express has separate functions for scatter and line plots, so in order
    to make it a "lines+markers" plot, we need to assign this to a `Figure` object
    and then add line traces. Here are the steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Figure` object and assign it to a variable, `fig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another `Figure` object, exactly like the previous one, with a different
    name and chart type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From `fig_lines`, we want to add its traces to `fig`. If you remember, the
    traces can be found under the `data` attribute of the `Figure` object. The `data`
    attribute is a tuple with each element corresponding to a trace. So, we need to
    loop over those traces (of the `data` attribute) and add them to `fig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that each new line trace will have its label on the legend. So we would
    have redundant line labels in the legend, which we had to remove. We handled that
    by setting the `showlegend` attribute to `False` for each of the traces. Running
    this code produces the chart in *Figure 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Creating multiple scatter and line plots using Plotly Express](img/B16780_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Creating multiple scatter and line plots using Plotly Express
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the mental effort and amount of code required to produce the same
    chart in two different approaches, we can see that there wasn't that much of a
    difference. This is typical when you want to produce something customized and/or
    something good enough for publishing. Still, for exploration purposes, Plotly
    Express is clearly a great starting point, and once you get a good idea of the
    data, you can better decide on which approach to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen an example of implicitly managing color on scatter plots (the colors
    were automatically set or us), and we are now ready to explore more options for
    managing color. If you are reading this on the printed grayscale version, you
    will see different shades of colors that might be distinguishable, but as we did
    previously, we will also use symbols to make it explicit and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore the different options that we have for managing color.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping and setting colors with scatter plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Colors are extremely important in conveying and expressing information about
    our charts. It is also a very big topic, and a full discussion is beyond the scope
    of this book. We will focus on colors for two types of variables – discrete and
    continuous. We will also tackle two ways of using colors in our charts: mapping
    variables to colors, and manually setting our colors.'
  prefs: []
  type: TYPE_NORMAL
- en: We start by exploring the differences between the two types of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete and continuous variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply speaking, continuous variables are the ones that can take an infinite
    number of possible values in a certain range of numbers. For example, population
    is a number that can take any value, based on the number of people living in a
    certain country. Continuous variables are typically numbers (integers or real
    numbers). Height, weight, and speed are other examples as well.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete variables, on the other hand, are variables that can take the value
    of any one of a limited set of items. Most importantly, discrete variables cannot
    take values in between the items. Countries are one such example. A country can
    either be country A or country B, but can't be 10% A and 90% B. Discrete variables
    are typically text variables, and usually have a relatively small number of unique
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we use color to express the nature of our variables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For continuous variables, we use a color scale that takes on colors that gradually
    change between two or more colors, as the values they represent change. For example,
    if our color scale starts as white for the lowest value, and ends up as blue at
    the highest value, all values in between would take on varying shades of white
    and blue. A marker that has a color that contains more blue than white means that
    its value is closer to the maximum value of that variable and vice versa. We will
    try this shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discrete variables are distinct items, and the colors we use for them need to
    be as distinct from each other as possible, especially the ones that appear next
    to each other. Examples will make this clear, and we start with continuous variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using color with continuous variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same metric we started with, we want to take an arbitrary year and
    plot the indicator value for each of the countries. We already know how to do
    this. We now want to add a new dimension to our chart. We want to use color to
    show another value, for example, population. This will allow us to see whether
    there is any correlation between population and the metric we are plotting (poverty
    at $1.90 in this case). Let''s prepare our variables and data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create variables for the indicator and year of choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the indicator and year, we create a subset of `poverty` where the year
    column is equal to our variable, `year`, and the `is_country` column is `True`.
    We then drop the missing values and sort the values according to this column.
    The following code achieves this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All we have to do is select the column we want for mapping its values to the
    appropriate colors, and we do this as we usually do with Plotly Express:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code produces the chart in *Figure 6.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Setting color for continuous variables with Plotly Express](img/B16780_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Setting color for continuous variables with Plotly Express
  prefs: []
  type: TYPE_NORMAL
- en: We basically added a new layer to our visualization with the column that we
    selected. Each visual attribute adds another dimension to the chart, and makes
    it richer, but adding too many dimensions might make it overwhelming and difficult
    to read. It's up to us to strike the right balance and make sure we are presenting
    something meaningful and readable to our audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can immediately see that the country with the highest population in the
    chart (the United States, in bright yellow) has one of the lowest values for our
    indicator. We can also see that since most other markers are closer to purple
    in color, this shows that the country with the highest population has quite an
    extreme value for that metric compared to the others. It seems to be an outlier
    in population, but not so, with the poverty indicator. The popup that appears
    when we hover over a marker also takes the same color and, being much bigger than
    the marker, makes it very easy to relate the color to its relative position on
    the color bar. The color `color_scale_continuous`. We can see how to do that,
    as well as its effect, in *Figure 6.7*, where we chose the **cividis** scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Choosing a different continuous color scale](img/B16780_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Choosing a different continuous color scale
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no additional information in this chart, only that we changed the
    color scale to a different one. It''s intuitive to understand this color scale,
    as it moves between dark blue and bright yellow, and all combinations of colors
    in between. The scale is also known as a "sequential" scale, because it shows
    how values move from a low to a high value. You can get a full list of named color
    scales by running `px.colors.named_colorscales()`, which will return the names
    of those scales. More interesting is the option to see all those scales and compare
    them, so you can choose which one you want. You can produce a chart with all available
    scales of a certain type by running `px.colors.sequential.swatches()`, and you
    can see part of the output in *Figure 6.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The first few sequential scales available in Plotly](img/B16780_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The first few sequential scales available in Plotly
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting way of showing the color scales in action is by using the
    `swatches_continuous` functions. For example, *Figure 6.9* shows the result of
    running `px.colors.sequential.swatches_continuous()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The first few sequential scales available in Plotly as they
    would appear in a color bar](img/B16780_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The first few sequential scales available in Plotly as they would
    appear in a color bar
  prefs: []
  type: TYPE_NORMAL
- en: This gives an even better idea of how they would actually look, and shows colors
    with smooth transitions in between.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `swatches` functions for other types of color scales and sequences.
    You simply run the previous command and replace `sequential` with any of the following:
    `carto`, `cmocean`, `colorbrewer`, `cyclical`, `diverging`, or `qualitative`.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have mapped the data values and colors automatically by choosing
    which column's values we want to use for that. There is also the option of manually
    setting the color scales.
  prefs: []
  type: TYPE_NORMAL
- en: Manually creating color scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way of doing this is by providing a list of two or more colors to the `color_continuous_scale`
    parameter. By default, the first color you provide will be assigned to the minimum
    value and the last color to the maximum value. Values in between will take combinations,
    resulting in shades of the two colors. This shows how close the data point is
    to each of the extremes. We''ll see an example of using more than two colors shortly.
    Using the same code and setting `color_continuous_scale=["steelblue", "darkorange"]`
    produces the chart in *Figure 6.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Manually setting continuous color scales](img/B16780_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Manually setting continuous color scales
  prefs: []
  type: TYPE_NORMAL
- en: This gives a glimpse of how granular the options are, and this is barely scratching
    the surface of what is available. Sometimes, you may want to rescale your data
    so the colors adopt a smoother progression from the minimum to the maximum. The
    charts we just created are a good candidate for this. We have one outlier when
    it comes to population, so it might be better to set the `color` parameter to
    a scaled version of our data if we want to do that. In general, because there
    are numerous scales that are well-established and tested, it is better to choose
    from them instead of manually setting your own colors. Another important consideration
    is color blindness, and trying to use scales that cater for people who have it.
    You don't want to use colors that are indistinguishable by some of your readers.
    You can run a simple check by searching online as to whether or not a color scale
    is colorblind-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now set a scale that uses three colors. The `RdBu` (red blue) scale
    goes from red to blue, with mid values taking white as their color. It is one
    of the default scales. Let''s quickly plot a simple chart with this scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a list of integers in the range [-2, 6] and mapped their colors
    to the `RdBu` scale, which produces the chart in *Figure 6.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Manually setting a continuous diverging color scale](img/B16780_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Manually setting a continuous diverging color scale
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can see the colors moving from red to white to blue, passing
    through the intermediate shades of each color. This is also known as a "diverging"
    scale. There is a midpoint (the white point in this case) where colors diverge,
    signifying two different types of values. Usually, we use this to show values
    above and below a certain value. In this case, we wanted to show negative values
    in red, zero values in white, and positive values in blue. But we didn't get that.
    The white midpoint was set as the midpoint of the data, which happens to be the
    fifth element of our list, and its value is 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be fixed by using the `color_continuous_midpoint` parameter, as you
    can see in *Figure 6.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Manually setting a midpoint for a continuous diverging color
    scale](img/B16780_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Manually setting a midpoint for a continuous diverging color scale
  prefs: []
  type: TYPE_NORMAL
- en: We now have a more meaningful midpoint, where the divergence in color makes
    it easy to see positive and negative values. Another important thing this achieves
    is that it also shows us how skewed the data is. Note that we don't have any red
    markers in the chart. We have two pinkish ones, while we have more blue values.
    This perfectly corresponds to the list of numbers, which contains two negative,
    and six positive values. The color bar also makes it clear that we are only covering
    part of the red spectrum, while blue is fully covered.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other options for setting colors, scaling the data, and expressing
    different values. I encourage you to learn more about this topic, and the good
    news is that Plotly provides options to customize colors the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how color works with discrete variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using color with discrete variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The objective now is not to visualize the degrees of difference between values.
    We now want to group values based on a criterion and see the differences across
    those groups of values. We can immediately see what happens if we simply set the
    `color` parameter to a column that has text values. For example, we can set `color="Income
    Group"` to get the chart in *Figure 6.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Using color with categorical variables](img/B16780_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Using color with categorical variables
  prefs: []
  type: TYPE_NORMAL
- en: Everything was automatically handled for us. Simply because we chose a column
    with text values, Plotly Express grouped the data according to that column, and
    chose a sequence of colors that are distinct from one another, so we can see how
    values change across the groups. We also used symbols to make it easier to see,
    especially on a grayscale version of the chart. This was achieved by setting `symbol='Income
    Group'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with continuous variables, we can also set our own discrete color sequence
    by providing one to the `color_discrete_sequence` parameter. *Figure 6.14* shows
    the effect of setting this parameter, by using one of the sequences provided by
    Plotly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Setting a different color sequence for categorical variables](img/B16780_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Setting a different color sequence for categorical variables
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have chosen a sequence by getting it from the available list, `px.colors.qualitative.G10`,
    and as you may have guessed, you can generate all the available sequences by running
    `px.colors.qualitative.swatches()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did with continuous variables, we can also manually set the colors of
    our discrete variables by providing a list of named colors. We can also use the
    colors'' hexadecimal representation, for example, `#aeae14`, or the RGB values,
    for example, `''rgb(25, 85, 125)''`. Passing our chosen colors to the `color_discrete_sequence`
    parameter, we get the chart in *Figure 6.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Manually setting the colors of a sequence for categorical variables](img/B16780_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Manually setting the colors of a sequence for categorical variables
  prefs: []
  type: TYPE_NORMAL
- en: 'When you manually select the colors of your choice, you need to make sure that
    you provide a list of colors that has the same number of elements as the unique
    values of the variable you are trying to visualize. Otherwise, it will cycle through
    the colors you provided, and this might be misleading. Again, it''s usually better
    to select from the available established sequences, but you can set them manually
    if you want to. When we set the colors that we want, we didn''t specify which
    item should take which color. We simply stated that we want the unique values
    to take this set of colors. Sometimes, you may want to explicitly map certain
    colors to certain categories. Once you know the unique values, you can provide
    a dictionary to the `color_discrete_map` parameter, and then map each value to
    the color of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting this option produces the chart in *Figure 6.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Manually setting the colors for each value of a sequence for
    categorical variables](img/B16780_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Manually setting the colors for each value of a sequence for categorical
    variables
  prefs: []
  type: TYPE_NORMAL
- en: Note that most continuous variable parameters contains "scale," while the discrete
    ones contain "sequence." This can help in remembering and understanding the fundamental
    difference in the process of mapping colors to the two kinds of variables.
  prefs: []
  type: TYPE_NORMAL
- en: With continuous variables, we are giving the readers the ability to see the
    approximate value of the markers based on the color, as well as the relative position
    in the dataset. It is not clear cut, but you can tell that the population of a
    certain country is around twenty million, and that it looks like it's one of the
    highest countries in this dataset. Users can, of course, hover and get the exact
    value if they want. With discrete variables, we are basically more interested
    in grouping by those variables and seeing trends across those groups.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a small subset of what can be done with colors, and now we move to
    consider a few other issues that might arise with scatter plots, namely, outliers
    and having many data points to plot.
  prefs: []
  type: TYPE_NORMAL
- en: Handling over-plotting and outlier values by managing opacity, symbols, and
    scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we are now interested in seeing the relationship between our variable
    and population for the same year that we have been working on. We want to have
    `Population, total` on the *x*-axis, and `perc_pov_19` on the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a subset of `poverty` where `year` is equal to 2010, and `is_country`
    is `True`, and sort the values using `Population, total`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see what it looks like when we plot those two variables. Here is
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this produces the chart in *Figure 6.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Over-plotting and outliers in charts](img/B16780_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Over-plotting and outliers in charts
  prefs: []
  type: TYPE_NORMAL
- en: The existence of one outlier, China, with a population close to 1.4 billion,
    forces all markers to be squeezed to a very narrow part of our chart. We also
    have a small cluster of values above 25 on the *y*-axis, but the difference is
    nowhere as extreme as the horizontal one. Another important issue is that there
    are many markers on top of one another. Having solid-colored markers means that
    if you plot one marker on top of another, it will not make any difference; not
    even a thousand markers will. The existence of the two issues together make it
    a very challenging chart to read.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to explore a few techniques that might help with these situations,
    and evaluate when and how they might be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have many points crowded on a very small part of the chart, we are
    likely to have several of them overlapping. Let's see the effect of changing the
    opacity and size of the markers.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the opacity and size of markers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `opacity` parameter takes values in the range [0, 1], inclusive. We can
    manually give it a number to control how opaque we want our markers to be. A value
    of `0` means completely transparent, which can also be thought of as a way to
    hide our markers (or a subset of them). A value of `1` means the markers will
    be fully opaque, taking whatever color they were assigned, and fully covering
    the area they are on. This also means that an `opacity` of `0.1` means that the
    marker will be 10% opaque. The practical implication for that is that it means
    that it will take 10 markers on top of one another to completely cover the area
    they are plotted on. If we set it to `0.5` (or 50%), this means that two markers
    would fully cover the area, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the markers are quite small, and we don''t have that many values, we
    can also increase their size for better visibility. The `size` parameter, just
    like all other parameters, can take the name of a column in our DataFrame, or
    a list of numbers. This is another visual attribute that we can use to express
    the values of a certain column where the relative sizes reflect the relative value
    that each marker represents. It is also sometimes called a bubble chart. For this
    case, we want to provide a fixed size. This can easily be done by providing a
    list having the same length as the DataFrame we are analyzing. This would give
    the markers a uniform default size, which might not be what we want, so we can
    control it with the `size_max` parameter. Reusing the same code and setting `opacity=0.1`,
    `size=[5]*len(df)`, and `size_max=15`, we get the chart in *Figure 6.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Modifying the opacity and size of markers](img/B16780_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Modifying the opacity and size of markers
  prefs: []
  type: TYPE_NORMAL
- en: This looks a little better. We have bigger markers, and with an `opacity` of
    `0.1`, we can better see that the majority of markers are concentrated very close
    to the origin. Most likely, there is more nuance than that, but because of the
    outlier that we have, those differences seem very small.
  prefs: []
  type: TYPE_NORMAL
- en: There will always be a trade-off between opacity and visibility. The more transparent
    your markers are, the clearer you can see, especially with hundreds or thousands
    of markers. But at the same time, they might become so transparent that you can't
    see anything. At `0.1` `opacity`, we are approaching that stage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at another technique, which involves the use of logarithmic
    scales for the axes.
  prefs: []
  type: TYPE_NORMAL
- en: Using logarithmic scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normal scales are intuitive and easy to understand. Just like physical objects,
    a piece of wood that is twice the length of another one contains twice as much
    wood, provided it is of the same width and depth. In the previous two figures,
    for example, the distance between 0 and 0.2 billion is the same as the distance
    between 0.2 and 0.4 billion. The "data distance" is also the same. On a normal
    scale, and in this example, every tick corresponds to an increase of a certain
    amount (0.2 billion in this case). On a logarithmic scale, every additional tick
    corresponds to a multiple of the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the numbers 10, 20, 30, and 40 form a typical sequence that you
    might see on a normal scale. If the scale was logarithmic, we don''t add 10; we
    would `log_x=True`, we get the updated chart in *Figure 6.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Using a logarithmic scale](img/B16780_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Using a logarithmic scale
  prefs: []
  type: TYPE_NORMAL
- en: Our chart now looks quite different, but it is still actually the same chart.
    Note that we have changed the `opacity` to `0.25`, because `0.1` was difficult
    to see, and because we now have the markers a lot more dispersed than previously.
    We now have a much more nuanced view of how the population is distributed. We
    can see that the most opaque part is around the ten million mark. Compared to
    1.4 billion, this is pretty much zero, which is what the previous chart told us,
    but now we have a better view.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the major ticks are each 10 times larger than the previous one (**10k**,
    **100k**, **1M**, **10M**, **100M**, and **1B**), or for every major tick we are
    adding a zero. At the same time, we can see minor ticks, **2** and **5**, meaning
    that these positions represent twice and five times, respectively, the value of
    the previous major tick.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore another option that we might consider in such situations. We will
    not use any opacity this time, but we will introduce a lot of space to our markers
    by changing the symbol that we use. Setting symbols can be managed exactly like
    setting discrete colors. `symbol_sequence` is the parameter responsible for that,
    it will cycle through the options that we provide, and then assign one for each
    unique discrete value in our column. We give it a list containing one value, so
    all markers will have the same symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now remove the `opacity` argument and replace it with `symbol_sequence=[''circle_open'']`
    to get the new chart in *Figure 6.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Modifying the symbols of markers](img/B16780_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Modifying the symbols of markers
  prefs: []
  type: TYPE_NORMAL
- en: This might be even better, as we are not sacrificing any visibility by changing
    the opacity. We achieved our objective of seeing where the markers are clustered,
    because it takes a lot of open circles to fully cover an area. The logarithmic
    scale spreads the markers horizontally, so it is easier to see how they are distributed.
    The tick labels clearly indicate the values, but we might need to make it very
    clear and explicit if our audience is not familiar with this kind of scale.
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine providing users with all the options that we just tried. We can
    think of having a component that allows users to modify the opacity, another component
    to toggle between normal and logarithmic scales, and maybe another to change the
    symbols. Ideally, we shouldn't make it that difficult for users to read our charts.
    It's best to do the work ourselves and provide sensible defaults after having
    explored the data. Based on what we have explored so far, let's consider what
    those defaults might be.
  prefs: []
  type: TYPE_NORMAL
- en: We know that this chart plots countries, and that they cannot be more than 200\.
    This means we can set a default opacity level that is appropriate for that number
    of markers. Having thousands of markers might require a much lower `opacity` level,
    such as `0.02`, for example. Open circles seem to have worked well for us by introducing
    space, so we might also choose that as the default symbol, and forget about opacity
    altogether. The same applies to the `size` parameter. Knowing that we are plotting
    population figures, and that it is most likely always going to contain outliers,
    as in this case, we might keep the logarithmic scale as the default.
  prefs: []
  type: TYPE_NORMAL
- en: A more general type of interactive chart might allow users to modify the indicators
    that they want to explore. In this case, we might give them those options. However,
    with more freedom and generality, our users will have to handle more of the data
    handling details themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We have established a good understanding of our metrics and seen many examples
    of many countries. This exploration is crucial for building a dashboard with sensible
    defaults, as we just saw. Let's now explore the new interactive components of
    this chapter – the `Slider` components.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing sliders and range sliders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Slider` and `RangeSlider` components are basically circles that users
    can drag horizontally or vertically to set or change a certain value. They are
    typically used for setting continuous values, as their appearance and dragging
    functionality are a natural fit for that. But this is not a requirement as we
    can use them for categorical/discrete values as well. We have seen that we have
    three levels of our `perc_pov_` metrics, and we know that we have all the years
    in our dataset to choose from. We now want to create two sliders. One allows users
    to select the level of poverty that they want to analyze, and the other allows
    them to select the year. Each combination of selections will create a different
    subset, and result in a different chart. *Figure 6.21* shows the top part of the
    end result that we will be working toward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Two sliders controlling a chart](img/B16780_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Two sliders controlling a chart
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the new functionality requires three main components – two `Slider`
    components and one `Graph` component. Of course, we have a few others to control
    the layout, as well as labels, but the focus is mainly going to be on how to create
    and incorporate this new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `RangeSlider` component is almost identical to the `Slider` component. The
    main difference is that it contains more than one handle, so users can modify
    the maximum and minimum points within which they want to filter data. For now,
    we will focus on normal `Slider` components, and we will tackle the `RangeSlider`
    component in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we will create this as a standalone app in JupyterLab, and once it
    is working fine, we will add it to the app. Let's start first by getting to know
    the `Slider` component, how it works, and then create the layout of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a minimal app and, within the app''s layout, create the `Slider`
    component, just like you do with other components, by calling `dcc.Slider()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a simple app with a single component, as you can see in *Figure
    6.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – A bare-bones slider component](img/B16780_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – A bare-bones slider component
  prefs: []
  type: TYPE_NORMAL
- en: 'This is visually easy to use, and it''s clear that users can slide the circle
    horizontally. There are no guides however, and users don''t know what values they
    are modifying, so let''s fix that. We will start by creating our first slider,
    containing the three poverty levels that we are analyzing. Let''s take a look
    at the parameters that we are going to use for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min`: As the name suggests, this is the minimum value of the slider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`: This also sets the upper limit for the values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: As we go (slide) from `min` to `max`, what should the increment size
    be? By default, it is set to `1`, but you can set it to a higher or lower value.
    For example, if you wanted users to manage opacity, you can set `min=0`, `max=1`,
    and `step=0.01`. This would give users 100 options to choose from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dots`: Should the slider display dots or should it be a simple line? In our
    case, we want users to choose between three distinct values, so it makes sense
    to set this option to `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`included`: Note that the slider in *Figure 6.22* is light blue to the left
    of the handle, and gray to its right. As you slide, the blue part expands/contracts
    with the handle, which is the default behavior. In our case, we are giving the
    user three distinct options, so we want to remove this to emphasize this fact,
    so we set its value to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This is the default value that the slider should take.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a `Slider` component that ranges from `0` to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the new slider in *Figure 6.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – A slider component with custom options](img/B16780_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – A slider component with custom options
  prefs: []
  type: TYPE_NORMAL
- en: The dots now guide users on where they can select, and it hints that the options
    are distinct from one another, especially that we set `included=False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another crucial parameter that `Slider` takes is the `marks` parameter. We
    need to show users what each dot corresponds to. In some cases, we might not have
    enough space to display all values, in which case we skip some of the values.
    We will do this in our years slider, but first let''s create the poverty indicator
    slider. We first do it without the `marks` parameter, and then add it after that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For `id`, as with other variables, we followed the rule of starting with `perc_pov_`
    to be consistent with other related objects in the app. The values that the callback
    function will receive from this component are going to be `0`, `1`, and `2`, and
    this is based on the `min`, `max`, and `step` arguments we gave. Now, those values
    don't mean anything in our situation, because we actually want the full text of
    the name of the indicator. We can simply handle this by taking the value of the
    slider and using it as the index for the `perc_pov_cols` list that we created.
    In our callback function, we will use this integer value to extract the respective
    indicator. We will see this later when we construct our callback function. Let's
    now create the marks for our slider.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the marks and values of sliders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to create these is by using a dictionary: `{0: ''$1.9'', 1:
    ''$3.2'', 2: ''$5.5''}`. They keys will be used as the `value` attribute, and
    the values of the dictionary are what the user will see for each poverty level.
    This will suffice for our case, and we can use it as such.'
  prefs: []
  type: TYPE_NORMAL
- en: We optionally have the chance to customize the style of our labels, which can
    take any CSS attribute as a dictionary. If you look at *Figure 6.21*, you can
    see that the marks (numbers) of the two sliders have a very light color, and they
    might give the impression that they belong to the same slider. We can improve
    this by setting their colors to a dark color. We can also set a bold font for
    the indicator slider. This will help distinguish them from the years, and it will
    also emphasize their uniqueness. Years are easy to immediately grasp, but users
    are most likely not familiar with the levels of poverty tracked in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to get a color that is consistent with our charts. And since we will
    be using the cividis color scale, it''s a good opportunity to get to know how
    we can extract its colors. The `px.colors.sequential` module contains, among other
    things, lists of the colors of the sequential color scales. We can get cividis
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The list we receive contains the 10 colors that are actually used to construct
    this scale. Recall that we tried this manually with 2 and 3 colors. It's also
    interesting to know that you can get the reversed version of a scale by appending
    `_r` to its name, for example, `px.colors.sequential.Cividis_r`. This would give
    us the same scale, but the yellow would correspond to the lower values in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the color that we want to use for the labels of the marks is going to
    be the darkest one in cividis, which we can easily extract and assign to a variable
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, we can now set our `marks` argument as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did was basically extend the dictionary, where, instead of strings
    as values, we added dictionaries in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In general, CSS attributes such as `font-size` and `font-weight` are hyphen-separated,
    and written in lowercase. In Dash, you can use the same attributes, but you have
    to remove the hyphens, and use camelCase (`fontSize` and `fontWeight`), as you
    can see in the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we just did, let''s now create the other slider with similar
    customizations. First, and in order to isolate our subset, we can create a special
    DataFrame for these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The important thing is that we removed any missing values from `perc_pov_cols`,
    and we also created a sorted list of unique years, `perc_pov_years`, using `sorted`
    and `set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates our new slider for the years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty much the same as we did for the indicators. We set the default
    to 2018, which is the latest year for which we have data. If this was a dynamically
    updated app, we can also set this value to the maximum of `perc_pov_years`. Note
    that we set the marks to show only one in five years. Otherwise, the slider would
    be very difficult to use. With this, we can see the slight difference in fonts
    and colors in *Figure 6.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Sliders with updated colors](img/B16780_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Sliders with updated colors
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of our layout is going to be the `Graph` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned before, we also have `Label` components, as well as `Col` and
    `Row` components to better manage the layout, but they weren't discussed, as we
    have already created several examples using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to create our callback function to link the three elements
    that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create the decorator of the function. This is straightforward, as
    we did with previous examples. The slight difference is that we have two inputs
    in this case. In the definition of the function, the order of the parameters will
    correspond to the order of the `Input` elements, so we will name them accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next part, we create the function''s signature, as well as the first
    few lines. The parameters are named `year` and `indicator`. We now use the indicator
    value (which is an integer) to get the corresponding element from `perc_pov_cols`.
    We then create the variable `df`, which filters `perc_pov_df` to only have values
    from `year`. Then, define we `dropna` and `sort_values`. There was a year that
    didn''t have any data, but had to be included in the values of the slider, so
    we need to handle the case when/if users select it. This is done using the simple
    check `if df.empty`, as you can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our DataFrame ready, we can create the `Figure` and return
    it. Most of the code should now be familiar. The `hover_name` parameter is used
    to add a title to the popup when users hover over markers. Setting it to `Country
    Name` would cause the title to take the respective country''s name and display
    it in bold. We also utilized the same dynamic height trick that we used in the
    last chapter, where we set a fixed height, and added 20 pixels for each country.
    The `ticksuffix` option we added at the end should be self-explanatory, to make
    it clear that these are percentages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adding the layout elements and callback to our app, we finally get the additional
    functionality in the form of two sliders that can generate more than 130 charts
    through their combinations. *Figure 6.25* shows the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Two sliders and a scatter plot – final result](img/B16780_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Two sliders and a scatter plot – final result
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on yet another addition to your app! This time, we created our
    first multiple input callback, which enriched the options that users can generate,
    without being complicated or overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: From a functionality perspective, there is nothing really different between
    dropdowns and sliders. We could have implemented the same thing with dropdowns,
    and it would have worked fine. The advantage of dropdowns is that they are extremely
    efficient in terms of space utilization. A small rectangle can contain tens or
    even hundreds of hidden options that users can search. Those options can be very
    long strings that may be impossible to fit next to each other, on a slider, for
    example.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sliders give a better perspective. They implicitly contain
    metadata about the options. You can immediately see the minimum and maximum points,
    and how widely they are spread. When you select an option, you can easily tell
    how extreme your choice was relative to the other options that are available.
    In the case of the poverty level slider, users can see all available options immediately.
    And finally, sliders are more similar to how we interact with physical objects,
    so playing with them might be more engaging than other interactive components.
    So, space restrictions, the types of variables that we are analyzing, and how
    we want to display them are some considerations that affect our choice of interactive
    components that we decide to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed that we are focusing less on how to put things together
    in the app, and that's intentional. We have already covered these topics several
    times, and it is designed to also encourage you to do them yourself and experiment
    with other options. You can always refer back to the code repository to check
    your work and for the minor details.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now recap what we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced scatter plots and saw how to create them, both using the `graph_objects`
    module, and using Plotly Express. We saw how to create multiple traces and tried
    different approaches for that. We then discussed color mapping and setting and
    explored how different the process is for continuous and discrete (categorical)
    variables. We saw different scales – sequential, diverging, and qualitative. We
    also saw how we can set our own colors, sequences, and scales. We also tackled
    some issues that arise when we have outliers, and when we have over-plotting.
    We experimented with opacity, changing symbols, and marker sizes, as well as using
    logarithmic scales to make our charts more readable. We also introduced sliders
    and learned how they work, and created two sliders that work together to generate
    charts expressing three values (as opposed to two values previously). We then
    created a callback function that managed those interactions and integrated it
    into our app.
  prefs: []
  type: TYPE_NORMAL
- en: By now, and with all the examples and techniques covered, we are getting closer
    to the point of creating dashboards in the same way as we create slideshows and
    presentations. Once we master the layout elements, it's very easy to customize
    any size and position we want. And now that we are exploring different chart types
    and data visualization techniques, it will become easier to manage things and
    modify them the way we want.
  prefs: []
  type: TYPE_NORMAL
- en: All the charts we have explored so far used regular geometric shapes, including
    circles, lines, and rectangles. In the next chapter, we will explore irregular
    shapes, and how to visualize them, in the form of maps. Maps are very engaging,
    and easily recognizable, yet not so straightforward to visualize, like simple
    regular shapes. This will be explored next.
  prefs: []
  type: TYPE_NORMAL
