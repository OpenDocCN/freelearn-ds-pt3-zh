<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer069">
<h1 class="chapter-number" id="_idParaDest-210"><a id="_idTextAnchor209"/>8</h1>
<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/>Using the Protein Data Bank</h1>
<p>Proteomics is<a id="_idIndexMarker567"/> the study of proteins, including their function and structure. One of the main objectives of this field is to characterize the three-dimensional structure of proteins. One of the most widely known computational resources in the proteomics field is <a id="_idIndexMarker568"/>the <strong class="bold">Protein Data Bank</strong> (<strong class="bold">PDB</strong>), a repository with the structural data of large biomolecules. Of course, many databases focus on protein primary structure instead; these are somewhat similar to the genomic databases that we saw in <a href="B17942_02.xhtml#_idTextAnchor040"><span class="No-break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Getting to Know NumPy, pandas, Arrow, and Matplotlib</em>.</p>
<p>In this chapter, we will mostly focus on processing data from the PDB. We will look at how to parse PDB files, perform some geometric computations, and visualize molecules. We will use the old PDB file format because, conceptually, it allows you to perform most necessary operations within a stable environment. Having said that, the newer mmCIF slated to replace the PDB format will also be presented in the <em class="italic">Parsing the mmCIF files with Biopython</em> recipe. We will use Biopython and introduce PyMOL for visualization. We will not discuss molecular docking here because that is probably more suited to a book about chemoinformatics.</p>
<p>Throughout this chapter, we will use a classic example of a protein: the tumor protein p53, a protein involved in the regulation of the cell cycle (for example, apoptosis). This protein is highly related to cancer. There is plenty of information available about this protein on the web.</p>
<p>Let’s start with something that you should be more familiar with by now: accessing databases, especially for a protein’s primary structure (as in, sequences of amino acids).</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Finding a protein in multiple databases</li>
<li>Introducing Bio.PDB</li>
<li>Extracting more information from a PDB file</li>
<li>Computing molecular distances on a PDB file</li>
<li>Performing geometric operations</li>
<li>Animating with PyMOL</li>
<li>Parsing the mmCIF files with Biopython</li>
</ul>
<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/>Finding a protein in multiple databases</h1>
<p>Before <a id="_idIndexMarker569"/>we<a id="_idIndexMarker570"/> start performing some more structural biology, we will look at how we can access existing proteomic databases, such as UniProt. We will query UniProt for our gene of interest, <em class="italic">TP53</em>, and take it from there.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>Getting ready</h2>
<p>To access the data, we will use Biopython and the REST API (we used a similar approach in <a href="B17942_05.xhtml#_idTextAnchor122"><span class="No-break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Working with Genomes</em>) with the <strong class="source-inline">requests</strong> library to access web APIs. The <strong class="source-inline">requests</strong> API is an easy-to-use wrapper for web requests that can be installed using standard Python mechanisms (for example, <strong class="source-inline">pip</strong> and <strong class="source-inline">conda</strong>). You can find this content in the <strong class="source-inline">Chapter08/Intro.py</strong> Notebook file.</p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li>First, let’s define a function to perform REST queries on UniProt, as follows:<p class="source-code">import requests</p><p class="source-code">server = 'http://www.uniprot.org/uniprot'</p><p class="source-code">def do_request(server, ID='', **kwargs):</p><p class="source-code">    params = ''</p><p class="source-code">    req = requests.get('%s/%s%s' % (server, ID, params), params=kwargs)</p><p class="source-code">    if not req.ok:</p><p class="source-code">        req.raise_for_status()</p><p class="source-code">    return req</p></li>
<li>We <a id="_idIndexMarker571"/>can now query all the <strong class="source-inline">p53</strong> genes<a id="_idIndexMarker572"/> that have been reviewed:<p class="source-code">req = do_request(server, query='gene:p53 AND reviewed:yes', format='tab',</p><p class="source-code"> columns='id,entry name,length,organism,organism-id,database(PDB),database(HGNC)',</p><p class="source-code"> limit='50')</p></li>
</ol>
<p>We will query the <strong class="source-inline">p53</strong> gene and request to see all entries that are reviewed (as in, manually curated). The output will be in a tabular format. We will request a maximum of 50 results, specifying the desired columns.</p>
<p>We could have restricted the output to just human data, but for this example, let’s include all available species.</p>
<ol>
<li value="3">Let’s check the results, as follows:<p class="source-code">import pandas as pd</p><p class="source-code">import io</p><p class="source-code">uniprot_list = pd.read_table(io.StringIO(req.text))</p><p class="source-code">uniprot_list.rename(columns={'Organism ID': 'ID'}, inplace=True)</p><p class="source-code">print(uniprot_list)</p></li>
</ol>
<p>We use <strong class="source-inline">pandas</strong> for easy processing of the tab-delimited list and pretty printing. The abridged output of the Notebook is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 8.1 - An abridged list of species for which there is a TP53 protein " height="410" src="image/B17942_08_01.jpg" width="1055"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 - An abridged list of species for which there is a TP53 protein</p>
<ol>
<li value="4">Now, we <a id="_idIndexMarker573"/>can get the human <strong class="source-inline">p53</strong> ID and use<a id="_idIndexMarker574"/> Biopython to retrieve and parse the <strong class="source-inline">SwissProt</strong> record:<p class="source-code">from Bio import ExPASy, SwissProt</p><p class="source-code">p53_human = uniprot_list[</p><p class="source-code">    (uniprot_list.ID == 9606) &amp;</p><p class="source-code">    (uniprot_list['Entry name'].str.contains('P53'))]['Entry'].iloc[0] </p><p class="source-code">handle = ExPASy.get_sprot_raw(p53_human)</p><p class="source-code">sp_rec = SwissProt.read(handle)</p></li>
</ol>
<p>We then use Biopython’s <strong class="source-inline">SwissProt</strong> module to parse the record. <strong class="source-inline">9606</strong> is the NCBI taxonomic code for humans.</p>
<p>As usual, if there is an error with your network services, it may be a network or server problem. If this is the case, just retry at a later date.</p>
<ol>
<li value="5">Let’s take a look at the <strong class="source-inline">p53</strong> record, as follows:<p class="source-code">print(sp_rec.entry_name, sp_rec.sequence_length, sp_rec.gene_name)</p><p class="source-code">print(sp_rec.description)</p><p class="source-code">print(sp_rec.organism, sp_rec.seqinfo)</p><p class="source-code">print(sp_rec.sequence)</p><p class="source-code">print(sp_rec.comments)</p><p class="source-code">print(sp_rec.keywords)</p></li>
</ol>
<p>The <a id="_idIndexMarker575"/>output is as<a id="_idIndexMarker576"/> follows:</p>
<p class="source-code"><strong class="bold">P53_HUMAN 393 Name=TP53; Synonyms=P53;</strong></p>
<p class="source-code"><strong class="bold"> RecName: Full=Cellular tumor antigen p53; AltName: Full=Antigen NY-CO-13; AltName: Full=Phosphoprotein p53; AltName: Full=Tumor suppressor p53;</strong></p>
<p class="source-code"><strong class="bold"> Homo sapiens (Human). (393, 43653, 'AD5C149FD8106131')</strong></p>
<p class="source-code"><strong class="bold"> MEEPQSDPSVEPPLSQETFSDLWKLLPENNVLSPLPSQAMDDLMLSPDDIEQWFTED PGPDEAPRMPEAAPPVAPAPAAPTPAAPAPAPSWPLSSSVPSQKTYQGSYGFRLGF LHSGTAKSVTCTYSPALNKMFCQLAKTCPVQLWVDSTPPPGTRVRAMAIYKQSQHM TEVVRRCPHHERCSDSDGLAPPQHLIRVEGNLRVEYLDDRNTFRHSVVVPYEPPEVG SDCTTIHYNYMCNSSCMGGMNRRPILTIITLEDSSGNLLGRNSFEVRVCACPGRDRR TEEENLRKKGEPHHELPPGSTKRALPNNTSSSPQPKKKPLDGEYFTLQIRGRERFEM FRELNEALELKDAQAGKEPGGSRAHSSHLKSKKGQSTSRHKKLMFKTEGPDSD</strong></p>
<ol>
<li value="6">A deeper look at the preceding record <a id="_idIndexMarker577"/>reveals a lot of really interesting information, especially on features, <strong class="bold">Gene Ontology</strong> (<strong class="bold">GO</strong>), and database <strong class="source-inline">cross_references</strong>:<p class="source-code">from collections import defaultdict</p><p class="source-code">done_features = set()</p><p class="source-code">print(len(sp_rec.features))</p><p class="source-code">for feature in sp_rec.features:</p><p class="source-code">    if feature[0] in done_features:</p><p class="source-code">        continue</p><p class="source-code">    else:</p><p class="source-code">        done_features.add(feature[0])</p><p class="source-code">        print(feature)</p><p class="source-code">print(len(sp_rec.cross_references))</p><p class="source-code">per_source = defaultdict(list)</p><p class="source-code">for xref in sp_rec.cross_references:</p><p class="source-code">    source = xref[0]</p><p class="source-code">    per_source[source].append(xref[1:])</p><p class="source-code">print(per_source.keys())</p><p class="source-code">done_GOs = set()</p><p class="source-code">print(len(per_source['GO']))</p><p class="source-code">for annot in per_source['GO']:</p><p class="source-code">    if annot[1][0] in done_GOs:</p><p class="source-code">        continue</p><p class="source-code">    else:</p><p class="source-code">        done_GOs.add(annot[1][0])</p><p class="source-code">        print(annot)</p></li>
</ol>
<p>Note<a id="_idIndexMarker578"/> that we are not even printing all of the information<a id="_idIndexMarker579"/> here, just a summary of it. We print a number of features of the sequence with one example per type, a number of external database references, plus databases that are referred to, and a number of GO entries, along with three examples. Currently, there are 1,509 features, 923 external references, and 173 GO terms <a id="_idIndexMarker580"/>just for this protein. Here is a highly<a id="_idIndexMarker581"/> abridged version of the output:</p>
<p class="source-code"><strong class="bold">Total features: 1509</strong></p>
<p class="source-code"><strong class="bold">type: CHAIN</strong></p>
<p class="source-code"><strong class="bold">location: [0:393]</strong></p>
<p class="source-code"><strong class="bold">id: PRO_0000185703</strong></p>
<p class="source-code"><strong class="bold">qualifiers:</strong></p>
<p class="source-code"><strong class="bold">    Key: note, Value: Cellular tumor antigen p53</strong></p>
<p class="source-code"><strong class="bold">type: DNA_BIND</strong></p>
<p class="source-code"><strong class="bold">location: [101:292]</strong></p>
<p class="source-code"><strong class="bold">qualifiers:</strong></p>
<p class="source-code"><strong class="bold">type: REGION</strong></p>
<p class="source-code"><strong class="bold">location: [0:320]</strong></p>
<p class="source-code"><strong class="bold">qualifiers:</strong></p>
<p class="source-code"><strong class="bold">    Key: evidence, Value: ECO:0000269|PubMed:25732823</strong></p>
<p class="source-code"><strong class="bold">    Key: note, Value: Interaction with CCAR2</strong></p>
<p class="source-code"><strong class="bold">[...]</strong></p>
<p class="source-code"><strong class="bold">Cross references:  923</strong></p>
<p class="source-code"><strong class="bold">dict_keys(['EMBL', 'CCDS', 'PIR', 'RefSeq', 'PDB', 'PDBsum', 'BMRB', 'SMR', 'BioGRID', 'ComplexPortal', 'CORUM', 'DIP', 'ELM', 'IntAct', 'MINT', 'STRING', 'BindingDB', 'ChEMBL', 'DrugBank', 'MoonDB', 'TCDB', 'GlyGen', 'iPTMnet', 'MetOSite', 'PhosphoSitePlus', 'BioMuta', 'DMDM', 'SWISS-2DPAGE', 'CPTAC', 'EPD', 'jPOST', 'MassIVE', 'MaxQB', 'PaxDb', 'PeptideAtlas', 'PRIDE', 'ProteomicsDB', 'ABCD', 'Antibodypedia', 'CPTC', 'DNASU', 'Ensembl', 'GeneID', 'KEGG', 'MANE-Select', 'UCSC', 'CTD', 'DisGeNET', 'GeneCards', 'GeneReviews', 'HGNC', 'HPA', 'MalaCards', 'MIM', 'neXtProt', 'OpenTargets', 'Orphanet', 'PharmGKB', 'VEuPathDB', 'eggNOG', 'GeneTree', 'InParanoid', 'OMA', 'OrthoDB', 'PhylomeDB', 'TreeFam', 'PathwayCommons', 'Reactome', 'SABIO-RK', 'SignaLink', 'SIGNOR', 'BioGRID-ORCS', 'ChiTaRS', 'EvolutionaryTrace', 'GeneWiki', 'GenomeRNAi', 'Pharos', 'PRO', 'Proteomes', 'RNAct', 'Bgee', 'ExpressionAtlas', 'Genevisible', 'GO', 'CDD', 'DisProt', 'Gene3D', 'IDEAL', 'InterPro', 'PANTHER', 'Pfam', 'PRINTS', 'SUPFAM', 'PROSITE'])</strong></p>
<p class="source-code"><strong class="bold">Annotation SOURCES: 173</strong></p>
<p class="source-code"><strong class="bold">('GO:0005813', 'C:centrosome', 'IDA:UniProtKB')</strong></p>
<p class="source-code"><strong class="bold">('GO:0036310', 'F:ATP-dependent DNA/DNA annealing activity', 'IDA:UniProtKB')</strong></p>
<p class="source-code"><strong class="bold">('GO:0006914', 'P:autophagy', 'IMP:CAFA')</strong></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/>There’s more</h2>
<p>There <a id="_idIndexMarker582"/>are many more databases with information on proteins – some of these are referred to in the preceding record. You can explore its result to try and find data elsewhere. For detailed information about UniProt’s REST interface, refer to <a href="http://www.uniprot.org/help/programmatic_access">http://www.uniprot.org/help/programmatic_access</a>.</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Introducing Bio.PDB</h1>
<p>Here, we will <a id="_idIndexMarker583"/>introduce Biopython’s <strong class="source-inline">PDB</strong> module for working with the PDB. We will use three models that represent part of the <strong class="source-inline">p53</strong> protein. You can read more about <a id="_idIndexMarker584"/>these files and <strong class="source-inline">p53</strong> at <a href="http://www.rcsb.org/pdb/101/motm.do?momID=31">http://www.rcsb.org/pdb/101/motm.do?momID=31</a>.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>Getting ready</h2>
<p>You should already be aware of the basic <strong class="source-inline">PDB</strong> data model of model, chain, residue, and atom objects. A good<a id="_idIndexMarker585"/> explanation of <em class="italic">Biopython’s Structural Bioinformatics FAQ</em> can be found at <a href="http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ">http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ</a>.</p>
<p>You can find this content in the <strong class="source-inline">Chapter08/PDB.py</strong> Notebook file.</p>
<p>Of the three models that we will download, the <strong class="source-inline">1TUP</strong> model is the one that will be used in the remainder of the recipes. Take some time to study this model, as it will help you later on.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>How to do it...</h2>
<p>Take a look at the<a id="_idIndexMarker586"/> following steps:</p>
<ol>
<li value="1">First, let’s retrieve our models of interest, as follows:<p class="source-code">from Bio import PDB</p><p class="source-code">repository = PDB.PDBList()</p><p class="source-code">repository.retrieve_pdb_file('1TUP', pdir='.', file_format='pdb')</p><p class="source-code">repository.retrieve_pdb_file('1OLG', pdir='.', file_format='pdb')</p><p class="source-code">repository.retrieve_pdb_file('1YCQ', pdir='.', file_format='pdb')</p></li>
</ol>
<p>Note that <strong class="source-inline">Bio.PDB</strong> will take care of downloading files for you. Moreover, these downloads will only occur if no local copy is already present.</p>
<ol>
<li value="2">Let’s parse our records, as shown in the following code:<p class="source-code">parser = PDB.PDBParser()</p><p class="source-code">p53_1tup = parser.get_structure('P 53 - DNA Binding', 'pdb1tup.ent')</p><p class="source-code">p53_1olg = parser.get_structure('P 53 - Tetramerization', 'pdb1olg.ent')</p><p class="source-code">p53_1ycq = parser.get_structure('P 53 - Transactivation', 'pdb1ycq.ent')</p></li>
</ol>
<p>You may get some warnings about the content of the file. These are usually not problematic.</p>
<ol>
<li value="3">Let’s inspect <a id="_idIndexMarker587"/>our headers, as follows:<p class="source-code">def print_pdb_headers(headers, indent=0):</p><p class="source-code">   ind_text = ' ' * indent</p><p class="source-code">   for header, content in headers.items():</p><p class="source-code">       if type(content) == dict:</p><p class="source-code">          print('\n%s%20s:' % (ind_text, header))</p><p class="source-code">          print_pdb_headers(content, indent + 4)</p><p class="source-code">          print()</p><p class="source-code">       elif type(content) == list:</p><p class="source-code">          print('%s%20s:' % (ind_text, header))</p><p class="source-code">          for elem in content:</p><p class="source-code">              print('%s%21s %s' % (ind_text, '-&gt;', elem))</p><p class="source-code">      else:</p><p class="source-code">          print('%s%20s: %s' % (ind_text, header, content))</p><p class="source-code">print_pdb_headers(p53_1tup.header)</p></li>
</ol>
<p>Headers are parsed as a dictionary of dictionaries. As such, we will use a recursive function to parse them. This function will increase the indentation for ease of reading and annotate lists of elements with the <strong class="source-inline">-&gt;</strong> prefix. For an example of recursive functions, refer to the previous chapter, <a href="B17942_07.xhtml#_idTextAnchor183"><em class="italic">Chapter 7</em></a>, <em class="italic">Phylogenetics</em>. For an <a id="_idIndexMarker588"/>advanced discussion on recursion in Python, go to the last chapter, <a href="B17942_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>, <em class="italic">Functional Programming for Bioinformatics</em>. The abridged output is as follows:</p>
<p class="source-code"><strong class="bold">                name: tumor suppressor p53 complexed with dna</strong></p>
<p class="source-code"><strong class="bold">                head: antitumor protein/dna</strong></p>
<p class="source-code"><strong class="bold">              idcode: 1TUP</strong></p>
<p class="source-code"><strong class="bold">     deposition_date: 1995-07-11</strong></p>
<p class="source-code"><strong class="bold">        release_date: 1995-07-11</strong></p>
<p class="source-code"><strong class="bold">    structure_method: x-ray diffraction</strong></p>
<p class="source-code"><strong class="bold">          resolution: 2.2</strong></p>
<p class="source-code"><strong class="bold"> structure_reference:</strong></p>
<p class="source-code"><strong class="bold">                   -&gt; n.p.pavletich,k.a.chambers,c.o.pabo the dna-binding domain of p53 contains the four conserved regions and the major mutation hot spots genes dev. v. 7 2556 1993 issn 0890-9369 </strong></p>
<p class="source-code"><strong class="bold">              author: Y.Cho,S.Gorina,P.D.Jeffrey,N.P.Pavletich</strong></p>
<p class="source-code"><strong class="bold">            compound:</strong></p>
<p class="source-code"><strong class="bold">                       2:</strong></p>
<p class="source-code"><strong class="bold">                        misc: </strong></p>
<p class="source-code"><strong class="bold">                    molecule: dna (5'-d(*ap*tp*ap*ap*tp*tp*gp*gp*gp*cp*ap*ap*gp*tp*cp*tp*a p*gp*gp*ap*a)-3') </strong></p>
<p class="source-code"><strong class="bold">                       chain: f</strong></p>
<p class="source-code"><strong class="bold">                  engineered: yes</strong></p>
<p class="source-code"><strong class="bold">has_missing_residues: True</strong></p>
<p class="source-code"><strong class="bold">    missing_residues:</strong></p>
<p class="source-code"><strong class="bold">                   -&gt; {'model': None, 'res_name': 'ARG', 'chain': 'A', 'ssseq': 290, 'insertion': None}</strong></p>
<p class="source-code"><strong class="bold">keywords: antigen p53, antitumor protein/dna complex</strong></p>
<p class="source-code"><strong class="bold">             journal: AUTH   Y.CHO,S.GORINA,P.D.JEFFREY,N.P.PAVLETICHTITL   CRYSTAL STRUCTURE OF A P53 TUMOR SUPPRESSOR-DNATITL 2 COMPLEX: UNDERSTANDING TUMORIGENIC MUTATIONS.REF    SCIENCE57</strong></p>
<ol>
<li value="4">We want to know<a id="_idIndexMarker589"/> the content of each chain on these files; for this, let’s take a look at the <strong class="source-inline">COMPND</strong> records:<p class="source-code">print(p53_1tup.header['compound'])</p><p class="source-code">print(p53_1olg.header['compound'])</p><p class="source-code">print(p53_1ycq.header['compound'])</p></li>
</ol>
<p>This will return all the compound headers printed in the preceding code. Unfortunately, this is not the best way to get information on chains. An alternative would be to get <strong class="source-inline">DBREF</strong> records, but Biopython’s parser is currently not able to access these. Having said that, using a tool such as <strong class="source-inline">grep</strong> will easily extract this information.</p>
<p>Note that for the <strong class="source-inline">1TUP</strong> model, chains <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong> are from the protein, while chains <strong class="source-inline">E</strong> and <strong class="source-inline">F</strong> are from the DNA. This information will be useful in the future.</p>
<ol>
<li value="5">Let’s do a top-down analysis of each <strong class="source-inline">PDB</strong> file. For now, let’s just get all of the chains, the number of residues, and atoms per chain, as follows:<p class="source-code">def describe_model(name, pdb):</p><p class="source-code">print()</p><p class="source-code">for model in pdb:</p><p class="source-code">    for chain in model:</p><p class="source-code">        print('%s - Chain: %s. Number of residues: %d. Number of atoms: %d.' %</p><p class="source-code">              (name, chain.id, len(chain), len(list(chain.get_atoms()))))</p><p class="source-code">describe_model('1TUP', p53_1tup)</p><p class="source-code">describe_model('1OLG', p53_1olg)</p><p class="source-code">describe_model('1YCQ', p53_1ycq)</p></li>
</ol>
<p>We will perform a<a id="_idIndexMarker590"/> bottom-up approach in a later recipe. Here is the output for <strong class="source-inline">1TUP</strong>:</p>
<p class="source-code"><strong class="bold">1TUP - Chain: E. Number of residues: 43. Number of atoms: 442.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: F. Number of residues: 35. Number of atoms: 449.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: A. Number of residues: 395. Number of atoms: 1734.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: B. Number of residues: 265. Number of atoms: 1593.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: C. Number of residues: 276. Number of atoms: 1610.</strong></p>
<p class="source-code"><strong class="bold"> </strong></p>
<p class="source-code"><strong class="bold">1OLG - Chain: A. Number of residues: 42. Number of atoms: 698.</strong></p>
<p class="source-code"><strong class="bold">1OLG - Chain: B. Number of residues: 42. Number of atoms: 698.</strong></p>
<p class="source-code"><strong class="bold">1OLG - Chain: C. Number of residues: 42. Number of atoms: 698.</strong></p>
<p class="source-code"><strong class="bold">1OLG - Chain: D. Number of residues: 42. Number of atoms: 698.</strong></p>
<p class="source-code"><strong class="bold"> </strong></p>
<p class="source-code"><strong class="bold">1YCQ - Chain: A. Number of residues: 123. Number of atoms: 741.</strong></p>
<p class="source-code"><strong class="bold">1YCQ - Chain: B. Number of residues: 16. Number of atoms: 100.</strong></p>
<ol>
<li value="6">Let’s get all<a id="_idIndexMarker591"/> non-standard residues (<strong class="source-inline">HETATM</strong>), with the exception of water, in the <strong class="source-inline">1TUP</strong> model, as shown in the following code:<p class="source-code">for residue in p53_1tup.get_residues():</p><p class="source-code">    if residue.id[0] in [' ', 'W']:</p><p class="source-code">        continue</p><p class="source-code">print(residue.id)</p></li>
</ol>
<p>We have three zincs, one in each of the protein chains.</p>
<ol>
<li value="7">Let’s take a look at a residue:<p class="source-code">res = next(p53_1tup[0]['A'].get_residues())</p><p class="source-code">print(res)</p><p class="source-code">for atom in res:</p><p class="source-code">    print(atom, atom.serial_number, atom.element)</p><p class="source-code">p53_1tup[0]['A'][94]['CA']</p></li>
</ol>
<p>This will print all the atoms in a certain residue:</p>
<p class="source-code"><strong class="bold">&lt;Residue SER het=  resseq=94 icode= &gt;</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom N&gt; 858 N</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom CA&gt; 859 C</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom C&gt; 860 C</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom O&gt; 861 O</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom CB&gt; 862 C</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom OG&gt; 863 O</strong></p>
<p class="source-code"><strong class="bold"> &lt;Atom CA&gt;</strong></p>
<p>Note the last statement. It is there just to show you that you can directly access an atom by resolving the model, chain, residue, and finally, the atom.</p>
<ol>
<li value="8">Finally, let’s <a id="_idIndexMarker592"/>export the protein fragment to a FASTA file, as follows:<p class="source-code">from Bio.SeqIO import PdbIO, FastaIO</p><p class="source-code">def get_fasta(pdb_file, fasta_file, transfer_ids=None):</p><p class="source-code">    fasta_writer = FastaIO.FastaWriter(fasta_file)</p><p class="source-code">    fasta_writer.write_header()</p><p class="source-code">    for rec in PdbIO.PdbSeqresIterator(pdb_file):</p><p class="source-code">        if len(rec.seq) == 0:</p><p class="source-code">            continue</p><p class="source-code">        if transfer_ids is not None and rec.id not in transfer_ids:</p><p class="source-code">            continue</p><p class="source-code">        print(rec.id, rec.seq, len(rec.seq))</p><p class="source-code">        fasta_writer.write_record(rec)</p><p class="source-code">        </p><p class="source-code">get_fasta(open('pdb1tup.ent'), open('1tup.fasta', 'w'), transfer_ids=['1TUP:B'])</p><p class="source-code">get_fasta(open('pdb1olg.ent'), open('1olg.fasta', 'w'), transfer_ids=['1OLG:B'])</p><p class="source-code">get_fasta(open('pdb1ycq.ent'), open('1ycq.fasta', 'w'), transfer_ids=['1YCQ:B'])</p></li>
</ol>
<p>If you inspect the <a id="_idIndexMarker593"/>protein chain, you will see that they are equal in each model, so we export a single one. In the case of <strong class="source-inline">1YCQ</strong>, we export the smallest one, because the biggest one is not <strong class="source-inline">p53</strong>-related. As you can see, here, we are using <strong class="source-inline">Bio.SeqIO</strong>, not <strong class="source-inline">Bio.PDB</strong>.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/>There’s more</h2>
<p>The PDB parser is incomplete. It’s not very likely that a complete parser will be seen soon, as the community is migrating to the mmCIF format.</p>
<p>Although the future is the <a id="_idIndexMarker594"/>mmCIF format (<a href="http://mmcif.wwpdb.org/">http://mmcif.wwpdb.org/</a>), PDB files are still around. Conceptually, many operations are similar after you have parsed the file.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/>Extracting more information from a PDB file</h1>
<p>Here, we will <a id="_idIndexMarker595"/>continue our exploration of the record structure <a id="_idIndexMarker596"/>produced by <strong class="source-inline">Bio.PDB</strong> from PDB files.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>Getting ready</h2>
<p>For general information about the PDB models that we are using, refer to the previous recipe.</p>
<p>You can find this content in the <strong class="source-inline">Chapter08/Stats.py</strong> Notebook file.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>How to do it...</h2>
<p>We’ll get started, using the following steps:</p>
<ol>
<li value="1">First, let’s retrieve <strong class="source-inline">1TUP</strong>, as follows:<p class="source-code">from Bio import PDB</p><p class="source-code">repository = PDB.PDBList()</p><p class="source-code">parser = PDB.PDBParser()</p><p class="source-code">repository.retrieve_pdb_file('1TUP', pdir='.', file_format='pdb') p53_1tup = parser.get_structure('P 53', 'pdb1tup.ent')</p></li>
<li>Then, extract <a id="_idIndexMarker597"/>some <a id="_idIndexMarker598"/>atom-related statistics:<p class="source-code">from collections import defaultdict</p><p class="source-code">atom_cnt = defaultdict(int)</p><p class="source-code">atom_chain = defaultdict(int)</p><p class="source-code">atom_res_types = defaultdict(int)</p><p class="source-code">for atom in p53_1tup.get_atoms():</p><p class="source-code">    my_residue = atom.parent</p><p class="source-code">    my_chain = my_residue.parent</p><p class="source-code">    atom_chain[my_chain.id] += 1</p><p class="source-code">    if my_residue.resname != 'HOH':</p><p class="source-code">        atom_cnt[atom.element] += 1</p><p class="source-code">    atom_res_types[my_residue.resname] += 1</p><p class="source-code">print(dict(atom_res_types))</p><p class="source-code">print(dict(atom_chain))</p><p class="source-code">print(dict(atom_cnt))</p></li>
</ol>
<p>This will print information on the atom’s residue type, the number of atoms per chain, and the quantity per element, as follows:</p>
<p class="source-code"><strong class="bold">{' DT': 257, ' DC': 152, ' DA': 270, ' DG': 176, 'HOH': 384, 'SER': 323, 'VAL': 315, 'PRO': 294, 'GLN': 189, 'LYS': 135, 'THR': 294, 'TYR': 288, 'GLY': 156, 'PHE': 165, 'ARG': 561, 'LEU': 336, 'HIS': 210, 'ALA': 105, 'CYS': 180, 'ASN': 216, 'MET': 144, 'TRP': 42, 'ASP': 192, 'ILE': 144, 'GLU': 297, ' ZN': 3}</strong></p>
<p class="source-code"><strong class="bold"> {'E': 442, 'F': 449, 'A': 1734, 'B': 1593, 'C': 1610}</strong></p>
<p class="source-code"><strong class="bold"> {'O': 1114, 'C': 3238, 'N': 1001, 'P': 40, 'S': 48, 'ZN': 3}</strong></p>
<p>Note that the preceding number of residues is not the proper number of residues, but the amount of times that a certain residue type is referred to (it adds up to the number of atoms, not residues).</p>
<p>Notice the<a id="_idIndexMarker599"/> water (<strong class="source-inline">W</strong>), nucleotide (<strong class="source-inline">DA</strong>, <strong class="source-inline">DC</strong>, <strong class="source-inline">DG</strong>, and <strong class="source-inline">DT</strong>), and<a id="_idIndexMarker600"/> zinc (<strong class="source-inline">ZN</strong>) residues, which add to the amino acid ones.</p>
<ol>
<li value="3">Now, let’s count the instance per residue and the number of residues per chain:<p class="source-code">res_types = defaultdict(int)</p><p class="source-code">res_per_chain = defaultdict(int)</p><p class="source-code">for residue in p53_1tup.get_residues():</p><p class="source-code">res_types[residue.resname] += 1</p><p class="source-code">res_per_chain[residue.parent.id] +=1</p><p class="source-code">print(dict(res_types))</p><p class="source-code">print(dict(res_per_chain))</p></li>
</ol>
<p>The following is the output:</p>
<p class="source-code"><strong class="bold">{' DT': 13, ' DC': 8, ' DA': 13, ' DG': 8, 'HOH': 384, 'SER': 54, 'VAL': 45, 'PRO': 42, 'GLN': 21, 'LYS': 15, 'THR': 42, 'TYR': 24, 'GLY': 39, 'PHE': 15, 'ARG': 51, 'LEU': 42, 'HIS': 21, 'ALA': 21, 'CYS': 30, 'ASN': 27, 'MET': 18, 'TRP': 3, 'ASP': 24, 'ILE': 18, 'GLU': 33, ' ZN': 3}</strong></p>
<p class="source-code"><strong class="bold"> {'E': 43, 'F': 35, 'A': 395, 'B': 265, 'C': 276}</strong></p>
<ol>
<li value="4">We can also get the bounds of a set of atoms:<p class="source-code">import sys</p><p class="source-code">def get_bounds(my_atoms):</p><p class="source-code">    my_min = [sys.maxsize] * 3</p><p class="source-code">    my_max = [-sys.maxsize] * 3</p><p class="source-code">    for atom in my_atoms:</p><p class="source-code">        for i, coord in enumerate(atom.coord):</p><p class="source-code">            if coord &lt; my_min[i]:</p><p class="source-code">                my_min[i] = coord</p><p class="source-code">            if coord &gt; my_max[i]:</p><p class="source-code">                my_max[i] = coord</p><p class="source-code">    return my_min, my_max</p><p class="source-code">chain_bounds = {}</p><p class="source-code">for chain in p53_1tup.get_chains():</p><p class="source-code">    print(chain.id, get_bounds(chain.get_atoms()))</p><p class="source-code">    chain_bounds[chain.id] = get_bounds(chain.get_atoms())</p><p class="source-code">print(get_bounds(p53_1tup.get_atoms()))</p></li>
</ol>
<p>A set of <a id="_idIndexMarker601"/>atoms can be a whole model, a chain, a <a id="_idIndexMarker602"/>residue, or any subset that you are interested in. In this case, we will print boundaries for all the chains and the whole model. Numbers don’t convey it so intuitively, so we will get a little bit more graphical.</p>
<ol>
<li value="5">To get a notion of the size of each chain, a plot is probably more informative than the numbers in the preceding code:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">from mpl_toolkits.mplot3d import Axes3D</p><p class="source-code">fig = plt.figure(figsize=(16, 9))</p><p class="source-code">ax3d = fig.add_subplot(111, projection='3d')</p><p class="source-code">ax_xy = fig.add_subplot(331)</p><p class="source-code">ax_xy.set_title('X/Y')</p><p class="source-code">ax_xz = fig.add_subplot(334)</p><p class="source-code">ax_xz.set_title('X/Z')</p><p class="source-code">ax_zy = fig.add_subplot(337)</p><p class="source-code">ax_zy.set_title('Z/Y')</p><p class="source-code">color = {'A': 'r', 'B': 'g', 'C': 'b', 'E': '0.5', 'F': '0.75'}</p><p class="source-code">zx, zy, zz = [], [], []</p><p class="source-code">for chain in p53_1tup.get_chains():</p><p class="source-code">    xs, ys, zs = [], [], []</p><p class="source-code">    for residue in chain.get_residues():</p><p class="source-code">        ref_atom = next(residue.get_iterator())</p><p class="source-code">        x, y, z = ref_atom.coord</p><p class="source-code">        if ref_atom.element == 'ZN':</p><p class="source-code">            zx.append(x)</p><p class="source-code">            zy.append(y)</p><p class="source-code">            zz.append(z)</p><p class="source-code">            continue</p><p class="source-code">        xs.append(x)</p><p class="source-code">        ys.append(y)</p><p class="source-code">        zs.append(z)</p><p class="source-code">    ax3d.scatter(xs, ys, zs, color=color[chain.id])</p><p class="source-code">    ax_xy.scatter(xs, ys, marker='.', color=color[chain.id])</p><p class="source-code">    ax_xz.scatter(xs, zs, marker='.', color=color[chain.id])</p><p class="source-code">    ax_zy.scatter(zs, ys, marker='.', color=color[chain.id])</p><p class="source-code">ax3d.set_xlabel('X')</p><p class="source-code">ax3d.set_ylabel('Y')</p><p class="source-code">ax3d.set_zlabel('Z')</p><p class="source-code">ax3d.scatter(zx, zy, zz, color='k', marker='v', s=300)</p><p class="source-code">ax_xy.scatter(zx, zy, color='k', marker='v', s=80)</p><p class="source-code">ax_xz.scatter(zx, zz, color='k', marker='v', s=80)</p><p class="source-code">ax_zy.scatter(zz, zy, color='k', marker='v', s=80)</p><p class="source-code">for ax in [ax_xy, ax_xz, ax_zy]:</p><p class="source-code">    ax.get_yaxis().set_visible(False)</p><p class="source-code">    ax.get_xaxis().set_visible(False)</p></li>
</ol>
<p>There are plenty of <a id="_idIndexMarker603"/>molecular visualization tools. Indeed, we will <a id="_idIndexMarker604"/>discuss PyMOL later. However, <strong class="source-inline">matplotlib</strong> is enough for simple visualization. The most important point about <strong class="source-inline">matplotlib</strong> is that it’s stable and very easy to integrate into reliable production code.</p>
<p>In the following chart, we performed a three-dimensional plot of chains, with the DNA in grey and the protein chains in different colors. We also plot planar projections (<strong class="bold">X/Y</strong>, <strong class="bold">X/Z</strong>, and <strong class="bold">Z/Y</strong>) on the left-hand side of the following graph:</p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 8.2 - The spatial distribution of the protein chains – the main figure is a 3D plot and the left subplots are planar views (X/Y, X/Z, and Z/Y) " height="531" src="image/B17942_08_02.jpg" width="907"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 - The spatial distribution of the protein chains – the main figure is a 3D plot and the left subplots are planar views (X/Y, X/Z, and Z/Y)</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor222"/>Computing molecular distances on a PDB file</h1>
<p>Here, we<a id="_idIndexMarker605"/> will find atoms closer to three zincs in<a id="_idIndexMarker606"/> the <strong class="source-inline">1TUP</strong> model. We will consider several distances to these zincs. We will take this opportunity to discuss the performance of algorithms.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/>Getting ready</h2>
<p>You can find this content in the <strong class="source-inline">Chapter08/Distance.py</strong> Notebook file.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li value="1">Let’s load our model, as follows:<p class="source-code">from Bio import PDB</p><p class="source-code">repository = PDB.PDBList()</p><p class="source-code">parser = PDB.PDBParser()</p><p class="source-code">repository.retrieve_pdb_file('1TUP', pdir='.', file_format='pdb')</p><p class="source-code">p53_1tup = parser.get_structure('P 53', 'pdb1tup.ent')</p></li>
<li>We will now get our zincs, against which we will perform comparisons later:<p class="source-code">zns = []for atom in p53_1tup.get_atoms():</p><p class="source-code">if atom.element == 'ZN':</p><p class="source-code">zns.append(atom)</p><p class="source-code">for zn in zns:</p><p class="source-code">    print(zn, zn.coord)</p></li>
</ol>
<p>You should see three zinc atoms.</p>
<ol>
<li value="3">Now, let’s <a id="_idIndexMarker607"/>define a function to get the<a id="_idIndexMarker608"/> distance between one atom and a set of other atoms, as follows:<p class="source-code">import math</p><p class="source-code">def get_closest_atoms(pdb_struct, ref_atom, distance):</p><p class="source-code">    atoms = {}</p><p class="source-code">    rx, ry, rz = ref_atom.coord</p><p class="source-code">    for atom in pdb_struct.get_atoms():</p><p class="source-code">        if atom == ref_atom:</p><p class="source-code">            continue</p><p class="source-code">        x, y, z = atom.coord</p><p class="source-code">        my_dist = math.sqrt((x - rx)**2 + (y - ry)**2 + (z - rz)**2)</p><p class="source-code">        if my_dist &lt; distance:</p><p class="source-code">            atoms[atom] = my_dist</p><p class="source-code">    return atoms</p></li>
</ol>
<p>We get coordinates for our reference atom and then iterate over our desired comparison list. If an atom is close enough, it’s added to the <strong class="source-inline">return</strong> list.</p>
<ol>
<li value="4">We now <a id="_idIndexMarker609"/>compute the atoms near our<a id="_idIndexMarker610"/> zincs, the distance of which can be up to 4 Ångströms for our model:<p class="source-code">for zn in zns:</p><p class="source-code">    print()</p><p class="source-code">    print(zn.coord)</p><p class="source-code">    atoms = get_closest_atoms(p53_1tup, zn, 4)</p><p class="source-code">    for atom, distance in atoms.items():</p><p class="source-code">        print(atom.element, distance, atom.coord)</p></li>
</ol>
<p>Here, we show the result for the first zinc, including the element, distance, and coordinates:</p>
<p class="source-code"><strong class="bold">[58.108 23.242 57.424]</strong></p>
<p class="source-code"><strong class="bold"> C 3.4080117696286854 [57.77  21.214 60.142]</strong></p>
<p class="source-code"><strong class="bold"> S 2.3262243799594877 [57.065 21.452 58.482]</strong></p>
<p class="source-code"><strong class="bold"> C 3.4566537492335123 [58.886 20.867 55.036]</strong></p>
<p class="source-code"><strong class="bold"> C 3.064120559761192 [58.047 22.038 54.607]</strong></p>
<p class="source-code"><strong class="bold"> N 1.9918273537290707 [57.755 23.073 55.471]</strong></p>
<p class="source-code"><strong class="bold"> C 2.9243719601324525 [56.993 23.943 54.813]</strong></p>
<p class="source-code"><strong class="bold"> C 3.857729198122736 [61.148 25.061 55.897]</strong></p>
<p class="source-code"><strong class="bold"> C 3.62725094648044 [61.61  24.087 57.001]</strong></p>
<p class="source-code"><strong class="bold"> S 2.2789209624943494 [60.317 23.318 57.979]</strong></p>
<p class="source-code"><strong class="bold"> C 3.087214470667822 [57.205 25.099 59.719]</strong></p>
<p class="source-code"><strong class="bold"> S 2.2253158446520818 [56.914 25.054 57.917]</strong></p>
<p>We only have three zincs, so the number of computations is quite significantly reduced. However, imagine that we had more, or that we were doing a pairwise comparison among all the atoms in the set (remember that the number of comparisons grows quadratically with the number of atoms in a pairwise case). Although our case is small, it’s not difficult to forecast use cases, while more comparisons<a id="_idIndexMarker611"/> take a lot of time. We will <a id="_idIndexMarker612"/>get back to this soon.</p>
<ol>
<li value="5">Let’s see how many atoms we get as we increase the distance:<p class="source-code">for distance in [1, 2, 4, 8, 16, 32, 64, 128]:</p><p class="source-code">    my_atoms = []</p><p class="source-code">    for zn in zns:</p><p class="source-code">        atoms = get_closest_atoms(p53_1tup, zn, distance)</p><p class="source-code">        my_atoms.append(len(atoms))</p><p class="source-code">    print(distance, my_atoms)</p></li>
</ol>
<p>The result is as follows:</p>
<p class="source-code"><strong class="bold">1 [0, 0, 0]</strong></p>
<p class="source-code"><strong class="bold">2 [1, 0, 0]</strong></p>
<p class="source-code"><strong class="bold">4 [11, 11, 12]</strong></p>
<p class="source-code"><strong class="bold">8 [109, 113, 106]</strong></p>
<p class="source-code"><strong class="bold">16 [523, 721, 487]</strong></p>
<p class="source-code"><strong class="bold">32 [2381, 3493, 2053]</strong></p>
<p class="source-code"><strong class="bold">64 [5800, 5827, 5501]</strong></p>
<p class="source-code"><strong class="bold">128 [5827, 5827, 5827]</strong></p>
<ol>
<li value="6">As we have <a id="_idIndexMarker613"/>seen previously, this specific<a id="_idIndexMarker614"/> case is not very expensive, but let’s time it anyway:<p class="source-code">import timeit</p><p class="source-code">nexecs = 10</p><p class="source-code">print(timeit.timeit('get_closest_atoms(p53_1tup, zns[0], 4.0)',</p><p class="source-code">      'from __main__ import get_closest_atoms, p53_1tup, zns',</p><p class="source-code">      number=nexecs) / nexecs * 1000)</p></li>
</ol>
<p>Here, we will use the <strong class="source-inline">timeit</strong> module to execute this function 10 times and then print the result in milliseconds. We pass the function as a string and pass yet another string with the necessary imports to make this function work. On a Notebook, you are probably aware of the <strong class="source-inline">%timeit</strong> magic and how it makes your life much easier in this case. This takes roughly 40 milliseconds on the machine where the code was tested. Obviously, on your computer, you will get somewhat different results.</p>
<ol>
<li value="7">Can we do better? Let’s consider a different <strong class="source-inline">distance</strong> function, as shown in the following code:<p class="source-code">def get_closest_alternative(pdb_struct, ref_atom, distance):</p><p class="source-code">    atoms = {}</p><p class="source-code">    rx, ry, rz = ref_atom.coord</p><p class="source-code">    for atom in pdb_struct.get_atoms():</p><p class="source-code">        if atom == ref_atom:</p><p class="source-code">            continue</p><p class="source-code">        x, y, z = atom.coord</p><p class="source-code">        if abs(x - rx) &gt; distance or abs(y - ry) &gt; distance or abs(z - rz) &gt; distance:</p><p class="source-code">            continue</p><p class="source-code">        my_dist = math.sqrt((x - rx)**2 + (y - ry)**2 + (z - rz)**2)</p><p class="source-code">        if my_dist &lt; distance:</p><p class="source-code">            atoms[atom] = my_dist</p><p class="source-code">    return atoms</p></li>
</ol>
<p>So, we take <a id="_idIndexMarker615"/>the original <a id="_idIndexMarker616"/>function and add a very simplistic <strong class="source-inline">if</strong> with the distances. The rationale for this is that the computational cost of the square root, and maybe the float power operation, is very expensive, so we will try to avoid it. However, for all atoms that are closer than the target distance in any dimension, this function will be more expensive.</p>
<ol>
<li value="8">Now, let’s time against it:<p class="source-code">print(timeit.timeit('get_closest_alternative(p53_1tup, zns[0], 4.0)',</p><p class="source-code">      'from __main__ import get_closest_alternative, p53_1tup, zns',</p><p class="source-code">      number=nexecs) / nexecs * 1000)</p></li>
</ol>
<p>On the same machine that we used in the preceding example, it takes 16 milliseconds, which means that it is roughly three times faster.</p>
<ol>
<li value="9">However, is this always better? Let’s compare the cost with different distances, as follows:<p class="source-code">print('Standard')</p><p class="source-code">for distance in [1, 4, 16, 64, 128]:</p><p class="source-code">    print(timeit.timeit('get_closest_atoms(p53_1tup, zns[0], distance)',</p><p class="source-code">          'from __main__ import get_closest_atoms, p53_1tup, zns, distance',</p><p class="source-code">          number=nexecs) / nexecs * 1000)</p><p class="source-code">print('Optimized')</p><p class="source-code">for distance in [1, 4, 16, 64, 128]:</p><p class="source-code">    print(timeit.timeit('get_closest_alternative(p53_1tup, zns[0], distance)',</p><p class="source-code">          'from __main__ import get_closest_alternative, p53_1tup, zns, distance',</p><p class="source-code">          number=nexecs) / nexecs * 1000)</p></li>
</ol>
<p>The result is<a id="_idIndexMarker617"/> shown in the following<a id="_idIndexMarker618"/> output:</p>
<p class="source-code"><strong class="bold">Standard</strong></p>
<p class="source-code"><strong class="bold"> 85.08649739999328</strong></p>
<p class="source-code"><strong class="bold"> 86.50681579999855</strong></p>
<p class="source-code"><strong class="bold"> 86.79630599999655</strong></p>
<p class="source-code"><strong class="bold"> 96.95437099999253</strong></p>
<p class="source-code"><strong class="bold"> 96.21982420001132</strong></p>
<p class="source-code"><strong class="bold"> Optimized</strong></p>
<p class="source-code"><strong class="bold"> 30.253444099980698</strong></p>
<p class="source-code"><strong class="bold"> 32.69531210000878</strong></p>
<p class="source-code"><strong class="bold"> 52.965772600009586</strong></p>
<p class="source-code"><strong class="bold"> 142.53310030001103</strong></p>
<p class="source-code"><strong class="bold"> 141.26269519999823</strong></p>
<p>Note that the cost of the Standard version is mostly constant, whereas the Optimized version varies depending on the distance of the closest atoms; the larger the distance, the more cases that will be computed using the extra <strong class="source-inline">if</strong>, plus the square root, making the function more expensive.</p>
<p>The larger <a id="_idIndexMarker619"/>point here is that you can probably code <a id="_idIndexMarker620"/>functions that are more efficient using smart computation shortcuts, but the complexity cost may change qualitatively. In the preceding case, I suggest that the second function is more efficient for all realistic and interesting cases when you’re trying to find the closest atoms. However, you have to be careful while designing your own versions of optimized algorithms.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor225"/>Performing geometric operations</h1>
<p>We will now perform <a id="_idIndexMarker621"/>computations with geometry information, including computing the center of the mass of chains and whole models.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/>Getting ready</h2>
<p>You can find this content in the <strong class="source-inline">Chapter08/Mass.py</strong> Notebook file.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>How to do it...</h2>
<p>Let’s take a look at the following steps:</p>
<ol>
<li value="1">First, let’s retrieve the data:<p class="source-code">from Bio import PDB</p><p class="source-code">repository = PDB.PDBList()</p><p class="source-code">parser = PDB.PDBParser()</p><p class="source-code">repository.retrieve_pdb_file('1TUP', pdir='.', file_format='pdb')</p><p class="source-code">p53_1tup = parser.get_structure('P 53', 'pdb1tup.ent')</p></li>
<li>Then, let’s recall the type of residues that we have with the following code:<p class="source-code">my_residues = set()</p><p class="source-code">for residue in p53_1tup.get_residues():</p><p class="source-code">    my_residues.add(residue.id[0])</p><p class="source-code">print(my_residues)</p></li>
</ol>
<p>So, we have <strong class="source-inline">H_ ZN</strong> (zinc) and <strong class="source-inline">W</strong> (water), which are <strong class="source-inline">HETATM</strong> types; the vast majority are standard PDB atoms.</p>
<ol>
<li value="3">Let’s compute <a id="_idIndexMarker622"/>the masses for all chains, zincs, and waters using the following code:<p class="source-code">def get_mass(atoms, accept_fun=lambda atom: atom.parent.id[0] != 'W'):</p><p class="source-code">    return sum([atom.mass for atom in atoms if accept_fun(atom)])</p><p class="source-code">chain_names = [chain.id for chain in p53_1tup.get_chains()]</p><p class="source-code">my_mass = np.ndarray((len(chain_names), 3))</p><p class="source-code">for i, chain in enumerate(p53_1tup.get_chains()):</p><p class="source-code">    my_mass[i, 0] = get_mass(chain.get_atoms())</p><p class="source-code">    my_mass[i, 1] = get_mass(chain.get_atoms(),</p><p class="source-code">        accept_fun=lambda atom: atom.parent.id[0] not in [' ', 'W'])</p><p class="source-code">    my_mass[i, 2] = get_mass(chain.get_atoms(),</p><p class="source-code">        accept_fun=lambda atom: atom.parent.id[0] == 'W')</p><p class="source-code">masses = pd.DataFrame(my_mass, index=chain_names, columns=['No Water','Zincs', 'Water'])</p><p class="source-code">print(masses)</p></li>
</ol>
<p>The <strong class="source-inline">get_mass</strong> function returns the mass of all atoms in the list that pass an acceptance criterion function. Here, the default acceptance criterion involves not being a water residue.</p>
<p>We then compute the mass for all chains. We have three versions: just amino acids, zincs, and water. Zinc does nothing more than detect a single atom per chain in this model. The output is as follows:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><img alt="Figure 8.3 - The mass for all protein chains " height="180" src="image/B17942_08_03.png" width="360"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 - The mass for all protein chains</p>
<ol>
<li value="4">Let’s compute the <a id="_idIndexMarker623"/>geometric center and the center of mass of the model, as follows:<p class="source-code">def get_center(atoms,</p><p class="source-code">    weight_fun=lambda atom: 1 if atom.parent.id[0] != 'W' else 0):</p><p class="source-code">    xsum = ysum = zsum = 0.0</p><p class="source-code">    acum = 0.0</p><p class="source-code">    for atom in atoms:</p><p class="source-code">        x, y, z = atom.coord</p><p class="source-code">        weight = weight_fun(atom)</p><p class="source-code">        acum += weight</p><p class="source-code">        xsum += weight * x</p><p class="source-code">        ysum += weight * y</p><p class="source-code">        zsum += weight * z</p><p class="source-code">    return xsum / acum, ysum / acum, zsum / acum</p><p class="source-code">print(get_center(p53_1tup.get_atoms()))</p><p class="source-code">print(get_center(p53_1tup.get_atoms(),</p><p class="source-code">    weight_fun=lambda atom: atom.mass if atom.parent.id[0] != 'W' else 0))</p></li>
</ol>
<p>First, we define a weighted function to get the coordinates of the center. The default function will treat all atoms as equal, as long as they are not a water residue.</p>
<p>We then compute the geometric center and the center of mass by redefining the <strong class="source-inline">weight</strong> function with a value of each atom equal to its mass. The geometric center is computed, irrespective of its molecular weights.</p>
<p>For example, you may want to compute the center of mass of the protein without DNA chains.</p>
<ol>
<li value="5">Let’s compute the <a id="_idIndexMarker624"/>center of mass and the geometric center of each chain, as follows:<p class="source-code">my_center = np.ndarray((len(chain_names), 6))</p><p class="source-code">for i, chain in enumerate(p53_1tup.get_chains()):</p><p class="source-code">    x, y, z = get_center(chain.get_atoms())</p><p class="source-code">    my_center[i, 0] = x</p><p class="source-code">    my_center[i, 1] = y</p><p class="source-code">    my_center[i, 2] = z</p><p class="source-code">    x, y, z = get_center(chain.get_atoms(),</p><p class="source-code">        weight_fun=lambda atom: atom.mass if atom.parent.id[0] != 'W' else 0)</p><p class="source-code">    my_center[i, 3] = x</p><p class="source-code">    my_center[i, 4] = y</p><p class="source-code">    my_center[i, 5] = z</p><p class="source-code">weights = pd.DataFrame(my_center, index=chain_names,</p><p class="source-code">    columns=['X', 'Y', 'Z', 'X (Mass)', 'Y (Mass)', 'Z (Mass)'])</p><p class="source-code">print(weights)</p></li>
</ol>
<p>The result is <a id="_idIndexMarker625"/>shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 8.4 - The center of mass and the geometric center of each protein chain " height="181" src="image/B17942_08_04.jpg" width="487"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 - The center of mass and the geometric center of each protein chain</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>There’s more</h2>
<p>Although this is not<a id="_idIndexMarker626"/> a book based on the protein structure determination technique, it’s important to remember that X-ray crystallography methods cannot detect hydrogens, so computing the mass of residues might be based on very inaccurate models; refer to <a href="http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm">http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm</a> for more information.</p>
<h1 id="_idParaDest-230"><a id="_idTextAnchor229"/>Animating with PyMOL</h1>
<p>Here, we will<a id="_idIndexMarker627"/> create a video of the p53 <strong class="source-inline">1TUP</strong> model. For that, we will use the PyMOL visualization library. We will start our animation by moving around the p53 <strong class="source-inline">1TUP</strong> model and then zooming in; as we zoom in, we change the rendering strategy so that you can see deeper into the model. You can find a version of the video that you will generate at <a href="https://odysee.com/@Python:8/protein_video:8%20">https://odysee.com/@Python:8/protein_video:8</a>.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/>Getting ready</h2>
<p>This recipe will be presented as a Python script, not as a Notebook. This is mostly because the output is not interactive, but a set of image files that will need further post-processing.</p>
<p>You will need to install <a id="_idIndexMarker628"/>PyMOL (<a href="http://www.pymol.org">http://www.pymol.org</a>). On Debian, Ubuntu, or Linux, you can use the <strong class="source-inline">apt-get install pymol</strong> command. If you are on Conda, I suggest not using it, as the dependencies will be easy to resolve – furthermore, you will be installing a 30-day-trial-only version requiring a license, whereas the version above is fully open source. If you are not on Debian or Linux, I suggest that you install the open source version available for your operating system.</p>
<p>PyMOL is more of an interactive program than a Python library, so I strongly encourage you to play with it before moving on to the recipe. This can be fun! The code for this recipe is available on the GitHub repository as a script, along with this chapter’s Notebook file, at <strong class="source-inline">Chapter08</strong>. We will use the <strong class="source-inline">PyMol_Movie.py</strong> file in this recipe.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>How to do it...</h2>
<p>Take a look <a id="_idIndexMarker629"/>at the following steps:</p>
<ol>
<li value="1">Let’s initialize and retrieve our PDB model and prepare the rendering, as follows:<p class="source-code">import pymol</p><p class="source-code">from pymol import cmd</p><p class="source-code">#pymol.pymol_argv = ['pymol', '-qc'] # Quiet / no GUI</p><p class="source-code">pymol.finish_launching()</p><p class="source-code">cmd.fetch('1TUP', async=False)</p><p class="source-code">cmd.disable('all')</p><p class="source-code">cmd.enable('1TUP')</p><p class="source-code">cmd.hide('all')</p><p class="source-code">cmd.show('sphere', 'name zn')</p></li>
</ol>
<p>Note that the <strong class="source-inline">pymol_argv</strong> line makes the code silent. In your first execution, you may want to comment this out and see the user interface.</p>
<p>For movie rendering, this will come in handy (as we will see soon). As a library, PyMOL is quite tricky to use. For instance, after the import, you have to call <strong class="source-inline">finish_launching</strong>. We then fetch our PDB file.</p>
<p>What then follows is a set of PyMOL commands. Many web guides for interactive usage can be quite useful for understanding what is going on. Here, we will enable all of the models for viewing purposes, hiding all (because the default view is of lines and this is not good enough), then making the zincs visible as spheres.</p>
<p>At this stage, bar zinc, everything else is invisible.</p>
<ol>
<li value="2">To <a id="_idIndexMarker630"/>render our model, we will use three scenes, as follows:<p class="source-code">cmd.show('surface', 'chain A+B+C')</p><p class="source-code">cmd.show('cartoon', 'chain E+F')</p><p class="source-code">cmd.scene('S0', action='store', view=0, frame=0, animate=-1)</p><p class="source-code">cmd.show('cartoon')</p><p class="source-code">cmd.hide('surface')</p><p class="source-code">cmd.scene('S1', action='store', view=0, frame=0, animate=-1)</p><p class="source-code">cmd.hide('cartoon', 'chain A+B+C')</p><p class="source-code">cmd.show('mesh', 'chain A')</p><p class="source-code">cmd.show('sticks', 'chain A+B+C')</p><p class="source-code">cmd.scene('S2', action='store', view=0, frame=0, animate=-1)</p></li>
</ol>
<p>We need to define two scenes. One scene corresponds to us moving around the protein (surface-based, thus opaque) and the other corresponds to us diving in (cartoon-based). The DNA is always rendered as a cartoon.</p>
<p>We also define a third scene for when we zoom out at the end. The protein will be rendered as sticks, and we add a mesh to chain A so that the relationship with the DNA becomes clearer.</p>
<ol>
<li value="3">Let’s define the basic parameter of our video, as follows:<p class="source-code">cmd.set('ray_trace_frames', 0)</p><p class="source-code">cmd.mset(1, 500)</p></li>
</ol>
<p>We define the default ray-tracing algorithm. This line does not need to be there, but try to increase the number to <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, or <strong class="source-inline">3</strong> and be ready to wait a lot.</p>
<p>You can only use <strong class="source-inline">0</strong> if you have the OpenGL interface on (with the GUI), so, for this fast version, you will need to have the GUI on (<strong class="source-inline">pymol_argv</strong> should be commented as it is).</p>
<p>We then inform PyMOL that we will have 500 frames.</p>
<ol>
<li value="4">In the <a id="_idIndexMarker631"/>first 150 frames, we move around using the initial scene. We move around the model a bit and then move nearer to the DNA using the following code:<p class="source-code">cmd.frame(0)</p><p class="source-code">cmd.scene('S0')</p><p class="source-code">cmd.mview()</p><p class="source-code">cmd.frame(60)</p><p class="source-code">cmd.set_view((-0.175534308,   -0.331560850,   -0.926960170,</p><p class="source-code">             0.541812420,     0.753615797,   -0.372158051,</p><p class="source-code">             0.821965039,    -0.567564785,    0.047358301,</p><p class="source-code">             0.000000000,     0.000000000, -249.619018555,</p><p class="source-code">             58.625568390,   15.602619171,   77.781631470,</p><p class="source-code">             196.801528931, 302.436492920,  -20.000000000))</p><p class="source-code">cmd.mview()</p><p class="source-code">cmd.frame(90)</p><p class="source-code">cmd.set_view((-0.175534308,   -0.331560850,   -0.926960170,</p><p class="source-code">              0.541812420,    0.753615797,   -0.372158051,</p><p class="source-code">              0.821965039,   -0.567564785,    0.047358301,</p><p class="source-code">              -0.000067875,    0.000017881, -249.615447998,</p><p class="source-code">              54.029174805,   26.956727982,   77.124832153,</p><p class="source-code">             196.801528931,  302.436492920,  -20.000000000))</p><p class="source-code">cmd.mview()</p><p class="source-code">cmd.frame(150)</p><p class="source-code">cmd.set_view((-0.175534308,   -0.331560850,   -0.926960170,</p><p class="source-code">              0.541812420,    0.753615797,   -0.372158051,</p><p class="source-code">              0.821965039,   -0.567564785,    0.047358301,</p><p class="source-code">              -0.000067875,    0.000017881,  -55.406421661,</p><p class="source-code">              54.029174805,   26.956727982,   77.124832153,</p><p class="source-code">              2.592475891,  108.227416992,  -20.000000000))</p><p class="source-code">cmd.mview()</p></li>
</ol>
<p>We define three points; the first two align with the DNA and the last point goes in. We get coordinates (all of these numbers) by using PyMOL in interactive mode, navigating using the mouse and keyboard, and using the <strong class="source-inline">get_view</strong> command, which will return coordinates that you can cut and paste.</p>
<p>The first <a id="_idIndexMarker632"/>frame is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Figure 8.5 - Frame 0 and scene DS0 " height="460" src="image/B17942_08_05.jpg" width="640"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 - Frame 0 and scene DS0</p>
<ol>
<li value="5">We now change the scene, in preparation for going inside the protein:<p class="source-code">cmd.frame(200)</p><p class="source-code">cmd.scene('S1')</p><p class="source-code">cmd.mview()</p></li>
</ol>
<p>The <a id="_idIndexMarker633"/>following screenshot shows the current position:</p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 8.6 - Frame 200 near the DNA molecule and scene S1 " height="480" src="image/B17942_08_06.jpg" width="640"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 - Frame 200 near the DNA molecule and scene S1</p>
<ol>
<li value="6">We move <a id="_idIndexMarker634"/>inside the protein and change the scene at the end using the following code:<p class="source-code">cmd.frame(350)</p><p class="source-code">cmd.scene('S1')</p><p class="source-code">cmd.set_view((0.395763457,   -0.173441306,    0.901825786,</p><p class="source-code">              0.915456235,    0.152441502,   -0.372427106,</p><p class="source-code">             -0.072881661,    0.972972929,    0.219108686,</p><p class="source-code">              0.000070953,    0.000013039,  -37.689743042,</p><p class="source-code">             57.748500824,   14.325904846,   77.241867065,</p><p class="source-code">             -15.123448372,   90.511535645,  -20.000000000))</p><p class="source-code">cmd.mview()</p><p class="source-code">cmd.frame(351)</p><p class="source-code">cmd.scene('S2')</p><p class="source-code">cmd.mview()</p></li>
</ol>
<p>We are<a id="_idIndexMarker635"/> now fully inside, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 8.7 - Frame 350 – scene S1 on the verge of changing to S2 " height="480" src="image/B17942_08_07.jpg" width="640"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 - Frame 350 – scene S1 on the verge of changing to S2</p>
<ol>
<li value="7">Finally, we<a id="_idIndexMarker636"/> let PyMOL return to its original position, and then play, save, and quit:<p class="source-code">cmd.frame(500)</p><p class="source-code">cmd.scene('S2')</p><p class="source-code">cmd.mview()</p><p class="source-code">cmd.mplay()</p><p class="source-code">cmd.mpng('p53_1tup')</p><p class="source-code">cmd.quit()</p></li>
</ol>
<p>This will generate 500 PNG files with the <strong class="source-inline">p53_1tup</strong> prefix.</p>
<p>Here is a frame approaching the end (450):</p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 8.8 - Frame 450 and scene S2 " height="480" src="image/B17942_08_08.jpg" width="640"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 - Frame 450 and scene S2</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/>There’s more</h2>
<p>The YouTube video was generated using <strong class="source-inline">ffmpeg</strong> on Linux at <strong class="source-inline">15</strong> frames per second, as follows:</p>
<p class="source-code">ffmpeg -r 15 -f image2 -start_number 1 -i "p53_1tup%04d.png" example.mp4</p>
<p>There are plenty of applications that you can use to generate videos from images. PyMOL can generate a MPEG, but it requires the installation of extra libraries.</p>
<p>PyMOL was created to be used interactively from its console (which can be extended in Python). Using it the other way around (importing from Python with no GUI) can be complicated and frustrating. PyMOL starts a separate thread to render images that work asynchronously.</p>
<p>For example, this means that your code may be in a different position from where the renderer is. I have put another script called <strong class="source-inline">PyMol_Intro.py</strong> in the GitHub repository; you will see that the second PNG call will start before the first one has finished. Try the script code, see how you expect it to behave, and how it actually behaves.</p>
<p>There is plenty of good documentation<a id="_idIndexMarker637"/> for PyMOL from a GUI perspective at <a href="http://www.pymolwiki.org/index.php/MovieSchool">http://www.pymolwiki.org/index.php/MovieSchool</a>. This is a great starting point if you want to make movies, and <a href="http://www.pymolwiki.org">http://www.pymolwiki.org</a> is a treasure trove of information.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/>Parsing mmCIF files using Biopython</h1>
<p>The <a id="_idIndexMarker638"/>mmCIF file format is probably the future. Biopython <a id="_idIndexMarker639"/>doesn’t have full functionality to work with it yet, but we will take a look at what currently exists.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>Getting ready</h2>
<p>As <strong class="source-inline">Bio.PDB</strong> is not able to automatically download mmCIF files, you need to get your protein file and rename it to <strong class="source-inline">1tup.cif</strong>. This can be found at <a href="https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py">https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py</a> under <strong class="source-inline">1TUP.cif</strong>.</p>
<p>You can find this content in the <strong class="source-inline">Chapter08/mmCIF.py</strong> Notebook file.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>How to do it...</h2>
<p>Take a look at <a id="_idIndexMarker640"/>the following steps:</p>
<ol>
<li value="1">Let’s parse the<a id="_idIndexMarker641"/> file. We just use the MMCIF parser instead of the PDB parser:<p class="source-code">from Bio import PDB</p><p class="source-code">parser = PDB.MMCIFParser()</p><p class="source-code">p53_1tup = parser.get_structure('P53', '1tup.cif')</p></li>
<li>Let’s inspect the following chains:<p class="source-code">def describe_model(name, pdb):</p><p class="source-code">    print()</p><p class="source-code">    for model in p53_1tup:</p><p class="source-code">        for chain in model:</p><p class="source-code">            print('%s - Chain: %s. Number of residues: %d. Number of atoms: %d.' %</p><p class="source-code">                  (name, chain.id, len(chain), len(list(chain.get_atoms()))))</p><p class="source-code">describe_model('1TUP', p53_1tup)</p></li>
</ol>
<p>The output will be as follows:</p>
<p class="source-code"><strong class="bold">1TUP - Chain: E. Number of residues: 43. Number of atoms: 442.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: F. Number of residues: 35. Number of atoms: 449.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: A. Number of residues: 395. Number of atoms: 1734.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: B. Number of residues: 265. Number of atoms: 1593.</strong></p>
<p class="source-code"><strong class="bold">1TUP - Chain: C. Number of residues: 276. Number of atoms: 1610.</strong></p>
<ol>
<li value="3">Many of the fields are not available in the parsed structure, but the fields can still be retrieved by using a lower-level dictionary, as follows:<p class="source-code">mmcif_dict = PDB.MMCIF2Dict.MMCIF2Dict('1tup.cif')</p><p class="source-code">for k, v in mmcif_dict.items():</p><p class="source-code">    print(k, v)</p><p class="source-code">    print()</p></li>
</ol>
<p>Unfortunately, this <a id="_idIndexMarker642"/>list is large and requires some post-processing to<a id="_idIndexMarker643"/> make sense of it, but it is available.</p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/>There’s more</h2>
<p>You still have all the model information from the mmCIF file made available by Biopython, so the parser is still quite useful. We can expect more developments with the <strong class="source-inline">mmCIF</strong> parser than with the <strong class="source-inline">PDB</strong> parser.</p>
<p>There is a Python library for this that’s been made available by the developers of PDB at <a href="http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml">http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml</a>.</p>
</div>
<div>
<div id="_idContainer070">
</div>
</div>
</div></body></html>