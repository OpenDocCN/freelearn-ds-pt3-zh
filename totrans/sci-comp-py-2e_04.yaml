- en: Linear Algebra - Arrays
  prefs: []
  type: TYPE_NORMAL
- en: Linear algebra is one of the essential building blocks of computational mathematics.
    The objects of linear algebra are vectors and matrices. The package NumPy includes
    all the necessary tools to manipulate those objects.
  prefs: []
  type: TYPE_NORMAL
- en: The first task is to build matrices and vectors or to alter existing ones by
    slicing. The other main task is the dot operation, which embodies most linear
    algebra operations (scalar product, matrix-vector product, and matrix-matrix product).
    Finally, various methods are available to solve linear problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the array type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical preliminaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The array type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing array entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to construct arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing and changing the shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions acting on arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear algebra methods in SciPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.1 Overview of the array type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the impatient, here is how to use arrays in a nutshell. Be aware though
    that the behavior of arrays may be surprising at first, so we encourage you to
    read on after this introductory section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note again, the presentation in this chapter assumes like everywhere else in
    this book that you have the module NumPy imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By importing NumPy, we give access to the datatype `ndarray`, which we'll describe
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Vectors and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating vectors is as simple as using the function `array` to convert a list
    into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The object `v` is now a vector that behaves much like a vector in linear algebra.
    We have already emphasized the differences with the list object in Python in [Section
    3.2](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *A quick glance at the concept
    of arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some illustrations of the basic linear algebra operations on vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all basic arithmetic operations are performed elementwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Some functions act elementwise on arrays as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This subject will be covered in [Section](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml) 4.8: *Functions
    acting on arrays.*
  prefs: []
  type: TYPE_NORMAL
- en: 'A matrix is created in a similar way to a vector, but from a list of lists
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note, vectors are not column or row matrices. An ![](img/dd804db6-ce44-4feb-b8b6-359bc63442df.png)
    vector, an ![](img/75c70cc7-6946-4e16-af4b-c6ba929f7142.png), and a ![](img/6f7b05e6-6f92-4cef-831d-790496c52a3b.png)
    matrix are three different objects even if they contain the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a row matrix containing the same data as the vector `v = array([1.,
    2., 1.])`, we apply the method `reshape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding column matrix is obtained by `reshape` in a corresponding
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After having learned how to create arrays and after having seen basic array
    operations, we will study now how array elements and subarrays can be addressed
    by indexing and slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Indexing and slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indexing and slicing are similar to the corresponding operations for lists.
    The main difference is that there may be several indexes or slices when the array
    is a matrix. The subject will be covered in depth in [Section 4.4.1](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Basic array slicing*; here, we just give some illustrative examples of indexing
    and slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As arrays are the basic datatype for all tasks in computational linear algebra,
    we now present in this overview section some examples, the dot product and the
    solution of linear equation systems.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.3 Linear algebra operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essential operator that performs most of the usual operations of linear algebra
    is the Python function `dot`. It is used for matrix-vector multiplications (see
    [Section 4.2.4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *The dot operations*
    for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be used to compute a scalar product between two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, it is used to compute matrix-matrix products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Solving a linear system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If [![](img/d658ccfe-c6c7-4c0f-9b56-efc5b11df1c4.png)] is a matrix and [![](img/16de0f6a-2627-450c-bd4f-0d2a6fab42a3.png)]
    is a vector, you can solve the linear equation system
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1378855e-0cd6-4a0c-b7e0-23e04a9d4809.png)'
  prefs: []
  type: TYPE_IMG
- en: 'by using the function `solve` from the linear algebra submodule `numpy.linalg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For example, to solve
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6d5dd31-f278-4cf2-8ab2-cd4287fa3b29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'the following Python statements are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The command `allclose` is used here to compare two vectors. If they are close
    enough to each other, this command returns `True`. Optionally a tolerance value
    can be set. For more methods related to linear equation systems, see [Section](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml) 4.9: *Linear
    algebra methods in SciPy*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have seen the first and essential way of how to use arrays in Python.
    In the following sections, we'll show you more details and the underlying principles.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Mathematical preliminaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how arrays work in NumPy, it is useful to understand
    the mathematical parallel between accessing tensor (matrix and vector) elements
    by indexes and evaluating mathematical functions by providing arguments. We also
    cover in this section the generalization of the dot product as a reduction operator.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Arrays as functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays may be considered from several different points of view. If you want
    to approach the concept from a mathematical point of view, you might benefit from understanding
    arrays through an analogy of functions of several variables. This view will later
    be taken again, when explaining the concept of broadcasting in [Section](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml) 5.5: *Broadcasting**.*
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, selecting a component of a given vector in ![](img/0827edf6-8019-496b-87da-a611639c6ab4.png)may
    just be considered a function from the set of ![](img/49fb25fc-995c-4a1c-b7db-fb0ca393e72e.png)
    to ![](img/cab4aa7c-b61f-459e-afa8-71cd5baa66f1.png), where we define the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1785531-d885-4fce-80da-fc35bec04dbe.png)'
  prefs: []
  type: TYPE_IMG
- en: Here the set ![](img/9ff103aa-3603-4365-9d45-818b85a2c38d.png) has *n* elements.
    The Python function `range` generates [*![](img/45ed4521-0799-4a89-9601-da50700491a7.png)*].
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an element of a given matrix, on the other hand, is a function of
    two parameters, taking its value in ![](img/2dd26863-2ac9-4c48-83ef-25700ef810e6.png).
    Picking a particular element of an *![](img/07d6e38b-b49b-4337-8925-160b771356ab.png)*
    matrix may thus be considered a function from ![](img/5398c6ee-de44-43c1-b7fb-7c30dbfe6117.png)
    to ![](img/f0d6533e-221c-4d66-8138-a00f24e830e0.png).
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 Operations are elementwise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy arrays are essentially treated as mathematical functions. This is in particular
    true for operations. Consider two functions, ![](img/4cdad02e-e6f4-4c17-95c7-bfd5cf329282.png)
    and ![](img/6acb3ba5-69f9-4970-a5f4-90f7281ac936.png), defined on the same domain
    and taking real values. The product ![](img/8bd32329-08fb-4861-b05a-64b90be30405.png)
    of those two functions is defined as the pointwise product, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e717cdf-b96e-492a-a775-81175e062d39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that this construction is possible for any operation between two functions.
    For an arbitrary operation defined on two scalars, which we denote here by ![](img/17a32615-8ff1-488f-b7df-8fc015e28be2.png),
    we could define ![](img/4e03099d-ba8c-47a9-865e-a675a56e4e02.png) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9564f5b5-d0d8-45d1-9a6a-f8d3968aac02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This innocuous remark allows us to understand NumPy''s stance on operations;
    all operations are elementwise in arrays. For instance, the product between two
    matrices, ![](img/498ba54b-8eb4-40c7-9b03-4ff15b67a00d.png) and ![](img/2aa90bb5-7dbc-4b46-9e63-053f3c934bcf.png),
    is defined, as with functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fc20d80-879e-43b3-be9d-6d65c0bd6d78.png)'
  prefs: []
  type: TYPE_IMG
- en: 4.2.3 Shape and number of dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a clear distinction between a:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Scalar:* A function with no arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Vector:* A function with one argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Matrix:* A function with two arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Higher-order tensor*: A function with more than two arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what follows, the number of dimensions is the number of arguments of a function.
    The shape corresponds essentially to the domain of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a vector of size *n* is a function from the set ![](img/3e022549-3df7-4296-89f7-f07c4a254201.png) to
    ![](img/67c574fe-7309-413d-bc56-5dbfee30661e.png). As a result, its domain  is
    ![](img/914d84e0-9c6a-4895-9e11-c42f794a770a.png). Its shape is defined as the
    singleton (*n,*). Similarly, a matrix of size ![](img/61fcaba3-7269-4d3d-b042-734057d63e0b.png) is
    a function defined on ![](img/cbf9a605-eaf9-45d2-843e-ee7498361ef6.png). The corresponding
    shape is simply the pair (*m*, *n*). The shape of an array is obtained by the
    function `numpy.shape`, and the number of dimensions by the function `numpy.ndim`;
    see also [Section 4.6](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Accessing
    and changing the shape*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.4 The dot operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Treating arrays as functions, although very powerful, completely neglects the
    linear algebra structures we are familiar with, that is, matrix-vector and matrix-matrix
    operations. Fortunately, these linear algebra operations may all be written in
    a similar unified form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector-vector operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d4531ef-e516-4ea5-907d-0de7b6edc077.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The matrix-vector operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b07789a-b088-40b2-aa11-da31e046119c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The matrix-matrix operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1e4e002-ee95-448c-91bd-4c9ecfa7120d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The vector-matrix operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91a09614-743b-4b57-8b5c-2b98fd13232b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The essential mathematical concept is that of reduction. For a matrix-vector
    operation, the reduction is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aec07b60-4dd3-4aa2-a52c-c21caae0c27d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In general, a reduction operation defined between two tensors, ![](img/1f0c151e-39a4-4e33-b6cf-23789680aa6e.png) and
    ![](img/8016ef96-8baa-48ac-80e0-56016e765985.png), of respective number of dimensions
    ![](img/58f0e0a7-a065-40a0-82b0-d8c685294696.png) and ![](img/cfd803fd-209a-4fa1-82cc-b2fa4237e1ac.png) may
    be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d735bf5-14bf-40c0-b43b-3347aab64854.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, the shapes of the tensors must be compatible with that operation to
    make
  prefs: []
  type: TYPE_NORMAL
- en: any sense. This requirement is familiar for matrix-matrix multiplication. The
    multiplication ![](img/e5b3c2c8-d223-4b63-9afe-67c3946130b2.png)
  prefs: []
  type: TYPE_NORMAL
- en: of matrices ![](img/40c5c7dc-0cc9-4c09-b130-5ed416713e2c.png) and *![](img/2ed6b962-1034-42c4-bcd7-9f6df445ef53.png)*
    only makes sense if the number of columns of ![](img/3f6cc52f-5279-45b4-ab25-c779292f6c32.png) equals
    the number of rows of *![](img/4fc01d29-fe44-4681-8146-b4b1da231ed4.png)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another consequence of the reduction operation is that it produces a new tensor
    with ![](img/907b8b22-fae5-42f9-bff7-b0381719d8fa.png) dimensions. In *Table 4.1*,
    we gather the output of the reduction operation for the familiar cases involving
    matrices and vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **![](img/badb856c-cd63-4a10-a3c2-8d733fd6ecc6.png)** | **![](img/61296058-9a76-48b0-a429-4e031bf7f616.png)**
    | **![](img/a80b9a58-4dbc-4325-ba0b-20a3c0b6c80c.png)** |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/28959d31-3da1-4a37-b9ba-a658517250f8.png) | ![](img/669e969c-43c9-462d-8448-9d6663e312eb.png)
    | ![](img/72498382-abab-44ee-ba00-50bbbfecc71e.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/9c3f79f5-ffa7-4480-8e0a-590a2a493fe5.png) | ![](img/f6d4ee8a-e85c-4952-a3d1-e6810b28d983.png)
    | ![](img/c6bd4cfd-a634-4531-90b9-69050d2a9ac0.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/9e9cd9c3-4a88-4eb3-b242-a59c8b0b2b13.png) | ![](img/742d6bd6-3c77-497f-8f05-ba91268a2709.png)
    | ![](img/ab0a2853-845f-403d-818a-9163956b0ba9.png) |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/74866b6c-26bb-499a-bfc9-93c23837a315.png) | ![](img/f8606684-f88f-4c51-991c-29b266868d6e.png)
    | ![](img/7c5146dc-ee25-4f2b-867d-f726be6c87ab.png) |'
  prefs: []
  type: TYPE_TB
- en: '​Table 4.1: Output of the reduction operation involving matrices and vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, all reduction operations are performed using the `dot` function
    or alternatively the `@` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Python version 3.5 or higher, the dot product can be written either in its
    operator form, `dot(M, v)`, or by using the infix notation, `M @ v`. From now
    on we'll stick to the more handy infix notation; you can modify the examples if
    the other form is preferred. We note, however, that `dot` performs type casting
    to arrays if its arguments are of other types that can be cast to an array, such
    as list or float. The infix operator form with `@` does not have this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiplication operator `*` is always elementwise. It has nothing to do
    with the dot operation. Even if *![](img/04ede9d1-0823-4b24-a5e7-fc247edcc0fa.png) *is
    a matrix and ![](img/8d8c60e1-cd74-45d6-9ec6-1798e72a0077.png) is a vector, `A*v`
    is still a legal operation. This will be explained in [Section 5.5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Broadcasting*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we identified the use of arrays with matrices and vectors in
    mathematics and explained operations. In particular, the most central operation
    in scientific computation, the dot product, was explained. We turn now to the
    array datatype `ndarray` and its methods more generally.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 The array type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objects used to manipulate vectors, matrices, and more general tensors in
    NumPy are called ndarrays, or just arrays for short. In this section, we examine
    their essential properties, how to create them, and how to access their information.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Array properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays are essentially characterized by the three properties, described in
    *Table 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `shape` | This describes how the data should be interpreted, as a vector,
    a matrix, or a higher-order tensor, and it gives the corresponding dimension.
    It is accessed with the attribute `shape`. |'
  prefs: []
  type: TYPE_TB
- en: '| `dtype` | This gives the type of the underlying data (float, complex, integer,
    and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `strides` | This attribute specifies in which order the data should be read.
    For instance, a matrix could be stored in memory contiguously column by column
    (FORTRAN convention), or row by row (C convention). The attribute is a tuple with
    the numbers of bytes that have to be skipped in memory to reach the next row and
    the number of bytes to be skipped to reach the next column. It even allows for
    a more flexible interpretation of the data in memory, which is what makes array
    views possible. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2: The three characterizing properties of an array'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Its elements have the type `'int64'`; that is, they use 64 bits or 8 bytes in
    memory. The complete array is stored in memory row-wise. The distance from `A[0,
    0]` to the first element in the next row `A[1,0]` is thus 24 bytes (three matrix
    elements) in memory. Correspondingly, the distance in memory between `A[0,0]` and `A[0,1]` is
    8 bytes (one matrix element). These values are stored in the attribute `strides`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Creating arrays from lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general way to create an array is by using the function `array`. The syntax
    to create a real-valued vector would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a complex vector with the same data, you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When no type is specified, the type is guessed. The `array` function chooses
    the type that allows storing all the specified values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy silently casts floats into integers, which might give unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The same, often unexpected array type casting happens from `complex` to `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Array and Python parentheses**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we noticed in [Section 1.2.2](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml):
    *Line joining*, Python allows a line break when some opening brace or parenthesis
    is not closed. This allows a convenient syntax for array creation, which makes
    it more pleasing to the human eye:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So far, you saw a lot of differences in the definition and use between arrays
    and lists. Accessing array elements, in contrast, seems quite similar to the way
    list elements are accessed. But especially the use of multiple indexes and the
    resulting objects from the slicing operations require that we look at these issues
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Accessing array entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array entries are accessed by indexes. In contrast to vector coefficients, two
    indexes are needed to access matrix coefficients. These are given in one pair
    of brackets. This distinguishes the array syntax from a list of lists. There,
    two pairs of brackets are needed to access elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's look now in more detail at the use of double indexes and slices.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Basic array slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Slices are similar to those of lists (see also [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *Slicing*) except that they might now be in more than one dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M[i,:]` is a vector filled by the row ![](img/60a8e43a-37e5-406e-bad5-90981a04b955.png) of
    ![](img/c0e17bfb-4fea-4289-9f4f-582181cc5699.png)*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M[:,j]` is a vector filled by the column ![](img/47def328-ef21-466c-8046-1574defb7ec6.png) of
    ![](img/450c6166-8464-42a9-b6c1-acce375705c0.png)*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M[2:4,:]` is a slice of `2:4` on the rows only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M[2:4,1:4]` is a slice of rows and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result of matrix slicing is given in the following *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b07bb9d1-b49f-46b6-9d8d-9d8db197d47e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The result of matrix slicing'
  prefs: []
  type: TYPE_NORMAL
- en: If you omit an index or a slice, NumPy assumes you are taking rows only. `M[3]` is
    a vector that is a view on the third row of *M *and `M[1:3]` is a matrix that
    is a view on the second and third rows of ![](img/26f718b7-5dab-4498-99cf-52a2ff1616a6.png)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the elements of a slice affects the entire array (see also [Section
    5.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Array views and copies*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'General slicing rules are given in *Table 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Access** | **ndim** | **Kind** |'
  prefs: []
  type: TYPE_TB
- en: '| index, index | 0 | scalar |'
  prefs: []
  type: TYPE_TB
- en: '| slice, index | 1 | vector |'
  prefs: []
  type: TYPE_TB
- en: '| index, slice | 1 | vector |'
  prefs: []
  type: TYPE_TB
- en: '| slice, slice | 2 | matrix |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.3: General slicing rules'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of slicing operations for an array `M` of shape *(4, 4)* are given
    in *Table 4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Access** | **Shape** | **ndim** | **Kind** |'
  prefs: []
  type: TYPE_TB
- en: '| `M[:2, 1:-1]` | (2,2) | 2 | matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `M[1,:]` | (4,) | 1 | vector |'
  prefs: []
  type: TYPE_TB
- en: '| `M[1,1]` | () | 0 | scalar |'
  prefs: []
  type: TYPE_TB
- en: '| `M[1:2,:]` | (1,4) | 2 | matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `M[1:2, 1:2]` | (1,1) | 2 | matrix |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.4: Result of slicing operations for an array M of shape (4,4)'
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Altering an array using slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may alter an array using slices or by direct access. The following changes
    only one element in a ![](img/b44e53a3-95ce-43a3-a6b4-3616878d891c.png) matrix ![](img/c54c7a2c-59a0-4e88-bb60-28e29b2a1852.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we may change one full row of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we may also replace a full submatrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a distinction between a column matrix and a vector. The following
    assignment with a column matrix returns no error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'while the assignment with a vector returns a `ValueError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The general slicing rules are shown in *Table 4.3*. The matrices and vectors
    in the preceding examples must have the right size to fit into matrix ![](img/b75a4632-4ef1-495c-891e-1184dfa2bc58.png).
    You may also make use of the broadcasting rules (see [Section 5.5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Broadcasting*)
    to determine the allowed size of the replacement arrays. If the replacement array
    does not have the right shape, a `ValueError` exception will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to construct arrays from other arrays by slicing. In the next section,
    we will consider special NumPy functions that are useful to directly create and
    initialize arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Functions to construct arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The usual way to set up an array is via a list. But there are also a couple
    of convenient methods for generating special arrays, which are given in *Table
    4.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Shape** | **Generates** |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros((n,m))` | *(n,m)* | Matrix filled with zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `ones((n,m)) ` | *(n,m)* | Matrix filled with ones |'
  prefs: []
  type: TYPE_TB
- en: '| `full((n,m),q)` | *(n,m)* | Matrix filled with ![](img/d4907979-e755-4827-ae0b-318783930a2d.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,k) ` | *(n,n)* | (Sub-, super-) diagonal matrix from a vector ![](img/9cb240a7-8fe3-4f7a-862a-2057841ca009.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `random.rand(n,m) ` | *(n,m)* | Matrix filled with uniformly distributed
    random numbers in `(0,1)` |'
  prefs: []
  type: TYPE_TB
- en: '| `arange(n)` | *(n,)* | First ![](img/cacd22ff-75a8-40a9-ad1d-b8e06d0c8dd9.png) integers
    |'
  prefs: []
  type: TYPE_TB
- en: '| `linspace(a,b,n) ` | *(n,)* | Vector with ![](img/76197639-ef19-4b09-89f0-b6702c4638f1.png) equispaced
    points between ![](img/a68eb689-1673-4372-a195-a071d550b333.png) and ![](img/86a00f21-9e02-489e-9ea3-cdd43faa105e.png)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.5: Commands to create arrays'
  prefs: []
  type: TYPE_NORMAL
- en: These commands may take additional arguments. In particular, the commands `zeros`, `ones`,
    `full`, and `arange` take `dtype` as an optional argument. The default type is `float`,
    except for `arange`. There are also methods such as `zeros_like` and `ones_like`,
    which are slight variants of the preceding ones. For instance, the command `zeros_like(A)` is
    equivalent to `zeros(shape(A))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `identity` constructs an identity matrix of a given size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The command is identical to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 4.6 Accessing and changing the shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of dimensions is what distinguishes a vector from a matrix. The *shape* is
    what distinguishes vectors of different sizes, or matrices of different sizes.
    In this section, we examine how to obtain and change the shape of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 The function shape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The shape of a matrix is the tuple of its dimensions. The shape of an ![](img/116a1156-6428-4645-83b5-91a371d0ac37.png)
    matrix is the tuple `(n, m)`. It can be obtained by the function `shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: or, simply by its attribute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the advantage of using `shape` as a function and not as an attribute
    is that the function may be used on scalars and lists as well. This may come in
    handy when code is supposed to work with both scalars and arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For a vector, the shape is a singleton containing the length of that vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 4.6.2 Number of dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The number of dimensions of an array is obtained with the function `ndim` or
    using the array attribute `ndim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the number of dimensions, given by the function `ndim`, of a tensor `T` (a
    vector, matrix, or higher-order tensor) is always equal to the length of its shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 4.6.3 Reshape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method `reshape` gives a new view of the array, with a new shape, without
    copying the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The various effects of `reshape` on an array defined by `arange(6)` are given
    in *Figure 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c83ae739-a14a-4dac-b732-b5926366fe1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The various effects of `reshape` on an array'
  prefs: []
  type: TYPE_NORMAL
- en: '`reshape` does not create a new array. It rather gives a new view on the existing
    array. In the preceding example, changing one element of `M` would automatically
    result in a change in the corresponding element in `v`. When this behavior is
    not acceptable, you need to copy the data, as explained in [Section 5.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Array views and copies*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to reshape an array with a shape that does not multiply to the original
    shape, an error is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is convenient to specify only one `shape` parameter and let Python
    determine the other in such a way that it multiplies to the original shape. This
    is done by setting the free `shape` parameter to `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Transpose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A special form of reshaping is *transposing*. It just switches the two shape
    elements of the matrix. The transpose of a matrix ![](img/01c5013f-d771-4398-8b4a-09a7127faf37.png)
    is a matrix ![](img/1e85d89b-68ed-4ce3-afcb-def575a94660.png) such that
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d4d53d1-e828-4034-a089-d1a79219f880.png)'
  prefs: []
  type: TYPE_IMG
- en: 'which is resolved in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`transpose` does not copy: transposition is very similar to reshaping. In particular,
    it does not copy the data either and just returns a view on the same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Transposing a vector makes no sense since vectors are tensors of one dimension,
    that is, functions of one variable – the index. NumPy will, however, comply and
    return exactly the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'What you have in mind when you want to transpose a vector is probably to create
    a row or column matrix. This is done using `reshape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 4.7 Stacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The universal method to build matrices from a couple of (matching) submatrices
    is `concatenate`. Its syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This command stacks the submatrices vertically (on top of each other) when `axis=0` is
    specified. With the argument `axis=1`, they are stacked horizontally, and this
    generalizes according to arrays with more dimensions. This function is called
    by several convenient functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hstack`: Used to stack arrays horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vstack`: Used to stack arrays vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columnstack`: Used to stack vectors in columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.7.1 Stacking vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may stack vectors row-wise or column-wise using `vstack` and `column_stack`,
    as illustrated in *Figure 4.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/489416aa-cee4-4c78-bd61-6d55509b1907.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Difference between vstack and column_stack'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `hstack` would produce the concatenation of `v1` and `v2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the symplectic permutation as an example for vector stacking:
    we have a vector of size ![](img/95e7f926-6570-4979-aff3-cfd2456400df.png). We
    want to perform a symplectic transformation of a vector with an even number of
    components, that is, exchange the first half with the second half of the vector
    with sign change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1945fef-683a-48a7-8b84-69079e39b55f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This operation is resolved in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 4.8 Functions acting on arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different types of functions acting on arrays. Some act elementwise,
    and they return an array of the same shape. Those are called *universal functions*.
    Other array functions return an array of a different shape. In this section, we
    will meet both types of functions and also learn how to convert scalar functions
    into *universal functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.1 Universal functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Universal functions are functions that act elementwise on arrays. They thus
    have an output array that has the same shape as the input array. These functions allow
    us to compute the result of a scalar function on a whole array at once.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in universal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A typical example is the `cos` function (the one provided by NumPy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that universal functions work on arrays in a componentwise manner. This
    is also true for operators, such as multiplication or exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Creation of universal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your function will automatically be universal if you use only universal functions
    in it. If, however, your function uses functions that are not universal, you might
    get scalar results, or even an error when trying to apply them on an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected behavior would be that the `heaviside` function applied to a vector `[a, b]` would
    return `[heaviside(*a*), heaviside(*b*)]`. Alas, this does not work because the
    function always returns a scalar, no matter the size of the input argument. Besides,
    using the function with an array input would cause the statement `if` to raise
    an exception, as is explained in detail in [Section 5.2.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Boolean arrays*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NumPy function `vectorize` allows us to quickly solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical application of this method is its use when plotting a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.4* shows the resulting graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87adeed7-835b-464a-bcc8-b0bb49a621e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Heaviside function'
  prefs: []
  type: TYPE_NORMAL
- en: The function `vectorize` provides a convenient way to quickly transform a function,
    so that it operates elementwise on lists and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '`vectorize` can also be used as a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Decorators will be introduced in [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Functions as decorators.*'
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.2 Array functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of functions acting on arrays that do not act componentwise.
    Examples of such functions are `max`, `min`, and `sum`. These functions may operate
    on the entire matrix, row-wise, or column-wise. When no argument is provided,
    they act on the entire matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4b74487-2302-49d4-9832-3dfaa7c465be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The function `sum` acting on that matrix returns a scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The command has an optional parameter, `axis`. It allows us to choose along which
    axis to perform the operation. For instance, if the axis is ![](img/34738052-9fa9-47b9-82ff-83a13e4cff45.png),
    it means that the sum should be computed along the first axis. The sum along axis
    ![](img/b3c35afb-1602-49a5-af3a-b4f4a92bb398.png) of an array of shape ![](img/925c52a4-d0cd-400d-a844-1f5ff7e56e72.png) will
    be a vector of length ![](img/0ae89473-603a-4d7f-a6e1-002309711489.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we compute the sum of `A` along the axis ![](img/fb5a95be-3141-40c3-bb6c-4fa00dbd0586.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This amounts to computing the sum on the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aa3de70-06db-4cc0-882f-20d159526e22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d594fcb4-c367-4178-8eac-e9669d2c878f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now suppose we compute the sum along axis *1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This amounts to computing the sum on the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b10b3aa4-6ef4-4079-bb86-d68282cd1f94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8e2b4fb-ca07-4164-8283-bee562f7dd36.png)'
  prefs: []
  type: TYPE_IMG
- en: After having seen in this section functions acting on arrays in general, we
    turn now to some functions solving tasks in basic scientific computing. We exemplify
    this by considering some standard tasks in linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Linear algebra methods in SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SciPy offers a large range of methods from numerical linear algebra in its module `scipy.linalg`.
    Many of these methods are Python wrapping programs from `LAPACK`, a collection
    of well-approved FORTRAN subroutines used to solve linear equation systems and
    eigenvalue problems, see [[5]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml). Linear
    algebra methods are the core of any method in scientific computing, and the fact
    that SciPy uses wrappers instead of pure Python code makes these central methods
    extremely fast. We present in detail here how two linear algebra problems are
    solved with Scipy to give you a flavor of this module.
  prefs: []
  type: TYPE_NORMAL
- en: You met before some linear algebra functions taken from the module `numpy.linalg`.
    Both packages NumPy and SciPy are compatible, but Scipy has its focus on scientific
    computing methods and is more comprehensive, while NumPy's focus is on the array
    datatype and it provides only some linear algebra methods for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.1 Solving several linear equation systems with LU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let ![](img/4196e6f5-3ee7-4824-9a06-1e2a0023f791.png) be an *![](img/6e3bf0cd-1219-43c9-8e6e-80888770ba90.png)*
    matrix and ![](img/919aa858-0c1e-4349-929f-6cab888543b5.png) be a sequence of
    ![](img/aec0a0b8-00cd-4635-9c1c-0686cbc24cc0.png) vectors. We consider the problem
    to find ![](img/143b692e-7046-4f9d-b164-fe5cd9effa12.png) vectors ![](img/67cb9bbc-afe6-4faa-849b-1d68041b2802.png)
    such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a0273f7-82f3-4066-88da-b79083ea9d5f.png)'
  prefs: []
  type: TYPE_IMG
- en: We assume that the vectors ![](img/85efadf5-99b6-44b4-a962-833b8b3d8355.png) are
    not known simultaneously. In particular, it is quite a common situation that the
    ![](img/871fa756-0080-460c-92c0-fd64f972467f.png)^(th) problem has to be solved
    before ![](img/0282095b-b6ca-4e70-8a8a-dce30fc06d5f.png)becomes available, for
    example in the context of the simplified Newton iteration, see [[24]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85bac675-3f92-4601-af52-ca94f39eef12.png) factorization is a way to
    organize the classical Gauss elimination method in such a way that the computation
    is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A factorization step of the matrix ![](img/00bdf963-c2e4-44f6-b55f-d79be2f3f4d9.png) to
    get matrices in triangular form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A relatively cheap backward and forward elimination step that works on the instances
    of ![](img/efd18f9b-201c-4d88-a885-7fe6cc05eec3.png)and benefits from the more
    time-consuming factorization step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method also uses the fact that if ![](img/cecba16b-7cc5-4ca7-a597-a6c22ccac977.png)
    is a permutation matrix such that ![](img/99dfac8f-563a-4c50-98cd-e977f9ac85b5.png)
    is the original matrix with its rows permuted, the two systems ![](img/b6467921-e799-4a7c-87d1-df158307b3d2.png)
    and ![](img/2d88dcdc-57aa-4e10-9cdb-494fbec51d25.png) have the same solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4578b253-5ead-4eef-9412-b4e3ea7439f6.png) factorization finds a permutation
    matrix ![](img/6c293ce8-4881-4f96-a225-cc7dfa04a769.png), a lower triangular matrix ![](img/44e8c59b-3b02-4ad4-9363-2b8a92b506fe.png), and
    an upper triangular matrix ![](img/98ffc1b2-a1c7-45ba-9c92-71043ecb2d05.png) such
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caaf71e0-07ba-4fc0-80e0-cb79f1286d6c.png)or equivalently ![](img/beaa3fdf-6087-4498-8883-f8d9797efc06.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Such a factorization always exists. Furthermore, ![](img/3d8a0cf3-0fba-48ef-992d-4654fb86a225.png)
    can be determined in such a way that *![](img/6bc9dce9-f3fd-46c4-a547-553c7e51e6a7.png)*.
    Thus, the essential data from ![](img/35f23021-e8c1-4326-b7e9-7909b1e2f02f.png)
    that has to be stored is ![](img/9f65052f-5fc6-451c-acc0-509bb256677c.png) with ![](img/9e90e974-9f89-492b-a3e8-3e8376d73586.png).
    Consequently, *![](img/2b0e1170-2606-4e74-88b1-2c0681f6076c.png)* and ![](img/8d7fe4fb-c2fb-4d10-9f76-b4ffb42ae6c3.png)
    can be stored together in an ![](img/46e6348b-3f0b-442e-8b32-6c724c4ea4f5.png)
    array, while the information about the permutation matrix ![](img/0bdf51ae-0e08-4759-8a69-fe3479b39ccb.png)
    just requires an ![](img/d0f432d4-6869-4b90-9b12-31e8f12db89b.png) integer vector
    – the pivot vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SciPy, there are two methods to compute the LU factorization. The standard
    one is `scipy.linalg.lu`, which returns the three matrices `L`, `U`, and `P`.
    The other method is `lu_factor`. That is the method we describe here, because
    it will be conveniently used later in combination with `lu_solve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the matrix `A` is factorized and an array with the information about `L` and `U` is
    returned, together with the pivot vector. With this information, the system can
    be solved by performing row interchanges of the vectors *![](img/153577e0-6458-4c62-92a0-8cf350510081.png)*
    according to the information stored in the pivot vector, backward substitution
    using *![](img/96b762f1-848b-444d-a841-7d0d2766a23c.png),* and finally, forward
    substitution using ![](img/db5a6831-edd9-4a37-bb7e-8284f8a66aef.png). This is
    bundled in Python, in the method `lu_solve`. The following code snippet shows
    how the system ![](img/a8a9ac9f-b68e-45f0-a555-b8e489316cd5.png)is solved once
    the LU factorization is performed and its results stored in the tuple (LU, piv):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 4.9.2 Solving a least square problem with SVD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A linear equation system ![](img/81eb24c9-baf8-4329-a16e-e721ec9262e1.png), with ![](img/92a1bee6-65ee-4def-b0a6-8ed17278ef02.png)
    being an *![](img/1d73bf3f-58a2-414e-9d7d-1afb6720205a.png)* matrix and *![](img/0fd80a0a-c81b-47b2-8e56-e2d1858c1e2a.png)*,
    is called an overdetermined linear system. In general, it has no classical solution
    and you seek a vector ![](img/6d0da559-17ca-4da7-bf6f-c8fc0c776aae.png) with the
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2456b56-3d9c-4b6d-b439-8a14d3933796.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/cbba8bf7-fee6-4d90-bdda-74de6bd48875.png) denotes the Euclidean
    vector norm ![](img/1b83e74f-85d8-4b81-9f8c-03be5257c74e.png).
  prefs: []
  type: TYPE_NORMAL
- en: This problem is called a least square problem. A stable method to solve it is
    based on factorizing ![](img/b6070459-10bf-46cd-8a81-79da90e4677d.png)*,* with ![](img/b2199c3b-3baf-4d99-b440-5a7f8128e122.png)
    being an ![](img/9f894183-c602-4e45-acd2-1a5b1dfa8e57.png) orthogonal matrix, ![](img/321ee887-ee37-47ad-88e9-f433f47452eb.png)
    an ![](img/ec15b505-3dc6-454e-8ac0-432c1126e3c5.png) orthogonal matrix, and ![](img/9b49437c-733d-43d8-a853-e62eeeb21ea9.png)
    an ![](img/e6e9669b-28f8-427e-84dd-a81995d4af03.png) matrix with the property ![](img/408d1afa-77dd-400a-9f84-938372b59921.png) for
    all ![](img/a93a7e22-86c4-451e-b37c-70929ccdb519.png). This factorization is called a **singular
    value decomposition**(**SVD**).
  prefs: []
  type: TYPE_NORMAL
- en: We write
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d56a3d65-e4e2-4ec7-82c4-5c66a05cb0c9.png)'
  prefs: []
  type: TYPE_IMG
- en: with a diagonal *![](img/482f5dde-34d4-431c-9b78-7922c29f02c6.png)* matrix ![](img/214f9d14-1fe5-4917-bf5f-903e54fc58fe.png).
    If we assume that ![](img/00bda032-6d12-4c96-bf4f-35e863ba8b90.png) has full rank,
    then [*![](img/40f74b62-32ab-4ffa-91ac-ae281d11d3da.png)*] is invertible and it
    can be shown that
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82c957bc-cd01-4ee7-9538-c30b62c29ffc.png)'
  prefs: []
  type: TYPE_IMG
- en: holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we split ![](img/871828cc-22c0-46f1-837c-68393d365c37.png) with ![](img/5ef1ec2f-a76a-4523-bfcb-990bf31f162f.png)
    being an ![](img/0a7fbf6f-dae4-4e00-8074-6c9453a683e9.png) submatrix, then the
    preceding equation can be simplified to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a49ee33-bc31-403a-8fa2-723e1e78588d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SciPy provides a function called `svd`, which we use to solve this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `full_matrices` tells whether the complete matrix ![](img/9e72bfce-f08d-4f8a-a8b1-1ffef56ddffa.png) or
    only its submatrix *![](img/51d29c20-bb37-4615-b3eb-5f131e0ed12b.png)* should
    be computed. As you often use `svd` to compute only singular values, ![](img/0ff12784-516f-4184-9447-e2016fa22484.png),
    we have, in our case, to explicitly demand the computation of ![](img/0be678a3-b8e0-4f25-88c3-38878a4d6a97.png)
    and ![](img/e209beca-7321-416e-a764-1645933a0536.png) by using the keyword `compute_uv`.
  prefs: []
  type: TYPE_NORMAL
- en: The SciPy function `scipy.linalg.lstsq` solves the least squares problem directly
    by internally using an SVD.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9.3 More methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples so far, you met a couple of methods for computational tasks
    in linear algebra, for example, `solve`. More methods are available after the
    command `import scipy.linalg as sl` is executed. The most common of them are listed
    in *Table 4.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.det` | Determinant of a matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.eig` | Eigenvalues and eigenvectors of a matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.inv` | Matrix inverse |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.pinv` | Matrix pseudoinverse |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.norm` | Matrix or vector norm |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.svd` | Singular value decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.lu` | LU decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.qr` | QR decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.cholesky` | Cholesky decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.solve` | Solution of a general or symmetric linear system: *Ax = b* |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.solve.banded` | The same for banded matrices |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.lstsq` | Least squares solution |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.6: Linear algebra functions of the module scipy.linalg'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `import scipy.linalg as sl` first.
  prefs: []
  type: TYPE_NORMAL
- en: 4.10 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with the most important objects in linear algebra
    – vectors and matrices. For this, we learned how to define arrays and we met important
    array methods. A smaller section demonstrated how to use modules from `scipy.linalg` to
    solve central tasks in linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we consider more advanced and special aspects of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 4.11 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Consider a ![](img/94b86ce2-e6b2-475b-9f14-76c5e36c9e19.png) matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9199d20-b134-4715-ae5c-f5f77974c909.png)'
  prefs: []
  type: TYPE_IMG
- en: Construct this matrix in Python using the function `array`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the same matrix using the function `arange` followed by a suitable
    `reshape`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of the expression `M[2,:]`? What is the result of the similar
    expression `M[2:]`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 2**: Given a vector *x*, construct in Python the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe063b6f-16f0-4f56-9598-adfd011526fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![](img/6b2583e7-6896-4d67-964d-fd049538ba7f.png) are the components
    of the vector ![](img/18d85501-1ef0-49b3-8a5b-9e48a139c592.png) (numbered from
    zero). Given a vector ![](img/219de5ca-b350-487d-aa10-0ad36e6b5f28.png), solve
    in Python the linear equation system ![](img/ebed84dd-d1d0-4f9e-a484-605bfc06c9bb.png).
    Let the components of ![](img/03a227be-9acb-460e-9c61-af0cd3bd9232.png) be denoted
    by *![](img/7e32640f-ea55-4d20-95c8-cb2b8f653841.png)*. Write a function `poly`,
    which has ![](img/2b36f4f3-1189-45e2-bb5a-a0425f127e30.png) and ![](img/782f3b31-642b-4427-8c2a-4ed1be231cd2.png)
    as input and computes the polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11bad0bb-4452-4459-9007-88365688c530.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Plot this polynomial and depict in the same plot the points ![](img/2f31ef49-1465-45fe-8d17-22e1a9ebb089.png) as
    small stars. Try your code with the vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f72d9a2-9a68-4ea6-a11e-3fb839a38d7b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 3:** The matrix ![](img/bcb237c4-8b52-4760-b9f7-a53906c9378f.png) in *Ex.
    2* is called a *Vandermonde matrix*. It can be set up in Python directly with
    the command `vander`. Evaluating a polynomial defined by a coefficient vector
    can be done with the Python command `polyval`. Repeat *Ex. 2* by using these commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4:** Let ![](img/ee99a147-92c3-476d-a39a-a74ad9c0985c.png) be a one-dimensional
    array. Construct another array ![](img/290f6f75-cb1d-4a2f-8ff2-0a8e1a7921d0.png)
    with values ![](img/6b23c9cd-6a6c-45c1-a2a7-fd6205634028.png). In statistics,
    this array is called the *moving average* of ![](img/31b367fc-8e36-4ceb-930b-b3b4c8cdb0ec.png).
    In approximation theory, it plays the role of the Greville abscissae of cubic
    splines. Try to avoid the use of `for` loops in your scrip t.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5:**'
  prefs: []
  type: TYPE_NORMAL
- en: Construct from the matrix ![](img/7178b185-4f57-411e-ab36-1878955e902b.png)given
    in *Ex. 2* a matrix ![](img/2df3ed42-0a6a-41a5-a792-3ea9d7c739c0.png) by deleting
    ![](img/0c7572b8-ae60-4056-bc23-b7755d8fd266.png)'s first column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Form the matrix ![](img/6eebcb7e-0a31-45fa-9f86-314c2724d5a4.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute ![](img/9f1f2ce4-d0bc-4b76-90e6-a007bf3de393.png) with *y* from *Ex.
    2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use ![](img/c3627f5c-ffb0-472c-adcd-349774cbc08b.png) and `polyval` to plot
    the polynomial defined by ![](img/6914b439-8e00-43a4-9d05-cf710057f952.png). Plot
    in the same picture again the points ![](img/fa578596-8b6d-4e5d-8d45-3444e2a19f77.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 6:** *Ex. 5* describes the least squares method. Repeat that exercise
    but use SciPy''s `scipy.linalg.lstsq` method instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 7:** Let ![](img/9c8c6479-a5f2-468d-89ff-ebba2e920bf6.png) be a vector
    written in its coordinate form as a ![](img/dfb4ade8-dd92-4337-8bbb-69ad3e591092.png)
    matrix ![](img/d5202a4a-76e0-49b2-aa6a-a3700a41331e.png). Construct the projection
    matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37ac33c-9332-43af-88a3-44340ef9916e.png) and ![](img/23ac98e4-77db-423f-8ce7-456009c627ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Show experimentally that ![](img/83a4e7b1-68fc-49e9-b334-210006ce7cf4.png) is
    an eigenvector for both matrices ![](img/92b532e7-074a-4860-aa1c-7f8c7173159e.png)
    and ![](img/0bc7f0fb-df10-4658-b18d-928f7a13cc76.png). What are the corresponding
    eigenvalues?
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 8:** In numerical linear algebra the *![](img/44464ed2-4f61-4367-8619-39608a28d1e7.png)*
    matrix ![](img/5f13f90a-e7a8-4775-a9e7-b9d2228e5ca4.png) with the property'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c02fdfc-2636-4564-b3ff-0995d87fa34d.png)'
  prefs: []
  type: TYPE_IMG
- en: is used as an example for an extreme growth factor, when performing LU factorization,
    see [[36, p. 165]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Set up this matrix in Python for various values of ![](img/a92b5fed-a950-43f8-ac67-7f39e1606d55.png),
    compute its LU factorization using the command `scipy.linalg.lu`, and derive experimentally
    a statement about the growth factor
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92f0c83e-a714-49df-a074-f358f6ea7290.png)'
  prefs: []
  type: TYPE_IMG
- en: in relation to ![](img/eadd88ba-9e5c-48dc-95c9-f34ba0fe8f6b.png).
  prefs: []
  type: TYPE_NORMAL
