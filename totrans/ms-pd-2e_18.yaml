- en: pandas Compared with Other Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter focuses on comparing pandas with R, the statistical package on
    which much of the pandas functionality is modeled, and other tools such as SQL
    and SAS, with which it has a significant degree of overlap. It is intended as
    a guide for R, SQL, and SAS users who wish to use pandas, and for users who wish
    to replicate functionality that they have seen in their code in pandas. It focuses
    on a number of key features available to R, SQL, and SAS users, and demonstrates
    how to achieve similar functionality in pandas by using some illustrative examples.
    This chapter assumes that you have the R statistical package installed. If not,
    it can be downloaded and installed from here: [http://www.r-project.org/](http://www.r-project.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, data analysis users should have a good grasp of
    the data analysis capabilities of these tools as compared to pandas, enabling
    them to transition to, or use, pandas should they need to. The various factors
    where the tools have been compared include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types and the pandas equivalents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing and selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operations on data type columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation and GroupBy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split-apply-combine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Melting and reshaping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factors and categorical data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison with R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R is the tool on which pandas is loosely designed. Many of the functionalities
    are very similar in terms of syntax, usage, and output. Differences occur mainly
    in some of the data types, which can be the matrix in R versus arrays in pandas,
    an aggregation framework, such as the `aggregate` function in R and the `GroupBy`
    operation in pandas, and subtle differences in the syntaxes of similarly named
    functions, such as `melt` and `cut`.
  prefs: []
  type: TYPE_NORMAL
- en: Data types in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'R has five primitive or atomic types:'
  prefs: []
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical/Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also has the following more complex container types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector**: This is similar to `numpy.array`. It can only contain objects of
    the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: This is a heterogeneous container. Its equivalent in pandas would
    be a series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: This is a heterogeneous two-dimensional container, equivalent
    to a pandas DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matrix**: This is a homogeneous two-dimensional version of a vector. It is
    similar to a `numpy.array`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this chapter, we will focus on list and DataFrame, which have the following
    equivalents in pandas: series and DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on R data types, refer to the following document at [http://www.statmethods.net/input/datatypes.html](http://www.statmethods.net/input/datatypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: For NumPy data types, refer to the following documents at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html)
    and [http://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.matrix.html).
  prefs: []
  type: TYPE_NORMAL
- en: R lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'R lists can be created explicitly as a list declaration, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block includes its series equivalent in pandas, with the
    creation of a list followed by the creation of a series therefrom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Array indexing starts at 0 in pandas, unlike R, where it starts at 1\. The
    following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: R DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can construct an R DataFrame as follows by calling the `data.frame()` constructor
    and then displaying it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we construct a pandas DataFrame and then display
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Slicing and selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In R, we slice objects in the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[`: This always returns an object of the same type as the original and can
    be used to select more than one element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[`: This is used to extract elements of a list or DataFrame, and can only
    be used to extract a single element. The nature of the returned element will not
    necessarily be a list or DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: This is used to extract elements of a list or DataFrame by name and is
    similar to `[[`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some slicing examples in R and their equivalents in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing R-matrix and NumPy array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at creation and selection in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the first row, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the second column, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at NumPy array creation and selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the first row, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Indexing is different in R and pandas/NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: In R, indexing starts at 1, while in pandas/NumPy, it starts at 0\. Hence, we
    have to subtract 1 from all indexes when making the translation from R to pandas/NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select the second column, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to transpose the array first and then select the column,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Comparing R lists and pandas series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List creation and selection in R is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Series creation and selection in pandas is effected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see a difference between an R-list and a pandas series from the perspective
    of the `[]` and `[[]]` operators. We can see the difference by considering the
    second item, which is a character string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of R, the `[]` operator produces a container type, that is, a list
    containing the string, while the `[[]]` operator produces an atomic type, in this
    case, a character, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of pandas, the opposite is true: `[]` produces the atomic type,
    while `[[]]` results in a complex type, that is, a series, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In both R and pandas, the column name can be specified in order to an element.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a column name in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In R, this can be done with the column name preceded by the `$` operator as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Specifying a column name in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, we subset elements in the usual way with the column name in square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'One area where R and pandas differ is in the subsetting of nested elements.
    For example, to obtain day 4 from weekdays, we have to use the `[[]]` operator
    in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the case of pandas, we can just use a double `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: R DataFrames versus pandas DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selecting data in R DataFrames and pandas DataFrames follows a similar script.
    The following section explains how we perform multi-column selects from both.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-column selection in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In R, we specify the multiple columns to select by stating them in a vector
    within square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Multi-column selection in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, we subset elements in the usual way with the column names in square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic operations on columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In R and pandas, we can apply arithmetic operations in data columns in a similar
    manner. Hence, we can perform arithmetic operations such as addition or subtraction
    on elements in corresponding positions in two or more DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we construct a DataFrame in R with columns labeled x and y, and subtract
    column y from column x:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with` operator in R also has the same effect as arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas, the same arithmetic operations can be performed on columns and the
    equivalent operator is `eval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Aggregation and GroupBy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we wish to split data into subsets and apply a function such as the
    mean, max, or min to each subset. In R, we can do this through the `aggregate`
    or `tapply` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have a dataset of statistics on the top five strikers of the four clubs
    that made it to the semi-final of the European Champions League Football tournament
    in 2014\. We will use it to illustrate aggregation in R and its equivalent GroupBy
    functionality in pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In R, aggregation is effected using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We now compute the goals-per-game ratio for each striker, so as to measure
    their deadliness in front of goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we wanted to know the highest goals-per-game ratio for each team.
    We would calculate this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tapply` function is used to apply a function to a subset of an array or
    vector that is defined by one or more columns. The `tapply` function can also
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The pandas GroupBy operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, we can achieve the same result by using the `GroupBy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Comparing matching operators in R and pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we demonstrate the equivalence of matching operators between R (`%in%`)
    and pandas (`isin()`). In both cases, a logical vector or series (pandas) is produced,
    which indicates the position at which a match was found.
  prefs: []
  type: TYPE_NORMAL
- en: R %in% operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we demonstrate the use of the `%in%` operator in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Pandas isin() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of using the pandas `isin()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Logical subsetting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In R, as well as in pandas, there is more than one way to perform logical subsetting.
    Suppose that we wished to display all players with the average goals-per-game
    ratio of greater than or equal to 0.5; that is, on average, they score at least
    one goal every two games.
  prefs: []
  type: TYPE_NORMAL
- en: Logical subsetting in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s how we can do this in R:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a logical slice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `subset()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Logical subsetting in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, we do similar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical slicing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`DataFrame.query()` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Split-apply-combine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R has a library called `plyr` for a split-apply-combine data analysis. The `plyr`
    library has a function called `ddply`, which can be used to apply a function to
    a subset of a DataFrame, and then combine the results into another DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on `ddply`, you can refer to the following link: [http://www.inside-r.org/packages/cran/plyr/docs/ddply](http://www.inside-r.org/packages/cran/plyr/docs/ddply).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let''s consider a subset of a recently created dataset in R,
    which contains data on flights departing NYC in 2013: [http://cran.r-project.org/web/packages/nycflights13/index.html](http://cran.r-project.org/web/packages/nycflights13/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation in R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we install the package in R and instantiate the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ddply` function enables us to summarize the departure delays (mean and 
    standard deviation) by year and month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save the `flights.sample` dataset to a CSV file so that we can use the
    data to show us how to do the same thing in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Implementation in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to do the same thing in pandas, we read the CSV file saved in the
    preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We achieve the same effect as `ddply` by making use of the `GroupBy()` operator,
    as shown in the following code and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Reshaping using melt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `melt` function converts data in a wide format to a single column consisting
    of unique ID-variable combinations.
  prefs: []
  type: TYPE_NORMAL
- en: R melt function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we demonstrate the use of the `melt()` function in R. It produces long-format
    data in which the rows are unique variable-value combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For more information, you can refer to the following link: [http://www.statmethods.net/management/reshape.html](http://www.statmethods.net/management/reshape.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The pandas melt function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, the `melt` function is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The reference source for this information is as follows: [http://pandas.pydata.org/pandas-docs/stable/reshaping.html#reshaping-by-melt](http://pandas.pydata.org/pandas-docs/stable/reshaping.html#reshaping-by-melt).'
  prefs: []
  type: TYPE_NORMAL
- en: Categorical data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: R refers to categorical variables as factors, and the `cut()` function enables
    us to break a continuous numerical variable into ranges and treat the ranges as
    factors or categorical variables, or to classify a categorical variable into a
    larger bin.
  prefs: []
  type: TYPE_NORMAL
- en: R example using cut()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code block shows an example in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The pandas solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code block contains the equivalent of the earlier explained `cut()`
    function in pandas (only applies to version 0.15+):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison in the previous sections can be summarized by the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/6c1339fc-8067-47da-be93-3ffa622739d3.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of data structures and operations in R and pandas
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas is similar to SQL in many ways in the sense that it is used for data
    selection, data filtering, data aggregation, data generation, and data modification.
    SQL does to the database tables what pandas does to the DataFrames. In this section,
    we will compare the features in SQL with their equivalents in pandas.
  prefs: []
  type: TYPE_NORMAL
- en: SELECT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SELECT is used to select or subset data in certain columns of the tables. Suppose
    you have a table/DataFrame called `DallasData`. This data would be attached in
    your book packet or could be accessed from the cloud drive of the book. To select
    five rows from the three given columns, you write the following
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/a78b25e9-6c2a-43e4-be1d-ed5309ab1ea7.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Output of select on DallasData
  prefs: []
  type: TYPE_NORMAL
- en: Where
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Where` statement is used in SQL to apply filter conditions to filter rows
    based on certain criteria. The equivalent in pandas is condition-based logical
    subsetting.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to find out the rows where `active_status ==1`. This can be
    done in the two tools in the following manner.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/542ae54e-ff9b-4f7c-86dc-7ce50c95b1cf.png)'
  prefs: []
  type: TYPE_IMG
- en: DallasData after filtering only active customers
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to find out the rows where the customers are active (`active_status
    ==1`) and have completed fewer than nine services (`services_completed<9`). This
    can be done in the two tools in the following manner.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d4d6fb8-55a3-451e-8a32-dd93ba678a47.png)'
  prefs: []
  type: TYPE_IMG
- en: DallasData after filtering customers who are active and have completed more
    than nine services
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to find out the rows where the customers are active (active_status
    ==1), but only find the customer ID, zip code, and seller ID for those rows. This
    can be done in the two tools in the following manner.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cd9dfaa-6c71-4afd-b621-b044d2e5f2e7.png)'
  prefs: []
  type: TYPE_IMG
- en: DallasData after filtering only active customers and selecting only particular
    columns
  prefs: []
  type: TYPE_NORMAL
- en: group by
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `group by` statement is used to aggregate data and find the aggregated values
    of numerical columns. The keyword for performing this operation is the same, but
    the syntax is a little different. Let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we are looking to find the numbers of active and inactive customers
    in the dataset. This can be done as follows in the two tools.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a65325d-d03d-456b-9ef9-7ea443aae685.png)'
  prefs: []
  type: TYPE_IMG
- en: Count of active and inactive customers using groupby in Python
  prefs: []
  type: TYPE_NORMAL
- en: Different aggregation operations can be applied to two different columns simultaneously
    while aggregating. The following example shows how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/657bd3dd-26ae-46d7-b579-165425a92689.png)'
  prefs: []
  type: TYPE_IMG
- en: Sum of services completed and the mean customer age grouped by active and inactive
    customers using groupby in Python
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating by more than one column or multi-index aggregation is also possible.
    Suppose we want zip code-wise details of active and inactive customers.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ce95321-6005-4939-9f4c-4460ada318e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-indexed grouping by customer active status and zip code using groupby
    in Python
  prefs: []
  type: TYPE_NORMAL
- en: update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `update` statements in SQL are used to filter data rows based on certain
    conditions and to update or modify certain values in those rows. In pandas, there
    is no particular keyword or function for doing this; instead, it is done by means
    of a direct assignment. Let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose it was established that the data administrator had made a mistake in
    data collection. Due to this error, the data points where the age was actually
    45 were randomly assigned a value greater than 35\. To rectify this, we will update
    all such rows (**age>35**) to 45.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two screenshots show the data before and after performing the
    update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51c65a70-65a7-4672-b64b-894ed68ba9b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Before and after updating all ages greater than 35 to 45
  prefs: []
  type: TYPE_NORMAL
- en: delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `delete` statements in SQL are used to delete data rows based on certain
    conditions from the database tables. In pandas, we don't delete rows; we just
    deselect them. Let's look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to look at those customers who are in the system for at least
    500 days (`days_old>500`).
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command to check whether it did the intended operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This should return 0 rows if the delete action was performed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: JOIN
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `join` statements are used to merge different tables in a database and extract
    important information spread across a variety of tables. In pandas, the merge
    operator does the same job. The only difference is that the syntax is a little
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two datasets for illustrating different joins and their syntaxes
    in SQL and pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef207ef-3c2b-4d03-81b7-2471a4f7f5c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Two dummy datasets
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to do an inner join between the two. This can be done in the
    two tools as shown preceding.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ff132e8-2b5c-4634-830c-c3f368f3057a.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the inner join of the two DataFrames
  prefs: []
  type: TYPE_NORMAL
- en: As expected of an inner join, only the key values present in both the tables
    appear in the merged dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to implement a left join between the two. This can be done
    in the two tools as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efa176a9-d7a8-451e-9d8a-72731f0f1961.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the left join between the two tables
  prefs: []
  type: TYPE_NORMAL
- en: As expected of a left join, it retrieves all the unique values of the key present
    in the left-hand table (`df1`, in this case), as well as the corresponding values
    in the right-hand table. For the key values in the left-hand table for which it
    doesn't find a match in the right-hand table, it returns NaN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to implement a right join between the two. This can be done
    in the two tools as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In SQL, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pandas, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output to the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b02be011-5eb5-40fc-953e-66477c2f2c8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of the right join between the two tables
  prefs: []
  type: TYPE_NORMAL
- en: As expected of a right join, it retrieves all the unique values of the key present
    in the right-hand table (`df2`, in this case), as well as the corresponding values
    in the left-hand table. For the key values in the right-hand table for which it
    doesn't find a match in the left-hand table, it returns NaN.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison with SAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SAS is the analytics sledgehammer of yesteryear. It was the market leader in
    analytics solutions before R and Python, the poster boys of the open source movement,
    dethroned it from its *numero uno* position. Nevertheless, many enterprises still
    trust it with all their analytics requirements, despite the unreasonably high
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will keep all the comparisons to a tabular format. The
    SAS and pandas equivalents are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pandas | SAS |'
  prefs: []
  type: TYPE_TB
- en: '| DataFrame | dataset |'
  prefs: []
  type: TYPE_TB
- en: '| column | variable |'
  prefs: []
  type: TYPE_TB
- en: '| row | observation |'
  prefs: []
  type: TYPE_TB
- en: '| groupby | BY-group |'
  prefs: []
  type: TYPE_TB
- en: '| NaN | . |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s see how we can perform the basic data operations in pandas and
    SAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Task | Pandas | SAS |'
  prefs: []
  type: TYPE_TB
- en: '| Creating a dataset | `pd.DataFrame({''odds'': [1, 3, 5, 7, 9], ''evens'':
    [2, 4, 6, 8, 10]})` | `data df;``    input x y;``    datalines;``    1 2``   
    3 4``    5 6``    7 8``    9 10;``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| Reading a dataset | `pd.read_csv(‘DallasData.csv’)` | `proc import datafile=''DallasData.csv''
    dbms=csv out=tips replace;``    getnames=yes;``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| Exporting a dataset | `DallasData.to_csv(‘dallas.csv’)` | `proc export data=DallasData
    outfile=''dallas.csv'' dbms=csv;``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| Column operations | `DallasData[''days_old_year''] = DallasData[''days_old'']/365`
    | `data DallasData;``    set DallasData;``    days_old_year = days_old / 365;``run;`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Filtering | `DallasData[DallasData[''days_old'']>800].head()` | `data tips;``   
    set DallasData;``    if days_old > 800;``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| If-else | `DallasData[''income_class''] = np.where(DallasData[''income_average'']
    < 40000, ''low'', ''high'')` | `data DallasData;``    set dallas;``    format
    income_average $5.;``    if days_old < 40000 then bucket = ''low'';``    else
    bucket = ''high'';``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| Column selection | `DallasData[[''zip'',''customerID'',''days_old'',''services_due'']].head()`
    | `data dallas;``    set DallasData;``    keep zip CustomerID days_old services_due;``run;`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sort | `dallas = DallasData.sort_values([''days_old'',''services_completed''])`
    | `proc sort data=DallasData;``    by days_old services_completed;``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| String length | `DallasData[''state_name''].str.len().head()` | `data _null_;``set
    DallasData;``put(LENGTHN(state_name));``put(LENGTHC(state_name));``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| Groupby aggregation | `dallas_grouped = DallasData.groupby([''zip'', ''customerID''])[''days_old'',
    ''services_completed''].sum()` | `proc summary data=DallasData nway;``    class
    zip customerID;``    var days_old services_completed;``    output out=dallas_summed
    sum=;``run;` |'
  prefs: []
  type: TYPE_TB
- en: '| Join | `df1 = pd.DataFrame({''key'': [''A'', ''B'', ''C'', ''D''], ''value'':
    np.random.randn(4)})``df2 = pd.DataFrame({''key'': [''B'', ''D'', ''D'', ''E''],''value'':
    np.random.randn(4)})``inner_join = df1.merge(df2, on=[''key''], how=''inner'')``left_join
    = df1.merge(df2, on=[''key''], how=''left'')``right_join = df1.merge(df2, on=[''key''],
    how=''right'')` | `proc sort data=df1;``    by key;``run;``proc sort data=df2;``   
    by key;``run;``data left_join inner_join right_join outer_join;``    merge df1(in=a)
    df2(in=b);``    if a and b then output inner_join;``    if a then output left_join;``   
    if b then output right_join;``    if a or b then output outer_join;``run;` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we  attempted to compare key features in R and SQL with their
    pandas equivalents in order to achieve the following objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: To assist R, SQL, and SAS users who may wish to replicate the same functionality
    in pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To assist any users who on reading some R, SQL, and SAS code, may wish to rewrite
    the code in pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next chapter, we will conclude the book by providing a brief introduction
    to the `scikit-learn` library for performing machine learning, and we will demonstrate
    how pandas fits in that framework. Reference documentation for this chapter can
    be found here: [http://pandas.pydata.org/pandas-docs/stable/comparison_with_r.html](http://pandas.pydata.org/pandas-docs/stable/comparison_with_r.html).'
  prefs: []
  type: TYPE_NORMAL
