<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Graphics with matplotlib"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Graphics with matplotlib</h1></div></div></div><p>This chapter explores matplotlib, an IPython library for production of publication-quality graphs. In this chapter, the following topics will be discussed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Two-dimensional plots using the <code class="literal">plot</code> function and setting up line widths, colors, and styles</li><li class="listitem" style="list-style-type: disc">Plot configuration and annotation</li><li class="listitem" style="list-style-type: disc">Three-dimensional plots</li><li class="listitem" style="list-style-type: disc">Animations</li></ul></div><p>Being an IPython library, matplotlib consists of a hierarchy of classes, and it is possible to code using it in the usual object-oriented style. However, matplotlib also supports an <span class="strong"><strong>interactive</strong></span> mode. In this <a class="indexterm" id="id211"/>mode, the graphs are constructed step-by-step, thus adding and configuring each component at a time. We lay emphasis on the second approach since it is designed for the rapid production of graphs. The object-oriented style will be explained whenever it is needed or leads to better results.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The sense in which the word <span class="emphasis"><em>interactive</em></span> is used in this context is somewhat different from what is understood today. Graphs produced by matplotlib are not interactive in the sense that the user can manipulate the graphs once they have been rendered in the notebook. Instead, the terminology comes from the time when matplotlib was used mostly in command-line mode, and each new line of code modified the existing plots. Curiously, the software that was the original inspiration for matplotlib still uses a command line-based interface.</p></div></div><div class="section" title="The plot function"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>The plot function</h1></div></div></div><p>The <code class="literal">plot()</code> function <a class="indexterm" id="id212"/>is the workhorse of the matplotlib library. In this <a class="indexterm" id="id213"/>section, we will explore the line-plotting and formatting capabilities included in this function.</p><p>To make things a <a class="indexterm" id="id214"/>bit more concrete, let's consider the formula for <span class="strong"><strong>logistic growth</strong></span>, as follows:</p><div class="mediaobject"><img alt="The plot function" src="graphics/8341OS_03_01.jpg"/></div><p>This model is frequently used to represent growth that shows an initial exponential phase, and then is eventually limited by some factor. The examples are the population in an environment with limited resources and new products and/or technological innovations, which initially attract a small and quickly growing market but eventually reach a saturation point.</p><p>A common strategy to understand a mathematical model is to investigate how it changes as the parameters defining it are modified. Let's say, we want to see what happens to the shape of the curve when the parameter <span class="emphasis"><em>b</em></span> changes. </p><p>To be able to do <a class="indexterm" id="id215"/>what we want more efficiently, we are going to use a <span class="strong"><strong>function factory</strong></span>. This <a class="indexterm" id="id216"/>way, we can quickly create logistic models with arbitrary values for <span class="emphasis"><em>r</em></span>, <span class="emphasis"><em>a</em></span>, <span class="emphasis"><em>b</em></span>, and <span class="emphasis"><em>c</em></span>. Run the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def make_logistic(r, a, b, c):</strong></span>
<span class="strong"><strong>    def f_logistic(t):</strong></span>
<span class="strong"><strong>        return a / (b + c * exp(-r * t))</strong></span>
<span class="strong"><strong>    return f_logistic</strong></span>
</pre></div><p>The function factory <a class="indexterm" id="id217"/>pattern takes advantage of the fact that functions are <span class="strong"><strong>first-class objects</strong></span> in Python. This means that functions can be treated as regular objects: they can be assigned to variables, stored in lists in dictionaries, and play the role of arguments and/or return values in other functions.</p><p>In our example, we <a class="indexterm" id="id218"/>define the <code class="literal">make_logistic()</code> function, whose output is itself a Python function. Notice how the <code class="literal">f_logistic()</code> function is defined <span class="emphasis"><em>inside</em></span> the body of <code class="literal">make_logistic()</code> and then returned in the last line.</p><p>Let's now use the <a class="indexterm" id="id219"/>function factory to create three functions representing logistic curves, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>r = 0.15</strong></span>
<span class="strong"><strong>a = 20.0</strong></span>
<span class="strong"><strong>c = 15.0</strong></span>
<span class="strong"><strong>b1, b2, b3 = 2.0, 3.0, 4.0</strong></span>
<span class="strong"><strong>logistic1 = make_logistic(r, a, b1, c)</strong></span>
<span class="strong"><strong>logistic2 = make_logistic(r, a, b2, c)</strong></span>
<span class="strong"><strong>logistic3 = make_logistic(r, a, b3, c)</strong></span>
</pre></div><p>In the preceding code, we first fix the values of <code class="literal">r</code>, <code class="literal">a</code>, and <code class="literal">c</code>, and define three logistic curves for different values of <span class="emphasis"><em>b</em></span>. The important point to notice is that <code class="literal">logistic1</code>, <code class="literal">logistic2</code>, and <code class="literal">logistic3</code> are functions. So, for example, we can use <code class="literal">logistic1(2.5)</code> to compute the value of the first logistic curve at the time 2.5.</p><p>We can now plot the functions using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tmax = 40</strong></span>
<span class="strong"><strong>tvalues = linspace(0, tmax, 300)</strong></span>
<span class="strong"><strong>plot(tvalues, logistic1(tvalues)) </strong></span>
<span class="strong"><strong>plot(tvalues, logistic2(tvalues)) </strong></span>
<span class="strong"><strong>plot(tvalues, logistic3(tvalues))</strong></span>
</pre></div><p>The first line in the preceding code sets the maximum time value, <code class="literal">tmax</code>, to be <code class="literal">40</code>. Then, we define the set of times at which we want the functions evaluated with the assignment, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tvalues = linspace(0, tmax, 300)</strong></span>
</pre></div><p>The <code class="literal">linspace()</code> <a class="indexterm" id="id220"/>function is very convenient to generate points for plotting. The preceding code creates an array of 300 equally spaced points in the interval from <code class="literal">0</code> to <code class="literal">tmax</code>. Note that, contrary to other functions, such as <code class="literal">range()</code> and <code class="literal">arange()</code>, the right endpoint of the interval is included by default. (To exclude the right endpoint, use the <code class="literal">endpoint=False</code> option.)</p><p>After defining the array of time values, the <code class="literal">plot()</code> function is called to graph the curves. In its most basic form, it plots a single curve in a default color and line style. In this usage, the two arguments are two arrays. The first array gives the horizontal coordinates of the points being plotted, and <a class="indexterm" id="id221"/>the second array gives the vertical coordinates. A typical example will be the following function call:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(x,y)</strong></span>
</pre></div><p>The variables <code class="literal">x</code> and <code class="literal">y</code> must refer to <code class="literal">NumPy</code> arrays (or any Python iterable values that can be converted into an array) and must have the same dimensions. The points plotted have coordinates as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x[0], y[0]</strong></span>
<span class="strong"><strong>x[1], y[1]</strong></span>
<span class="strong"><strong>x[2], y[2]</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div><p>The preceding command will produce the following plot, displaying the three logistic curves:</p><div class="mediaobject"><img alt="The plot function" src="graphics/8341OS_03_02.jpg"/></div><p>You may have noticed that before the graph is displayed, there is a line of text output that looks like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[&lt;matplotlib.lines.Line2D at 0x7b57c50&gt;]</strong></span>
</pre></div><p>This is the return value of the last call to the <code class="literal">plot()</code> function, which is a list (or with a single element) of objects of the <code class="literal">Line2D</code> type. One way to prevent the output from being shown is to enter <code class="literal">None</code> as the last row in the cell. Alternatively, we can assign the return value of the last call in the cell to a dummy variable:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>_dummy_ = plot(tvalues, logistic3(tvalues))</strong></span>
</pre></div><p>The <code class="literal">plot()</code> function <a class="indexterm" id="id222"/>supports plotting several curves in the same function call. We need to change the contents of the cell that are shown in the following code and run it again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tmax = 40</strong></span>
<span class="strong"><strong>tvalues = linspace(0, tmax, 300)</strong></span>
<span class="strong"><strong>plot(tvalues, logistic1(tvalues), </strong></span>
<span class="strong"><strong>     tvalues, logistic2(tvalues), </strong></span>
<span class="strong"><strong>     tvalues, logistic3(tvalues))</strong></span>
</pre></div><p>This form saves some typing <a class="indexterm" id="id223"/>but turns out to be a little less flexible when it comes to customizing line options. Notice that the text output produced now is a list with three elements:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[&lt;matplotlib.lines.Line2D at 0x9bb6cc0&gt;,</strong></span>
<span class="strong"><strong> &lt;matplotlib.lines.Line2D at 0x9bb6ef0&gt;,</strong></span>
<span class="strong"><strong> &lt;matplotlib.lines.Line2D at 0x9bb9518&gt;]</strong></span>
</pre></div><p>This output can be useful in some instances. For now, we will stick with using one call to <code class="literal">plot()</code> for each curve, since it produces code that is clearer and more flexible.</p><p>Let's now change the line options in the plot and set the plot bounds. Change the contents of the cell to read as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(tvalues, logistic1(tvalues), </strong></span>
<span class="strong"><strong>     linewidth=1.5, color='DarkGreen', linestyle='-') </strong></span>
<span class="strong"><strong>plot(tvalues, logistic2(tvalues), </strong></span>
<span class="strong"><strong>     linewidth=2.0, color='#8B0000', linestyle=':') </strong></span>
<span class="strong"><strong>plot(tvalues, logistic3(tvalues), </strong></span>
<span class="strong"><strong>     linewidth=3.5, color=(0.0, 0.0, 0.5), linestyle='--')</strong></span>
<span class="strong"><strong>axis([0, tmax, 0, 11.])</strong></span>
<span class="strong"><strong>None</strong></span>
</pre></div><p>Running the preceding command lines will produce the following plots:</p><div class="mediaobject"><img alt="The plot function" src="graphics/8341OS_03_03.jpg"/></div><p>The options set in the preceding code are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first curve is plotted with a line width of <code class="literal">1.5</code>, with the HTML color of <code class="literal">DarkGreen</code>, and a filled-line style</li><li class="listitem" style="list-style-type: disc">The second curve is plotted with a line width of <code class="literal">2.0</code>, colored with the RGB value given by the hexadecimal string <code class="literal">#8B0000</code>, and a dotted-line style</li><li class="listitem" style="list-style-type: disc">The third curve is plotted with a line width of <code class="literal">3.0</code>, colored with the RGB components, <code class="literal">(0.0, 0.0, 0.5)</code>, and a dashed-line style</li></ul></div><p>Notice that there are different <a class="indexterm" id="id224"/>ways of specifying a fixed color: a HTML color name, a hexadecimal string, or a tuple of floating-point values. In the last case, the entries in the tuple represent the intensity of the red, green, and blue colors, respectively, and must be floating-point values between <code class="literal">0.0</code> and <code class="literal">1.0</code>. A complete list of HTML name <a class="indexterm" id="id225"/>colors can be found at <a class="ulink" href="http://www.w3schools.com/html/html_colornames.asp">http://www.w3schools.com/html/html_colornames.asp</a>.</p><p>Line styles are specified by a symbolic string. The allowed values are shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Symbol string</p>
</th><th style="text-align: left" valign="bottom">
<p>Line style</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>'<code class="literal">-</code>'</p>
</td><td style="text-align: left" valign="top">
<p>Solid (the default)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>'<code class="literal">--</code>'</p>
</td><td style="text-align: left" valign="top">
<p>Dashed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>'<code class="literal">:</code>'</p>
</td><td style="text-align: left" valign="top">
<p>Dotted</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>'<code class="literal">-.</code>'</p>
</td><td style="text-align: left" valign="top">
<p>Dash-dot</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>'<code class="literal">None</code>', '<code class="literal"> </code>', <code class="literal">or</code> ''</p>
</td><td style="text-align: left" valign="top">
<p>Not displayed</p>
</td></tr></tbody></table></div><p>After the calls to <code class="literal">plot()</code>, we set the graph bounds with the function call:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>axis([0, tmax, 0, 11.])</strong></span>
</pre></div><p>The argument to<code class="literal"> axis()</code> is a four-element list that specifies, in this order, the maximum and minimum values of the horizontal coordinates, and the maximum and minimum values of the vertical coordinates.</p><p>It may seem non-intuitive that the bounds for the variables are set after the plots are drawn. In the interactive mode, matplotlib remembers the state of the graph being constructed, and graphics objects are updated in the background after each command is issued. The graph is only rendered when all computations in the cell are done so that all previously specified options take effect. Note that starting a new cell clears all the graph data. This interactive behavior is part of the <code class="literal">matplotlib.pyplot</code> module, which is one of the components imported by <code class="literal">pylab</code>.</p><p>Besides drawing a line connecting the data points, it is also possible to draw markers at specified points. Change the graphing commands indicated in the following code snippet, and then run the cell again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(tvalues, logistic1(tvalues), </strong></span>
<span class="strong"><strong>     linewidth=1.5, color='DarkGreen', linestyle='-',</strong></span>
<span class="strong"><strong>     marker='o', markevery=50, markerfacecolor='GreenYellow',</strong></span>
<span class="strong"><strong>     markersize=10.0) </strong></span>
<span class="strong"><strong>plot(tvalues, logistic2(tvalues), </strong></span>
<span class="strong"><strong>     linewidth=2.0, color='#8B0000', linestyle=':',</strong></span>
<span class="strong"><strong>     marker='s', markevery=50, markerfacecolor='Salmon',</strong></span>
<span class="strong"><strong>     markersize=10.0)  </strong></span>
<span class="strong"><strong>plot(tvalues, logistic3(tvalues), </strong></span>
<span class="strong"><strong>     linewidth=2.0, color=(0.0, 0.0, 0.5), linestyle='--',</strong></span>
<span class="strong"><strong>     marker = '*', markevery=50, markerfacecolor='SkyBlue',</strong></span>
<span class="strong"><strong>     markersize=12.0)</strong></span>
<span class="strong"><strong>axis([0, tmax, 0, 11.])</strong></span>
<span class="strong"><strong>None</strong></span>
</pre></div><p>Now, the graph will look as shown in the following figure:</p><div class="mediaobject"><img alt="The plot function" src="graphics/8341OS_03_04.jpg"/></div><p>The only difference from the <a class="indexterm" id="id226"/>previous code is that now we added options to draw markers. The following are the options we use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">marker</code> option <a class="indexterm" id="id227"/>specifies the shape of the marker. Shapes are given <a class="indexterm" id="id228"/>as symbolic strings. In the preceding examples, we use <code class="literal">'o'</code> for a circular marker, <code class="literal">'s' </code>for a square, and <code class="literal">'*'</code> for a star. A complete list of available markers can be found at <a class="ulink" href="http://matplotlib.org/api/markers_api.html#module-matplotlib.markers">http://matplotlib.org/api/markers_api.html#module-matplotlib.markers</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">markevery</code> option <a class="indexterm" id="id229"/>specifies a stride within the data points for the placement of markers. In our example, we place a marker after every 50 data points.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">markercolor</code> <a class="indexterm" id="id230"/>option specifies the color of the marker.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">markersize</code> <a class="indexterm" id="id231"/>option specifies the size of the marker. The size is given in pixels.</li></ul></div><p>There are a large number of other options that can be applied to lines in matplotlib. A complete list is available at <a class="ulink" href="http://matplotlib.org/api/artist_api.html#module-matplotlib.lines">http://matplotlib.org/api/artist_api.html#module-matplotlib.lines</a>.</p><div class="section" title="Adding a title, labels, and a legend"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Adding a title, labels, and a legend</h2></div></div></div><p>The next step is to <a class="indexterm" id="id232"/>add a title and labels for the axes. Just before the <code class="literal">None</code> line, add the <a class="indexterm" id="id233"/>following three lines of code to the cell that creates <a class="indexterm" id="id234"/>the graph:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>title('Logistic growth: a={:5.2f}, c={:5.2f}, r={:5.2f}'.format(a, c, r))</strong></span>
<span class="strong"><strong>xlabel('$t$')</strong></span>
<span class="strong"><strong>ylabel('$N(t)=a/(b+ce^{-rt})$')</strong></span>
</pre></div><p>In the first line, we call the <code class="literal">title()</code> function to set the title of the plot. The argument can be any Python string. In our example, we use a formatted string:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>title('Logistic growth: a={:5.2f}, b={:5.2f}, r={:5.2f}'.format(a, c, r)) </strong></span>
</pre></div><p>We use the <code class="literal">format()</code> method of the string class. The formats are placed between braces, as in <code class="literal">{:5.2f}</code>, which specifies a floating-point format with five spaces and two digits of precision. Each of the <a class="indexterm" id="id235"/>format specifiers is then associated sequentially with one of the data arguments of the method. Some of the details of string formatting are covered in <a class="link" href="apb.html" title="Appendix B. A Brief Review of Python">Appendix B</a>, <span class="emphasis"><em>A Brief Review of Python</em></span>, and the full documentation is available at <a class="ulink" href="https://docs.python.org/2/library/string.html">https://docs.python.org/2/library/string.html</a>.</p><p>The axis labels are set in the calls:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>xlabel('$t$')</strong></span>
<span class="strong"><strong>ylabel('$N(t)=a/(b+ce^{-rt})$')</strong></span>
</pre></div><p>As in the <code class="literal">title()</code> functions, the <code class="literal">xlabel()</code> and <code class="literal">ylabel()</code> functions accept any Python string. Note that in the '<code class="literal">$t$</code>' and '<code class="literal">$N(t)=a/(b+ce^{-rt}$</code>' strings, we use LaTeX to format the mathematical <a class="indexterm" id="id236"/>formulas. This is indicated by the dollar signs, <code class="literal">$...$</code>, in the string.</p><p>After the addition of a title <a class="indexterm" id="id237"/>and labels, our graph looks like the following:</p><div class="mediaobject"><img alt="Adding a title, labels, and a legend" src="graphics/8341OS_03_05.jpg"/></div><p>Next, we need a way to identify each of the curves in the picture. One way to do that is to use a <code class="literal">legend</code>, which is indicated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>legend(['b={:5.2f}'.format(b1),</strong></span>
<span class="strong"><strong>        'b={:5.2f}'.format(b2),</strong></span>
<span class="strong"><strong>        'b={:5.2f}'.format(b3)])</strong></span>
</pre></div><p>The <code class="literal">legend()</code> function accepts a list of strings. Each string is associated with a curve in the order they are added to the plot. Notice that we are again using formatted strings.</p><p>Unfortunately, the preceding <a class="indexterm" id="id238"/>code does not produce great results. The legend, by default, is placed in the top-right corner of the plot, which, in this case, hides part of the graph. This is easily fixed using the <code class="literal">loc</code> option in the <code class="literal">legend</code> function, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>legend(['b={:5.2f}'.format(b1),</strong></span>
<span class="strong"><strong>        'b={:5.2f}'.format(b2),</strong></span>
<span class="strong"><strong>        'b={:5.2f}'.format(b3)], loc='upper left')</strong></span>
</pre></div><p>Running this code, we obtain the final version of our logistic growth plot, as follows:</p><div class="mediaobject"><img alt="Adding a title, labels, and a legend" src="graphics/8341OS_03_06.jpg"/></div><p>The legend location can be <a class="indexterm" id="id239"/>any of the strings: <code class="literal">'best'</code>, <code class="literal">'upper right'</code>, <code class="literal">'upper left'</code>, <code class="literal">'lower left'</code>, <code class="literal">'lower right'</code>, <code class="literal">'right'</code>, <code class="literal">'center left'</code>, <code class="literal">'center right'</code>, <code class="literal">'lower center'</code>, <code class="literal">'upper center'</code>, and <code class="literal">'center'</code>. It is also possible to specify the <a class="indexterm" id="id240"/>location of the legend precisely with the <code class="literal">bbox_to_anchor</code> option. To see how this works, modify the code for the legend as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>legend(['b={:5.2f}'.format(b1),</strong></span>
<span class="strong"><strong>        'b={:5.2f}'.format(b2),</strong></span>
<span class="strong"><strong>        'b={:5.2f}'.format(b3)],  bbox_to_anchor=(0.9,0.35))</strong></span>
</pre></div><p>Notice that the <code class="literal">bbox_to_anchor</code> option, by default, uses a coordinate system that is not the same as the one we specified for the plot. The <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates of the box in the preceding example are interpreted as a fraction of the width and height, respectively, of the whole figure. A little trial-and-error is necessary to place the legend box precisely where we want it. Note <a class="indexterm" id="id241"/>that the legend box can be placed outside the plot area. For example, try <a class="indexterm" id="id242"/>the coordinates <code class="literal">(1.32,1.02)</code>.</p><p>The <code class="literal">legend()</code> function is <a class="indexterm" id="id243"/>quite flexible and has quite a few other options that are <a class="indexterm" id="id244"/>documented at <a class="ulink" href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend">http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend</a>.</p></div><div class="section" title="Text and annotations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Text and annotations</h2></div></div></div><p>In this subsection, we will show how to add annotations to plots in matplotlib. We will build a plot <a class="indexterm" id="id245"/>demonstrating the fact that the tangent to a curve must be horizontal at the highest and lowest points. We start by defining the function associated <a class="indexterm" id="id246"/>with the curve and the set of values at which we want the curve to be plotted, which is shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>f = lambda x:  (x**3 - 6*x**2 + 9*x + 3) / (1 + 0.25*x**2)</strong></span>
<span class="strong"><strong>xvalues = linspace(0, 5, 200)</strong></span>
</pre></div><p>The first line in the preceding code uses a lambda expression to define the <code class="literal">f()</code> function. We use this approach here because the formula for the function is a simple, one-line expression. The general form of a lambda expression is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>lambda &lt;arguments&gt; : &lt;return expression&gt;</strong></span>
</pre></div><p>This expression by itself creates an anonymous function that can be used in any place that a function object is expected. Note that the return value must be a single expression and cannot contain any statements.</p><p>The formula for the function may seem unusual, but it was chosen by trial-and-error and a little bit of calculus so that it produces a nice graph in the interval from <code class="literal">0</code> to <code class="literal">5</code>. The <code class="literal">xvalues</code> array is defined to contain 200 equally spaced points on this interval.</p><p>Let's create an initial plot of our curve, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(xvalues, f(xvalues), lw=2, color='FireBrick')</strong></span>
<span class="strong"><strong>axis([0, 5, -1, 8])</strong></span>
<span class="strong"><strong>grid()</strong></span>
<span class="strong"><strong>xlabel('$x$')</strong></span>
<span class="strong"><strong>ylabel('$f(x)$')</strong></span>
<span class="strong"><strong>title('Extreme values of a function')</strong></span>
<span class="strong"><strong>None # Prevent text output</strong></span>
</pre></div><p>Most of the code in this segment is explained in the previous section. The only new bit is that we use the <code class="literal">grid()</code> function to draw a grid. Used with no arguments, the grid coincides with the <a class="indexterm" id="id247"/>tick marks on the plot. As everything else in matplotlib, grids <a class="indexterm" id="id248"/>are highly customizable. Check the documentation at <a class="ulink" href="http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid">http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid</a>.</p><p>When the preceding code is <a class="indexterm" id="id249"/>executed, the following plot is produced:</p><div class="mediaobject"><img alt="Text and annotations" src="graphics/8341OS_03_07.jpg"/></div><p>Note that the curve has a highest point (<span class="emphasis"><em>maximum</em></span>) and a lowest point (<span class="emphasis"><em>minimum</em></span>). These are collectively called the <span class="emphasis"><em>extreme values</em></span> of the function (on the displayed interval, this function actually grows <a class="indexterm" id="id250"/>without bounds as <span class="emphasis"><em>x</em></span> becomes large). We would like to locate these on the plot with annotations. We will first store the relevant points as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x_min = 3.213</strong></span>
<span class="strong"><strong>f_min = f(x_min)</strong></span>
<span class="strong"><strong>x_max = 0.698</strong></span>
<span class="strong"><strong>f_max = f(x_max)</strong></span>
<span class="strong"><strong>p_min = array([x_min, f_min])</strong></span>
<span class="strong"><strong>p_max = array([x_max, f_max])</strong></span>
<span class="strong"><strong>print p_min</strong></span>
<span class="strong"><strong>print p_max</strong></span>
</pre></div><p>The variables, <code class="literal">x_min</code> and <code class="literal">f_min</code>, are defined to be (approximately) the coordinates of the lowest point in the graph. Analogously, <code class="literal">x_max</code> and <code class="literal">f_max</code> represent the highest point. Don't be concerned with how these points were found. For the purposes of graphing, even a rough approximation <a class="indexterm" id="id251"/>by trial-and-error would suffice. In <a class="link" href="ch05.html" title="Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro">Chapter 5</a>, <span class="emphasis"><em>Advanced Computing with SciPy, Numba, and NumbaPro</em></span>, we will see how to solve this kind of problem accurately via SciPy. Now, add the following code to the cell that draws the plot, right below the <code class="literal">title()</code> command, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>arrow_props = dict(facecolor='DimGray', width=3, shrink=0.05, </strong></span>
<span class="strong"><strong>              headwidth=7)</strong></span>
<span class="strong"><strong>delta = array([0.1, 0.1])</strong></span>
<span class="strong"><strong>offset = array([1.0, .85])</strong></span>
<span class="strong"><strong>annotate('Maximum', xy=p_max+delta, xytext=p_max+offset,</strong></span>
<span class="strong"><strong>         arrowprops=arrow_props, verticalalignment='bottom',</strong></span>
<span class="strong"><strong>         horizontalalignment='left', fontsize=13)</strong></span>
<span class="strong"><strong>annotate('Minimum', xy=p_min-delta, xytext=p_min-offset,</strong></span>
<span class="strong"><strong>         arrowprops=arrow_props, verticalalignment='top',</strong></span>
<span class="strong"><strong>         horizontalalignment='right', fontsize=13)</strong></span>
</pre></div><p>Run the cell to produce the plot shown in the following diagram:</p><div class="mediaobject"><img alt="Text and annotations" src="graphics/8341OS_03_08.jpg"/></div><p>In the code, start by assigning the variables <code class="literal">arrow_props</code>, <code class="literal">delta</code>, and <code class="literal">offset</code>, which will be used to set the arguments in the calls to <code class="literal">annotate()</code>. The <code class="literal">annotate()</code> function adds a textual <a class="indexterm" id="id252"/>annotation to the graph with an optional arrow indicating the point being annotated. The first argument of the function is the text of the annotation. The next two arguments give the locations of the arrow and the text:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">xy</code>: This is the point being annotated and will correspond to the tip of the arrow. We want this to <a class="indexterm" id="id253"/>be the maximum/minimum points, <code class="literal">p_min</code> and <code class="literal">p_max</code>, but we add/subtract the <code class="literal">delta</code> vector so that the tip is a bit removed from the actual point.</li><li class="listitem" style="list-style-type: disc"><code class="literal">xytext</code>: This is the <a class="indexterm" id="id254"/>point where the text will be placed as well as the base of the arrow. We specify this as offsets from <code class="literal">p_min</code> and <code class="literal">p_max</code> using the <code class="literal">offset</code> vector.</li></ul></div><p>All other arguments of <code class="literal">annotate()</code> are formatting options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">arrowprops</code>: This is a <a class="indexterm" id="id255"/>Python dictionary containing the arrow properties. We predefine the dictionary, <code class="literal">arrow_props</code>, and use it here. Arrows can be quite sophisticated in matplotlib, and you are directed to the documentation for details.</li><li class="listitem" style="list-style-type: disc"><code class="literal">verticalalignment</code> and <code class="literal">horizontalalignment</code>: These specify how the arrow <a class="indexterm" id="id256"/>should be aligned with the <a class="indexterm" id="id257"/>text.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fontsize</code>: This signifies the size of the text. Text is also highly configurable, and <a class="indexterm" id="id258"/>the reader is directed to the documentation for details.</li></ul></div><p>The <code class="literal">annotate()</code> function has a huge number of options; for complete details of what is available, users should consult the documentation at <a class="ulink" href="http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate">http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate</a> for the full details.</p><p>We now want to add a comment for what is being demonstrated by the plot by adding an explanatory textbox. Add the following code to the cell right after the calls to <code class="literal">annotate()</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bbox_props = dict(boxstyle='round', lw=2, fc='Beige')</strong></span>
<span class="strong"><strong>text(2, 6, 'Maximum and minimum points\nhave horizontal tangents', </strong></span>
<span class="strong"><strong>     bbox=bbox_props, fontsize=12, verticalalignment='top')</strong></span>
</pre></div><p>The <code class="literal">text()</code>function is <a class="indexterm" id="id259"/>used to place text at an arbitrary position of the plot. The first two arguments are the position of the textbox, and the third argument is a string containing the text to be <a class="indexterm" id="id260"/>displayed. Notice the use of <code class="literal">'\n'</code> to indicate a line break. The other <a class="indexterm" id="id261"/>arguments are configuration options. The <code class="literal">bbox</code> argument is a dictionary with the options for the box. If omitted, the text will be displayed without any surrounding box. In the example code, the box is a rectangle with rounded corners, with a border width of 2 pixels and the face color, beige.</p><p>As a final detail, let's add the tangent lines at the extreme points. Add the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot([x_min-0.75, x_min+0.75], [f_min, f_min],</strong></span>
<span class="strong"><strong>     color='RoyalBlue', lw=3)</strong></span>
<span class="strong"><strong>plot([x_max-0.75, x_max+0.75], [f_max, f_max],</strong></span>
<span class="strong"><strong>     color='RoyalBlue', lw=3)</strong></span>
</pre></div><p>Since the tangents are segments of straight lines, we simply give the coordinates of the endpoints. The reason to add the code for the tangents at the top of the cell is that this causes them to be plotted first so that the graph of the function is drawn at the top of the tangents. This is the final result:</p><div class="mediaobject"><img alt="Text and annotations" src="graphics/8341OS_03_09.jpg"/></div><p>The examples we have <a class="indexterm" id="id262"/>seen so far only scratch the surface of what is possible with <a class="indexterm" id="id263"/>matplotlib. The reader should read the matplotlib documentation for more examples.</p></div></div></div>
<div class="section" title="Three-dimensional plots"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Three-dimensional plots</h1></div></div></div><p>In this section, we present methods to display three-dimensional plots, that is, plots of mathematical <a class="indexterm" id="id264"/>objects in space. Examples include surfaces and lines that are not confined to a plate.</p><p>matplotlib has excellent support for three-dimensional plots. In this section, we will present an example of a surface plot and corresponding contour plot. The types of plot available in the three-dimensional library include wireframe plots, line plots, scatterplots, triangulated surface plots, polygon plots, and several others. The following link will help you to understand the <a class="indexterm" id="id265"/>types of plots that are not treated here: <a class="ulink" href="http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial">http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial</a>
</p><p>Before we start, we need to import the three-dimensional library objects we need using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from mpl_toolkits.mplot3d import axes3d</strong></span>
</pre></div><p>Now, let's draw our surface plot by running the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def dist(x, y):</strong></span>
<span class="strong"><strong>    return sqrt(x**2 + y**2) </strong></span>
<span class="strong"><strong>def fsurface(x, y):</strong></span>
<span class="strong"><strong>    d = sqrt(x**2 + y**2)</strong></span>
<span class="strong"><strong>    c = 5.0</strong></span>
<span class="strong"><strong>    r = 7.5</strong></span>
<span class="strong"><strong>    return c - (d**4 - r * d**2)</strong></span>

<span class="strong"><strong>xybound = 2.5</strong></span>
<span class="strong"><strong>fig = figure(figsize=(8,8))</strong></span>
<span class="strong"><strong>ax = subplot(1, 1, 1, projection='3d')</strong></span>
<span class="strong"><strong>X = linspace(-xybound, xybound, 25)</strong></span>
<span class="strong"><strong>Y = linspace(-xybound, xybound, 25)</strong></span>
<span class="strong"><strong>X, Y = meshgrid(X, Y)</strong></span>
<span class="strong"><strong>Z = fsurface(X,Y)</strong></span>
<span class="strong"><strong>ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,</strong></span>
<span class="strong"><strong>                antialiased=True, linewidth=0.2)</strong></span>
<span class="strong"><strong>ax.set_xlabel(r'$x$')</strong></span>
<span class="strong"><strong>ax.set_ylabel(r'$y$')</strong></span>
<span class="strong"><strong>ax.set_zlabel(r'$f(x,y)$')</strong></span>
<span class="strong"><strong>None #Prevent text output</strong></span>
</pre></div><p>We start by specifying the <a class="indexterm" id="id266"/>
<code class="literal">fsurface()</code> function, which defines the surface. The details of the function definition are not relevant; we will just note that this is a surface of revolution that has a dip at the center, surrounded by a ridge. We then start setting up the figure with the following lines of code:</p><div class="informalexample"><pre class="programlisting">fig = figure(figsize=(8,8))
ax = subplot(1, 1, 1, projection='3d')</pre></div><p>This time, we specifically construct the <code class="literal">Figure</code> object because we want to specify its size explicitly. The size here is defined as an <code class="literal">8</code> x <code class="literal">8</code> inch square, but this is not quite accurate since the actual size of the figure will depend on the resolution of the display and the magnification factor of the browser. We then create a subplot and set its projection type to <code class="literal">'3d'</code>. The <code class="literal">subplot()</code> function <a class="indexterm" id="id267"/>will be treated with more detail later in this section.</p><p>Next, we will define the <a class="indexterm" id="id268"/>grid of points where the function is computed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>xybound = 2.5</strong></span>
<span class="strong"><strong>x = linspace(-xybound, xybound, 25)</strong></span>
<span class="strong"><strong>y = linspace(-xybound, xybound, 25)</strong></span>
<span class="strong"><strong>X, Y = meshgrid(x, y)</strong></span>
</pre></div><p>The most <a class="indexterm" id="id269"/>important point here is the use of the <code class="literal">meshgrid()</code> function, which is a part of the <code class="literal">NumPy</code> package. This function takes two one-dimensional arrays, with <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values and computes two matrices that define the corresponding grid of points on the plane. To understand how this works, run the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>xx = [1,2,3]</strong></span>
<span class="strong"><strong>yy = [4,5,6]</strong></span>
<span class="strong"><strong>XX, YY = meshgrid(xx, yy)</strong></span>
<span class="strong"><strong>print XX</strong></span>
<span class="strong"><strong>print YY</strong></span>
</pre></div><p>The two matrices produced, <code class="literal">XX</code> and <code class="literal">YY</code>, are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">XX</code> matrix:<div class="informalexample"><pre class="programlisting">[[1 2 3]
 [1 2 3]
 [1 2 3]]</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">YY</code> matrix:<div class="informalexample"><pre class="programlisting">[[4 4 4]
 [5 5 5]
 [6 6 6]]</pre></div></li></ul></div><p>Note that, if we take the elements of <code class="literal">XX</code> and the corresponding entries in <code class="literal">YY</code>, we get the set of points (1,4), (1,5), (1,6), (2,4),…, (3,5), (3,6), which are on a regularly spaced grid on the plane.</p><p>We are now ready to call the function that computes the surface and plot it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Z = fsurface(X,Y)</strong></span>
<span class="strong"><strong>ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,</strong></span>
<span class="strong"><strong>                antialiased=True, linewidth=0.2)</strong></span>
<span class="strong"><strong>ax.set_xlabel(r'$x$')</strong></span>
<span class="strong"><strong>ax.set_ylabel(r'$y$')</strong></span>
<span class="strong"><strong>ax.set_zlabel(r'$f(x,y)$')</strong></span>
</pre></div><p>The first line computes the <code class="literal">Z</code> array, containing the <span class="emphasis"><em>z</em></span> coordinates of the surface. This call makes heavy <a class="indexterm" id="id270"/>use of a feature of <code class="literal">NumPy</code> called <span class="strong"><strong>broadcasting</strong></span> in the background. This is a set of rules that tells us how <code class="literal">NumPy</code> deals with operations for arrays with different sizes. For more information, see <a class="ulink" href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html</a>.</p><p>The next step is to call the <a class="indexterm" id="id271"/>
<code class="literal">plot_surface()</code> method, which does the actual plotting. The first three arguments define the data being plotted, that is, the arrays <code class="literal">X</code>, <code class="literal">Y</code>, and <code class="literal">Z</code>. The <code class="literal">cstride</code> and <code class="literal">rstride</code> options can be used to skip points in the data <a class="indexterm" id="id272"/>arrays. Set these to values greater than 1 to skip points in the grid, in the event the data set is too large.</p><p>We are using a <span class="strong"><strong>colormap</strong></span> <a class="indexterm" id="id273"/>feature specified by the <code class="literal">cmap=cm.coolwarm</code> option. The colormap feature tells matplotlib how to assign a color to each height in the plot. A large number of built-in colormaps are available. To see a complete list, run the following lines of code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>for key, value in cm.__dict__.items():</strong></span>
<span class="strong"><strong>    if isinstance(value, matplotlib.colors.Colormap):</strong></span>
<span class="strong"><strong>        print key</strong></span>
</pre></div><p>Note that three-dimensional surface plots are, by default, not antialiased, so we set the <code class="literal">antialiased=True</code> option in the code to produce a better image.</p><p>Let's now add a contour plot to the graph. We want the three-dimensional surface plot and the contour graph to appear side-by-side. To achieve that, modify the code in the cell to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fig = figure(figsize(20,8))</strong></span>
<span class="strong"><strong>ax1 = subplot(1, 2, 1, projection='3d')</strong></span>
<span class="strong"><strong>X = linspace(-xybound, xybound, 100)</strong></span>
<span class="strong"><strong>Y = linspace(-xybound, xybound, 100)</strong></span>
<span class="strong"><strong>X, Y = np.meshgrid(X, Y)</strong></span>
<span class="strong"><strong>Z = fsurface(X,Y)</strong></span>
<span class="strong"><strong>ax1.plot_surface(X, Y, Z, rstride=5, cstride=5, cmap=cm.coolwarm,</strong></span>
<span class="strong"><strong>                antialiased=True, linewidth=0.2)</strong></span>
<span class="strong"><strong>ax1.set_xlabel(r'$x$')</strong></span>
<span class="strong"><strong>ax1.set_ylabel(r'$y$')</strong></span>
<span class="strong"><strong>ax1.set_zlabel(r'$f(x,y)$')</strong></span>
<span class="strong"><strong>ax1.set_title('A surface plot', fontsize=18)</strong></span>
<span class="strong"><strong>ax2 = subplot(1, 2, 2)</strong></span>
<span class="strong"><strong>ax2.set_aspect('equal')</strong></span>
<span class="strong"><strong>levels = arange(5, 20, 2.5)</strong></span>
<span class="strong"><strong>cs = ax2.contour(X, Y, Z,</strong></span>
<span class="strong"><strong>            levels,</strong></span>
<span class="strong"><strong>            cmap=cm.Reds,</strong></span>
<span class="strong"><strong>            linewidths=1.5)</strong></span>
<span class="strong"><strong>cs.clabel(levels[1::2], fontsize=12)</strong></span>
<span class="strong"><strong>ax2.set_title('Contour Plot', fontsize=18)</strong></span>
</pre></div><p>The result of running <a class="indexterm" id="id274"/>the code is shown in the following figure:</p><div class="mediaobject"><img alt="Three-dimensional plots" src="graphics/8341OS_03_10.jpg"/></div><p>Let's first concentrate on the <code class="literal">contours()</code> method. The first argument, <code class="literal">levels</code>, specifies the values (heights) for <a class="indexterm" id="id275"/>which the contours are plotted. This argument can be left out, and matplotlib will try to choose the heights in a way that makes sense. The other arguments are options for how to display the contours. We specify the colormap and line width in this example.</p><p>The <code class="literal">clabel()</code> method <a class="indexterm" id="id276"/>adds labels to the contours. The first argument, <code class="literal">levels[1::2]</code>, specifies that every second contour is to be labeled.</p><p>Note the code that is used to place two axes in the same figure. The axes are defined by the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ax1 = subplot(1, 2, 1, projection='3d')</strong></span>
<span class="strong"><strong>ax2 = subplot(1, 2, 2)</strong></span>
</pre></div><p>The general form of the <code class="literal">subplot()</code> function is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>subplot(nrows, ncols, axis_position, **kwargs)</strong></span>
</pre></div><p>This specifies an <code class="literal">Axes</code> object in an array with <code class="literal">nrows</code> rows and <code class="literal">ncols</code> columns. The position of the axis is an integer from 1 to <code class="literal">nrows*ncols</code>. The following figure illustrates how the axes are numbered in the case of a 3 x 2 array:</p><div class="mediaobject"><img alt="Three-dimensional plots" src="graphics/8341OS_03_11.jpg"/></div><p>The preceding image was generated with the help of the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fig = figure(figsize=(5,6))</strong></span>
<span class="strong"><strong>nrows = 3</strong></span>
<span class="strong"><strong>ncols = 2</strong></span>
<span class="strong"><strong>for i in range(nrows*ncols):</strong></span>
<span class="strong"><strong>    ax = subplot(nrows, ncols, i+1, axisbg='Bisque')</strong></span>
<span class="strong"><strong>    axis([0,10,0,5])</strong></span>
<span class="strong"><strong>    text(1, 2.2, 'subplot({},{},{})'.format(nrows, ncols, i+1),</strong></span>
<span class="strong"><strong>         fontsize=14, color='Brown')</strong></span>
</pre></div><p>After defining the figure size in the usual way, we set the number of rows and columns of the grid of axes we want to generate. Then, each of the <code class="literal">Axes</code> objects is created and configured in the loop. Look carefully at how the positions of the axes are identified. Note also that we show how to set the background color of the axes.</p></div>
<div class="section" title="Animations"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Animations</h1></div></div></div><p>We will finish the chapter <a class="indexterm" id="id277"/>with a more complex example that illustrates the power that matplotlib gives us. We will create an animation of a forced pendulum, a well-known and much studied example of a dynamic system exhibiting deterministic chaos.</p><p>Since this section involves more sophisticated code, we will refrain from using <code class="literal">pylab</code> and adopt the generally recommended way of importing modules. This makes the code easier to export to a script if we so wish. We also give samples of some of the object-oriented features of matplotlib.</p><p>The process of animating a pendulum (or any physical process) is actually very simple: we compute the position of the pendulum at a finite number of times and display the corresponding images in quick succession. So, the code will naturally break down into the following three pieces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A function that displays a pendulum in an arbitrary position</li><li class="listitem" style="list-style-type: disc">Setting up the computation of the position of the pendulum at an arbitrary time</li><li class="listitem" style="list-style-type: disc">The code that actually computes the position of the pendulum and displays the corresponding images</li></ul></div><p>We start by importing all the modules and functions we need to set up the animation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%matplotlib inline</strong></span>
<span class="strong"><strong>import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>import numpy as np</strong></span>
<span class="strong"><strong>import matplotlib.patches as patches</strong></span>
<span class="strong"><strong>import matplotlib.lines as lines</strong></span>
<span class="strong"><strong>from scipy.integrate import ode</strong></span>
<span class="strong"><strong>from IPython.display import display, clear_output</strong></span>
<span class="strong"><strong>import time</strong></span>
</pre></div><p>In the following code, we will define a function that draws a simple sketch of a pendulum:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def draw_pendulum(ax, theta, length=5, radius=1):</strong></span>
<span class="strong"><strong>    v = length * np.array([np.sin(theta), -np.cos(theta)])</strong></span>
<span class="strong"><strong>    ax.axhline(0.0, color='Brown', lw=5, zorder=0)</strong></span>
<span class="strong"><strong>    rod = lines.Line2D([0.0, v[0]], [0.0, v[1]], </strong></span>
<span class="strong"><strong>                       lw=4, color='DarkGray', zorder=1)</strong></span>
<span class="strong"><strong>    bob = patches.Circle(v, radius, </strong></span>
<span class="strong"><strong>                         fc='DodgerBlue', ec='DarkSlateGray', </strong></span>
<span class="strong"><strong>                         lw=1.5, zorder=3)</strong></span>
<span class="strong"><strong>    peg = patches.Circle([0.0, 0.0], 0.3, </strong></span>
<span class="strong"><strong>                         fc='black', zorder=2)</strong></span>
<span class="strong"><strong>    ax.add_patch(bob)</strong></span>
<span class="strong"><strong>    ax.add_patch(peg)</strong></span>
<span class="strong"><strong>    ax.add_line(rod)</strong></span>
<span class="strong"><strong>    return ax</strong></span>
</pre></div><p>This function takes as the first argument an <code class="literal">Axes</code> object. The other arguments are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The angle, <code class="literal">theta</code>, of the pendulum with the vertical surface</li><li class="listitem" style="list-style-type: disc">The <code class="literal">length</code> of the rod</li><li class="listitem" style="list-style-type: disc">The <code class="literal">radius</code> of the bob</li></ul></div><p>The preceding <a class="indexterm" id="id278"/>quantities are indicated in the following figure:</p><div class="mediaobject"><img alt="Animations" src="graphics/8341OS_03_12.jpg"/></div><p>Then, we define a <code class="literal">NumPy</code> vector, <code class="literal">v</code>, which holds the position of the pendulum relative to the origin. The following statements define the objects to be drawn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ax.axhline()</code>: This <a class="indexterm" id="id279"/>function draws a horizontal line across the plot</li><li class="listitem" style="list-style-type: disc"><code class="literal">rod</code>: This is a <code class="literal">lines.Line2D</code> object (incidentally, this is the object that is used to draw <a class="indexterm" id="id280"/>most plots in matplotlib)</li><li class="listitem" style="list-style-type: disc"><code class="literal">bob</code> and <code class="literal">peg</code>: These <a class="indexterm" id="id281"/>are objects of the <code class="literal">patches.Circle</code> type; matplotlib patches <a class="indexterm" id="id282"/>represent essentially any kind of object that can be placed in a figure</li></ul></div><p>The following lines of code can be used to test the drawing code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>fig = plt.figure(figsize=(5,5))</strong></span>
<span class="strong"><strong>ax = fig.add_subplot(1, 1, 1)</strong></span>
<span class="strong"><strong>ax.set_aspect('equal')</strong></span>
<span class="strong"><strong>ax.set_xlim(-10,10)</strong></span>
<span class="strong"><strong>ax.set_ylim(-20,0.5)</strong></span>
<span class="strong"><strong>draw_pendulum(ax, np.pi / 10, length=15, radius=0.5)</strong></span>
<span class="strong"><strong>ax.set_xticks([])</strong></span>
<span class="strong"><strong>ax.set_yticks([])</strong></span>
</pre></div><p>Running the code in the <a class="indexterm" id="id283"/>previous cell will produce the following image:</p><div class="mediaobject"><img alt="Animations" src="graphics/8341OS_03_13.jpg"/></div><p>The following comments indicate how the code in the preceding example works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first two lines define the variables, <code class="literal">fig</code> and <code class="literal">ax</code>, that hold the <code class="literal">Figure</code> and <code class="literal">Axes</code> objects, respectively. In matplotlib, a <code class="literal">Figure</code> object is a container that holds all other plotting objects. Each <code class="literal">Figure</code> can contain several <code class="literal">Axes</code>, which contain individual plots. Note the use of the <code class="literal">figsize=(5,5)</code> argument to set the size of the figure.</li><li class="listitem">Next, we set the axis limits. The <code class="literal">set_aspect()</code> method of the <code class="literal">ax</code> object is used to set the aspect ratio to be the same in both directions. Without this, the circles will be drawn as ellipses. Then, the <code class="literal">set_xlim()</code> and <code class="literal">set_ylim()</code> methods specify the bounds for the axes.</li><li class="listitem">We then call the <code class="literal">draw_pendulum()</code> function, which does all the drawing.</li><li class="listitem">Finally, we use <code class="literal">ax.set_xticks([])</code> and <code class="literal">set_yticks([])</code> to remove the tick marks from the axes.</li></ol></div><p>The next step is to set up what is needed to find the trajectory to the pendulum. The dynamics of a pendulum are given by a system of differential equations, which is defined in the following lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def pendulum_eq(t, x, c=1, f=lambda t:0.0):</strong></span>
<span class="strong"><strong>    theta, omega = x</strong></span>
<span class="strong"><strong>    return np.array([omega,</strong></span>
<span class="strong"><strong>                     -np.sin(theta) - c * omega + f(t)], </strong></span>
<span class="strong"><strong>                    dtype=np.float64)</strong></span>
<span class="strong"><strong>solver = ode(pendulum_eq)</strong></span>
<span class="strong"><strong>solver.set_integrator('lsoda')</strong></span>
<span class="strong"><strong>c = 0.3</strong></span>
<span class="strong"><strong>f = lambda t: 2.0 * np.sin(3 * t)</strong></span>
<span class="strong"><strong>solver.set_f_params(c, f)</strong></span>
</pre></div><p>This code starts by defining the <code class="literal">pendulum_eq()</code> function, which stipulates the differential equations for a pendulum. The derivation of the equations is beyond the scope of this book. The remaining code in the cell configures an object of the <code class="literal">ode()</code> type, which is a part of the <code class="literal">scipy.integrate</code> module. We will not discuss the details here, but this module is discussed in <a class="link" href="ch05.html" title="Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro">Chapter 5</a>, <span class="emphasis"><em>Advanced Computing with SciPy, Numba, and NumbaPro</em></span>.</p><p>We are now ready to run <a class="indexterm" id="id284"/>the animation by executing the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tmax = 20.0</strong></span>
<span class="strong"><strong>dt = 0.2</strong></span>

<span class="strong"><strong>fig = plt.figure(1,figsize=(5,5))</strong></span>
<span class="strong"><strong>ax = plt.subplot(1,1,1)</strong></span>
<span class="strong"><strong>ax.set_aspect('equal')</strong></span>
<span class="strong"><strong>ax.set_xlim(-10,10)</strong></span>
<span class="strong"><strong>ax.set_ylim(-20,0.5)</strong></span>
<span class="strong"><strong>xtext = -9</strong></span>
<span class="strong"><strong>ytext = -2</strong></span>
<span class="strong"><strong>dytext = -1.0</strong></span>

<span class="strong"><strong>ic = np.array([0.0, 0.3])</strong></span>
<span class="strong"><strong>solver.set_initial_value(ic, 0.0)</strong></span>
<span class="strong"><strong>while True:</strong></span>
<span class="strong"><strong>    clear_output(wait=True)</strong></span>
<span class="strong"><strong>    time.sleep(1./20)</strong></span>
<span class="strong"><strong>    t = solver.t</strong></span>
<span class="strong"><strong>    if t &gt; tmax:</strong></span>
<span class="strong"><strong>        break</strong></span>
<span class="strong"><strong>    theta, omega = solver.integrate(t + dt)</strong></span>
<span class="strong"><strong>    if not solver.successful():</strong></span>
<span class="strong"><strong>        print 'Solver interrupted'</strong></span>
<span class="strong"><strong>        break</strong></span>
<span class="strong"><strong>    ax.clear()</strong></span>
<span class="strong"><strong>    ax.set_xticks([])</strong></span>
<span class="strong"><strong>    ax.set_yticks([])</strong></span>
<span class="strong"><strong>    ax.text(xtext, ytext, r'$t={:5.2f}$'.format(t))</strong></span>
<span class="strong"><strong>    ax.text(xtext, ytext + dytext, </strong></span>
<span class="strong"><strong>            r'$\theta={:5.2f}$'.format(theta))</strong></span>
<span class="strong"><strong>    ax.text(xtext, ytext + 2 * dytext, </strong></span>
<span class="strong"><strong>            r'$\dot{{\theta}}={:5.2f}$'.format(omega))</strong></span>
<span class="strong"><strong>    draw_pendulum(ax, theta=theta, length=15, radius=0.5)</strong></span>
<span class="strong"><strong>    display(fig)</strong></span>
<span class="strong"><strong>    plt.close()</strong></span>
</pre></div><p>This is probably the most complex code segment in the book so far, but most of it has already been covered. The variables <code class="literal">tmax</code> and <code class="literal">dt</code> hold the maximum time for the animation and the time <a class="indexterm" id="id285"/>increment, respectively. We then set the <code class="literal">Figure</code> and <code class="literal">Axes</code> objects for the plot.</p><p>Then comes a <code class="literal">while</code> loop, where the animation is actually executed. This is the general skeleton of the loop:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>while True:</strong></span>
<span class="strong"><strong>    clear_output(wait=True)</strong></span>
<span class="strong"><strong>    time.sleep(1./20)</strong></span>
<span class="strong"><strong>    t = solver.t</strong></span>
<span class="strong"><strong>    if t &gt; tmax:</strong></span>
<span class="strong"><strong>        break</strong></span>

<span class="strong"><strong>    ... Code to determine the position of the pendulum...</strong></span>

<span class="strong"><strong>    ... Code to draw pendulum ...</strong></span>

<span class="strong"><strong>    display(fig)</strong></span>
<span class="strong"><strong>    plt.close()</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>We will not discuss in detail the code used to solve the differential equation since it will be presented in detail in <a class="link" href="ch05.html" title="Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro">Chapter 5</a>, <span class="emphasis"><em>Advanced Computing with SciPy, Numba, and NumbaPro</em></span>.</p></div></div><p>The loop has <code class="literal">True</code> as the looping condition so this is potentially an infinite loop. However, inside the loop, we check if the current time is larger than the maximum time for the animation, and if that is the case, we break from the loop:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>    t = solver.t</strong></span>
<span class="strong"><strong>    if t &gt; tmax:</strong></span>
<span class="strong"><strong>        break</strong></span>
</pre></div><p>The first thing we <a class="indexterm" id="id286"/>do in the loop is to call the <code class="literal">clear_output()</code> function. This function, as the name indicates, removes the output of the current cell and is at the heart of doing simple animations in the notebook. The <code class="literal">wait=True</code> argument tells the function to wait until the next image is fully drawn before clearing the output, which prevents flickering.</p><p>The <code class="literal">time.sleep(1./20)</code> argument pauses the computation for a brief period of time to prevent the animation <a class="indexterm" id="id287"/>from running too fast. Then, a new position of the pendulum is computed and plotted. Then, <code class="literal">display(fig)</code> is called to show the figure. This is needed here because, contrary to the case of static graphs, we don't want the plot to be shown only at the end of the cell.</p><p>The final detail is to call <code class="literal">plt.close()</code> at the end of the loop. This prevents the pendulum image from being drawn one extra time when the loop is exited. Placing this call inside the loop also helps to avoid flicker.</p><p>The reader is encouraged to <a class="indexterm" id="id288"/>play with the parameters of the animation, specially the time interval, <code class="literal">dt</code>; the maximum time, <code class="literal">tmax</code>; and the <code class="literal">time.sleep()</code> parameter. A bit of trial-and-error is needed to get satisfactory animation.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we learned how to use matplotlib to produce presentation-quality plots. We covered two-dimensional plots and how to set plot options, and annotate and configure plots. You also learned how to add labels, titles, and legends. We also learned how to draw three-dimensional surface plots and how to create simple animations.</p><p>In the next chapter, we will explore how to work with data in the notebook using the pandas library.</p></div></body></html>