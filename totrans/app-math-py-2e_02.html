<html><head></head><body>
		<div id="_idContainer302">
			<h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor036"/>2</h1>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Mathematical Plotting with Matplotlib</h1>
			<p>Plotting is a fundamental tool in all of mathematics. A good plot can reveal hidden details, suggest future directions, verify results, or reinforce an argument. It is no surprise, then, that the scientific Python stack features a powerful and flexible plotting library <span class="No-Break">called Matplotlib.</span></p>
			<p>In this chapter, we will plot functions and data in a variety of styles and create figures that are fully labeled and annotated. We will create three-dimensional plots, customize the appearance of figures, create figures that contain multiple plots using subplots, and save figures directly to files for applications that are not running in an <span class="No-Break">interactive environment.</span></p>
			<p>Plotting is one of the most important aspects covered in this book. Plotting data, functions, or solutions can often help you gain an understanding of a problem that can really help to reason about your methods. We will see plotting again in every chapter of <span class="No-Break">this book.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Basic plotting <span class="No-Break">with Matplotlib</span></li>
				<li><span class="No-Break">Adding subplots</span></li>
				<li>Plotting with <span class="No-Break">error bars</span></li>
				<li>Saving <span class="No-Break">Matplotlib figures</span></li>
				<li>Surface and <span class="No-Break">contour plots</span></li>
				<li>Customizing <span class="No-Break">three-dimensional plots</span></li>
				<li>Plotting vector fields with <span class="No-Break">quiver plots</span></li>
			</ul>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>The main plotting package for Python is Matplotlib, which can be installed using your favorite package manager, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
python3.10 -m pip install matplotlib</pre>
			<p>This will install the most recent version of Matplotlib, which, at the time of writing this book, is <span class="No-Break">version 3.5.2.</span></p>
			<p>Matplotlib contains numerous sub-packages, but the main <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) is the <strong class="source-inline">matplotlib.pyplot</strong> package, which, by convention, is imported under the <strong class="source-inline">plt</strong> alias. This is achieved using the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
import matplotlib.pyplot as plt</pre>
			<p>Many of the recipes in this chapter also require NumPy, which, as usual, is imported under the <span class="No-Break"><strong class="source-inline">np</strong></span><span class="No-Break"> alias.</span></p>
			<p>The code for this chapter can be found in the <span class="No-Break"><strong class="source-inline">Chapter 02</strong></span> folder of the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002"><span class="No-Break">https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Basic plotting with Matplotlib</h1>
			<p>Plotting<a id="_idIndexMarker120"/> is an<a id="_idIndexMarker121"/> important part of understanding behavior. So much can be learned by simply plotting a function or data that would otherwise be hidden. In this recipe, we will walk through how to plot simple functions or data using Matplotlib, set the plotting style, and add labels to <span class="No-Break">a plot.</span></p>
			<p>Matplotlib is <a id="_idIndexMarker122"/>a very powerful plotting library, which means it can be rather intimidating to perform simple tasks with it. For users who are used to working with MATLAB and other <a id="_idIndexMarker123"/>mathematical software packages, there is a state-based interface called <strong class="source-inline">pyplot</strong>. There is also <a id="_idIndexMarker124"/>an <strong class="bold">object-oriented interface</strong> (<strong class="bold">OOI</strong>), which might be more appropriate for more complex plots. In either case, the <strong class="source-inline">pyplot</strong> interface is a convenient way to create <span class="No-Break">basic objects.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Getting ready</h2>
			<p>Most commonly, the data that you wish to plot will be stored in two separate NumPy arrays, which we will label <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> for clarity (although this naming does not matter in practice). We will demonstrate plotting the graph of a function, so we will generate an array of <strong class="source-inline">x</strong> values and use the function to generate the corresponding <strong class="source-inline">y</strong> values. We’re going to plot three<a id="_idIndexMarker125"/> different functions over the range <img alt="" src="image/Formula_02_001.png"/> on the <span class="No-Break">same axes:</span></p>
			<pre class="source-code">
def f(x):
  return x*(x - 2)*np.exp(3 – x)
def g(x):
  return x**2
def h(x):
  return 1 - x</pre>
			<p>Let’s plot these three functions in Python <span class="No-Break">using Matplotlib.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>How to do it...</h2>
			<p>Before we<a id="_idIndexMarker126"/> can plot the function, we must generate <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> data to be plotted. If you are plotting existing data, you can skip these commands. We need to create a set of <strong class="source-inline">x</strong> values that cover the desired range, and then use the function to create <span class="No-Break"><strong class="source-inline">y</strong></span><span class="No-Break"> values:</span></p>
			<ol>
				<li>The <strong class="source-inline">linspace</strong> routine from NumPy is ideal for creating arrays of numbers for plotting. By default, it will create 50 equally spaced points between the specified arguments. The number of points can be customized by providing an additional argument, but 50 is sufficient for <span class="No-Break">most cases:</span><pre class="console">
x = np.linspace(-0.5, 3.0)  # 50 values between -0.5 and 3.0</pre></li>
				<li>Once we have created <strong class="source-inline">x</strong> values, we can generate <span class="No-Break"><strong class="source-inline">y</strong></span><span class="No-Break"> values:</span><pre class="console">
y1 = f(x)  # evaluate f on the x points</pre><pre class="console">
y2 = g(x)  # evaluate g on the x points</pre><pre class="console">
y3 = h(x)  # evaluate h on the x points</pre></li>
				<li>To plot the data, we first need to create a new figure and attach axes objects, which can be achieved by calling the <strong class="source-inline">plt.subplots</strong> routine without <span class="No-Break">any arguments:</span><pre class="console">
fig, ax = plt.subplots()</pre></li>
			</ol>
			<p>Now, we<a id="_idIndexMarker127"/> use the <strong class="source-inline">plot</strong> method on the <strong class="source-inline">ax</strong> object to plot <a id="_idIndexMarker128"/>the first function. The first two arguments are <img alt="" src="image/Formula_02_002.png"/> and <img alt="" src="image/Formula_02_003.png"/> coordinates to be plotted, and the third (optional) argument specifies that the line color should <span class="No-Break">be black:</span></p>
			<pre class="source-code">
ax.plot(x, y1, "k")  # black solid line style</pre>
			<p>To help distinguish the plots for the other functions, we plot those with a dashed line and a <span class="No-Break">dot-dash line:</span></p>
			<pre class="source-code">
ax.plot(x, y2, "k--")  # black dashed line style
ax.plot(x, y3, "k.-")  # black dot-dashed line style</pre>
			<p>Every plot should have a title and axis labels. In this case, there isn’t anything interesting to label the axes with, so we just label them <strong class="source-inline">"x"</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">"y"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
ax.set_title("Plot of the functions f, g, and h")
ax.set_xlabel("x")
ax.set_ylabel("y")</pre>
			<p>Let’s also add a legend to help you distinguish between the different function plots without having to look elsewhere to see which line <span class="No-Break">is which:</span></p>
			<pre class="source-code">
ax.legend(["f", "g", "h"])</pre>
			<p>Finally, let’s annotate the plot to mark the intersection between the functions <img alt="" src="image/Formula_02_004.png"/> and <img alt="" src="image/Formula_02_005.png"/> <span class="No-Break">with text:</span></p>
			<pre class="source-code">
ax.text(0.4, 2.0, "Intersection")</pre>
			<p>This will plot the <strong class="source-inline">y</strong> values against the <strong class="source-inline">x</strong> values on a new figure. If you are working within IPython or with a Jupyter notebook, then the plot should automatically appear at this point; otherwise, you might need to call the <strong class="source-inline">plt.show</strong> function to make the <span class="No-Break">plot appear:</span></p>
			<pre class="source-code">
plt.show()</pre>
			<p>If you use <strong class="source-inline">plt.show</strong>, the <a id="_idIndexMarker129"/>figure should appear in a new window. We won’t add this command to any further recipes in this chapter, but you should be aware <a id="_idIndexMarker130"/>that you will need to use it if you are not working in an environment where plots will be rendered automatically, such as an IPython console or a Jupyter Notebook. The resulting plot should look something like the plot in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer228">
					<img alt="Figure 2.1 – Three functions on a single set of axes, each with a different style, with labels, legend, and an annotation" src="image/B19085_02_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Three functions on a single set of axes, each with a different style, with labels, legend, and an annotation</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using a Jupyter notebook and the <strong class="source-inline">subplots</strong> command, you must include the call to <strong class="source-inline">subplots</strong> within the same cell as the plotting commands or the figure will not <span class="No-Break">be produced.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>How it works…</h2>
			<p>Here, we’re<a id="_idIndexMarker131"/> using <a id="_idIndexMarker132"/>the OOI because it allows us to keep track of exactly which figure and axes object we’re plotting on. This isn’t so important here where we have only a single <strong class="source-inline">figure</strong> and <strong class="source-inline">axes</strong>, but one can easily envisage situations where you might have two or more figures and axes concurrently. Another reason to follow this pattern is to be consistent when you add multiple subplots—see the <em class="italic">Adding </em><span class="No-Break"><em class="italic">subplots</em></span><span class="No-Break"> recipe.</span></p>
			<p>You can produce the same plot as in the recipe via the state-based interface by using the following sequence <span class="No-Break">of commands:</span></p>
			<pre class="source-code">
plt.plot(x, y1, "k", x, y2, "k--", x, y3, "k.-")
plt.title("Plot of the functions f, g, and h")
plt.xlabel("x")
plt.ylabel("y")
plt.legend(["f", "g", "h"])
plt.text(0.4, 2.0, "Intersection")</pre>
			<p>If there are currently no <strong class="source-inline">Figure</strong> or <strong class="source-inline">Axes</strong> objects, the <strong class="source-inline">plt.plot</strong> routine creates a new <strong class="source-inline">Figure</strong> object, adds a new <strong class="source-inline">Axes</strong> object to the figure, and populates this <strong class="source-inline">Axes</strong> object with the plotted data. A list of handles to the plotted lines is returned. Each of these handles is a <strong class="source-inline">Lines2D</strong> object. In this case, this list will contain a single <strong class="source-inline">Lines2D</strong> object. We could use this <strong class="source-inline">Lines2D</strong> object to further customize the appearance of the <span class="No-Break">line later.</span></p>
			<p>Notice that in the preceding code, we combined all the calls to the <strong class="source-inline">plot</strong> routine together. This is also possible if you use the OOI; the state-based interface is passing the arguments to the axes method on the set of axes that it either retrieves <span class="No-Break">or creates.</span></p>
			<p>The object layer of Matplotlib interacts with a lower-level <em class="italic">backend</em>, which does the heavy lifting of producing the graphical plot. The <strong class="source-inline">plt.show</strong> function issues an instruction to the backend to render the current figure. There are a number of backends that can be used with Matplotlib, which can be customized by setting the <strong class="source-inline">MPLBACKEND</strong> environment variable, modifying the <strong class="source-inline">matplotlibrc</strong> file, or by calling <strong class="source-inline">matplotlib.use</strong> from within Python with the name of an alternative backend. By default, Matplotlib picks a backend that is appropriate for the platform (Windows, macOS, Linux) and purpose (interactive or non-interactive), based on which backends are available. For example, on the author’s system, the <strong class="source-inline">QtAgg</strong> backend is the default. This is an interactive<a id="_idIndexMarker133"/> backend <a id="_idIndexMarker134"/>based on the <strong class="bold">Anti-Grain Geometry</strong> (<strong class="bold">AGG</strong>) library. Alternatively, one might want<a id="_idIndexMarker135"/> to use the <strong class="source-inline">QtCairo</strong> backend, which uses the Cairo library <span class="No-Break">for rendering.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">plt.show</strong> function <a id="_idIndexMarker136"/>does more than simply call the <strong class="source-inline">show</strong> method on a figure. It also hooks into an event loop to correctly display the figure. The <strong class="source-inline">plt.show</strong> routine should be used to display a figure, rather than the <strong class="source-inline">show</strong> method on a <span class="No-Break"><strong class="source-inline">Figure</strong></span><span class="No-Break"> object.</span></p>
			<p>The <strong class="bold">format string</strong> used <a id="_idIndexMarker137"/>to quickly specify the line style has three optional parts, each consisting of one or more characters. The first part controls the marker style, which is the symbol that is printed at each data point; the second controls the style of the line that connects the data points; the third controls the color of the plot. In this recipe, we only specified the line style. However, one could specify both line style and marker style or just marker style. If you only provide the marker style, no connecting lines are drawn between the points. This is useful for plotting discrete data where no interpolation between points <span class="No-Break">is necessary.</span></p>
			<p>Four line-style parameters are available: a solid line (<strong class="source-inline">-</strong>), a dashed line (<strong class="source-inline">--</strong>), a dash-dot line (<strong class="source-inline">-.</strong>), or a dotted line (<strong class="source-inline">:</strong>). Only a limited number of colors can be specified in the format string; they are red, green, blue, cyan, yellow, magenta, black, and white. The character used in the format string is the first letter of each color (with the exception of black), so the corresponding characters are <strong class="source-inline">r</strong>, <strong class="source-inline">g</strong>, <strong class="source-inline">b</strong>, <strong class="source-inline">c</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">m</strong>, <strong class="source-inline">k</strong>, and <span class="No-Break"><strong class="source-inline">w</strong></span><span class="No-Break">, respectively.</span></p>
			<p>In the recipe, we saw three examples of these format strings: the single <strong class="source-inline">k</strong> format string only changed the color of the line and kept the other settings at default (small point markers and unbroken blue line); the <strong class="source-inline">k--</strong> and <strong class="source-inline">k.-</strong> format strings both changed the color and the line style. For an example of changing the point style, see the <em class="italic">There’s more...</em> section and <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer229">
					<img alt="Figure 2.2 - Plot of three sets of data, each plotted using a different marker style&#13;&#10;" src="image/B19085_02_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 - Plot of three sets of data, each plotted using a different marker style</p>
			<p>The <strong class="source-inline">set_title</strong>, <strong class="source-inline">set_xlabel</strong>, and <strong class="source-inline">set_ylabel</strong> methods simply add the text argument to the corresponding position of the <strong class="source-inline">Axes</strong> object. The <strong class="source-inline">legend</strong> method, as called in the<a id="_idIndexMarker138"/> preceding code, adds the labels to the datasets in the order that they were added to the plot—in this case, <strong class="source-inline">y1</strong>, <strong class="source-inline">y2</strong>, and <span class="No-Break">then </span><span class="No-Break"><strong class="source-inline">y3</strong></span><span class="No-Break">.</span></p>
			<p>There are a<a id="_idIndexMarker139"/> number of keyword arguments that can be supplied to the <strong class="source-inline">set_title</strong>, <strong class="source-inline">set_xlabel</strong>, and <strong class="source-inline">set_ylabel</strong> routines to control the style of the text. For example, the <strong class="source-inline">fontsize</strong> keyword can be used to specify the size of the label font in the usual <strong class="source-inline">pt</strong> <span class="No-Break">point measure.</span></p>
			<p>The <strong class="source-inline">annotate</strong> method on the <strong class="source-inline">Axes</strong> object adds arbitrary text to a specific position on the plot. This routine takes two arguments—the text to display as a string and the coordinates of the point at which the annotation should be placed. This routine also accepts keyword arguments that can be used to customize the style of <span class="No-Break">the annotation.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>There’s more…</h2>
			<p>The <strong class="source-inline">plt.plot</strong> routine accepts a variable number of positional inputs. In the preceding code, we supplied two positional arguments that were interpreted as <strong class="source-inline">x</strong> values and <strong class="source-inline">y</strong> values (in that order). If we had instead provided only a single array, the <strong class="source-inline">plot</strong> routine would have plotted the values against their position in the array; that is, the <strong class="source-inline">x</strong> values are taken to be <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <span class="No-Break">so on.</span></p>
			<p>The <strong class="source-inline">plot</strong> method<a id="_idIndexMarker140"/> also accepts a number of keyword arguments that can also be used to control the style of a plot. Keyword arguments take precedence <a id="_idIndexMarker141"/>over format string parameters if both are present, and they apply to all sets of data plotted by the call. The keyword to control the marker style is <strong class="source-inline">marker</strong>, the keyword for the line style is <strong class="source-inline">linestyle</strong>, and the keyword for color is <strong class="source-inline">color</strong>. The <strong class="source-inline">color</strong> keyword argument accepts a number of different formats to specify a color, which includes RGB values as a <strong class="source-inline">(r, g, b)</strong> tuple, where each character is a float between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> or is a hex string. The width of the line plotted can be controlled using the <strong class="source-inline">linewidth</strong> keyword, which should be provided with a <strong class="source-inline">float</strong> value. Many other keyword arguments can be passed to <strong class="source-inline">plot</strong>; a list is given in the Matplotlib documentation. Many of these keyword arguments have a shorter version, such as <strong class="source-inline">c</strong> for <strong class="source-inline">color</strong> and <strong class="source-inline">lw</strong> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">linewidth</strong></span><span class="No-Break">.</span></p>
			<p>In the this recipe, we plotted a large number of coordinates generated by evaluating functions on a selection of <img alt="" src="image/Formula_02_017.png"/> values. In other applications, one might have data sampled from the real world (as opposed to generated). In these situations, it might be better to leave out the connecting lines and simply plot the markers at the points. Here is an example of how this might <span class="No-Break">be done:</span></p>
			<pre class="source-code">
y1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
y2 = np.array([1.2, 1.6, 3.1, 4.2, 4.8])
y3 = np.array([3.2, 1.1, 2.0, 4.9, 2.5])
fig, ax = plt.subplots()
ax.plot(y1, 'o', y2, 'x', y3, '*', color="k")</pre>
			<p>The result of these commands is shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>. Matplotlib has a specialized method for producing scatter plots such as this, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">scatter</strong></span><span class="No-Break">.</span></p>
			<p>Other aspects of the plot can be customized by using methods on the <strong class="source-inline">Axes</strong> object. The axes ticks can be modified using the <strong class="source-inline">set_xticks</strong> and <strong class="source-inline">set_yticks</strong> methods on the <strong class="source-inline">Axes</strong> object, and the grid appearance can be configured using the <strong class="source-inline">grid</strong> method. There are also convenient methods in the <strong class="source-inline">pyplot</strong> interface that apply these modifications to the current axes (if <span class="No-Break">they exist).</span></p>
			<p>For example, we modify the axis limits, set the ticks at every multiple of <strong class="source-inline">0.5</strong> in both the <img alt="" src="image/Formula_02_006.png"/> and <img alt="" src="image/Formula_02_008.png"/> direction, and add a grid to the plot by using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
ax.axis([-0.5, 5.5, 0, 5.5]) # set axes
ax.set_xticks([0.5*i for i in range(9)])  # set xticks
ax.set_yticks([0.5*i for i in range(11)]) # set yticks
ax.grid()  # add a grid</pre>
			<p>Notice how <a id="_idIndexMarker142"/>we set the limits slightly larger than the extent of the plot. This is to avoid markers being placed on the boundary of the <span class="No-Break">plot window.</span></p>
			<p>Matplotlib <a id="_idIndexMarker143"/>has many other plotting routines besides the <strong class="source-inline">plot</strong> routine described here. For example, there are plotting methods that use a different scale for the axes, including the logarithmic <img alt="" src="image/Formula_02_009.png"/> or <img alt="" src="image/Formula_02_010.png"/> axes separately (<strong class="source-inline">semilogx</strong> or <strong class="source-inline">semilogy</strong>, respectively) or together (<strong class="source-inline">loglog</strong>). These are explained in the Matplotlib documentation. The <strong class="source-inline">scatter</strong> plotting routine may be useful if you wish to plot discrete data on axes without connecting the points with a line. This allows more control over the style of the marker. For example, you can scale the marker according to some <span class="No-Break">additional information.</span></p>
			<p>We can use a different font by using the <strong class="source-inline">fontfamily</strong> keyword, the value of which can be the name of a font or <strong class="source-inline">serif</strong>, <strong class="source-inline">sans-serif</strong>, or <strong class="source-inline">monospace</strong>, which will choose the appropriate built-in font. A complete list of modifiers can be found in the Matplotlib documentation for the <span class="No-Break"><strong class="source-inline">matplotlib.text.Text</strong></span><span class="No-Break"> class.</span></p>
			<p>Text arguments can also be rendered using TeX for additional formatting by supplying <strong class="source-inline">usetex=True</strong> to the routine. We’ll demonstrate the use of TeX formatting of labels in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.3</em> in the following recipe. This is especially useful if the title or axis label contains a mathematical formula. Unfortunately, the <strong class="source-inline">usetex</strong> keyword argument cannot be used if TeX is not installed on the system—it will cause an error in this case. However, it is still possible to use the TeX syntax for formatting mathematical text within labels, but this will be typeset by Matplotlib, rather than <span class="No-Break">by TeX.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Adding subplots</h1>
			<p>Occasionally, it is useful to place multiple related plots within the same figure side by side but not on the same axes. Subplots <a id="_idIndexMarker144"/>allow us to produce a grid of individual plots within a single figure. In this recipe, we will see how to create two plots side by side on a single figure <span class="No-Break">using subplots.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Getting ready</h2>
			<p>You will need <a id="_idIndexMarker145"/>the data to be plotted on each subplot. As an example, we will plot the first five iterates of Newton’s method applied to the <img alt="" src="image/Formula_02_011.png"/> function with an initial value of <img alt="" src="image/Formula_02_012.png"/> on the first subplot, and for the second, we will plot the error of the iterate. We first define a generator function to get <span class="No-Break">the iterates:</span></p>
			<pre class="source-code">
def generate_newton_iters(x0, number):
  iterates = [x0]
  errors = [abs(x0 - 1.)]
  for _ in range(number):
       x0 = x0 - (x0*x0 - 1.)/(2*x0)
       iterates.append(x0)
       errors.append(abs(x0 - 1.))
    return iterates, errors</pre>
			<p>This routine generates two lists. The first list contains iterates of Newton’s method applied to the function, and the second contains the error in <span class="No-Break">the approximation:</span></p>
			<pre class="source-code">
iterates, errors = generate_newton_iters(2.0, 5)</pre>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>How to do it...</h2>
			<p>The following steps show how to create a figure that contains <span class="No-Break">multiple subplots:</span></p>
			<ol>
				<li value="1">We use the <strong class="source-inline">subplots</strong> routine to create a new figure and references to all of the <strong class="source-inline">Axes</strong> objects in each subplot, arranged in a grid with one row and two columns. We also set the <strong class="source-inline">tight_layout</strong> keyword argument to <strong class="source-inline">True</strong> to fix the layout of the resulting plots. This isn’t strictly necessary, but it is in this case as it produces a better result than <span class="No-Break">the default:</span><pre class="console">
fig, (ax1, ax2) = plt.subplots(1, 2, </pre><pre class="console">
tight_layout=True) </pre><pre class="console">
#1 row, 2 columns</pre></li>
				<li>Once <strong class="source-inline">Figure</strong> and <strong class="source-inline">Axes</strong> objects are created, we can populate the figure by calling <a id="_idIndexMarker146"/>the relevant plotting method on each <strong class="source-inline">Axes</strong> object. For the first plot (displayed on the left), we use the <strong class="source-inline">plot</strong> method on the <strong class="source-inline">ax1</strong> object, which has the same signature as the standard <strong class="source-inline">plt.plot</strong> routine. We can then call the <strong class="source-inline">set_title</strong>, <strong class="source-inline">set_xlabel</strong>, and <strong class="source-inline">set_ylabel</strong> methods on <strong class="source-inline">ax1</strong> to set the title and the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> labels. We also use TeX formatting for the axes labels by providing the <strong class="source-inline">usetex</strong> keyword argument; you can ignore this if you don’t have TeX installed on <span class="No-Break">your system:</span><pre class="console">
ax1.plot(iterates, "kx")</pre><pre class="console">
ax1.set_title("Iterates")</pre><pre class="console">
ax1.set_xlabel("$i$", usetex=True)</pre><pre class="console">
ax1.set_ylabel("$x_i$", usetex=True)</pre></li>
				<li>Now, we can plot the error values on the second plot (displayed on the right) using the <strong class="source-inline">ax2</strong> object. We use an alternative plotting method that uses a logarithmic scale on the <img alt="" src="image/Formula_02_014.png"/> axis, called <strong class="source-inline">semilogy</strong>. The signature for this method is the same as the standard <strong class="source-inline">plot</strong> method. Again, we set the axes labels and the title. Again, the use of <strong class="source-inline">usetex</strong> can be left out if you don’t have <span class="No-Break">TeX installed:</span><pre class="console">
ax2.semilogy(errors, "kx") # plot y on logarithmic scale</pre><pre class="console">
ax2.set_title("Error")</pre><pre class="console">
ax2.set_xlabel("$i$", usetex=True)</pre><pre class="console">
ax2.set_ylabel("Error")</pre></li>
			</ol>
			<p>The result of this sequence of commands is <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer238">
					<img alt="Figure 2.3 - Multiple subplots on the same Matplotlib figure&#13;&#10;" src="image/B19085_02_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 - Multiple subplots on the same Matplotlib figure</p>
			<p>The left-hand side<a id="_idIndexMarker147"/> plots the first five iterates of Newton’s method, and the right-hand side is the approximation error plotted on a <span class="No-Break">logarithmic scale.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>How it works...</h2>
			<p>A <strong class="source-inline">Figure</strong> object in Matplotlib is simply a container for plot elements, such as <strong class="source-inline">Axes</strong>, of a certain size. A <strong class="source-inline">Figure</strong> object will usually only hold a single <strong class="source-inline">Axes</strong> object, which occupies the entire figure area, but it can contain any number of <strong class="source-inline">Axes</strong> objects in the same area. The <strong class="source-inline">subplots</strong> routine does several things. It first creates a new figure and then creates a grid with the specified shape in the figure area. Then, a new <strong class="source-inline">Axes</strong> object is added to each position of the grid. The new <strong class="source-inline">Figure</strong> object and one or more <strong class="source-inline">Axes</strong> objects are then returned to the user. If a single subplot is requested (one row and one column, with no arguments) then a plain <strong class="source-inline">Axes</strong> object is returned. If a single row or column is requested (with more than one column or row, respectively), then a list of <strong class="source-inline">Axes</strong> objects is returned. If more than one row and column are requested, a list of lists, with rows represented by inner lists filled with <strong class="source-inline">Axes</strong> objects, will be returned. We can then use the plotting methods on each of the <strong class="source-inline">Axes</strong> objects to populate the figure with the <span class="No-Break">desired plots.</span></p>
			<p>In this recipe, we <a id="_idIndexMarker148"/>used the standard <strong class="source-inline">plot</strong> method for the left-hand side plot, as we have seen in previous recipes. However, for the right-hand side plot, we used a plot where the <img alt="" src="image/Formula_02_015.png"/> axis had been changed to a logarithmic scale. This means that each unit on the <img alt="" src="image/Formula_02_015.png"/> axis represents a change of a power of 10 rather than a change of one unit so that <strong class="source-inline">0</strong> represents <img alt="" src="image/Formula_02_016.png"/>, <strong class="source-inline">1</strong> represents 10, <strong class="source-inline">2</strong> represents 100, and so on. The axes labels are automatically changed to reflect this change in scale. This type of scaling is useful when the values change by an order of magnitude, such as the error in an approximation, as we use more and more iterations. We can also plot with a logarithmic scale for <img alt="" src="image/Formula_02_017.png"/> only by using the <strong class="source-inline">semilogx</strong> method, or both axes on a logarithmic scale by using the <span class="No-Break"><strong class="source-inline">loglog</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>There’s more...</h2>
			<p>There are several ways to create subplots in Matplotlib. If you have already created a <strong class="source-inline">Figure</strong> object, then subplots can be added using the <strong class="source-inline">add_subplot</strong> method of the <strong class="source-inline">Figure</strong> object. Alternatively, you can use the <strong class="source-inline">subplot</strong> routine from <strong class="source-inline">matplotlib.pyplot</strong> to add subplots to the current figure. If one does not yet exist, it will be created when this routine is called. The <strong class="source-inline">subplot</strong> routine is a convenience wrapper of the <strong class="source-inline">add_subplot</strong> method on the <span class="No-Break"><strong class="source-inline">Figure</strong></span><span class="No-Break"> object.</span></p>
			<p>In the preceding example, we created two plots with differently scaled <img alt="" src="image/Formula_02_018.png"/> axes. This demonstrates one of the many possible uses of subplots. Another common use is for plotting data in a matrix where columns have a common <strong class="source-inline">x</strong> label and rows have a common <strong class="source-inline">y</strong> label, which is especially common in multivariate statistics when investigating the correlation between various sets of data. The <strong class="source-inline">plt.subplots</strong> routine for creating subplots accepts the <strong class="source-inline">sharex</strong> and <strong class="source-inline">sharey</strong> keyword parameters, which allows the axes to be shared among all subplots or among a row or column. This setting affects the scale and ticks of <span class="No-Break">the axes.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>See also</h2>
			<p>Matplotlib supports more advanced layouts by providing the <strong class="source-inline">gridspec_kw</strong> keyword arguments to the <strong class="source-inline">subplots</strong> routine. See the documentation for <strong class="source-inline">matplotlib.gridspec</strong> for <span class="No-Break">more information.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Plotting with error bars</h1>
			<p>It is quite<a id="_idIndexMarker149"/> common that the values that we gather from the real world carry some uncertainty; no measurement of a real-world quantity is perfectly accurate. For <a id="_idIndexMarker150"/>example, if we measure a distance with a tape measure, there is a certain amount of accuracy that we can assume in our results, but beyond this accuracy, we cannot be sure that our measurement is valid. For such a situation, we can probably be confident of our accuracy up to about 1 millimeter or a little less than 1/16 inch. (This is, of course, assuming that we are measuring perfectly.) These values are the smallest subdivisions on typical tape measures. Let’s assume that we have collected such a set of 10 measurements (in centimeters) and we wish to plot these values along with the accuracy that we are confident about. (The range of values that lie above or below the measurement by the accuracy amount is called the <em class="italic">error</em>.) This is what we address in <span class="No-Break">this recipe.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Getting ready</h2>
			<p>As usual, we have the Matplotlib <strong class="source-inline">pyplot</strong> interface imported under the alias <strong class="source-inline">plt</strong>. We first need to generate our hypothetical data and the assumed accuracy in <span class="No-Break">NumPy arrays:</span></p>
			<pre class="source-code">
measurement_id = np.arange(1, 11)
measurements = np.array([2.3, 1.9, 4.4, 1.5, 3.0, 3.3, 2.9,    2.6, 4.1, 3.6]) # cm
err = np.array([0.1]*10)  # 1mm</pre>
			<p>Let’s see how to use plotting routines in Matplotlib to plot these measurements with error bars to indicate the uncertainty in <span class="No-Break">each measurement.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>How to do it…</h2>
			<p>The following steps show how to plot measurements along with accuracy information on <span class="No-Break">a figure.</span></p>
			<p>First, we<a id="_idIndexMarker151"/> need to generate a new <strong class="source-inline">figure</strong> and <strong class="source-inline">axis</strong> object <span class="No-Break">as usual:</span></p>
			<pre class="source-code">
fig, ax = plt.subplots()</pre>
			<p>Next, we <a id="_idIndexMarker152"/>use the <strong class="source-inline">errorbar</strong> method on the axis object to plot the data along with the error bars. The accuracy information (the error) is passed as the <span class="No-Break"><strong class="source-inline">yerr</strong></span><span class="No-Break"> argument:</span></p>
			<pre class="source-code">
ax.errorbar(measurement_id,
    measurements, yerr=err, fmt="kx", 
     capsize=2.0)</pre>
			<p>As usual, we should always add meaningful labels to the axes and a title to <span class="No-Break">the plot:</span></p>
			<pre class="source-code">
ax.set_title("Plot of measurements and their estimated error")
ax.set_xlabel("Measurement ID")
ax.set_ylabel("Measurement(cm)")</pre>
			<p>Since Matplotlib will not produce <strong class="source-inline">xlabel</strong> ticks at every value by default, we set the x-tick values to the measurement IDs so that they are all displayed on <span class="No-Break">the plot:</span></p>
			<pre class="source-code">
ax.set_xticks(measurement_id)</pre>
			<p>The resulting plot is shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em>. The recorded value is shown at the <strong class="source-inline">x</strong> markers, and the error bar extends above and below that value by an accuracy of 0.1 cm (<span class="No-Break">1 mm):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer244">
					<img alt="Figure 2.4 - Plot of a set of 10 sample measurements (in centimeters) with their measurement error shown&#13;&#10;" src="image/B19085_02_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 - Plot of a set of 10 sample measurements (in centimeters) with their measurement error shown</p>
			<p>We can see <a id="_idIndexMarker153"/>here that each of the markers has a vertical bar that <a id="_idIndexMarker154"/>indicates the range in which we expect the true measurement (<img alt="" src="image/Formula_02_019.png"/>-value) <span class="No-Break">to lie.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>How it works…</h2>
			<p>The <strong class="source-inline">errorbar</strong> method works in a similar way to other plotting methods. The first two arguments are the <img alt="" src="image/Formula_02_020.png"/> and <img alt="" src="image/Formula_02_021.png"/> coordinates of the points to be plotted. (Note that both must be provided, which is not the case for other plotting methods.) The <strong class="source-inline">yerr</strong> argument indicates the size of the error bars to be added to the plot and should all be positive values. The form of the value(s) passed to this argument determines the nature of the error bars. In the recipe, we provided a flat NumPy array with 10 entries—one for each measurement—which leads to error bars above and below each point with the same size (the corresponding value from the argument). Alternatively, we could have specified a 2-by-10 array, where the first row contains the lower error and the second row contains the upper error. (Since all our errors are the same, we could also have provided a single float containing the common error for <span class="No-Break">all measurements.)</span></p>
			<p>In addition <a id="_idIndexMarker155"/>to the data arguments, there are the usual format arguments, including the <strong class="source-inline">fmt</strong> format string. (We used this here as a keyword argument because <a id="_idIndexMarker156"/>we named the <strong class="source-inline">yerr</strong> argument that precedes it.) In addition to the formatting of lines and points found in other plotting methods, there are special arguments for customizing the look of error bars. In the recipe, we used the <strong class="source-inline">capsize</strong> argument to add “caps” to either end of the error bars so that we could easily identify the ends of those bars; the default style is a <span class="No-Break">simple line.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>There’s more...</h2>
			<p>In the recipe, we only plotted errors in the <img alt="" src="image/Formula_02_022.png"/> axis because the <img alt="" src="image/Formula_02_023.png"/> values were simply ID values. If both sets of values have uncertainty, you can also specify the <img alt="" src="image/Formula_02_024.png"/> error values using the <strong class="source-inline">xerr</strong> argument. This argument functions in the same way as the <strong class="source-inline">yerr</strong> argument <span class="No-Break">used previously.</span></p>
			<p>If you are plotting a very large number of points that follow some kind of trend, you might wish to plot error bars more selectively. For this, you can use the <strong class="source-inline">errorevery</strong> keyword argument to instruct Matplotlib to add error bars at every <strong class="source-inline">n</strong>th data point rather than at all of them. This can be either a positive integer—indicating the “stride” to use to select points that will have errors—or a tuple containing an offset from the first value and a stride. For example, <strong class="source-inline">errorevery=(2, 5)</strong> would place error bars every five data points, starting from the <span class="No-Break">second entry.</span></p>
			<p>You can also add error bars to bar charts in the same way (except here, the <strong class="source-inline">xerr</strong> and <strong class="source-inline">yerr</strong> arguments are keywords only). We could have plotted the data from the recipe as a bar chart using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
ax.bar(measurement_id, measurements, 
yerr=err, capsize=2.0, alpha=0.4)</pre>
			<p>If this line is used instead of the call to <strong class="source-inline">errorbar</strong> in the recipe, then we would get a bar chart, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer251">
					<img alt="Figure 2.5 - Bar chart of measurements with error bars&#13;&#10;" src="image/B19085_02_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 - Bar chart of measurements with error bars</p>
			<p>As before, the <a id="_idIndexMarker157"/>measurement bar is capped with an indicator of the <img alt="" src="image/Formula_02_025.png"/> range <a id="_idIndexMarker158"/>in which we expect the true measurement <span class="No-Break">to lie.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Saving Matplotlib figures</h1>
			<p>When you work in<a id="_idIndexMarker159"/> an interactive environment, such as an IPython console or a Jupyter notebook, displaying a figure at runtime is perfectly normal. However, there are plenty of situations where it would be more appropriate to store a figure directly to a file, rather than rendering it on screen. In this recipe, we will see how to save a<a id="_idIndexMarker160"/> figure directly to a file, rather than displaying it <span class="No-Break">on screen.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Getting ready</h2>
			<p>You will need the data to be plotted and the path or file object in which you wish to store the output. We store the result in <strong class="source-inline">savingfigs.png</strong> in the current directory. In this example, we will plot the <span class="No-Break">following data:</span></p>
			<pre class="source-code">
x = np.arange(1, 5, 0.1)
y = x*x</pre>
			<p>Let’s see <a id="_idIndexMarker161"/>how to plot this curve using Matplotlib and save the resulting plot <a id="_idIndexMarker162"/>to a file (without needing to interact with the <span class="No-Break">plot GUI).</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>How to do it...</h2>
			<p>The following steps show how to save a Matplotlib plot directly to <span class="No-Break">a file:</span></p>
			<ol>
				<li value="1">The first step is to create a figure, as usual, and add any labels, titles, and annotations that are necessary. The figure will be written to the file in its current state, so any changes to the figure should be made <span class="No-Break">before saving:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
ax.plot(x, y)</pre><pre class="console">
ax.set_title("Graph of $y = x^2$", usetex=True)</pre><pre class="console">
ax.set_xlabel("$x$", usetex=True)</pre><pre class="console">
ax.set_ylabel("$y$", usetex=True)</pre></li>
				<li>Then, we use the <strong class="source-inline">savefig</strong> method on <strong class="source-inline">fig</strong> to save this figure to a file. The only required argument is the path to output to or a file-like object that the figure can be written to. We can adjust various settings for the output format, such as the resolution, by providing the appropriate keyword arguments. We’ll set <a id="_idIndexMarker163"/>the <strong class="bold">Dots per Inch</strong> (<strong class="bold">DPI</strong>) of the output figure to <strong class="source-inline">300</strong>, which is a reasonable resolution for <span class="No-Break">most applications:</span><pre class="console">
fig.savefig("savingfigs.png", dpi=300)</pre></li>
			</ol>
			<p>Matplotlib will infer that we wish to save the image in the <strong class="bold">Portable Network Graphics</strong> (<strong class="bold">PNG</strong>) format <a id="_idIndexMarker164"/>from the extension of the file given. Alternatively, a format can be explicitly provided as a keyword argument (by using the <strong class="source-inline">format</strong> keyword), or it will fall back to the default from the <span class="No-Break">configuration file.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>How it works...</h2>
			<p>The <strong class="source-inline">savefig</strong> method<a id="_idIndexMarker165"/> chooses the appropriate backend <a id="_idIndexMarker166"/>for the output <a id="_idIndexMarker167"/>format and then renders the current figure in that format. The resulting image data is written to the specified path or file-like object. If you have manually created a <strong class="source-inline">Figure</strong> instance, the same effect can be achieved by calling the <strong class="source-inline">savefig</strong> method on <span class="No-Break">that instance.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>There’s more...</h2>
			<p>The <strong class="source-inline">savefig</strong> routine takes a number of additional optional keyword arguments to customize the output image. For example, the resolution of the image can be specified using the <strong class="source-inline">dpi</strong> keyword. The plots in this chapter have been produced by saving the Matplotlib figures to <span class="No-Break">the file.</span></p>
			<p>The output formats available include <a id="_idIndexMarker168"/>PNG, <strong class="bold">Scalable Vector Graphics</strong> (<strong class="bold">SVG</strong>), <strong class="bold">PostScript</strong> (<strong class="bold">PS</strong>), <strong class="bold">Encapsulated PostScript</strong> (<strong class="bold">EPS</strong>), and <strong class="bold">Portable Document Format</strong> (<strong class="bold">PDF</strong>). You <a id="_idIndexMarker169"/>can<a id="_idIndexMarker170"/> also<a id="_idIndexMarker171"/> save to JPEG format if the Pillow package is installed, but Matplotlib does not support this natively since version 3.1. There are additional customization keyword arguments for JPEG images, such as <strong class="source-inline">quality</strong> and <strong class="source-inline">optimize</strong>. A dictionary of image metadata can be passed to the <strong class="source-inline">metadata</strong> keyword, which will be written as image metadata <span class="No-Break">when saving.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>See also</h2>
			<p>The examples gallery on the Matplotlib website includes examples of embedding Matplotlib figures into a GUI application using several common Python <span class="No-Break">GUI frameworks.</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Surface and contour plots</h1>
			<p>Matplotlib <a id="_idIndexMarker172"/>can also plot three-dimensional data in a variety of ways. Two common choices for displaying data such as this are using <strong class="bold">surface plots</strong> or <strong class="bold">contour plots</strong> (think of contour lines on a map). In<a id="_idIndexMarker173"/> this recipe, we will see a method for plotting surfaces from three-dimensional data and how to plot contours of <span class="No-Break">three-dimensional data.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Getting ready</h2>
			<p>To <a id="_idIndexMarker174"/>plot three-dimensional data, it <a id="_idIndexMarker175"/>needs to be arranged into two-dimensional arrays for the <img alt="" src="image/Formula_02_026.png"/>, <img alt="" src="image/Formula_02_027.png"/>, and <img alt="" src="image/Formula_02_028.png"/> components, where both the <img alt="" src="image/Formula_02_029.png"/> and <img alt="" src="image/Formula_02_030.png"/> components must be of the same shape as the <img alt="" src="image/Formula_02_031.png"/> component. For the sake of this demonstration, we will plot the surface corresponding to the <span class="No-Break">following function:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer259">
					<img alt="" src="image/Formula_02_032.jpg"/>
				</div>
			</div>
			<p>For 3D data, we can’t just use the routines from the <strong class="source-inline">pyplot</strong> interface. We need to import some extra functionality from another part of Matplotlib. We’ll see how to do <span class="No-Break">this next.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>How to do it...</h2>
			<p>We want to plot the function <img alt="" src="image/Formula_02_033.png"/> on the <img alt="" src="image/Formula_02_034.png"/> and <img alt="" src="image/Formula_02_035.png"/> range. The first task is to create a suitable grid of <img alt="" src="image/Formula_02_036.png"/> pairs on which to evaluate <span class="No-Break">this function:</span></p>
			<ol>
				<li value="1">We first use <strong class="source-inline">np.linspace</strong> to generate a reasonable number of points in <span class="No-Break">these ranges:</span><pre class="console">
X = np.linspace(-5, 5)</pre><pre class="console">
Y = np.linspace(-5, 5)</pre></li>
				<li>Now, we need to create a grid on which to create our <img alt="" src="image/Formula_02_037.png"/> values. For this, we use the <span class="No-Break"><strong class="source-inline">np.meshgrid</strong></span><span class="No-Break"> </span><span class="No-Break">routine:</span><pre class="console">
grid_x, grid_y = np.meshgrid(X, Y)</pre></li>
				<li>Now, we can create <img alt="" src="image/Formula_02_038.png"/> values to plot, which hold the value of the function at each of the <span class="No-Break">grid points:</span><pre class="console">
z = np.exp(-((grid_x-2.)**2 + (</pre><pre class="console">
    grid_y-3.)**2)/4) -  np.exp(-(</pre><pre class="console">
    (grid_x+3.)**2 + (grid_y+2.)**2)/3)</pre></li>
				<li>To <a id="_idIndexMarker176"/>plot three-dimensional surfaces, we need to load a Matplotlib toolbox, <strong class="source-inline">mplot3d</strong>, which comes with the Matplotlib package. This won’t be used explicitly in the code, but behind the scenes, it makes the three-dimensional plotting utilities available <span class="No-Break">to Matplotlib:</span><pre class="console">
from mpl_toolkits import mplot3d</pre></li>
				<li>Next, we create a new figure and a set of three-dimensional axes for <span class="No-Break">the figure:</span><pre class="console">
fig = plt.figure()</pre><pre class="console">
# declare 3d plot</pre><pre class="console">
ax = fig.add_subplot(projection="3d")</pre></li>
				<li>Now, we can call the <strong class="source-inline">plot_surface</strong> method on these axes to plot the data (we set the colormap to gray for better visibility in print; see the next recipe for a more <span class="No-Break">detailed discussion):</span><pre class="console">
ax.plot_surface(grid_x, grid_y, z, cmap="gray")</pre></li>
				<li>It is extra important to add axis labels to three-dimensional plots because it might not be clear which axis is which on the displayed plot. We also set the title at <span class="No-Break">this point:</span><pre class="console">
ax.set_xlabel("x")</pre><pre class="console">
ax.set_ylabel("y")</pre><pre class="console">
ax.set_zlabel("z")</pre><pre class="console">
ax.set_title("Graph of the function f(x, y)")</pre></li>
			</ol>
			<p>You can use the <strong class="source-inline">plt.show</strong> routine to display the figure in a new window (if you are using Python interactively and not in a Jupyter notebook or on an IPython console) or <strong class="source-inline">plt.savefig</strong> to save the figure to a file. The result of the preceding sequence is <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer266">
					<img alt="Figure 2.6 - A three-dimensional surface plot produced with Matplotlib&#13;&#10;" src="image/B19085_02_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 - A three-dimensional surface plot produced with Matplotlib</p>
			<ol>
				<li value="8">Contour plots<a id="_idIndexMarker177"/> do not require the <strong class="source-inline">mplot3d</strong> toolkit, and there is a <strong class="source-inline">contour</strong> routine in the <strong class="source-inline">pyplot</strong> interface that produces contour plots. However, unlike the usual (two-dimensional) plotting routines, the <strong class="source-inline">contour</strong> routine requires the same arguments as the <strong class="source-inline">plot_surface</strong> method. We use the following sequence to produce <span class="No-Break">a plot:</span><pre class="console">
fig = plt.figure()  # Force a new figure</pre><pre class="console">
plt.contour(grid_x, grid_y, z, cmap="gray")</pre><pre class="console">
plt.title("Contours of f(x, y)")</pre><pre class="console">
plt.xlabel("x")</pre><pre class="console">
plt.ylabel("y")</pre></li>
			</ol>
			<p>The result is shown in the <span class="No-Break">following plot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer267">
					<img alt="Figure 2.7 - Contour plot produced using Matplotlib with the default settings&#13;&#10;" src="image/B19085_02_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 - Contour plot produced using Matplotlib with the default settings</p>
			<p>The peak <a id="_idIndexMarker178"/>and basin of the function are shown clearly here by the rings of concentric circles. In the top right, the shading is lighter, indicating that the function is increasing, and in the bottom left, the shade is darker, indicating that the function is decreasing. The curve that separates the regions in which the function is increasing and decreasing is shown <span class="No-Break">between them.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>How it works...</h2>
			<p>The <strong class="source-inline">mplot3d</strong> toolkit<a id="_idIndexMarker179"/> provides an <strong class="source-inline">Axes3D</strong> object, which is a three-dimensional version of the <strong class="source-inline">Axes</strong> object in the core Matplotlib package. This is made available to the <strong class="source-inline">axes</strong> method on a <strong class="source-inline">Figure</strong> object when the <strong class="source-inline">projection="3d"</strong> keyword argument is given. A surface plot is obtained by drawing quadrilaterals in the three-dimensional projection between nearby points in the same way that a two-dimensional curve is approximated by straight lines joining <span class="No-Break">adjacent points.</span></p>
			<p>The <strong class="source-inline">plot_surface</strong> method needs the <img alt="" src="image/Formula_02_039.png"/> values to be provided as a two-dimensional array that encodes the <img alt="" src="image/Formula_02_040.png"/> values on a grid of <img alt="" src="image/Formula_02_041.png"/> pairs. We created a range of <img alt="" src="image/Formula_02_042.png"/> and <img alt="" src="image/Formula_02_043.png"/> values that we are interested in, but if we simply evaluate our function on the pairs of corresponding values from these arrays, we will get the <img alt="" src="image/Formula_02_044.png"/> values along a line and not over a grid. Instead, we use the <strong class="source-inline">meshgrid</strong> routine, which takes the two <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong> arrays and creates from them a grid consisting of all the possible combinations of values in <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong>. The output is a pair of two-dimensional arrays on which we can evaluate our function. We can then provide all three of these two-dimensional arrays to the <span class="No-Break"><strong class="source-inline">plot_surface</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>There’s more...</h2>
			<p>The routines described<a id="_idIndexMarker180"/> in the preceding section, <strong class="source-inline">contour</strong> and <strong class="source-inline">plot_surface</strong>, only work with highly structured data where the <img alt="" src="image/Formula_02_045.png"/>, <img alt="" src="image/Formula_02_046.png"/>, and <img alt="" src="image/Formula_02_047.png"/> components are <a id="_idIndexMarker181"/>arranged into grids. Unfortunately, real-life data is rarely so structured. In this case, you need to perform some kind of interpolation between known points to approximate the value on a uniform grid, which can then be plotted. A common method for performing this interpolation is by triangulating the collection of <img alt="" src="image/Formula_02_048.png"/> pairs and then using the values of the function on the vertices of each triangle to estimate the value on the grid points. Fortunately, Matplotlib has a method that does all of these steps and then plots the result, which is the <strong class="source-inline">plot_trisurf</strong> routine. We briefly explain how this can be <span class="No-Break">used here:</span></p>
			<ol>
				<li value="1">To illustrate the use of <strong class="source-inline">plot_trisurf</strong>, we will plot a surface and contours from the <span class="No-Break">following data:</span><pre class="console">
x = np.array([ 0.19, -0.82, 0.8 , 0.95, 0.46, 0.71,</pre><pre class="console">
      -0.86, -0.55,   0.75,-0.98, 0.55, -0.17, -0.89,</pre><pre class="console">
            -0.4 , 0.48, -0.09, 1., -0.03, -0.87, -0.43])</pre><pre class="console">
y = np.array([-0.25, -0.71, -0.88, 0.55, -0.88, 0.23,</pre><pre class="console">
        0.18,-0.06, 0.95, 0.04, -0.59, -0.21, 0.14, 0.94,</pre><pre class="console">
              0.51, 0.47, 0.79, 0.33, -0.85, 0.19])</pre><pre class="console">
z = np.array([-0.04, 0.44, -0.53, 0.4, -0.31,</pre><pre class="console">
    0.13,-0.12, 0.03, 0.53, -0.03, -0.25, 0.03, </pre><pre class="console">
    -0.1 ,-0.29, 0.19, -0.03, 0.58, -0.01, 0.55, </pre><pre class="console">
    -0.06])</pre></li>
				<li>This time, we will plot both the surface and contour (approximations) on the same figure as two separate subplots. For this, we supply the <strong class="source-inline">projection="3d"</strong> keyword argument to the subplot that will contain the surface. We use the <strong class="source-inline">plot_trisurf</strong> method on the three-dimensional axes to plot the approximated surface, and the <strong class="source-inline">tricontour</strong> method on the two-dimensional axes to <a id="_idIndexMarker182"/>plot the <span class="No-Break">approximated contours:</span><pre class="console">
fig = plt.figure(tight_layout=True)  # force new figure</pre><pre class="console">
ax1 = fig.add_subplot(1, 2, 1, projection="3d")  # 3d axes</pre><pre class="console">
ax1.plot_trisurf(x, y, z)</pre><pre class="console">
ax1.set_xlabel("x")</pre><pre class="console">
ax1.set_ylabel("y")</pre><pre class="console">
ax1.set_zlabel("z")</pre><pre class="console">
ax1.set_title("Approximate surface")</pre></li>
				<li>We can<a id="_idIndexMarker183"/> now plot the contours for the triangulated surface using the <span class="No-Break">following command:</span><pre class="console">
ax2 = fig.add_subplot(1, 2, 2)  # 2d axes</pre><pre class="console">
ax2.tricontour(x, y, z)</pre><pre class="console">
ax2.set_xlabel("x")</pre><pre class="console">
ax2.set_ylabel("y")</pre><pre class="console">
ax2.set_title("Approximate contours")</pre></li>
			</ol>
			<p>We include the <strong class="source-inline">tight_layout=True</strong> keyword argument with the figure to save a call to the <strong class="source-inline">plt.tight_layout</strong> routine later. The result is <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer278">
					<img alt="Figure 2.8 - Approximate surface and contour plots generated from unstructured data using triangulation&#13;&#10;" src="image/B19085_02_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 - Approximate surface and contour plots generated from unstructured data using triangulation</p>
			<p>In addition to <a id="_idIndexMarker184"/>surface plotting routines, the <strong class="source-inline">Axes3D</strong> object has a <strong class="source-inline">plot</strong> (or <strong class="source-inline">plot3D</strong>) routine for simple three-dimensional plotting, which works exactly as<a id="_idIndexMarker185"/> the usual <strong class="source-inline">plot</strong> routine but on three-dimensional axes. This method can also be used to plot two-dimensional data on one of <span class="No-Break">the axes.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>See also</h2>
			<p>Matplotlib is the go-to plotting library for Python, but other options do exist. We’ll see the Bokeh library in <a href="B19085_06.xhtml#_idTextAnchor226"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. There are other libraries, such<a id="_idIndexMarker186"/> as Plotly (https://plotly.com/python/), that simplify the process of creating certain types of plots and adding more features, such as <span class="No-Break">interactive plots.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Customizing three-dimensional plots</h1>
			<p>Contour plots <a id="_idIndexMarker187"/>can hide some detail of the surface that they represent since they only show where the “height” is similar and not what the value is, even in relation to the surrounding values. On a map, this is remedied by printing the height onto certain contours. Surface plots are more revealing, but the problem of projecting three-dimensional objects into 2D to be displayed on a screen can itself obscure some details. To address these issues, we can customize the appearance of a three-dimensional plot (or contour plot) to enhance the plot and make sure the detail that we wish to highlight is clear. The easiest way to do this is by changing the colormap of the plot, as we saw in the previous recipe. (By default, Matplotlib will produce surface plots with a single color, which makes details difficult to see in printed media.) In this recipe, we look at some other ways we can customize 3D surface plots, including changing the initial angle of the display and changing the normalization applied for <span class="No-Break">the colormap.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Getting ready</h2>
			<p>In this recipe, we<a id="_idIndexMarker188"/> will further customize the function we plotted in the <span class="No-Break">previous recipe:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer279">
					<img alt="" src="image/Formula_02_049.jpg"/>
				</div>
			</div>
			<p>We generate points at which this should be plotted, as in the <span class="No-Break">previous recipe:</span></p>
			<pre class="source-code">
t = np.linspace(-5, 5)
x, y = np.meshgrid(t, t)
z = np.exp(-((x-2.)**2 + (y-3.)**2)/4) - np.exp(
    -((x+3.)**2 + (y+2.)**2)/3)</pre>
			<p>Let’s see how to customize a three-dimensional plot of <span class="No-Break">these values.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>How to do it...</h2>
			<p>The following steps show how to customize the appearance of a <span class="No-Break">3D plot:</span></p>
			<p>As usual, our first task is to create a new figure and axes on which we will plot. Since we’re going to customize the properties of the <strong class="source-inline">Axes3D</strong> object, we’ll just create a new <span class="No-Break">figure first:</span></p>
			<pre class="source-code">
fig = plt.figure()</pre>
			<p>Now, we need to add a new <strong class="source-inline">Axes3D</strong> object to this figure and change the initial viewing angle by setting the <strong class="source-inline">azim</strong> and <strong class="source-inline">elev</strong> keyword arguments along with the <strong class="source-inline">projection=</strong><strong class="source-inline">"3d"</strong> keyword argument that we have <span class="No-Break">seen before:</span></p>
			<pre class="source-code">
ax = fig.add_subplot(projection="3d", azim=-80, elev=22)</pre>
			<p>With <a id="_idIndexMarker189"/>this done, we can now plot the surface. We’re going to change the bounds of the normalization so that the maximum value and minimum value are not at the extreme ends of our colormap. We do this by changing the <strong class="source-inline">vmin</strong> and <span class="No-Break"><strong class="source-inline">vmax</strong></span><span class="No-Break"> arguments:</span></p>
			<pre class="source-code">
ax.plot_surface(x, y, z, cmap="gray", vmin=-1.2, vmax=1.2)</pre>
			<p>Finally, we can set up the axes labels and the title <span class="No-Break">as usual:</span></p>
			<pre class="source-code">
ax.set_title("Customized 3D surface plot")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("z")</pre>
			<p>The resulting plot is shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer280">
					<img alt="Figure 2.9 - Customized 3D surface plot with modified normalization and an initial viewing angle&#13;&#10;" src="image/B19085_02_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 - Customized 3D surface plot with modified normalization and an initial viewing angle</p>
			<p>Comparing <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.6</em> with <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>, we can see that the latter generally contains darker<a id="_idIndexMarker190"/> shades compared to the former, and the viewing angle offers a better view of the basin where the function is minimized. The darker shade is due to the normalization applied to the values for the colormap, which we altered using the <strong class="source-inline">vmin</strong> and <strong class="source-inline">vmax</strong> <span class="No-Break">keyword arguments.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>How it works...</h2>
			<p>Color mapping <a id="_idIndexMarker191"/>works by assigning an RGB value according to a scale—the <strong class="bold">colormap</strong>. First, the values are<a id="_idIndexMarker192"/> normalized so that they lie between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, which is typically done by a linear transformation that takes the minimum value to <strong class="source-inline">0</strong> and the maximum value to <strong class="source-inline">1</strong>. The appropriate color is then applied to each face of the surface plot (or line, in another kind <span class="No-Break">of plot).</span></p>
			<p>In the recipe, we used the <strong class="source-inline">vmin</strong> and <strong class="source-inline">vmax</strong> keyword arguments to artificially change the value that is mapped to <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, respectively, for the purposes of fitting the colormap. In effect, we changed the ends of the color range applied to <span class="No-Break">the plot.</span></p>
			<p>Matplotlib comes with a number of built-in colormaps that can be applied by simply passing the name to the <strong class="source-inline">cmap</strong> keyword argument. A list of these colormaps is given in the documentation (<a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a>) and also comes with a reversed variant, which is obtained by adding the <strong class="source-inline">_r</strong> suffix to the name of the <span class="No-Break">chosen colormap.</span></p>
			<p>The viewing <a id="_idIndexMarker193"/>angle for a 3D plot is described by two angles: the <strong class="bold">Azimuthal</strong> angle, measured<a id="_idIndexMarker194"/> within the reference plane (here, the <img alt="" src="image/Formula_02_050.png"/>-<img alt="" src="image/Formula_02_051.png"/>-plane), and<a id="_idIndexMarker195"/> the <strong class="bold">elevation</strong> angle, measured as the angle from the reference plane. The default viewing angle for <strong class="source-inline">Axes3D</strong> is -60 Azimuthal and 30 elevation. In the recipe, we used the <strong class="source-inline">azim</strong> keyword argument of <strong class="source-inline">plot_surface</strong> to change the initial Azimuthal angle to -80 degrees (almost from the direction of the negative <img alt="" src="image/Formula_02_052.png"/> axis) and the <strong class="source-inline">elev</strong> argument to change the initial elevation to <span class="No-Break">22 degrees.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>There’s more...</h2>
			<p>The normalization step in applying a colormap is performed by an object derived from the <strong class="source-inline">Normalize</strong> class. Matplotlib provides a number of standard normalization routines, including <strong class="source-inline">LogNorm</strong> and <strong class="source-inline">PowerNorm</strong>. Of course, you can also create your own subclass of <strong class="source-inline">Normalize</strong> to perform the normalization. An alternative <strong class="source-inline">Normalize</strong> subclass can be added using the <strong class="source-inline">norm</strong> keyword of <strong class="source-inline">plot_surface</strong> or other <span class="No-Break">plotting functions.</span></p>
			<p>For more advanced uses, Matplotlib provides an interface for creating custom shading using light sources. This is done by importing the <strong class="source-inline">LightSource</strong> class from the <strong class="source-inline">matplotlib.colors</strong> package, and then using an instance of this class to shade the surface elements according to the <img alt="" src="image/Formula_02_053.png"/> value. This is done using the <strong class="source-inline">shade</strong> method on the <span class="No-Break"><strong class="source-inline">LightSource</strong></span><span class="No-Break"> </span><span class="No-Break">object:</span></p>
			<pre class="source-code">
from matplotlib.colors import LightSource
light_source = LightSource(0, 45)  # angles of lightsource
cmap = plt.get_cmap("binary_r")
vals = light_source.shade(z, cmap)
surf = ax.plot_surface(x, y, z, facecolors=vals)</pre>
			<p>Complete examples are shown in the Matplotlib gallery should you wish to learn more about <span class="No-Break">how this.</span></p>
			<p>In addition <a id="_idIndexMarker196"/>to the viewing angle, we can also change the type of projection used to represent 3D data as a 2D image. The default is a perspective projection, but we can also use an orthogonal projection by setting the <strong class="source-inline">proj_type</strong> keyword argument <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"ortho"</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Plotting vector fields with quiver plots</h1>
			<p>A vector field<a id="_idIndexMarker197"/> is a function that assigns to each point in a region a vector—it is a <a id="_idIndexMarker198"/>vector-valued function defined on a space. These are especially common in the study of (systems of) differential equations, where a vector field typically appears as the right-hand side of the equation. (See the <em class="italic">Solving systems of differential equations</em> recipe from <a href="B19085_03.xhtml#_idTextAnchor078"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> for more details.) For this reason, it is often useful to visualize a vector field and understand how the function will evolve over space. For now, we’re simply going to produce a plot of a vector field<a id="_idIndexMarker199"/> using a quiver plot, which takes a set of <img alt="" src="image/Formula_02_054.png"/> and <img alt="" src="image/Formula_02_055.png"/> coordinates and a set of <img alt="" src="image/Formula_02_056.png"/> and <img alt="" src="image/Formula_02_057.png"/> vectors, and produces a plot on which each point has an arrow in the direction <img alt="" src="image/Formula_02_058.png"/> and whose length is the length of this vector. (Hopefully, this will become more clear when we actually create the <span class="No-Break">said plot.)</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Getting ready</h2>
			<p>As usual, we import the Matplotlib <strong class="source-inline">pyplot</strong> interface under the alias <strong class="source-inline">plt</strong>. Before we start, we need to define a function that takes a point and produces a vector; we’ll use this later to generate <img alt="" src="image/Formula_02_059.png"/> and <img alt="" src="image/Formula_02_060.png"/> data that will be passed to the <span class="No-Break">plotting function.</span></p>
			<p>For this example, we’re going to plot the following <span class="No-Break">vector field:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer292">
					<img alt="" src="image/Formula_02_061.jpg"/>
				</div>
			</div>
			<p>For this example, we’ll plot the vector field over the region where <img alt="" src="image/Formula_02_062.png"/> <span class="No-Break">and <img alt="" src="image/Formula_02_063.png"/>.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>How to do it…</h2>
			<p>The following steps show how to visualize the aforementioned vector field over the <span class="No-Break">specified region.</span></p>
			<p>First, we need to define a Python function that evaluates our vector field <span class="No-Break">at points:</span></p>
			<pre class="source-code">
def f(x, y):
  v = x**2 +y**2
    return np.exp(-2*v)*(x+y), np.exp(
        -2*v)*(x-y)</pre>
			<p>Next, we<a id="_idIndexMarker200"/> need to create our grid of points covering the region. For this, we first create a temporary <strong class="source-inline">linspace</strong> routine<a id="_idIndexMarker201"/> with values between <strong class="source-inline">-1</strong> and <strong class="source-inline">1</strong>. Then, we use <strong class="source-inline">meshgrid</strong> to generate a grid <span class="No-Break">of points:</span></p>
			<pre class="source-code">
t = np.linspace(-1., 1.)
x, y = np.meshgrid(t, t)</pre>
			<p>Next, we use our function to generate <strong class="source-inline">dx</strong> and <strong class="source-inline">dy</strong> values that describe the vectors at each <span class="No-Break">grid point:</span></p>
			<pre class="source-code">
dx, dy = f(x, y)</pre>
			<p>Now, we can create a new figure and axis and use the <strong class="source-inline">quiver</strong> method to generate <span class="No-Break">a plot:</span></p>
			<pre class="source-code">
fig, ax = plt.subplots()
ax.quiver(x, y, dx, dy)</pre>
			<p>The resulting plot is shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer295">
					<img alt="Figure 2.10 - Visualization of a vector field using a quiver plot&#13;&#10;" src="image/B19085_02_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 - Visualization of a vector field using a quiver plot</p>
			<p>In <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.10</em>, we <a id="_idIndexMarker202"/>can see the <img alt="" src="image/Formula_02_064.png"/> value represented <a id="_idIndexMarker203"/>as an arrow based at each <img alt="" src="image/Formula_02_065.png"/> coordinate. The size of the arrow is determined by the magnitude of the vector field. At the origin, the vector field has <img alt="" src="image/Formula_02_066.png"/>, so the arrows nearby are <span class="No-Break">very small.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>How it works…</h2>
			<p>Our example from the recipe is a mathematical construction rather than something that might arise from real data. For this particular case, the arrows describe how some quantity might evolve if it flows according to the vector field <span class="No-Break">we specified.</span></p>
			<p>Each point in the grid is the base of an arrow. The direction of the arrow is given by the corresponding <img alt="" src="image/Formula_02_067.png"/> value, and the length of the arrow is normalized by length (so, a vector <img alt="" src="image/Formula_02_068.png"/> with smaller components produces a shorter arrow). This can be customized by changing the <strong class="source-inline">scale</strong> keyword argument. Many other aspects of the plot can be <span class="No-Break">customized too.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>There’s more…</h2>
			<p>If you <a id="_idIndexMarker204"/>want to plot <a id="_idIndexMarker205"/>a set of trajectories that follow a vector field, you can use the <strong class="source-inline">streamplot</strong> method. This will plot trajectories starting at various points to indicate the general flow in different parts of the domain. Each streamline has an arrow to indicate the direction of flow. For example, <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.11</em> shows the result of using the <strong class="source-inline">streamplot</strong> method with the vector field in <span class="No-Break">the recipe:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer301">
					<img alt="Figure 2.11 – Plot of the trajectories described by the vector field from the recipe&#13;&#10;" src="image/B19085_02_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Plot of the trajectories described by the vector field from the recipe</p>
			<p>In a different scenario, you might have data about wind speed (or similar quantities) at a number of coordinates—on a map, say—and you want to plot these quantities in the standard style for <a id="_idIndexMarker206"/>weather charts. Then, we can use the <strong class="source-inline">barbs</strong> plotting method. The arguments<a id="_idIndexMarker207"/> are similar to the <span class="No-Break"><strong class="source-inline">quiver</strong></span><span class="No-Break"> method.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Further reading</h1>
			<p>The Matplotlib package is extensive, and we can scarcely do it justice in such a short space. The documentation contains far more detail than is provided here. Moreover, there is a large <a id="_idIndexMarker208"/>gallery of examples (<a href="https://matplotlib.org/gallery/index.html#">https://matplotlib.org/gallery/index.html#</a>) covering many more of the capabilities of the package than in <span class="No-Break">this book.</span></p>
			<p>Other packages build on top of Matplotlib to offer high-level plotting methods for specific applications. For example, the <a id="_idIndexMarker209"/>Seaborn libraries provide routines for visualizing <span class="No-Break">data (</span><a href="https://seaborn.pydata.org/"><span class="No-Break">https://seaborn.pydata.org/</span></a><span class="No-Break">).</span></p>
		</div>
	</body></html>