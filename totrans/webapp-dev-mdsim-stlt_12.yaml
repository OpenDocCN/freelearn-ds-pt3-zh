- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Smart File Uploading – Advanced Techniques for Professional Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point of our journey, we have almost acquired all the skills we need
    to implement and deploy well-working and nice-looking web applications. Anyway,
    our web apps still have a quite “naive” aspect and are a little bit far from professional
    ones. Starting with this chapter, we will deal with some advanced techniques that
    will help make our products look more complete and professional.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the file uploader, a widget that we already used in the *Covid-19
    Detection Tool* app when we were asked to upload an X-ray image of the chest.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do now is move the file uploader to another level, deeply customizing
    it to automatically detect the type of file we are going to open and adopt the
    appropriate actions. This kind of behavior gives our web applications a very professional
    standing and makes them easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the customized features of the file uploader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a suitable file uploader for web apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying web apps with smart components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll use the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docx2txt`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pdfplumber`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/57674ee5b5c58769120051cfb466f4b4d658c20c/Chapter12](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/57674ee5b5c58769120051cfb466f4b4d658c20c/Chapter12).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the customized features of the file uploader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uploading a file is a simple task. There are several ways to do it, and these
    different approaches have different effects on the so-called *user experience*:
    the way users perceive the application itself. Moreover, a better-implemented
    uploading feature can speed up the entire application, making things easier for
    the users. Let’s imagine that we want to upload a file containing text. It could
    be a `.txt` file, so a plain text file, but also a `.docx` file, a Microsoft Word
    file, or even a `.pdf` file. One approach is to ask the customer, *what kind of
    file do you need to upload (.txtx, .docx, .pdf)?* If the user replies `.txt`,
    the application will launch the `file_uploader` widget customized for this file
    format; if the answer is `.docx`, the `file_uploader` widget customized for Microsoft
    Word will be executed, and so on. This kind of approach works perfectly, but it’s
    a little bit too complex.'
  prefs: []
  type: TYPE_NORMAL
- en: What if the user updated a file and the web application recognized its type
    automatically without human intervention?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to implement this feature according to both approaches, one
    requiring information from the user and another that’s completely automated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new virtual environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll create a new virtual environment dedicated to this chapter. So,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and call it `FileUploader`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, move to the newly created folder and, once inside it, as usual, write
    `pipenv shell` to create the virtual environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The instructions are shown in *Figure 12**.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.1: Creating a new virtual environment dedicated to this chapter](img/B21147_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Creating a new virtual environment dedicated to this chapter'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the only library we need is Streamlit, so let’s type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After a few seconds, our environment will be equipped with the latest Streamlit
    version that’s available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As usual, before we start coding, we have to create an empty Python file, which
    is a very easy operation. We can do this by writing the following instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `app.py` is the name of our file.
  prefs: []
  type: TYPE_NORMAL
- en: We can open the `app.py` file with our favorite IDE, such as Sublime Text.
  prefs: []
  type: TYPE_NORMAL
- en: Building the app skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we have an empty file, the best starting option is to always use the *skeleton*
    we adopted in the two web applications we implemented previously. So, we can import
    the libraries – in this case, just streamlit – and then define a main function
    containing the menu. The menu for this chapter’s app is quite light in that it
    just contains two voices: **Dropfiles** and **About**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we can see how short the skeleton we are using for
    this specific case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: The skeleton of our app](img/B21147_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: The skeleton of our app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the code shown in *Figure 12**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 1*, we import the library (here, `streamlit`), while on *line 4*, we
    define the `main` function – that is, the function containing the business logic
    of our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 5*, we have a list named `menu` containing the values of the web application
    menu (the functions this web application can offer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 6*, we create a select box starting from the menu list in the sidebar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *lines 8* and *13*, we add an `if` clause that enters the proper code to
    execute according to the selection that was performed in the selectbox on *line
    6*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that, we have the skeleton of our app. Now, we can write the following
    instruction in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can start the web application and see it in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: First execution of our new web app](img/B21147_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: First execution of our new web app'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, in the sidebar, there is a selectbox offering the two options
    in the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on the **Dropfile** voice of the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a radio button for the app menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use a radio button to let the user indicate what kind of file they would
    like to upload. Let’s add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the file selection is stored in a variable named `file_selection`.
    So far, our app looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Selecting the file type with radio buttons](img/B21147_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Selecting the file type with radio buttons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user selects an option, we are ready to open `file_uploader` using
    the file type as the selected option. The following code can be adopted in this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Quite easily, after uploading the file (with the `txt` type), we can check that
    the file is not null, read it using `utf-8` encoding, and visualize it on the
    screen. If the uploaded file is null, we just print a warning on the screen stating
    **TXT File** **Fetching Problem...**.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.5* shows the code in the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Uploading a .txt file](img/B21147_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Uploading a .txt file'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we move to the browser, something interesting happens. Even if we have
    three different files containing text in our directory – that is, `''txt''`, `''docx''`,
    and `''pdf''` – since we specify `txt` as the type, the file uploader just sees
    and can open the `.``txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: In the directory on the left, there are three different files,
    but we can only open the .txt file](img/B21147_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: In the directory on the left, there are three different files,
    but we can only open the .txt file'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, to manage other file types, we should write more or less the
    same code we used for the `txt` type but also specify the different types. So,
    the code can evolve into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Asking the user for the type of file](img/B21147_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Asking the user for the type of file'
  prefs: []
  type: TYPE_NORMAL
- en: The code in *Figure 12**.7* contains a couple of `pass` calls for `.docx` and
    `.pdf` files. If you want to complete the related functions, you must import the
    proper library and read the content of the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real point here is that when approaching file uploading in this way, even
    if the code works very well technically, we are forced to do a couple of operations
    we don’t like that much:'
  prefs: []
  type: TYPE_NORMAL
- en: Asking the user about the type of file at the beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating (we just copy and paste) a lot of code that is redundant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve explored this solution, let’s try to implement something much
    more elegant and cleaner that can automatically read the type of file, without
    asking the user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a suitable file uploader for web apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can imagine, this time, we are not using the radio button. Instead, we
    are directly uploading the files. So, referring to *Figure 12**.7*, let’s comment
    all the code between *lines 11* and *31*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediately in the subheading, on *line 10*, we can add `file_uploader`, this
    time including all three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we try to upload the file from the browser, this time in our directory,
    we will see all three types of files and be able to select one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did on *line 15* in the code presented in *Figure 12**.5*, we can check
    that the file is not null by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After this `if` clause, we must get the details of the file. We need these details
    to understand which type of file we selected and how to manage it. By using the
    `raw_file_text` variable, which contains the file we uploaded, we can use three
    methods named `name`, `type`, and `size` to collect the details we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'These details will be put into a dictionary; we are calling it `file_details`.
    Let’s see it in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: The code for file upload and file detail detection](img/B21147_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: The code for file upload and file detail detection'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: File upload and file detail detection in the browser](img/B21147_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: File upload and file detail detection in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, in the directory, we have all three types of files and can select
    any one of them since the information about the file details has been intercepted
    correctly. In the case of the `.txt` file, we got the correct filename, the `text/plain`
    type, and its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what type we get for the `.docx` and `.pdf` files. The `.docx` file,
    as shown here, has a very long type file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: The .docx file](img/B21147_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: The .docx file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, the `.pdf` file has a shorter name:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.11: The .pdf \uFEFFfile](img/B21147_12_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: The .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: 'These three different types of files are all we need to manage file uploading
    automatically. To open the `.pdf` and `.docx` files, we need to install the proper
    libraries (`pdfplumber` and `docx2txt`). So, please write the following command
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first package takes care of `.pdf` files, while the second takes care of
    `.``docx` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installation is finished, we must import these libraries into our
    `app.py` file by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have everything we need. So, referring to *Figure 12**.8*, continuing
    from *line 15* of our code, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code checks that the type of file we uploaded is `text/plain`.
    In this case, it reads it, stores its content in a variable named `raw_text`,
    and prints a label on the screen saying just **Text from TXT file**. This check
    happens in a try cycle; so, in case of an error, a simple exception will be printed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The same code we used for the `.txt` file has to be used for the other kind
    of files; the only differences are the type of the files and the libraries needed
    to read the content of the files (the two libraries we just imported – that is,
    `pdfplumber` and `docx2txt`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the code shown in *Figure 12**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: The code that automatically uploads the files](img/B21147_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.12: The code that automatically uploads the files'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 27*, we used `pdfplumber` because the file type is `"application/pdf"`,
    while on *line 35*, we used `docx2txt` because the file to open is a `.``docx`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on *line 42*, we automatically print the contents of the opened file
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result in the case of a `.docx` file; please note the very long
    name of the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: A .docx file is automatically recognized and opened](img/B21147_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: A .docx file is automatically recognized and opened'
  prefs: []
  type: TYPE_NORMAL
- en: 'The application behavior with a `.pdf` file is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: A .pdf file is automatically recognized and opened](img/B21147_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: A .pdf file is automatically recognized and opened'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned two ways of uploading files: asking the user about
    the file type and making the file uploading process automated. Both approaches
    are valid, and which one you should choose depends on the use case. Simplifying
    our web apps with smart components should always be the preferred solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying web apps with smart components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have learned about the principles of effective web
    application design. Now, we can move toward the user experience, which should
    always be simple, intuitive, and aesthetically pleasing.
  prefs: []
  type: TYPE_NORMAL
- en: The approach with the radio button, from a functional point of view, works very
    well but makes things a little bit too complex because it requires the user’s
    intervention at the beginning and draws an ugly radio button on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The other approach is very neat and extremely clean because just a file uploader
    widget is present on the screen and the user can select the file by just clicking
    on it (or using drag and drop) without any other kind of intervention.
  prefs: []
  type: TYPE_NORMAL
- en: This is possible because the web app intercepts the file type property and uses
    it to open the file and read its content by selecting the proper library.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of approach is quite smart and delineates the difference between an
    application made by a rookie and an application that looks very professional.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned how to manage file uploading in different ways
    and according to different approaches: first, by specifying the file type at any
    time to trigger the proper function, and second by making the file type detection
    automatic and seamless.'
  prefs: []
  type: TYPE_NORMAL
- en: While the first approach involves the user, the second one makes our application
    usage very smooth.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue exploring advanced features and solutions
    to make our web applications more professional.
  prefs: []
  type: TYPE_NORMAL
