- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Protein Data Bank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proteomics is the study of proteins, including their function and structure.
    One of the main objectives of this field is to characterize the three-dimensional
    structure of proteins. One of the most widely known computational resources in
    the proteomics field is the **Protein Data Bank** (**PDB**), a repository with
    the structural data of large biomolecules. Of course, many databases focus on
    protein primary structure instead; these are somewhat similar to the genomic databases
    that we saw in [*Chapter 2*](B17942_02.xhtml#_idTextAnchor040), *Getting to Know
    NumPy, pandas, Arrow, and Matplotlib*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will mostly focus on processing data from the PDB. We will
    look at how to parse PDB files, perform some geometric computations, and visualize
    molecules. We will use the old PDB file format because, conceptually, it allows
    you to perform most necessary operations within a stable environment. Having said
    that, the newer mmCIF slated to replace the PDB format will also be presented
    in the *Parsing the mmCIF files with Biopython* recipe. We will use Biopython
    and introduce PyMOL for visualization. We will not discuss molecular docking here
    because that is probably more suited to a book about chemoinformatics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will use a classic example of a protein: the tumor
    protein p53, a protein involved in the regulation of the cell cycle (for example,
    apoptosis). This protein is highly related to cancer. There is plenty of information
    available about this protein on the web.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with something that you should be more familiar with by now: accessing
    databases, especially for a protein’s primary structure (as in, sequences of amino
    acids).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding a protein in multiple databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Bio.PDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting more information from a PDB file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing molecular distances on a PDB file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing geometric operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating with PyMOL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the mmCIF files with Biopython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a protein in multiple databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start performing some more structural biology, we will look at how
    we can access existing proteomic databases, such as UniProt. We will query UniProt
    for our gene of interest, *TP53*, and take it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the data, we will use Biopython and the REST API (we used a similar
    approach in [*Chapter 5*](B17942_05.xhtml#_idTextAnchor122), *Working with Genomes*)
    with the `requests` library to access web APIs. The `requests` API is an easy-to-use
    wrapper for web requests that can be installed using standard Python mechanisms
    (for example, `pip` and `conda`). You can find this content in the `Chapter08/Intro.py`
    Notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define a function to perform REST queries on UniProt, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now query all the `p53` genes that have been reviewed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will query the `p53` gene and request to see all entries that are reviewed
    (as in, manually curated). The output will be in a tabular format. We will request
    a maximum of 50 results, specifying the desired columns.
  prefs: []
  type: TYPE_NORMAL
- en: We could have restricted the output to just human data, but for this example,
    let’s include all available species.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the results, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use `pandas` for easy processing of the tab-delimited list and pretty printing.
    The abridged output of the Notebook is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 - An abridged list of species for which there is a TP53 protein
    ](img/B17942_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 - An abridged list of species for which there is a TP53 protein
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can get the human `p53` ID and use Biopython to retrieve and parse
    the `SwissProt` record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then use Biopython’s `SwissProt` module to parse the record. `9606` is the
    NCBI taxonomic code for humans.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, if there is an error with your network services, it may be a network
    or server problem. If this is the case, just retry at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `p53` record, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A deeper look at the preceding record reveals a lot of really interesting information,
    especially on features, `cross_references`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we are not even printing all of the information here, just a summary
    of it. We print a number of features of the sequence with one example per type,
    a number of external database references, plus databases that are referred to,
    and a number of GO entries, along with three examples. Currently, there are 1,509
    features, 923 external references, and 173 GO terms just for this protein. Here
    is a highly abridged version of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many more databases with information on proteins – some of these are
    referred to in the preceding record. You can explore its result to try and find
    data elsewhere. For detailed information about UniProt’s REST interface, refer
    to [http://www.uniprot.org/help/programmatic_access](http://www.uniprot.org/help/programmatic_access).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Bio.PDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will introduce Biopython’s `PDB` module for working with the PDB. We
    will use three models that represent part of the `p53` protein. You can read more
    about these files and `p53` at [http://www.rcsb.org/pdb/101/motm.do?momID=31](http://www.rcsb.org/pdb/101/motm.do?momID=31).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should already be aware of the basic `PDB` data model of model, chain, residue,
    and atom objects. A good explanation of *Biopython’s Structural Bioinformatics
    FAQ* can be found at [http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ](http://biopython.org/wiki/The_Biopython_Structural_Bioinformatics_FAQ).
  prefs: []
  type: TYPE_NORMAL
- en: You can find this content in the `Chapter08/PDB.py` Notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: Of the three models that we will download, the `1TUP` model is the one that
    will be used in the remainder of the recipes. Take some time to study this model,
    as it will help you later on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s retrieve our models of interest, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `Bio.PDB` will take care of downloading files for you. Moreover, these
    downloads will only occur if no local copy is already present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s parse our records, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may get some warnings about the content of the file. These are usually not
    problematic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inspect our headers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Headers are parsed as a dictionary of dictionaries. As such, we will use a
    recursive function to parse them. This function will increase the indentation
    for ease of reading and annotate lists of elements with the `->` prefix. For an
    example of recursive functions, refer to the previous chapter, [*Chapter 7*](B17942_07.xhtml#_idTextAnchor183),
    *Phylogenetics*. For an advanced discussion on recursion in Python, go to the
    last chapter, [*Chapter 12*](B17942_12.xhtml#_idTextAnchor294), *Functional Programming
    for Bioinformatics*. The abridged output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to know the content of each chain on these files; for this, let’s take
    a look at the `COMPND` records:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will return all the compound headers printed in the preceding code. Unfortunately,
    this is not the best way to get information on chains. An alternative would be
    to get `DBREF` records, but Biopython’s parser is currently not able to access
    these. Having said that, using a tool such as `grep` will easily extract this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the `1TUP` model, chains `A`, `B`, and `C` are from the protein,
    while chains `E` and `F` are from the DNA. This information will be useful in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do a top-down analysis of each `PDB` file. For now, let’s just get all
    of the chains, the number of residues, and atoms per chain, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will perform a bottom-up approach in a later recipe. Here is the output
    for `1TUP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s get all non-standard residues (`HETATM`), with the exception of water,
    in the `1TUP` model, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have three zincs, one in each of the protein chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a residue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print all the atoms in a certain residue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note the last statement. It is there just to show you that you can directly
    access an atom by resolving the model, chain, residue, and finally, the atom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s export the protein fragment to a FASTA file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you inspect the protein chain, you will see that they are equal in each model,
    so we export a single one. In the case of `1YCQ`, we export the smallest one,
    because the biggest one is not `p53`-related. As you can see, here, we are using
    `Bio.SeqIO`, not `Bio.PDB`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PDB parser is incomplete. It’s not very likely that a complete parser will
    be seen soon, as the community is migrating to the mmCIF format.
  prefs: []
  type: TYPE_NORMAL
- en: Although the future is the mmCIF format ([http://mmcif.wwpdb.org/](http://mmcif.wwpdb.org/)),
    PDB files are still around. Conceptually, many operations are similar after you
    have parsed the file.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting more information from a PDB file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will continue our exploration of the record structure produced by `Bio.PDB`
    from PDB files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For general information about the PDB models that we are using, refer to the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this content in the `Chapter08/Stats.py` Notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll get started, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s retrieve `1TUP`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, extract some atom-related statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print information on the atom’s residue type, the number of atoms
    per chain, and the quantity per element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding number of residues is not the proper number of residues,
    but the amount of times that a certain residue type is referred to (it adds up
    to the number of atoms, not residues).
  prefs: []
  type: TYPE_NORMAL
- en: Notice the water (`W`), nucleotide (`DA`, `DC`, `DG`, and `DT`), and zinc (`ZN`)
    residues, which add to the amino acid ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s count the instance per residue and the number of residues per chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also get the bounds of a set of atoms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A set of atoms can be a whole model, a chain, a residue, or any subset that
    you are interested in. In this case, we will print boundaries for all the chains
    and the whole model. Numbers don’t convey it so intuitively, so we will get a
    little bit more graphical.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a notion of the size of each chain, a plot is probably more informative
    than the numbers in the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are plenty of molecular visualization tools. Indeed, we will discuss PyMOL
    later. However, `matplotlib` is enough for simple visualization. The most important
    point about `matplotlib` is that it’s stable and very easy to integrate into reliable
    production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following chart, we performed a three-dimensional plot of chains, with
    the DNA in grey and the protein chains in different colors. We also plot planar
    projections (**X/Y**, **X/Z**, and **Z/Y**) on the left-hand side of the following
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 - The spatial distribution of the protein chains – the main figure
    is a 3D plot and the left subplots are planar views (X/Y, X/Z, and Z/Y) ](img/B17942_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 - The spatial distribution of the protein chains – the main figure
    is a 3D plot and the left subplots are planar views (X/Y, X/Z, and Z/Y)
  prefs: []
  type: TYPE_NORMAL
- en: Computing molecular distances on a PDB file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will find atoms closer to three zincs in the `1TUP` model. We will
    consider several distances to these zincs. We will take this opportunity to discuss
    the performance of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find this content in the `Chapter08/Distance.py` Notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load our model, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now get our zincs, against which we will perform comparisons later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see three zinc atoms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s define a function to get the distance between one atom and a set
    of other atoms, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We get coordinates for our reference atom and then iterate over our desired
    comparison list. If an atom is close enough, it’s added to the `return` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now compute the atoms near our zincs, the distance of which can be up to
    4 Ångströms for our model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we show the result for the first zinc, including the element, distance,
    and coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We only have three zincs, so the number of computations is quite significantly
    reduced. However, imagine that we had more, or that we were doing a pairwise comparison
    among all the atoms in the set (remember that the number of comparisons grows
    quadratically with the number of atoms in a pairwise case). Although our case
    is small, it’s not difficult to forecast use cases, while more comparisons take
    a lot of time. We will get back to this soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how many atoms we get as we increase the distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen previously, this specific case is not very expensive, but let’s
    time it anyway:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we will use the `timeit` module to execute this function 10 times and
    then print the result in milliseconds. We pass the function as a string and pass
    yet another string with the necessary imports to make this function work. On a
    Notebook, you are probably aware of the `%timeit` magic and how it makes your
    life much easier in this case. This takes roughly 40 milliseconds on the machine
    where the code was tested. Obviously, on your computer, you will get somewhat
    different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do better? Let’s consider a different `distance` function, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we take the original function and add a very simplistic `if` with the distances.
    The rationale for this is that the computational cost of the square root, and
    maybe the float power operation, is very expensive, so we will try to avoid it.
    However, for all atoms that are closer than the target distance in any dimension,
    this function will be more expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s time against it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the same machine that we used in the preceding example, it takes 16 milliseconds,
    which means that it is roughly three times faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, is this always better? Let’s compare the cost with different distances,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that the cost of the Standard version is mostly constant, whereas the Optimized
    version varies depending on the distance of the closest atoms; the larger the
    distance, the more cases that will be computed using the extra `if`, plus the
    square root, making the function more expensive.
  prefs: []
  type: TYPE_NORMAL
- en: The larger point here is that you can probably code functions that are more
    efficient using smart computation shortcuts, but the complexity cost may change
    qualitatively. In the preceding case, I suggest that the second function is more
    efficient for all realistic and interesting cases when you’re trying to find the
    closest atoms. However, you have to be careful while designing your own versions
    of optimized algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Performing geometric operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now perform computations with geometry information, including computing
    the center of the mass of chains and whole models.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find this content in the `Chapter08/Mass.py` Notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s retrieve the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s recall the type of residues that we have with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we have `H_ ZN` (zinc) and `W` (water), which are `HETATM` types; the vast
    majority are standard PDB atoms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compute the masses for all chains, zincs, and waters using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `get_mass` function returns the mass of all atoms in the list that pass
    an acceptance criterion function. Here, the default acceptance criterion involves
    not being a water residue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then compute the mass for all chains. We have three versions: just amino
    acids, zincs, and water. Zinc does nothing more than detect a single atom per
    chain in this model. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 - The mass for all protein chains ](img/B17942_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 - The mass for all protein chains
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compute the geometric center and the center of mass of the model, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we define a weighted function to get the coordinates of the center. The
    default function will treat all atoms as equal, as long as they are not a water
    residue.
  prefs: []
  type: TYPE_NORMAL
- en: We then compute the geometric center and the center of mass by redefining the
    `weight` function with a value of each atom equal to its mass. The geometric center
    is computed, irrespective of its molecular weights.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you may want to compute the center of mass of the protein without
    DNA chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compute the center of mass and the geometric center of each chain, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 - The center of mass and the geometric center of each protein
    chain ](img/B17942_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 - The center of mass and the geometric center of each protein chain
  prefs: []
  type: TYPE_NORMAL
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although this is not a book based on the protein structure determination technique,
    it’s important to remember that X-ray crystallography methods cannot detect hydrogens,
    so computing the mass of residues might be based on very inaccurate models; refer
    to [http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm](http://www.umass.edu/microbio/chime/pe_beta/pe/protexpl/help_hyd.htm)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Animating with PyMOL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will create a video of the p53 `1TUP` model. For that, we will use
    the PyMOL visualization library. We will start our animation by moving around
    the p53 `1TUP` model and then zooming in; as we zoom in, we change the rendering
    strategy so that you can see deeper into the model. You can find a version of
    the video that you will generate at [https://odysee.com/@Python:8/protein_video:8](https://odysee.com/@Python:8/protein_video:8%20).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will be presented as a Python script, not as a Notebook. This is
    mostly because the output is not interactive, but a set of image files that will
    need further post-processing.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install PyMOL ([http://www.pymol.org](http://www.pymol.org)).
    On Debian, Ubuntu, or Linux, you can use the `apt-get install pymol` command.
    If you are on Conda, I suggest not using it, as the dependencies will be easy
    to resolve – furthermore, you will be installing a 30-day-trial-only version requiring
    a license, whereas the version above is fully open source. If you are not on Debian
    or Linux, I suggest that you install the open source version available for your
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: PyMOL is more of an interactive program than a Python library, so I strongly
    encourage you to play with it before moving on to the recipe. This can be fun!
    The code for this recipe is available on the GitHub repository as a script, along
    with this chapter’s Notebook file, at `Chapter08`. We will use the `PyMol_Movie.py`
    file in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s initialize and retrieve our PDB model and prepare the rendering, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `pymol_argv` line makes the code silent. In your first execution,
    you may want to comment this out and see the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: For movie rendering, this will come in handy (as we will see soon). As a library,
    PyMOL is quite tricky to use. For instance, after the import, you have to call
    `finish_launching`. We then fetch our PDB file.
  prefs: []
  type: TYPE_NORMAL
- en: What then follows is a set of PyMOL commands. Many web guides for interactive
    usage can be quite useful for understanding what is going on. Here, we will enable
    all of the models for viewing purposes, hiding all (because the default view is
    of lines and this is not good enough), then making the zincs visible as spheres.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, bar zinc, everything else is invisible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render our model, we will use three scenes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to define two scenes. One scene corresponds to us moving around the
    protein (surface-based, thus opaque) and the other corresponds to us diving in
    (cartoon-based). The DNA is always rendered as a cartoon.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a third scene for when we zoom out at the end. The protein will
    be rendered as sticks, and we add a mesh to chain A so that the relationship with
    the DNA becomes clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the basic parameter of our video, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the default ray-tracing algorithm. This line does not need to be there,
    but try to increase the number to `1`, `2`, or `3` and be ready to wait a lot.
  prefs: []
  type: TYPE_NORMAL
- en: You can only use `0` if you have the OpenGL interface on (with the GUI), so,
    for this fast version, you will need to have the GUI on (`pymol_argv` should be
    commented as it is).
  prefs: []
  type: TYPE_NORMAL
- en: We then inform PyMOL that we will have 500 frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first 150 frames, we move around using the initial scene. We move around
    the model a bit and then move nearer to the DNA using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define three points; the first two align with the DNA and the last point
    goes in. We get coordinates (all of these numbers) by using PyMOL in interactive
    mode, navigating using the mouse and keyboard, and using the `get_view` command,
    which will return coordinates that you can cut and paste.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first frame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 - Frame 0 and scene DS0 ](img/B17942_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 - Frame 0 and scene DS0
  prefs: []
  type: TYPE_NORMAL
- en: 'We now change the scene, in preparation for going inside the protein:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows the current position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 - Frame 200 near the DNA molecule and scene S1 ](img/B17942_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 - Frame 200 near the DNA molecule and scene S1
  prefs: []
  type: TYPE_NORMAL
- en: 'We move inside the protein and change the scene at the end using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now fully inside, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 - Frame 350 – scene S1 on the verge of changing to S2 ](img/B17942_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 - Frame 350 – scene S1 on the verge of changing to S2
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we let PyMOL return to its original position, and then play, save,
    and quit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate 500 PNG files with the `p53_1tup` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a frame approaching the end (450):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 - Frame 450 and scene S2 ](img/B17942_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 - Frame 450 and scene S2
  prefs: []
  type: TYPE_NORMAL
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The YouTube video was generated using `ffmpeg` on Linux at `15` frames per
    second, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are plenty of applications that you can use to generate videos from images.
    PyMOL can generate a MPEG, but it requires the installation of extra libraries.
  prefs: []
  type: TYPE_NORMAL
- en: PyMOL was created to be used interactively from its console (which can be extended
    in Python). Using it the other way around (importing from Python with no GUI)
    can be complicated and frustrating. PyMOL starts a separate thread to render images
    that work asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: For example, this means that your code may be in a different position from where
    the renderer is. I have put another script called `PyMol_Intro.py` in the GitHub
    repository; you will see that the second PNG call will start before the first
    one has finished. Try the script code, see how you expect it to behave, and how
    it actually behaves.
  prefs: []
  type: TYPE_NORMAL
- en: There is plenty of good documentation for PyMOL from a GUI perspective at [http://www.pymolwiki.org/index.php/MovieSchool](http://www.pymolwiki.org/index.php/MovieSchool).
    This is a great starting point if you want to make movies, and [http://www.pymolwiki.org](http://www.pymolwiki.org)
    is a treasure trove of information.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing mmCIF files using Biopython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mmCIF file format is probably the future. Biopython doesn’t have full functionality
    to work with it yet, but we will take a look at what currently exists.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As `Bio.PDB` is not able to automatically download mmCIF files, you need to
    get your protein file and rename it to `1tup.cif`. This can be found at [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-Edition/blob/master/Datasets.py)
    under `1TUP.cif`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this content in the `Chapter08/mmCIF.py` Notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s parse the file. We just use the MMCIF parser instead of the PDB parser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s inspect the following chains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Many of the fields are not available in the parsed structure, but the fields
    can still be retrieved by using a lower-level dictionary, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unfortunately, this list is large and requires some post-processing to make
    sense of it, but it is available.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You still have all the model information from the mmCIF file made available
    by Biopython, so the parser is still quite useful. We can expect more developments
    with the `mmCIF` parser than with the `PDB` parser.
  prefs: []
  type: TYPE_NORMAL
- en: There is a Python library for this that’s been made available by the developers
    of PDB at [http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml](http://mmcif.wwpdb.org/docs/sw-examples/python/html/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
