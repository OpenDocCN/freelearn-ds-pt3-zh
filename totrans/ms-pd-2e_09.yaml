- en: Grouping, Merging, and Reshaping Data in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll tackle the question of rearranging and reshaping data
    in our data structures. We'll examine the various functions that enable us to
    rearrange data by utilizing them on real-world datasets. Such functions include
    `groupby`, `concat`, `aggregate`, `append`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we''ll discuss in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating/grouping data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging and concatenating data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reshaping data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other methods for reshaping DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Grouping data is vital to arrive at key conclusions at an initial exploratory
    analysis phase. For example, when you deal with a retail dataset with variables
    such as *OrderID, CustomerID, Shipping Date, Product Category, Sales Region, Quantity
    Ordered, Cancelation Status, Total Sales, Profit, Discount,* and others,grouping
    the data and aggregating it helps you to arrive at answers to questions such as
    those that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Which region was the most profitable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which product category had the most cancelations?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What percent of customers contribute to 80% of the profit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping involves aggregating across each category. Aggregation may involve
    operations such as count, sum, exponent, or implementing a complex user-defined
    function. The `groupby` function of pandas helps with grouping. This is not much
    different from the `groupby` query in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The groupby operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through a `groupby` function, a chain of actions gets executed: splitting,
    applying, and combining. Splitting segments each category from the desired grouping
    variable to perform further operations with it. Then, functions can be individually
    applied across each of these split groups. These functions might involve aggregation
    (sum across a group or mean across a group), transformation (filling NAs within
    a group or sorting), filtration (applying conditions within a group to drop rows),
    or even a combination of these three operations. Finally, the results obtained
    after the functions are applied across each of the split groups are combined together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use sample data from a fictitious global retailer. The data available
    as CSV is read as a pandas DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `head` function will give us a quick glimpse of the dataset we just imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcf0a6c6-1720-4dee-adfc-20c36448a3fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Snapshot of sample sales data
  prefs: []
  type: TYPE_NORMAL
- en: While a sample of five rows has been shown in the preceding output, the data
    contains 51,290 rows and 15 columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to understand how `groupby` splits the data, let''s split it by the `Category`
    variable. The object created is not a DataFrame but rather an object type unique
    to the `groupby` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The grouping object is referred to as the key. Here, `Category` is the key.
    The groups under the `groupby` object created in the previous step are shown here.
    You can see that each group in `Category` is mapped to the row-index labels covered
    by each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edab4c50-68a7-4d0d-a1e6-a1e882fb9bc2.png)'
  prefs: []
  type: TYPE_IMG
- en: Information for each group
  prefs: []
  type: TYPE_NORMAL
- en: 'The data has four quantitative variables: `Quantity`, `Sales`, `Discount`,
    and `Profit`. Using `groupby`, let''s compute the sum of all these four variables
    across each `Category`. This is an application of aggregation with `groupby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a2acde3-97d0-4c21-be06-b6f951325fee.png)'
  prefs: []
  type: TYPE_IMG
- en: Results of groupby and summing
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code slightly, as shown here, to compute only the sum of sales.
    This involves subsetting the data right before applying `groupby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57784647-3ea2-4f59-8078-f78624504dbe.png)'
  prefs: []
  type: TYPE_IMG
- en: groupby and sum across one variable
  prefs: []
  type: TYPE_NORMAL
- en: 'Aggregation need not be applied across only a quantitative variable. Now, using
    `groupby`, let''s find the `Country` in which each category was first ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a86594b7-6ffd-4efc-b61d-194b6afac555.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the aggregate first along with groupby
  prefs: []
  type: TYPE_NORMAL
- en: 'The `size()` function helps to find the number of occurrences of each `Category`.
    After computing `size`, let''s explore the transformation ability of `groupby`
    by sorting the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f44a750b-9060-42c4-bf4c-903a4ae1c2f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregation of size after sorting
  prefs: []
  type: TYPE_NORMAL
- en: 'The key or grouping object need not necessarily be an existing column; it can
    also be a function defining a grouping rule. For example, from `OrderDate`, we
    can extract the year and then `groupby` the year in which orders were placed.
    For this, the index is first set to `OrderDate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2590d6d-1154-4c13-8a81-cb716d75dfb4.png)'
  prefs: []
  type: TYPE_IMG
- en: Groupby to group variables created via a custom& function
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to group by more than one key. Here, let''s group by `ShipMode `and
    `Category `to aggregate by the number of observations. The `groupby` function
    accepts multiple variables as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06986d90-88b0-4d56-a6de-a971031143e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregate of size across two grouping variables
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_group()` attribute of the `groupby` function allows data to be filtered
    by one category out of all of the categories available in the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc9c1c3-fabf-4aa7-b6d0-56188829e0ec.png)'
  prefs: []
  type: TYPE_IMG
- en: The `get_group` attribute of groupby
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groupby` object produced by the `groupby` function is iterable. Let''s
    iterate over a simple `groupby` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fa6ede3-19f0-4fe7-9bab-829bfa19904c.png)'
  prefs: []
  type: TYPE_IMG
- en: Iterating through the groupby object
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of grouping by a column name, an index can also be used. When using
    an index, the level can be specified in place of the index name. Let''s set `Region `as
    an index to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1c1c5b2-5987-4053-a759-2c3cf5f80dcc.png)'
  prefs: []
  type: TYPE_IMG
- en: Grouping with index
  prefs: []
  type: TYPE_NORMAL
- en: '`groupby `aggregations need not always occur along a column. If required, items
    can be grouped and aggregated along a row by changing the `axis` argument. The
    default setting of the `axis` argument is `0`. Changing it to `axis =  1 `groups
    items along a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using groupby with a MultiIndex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore how the `groupby` function works for hierarchically indexed data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we can assign two indices to the sample sales data, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8596f393-eefc-4ad1-938c-d96d733d66a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Snapshot of multi-indexed data
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping by an index can be done by specifying either the level number or the
    index name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce9d8a8b-c144-40a7-9741-534456bd86c2.png)'
  prefs: []
  type: TYPE_IMG
- en: The level attribute of groupby
  prefs: []
  type: TYPE_NORMAL
- en: 'The `level` parameter can take names as well instead of numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11a3d0a5-81ae-4919-bc1f-6eaa0f1f2701.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the level name to group by
  prefs: []
  type: TYPE_NORMAL
- en: 'Index names can be used directly as keys, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f61d3aeb-42b1-4124-846d-b85e16b75612.png)'
  prefs: []
  type: TYPE_IMG
- en: Providing index names as the key
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple indices can also be passed through the `level` argument of `groupby `to
    obtain the same result as the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fab41586-1523-4031-99d5-d18694ec280b.png)'
  prefs: []
  type: TYPE_IMG
- en: Groupby for multiple indexes
  prefs: []
  type: TYPE_NORMAL
- en: 'When grouping by index, the aggregation functions can directly take up the
    `level` parameter to enable splitting across groups. Here, we have grouped across
    both levels by specifying the `level` number. Instead of the `level` number, the
    index name can also be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/743f2b0e-14f0-4967-a404-7f3f48f79a3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Multi-index grouping with the level parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'To group by both index and column name, the following method can be used. The
    level number provided here can also be replaced with the level name. Instead of
    using the `Grouper` function, the index name and column name can be provided as
    a list of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff2ca38a-32ab-4df0-9038-8b662d7b0826.png)'
  prefs: []
  type: TYPE_IMG
- en: Using normal columns and index columns together for grouping
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take `groupby` a notch further and apply some data transformation to
    the results. We will begin by computing the ratio of total sales, quantity, profit,
    and discount with respect to the overall `Sales`, `Quantity`, `Profit`, and `Discount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74a25962-4717-44d9-aee1-11f24a7c6d37.png)'
  prefs: []
  type: TYPE_IMG
- en: Groupby to evaluate complex calculations
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in a series. Remember the `transpose` function from NumPy? Similarly,
    a DataFrame can be transposed as well. However, the output just obtained is a
    series and not a DataFrame. Before transposing, the series has to be converted
    to a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52fe431e-0691-4cfb-b26f-0247d8d4444b.png)'
  prefs: []
  type: TYPE_IMG
- en: Intermediate result of data transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'The index label in the result is `0`. Let''s rename it to a more appropriate
    label using the following snippet. The output is also shown in the screenshot
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10b645bc-aeeb-4838-89cc-254374fff7f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Result of data transformation
  prefs: []
  type: TYPE_NORMAL
- en: Using the aggregate method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In all of the previous use cases, we used sum aggregation. We were directly
    able to use `sum` without going through the `aggregate` function of Python. The `sum()`
    function that we used is a Cython-optimized implementation. Some other Cython-optimized
    implementations are `mean`, `std`, and `sem` (standard error of the mean). To
    implement other functions or a combination of aggregations, the `aggregate` function
    comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aea7e66-b914-4d4b-95de-20fa6004e452.png)'
  prefs: []
  type: TYPE_IMG
- en: Use of the aggregate function
  prefs: []
  type: TYPE_NORMAL
- en: All the rules discussed in the sections on handling multiple keys and indices
    are applicable here as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that when using multiple keys or Multiindex, the result has a hierarchical
    ordering in indices. To overcome this, you can use the `reset_index` attribute
    of DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71375e84-b550-4424-86a7-a0094780b43d.png)'
  prefs: []
  type: TYPE_IMG
- en: The aggregate function for multiple columns
  prefs: []
  type: TYPE_NORMAL
- en: 'The index of the output can be reset using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fc7c293-f9bb-4314-813e-4bbd3c482d32.png)'
  prefs: []
  type: TYPE_IMG
- en: The aggregate function for multiple grouping variables
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve the same results, in place of `reset_index`, the `as_index` parameter
    of `groupby` can be set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the implementation of the `sum` function, the following is a list of other
    functions that can be applied to `groupby` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `mean()` | Compute mean of groups |'
  prefs: []
  type: TYPE_TB
- en: '| `sum()` | Compute sum of group values |'
  prefs: []
  type: TYPE_TB
- en: '| `size()` | Compute group sizes |'
  prefs: []
  type: TYPE_TB
- en: '| `count()` | Compute count of group |'
  prefs: []
  type: TYPE_TB
- en: '| `std()` | Standard deviation of groups |'
  prefs: []
  type: TYPE_TB
- en: '| `var()` | Compute variance of groups |'
  prefs: []
  type: TYPE_TB
- en: '| `sem()` | Standard error of the mean of groups |'
  prefs: []
  type: TYPE_TB
- en: '| `describe()` | Generate descriptive statistics |'
  prefs: []
  type: TYPE_TB
- en: '| `first()` | Compute first of group values |'
  prefs: []
  type: TYPE_TB
- en: '| `last()` | Compute last of group values |'
  prefs: []
  type: TYPE_TB
- en: '| `nth()` | Take nth value, or a subset if n is a list |'
  prefs: []
  type: TYPE_TB
- en: '| `min()` | Compute min of group values |'
  prefs: []
  type: TYPE_TB
- en: '| `max()` | Compute max of group values |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: List of all aggregate functions'
  prefs: []
  type: TYPE_NORMAL
- en: Applying multiple functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For any DataFrame, a list of aggregations can be performed after applying `groupby`.
    In the following example, the mean and standard deviation have been computed for
    `Sales` and `Quantity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2f99b80-8e48-4fd2-ac16-5e5b614b4c63.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple aggregations
  prefs: []
  type: TYPE_NORMAL
- en: Note that hierarchy has also been introduced in the column index. `agg` is a
    short form of aggregate. These aggregations will exclude any NAs found for computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, columns were created with the `mean` and `std `labels.
    Let''s try renaming them. The `rename` argument maps the new name onto the old
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac9f0eda-4a19-4d7b-92d5-6db90a724b2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Different aggregates for each column
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply selected functions to selected columns, the following convention can
    be used. For example, here, the sum of `Sales` and the mean of `Quantity` have
    been computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8b130f1-5fbf-4e92-8fbf-6c04d063d6ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Renaming columns after aggregation
  prefs: []
  type: TYPE_NORMAL
- en: The transform() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `transform` function in `groupby` is used to perform transformation operations
    on a `groupby` object. For example, we could replace NaN values in the `groupby`
    object using the `fillna` method. The resultant object after using `transform`
    has the same size as the original `groupby` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce NAs into the sample sales data. The following code injects
    NAs into 25% of the records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd700e6-42e7-45e6-8ec1-b18d49204f91.png)'
  prefs: []
  type: TYPE_IMG
- en: Snapshot of data with NAs inserted
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the four quantitative variables contain NAs in 25% of the rows, and `Category`
    is set as the index. A simple `groupby` and `count` aggregation will give the
    number of non-NA values in each column for each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b00bfdf-e910-44c3-b27a-8634e551bc7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Count of non-NA values
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transform()` function fills the NAs with the mean of each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04cf6412-aa6b-4a05-8652-26f60e0f95ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Using transform to fill NAs
  prefs: []
  type: TYPE_NORMAL
- en: 'The result shows that `transform()` performs group-specific NA handling. The
    count of non-NAs can be seen to have increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/813570b2-6ab7-46b3-9e0a-7f7026e60a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Count of non-NAs after transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the operation, let''s compare averages of the groups before and after
    transformation. The outputs from the two methods are found to be equal as shown
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65edcccf-0941-422f-acae-0f9c0ba45e96.png)'
  prefs: []
  type: TYPE_IMG
- en: Group means before transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the mean using the object obtained from the transform method can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/324c6a91-1599-45b7-a3bd-181fa2418e25.png)'
  prefs: []
  type: TYPE_IMG
- en: Group means after transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions, such as `bfill()` (backward fill), `ffill()` (forward fill),
    `fillna()`, and `shift()` can perform transformation by themselves, without the
    need for the `transform()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00dc4098-1d60-4637-8836-8a7e224917c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Transformation with backward fill
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations such as `rolling()`, `resample()`, and `expanding()` can also be
    used as methods on `groupby`. `rolling() `aggregates values in moving windows,
    `expanding()` cumulates the aggregates, and `resample()` helps to bring regular
    frequency to time-series data with forward fill or backward fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example of `expanding()` calculates a cumulative sum within each
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filter` method enables us to apply filtering to a `groupby` object to result
    in a subset of the initial object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s apply `filter `to the sample sales data to compute only the sums of
    those groups whose length is more than `10000`, when grouped across `Category`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4430aea-88b6-4c3a-8304-ec0ab74c01d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Filtering with groupby
  prefs: []
  type: TYPE_NORMAL
- en: Now, as you can see, filtering removes the `Furniture` category, whose length
    is less than `10000`.
  prefs: []
  type: TYPE_NORMAL
- en: Merging and joining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various functions that can be used to merge and join pandas data
    structures, which include the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`concat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`append`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concat function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `concat` function is used to join multiple pandas data structures along
    a specified axis and possibly perform union or intersection operations along other
    axes. The following command explains the `concat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements of the `concat` function can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `objs` function: A list or dictionary of Series, DataFrame, or Panel objects
    to be concatenated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `axis` function: The axis along which the concatenation should be performed.
    `0` is the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `join` function: The type of join to perform when handling indexes on other
    axes. The `''outer''` function is the default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `join_axes` function: This is used to specify exact indexes for the remaining
    indexes instead of doing an outer/inner join.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `keys` function: This specifies a list of keys to be used to construct
    a MultiIndex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an explanation of the remaining options, please refer to the documentation
    at [http://pandas.pydata.org/pandas-docs/stable/merging.html](http://pandas.pydata.org/pandas-docs/stable/merging.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration of the workings of `concat` using our stock price examples
    from earlier chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We now take various slices of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we perform concatenation by specifying an outer join, which concatenates
    and performs a union on all three DataFrames and includes entries that do not
    have values for all the columns by inserting `NaN` for such columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify an inner join that performs concatenation but only includes
    rows that contain values for all the columns in the final DataFrame by throwing
    out rows with missing columns; that is, it takes the intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The third case enables us to use the specific index from the original DataFrame
    to join on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this last case, we see that the `YHOO `row was included even though it wasn''t
    contained in any of the slices that were concatenated. In this case, however,
    the values for all the columns are `NaN`. Here is another illustration of `concat`,
    but this time, it is on random statistical distributions. Note that in the absence
    of an `axis` argument, the default axis of concatenation is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using append
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`append` is a simpler version of `concat` that concatenates along `axis=0`.
    Here is an illustration of its use, where we slice out the first two rows and
    the first three columns of the `stockData` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And the remaining rows can be obtained as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use `append` to combine the two DataFrames from the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to maintain the order of columns similar to the original DataFrame,
    we can apply the `reindex_axis` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that, for the first two rows, the value of the last two columns is `NaN`
    since the first DataFrame only contained the first three columns. The `append`
    function does not work in places, but it returns a new DataFrame with the second
    DataFrame appended to the first.
  prefs: []
  type: TYPE_NORMAL
- en: Appending a single row to a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can append a single row to a DataFrame by passing a series or dictionary
    to the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In order for this to work, you must pass the `ignore_index=True` argument so
    that the `index [0,1,2,3]` in `algoDF` is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: SQL-like merging/joining of DataFrame objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `merge` function is used to join two DataFrame objects similar to those
    used in SQL database queries. It results in a merged DataFrame. DataFrame objects
    are analogous to SQL tables. The following command explains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a summary of the `merge` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `left` argument: This is the first DataFrame object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `right` argument: This is the second DataFrame object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `how` argument: This is the type of join and can be inner, outer, left,
    or right. The default is inner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `on` argument: This shows the names of columns to join on as join keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `left_on` and `right_on` arguments: These show the left and right `DataFrame`
    column names to join on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `left_index` and `right_index` arguments: These have a Boolean value. If
    this is `True`, use the left or right `DataFrame` index/row labels to join on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sort` argument: This has a Boolean value. The default `True` setting results
    in a lexicographical sort. Setting the default value to `False` may improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `suffixes` argument: The tuple of string suffixes to be applied to overlapping
    columns. The defaults are `''_x''` and `''_y''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `copy` argument: The default `True` value causes data to be copied from
    the passed `DataFrame` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source of the preceding information is [http://pandas.pydata.org/pandas-docs/stable/merging.html](http://pandas.pydata.org/pandas-docs/stable/merging.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create two DataFrames – left and right – to understand merging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4c4680b-f7b6-4f34-aefc-0975de88893a.png)'
  prefs: []
  type: TYPE_IMG
- en: Left DataFrame for merge
  prefs: []
  type: TYPE_NORMAL
- en: 'The right dataframe can be viewed using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a8ccd95-b5df-41e8-8a68-554e4d77df84.png)'
  prefs: []
  type: TYPE_IMG
- en: Right dataframe for merge
  prefs: []
  type: TYPE_NORMAL
- en: 'The DataFrames have five rows each, with `Category `and `Region` as the keys.
    Of these five rows, two rows from each DataFrame share the same set of keys. Let''s
    perform a merge on both keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7503539b-acd4-44de-92d2-963dafb0c0db.png)'
  prefs: []
  type: TYPE_IMG
- en: Default inner merge
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `how` argument is set to `inner`, hence, in this scenario,
    an inner join is performed. Now, let''s perform a `left` join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f67e3ca-961f-431d-9510-1d54d2b9d21a.png)'
  prefs: []
  type: TYPE_IMG
- en: Left merge
  prefs: []
  type: TYPE_NORMAL
- en: 'In a left join, all the rows found in the left DataFrame are included in the
    result. The rows of `left` not found in `right` get NAs appended to the columns
    originating from the right DataFrame – `Discount` and `Profit` – for which keys
    do not exist in the left DataFrame. A right join would be the exact opposite:
    the result would contain all the rows from the right dataframe and NAs would be
    appended to `Sales` and `Quantity `for cases where keys are found in `left` but
    not in the right DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6afd4e55-db7d-4a5d-b3df-7053fd520fff.png)'
  prefs: []
  type: TYPE_IMG
- en: Right merge
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an outer join, no rows are excluded and NAs are appended as
    necessary for missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/495b4f94-04f1-441e-96a1-16ba7e07555a.png)'
  prefs: []
  type: TYPE_IMG
- en: Outer merge
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s investigate the behavior of an outer merge when duplicate entries of
    a key are found. The following command duplicates the last key combination of
    the `left `DataFrame. The keys with the `Office Supplies `category and the `Canada `region
    occur twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87a6f49b-a6d7-4901-93b1-4afc77d46ea3.png)'
  prefs: []
  type: TYPE_IMG
- en: Inserting duplicates in the left DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the outer merge is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e244184e-5af2-47f4-a354-555f388261a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Outer merge for data with duplicates
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `right` DataFrame gets merged on the `left` DataFrame for
    each occurrence of the key and duplicates are not dropped. This behavior may not
    be desirable in huge datasets. It may be necessary to drop duplicates before merging.
    For such instances, the `validate` argument of `merge` helps to keep a check to
    support only one-to-one merges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0f88a15-4dc6-425a-8b82-2cade3322aa0.png)'
  prefs: []
  type: TYPE_IMG
- en: Error indicating duplicates in the DataFrame when merging
  prefs: []
  type: TYPE_NORMAL
- en: 'The `indicator` argument of merge indicates the source of a row – `left`, `right`,
    or both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a1f9823-b09b-449e-8675-733a1dd46390.png)'
  prefs: []
  type: TYPE_IMG
- en: The indicator parameter of merge
  prefs: []
  type: TYPE_NORMAL
- en: The join function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DataFrame.join` function is used to combine two DataFrames that have different
    columns with nothing in common. Essentially, this does a longitudinal join of
    two DataFrames. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7b1434b-8f15-41a0-83c5-ac228d2057e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Default left join
  prefs: []
  type: TYPE_NORMAL
- en: '`join` is almost identical to `merge`, the difference being that, while merge
    works for DataFrames that share identical keys, `join` combines DataFrames by
    the row-index. By default, the `join` function performs a left join. The other
    types of join can be specified through the `how` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71820881-b334-4ba1-b4c1-a263e27dc44e.png)'
  prefs: []
  type: TYPE_IMG
- en: Right join
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner join can be performed as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c4ff5cd-a51a-4b8f-b9a6-fd3b0ecc61e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Inner join
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer join can be performed as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9321a282-86b3-4d85-ba09-52f9b244cc59.png)'
  prefs: []
  type: TYPE_IMG
- en: Outer join
  prefs: []
  type: TYPE_NORMAL
- en: If the two DataFrames being joined have a common column over which the join
    should be performed, the key or list of keys can be mentioned in the `on` parameter
    of the `join` function. This is just the same as a `merge` function.
  prefs: []
  type: TYPE_NORMAL
- en: Pivots and reshaping data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section deals with how you can reshape data. Sometimes, data is stored
    in what is known as a *stacked* format. Here is an example of stacked data using
    the `PlantGrowth` dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This data consists of results from an experiment that compared the dried weight
    yields of plants that were obtained under a **control** (**ctrl**) and two different
    treatment conditions (**trt1 **and **trt2**). Suppose we wanted to do some analysis
    on this data by group value. One way to do this would be to use a logical filter
    on the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be tedious, so we would instead like to pivot/unstack this data and
    display it in a form that is more conducive to analysis. We can do this using
    the `DataFrame.pivot` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, a DataFrame is created with columns corresponding to the different values
    of a group, or, in statistical parlance, levels of the factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more examples of pivoting on `salesdata.csv` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output. This gives the results for all the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da032d62-e5ed-4d61-b8cf-a27ea1d6512a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we specify a `columns` parameter with a variable name, all the categories
    in that variable become separate columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the output of the preceding code would be as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/864919be-166e-4a7f-950d-388a0fb46ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Multi-indexed pivots are also possible, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d2912c3-41a9-47cc-b692-ee544e9dc9b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A different aggregate function, other than default average, or a custom function
    can be applied for aggregation as shown in the example following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54a535d8-64f3-479d-8055-d2e50630bd07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some more important tips and tricks to keep in mind while using `pivot_tables`
    are listed following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you expect missing values in your pivot table, then use `fill.values=0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want totals at the end, use `margins=TRUE`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass different aggregate functions to different value columns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Stacking and unstacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to pivot functions, the stack and unstack functions are also available
    on Series and DataFrames, which work on objects containing MultiIndex.
  prefs: []
  type: TYPE_NORMAL
- en: The stack() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When stacking, a set of column labels get converted to an index level. To explore
    stacking further, let''s use a DataFrame with a MultiIndex along the row-index
    and column-index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2d47143-71d1-4a0b-9a1b-0c05dc5c9d2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Hierarchical data for stacking and unstacking
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying `stack() `makes a wide DataFrame longer. Let''s apply `stack()` on
    the preceding DataFrame. The column labels on the last level get added to the
    MultiIndex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f573195b-a5cb-41a0-883b-9f63476744fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Result of stacking
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stack()` function accepts a `level` argument. In this case, the default
    level setting is `1`. Let''s try stacking at level `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f94af5a-13df-4bca-90cb-8a43704d76c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Stacking using the level parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of specifying level numbers, level names can also be specified when
    stacking. To stack multiple levels, a list of level names or level numbers can
    be passed to the `level` argument. However, the list cannot be a combination of
    both level names and level numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53a27fd4-b4cd-4a5b-844f-8764011dab5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Stacking multiple levels at once
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the attributes of the index after stacking. The `index` attribute
    of a DataFrame helps us understand the various levels, labels, and names of each
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2bf78e4-cded-4a41-bc98-a7471e103be4.png)'
  prefs: []
  type: TYPE_IMG
- en: Index properties after stacking
  prefs: []
  type: TYPE_NORMAL
- en: 'At times, stacking introduces missing values when there are no values for a
    certain combination of index and column name. Consider the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1985d13-8377-43f4-b81f-f379b458d33f.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling missing values when stacking
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon stacking, the `dropna` parameter of the `stack` function, which is set
    to `True` by default, automatically drops all NAs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eee33c1-dbd7-47d7-86a6-0e5a23da2279.png)'
  prefs: []
  type: TYPE_IMG
- en: dropna set to False when stacking
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it will drop the rows with all missing values, as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8dc1b7ae-f9e8-42f3-8c5e-cd744a0c5c92.png)'
  prefs: []
  type: TYPE_IMG
- en: Dropping NAs by default when stacking
  prefs: []
  type: TYPE_NORMAL
- en: The unstack() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `unstack` function performs the reverse operation of the `stack` function.
    It converts long DataFrames to a wider format. Let''s unstack the multi-level
    indexed sales data. The last level is unstacked by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b6d4218-e6f7-485d-b16a-45f27fe3df43.png)'
  prefs: []
  type: TYPE_IMG
- en: Unstacking
  prefs: []
  type: TYPE_NORMAL
- en: Just like `stack`, `unstack` has a `level` parameter. This `level` parameter
    accepts a level number, a level name, or a list of level names/level numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any missing values created when unstacking can be handled using the `fill_value`
    argument of the `unstack` function. Consider the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8630f903-1d61-488d-9e42-13e106518daf.png)'
  prefs: []
  type: TYPE_IMG
- en: Snapshot of data
  prefs: []
  type: TYPE_NORMAL
- en: 'Unstacking the preceding DataFrame introduces NAs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1ef3ab3e-d937-426c-bbd3-ddf901936f90.png)'
  prefs: []
  type: TYPE_IMG
- en: Unstacking without handling missing data
  prefs: []
  type: TYPE_NORMAL
- en: 'We can impute the missing cells with a value of our choice using the `fill_value`
    method. Following are the missing values have been replaced by 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f7a65c30-3f69-46b8-bda7-e7bea17a0ab4.png)'
  prefs: []
  type: TYPE_IMG
- en: Filling NAs with 0 when unstacking
  prefs: []
  type: TYPE_NORMAL
- en: Other methods for reshaping DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various other methods that are related to reshaping DataFrames; we'll
    discuss them here.
  prefs: []
  type: TYPE_NORMAL
- en: Using the melt function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `melt` function enables us to transform a DataFrame by designating some
    of its columns as ID columns, ensuring they remain as columns with the remaining
    non-ID columns treated as *variable* columns and are pivoted and become part of
    a name-value two-column scheme. ID columns uniquely identify a row in a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of those non-ID columns can be customized by supplying the `var_name`
    and `value_name` parameters. The use of `melt` is perhaps best illustrated by
    an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The pandas.get_dummies() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function is used to convert a categorical variable into an indicator DataFrame,
    which is essentially a truth table of possible values of the categorical variable.
    An example of this is the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The source of the preceding data is [http://vincentarelbundock.github.io/Rdatasets/csv/datasets/PlantGrowth.csv](http://vincentarelbundock.github.io/Rdatasets/csv/datasets/PlantGrowth.csv).
  prefs: []
  type: TYPE_NORMAL
- en: pivot table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pandas `pivot_table` function is more advanced than the `pivot` function
    in several ways. Let''s discuss some interesting parameters of the `pivot_table`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: The DataFrame object that is to be reshaped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: A column or a list of columns that are to be aggregated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: The key across which grouping of pivot index occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columns`: The key with respect to which grouping of the `pivot` column occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aggfunc`: The function to use for aggregation, such as `np.mean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s pivot the sample sales data to slice and dice `Sales` across `Category`
    and `ShipMode`. Note that when `aggfunc` is empty, the mean is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c9f51e3-4a80-4bbc-9bef-8621031db69a.png)'
  prefs: []
  type: TYPE_IMG
- en: Pivot table from pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is possible to have multiple values for `values`, `index`, `column`,
    or `aggfunc`. Those multiple values can be passed as a list. Let''s calculate
    `mean` for `Sales` and `sum` for `Quantity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1456c041-5da8-41c0-a546-e79e891deceb.png)'
  prefs: []
  type: TYPE_IMG
- en: Pivot table with multiple aggregations
  prefs: []
  type: TYPE_NORMAL
- en: Through `pivot_table`, DataFrames with hierarchical indices can be created.
    The `fill_value` and `dropna` parameters of the `pivot_table` function help in
    handling missing values.
  prefs: []
  type: TYPE_NORMAL
- en: Transpose in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `transpose` function in pandas is similar to that of NumPy. It interchanges
    rows and columns. Let''s find the transpose of the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ab29d7a-bafd-482a-8f9f-fbab762e43f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Data to be transposed
  prefs: []
  type: TYPE_NORMAL
- en: 'In the transpose of the DataFrame, the column labels and row indices are swapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bff6518d-61aa-4a4a-a2fb-ede17f78f66c.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of transpose
  prefs: []
  type: TYPE_NORMAL
- en: '`T` acts as an accessor to the `transpose` function and can be used as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `swaplevel` function helps to interchange the levels within any axis. Consider
    the following DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d98f001-fcf4-4916-9358-4fd619e042f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Data for swaplevel and swapaxes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s switch the positions of the `Category` and `ShipMode `index levels. Level
    numbers or level names can be provided as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b2d0fe8-1ee8-41c4-a144-b659540c7f08.png)'
  prefs: []
  type: TYPE_IMG
- en: Levels swapped
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, such switches can also be executed on the column labels by setting
    `axis` to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bac432a-2314-4130-ba8a-30df215a7f1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Levels swapped along axis 1
  prefs: []
  type: TYPE_NORMAL
- en: 'The `swapaxes` function is functionally similar to the `transpose` function.
    The following shows the `swapaxes` function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d40cbf8-aa4d-426a-a215-ef2a8393387e.png)'
  prefs: []
  type: TYPE_IMG
- en: Axis swapped
  prefs: []
  type: TYPE_NORMAL
- en: Squeeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`squeeze` helps to convert a 1D DataFrame to a series. Let''s consider a 1D
    DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42d5196e-b6c1-4cbf-af15-edcb8d8df314.png)'
  prefs: []
  type: TYPE_IMG
- en: Data to squeeze
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the preceding object has been deciphered here – it is a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70a1b703-3992-4942-870b-3854bf22cf61.png)'
  prefs: []
  type: TYPE_IMG
- en: Object type before squeezing
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s apply the `squeeze` function and find the object type. The required
    snippet and the output looks as shown following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cb19268e-6d19-4e62-a6a6-107dd298f679.png)'
  prefs: []
  type: TYPE_IMG
- en: Object type after squeezing
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `squeeze` transforms the DataFrame into a series.
  prefs: []
  type: TYPE_NORMAL
- en: nsmallest and nlargest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `nsmallest` and `nlargest `functions are extremely useful for returning
    the n smallest and n largest rows after ordering by the desired column.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the sample sales data, let''s find the `3` smallest records by `Profit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/087b2825-526c-48bd-a110-585dcc3f4b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure6.73: Result of nsmallest'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ordering can also be done with respect to multiple columns, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bbd3fc8-f873-470d-a5be-a1595c485d06.png)'
  prefs: []
  type: TYPE_IMG
- en: Result of nlargest
  prefs: []
  type: TYPE_NORMAL
- en: These functions – `nsmallest` and `nlargest` have the `keep` parameter to decide
    how duplicates are handled. It helps to choose either the first occurrence, the
    last occurrence, or to retain all duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter added to our arsenal of pandas tricks to aggregate, join, and
    transform data. Here is a quick recap of the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupby` creates groups of rows – one group for each category in a categorical
    variable (or a combination of categories across categorical variables).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `groupby`, the same analysis can be performed on different groups efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly shaped DataFrames can be concatenated or appended to perform analysis
    simultaneously for the entire dataset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL-like joining or merging between DataFrames is also possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wide data can be made longer, or vice versa, depending on the requirement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas can handle multi-index data and there are functions to convert multi-index
    data to single-index data and vice versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spreadsheet operations such as pivot tables and transposes are possible and
    provide more flexibility than in spreadsheets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss and elaborate on the methods, syntax, and
    usage of some of these special data operations in pandas.
  prefs: []
  type: TYPE_NORMAL
