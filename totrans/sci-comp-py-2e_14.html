<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Input and Output
                </header>
            
            <article>
                
<p>In this chapter, we will cover some options for handling data files. Depending on the data and the desired format, there are several options for reading and writing. We will show some of the most useful alternatives.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>File handling</li>
<li>NumPy methods</li>
<li>Pickling</li>
<li>Shelves</li>
<li>Reading and writing Matlab data files</li>
<li>Reading and writing images</li>
</ul>
<h1 id="uuid-46e178da-eee3-4165-bb27-af904279d0c9">14.1 File handling</h1>
<p>File <strong>input and output</strong>(<strong>I/O</strong>) is essential in a number of scenarios, for example:</p>
<ul>
<li>Working with measured or scanned data. Measurements are stored in files that need to be read in order to be analyzed.</li>
<li>Interacting with other programs. Save results to files so that they can be imported into other applications, and vice-versa.</li>
<li>Storing information for future reference or comparisons.</li>
<li>Sharing data and results with others, possibly on other platforms using other software.</li>
</ul>
<p>In this section, we will cover how to handle file I/O in Python.</p>
<h2 id="uuid-32bafb34-dd7b-430f-a4aa-91418168ce5e">14.1.1 Interacting with files</h2>
<p>In Python, an object of the type<span> </span><kbd>file</kbd><span> </span>represents the contents of a physical file stored on a disk. A new object<span> </span><kbd>file</kbd><span> </span>may be created using the following syntax:</p>
<pre># creating a new file object from an existing file<br/>myfile = open('measurement.dat','r')</pre>
<p>The contents of the file may be accessed, for instance, with this command:</p>
<pre>print(myfile.read())</pre>
<p>Usage of file objects requires some care. The problem is that a file has to be closed before it can be re-read or used by other applications, which is done using the following syntax:</p>
<pre>myfile.close() # closes the file object</pre>
<p>It is not that simple because an exception might be triggered before the call to<span> </span><kbd>close</kbd><span> </span>is executed, which will skip the closing code (consider the following example). A simple way to make sure that a file will be properly closed is to use context managers. This construction, using the keyword <kbd>with</kbd>, is explained in more detail in <a href="9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml">Section 12.1.3</a>: <em>Context </em><em>Managers – the with statement</em>. Here is how it is used with files:</p>
<pre>with open('measurement.dat','r') as myfile: 
     ... # use myfile here</pre>
<p>This ensures that the file is closed when you exit the <kbd>with</kbd> block, even if an exception is raised inside the block. The command works with context manager objects. We recommend that you read more on context managers in <a href="9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml">Section 12.1.3</a>:<span> </span><em>Context</em><br/>
<em>Managers – the with statement</em>. Here is an example showing why the construct<span> </span><kbd>with</kbd><span> </span>is desirable:</p>
<pre>myfile = open(name,'w')
myfile.write('some data')
a = 1/0
myfile.write('other data')
myfile.close()</pre>
<p>An exception is raised before the file is closed. The file remains open, and there is no guarantee of what data is written in the file or when it is written. Hence, the proper way to achieve the same result is this:</p>
<pre>with open(name,'w') as myfile:
    myfile.write('some data')
    a = 1/0
    myfile.write('other data')</pre>
<p>In that case, the file is cleanly closed just after the exception (here, <kbd>ZeroDivisionError</kbd>) is raised. Notice also that there is no need to close the file explicitly.</p>
<h2 id="uuid-36c111ec-6a50-45e4-b347-f488cce9d4d8">14.1.2 Files are iterables</h2>
<p>A file is, in particular, iterable (see <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.3</a>: <em>Iterable objects</em>). Files iterate their lines:</p>
<pre>with open(name,'r') as myfile:
    for line in myfile:
        data = line.split(';')
        print(f'time {data[0]} sec temperature {data[1]} C')</pre>
<p>The lines of the file are returned as strings. The string method<span> </span><kbd>split</kbd><span> </span>is a possible tool to convert the string to a list of strings; for example:</p>
<pre>data = 'aa;bb;cc;dd;ee;ff;gg'
data.split(';') # ['aa', 'bb', 'cc', 'dd', 'ee', 'ff', 'gg']

data = 'aa bb cc dd ee ff gg'
data.split(' ') # ['aa', 'bb', 'cc', 'dd', 'ee', 'ff', 'gg']</pre>
<p>Since the <span>object</span><span> </span><kbd>myfile</kbd><span> </span>is iterable, we can also do a direct extraction into a list, as follows:</p>
<pre>data = list(myfile)</pre>
<h2 id="uuid-fca54171-7335-481a-b964-2a224401e1c9">14.1.3 File modes</h2>
<p>As you can see in these examples of file handling, the function<span> </span><kbd>open</kbd><span> </span>takes at least two arguments. The first is obviously the filename, and the second is a string describing the way in which the file will be used. There are several such modes for opening files. The basic ones are as follows:</p>
<pre>with open('file1.dat','r') as ...  # read only
with open('file2.dat','r+') as ...  # read/write
with open('file3.dat','rb') as ...  # read in byte mode  
with open('file4.dat','a') as ...  # append (write to the end of the file)
with open('file5.dat','w') as ... # (over-)write the file
with open('file6.dat','wb') as ... # (over-)write the file in byte mode</pre>
<p>The modes<span> </span><kbd>'r'</kbd>,<span> </span><kbd>'r+'</kbd>, and <kbd>'a'</kbd><span> </span>require that the file exists, whereas<span> </span><kbd>'w'</kbd><span> </span>will create a new file if no file with that name exists. Reading and writing with<span> </span><kbd>'r'</kbd><span> </span>and<span> </span><kbd>'w'</kbd><span> </span>is most common, as you saw in previous examples.</p>
<p>Consider an example of opening a file and adding data at the end of the file without modifying what is already there using the append <span>mode</span><span> </span><kbd>'a'</kbd>. Note the line break,<kbd>\n</kbd>:</p>
<pre>_with open('file3.dat','a') as myfile:
    myfile.write('something new\n')</pre>
<h1 id="uuid-e35f448b-a59b-4ed2-9ddd-db7001d4bb47">14.2 NumPy methods</h1>
<p>NumPy has built-in methods for reading and writing NumPy array data to text files. These are <kbd>numpy.loadtxt</kbd> and <kbd>numpy.savetxt</kbd>.</p>
<h2 id="uuid-5e5f7431-8c19-4bda-992e-c13bddd7f51c">14.2.1 savetxt</h2>
<p>Writing an<span> </span>array to a text file is simple:</p>
<pre>savetxt(filename,data)</pre>
<p>There are two useful parameters given as strings,<span> </span><kbd>fmt</kbd>,<span> </span>and<span> </span><kbd>delimiter</kbd>, which control the format and the delimiter between columns. The defaults are space for the delimiter and<span> </span><kbd>%.18e</kbd><span> </span>for the format, which corresponds to the exponential format with all digits. The formatting parameters are used as follows:</p>
<pre>x = range(100) # 100 integers
savetxt('test.txt',x,delimiter=',') # use comma instead of space
savetxt('test.txt',x,fmt='%d') # integer format instead of float with e</pre>
<h2 id="uuid-e51d592f-6a72-4160-bd79-88932b6702a4">14.2.3 loadtxt</h2>
<p>Reading to an array from a text file is done with the help of the following syntax:</p>
<pre>filename = 'test.txt'
data = loadtxt(filename)</pre>
<p>Due to the fact that each row in an array must have the same length, each row in the text file must have the same number of elements. Similar to<span> </span><kbd>savetxt</kbd>, the default values are<span> </span><kbd>float</kbd><span> </span>and the delimiter is<span> a </span>space. These can be set using the <span>parameters</span><span> </span><kbd>dtype</kbd><span> </span>and<span> </span><kbd>delimiter</kbd>. Another useful parameter is<span> </span><kbd>comments</kbd>, which can be used to mark what symbol is used for comments in the data file. An example of using the formatting parameters is as follows:</p>
<pre>data = loadtxt('test.txt',delimiter=';')    # data separated by semicolons
<br/># read to integer type, comments in file begin with a hash character<br/>data = loadtxt('test.txt',dtype=int,comments='#')</pre>
<h1 id="uuid-8ddcb4dd-ae2c-4c4a-9307-67d31400326a">14.3 Pickling</h1>
<p>The read and write methods you just saw convert data to strings before writing. Complex types (such as objects and classes) cannot be written this way. With Python's <span>module</span> <kbd>pickle</kbd>, you can save any object and also multiple objects to a file.</p>
<p>Data can be saved in plain-text (ASCII) format or using a slightly more efficient binary format. There are two main methods: <kbd>dump</kbd>, which saves a pickled representation of a Python object to a file, and<span> </span><kbd>load</kbd>, which retrieves a pickled object from the file. The basic usage is like this:</p>
<pre>import pickle
with open('file.dat','wb') as myfile:
    a = random.rand(20,20)
    b = 'hello world'
    pickle.dump(a,myfile)    # first call: first object
    pickle.dump(b,myfile)    # second call: second object

import pickle
with open('file.dat','rb') as myfile:
    numbers = pickle.load(myfile) # restores the array
    text = pickle.load(myfile)    # restores the string</pre>
<p>Note the order in which the two objects are returned. Besides the two main methods, it is sometimes useful to serialize a Python object to a string instead of a file. This is done with<span> </span><kbd>dumps</kbd><span> </span>and<span> </span><kbd>loads</kbd>. Consider an example of serializing an array and a dictionary:</p>
<pre>a = [1,2,3,4]
pickle.dumps(a) # returns a bytes object
b = {'a':1,'b':2}
pickle.dumps(b) # returns a bytes object</pre>
<p>A good example of using<span> </span><kbd>dumps</kbd><span> </span>is when you need to write Python objects or NumPy arrays to a database. These usually have support for storing strings, which makes it easy to write and read complex data and objects without any special modules. Besides the <kbd>pickle</kbd> module, there is also an optimized version called<span> </span><kbd>cPickle</kbd>. It is written in C and is an option if you need fast reading and writing. The data produced by pickle and<span> </span><em>cPickle</em><span> </span>is identical and can be interchanged.</p>
<h1 id="uuid-ac131cc3-1fd6-4756-bf73-751d4f9ac8cb">14.4 Shelves</h1>
<p>Objects in dictionaries can be accessed by keys. There is a similar way to access particular data in a file by first assigning it a key. This is possible by using the module <kbd>shelve</kbd>:</p>
<pre>from contextlib import closing
import shelve as sv
# opens a data file (creates it before if necessary)
with closing(sv.open('datafile')) as data:
    A = array([[1,2,3],[4,5,6]])     
    data['my_matrix'] = A  # here we created a key</pre>
<p>In <a href="f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml">Section 14.1.1</a>: <em>Interacting with files</em><span>, </span>we saw that the built-in <span>command</span><span> </span><kbd>open</kbd><span> </span>generates a context manager, and we saw why this is important for handling external resources, such as files. In contrast to this command,<span> </span><kbd>sv.open</kbd> does not create a context manager by itself. The <span>command</span><span> </span><kbd>closing</kbd><span> </span>from the <span>module</span><span> </span><kbd>contextlib</kbd><span> </span>is needed to transform it into an appropriate context manager.</p>
<p>Consider the following example of restoring the file:</p>
<pre>from contextlib import closing
import shelve as sv
with closing(sv.open('datafile')) as data: # opens a data file
    A = data['my_matrix']  # here we used the key
    ...</pre>
<p>A <kbd>shelve</kbd> object has all dictionary methods, for example, keys and values, and can be used in the same way as a dictionary. Note that changes are only written in the file after one of the <span>methods</span><span> </span><kbd>close</kbd><span> </span>or<span> </span><kbd>sync</kbd><span> </span>has been called.</p>
<h1 id="uuid-64c334f1-eca5-4a36-9200-5fb7975dac48">14.5 Reading and writing Matlab data files</h1>
<p>SciPy has the ability to read and write data in Matlab's<span> </span><kbd>.mat</kbd><span> </span>file format using the module \pyth!scipy.io!. The commands are<span> </span><kbd>loadmat</kbd><span> </span>and<span> </span><kbd>savemat</kbd>.</p>
<p>To load data, use the following syntax:</p>
<pre>import scipy.io
data = scipy.io.loadmat('datafile.mat')</pre>
<p>The variable data now contains a dictionary, with keys corresponding to the variable names saved in the<span> </span><kbd>.mat</kbd><span> </span>file. The variables are in NumPy array format. Saving to<span> </span><kbd>.mat</kbd><span> </span>files involves creating a dictionary with all the variables you want to save (variable name and value). The command is then<span> </span><kbd>savemat</kbd>:</p>
<pre>data = {}
data['x'] = x
data['y'] = y
scipy.io.savemat('datafile.mat',data)</pre>
<p>This saves the NumPy arrays,<span> </span><kbd>x</kbd><span> </span>and<span> </span><kbd>y</kbd>, <span>in</span> Matlab's internal file format, thereby preserving variable names.</p>
<h1 id="uuid-69973013-c653-4d81-a101-49119bcd71eb">14.6 Reading and writing images</h1>
<p>The module <kbd>PIL.Image</kbd> comes with some functions for handling images. The following will read a<span> </span><em>JPEG</em><span> </span>image, print the shape and type, and then create a resized image, and write the new image to a file:</p>
<pre>import PIL.Image as pil   # imports the Pillow module

# read image to array<br/>im=pil.open("test.jpg")
print(im.size)   # (275, 183)  <br/>                 # Number of pixels in horizontal and vertical directions
# resize image
im_big = im.resize((550, 366))
im_big_gray = im_big.convert("L") # Convert to grayscale<br/><br/>im_array=array(im)
<br/>print(im_array.shape)<br/>print(im_array.dtype)   # unint 8<br/># write result to new image file
im_big_gray.save("newimage.jpg")</pre>
<p> </p>
<p>PIL creates an image object that can easily be converted to a NumPy array. As an array object, images are stored with pixel values in the range<span> </span><em>0...255</em> as 8-bit unsigned integers (<kbd>unint8</kbd>). The third shape value shows how many color channels the image has. In this case, <em>3</em><span> </span>means it is a color image with values stored in this order: red<span> </span><kbd>im_array[:,:,0]</kbd>, green<span> </span><kbd>im_array[:,:,1]</kbd>, and blue<span> </span><kbd>im_array[:,:,2]</kbd>. A grayscale image would only have one channel.</p>
<p>For working with images, the module <kbd>PIL</kbd> contains many useful basic image processing functions, including filtering, transforms, measurements, and conversion from a NumPy array to a <kbd>PIL</kbd> image object:</p>
<pre>new_image = pil.from_array(ima_array)</pre>
<h1 id="uuid-819a44a0-7fa4-4274-90c1-db9168efc0f4">14.7 Summary</h1>
<p>File handling is inevitable when dealing with measurements and other sources of a larger amount of data. Also, communication with other programs and tools is done via file handling.</p>
<p>You learned to see a file as a Python object, like others, with important methods such as <kbd>readlines</kbd><span> </span>and<span> </span><kbd>write</kbd>. We showed how files can be protected by special attributes, which may allow only read or write access.</p>
<p>The way you write to a file often influences the speed of the process. We saw how data is stored by pickling or by using the <span>method</span><span> </span><kbd>shelve</kbd>.</p>


            </article>

            
        </section>
    </body></html>