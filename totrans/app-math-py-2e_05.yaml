- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Trees and Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks are objects that contain *nodes* and *edges* between pairs of nodes.
    They can be used to represent a wide variety of real-world situations, such as
    distribution and scheduling. Mathematically, networks are useful for visualizing
    combinatorial problems and make for a rich and fascinating theory.
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, several different kinds of networks. We will mostly deal
    with simple networks, where edges connect two distinct nodes (so there are no
    self-loops), there is, at most, one edge between any two nodes, and all the edges
    are bidirectional. A *tree* is a special kind of network in which there are no
    cycles; that is, there are no lists of nodes in which each node is connected to
    the following node by an edge, and the final node is connected to the first. Trees
    are especially simple in terms of their theory because they connect several nodes
    with the fewest possible edges. A *complete network* is a network in which every
    node is connected to every other node by an edge.
  prefs: []
  type: TYPE_NORMAL
- en: Networks can be directed, where each edge has a source and a destination node
    or can carry additional attributes, such as weights. Weighted networks are especially
    useful in certain applications. There are also networks in which we allow multiple
    edges between two given nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create, manipulate, and analyze networks,
    and then apply network algorithms to solve various problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the literature, especially in mathematical texts, networks are more commonly
    called *graphs*. Nodes are sometimes called *vertices*. We favor the term network
    to avoid confusion with the more common usage of a graph to mean a plot of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating networks in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the basic characteristics of networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the adjacency matrix for a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating directed and weighted networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the shortest paths in a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantifying clustering in a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding minimal spanning trees and dominating sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will primarily use the NetworkX package for working with
    trees and networks. This package can be installed using your favorite package
    manager, such as `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We usually import this under the `nx` alias, following the conventions established
    in the official NetworkX ([https://networkx.org/documentation/stable/](https://networkx.org/documentation/stable/))
    documentation, using the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code for this chapter can be found in the `Chapter 05` folder of this book’s
    GitHub repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2005).
  prefs: []
  type: TYPE_NORMAL
- en: Creating networks in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve the multitude of problems that can be expressed as network problems,
    we need a way of creating networks in Python. For this, we will make use of the
    NetworkX package and the routines and classes it provides to create, manipulate,
    and analyze networks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll create an object in Python that represents a network and
    add nodes and edges to this object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned in the *Technical requirements* section, we need the NetworkX
    package to be imported under the `nx` alias. We can do this using the following
    `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Python representation of a simple graph:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new `Graph` object that will store the nodes and edges
    that constitute the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add the nodes for the network using the `add_node` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To avoid calling this method repetitively, we can use the `add_nodes_from`
    method to add nodes from an iterable, such as a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add edges between the nodes that we’ve added using either
    the `add_edge` or `add_edges_from` method, which adds either a single edge or
    a list of edges (as tuples), respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must retrieve a view of the current nodes and edges in a graph
    by accessing the `nodes` and `edges` attributes, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NetworkX package adds several classes and routines for creating, manipulating,
    and analyzing networks using Python. The `Graph` class is the most basic class
    for representing networks that do not contain multiple edges between any given
    nodes and where their edges are undirected (bidirectional).
  prefs: []
  type: TYPE_NORMAL
- en: Once a blank `Graph` object has been created, we can add new nodes and edges
    using the methods described in this recipe. In this recipe, we created nodes that
    hold integer values. However, a node can hold any hashable Python object except
    `None`. Moreover, associated data can be added to a node via keyword arguments
    passed to the `add_node` method. Attributes can also be added when using the `add_nodes_from`
    method by supplying a list of tuples containing the node object and a dictionary
    of attributes. The `add_nodes_from` method is useful for adding nodes in bulk,
    while `add_node` is useful for attaching individual nodes to an existing network.
  prefs: []
  type: TYPE_NORMAL
- en: An edge in a network is a tuple containing two (distinct) nodes. In a simple
    network, such as the one represented by the basic `Graph` class, there can be,
    at most, one edge between any two given nodes. These edges are added via the `add_edge`
    or `add_edges_from` method, which adds either a single edge or a list of edges
    to the network, respectively. As for the nodes, edges can hold arbitrary associated
    data via an attributes dictionary. In particular, weights can be added by supplying
    the `weight` attribute when adding edges. We will provide more details about weighted
    graphs in the *Creating directed and weighted* *networks* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `nodes` and `edges` attributes hold the nodes and edges that constitute
    the network, respectively. The `nodes` attribute returns a `NodesView` object,
    which is a dictionary-like interface to the nodes and their associated data. Similarly,
    the `edges` attribute returns an `EdgeView` object. This can be used to inspect
    individual edges and their associated data.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Graph` class represents *simple networks*, which are networks in which
    nodes are joined by, at most, one edge, and the edges are not directed. We will
    discuss directed networks in the *Creating directed and weighted networks* recipe.
    There is a separate class for representing networks in which there can be multiple
    edges between a pair of nodes called `MultiGraph`. All of the network types allow
    self-loops, which are sometimes not allowed in a *simple network* in the literature,
    where a simple network typically refers to an undirected network with no self-loops.
  prefs: []
  type: TYPE_NORMAL
- en: All network types offer various methods for adding nodes and edges, as well
    as inspecting the current nodes and edges. There are also methods for copying
    networks into some other kind of network or extracting subnetworks. There are
    also several utility routines in the NetworkX package for generating standard
    networks and adding subnetworks to an existing network.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX also provides various routines for reading and writing networks to
    different file formats, such as GraphML, JSON, and YAML. For example, we can write
    a network to a GraphML file using the `nx.write_graphml` routine and read it using
    the `nx.read_graphml` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common first step in analyzing a network is to draw the network, which can
    help us identify some of the prominent features of a network. (Of course, drawings
    can be misleading, so we should not rely on them too heavily in our analysis.)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll describe how to use the network drawing facilities in
    the NetworkX package to visualize a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need to import the NetworkX package under the `nx`
    alias, as described in the *Technical requirements* section. We will also need
    the Matplotlib package. For this, as usual, we must import the `pyplot` module
    as `plt` using the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to draw a simple network object using the drawing
    routines from NetworkX:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a simple example network to draw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create new Matplotlib `Figure` and `Axes` objects for it, ready
    to plot the network using the `subplots` routine from `plt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create a layout that will be used to position the nodes on the
    figure. For this figure, we shall use a shell layout using the `shell_layout`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the `draw` routine to draw the network on the figure. Since we have
    already created a Matplotlib `Figure` and `Axes`, we can supply the `ax` keyword
    argument. We will also add labels to the nodes using the `with_labels` keyword
    argument and specify the layout that we just created using the `pos` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting drawing can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A drawing of a simple network arranged using a shell layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – A drawing of a simple network arranged using a shell layout
  prefs: []
  type: TYPE_NORMAL
- en: Since the number of nodes in this example is relatively small, they are arranged
    in a single circle. The edges are indicated by lines.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `draw` routine is a specialized plotting routine specifically for drawing
    networks. The layout we created specifies the coordinates at which each of the
    nodes will be placed. We used a *shell layout*, which arranges the nodes in a
    concentric circle arrangement (only a single circle was used in this recipe),
    which is determined by the nodes and edges of the network. By default, the `draw`
    routine creates a randomized layout.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` routine has numerous keyword arguments for customizing the appearance
    of the plotted network. In this recipe, we added the `with_labels` keyword argument
    to label the nodes in the figure according to the objects they hold. The nodes
    hold integers, which is why the nodes in the preceding figure are labeled by integers.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a set of axes separately using the `plt.subplots` routine. This
    isn’t strictly necessary since the `draw` routine will automatically create a
    new figure and new axes if they’re not provided.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NetworkX package provides several layout-generating routines, similar to
    the `shell_layout` routine that we used in this recipe. This layout is simply
    a dictionary, indexed by the nodes, whose elements are the x and y coordinates
    of the position where the node should be plotted. The NetworkX routines for creating
    layouts represent common arrangements that will be useful for most cases, but
    you can also create custom layouts, should you need them. A full list of the different
    layout creation routines is provided in the NetworkX documentation. There are
    also shortcut drawing routines that will use a specific layout with the need to
    create the layout separately; for example, the `draw_shell` routine will draw
    the network with the shell layout that is equivalent to the `draw` call given
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` routine takes several keyword arguments to customize the appearance
    of the figure. For example, there are keyword arguments to control the node’s
    size, color, shape, and transparency. We can also add arrows (for directed edges)
    and/or only draw a specific set of nodes and edges from the network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the basic characteristics of networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks have various basic characteristics beyond the number of nodes and edges
    that are useful for analyzing a graph. For example, the *degree* of a node is
    the number of edges that start (or end) at that node. A higher degree indicates
    that the node is better connected to the rest of the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to access the basic attributes and compute
    various basic measures associated with a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we need to import the NetworkX package under the `nx` alias. We also
    need to import the Matplotlib `pyplot` module as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to access the various basic characteristics of a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the sample network that we will analyze in this recipe, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, it is good practice to draw the network and arrange the nodes in a circular
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure. As we can see, the
    network is split into two distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A simple network drawn in a circular arrangement with two distinct
    components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – A simple network drawn in a circular arrangement with two distinct
    components
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must print the `Graph` object to display some basic information about
    the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the `degree` property of the `Graph` object to retrieve the
    degree of a specific node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can get the connected components of the network using the `connected_components`
    routine, which returns a generator that we make into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can compute the **density** of a network using the density routine, which
    returns a float between 0 and 1\. This represents the proportion of edges meeting
    the node to the total number of possible edges at the node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can determine whether a network is *planar* – meaning that no two
    edges need to be drawn crossing one another – by using the `check_planarity` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we glance back at *Figure 5**.2*, we can see that we can indeed draw this
    graph without having to cross two of the edges.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `info` routine generates a small summary of the network, including the type
    of the network (which is a simple `Graph` type in this recipe), the number of
    nodes and edges, and the average degrees of the nodes in the network. The actual
    degree of a node in the network can be accessed using the `degree` property, which
    offers a dictionary-like interface for finding the degree of each node.
  prefs: []
  type: TYPE_NORMAL
- en: A set of nodes is said to be connected if every node in the set is joined to
    the others by an edge or sequence of edges. The *connected components* of a network
    are the largest sets of nodes that are connected. Any two distinct connected components
    are disjointed. Every network can be decomposed into one or more connected components.
    The network we defined in this recipe has two connected components, `{0, 1, 2,
    3, 4, 5}` and `{8, 9, 6, 7}`. These are visible in the preceding figure, where
    the first connected component is drawn above the second connected component. In
    this figure, we can trace a path along the edges of the network from any node
    in a component to any other; for example, from 0 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: The *density* of a network measures the ratio of the number of edges in the
    network to the total possible number of edges given by the number of nodes in
    a network. The density of a complete network is 1, but in general, the density
    will be less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: A network is *planar* if it can be drawn on a flat surface without crossing
    edges. The easiest example of a non-planar network is a complete network with
    five nodes. Complete networks with, at most, four nodes are planar. A little experimentation
    with the way you draw these networks on paper will reveal a drawing that doesn’t
    contain crossing edges. In addition, any network that contains a complete graph
    with at least five nodes is not planar. Planar networks are important in theory
    due to their relative simplicity, but they are less common in networks that arise
    in applications.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the methods on the network classes, there are several other routines
    in the NetworkX package that can be used to access the attributes of the nodes
    and edges in a network. For example, `nx.get_node_attributes` gets a named attribute
    from each node in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the adjacency matrix for a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One potent tool for analyzing graphs is the adjacency matrix, which has entries
    ![](img/Formula_05_003.png) if there is an edge from node ![](img/Formula_05_004.png)
    to node ![](img/Formula_05_005.png), and 0 otherwise. For most networks, the adjacency
    matrix will be sparse (most of the entries are 0). For networks that are not directed,
    the matrix will also be symmetric (![](img/Formula_05_006.png)). Numerous other
    matrices can be associated with a network. We will briefly discuss these in the
    *There’s more...* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will generate the adjacency matrix for a network and learn
    how to get some basic properties of the network from this matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the NetworkX package imported under the `nx` alias,
    and the NumPy module imported as `np`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to generate the adjacency matrix for a network
    and derive some simple properties of the network from this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will generate a network to work with throughout this recipe. We’ll
    generate a random network with five nodes and five edges while using a seed for
    reproducibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To generate the adjacency matrix, we can use the `adjacency_matrix` routine
    from NetworkX. This returns a sparse matrix by default, so we will also convert
    this into a full NumPy array for this demonstration using the `todense` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Taking the ![](img/Formula_05_007.png)th power of the adjacency matrix gives
    us the number of paths of length ![](img/Formula_05_007.png) from one node to
    another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both the adjacency matrix from step 2 and the fourth power from step 3 are symmetric
    matrices. Also, notice that the non-zero entries of `paths_len_4` are located
    in the positions where 0 appears in the adjacency matrix. This is because there
    are two distinct groups of nodes, and paths of odd length swap between these two
    groups whereas paths of even length return to the starting group.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dense_gnm_random_graph` routine generates a (dense) random network, chosen
    uniformly from the family of all networks with ![](img/Formula_05_007.png) nodes
    and ![](img/Formula_05_010.png) edges. In this recipe, ![](img/Formula_05_011.png)
    and ![](img/Formula_05_012.png). The `dense` prefix indicates that this routine
    uses an algorithm that should be faster than the alternative `gnm_random_graph`
    for dense networks with a relatively large number of edges compared to nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The adjacency matrix of a network is easy to generate, especially in sparse
    form, when the graph is relatively small. For larger networks, this can be an
    expensive operation, so it might not be practical, particularly if you convert
    it into a full matrix, as we saw in this recipe. You don’t need to do this in
    general, since we can simply use the sparse matrix generated by the `adjacency_matrix`
    routine and the sparse linear algebra tools in the SciPy `sparse` module instead.
  prefs: []
  type: TYPE_NORMAL
- en: The matrix powers provide information about the number of paths of a given length.
    This can easily be seen by tracing through the definitions of matrix multiplication.
    Remember that the entries of the adjacency matrix are 1 when there is an edge
    (path of length 1) between two given nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Eigenvalues of the adjacency matrix for a network provide some additional
    information about the structure of the network, such as the bounds for the chromatic
    number of the network. (See the *Coloring a network* recipe for more information
    about coloring a network.) There is a separate routine for computing the Eigenvalues
    of the adjacency matrix. For example, the `adjacency_spectrum` routine to generate
    the Eigenvalues of the adjacency matrix of a network. Methods involving the Eigenvalues
    of a matrix associated with a network are usually called *spectral methods*.
  prefs: []
  type: TYPE_NORMAL
- en: There are other matrices associated with networks, such as the *incidence matrix*
    and the *Laplacian matrix*. The incidence matrix of a network is an ![](img/Formula_05_013.png)
    matrix, where ![](img/Formula_05_014.png) is the number of nodes and ![](img/Formula_05_015.png)
    is the number of edges. This has an ![](img/Formula_05_016.png)th entry of 1 if
    node ![](img/Formula_05_017.png) appears in edge ![](img/Formula_05_018.png) and
    0 otherwise. The Laplacian matrix of a network is defined to be the ![](img/Formula_05_019.png)
    matrix, where ![](img/Formula_05_020.png) is the diagonal matrix containing the
    degrees of the nodes in the network and ![](img/Formula_05_021.png) is the adjacency
    matrix of the network. Both of these matrices are useful for analyzing networks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating directed and weighted networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple networks, such as those described in the previous recipes, are useful
    for describing networks where the direction of an edge is unimportant and where
    the edges carry equal weight. In practice, most networks carry additional information,
    such as weights or directions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a directed and weighted network and explore some
    of the basic properties of such networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the NetworkX package, imported under the `nx`
    alias (as usual), the Matplotlib `pyplot` module imported as `plt`, and the NumPy
    package imported as `np`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline how to create a directed network with weights,
    as well as how to explore some of the properties and techniques we discussed in
    the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a directed network, we can use the `DiGraph` class from NetworkX
    rather than the simple `Graph` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As usual, we must add nodes to the network using the `add_node` or `add_nodes_from`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add weighted edges, we can use either the `add_edge` method and provide
    the `weight` keyword argument, or use the `add_weighted_edges_from` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must draw the network with arrows to indicate the direction of each
    edge. We must also provide positions for this plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A weighted, directed network'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A weighted, directed network
  prefs: []
  type: TYPE_NORMAL
- en: 'The adjacency matrix of a directed matrix is created in the same way as a simple
    network, but the resulting matrix will not be symmetric:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rather than the number of edges between two given nodes, the adjacency matrix
    contains the sum of the weights of edges between those nodes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DiGraph` class represents a directed network, where the order of the nodes
    when adding an edge is important. In this recipe, we added two edges for connecting
    nodes 2 and 3, one in each direction. In a simple network (the `Graph` class),
    the addition of the second edge would not add another edge. However, for a directed
    network (the `DiGraph` class), the order that the nodes are given in when adding
    the edge determines the direction.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing special about weighted edges except for the addition of the
    `weight` attribute that’s attached to the edge. (Arbitrary data can be attached
    to an edge or node in a network via keyword arguments.) The `add_weighted_edges_from`
    method simply adds the corresponding weight value (the third value in the tuple)
    to the edge in question. Weights can be added to any edge in any network, not
    just the directed networks shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw` routine automatically adds arrows to edges when drawing a directed
    network. This behavior can be turned off by passing the `arrows=False` keyword
    argument. The adjacency matrix for a directed or weighted network also differs
    from that of a simple network. In a directed network, the matrix is not generally
    symmetrical, because edges may exist in one direction but not the other. For a
    weighted network, the entries can be different from 1 or 0, and will instead be
    the weight of the corresponding edge.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weighted networks appear in lots of applications, such as when describing transportation
    networks with distances or speeds. You can also use networks to examine flow through
    a network by providing a *capacity* for edges in the network (as a weight or as
    another attribute). NetworkX has several tools for analyzing flow through a network,
    such as finding the maximum flow through a network via the `nx.maximum_flow` routine.
  prefs: []
  type: TYPE_NORMAL
- en: Directed networks add directional information to a network. Many real-world
    applications give rise to networks that have unidirectional edges, such as those
    in industrial processes or supply chain networks. This additional directional
    information has consequences for many of the algorithms for working with networks,
    as we’ll see throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the shortest paths in a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem where networks make an appearance is in the problem of finding
    the shortest – or perhaps more precisely, the highest reward – route between two
    nodes in a network. For instance, this could be the shortest distance between
    two cities, where the nodes represent the cities, and the edges are roads connecting
    pairs of cities. In this case, the weights of the edges would be their lengths.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will find the shortest path between two nodes in a network
    with weights.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NetworkX package imported, as usual, under
    the `nx` alias, the Matplotlib `pyplot` module imported as `plt`, and a random
    number generator object from NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to find the shortest path between two nodes in a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a random network using `gnm_random_graph` and a `seed`
    for this demonstration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll draw the network with a circular arrangement to see how the nodes
    connect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure. Here, we can see that
    there is no direct edge from node 7 to node 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A randomly generated network with 10 nodes and 17 edges'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – A randomly generated network with 10 nodes and 17 edges
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add a weight to each of the edges so that some routes are preferable
    to others in terms of the shortest path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will compute the shortest path from node 7 to node 9 using the `nx.shortest_path`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can find the length of this shortest path using the `nx.shortest_path_`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`length` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here the *length* of the path is the sum of the weights of the edges along the
    shortest path. If the network is not weighted, then this will be equal to the
    number of edges traversed along this path.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shortest_path` routine computes the shortest path between each pair of
    nodes. Alternatively, when supplied with the source and destination node, which
    is what we did in this recipe, it computes the shortest path between the two specified
    nodes. We supplied the optional `weight` keyword argument, which makes the algorithm
    find the shortest path according to the *weight* attribute of the edge. This argument
    changes the meaning of *shortest*, with the default being the *fewest edges*.
  prefs: []
  type: TYPE_NORMAL
- en: The default algorithm for finding the shortest path between two nodes is Dijkstra’s
    algorithm, which is a staple of computer science and mathematics courses. It is
    a good general-purpose algorithm but is not particularly efficient. Other route-finding
    algorithms include the A* algorithm. Greater efficiency can be obtained by using
    the A* algorithm with additional heuristic information to guide node selection.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many algorithms for finding the shortest path between two nodes in
    a network. There are also variants for finding the maximum weighted path.
  prefs: []
  type: TYPE_NORMAL
- en: There are several related problems regarding finding the paths in a network,
    such as the *traveling salesperson problem* and the *route inspection problem*.
    In the traveling salesperson problem, we find a cycle (a path starting and ending
    at the same node) that visits every node in the network, with the smallest (or
    largest) total weight. In the route inspection problem, we seek the shortest cycle
    (by weight) that traverses every edge in the network and returns to the starting
    point. The traveling salesperson problem is known to be NP-hard, but the route
    inspection problem can be solved in polynomial time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A famous problem in graph theory is the bridges at Königsberg, which asks to
    find a path in a network that traverses every edge in the network exactly once.
    It turns out, as proved by Euler, that finding such a path in the Königsberg bridges
    problem is impossible. A path that traverses every edge exactly once is called
    an *Eulerian circuit*. A network that admits an Eulerian circuit is called *Eulerian*.
    A network is Eulerian if and only if every node has an even degree. The network
    representation of the Königsberg bridge problem can be seen in the following figure.
    The edges in this figure represent the different bridges over the rivers, while
    the nodes represent the different land masses. We can see that all four of the
    nodes have an odd degree, which means that there cannot be a path that crosses
    every edge exactly once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A network representing the Königsberg bridge problem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – A network representing the Königsberg bridge problem
  prefs: []
  type: TYPE_NORMAL
- en: The edges represent the bridges between the different land masses represented
    by the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifying clustering in a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various quantities associated with networks that measure the characteristics
    of the network. For example, the clustering coefficient of a node measures the
    interconnectivity between the nodes nearby (here, nearby means connected by an
    edge). In effect, it measures how close the neighboring nodes are to forming a
    complete network or *clique*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The clustering coefficient of a node measures the proportion of the adjacent
    nodes that are connected by an edge; that is, two adjacent nodes form a triangle
    with the given node. We count the number of triangles and divide this by the total
    number of possible triangles that could be formed, given the degree of the node.
    Numerically, the clustering coefficient at a node, ![](img/Formula_05_022.png),
    in a simple unweighted network is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/Formula_05_024.png) is the number of triangles at ![](img/Formula_05_025.png)
    and the denominator is the total possible number of triangles at ![](img/Formula_05_025.png).
    If the degree of ![](img/Formula_05_025.png) (the number of edges from ![](img/Formula_05_025.png))
    is 0 or 1, then we set ![](img/Formula_05_029.png) to 0.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to compute the clustering coefficient of a
    node in a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will need the NetworkX package under the `nx` alias and
    the Matplotlib `pyplot` module imported as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you how to compute the clustering coefficient of a
    node in a network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a sample network to work with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must draw the network so that we can compare the clustering coefficients
    that we’ll be calculating. This will allow us to see how these nodes appear in
    the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A sample network for testing clustering'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – A sample network for testing clustering
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can compute the clustering coefficients of the nodes in the network
    using the `nx.clustering` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the `nx.clustering` routine is a dictionary over the nodes in
    the network. So, we can print some selected nodes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The average clustering coefficient for all the nodes in the network can be
    computed using the `nx.average_clustering` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This average clustering coefficient indicates that, on average, the nodes have
    approximately 1/3 of the total possible connections.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The clustering coefficient of a node measures how close the neighborhood of
    that node is to being a complete network (all the nodes are connected). In this
    recipe, we have three different computed values: 0 has a clustering coefficient
    of 0.5, 2 has a clustering coefficient of 1.0, and 6 has a clustering coefficient
    of 0\. This means that the nodes connected to node 2 form a complete network,
    which is because we designed our network in this way. (Nodes 0 to 4 form a complete
    network by design.) The neighborhood of node 6 is very far from being complete
    since there are no interconnecting edges between either of its neighbors.'
  prefs: []
  type: TYPE_NORMAL
- en: The average clustering value is a simple average of the clustering coefficients
    over all the nodes in the network. It is not quite the same as the global clustering
    coefficient (computed using the `nx.transitivity` routine in NetworkX), but it
    does give us an idea of how close the network is to being a complete network as
    a whole. The global clustering coefficient measures the ratio of the number of
    triangles to the number of triplets – a collection of three nodes that are connected
    by at least two edges – over the whole network.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between global clustering and average clustering is quite subtle.
    The global clustering coefficient measures the clustering of the network as a
    whole, but the average clustering coefficient measures how much, on average, the
    network is locally clustered. The difference is best seen in a windmill network,
    which consists of a single node surrounded by a circle of an even number of nodes.
    All the nodes are connected to the center, but the nodes on the circle are only
    connected in an alternating pattern. The outer nodes have a local clustering coefficient
    of 1, while the center node has a local clustering coefficient of ![](img/Formula_05_030.png),
    where ![](img/Formula_05_031.png) denotes the number of triangles joining the
    center node. However, the global clustering coefficient is ![](img/Formula_05_032.png).
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clustering coefficients are related to *cliques* in a network. A clique is a
    subnetwork that is complete (all the nodes are connected by an edge). An important
    problem in network theory is finding the maximal cliques in a network, which is
    a very difficult problem in general (here, maximal means *cannot be* *made larger*).
  prefs: []
  type: TYPE_NORMAL
- en: Coloring a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks are also useful in scheduling problems, where you need to arrange activities
    into different slots so that there are no conflicts. For example, we could use
    networks to schedule classes to make sure that students who are taking different
    options do not have to be in two classes at once. In this scenario, the nodes
    will represent the different classes and the edges will indicate that students
    are taking both classes. The process we use to solve these kinds of problems is
    called *network coloring*. This process involves assigning the fewest possible
    colors to the nodes in a network so that no two adjacent nodes have the same color.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to color a network to solve a simple scheduling
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need the NetworkX package imported under the `nx` alias
    and the Matplotlib `pyplot` module imported as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to solve a network coloring problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a sample network to use in this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will draw the network so that we can understand the coloring when
    it is generated. For this, we will use the `draw_circular` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting plot can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Example network for a simple scheduling problem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Example network for a simple scheduling problem
  prefs: []
  type: TYPE_NORMAL
- en: 'We will generate the coloring using the `nx.greedy_color` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the actual colors that were used in this coloring, we will generate
    a set of values from the `coloring` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the number of colors in the coloring cannot be smaller since nodes
    0, 1, 2, and 6 form a complete network – each of these nodes is connected to the
    others, so each of them requires a separate color.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nx.greedy_color` routine colors the network using one of several possible
    strategies. By default, it works in order of degree from largest to smallest.
    In our case, it started by assigning color 0 to node 2, which has a degree of
    6, then color 1 to node 0, which has a degree of 4, and so on. The first available
    color is chosen for each node in this sequence. This is not necessarily the most
    efficient algorithm for coloring a network.
  prefs: []
  type: TYPE_NORMAL
- en: Any network can be colored by assigning every node a different color, but in
    most cases, fewer colors are necessary. In the recipe, the network has seven nodes,
    but only four colors are required. The smallest number of colors necessary is
    called the **chromatic number** of the network.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we have described here is the *node coloring* problem. There is
    a related problem known as *edge coloring*. We can turn an edge coloring problem
    into a node coloring problem by considering the network whose nodes are the edges
    of the original network, with an edge between two of these notes added whenever
    the edges share a common node in the original network.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several variations of the coloring problem for networks. One such
    variation is the **list coloring problem**, in which we seek a coloring for a
    network where each node is given a color from a predefined list of possible colors.
    This problem is more difficult than the general coloring problem.
  prefs: []
  type: TYPE_NORMAL
- en: The general coloring problem has surprising results. For example, every planar
    network can be colored by, at most, four different colors. This is a famous theorem
    from graph theory called the **four-color theorem**, which was proved by Appel
    and Haken in 1977\. This theorem states that every planar graph has a chromatic
    number that is no larger than 4.
  prefs: []
  type: TYPE_NORMAL
- en: Finding minimal spanning trees and dominating sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networks have applications for a wide variety of problems. Two obvious areas
    that see many applications are communication and distribution. For example, we
    might wish to find a way of distributing goods to several cities (nodes) in a
    road network that covers the smallest distance from a particular point. For problems
    like this, we need to look at minimal spanning trees and dominating sets.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will find a minimal spanning tree and a dominating set in
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to import the NetworkX package under the `nx` alias
    and the Matplotlib `pyplot` module as `plt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to find a minimum spanning tree and dominating set for a
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a sample network to analyze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, as usual, we will draw the network before doing any analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The minimum spanning tree can be computed using the `nx.minimum_``spanning_tree`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will overlay the edges of the minimum spanning tree onto the plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will find a dominating set – a set where every node in the network
    is adjacent to at least one node from the set – for the network using the `nx.dominating_set`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A plot of the network with the minimum spanning tree overlaid can be seen in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The network drawn with the minimum spanning tree overlaid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/5.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – The network drawn with the minimum spanning tree overlaid
  prefs: []
  type: TYPE_NORMAL
- en: The edges used in the minimum spanning tree are the bold unbroken lines, and
    the edges from the original network are the dashed lines. The fact that the minimum
    spanning tree is indeed a tree is slightly obscured by the layout, but we can
    easily trace through and see that no two nodes connected to a single parent node
    are connected.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *spanning tree* of a network is a tree contained in the network that contains
    all the nodes. A *minimum* spanning tree is a spanning tree that contains the
    fewest edges possible – or has the lowest total weight. Minimum spanning trees
    are useful for distribution problems over a network. A simple algorithm for finding
    minimum spanning trees is to simply select the edges (of the smallest weight first,
    if the network is weighted) in such a way that it does not create cycles until
    this is no longer possible.
  prefs: []
  type: TYPE_NORMAL
- en: A *dominating set* for a network is a set of vertices where every node in the
    network is adjacent to at least one node in the dominating set. Dominating sets
    have applications in communication networks. We are often interested in finding
    minimal dominating sets, but this is computationally difficult. Testing whether
    there is a dominating set that’s smaller than a given size is NP-complete. However,
    there are some efficient algorithms for finding the smallest dominating sets for
    certain classes of graphs. Informally speaking, the problem is that once you’ve
    identified a candidate for a minimum-size dominating set, you have to verify that
    there are no dominating sets that are smaller in size. This is very difficult
    if you do not know all the possible dominating sets in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several classical texts on graph theory, including books by Bollobás
    and Diestel:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Diestel, R., 2010\. *Graph Theory*. 3rd ed. Berlin: Springer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bollobás, B., 2010\. *Modern Graph Theory*. New York, NY: Springer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
