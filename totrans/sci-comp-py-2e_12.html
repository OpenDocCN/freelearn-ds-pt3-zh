<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Error and Exception Handling
                </header>
            
            <article>
                
<p>In this chapter, we will cover errors and exceptions and how to find and fix them. Handling exceptions is an important part of writing reliable and usable code. We will introduce basic built-in exceptions and show how to use and treat exceptions. We'll introduce debugging and show you how to use the built-in Python debugger.</p>
<p>In this chapter, we cover the following topics:</p>
<ul>
<li>What are exceptions?</li>
<li>Finding errors: debugging</li>
</ul>
<h1 id="uuid-b74db188-7de9-487d-9b4c-f60c4808bec5">12.1 What are exceptions?</h1>
<p>The first error that programmers (even experienced ones) are confronted with is when the code has incorrect syntax, meaning that the code instructions are not correctly formatted.</p>
<p>Consider this example of a syntax error:</p>
<pre>&gt;&gt;&gt; for i in range(10)
  File “&lt;stdin&gt;”, line 1
    for i in range(10)
                      ^
SyntaxError: invalid syntax</pre>
<p>The error occurs because of a missing colon at the end of the<span> </span><kbd>for</kbd><span> </span>declaration. This is an example of an exception being raised. In the case of<span> </span><kbd><span>SyntaxError</span></kbd>, it tells the programmer that the code has incorrect syntax and also prints the line where the error occurred, with an arrow pointing to where in that line the problem is.</p>
<p>Exceptions in Python are derived (inherited) from a base class called <span><kbd>Exception</kbd>.</span> Python comes with a number of built-in exceptions. Some common exception types are listed in<span> </span><em>Table 12.1</em>.</p>
<p>Here are two common examples of exceptions. As you might expect,<span> </span><span><kbd>ZeroDivisionError</kbd></span><span> </span>is raised when you try to divide by zero:</p>
<pre>def f(x):
    return 1/x

&gt;&gt;&gt; f(2.5)
0.4 
&gt;&gt;&gt; f(0)

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "exception_tests.py", line 3, in f
    return 1/x
ZeroDivisionError: integer division or modulo by zero</pre>
<table style="width: 100%;border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p><strong>Exception</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>IndexError</kbd></p>
</td>
<td>
<p>Index is out of bounds, <span>for example,</span> <kbd>v[10]</kbd><span> </span>when <kbd>v</kbd> only has five elements.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>KeyError</kbd></p>
</td>
<td>
<p>A reference to an undefined dictionary key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>NameError</kbd></p>
</td>
<td>
<p>A name not found, for example, an undefined variable.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>LinAlgError</kbd></p>
</td>
<td>
<p>Errors in the<span> </span><kbd>linalg</kbd><span> </span>module, for example, when solving a system with a singular matrix.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ValueError</kbd></p>
</td>
<td>
<p>Incompatible data value, for example, when using<span> </span><kbd>dot</kbd><span> </span>with incompatible arrays.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IOError</kbd></p>
</td>
<td>
<p>I/O operation fails, for ex<span>ample,</span><span> </span><kbd>file not found</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ImportError</kbd></p>
</td>
<td>
<p>A module or name is not found on import.</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 12.1: Some frequently used built-in exceptions and their meaning</div>
<p>A division by zero raises<span> </span><span><kbd>ZeroDivisionError</kbd> </span>and prints out the file name, the line, and the function name where the error occurred.</p>
<p>As we have seen before, arrays can only contain elements of the same datatype. If you try to assign a value of an incompatible type, <span><kbd>ValueError</kbd> </span>is raised. An example of a value error is:</p>
<pre>&gt;&gt;&gt; a = arange(8.0) 
&gt;&gt;&gt; a 
array([ 0., 1., 2., 3., 4., 5., 6., 7.]) 
&gt;&gt;&gt; a[3] = 'string'
Traceback (most recent call last): 
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: could not convert string to float: string</pre>
<p>Here,<span> </span><kbd>ValueError</kbd><span> </span>is raised because the array contains floats and an element cannot be assigned a string value.</p>
<h2 id="uuid-f271b810-b89d-4aff-9525-bb8d60ee248a">12.1.1 Basic principles</h2>
<p>Let's look at the basic principles on how to use exceptions by raising them with<span> </span><kbd>raise</kbd><span> </span>and catching them with <kbd>try</kbd> statements.</p>
<h3 id="uuid-6164d554-ac19-4919-8408-d3a07b71b4c7">Raising exceptions</h3>
<p>Creating an error is referred to as raising an exception. You saw some examples of exceptions in the previous section. You can also define your own exceptions of a predefined type or use an exception of an unspecified type. Raising an exception is done with a command like this:</p>
<pre>raise Exception("Something went wrong")</pre>
<p>Here an exception of an unspecified type was raised.</p>
<p>It might be tempting to print out error messages when something goes wrong, for example, like this:</p>
<pre>print("The algorithm did not converge.")</pre>
<p>This is not recommended for a number of reasons. Firstly, printouts are easy to miss, especially if the message is buried in many other messages being printed to your console. Secondly, and more importantly, it renders your code unusable by other code. The calling code will not <em>read</em> what you printed and will not have a way of knowing that an error occurred and therefore has no way of taking care of it.</p>
<p>For these reasons, it is always better to raise an exception instead. Exceptions should always contain a descriptive message, for example:</p>
<pre>raise Exception("The algorithm did not converge.")</pre>
<p>This message will stand out clearly to the user. It also gives the opportunity for the calling code to know that an error occurred, and to possibly find a remedy.</p>
<p>Here is a typical example of checking the input inside a function to make sure it is usable before continuing. A simple check for negative values and the correct datatype ensures the intended input of a function to compute factorials:</p>
<pre>def factorial(n):<br/>    if not (isinstance(n, (int, int32, int64))):<br/>       raise TypeError("An integer is expected")<br/>    if not (n &gt;=0): <br/>       raise ValueError("A positive number is expected")</pre>
<p>The user of the function will immediately know what the error is, if an incorrect input is given, and it is the user's responsibility to handle the exception. Note the use of the exception name when raising a predefined exception type, in this case<span>,</span> <kbd>ValueError</kbd><span> </span>followed by the message. By specifying the type of the exception, the calling code can decide to handle errors differently depending on what type of error is raised.</p>
<p>Summing up, it is always better to raise exceptions than to print error messages.</p>
<h3 id="uuid-33a19094-3f2f-4879-af23-0dc4616519c3">Catching exceptions</h3>
<p>Dealing with an exception is referred to as <em>catching an exception</em>. Checking for exceptions is done with the <span>commands </span><kbd>try</kbd> <span>and</span> <kbd>except</kbd><span>.</span></p>
<p>An exception stops the program execution flow and looks for the closest<span> </span><kbd>try</kbd><span> </span>enclosing block. If the exception is not caught, the program unit is left and it continues searching for the next enclosing<span> </span><kbd>try</kbd><span> </span>block in a program unit higher up in the calling stack. If no block is found and the exception is not handled, execution stops entirely and the standard traceback information is displayed.</p>
<p>Let's look at the factorial example from previously and use it with the<span> </span><kbd>try</kbd><span> </span>statement:</p>
<pre>n=-3<br/>try:
    print(factorial(n))
except ValueError:
    print(factorial(-n))   # Here we catch the error<br/><br/></pre>
<p>In this case, if the code inside the<span> </span><kbd>try</kbd><span> </span>block raises an error of type<span> </span><kbd>ValueError</kbd>, the exception will be caught and the action in the<span> </span><kbd>except</kbd><span> </span>block is taken. If no exception occurs inside the<span> </span><kbd>try</kbd><span> </span>block, the<span> </span><kbd>except</kbd><span> </span>block is skipped entirely and execution continues.</p>
<p>The<span> </span><kbd>except</kbd><span> </span>statement can catch multiple exceptions. This is done by simply grouping them in a tuple, like this:</p>
<pre>except (RuntimeError, ValueError, IOError):</pre>
<p>The<span> </span><kbd>try</kbd><span> </span>block can also have multiple<span> </span><kbd>except</kbd><span> </span>statements. This makes it possible to handle exceptions differently depending on the type. Let's see another example of multiple exception types:</p>
<pre>try: <br/>    f = open('data.txt', 'r') <br/>    data = f.readline() <br/>    value = float(data) <br/>except FileNotFoundError as FnF: <br/>    print(f'{FnF.strerror}: {FnF.filename}') <br/>except ValueError: <br/>    print("Could not convert data to float.")</pre>
<p> </p>
<p>Here, <kbd>FileNotFoundError</kbd> will be caught if, for example, the file does not exist; and <kbd>ValueError</kbd><span> </span>will be caught if, for example, the data in the first line of the file is not compatible with the float data type.</p>
<p>In this example, we assigned <kbd>FileNotFoundError</kbd><span> </span>to a variable <kbd>FnF</kbd> by the keyword<span> </span><kbd>as</kbd>. This allows access to more details when handling this exception. Here we printed the error string <kbd>FnF.strerror</kbd><span> </span>and the name of the related file <kbd>FnF.filename</kbd>. Each error type can have its own set of attributes depending on the type. If the file with the name <kbd>data.txt</kbd> does not exist, in the preceding example, the message is:</p>
<pre>No such file or directory: data.txt</pre>
<p>This is a useful way to format the output when catching exceptions.</p>
<p>The<span> </span><kbd>try</kbd>-<kbd>except</kbd><span> </span>combination can be extended with optional<span> </span><kbd>else</kbd><span> </span>and<span> </span><kbd>finally</kbd><span> </span>blocks.</p>
<p>An example of using<span> </span><kbd>else</kbd><span> </span>can be seen in <a href="dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml"/><a href="dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml">Section 15.2.1</a>: <em>Testing the bisection algorithm</em>. Combining <kbd>try</kbd> with <kbd>finally</kbd> gives a useful construction when cleanup work needs to happen at the end. This is illustrated by an example for making sure a file is closed properly is:</p>
<pre>try:
    f = open('data.txt', 'r')
    # some function that does something with the file
    process_file_data(f) 
except: 
    ... 
finally:
    f.close()</pre>
<p>This will make sure that the file is closed at the end no matter what exceptions are thrown while processing the file data. Exceptions that are not handled inside the<span> </span><kbd>try</kbd><span> </span>statement are saved and raised after the<span> </span><kbd>finally</kbd><span> </span>block. This combination is used in the<span> </span><kbd>with</kbd><span> </span>statement; see Section 12.1.3:<span> </span><em>Context managers – the with statement</em>.</p>
<h2 id="uuid-9fddeef4-6340-4b97-bfe3-cf9990fdb602">12.1.2 User-defined exceptions</h2>
<p>Besides the built-in Python exceptions, it is also possible to define your own exceptions. Such user-defined exceptions should inherit from the <span>base class</span><span> </span><kbd>Exception</kbd>. This can be useful when you define your own classes such as the polynomial class in <a href="2bd9f874-5cdc-4298-873f-12572838a10c.xhtml">Section 19.1</a>.</p>
<p>Take a look at this small example of a simple user-defined exception:</p>
<pre>class MyError(Exception):
    def __init__(self, expr):
        self.expr = expr
    def __str__(self):
        return str(self.expr)

try:
   x = random.rand()
   if x &lt; 0.5:
      raise MyError(x)
except MyError as e:
   print("Random number too small", e.expr)
else:
   print(x)</pre>
<p>A random number is generated. If the number is below <kbd>0.5</kbd>, an exception is thrown and a message that the value is too small is printed. If no exception is raised, the number is printed.</p>
<p>In this example, you also saw a case of using<span> </span><kbd>else</kbd><span> </span>in a<span> </span><kbd>try</kbd><span> </span>statement. The block under<span> </span><kbd>else</kbd><span> </span>will be executed if no exception occurs.</p>
<p>It is recommended that you define your exceptions with names that end in<span> </span><kbd>Error</kbd>, like the naming of the standard built-in exceptions.</p>
<h2 id="uuid-12434e20-fdf4-498b-978e-635261239dcc">12.1.3 Context managers – the with statement</h2>
<p>There is a very useful construction in Python for simplifying exception handling when working with contexts such as files or databases. The statement encapsulates the <span>structure</span><span> </span><kbd>try ... finally</kbd><span> </span>in one simple command. Here is an example of using<span> </span><kbd>with</kbd><span> </span>to read a file:</p>
<pre>with open('data.txt', 'w') as f:
    process_file_data(f)</pre>
<p>This will try to open the file, run the specified operations on the file (for example, reading), and close the file. If anything goes wrong during the execution of<span> </span><kbd>process_file_data</kbd>, the file is closed properly and then the exception is raised. This is equivalent to:</p>
<pre>f = open('data.txt', 'w')
try: 
    # some function that does something with the file 
    process_file_data(f) 
except:
    ... 
finally:
    f.close()</pre>
<p>We will use this option in <span><a href="f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml">Section 14.1</a>:</span> <em>File handling</em>, when reading and writing files.</p>
<p>The preceding file-reading example is an example of using context managers. Context managers are Python objects with two special methods,<span> </span><kbd>__enter__</kbd><span> </span>and<span> </span><kbd>__exit__</kbd>. Any object of a class that implements these two methods can be used as a context manager. In this example, the file object<span> </span><kbd>f</kbd> is a context manager as there are the <span>methods</span><span> </span><kbd>f.__enter__</kbd><span> </span><span>and</span><span> </span><kbd>f.__exit__</kbd><span>.</span></p>
<p>The<span> </span><span>method</span><span> </span><kbd>__enter__</kbd><span> </span><span>should implement the initialization instructions, for example, opening a file or a database connection. If this method has a return statement, the returned object is accessed using the </span><span>construct</span><span> </span><kbd>as</kbd><span>. Otherwise, the</span><span> </span><span>keyword</span><span> </span><kbd>as</kbd><span> is omitted. The</span><span> </span><span>method</span><span> </span><span><kbd>__exit__</kbd> </span><span>contains the cleanup instructions, for example, closing a file or committing transactions and closing a database connection. For more explanations and an example of a self-written context manager, see </span><a href="dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml"><span>Section</span><span> 15.3.3</span></a><span>: </span><em>Timing with a context manager</em><span>.</span></p>
<p>There are NumPy functions that can be used as context managers. For example, the<span> </span><span>function </span><kbd>load</kbd><span> </span><span>supports the context manager for some file formats. NumPy's function</span><span> </span><kbd>errstate</kbd><span> </span><span>can be used as a context manager to specify floating-point error handling behavior within a block of code.</span></p>
<p class="mce-root"/>
<p>Here is an example of working with <kbd>errstate</kbd> and a context manager:</p>
<pre>import numpy as np      # note, sqrt in NumPy and SciPy 
                        # behave differently in that example
with errstate(invalid='ignore'):
    print(np.sqrt(-1)) # prints 'nan'

with errstate(invalid='warn'):
    print(np.sqrt(-1)) # prints 'nan' and 
                   # 'RuntimeWarning: invalid value encountered in sqrt'

with errstate(invalid='raise'):
    print(np.sqrt(-1)) # prints nothing and raises FloatingPointError</pre>
<p>See <a href="879c0554-386f-4bb1-8fa8-b86c43927545.xhtml">Section 2.2.2</a>: <em>Floating-point numbers</em> for more details on this example and <a href="dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml">Section 15.3.3</a>: <em>Timing wit</em><em>h a context manager</em> for another example.</p>
<h1 id="uuid-37691dec-4fb0-40e0-a7f3-7e300af0efe2">12.2 Finding errors: debugging</h1>
<p>Errors in software code are sometimes referred to as bugs. Debugging is the process of finding and fixing bugs in code. This process can be performed at varying degrees of sophistication. The most efficient way is to use a tool called a debugger. Having unit tests in place is a good way to identify errors early; see <a href="dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml">Section 15.2.2</a>: <em>Using the unittest package</em>. When it is not obvious where or what the problem is, a debugger is very useful.</p>
<h2 id="uuid-fde45218-9cae-46d5-82f1-6f0842f3f86d">12.2.1 Bugs</h2>
<p>There are typically two kinds of bugs:</p>
<ul>
<li>An exception is raised and not caught.</li>
<li>The code does not function properly.</li>
</ul>
<p>The first case is usually easier to fix. The second can be more difficult as the problem can be a faulty idea or solution, a faulty implementation, or a combination of the two.</p>
<p>We are only concerned with the first case in what follows, but the same tools can be used to help find why the code does not do what it is supposed to.</p>
<h2 id="uuid-d22122ab-af1c-4b61-9737-21870f9525fb">12.2.2 The stack</h2>
<p>When an exception is raised, you see the call stack. The call stack contains the trace of all the functions that called the code where the exception was raised.</p>
<p>A simple stack example is:</p>
<pre>def f():
   g()
def g():
   h()
def h():
   1//0

f()</pre>
<p>The stack, in this case, is<span> </span><kbd>f</kbd>,<span> </span><kbd>g</kbd>, and<span> </span><kbd>h</kbd>. The output generated by running this piece of code looks like this:</p>
<pre>Traceback (most recent call last):
  File "stack_example.py", line 11, in &lt;module&gt;
    f() 
  File "stack_example.py", line 3, in f
    g() 
  File "stack_example.py", line 6, in g
    h() File "stack_example.py", line 9, in h
    1//0 
ZeroDivisionError: integer division or modulo by zero</pre>
<p>The error is printed. The sequence of functions leading up to the error is shown. The function <kbd>f</kbd> on <kbd>line 11</kbd> was called, which in turn called<span> </span><kbd>g</kbd><span> </span>and then<span> </span><kbd>h</kbd>. This caused <kbd>ZeroDivisionError</kbd>.</p>
<p>A stack trace reports on the active stack at a certain point in the execution of a program. A stack trace lets you track the sequence of functions called up to a given point. Often this is after an uncaught exception has been raised. This is sometimes called post-mortem analysis, and the stack tracepoint is then the place where the exception occurred. Another option is to invoke a stack trace manually to analyze a piece of code where you suspect there is an error, perhaps before the exception occurs.</p>
<p>In the following example, an exception is raised to provoke the generation of a stack trace:</p>
<pre>def f(a):
   g(a)
def g(a):
   h(a)
def h(a):
   raise Exception(f'An exception just to provoke a strack trace and a value a={a}')

f(23)</pre>
<p>This returns the following output:</p>
<pre>Traceback (most recent call last):<br/><br/>  File ".../Python_experiments/manual_trace.py", line 17, in &lt;module&gt;<br/>    f(23)<br/><br/>  File "../Python_experiments/manual_trace.py", line 11, in f<br/>    g(a)<br/><br/>  File "../Python_experiments/manual_trace.py", line 13, in g<br/>    h(a)<br/><br/>  File "/home/claus/Python_experiments/manual_trace.py", line 15, in h<br/>    raise Exception(f'An exception just to provoke a strack trace and a value a={a}')<br/><br/>Exception: An exception just to provoke a strack trace and a value a=23</pre>
<h2 id="uuid-a3fc5178-6a63-41a1-8eb8-eb87f255f91e">12.2.3 The Python debugger</h2>
<p>Python comes with its own built-in debugger called <kbd>pdb</kbd>. Some development environments come with the debugger integrated. The following process still holds in most of these cases.</p>
<p>The easiest way to use the debugger is to enable stack tracing at the point in your code that you want to investigate. Here is a simple example of triggering the debugger based on the example mentioned in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.3</a>:<span> </span><em>Return values</em>:</p>
<pre>import pdb

def complex_to_polar(z):
    pdb.set_trace() 
    r = sqrt(z.real ** 2 + z.imag ** 2)
    phi = arctan2(z.imag, z.real)
    return (r,phi)
z = 3 + 5j 
r,phi = complex_to_polar(z)

print(r,phi)</pre>
<p>The command<span> </span><kbd>pdb.set_trace()</kbd><span> </span>starts the debugger and enables the tracing of subsequent commands. The preceding code will show this:</p>
<pre>&gt; debugging_example.py(7)complex_to_polar()
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) 
(Pdb)</pre>
<p>The debugger prompt is indicated with <kbd>(Pdb)</kbd>. The debugger stops the program execution and gives you a prompt that lets you inspect variables, modify variables, step through commands, and so on.</p>
<p>The current line is printed at each step, so you can follow where you are and what will happen next. Stepping through commands is done with the command<span> </span><kbd>n</kbd><span> </span>(next), like this:</p>
<pre>&gt; debugging_example.py(7)complex_to_polar() 
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) 
(Pdb) n 
&gt; debugging_example.py(8)complex_to_polar() 
-&gt; phi = arctan2(z.imag, z.real) 
(Pdb) n 
&gt; debugging_example.py(9)complex_to_polar() 
-&gt; return (r,phi) 
(Pdb) 
...</pre>
<p>The command<span> </span><kbd>n</kbd><span> </span>(next) will continue to the next line and print the line. If you need to see more than one line at a time, the  command<span> </span><kbd>l</kbd><span> </span>(list) shows the current line with the surrounding code:</p>
<pre>&gt; debugging_example.py(7)complex_to_polar() 
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) 
(Pdb) l
  2
  3 import pdb
  4
  5 def complex_to_polar(z):
  6 pdb.set_trace()
  7 -&gt; r = sqrt(z.real ** 2 + z.imag ** 2)
  8 phi = arctan2(z.imag, z.real)
  9 return (r,phi)
 10
 11 z = 3 + 5j
 12 r,phi = complex_to_polar(z) 
(Pdb)</pre>
<p>The inspection of variables can be done by printing their values to the console using the command<span> </span><kbd>p</kbd><span> </span>(print) followed by the variable name. An example of printing variables is: </p>
<pre>&gt; debugging_example.py(7)complex_to_polar() 
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) 
(Pdb) p z 
(3+5j) <br/>(Pdb) n 
&gt; debugging_example.py(8)complex_to_polar() 
-&gt; phi = arctan2(z.imag, z.real) 
(Pdb) p r 
5.8309518948453007 
(Pdb) c 
(5.8309518948453007, 1.0303768265243125)</pre>
<p>The<span> </span><span>command</span><span> </span><kbd>p</kbd><span> </span><span>(print) will print the variable; the command</span><span> </span><kbd>c</kbd><span> </span><span>(continue) continues execution.</span></p>
<p>Changing a variable mid-execution is useful. Simply assign the new value at the debugger prompt and step or continue the execution:</p>
<pre>&gt; debugging_example.py(7)complex_to_polar() 
-&gt; r = sqrt(z.real ** 2 + z.imag ** 2) 
(Pdb) z = 2j 
(Pdb) z 
2j 
(Pdb) c 
(2.0, 1.5707963267948966)</pre>
<p>Here the variable<span> </span><kbd>z</kbd><span> </span>is assigned a new value to be used throughout the remaining code. Note that the final printout has changed.</p>
<h2 id="uuid-0ad88973-efc4-43be-922b-f5f5604aacc0">12.2.4 Overview <span>–</span> debug commands</h2>
<p>In<span> </span><em>Table 12.2</em>, the most common debug commands are shown. For a full listing and description of commands, see the documentation for more information [24]. Note that any Python command also works, for example, assigning values to variables.</p>
<p class="mce-root">If you want to inspect a variable with a name that coincides with any of the debugger's short commands, for example,<span> </span><kbd>h</kbd>, you must use<span> </span><kbd>!h</kbd><span> </span>to display the variable.</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Command</strong></p>
</td>
<td>
<p><strong>Action</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>h</kbd></p>
</td>
<td>
<p>Help (without arguments, it prints available commands)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>l</kbd></p>
</td>
<td>
<p>Lists the code around the current line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>q</kbd></p>
</td>
<td>
<p>Quit (exits the debugger and the execution stops)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>c</kbd></p>
</td>
<td>
<p>Continues execution</p>
</td>
</tr>
<tr>
<td>
<p><kbd>r</kbd></p>
</td>
<td>
<p>Continues execution until the current function returns</p>
</td>
</tr>
<tr>
<td>
<p><kbd>n</kbd></p>
</td>
<td>
<p>Continues execution until the next line</p>
</td>
</tr>
<tr>
<td>
<p><kbd>p &lt;expression&gt;</kbd></p>
</td>
<td>
<p>Evaluates and prints the expression in the current context</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 12.2: The most common debug commands for the debugger</div>
<h2 id="uuid-82f677f0-23a7-4831-b52d-643147d44cfa">12.2.5 Debugging<span> </span>in IPython</h2>
<p>IPython comes with a version of the debugger called<span> </span><kbd>ipdb</kbd>. At the time of writing this book, the differences to <kbd>pdb</kbd> are very minor but this may change.</p>
<p>There is a command in IPython, <kbd>%pdb</kbd>, that automatically turns on the debugger in case of an exception. This is very useful when experimenting with new ideas or code. An example of how to automatically turn on the debugger in<span> </span><span>IPython is</span>:</p>
<pre>In [1]: %pdb # this is a so - called IPython magic command 
Automatic pdb calling has been turned ON

In [2]: a = 10

In [3]: b = 0

In [4]: c = a/b
___________________________________________________________________
ZeroDivisionError                  Traceback (most recent call last) 
&lt;ipython-input-4-72278c42f391&gt; in &lt;module&gt;() 
—-&gt; 1 c = a/b

ZeroDivisionError: integer division or modulo by zero 
&gt; &lt;ipython-input-4-72278c42f391&gt;(1)&lt;module&gt;()
      -1 c = a/b
ipdb&gt;</pre>
<p>The IPython magic command<span> </span><kbd>%pdb</kbd><span> </span>at the IPython prompt automatically enables the debugger when exceptions are raised. Here the debugger prompt shows<span> </span><kbd>ipdb</kbd> instead to indicate that the debugger is running.</p>
<h1 id="uuid-0666af5a-fae7-4da5-b6f6-590a5dbb80bd">12.3 Summary</h1>
<p>The key concepts in this chapter were exceptions and errors. We showed how an exception is raised to be <span>caught </span><span>later in another program unit. You can define your own exceptions and equip them with messages and current values of given variables.</span></p>
<p>The code may return unexpected results without throwing an exception. The technique to localize the source of the erroneous result is called debugging. We introduced debugging methods and hopefully encouraged you to train them so that you have them readily available when needed. The need for serious debugging comes sooner than you might expect.</p>


            </article>

            
        </section>
    </body></html>