- en: Input and Output
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover some options for handling data files. Depending
    on the data and the desired format, there are several options for reading and
    writing. We will show some of the most useful alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: File handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pickling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shelves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing Matlab data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.1 File handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'File **input and output**(**I/O**) is essential in a number of scenarios, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with measured or scanned data. Measurements are stored in files that
    need to be read in order to be analyzed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with other programs. Save results to files so that they can be imported
    into other applications, and vice-versa.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing information for future reference or comparisons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data and results with others, possibly on other platforms using other
    software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover how to handle file I/O in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.1 Interacting with files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, an object of the type `file` represents the contents of a physical
    file stored on a disk. A new object `file` may be created using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the file may be accessed, for instance, with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage of file objects requires some care. The problem is that a file has to
    be closed before it can be re-read or used by other applications, which is done
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not that simple because an exception might be triggered before the call
    to `close` is executed, which will skip the closing code (consider the following
    example). A simple way to make sure that a file will be properly closed is to
    use context managers. This construction, using the keyword `with`, is explained
    in more detail in [Section 12.1.3](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml):
    *Context **Managers – the with statement*. Here is how it is used with files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the file is closed when you exit the `with` block, even if
    an exception is raised inside the block. The command works with context manager
    objects. We recommend that you read more on context managers in [Section 12.1.3](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml): *Context*
  prefs: []
  type: TYPE_NORMAL
- en: '*Managers – the with statement*. Here is an example showing why the construct `with` is
    desirable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An exception is raised before the file is closed. The file remains open, and
    there is no guarantee of what data is written in the file or when it is written.
    Hence, the proper way to achieve the same result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In that case, the file is cleanly closed just after the exception (here, `ZeroDivisionError`)
    is raised. Notice also that there is no need to close the file explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1.2 Files are iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A file is, in particular, iterable (see [Section 9.3](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Iterable objects*). Files iterate their lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines of the file are returned as strings. The string method `split` is
    a possible tool to convert the string to a list of strings; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the object `myfile` is iterable, we can also do a direct extraction into
    a list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 14.1.3 File modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see in these examples of file handling, the function `open` takes
    at least two arguments. The first is obviously the filename, and the second is
    a string describing the way in which the file will be used. There are several
    such modes for opening files. The basic ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The modes `'r'`, `'r+'`, and `'a'` require that the file exists, whereas `'w'` will
    create a new file if no file with that name exists. Reading and writing with `'r'` and `'w'` is
    most common, as you saw in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of opening a file and adding data at the end of the file
    without modifying what is already there using the append mode `''a''`. Note the
    line break,`\n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 14.2 NumPy methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy has built-in methods for reading and writing NumPy array data to text
    files. These are `numpy.loadtxt` and `numpy.savetxt`.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2.1 savetxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing an array to a text file is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two useful parameters given as strings, `fmt`, and `delimiter`, which
    control the format and the delimiter between columns. The defaults are space for
    the delimiter and `%.18e` for the format, which corresponds to the exponential
    format with all digits. The formatting parameters are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 14.2.3 loadtxt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading to an array from a text file is done with the help of the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the fact that each row in an array must have the same length, each row
    in the text file must have the same number of elements. Similar to `savetxt`,
    the default values are `float` and the delimiter is a space. These can be set
    using the parameters `dtype` and `delimiter`. Another useful parameter is `comments`,
    which can be used to mark what symbol is used for comments in the data file. An
    example of using the formatting parameters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 14.3 Pickling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The read and write methods you just saw convert data to strings before writing.
    Complex types (such as objects and classes) cannot be written this way. With Python's module `pickle`,
    you can save any object and also multiple objects to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data can be saved in plain-text (ASCII) format or using a slightly more efficient
    binary format. There are two main methods: `dump`, which saves a pickled representation
    of a Python object to a file, and `load`, which retrieves a pickled object from
    the file. The basic usage is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the order in which the two objects are returned. Besides the two main
    methods, it is sometimes useful to serialize a Python object to a string instead
    of a file. This is done with `dumps` and `loads`. Consider an example of serializing
    an array and a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A good example of using `dumps` is when you need to write Python objects or
    NumPy arrays to a database. These usually have support for storing strings, which
    makes it easy to write and read complex data and objects without any special modules.
    Besides the `pickle` module, there is also an optimized version called `cPickle`.
    It is written in C and is an option if you need fast reading and writing. The
    data produced by pickle and *cPickle* is identical and can be interchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Shelves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects in dictionaries can be accessed by keys. There is a similar way to
    access particular data in a file by first assigning it a key. This is possible
    by using the module `shelve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Section 14.1.1](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml): *Interacting
    with files*, we saw that the built-in command `open` generates a context manager,
    and we saw why this is important for handling external resources, such as files.
    In contrast to this command, `sv.open` does not create a context manager by itself.
    The command `closing` from the module `contextlib` is needed to transform it into
    an appropriate context manager.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of restoring the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A `shelve` object has all dictionary methods, for example, keys and values,
    and can be used in the same way as a dictionary. Note that changes are only written
    in the file after one of the methods `close` or `sync` has been called.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5 Reading and writing Matlab data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SciPy has the ability to read and write data in Matlab's `.mat` file format
    using the module \pyth!scipy.io!. The commands are `loadmat` and `savemat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load data, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable data now contains a dictionary, with keys corresponding to the
    variable names saved in the `.mat` file. The variables are in NumPy array format.
    Saving to `.mat` files involves creating a dictionary with all the variables you
    want to save (variable name and value). The command is then `savemat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This saves the NumPy arrays, `x` and `y`, in Matlab's internal file format,
    thereby preserving variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 14.6 Reading and writing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The module `PIL.Image` comes with some functions for handling images. The following
    will read a *JPEG* image, print the shape and type, and then create a resized
    image, and write the new image to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'PIL creates an image object that can easily be converted to a NumPy array.
    As an array object, images are stored with pixel values in the range *0...255* as
    8-bit unsigned integers (`unint8`). The third shape value shows how many color
    channels the image has. In this case, *3* means it is a color image with values
    stored in this order: red `im_array[:,:,0]`, green `im_array[:,:,1]`, and blue `im_array[:,:,2]`.
    A grayscale image would only have one channel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For working with images, the module `PIL` contains many useful basic image
    processing functions, including filtering, transforms, measurements, and conversion
    from a NumPy array to a `PIL` image object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 14.7 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File handling is inevitable when dealing with measurements and other sources
    of a larger amount of data. Also, communication with other programs and tools
    is done via file handling.
  prefs: []
  type: TYPE_NORMAL
- en: You learned to see a file as a Python object, like others, with important methods
    such as `readlines` and `write`. We showed how files can be protected by special
    attributes, which may allow only read or write access.
  prefs: []
  type: TYPE_NORMAL
- en: The way you write to a file often influences the speed of the process. We saw
    how data is stored by pickling or by using the method `shelve`.
  prefs: []
  type: TYPE_NORMAL
