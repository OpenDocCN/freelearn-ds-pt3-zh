["```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: N = 100  # maximum population size\n            a = 0.5/N  # birth rate\n            b = 0.5/N  # death rate\n    ```", "```py\n    In [3]: nsteps = 1000\n            x = np.zeros(nsteps)\n            x[0] = 25\n    ```", "```py\n    In [4]: for t in range(nsteps - 1):\n                if 0 < x[t] < N-1:\n                    # Is there a birth?\n                    birth = np.random.rand() <= a*x[t]\n                    # Is there a death?\n                    death = np.random.rand() <= b*x[t]\n                    # We update the population size.\n                    x[t+1] = x[t] + 1*birth - 1*death\n                # The evolution stops if we reach 0 or N.\n                else:\n                    x[t+1] = x[t]\n    ```", "```py\n    In [5]: plt.plot(x)\n    ```", "```py\n    In [6]: ntrials = 100\n            x = np.random.randint(size=ntrials,\n                                  low=0, high=N)\n    ```", "```py\n    In [7]: def simulate(x, nsteps):\n                \"\"\"Run the simulation.\"\"\"\n                for _ in range(nsteps - 1):\n                    # Which trials to update?\n                    upd = (0 < x) & (x < N-1)\n                    # In which trials do births occur?\n                    birth = 1*(np.random.rand(ntrials) <= a*x)\n                    # In which trials do deaths occur?\n                    death = 1*(np.random.rand(ntrials) <= b*x)\n                    # We update the population size for all\n                    # trials.\n                    x[upd] += birth[upd] - death[upd]\n    ```", "```py\n    In [8]: bins = np.linspace(0, N, 25)\n    In [9]: nsteps_list = [10, 1000, 10000]\n            for i, nsteps in enumerate(nsteps_list):\n                plt.subplot(1, len(nsteps_list), i + 1)\n                simulate(x, nsteps)\n                plt.hist(x, bins=bins)\n                plt.xlabel(\"Population size\")\n                if i == 0:\n                    plt.ylabel(\"Histogram\")\n                plt.title(\"{0:d} time steps\".format(nsteps))\n    ```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: rate = 20\\.  # average number of events per second\n    ```", "```py\n    In [3]: dt = .001  # time step\n            n = int(1./dt)  # number of time steps\n    ```", "```py\n    In [4]: x = np.zeros(n)\n            x[np.random.rand(n) <= rate*dt] = 1\n    ```", "```py\n    In [5]: x[:5]\n    Out[5]: array([ 0.,  1.,  0.,  0.,  0\\. ])\n    ```", "```py\n    In [6]: plt.vlines(np.nonzero(x)[0], 0, 1)\n            plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [7]: plt.plot(np.linspace(0., 1., n), np.cumsum(x))\n            plt.xlabel(\"Time\")\n            plt.ylabel(\"Counting process\")\n    ```", "```py\n    In [8]: y = np.cumsum(np.random.exponential(\n                                 1./rate, size=int(rate)))\n    ```", "```py\n    In [9]: y[:5]\n    Out[9]: array([ 0.006,  0.111,  0.244,  0.367,  0.365])\n    ```", "```py\n    In [10]: plt.vlines(y, 0, 1)\n             plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: n = 5000\n    ```", "```py\n    In [3]: x = np.cumsum(np.random.randn(n))\n            y = np.cumsum(np.random.randn(n))\n    ```", "```py\n    In [4]: k = 10  # We add 10 intermediary points between two \n                    # successive points.\n            # We interpolate x and y.\n            x2 = np.interp(np.arange(n*k), np.arange(n)*k, x)\n            y2 = np.interp(np.arange(n*k), np.arange(n)*k, y)\n    In [5]: # Now, we draw our points with a gradient of \n            # colors.\n            plt.scatter(x2, y2, c=range(n*k), linewidths=0,\n                        marker='o', s=3, cmap=plt.cm.jet)\n            plt.axis('equal')\n            plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: sigma = 1\\.  # Standard deviation.\n            mu = 10.0  # Mean.\n            tau = 0.05  # Time constant.\n    ```", "```py\n    In [3]: dt = 0.001  # Time step.\n            T = 1.0  # Total time.\n            n = int(T/dt)  # Number of time steps.\n            t = np.linspace(0., T, n)  # Vector of times.\n    ```", "```py\n    In [4]: sigma_bis = sigma * np.sqrt(2\\. / tau)\n            sqrtdt = np.sqrt(dt)\n    ```", "```py\n    In [5]: x = np.zeros(n)\n    ```", "```py\n    In [6]: for i in range(n-1):\n                x[i+1] = x[i] + dt*(-(x[i]-mu)/tau) + \\\n                         sigma_bis * sqrtdt * np.random.randn()\n    ```", "```py\n    In [7]: plt.plot(t, x)\n    ```", "```py\n    In [8]: ntrials = 10000\n            X = np.zeros(ntrials)\n    In [9]: # We create bins for the histograms.\n            bins = np.linspace(-2., 14., 50);\n            for i in range(n):\n                # We update the process independently for all\n                # trials.\n                X += dt*(-(X-mu)/tau) + \\\n                     sigma_bis*sqrtdt*np.random.randn(ntrials)\n                # We display the histogram for a few points in\n                # time.\n                if i in (5, 50, 900):\n                    hist, _ = np.histogram(X, bins=bins)\n                    plt.plot((bins[1:]+bins[:-1])/2,  hist,\n                             label=\"t={0:.2f}\".format(i*dt))\n                plt.legend()\n    ```"]