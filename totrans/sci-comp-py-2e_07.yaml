- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces functions, a fundamental building block in programming.
    We show how to define them, how to handle input and output, how to properly use
    them, and how to treat them as objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions in mathematics and functions in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions are objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions – the keyword `lambda`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1 Functions in mathematics and functions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics, a function is written as a map that uniquely assigns to every
    element ![](img/89f426e0-adb7-4ef9-b912-278993b26f35.png) from the domain *![](img/15cf5f8d-54c0-4464-8e43-130804048db7.png)*
    a corresponding element ![](img/d900968b-92f1-4fdb-9c1c-438c64794e2b.png) from
    the range ![](img/196ecfe6-b8c8-4550-9f29-9b136a555cc7.png).
  prefs: []
  type: TYPE_NORMAL
- en: This is expressed by *![](img/89d0dd79-9ade-4d44-b0eb-0626c808e581.png).*
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, when considering particular elements ![](img/e2fc557d-295f-4e14-88df-711e26a8f84f.png)
    and ![](img/632e9af1-ad40-45a1-ab58-0e09997f0262.png), you write ![](img/5f74a00c-0ba1-4bf4-9ea2-6ba4bc30ac39.png).
  prefs: []
  type: TYPE_NORMAL
- en: Here, ![](img/56d5d832-f148-4f4b-a6e1-e1f0fcc2652a.png) is called the name of
    the function and ![](img/3588ed47-5f38-428e-acf2-876c76dd8d16.png) is its value
    when applied to ![](img/a5117bc4-e31a-4d05-9465-f5b747caea99.png). Here, *![](img/3435f1a2-4591-43ed-b9af-99edeb63de74.png)*
    is sometimes called the argument of ![](img/ab2f2260-ab84-4410-9a3e-8902931eb19a.png).
    Let's first look at an example before considering functions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ![](img/31802895-c824-49de-9a09-bf24daaa65fb.png) and ![](img/f7efefb7-81ad-4118-9f5d-30133e021096.png).
    This function maps two real numbers to their difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, functions can have numbers, vectors, matrices, and even other
    functions as arguments. Here is an example of a function with mixed arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f736ebec-686e-4796-b4a9-f0d3d54ac072.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, a real number is returned. When working with functions, we have
    to distinguish between two different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluation of the function, that is, the computation of *![](img/c1ac1058-17b6-4c2d-ba2f-f8ce7303bde3.png)*
    for a given value of *![](img/7bbf122b-e48d-4395-96df-d601e8dee3dc.png)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step is done once, while the second can be performed many times for
    various arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in programming languages follow mainly the same concept and apply
    it to a wide range of types of input arguments, for example, strings, lists, floats,
    or simply any object. We demonstrate a definition of a function by considering
    the given example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `def` indicates that we are going to define a function. `subtract`
    is the function’s name and `x1` and `x2` are its parameters. The colon indicates
    that we are using a block command. The value that is returned by the function
    follows the keyword `return`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can evaluate this function. The function is called with its parameters
    replaced by input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result `0.7` is computed and assigned to the variable `r`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Parameters and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining a function, its input variables are called the *parameters* of
    the function. The input used when executing the function is called its *argument*.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.1 Passing arguments – by position and by keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will consider the previous example again, where the function takes two parameters,
    namely `x1` and `x2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their names serve to distinguish the two numbers, which in this case cannot
    be interchanged without altering the result. The first parameter defines the number
    from which the second parameter is subtracted. When `subtract` is called, every
    parameter is replaced by an argument. Only the order of the arguments matters;
    the arguments can be any object. For instance, we may call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides this standard way of calling a function, which is bypassing the arguments
    by position, it might sometimes be convenient to pass arguments using keywords.
    The names of the parameters are the keywords; consider the following instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the arguments are assigned to the parameters by name and not by position
    in the call. Both ways of calling a function can be combined so that the arguments
    given by position come first and the arguments given by keyword follow last. We
    show this by using the function `plot`, which was described in [Section 6.1](86c61820-e645-486c-9418-10079ffac7f8.xhtml):
    *Basic plotting*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 7.2.2 Changing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of parameters is to provide the function with the necessary input
    data. Changing the value of the parameter inside the function normally has no
    effect on its value outside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This applies to all immutable arguments, such as strings, numbers, and tuples.
    The situation is different if mutable arguments, such as lists or dictionaries,
    are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, passing mutable input arguments to a function and changing them
    inside the function can change them outside the function too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a function misuses its arguments to return results. We strongly dissuade
    you from such constructions and recommend that you do not change input arguments
    inside the function (for more information, see [Section 7.2.4](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Default arguments*).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.3 Access to variables defined outside the local namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python allows functions to access variables defined in any of its enclosing
    program units. These are called global variables, in contrast to local variables.
    The latter is only accessible within the function. For example, consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature should not be abused. The following code is an example of what
    not to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When changing the variable `a`, the function `multiply` tacitly changes its
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is much better, in that case, to provide the variable as a parameter through
    the argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Global variables can be useful when working with closures; see also the related
    example in [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Anonymous
    functions – the* *keyword* *lambda**.*'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.4 Default arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some functions can have many parameters, and among them, some might only be
    of interest in nonstandard situations. It would be practical if arguments could
    automatically be set to standard (default) values.
  prefs: []
  type: TYPE_NORMAL
- en: We demonstrate the use of default arguments by looking at the command `norm`
    in the module `scipy.linalg`. It computes various norms of matrices and vectors. More
    on matrix norms can be found in [[10 ,§2.3]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following calls for computing the Frobenius **norm** of the ![](img/3966daf2-2ea1-4563-9c44-061c1042b7b3.png)
    identity matrix are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the first call, no information about the keyword `ord` is given.
    How does Python know that it should compute the Frobenius norm and not another
    norm, for example, the Euclidean 2-norm?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the previous question is the use of default values. A default
    value is a value already given by the function definition. If the function is
    called without providing this argument, Python uses the value that the programmer
    provided when the function was defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we call the function `subtract` and provide it with only one argument;
    we would get an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow the omission of the argument `x2`, the definition of the function
    has to provide a *default value*, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Default arguments are given in the definition of the function by assigning a
    value to one of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, arguments can be given as positional arguments and keyword arguments.
    All positional arguments have to be given first. You do not need to provide all
    keyword arguments as long as those omitted arguments have default values in the
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of mutable default arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default arguments are set upon function definition. Changing mutable arguments
    inside a function has a side effect when working with default values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Recall, lists are mutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.5 Variable number of arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists and dictionaries may be used to define or call functions with a variable
    number of arguments. Let''s define a list and a dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can call the `plot` function using starred (`*`) arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable name prefixed by `*`, such as `*data` in the preceding example,
    means that a list that gets unpacked to provide the function with its arguments.
    In this way, a list generates positional arguments. Similarly, a variable name
    prefixed by `**`, such as `**style` in the example, unpacks a dictionary to keyword
    arguments; see *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af27c774-d30e-4912-82c4-83562b036b9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Starred arguments in function calls'
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to use the reverse process, where all given positional arguments
    are packed into a list and all keyword arguments are packed into a dictionary
    when passed to a function. In the function definition, this is indicated by parameters
    prefixed by `*` and `**`, respectively. You will often find the parameters `*args`
    and `**kwargs` in code documentation; see *Figure 7.2.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/351df170-0fda-4879-a49e-9bf80d2526e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Starred arguments in function definitions'
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function in Python always returns a single object. If a function has to return
    more than one object, these are packed and returned as a single tuple object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following function takes a complex number ![](img/0bac0f3d-d6ac-4268-a99e-0f971194689b.png)
    and returns its polar coordinate representation as magnitude ![](img/5530f0e2-5dac-46e6-9980-2221beb32362.png)
    and angle ![](img/7414aca2-5855-4e3b-9c08-d2f13de7acc3.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: (See also Euler’s formula, ![](img/de874ce0-e2fa-4001-9103-6dd2ec877c4a.png).)
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used the NumPy function `sqrt(x)` for the square root of a number `x`
    and `arctan2(x,y)` for the expression ![](img/b3c0157c-8a54-45ae-99c2-05f5c7ef11d5.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The last three statements can be written more elegantly in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can test our function by calling `polar_to_comp` defined in *Exercise 1*
    in the *Exercises* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function has no `return` statement, it returns the value `None`. There
    are many cases where a function does not need to return any value. This could
    be because the variables passed to a function may be subject to modification.
    Consider, for instance, the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function does not return anything because it modifies one of the
    objects that is given as a mutable argument. There are many methods that behave
    in the same way. To mention the list methods only, the methods `append`, `extend`,
    `reverse`, and `sort` do not return anything (that is, they return `None` ). When
    an object is modified by a method in this way, the modification is called *in
    place*. It is difficult to know whether a method changes an object, except by
    looking at the code or the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for a function, or a method, not to return anything is when it
    prints out a message or writes to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution stops at the first occurring `return` statement. Lines after
    that statement are dead code that will never be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 7.4 Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics, many functions are defined recursively. In this section, we
    will show how this concept can be used even when programming a function. This
    makes the relation of the program to its mathematical counterpart very clear,
    which may ease the readability of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we recommend using this programming technique with care, especially
    within scientific computing. In most applications, the more straightforward iterative
    approach is more efficient. This will become immediately clear from the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chebyshev polynomials are defined by a three-term recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/599c7304-96a1-4b1c-8d58-e91f7d52874b.png)'
  prefs: []
  type: TYPE_IMG
- en: Such a recursion needs to be initialized, that is, *[![](img/a68a459e-835f-492b-84de-87e405fd258f.png)].*
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, this *three-term recursion* can be realized by the following function
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute ![](img/30b7eadf-af02-468d-84cb-081ad13a56cb.png), the function
    is then called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This example also illustrates the risk of dramatically wasting computation time.
    The number of function evaluations increases exponentially with the recursion
    level and most of these evaluations are just duplicates of previous computations.
    While it might be tempting to use recursive programs for demonstrating the strong
    relation between code and mathematical definition, production code will avoid
    this programming technique (see also *Exercise* *6 *in the *Exercises *section).
    We also refer to a technique called memoization that combines recursive programming
    with a caching technique to save replicated function evaluations, see [[22]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive function usually has a level parameter. In the previous example,
    it is `n`*.* It is used to control the function''s two main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The base case; here, the first two `if` branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive body, in which the function itself is called once or several times
    with smaller-level parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number of levels passed by the execution of a recursive function is called
    the recursion depth. This quantity should not be too large; otherwise, the computation
    might no longer be efficient and, in the ultimate case, the following error will
    be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximal recursion depth depends on the memory of the computer you use.
    This error also occurs when the initialization step is missing in the function
    definition. We encourage the use of recursive programs for very small recursion
    depths only (for more information, see [Section 9.7.2](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Recursion*).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Function documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should document your functions using a string at the beginning. This string
    is called a *docstring*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling `help(newton)`, you get this docstring displayed together with
    the call of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The docstring is internally saved as an attribute, `__doc__`, of the given function.
    In the example, it is `newton.__doc__`. The minimal information you should provide
    in a docstring is the purpose of the function and the description of the input
    and output objects. There are tools to automatically generate full code documentation
    by collecting all docstrings in your program (for more information, see the documentation
    of Sphinx, [[32]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Functions are objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are objects, like everything else in Python. You may pass functions
    as arguments, change their names, or delete them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Passing functions as arguments is very common when applying algorithms in scientific
    computing. The function `fsolve` in `scipy.optimize` for computing a zero of a
    given function or `quad` in `scipy.integrate` for computing integrals are typical
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: A function itself can have a different number of arguments with differing types.
    So, when passing your function `f` to another function `g` as an argument, make
    sure that `f` has exactly the form described in the docstring of `g`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The docstring of `fsolve` gives information about its parameter `func`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 7.6.1 Partial application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with an example of a function with two variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function ![](img/9502da7b-86bf-48e3-8564-7821236cc621.png) can be viewed
    as a function in two variables. Often you consider ![](img/338903f2-95ad-4f1e-a84c-eafbfeb69218.png)
    not as a free variable but as a fixed parameter of a family of functions *![](img/eeaff405-ef7d-405b-8f02-e3bff86d22fb.png)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/61ae8234-2d80-4209-af59-a3d132be42cb.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: This interpretation reduces a function in two variables to a function in one
    variable ![](img/3be52ca7-be0d-413c-990e-475b16061773.png) given a fixed parameter
    value *![](img/49a1eac7-3ffe-48ef-9a3d-3f4b0cca152d.png)*. The process of defining
    a new function by fixing (freezing) one or several parameters of a function is
    called partial application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial applications are easily created using the Python module `functools`,
    which provides a function called `partial` for precisely this purpose. We illustrate
    this by constructing a function that returns a sine for a given frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the last line, the newly created function is evaluated at ![](img/7dab2cdb-e183-49f4-a87d-9369f0a1240f.png).
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.2 Using closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the view that functions are objects, partial applications can be realized
    by writing a function, which itself returns a new function, with a reduced number
    of input arguments. For instance, the function `make_sine` could be defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the inner function `mysine` has access to the variable `freq`;
    it is neither a local variable of this function nor is it passed to it via the
    argument list. Python allows such a construction, see [Section](919d9596-6c84-492d-8b65-8f1045866d8e.xhtml)
    13.1, *Namespaces*.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Anonymous functions – the keyword lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The keyword `lambda` is used in Python to define anonymous functions, that is,
    functions without a name and described by a single expression. You might just
    want to perform an operation on a function that can be expressed by a simple expression
    without naming this function and without defining this function by a lengthy `def`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: The name *lambda* originates from a special branch of calculus and mathematical
    logic, the ![](img/8acb12a5-c98d-4653-ac41-9e4fba93f10a.png)-calculus.
  prefs: []
  type: TYPE_NORMAL
- en: 'We demonstrate the use of `lambda`-functions by numerically evaluating the
    following integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7b1ca59-f9c8-4ae1-965b-1fe67f6f9331.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use SciPy’s function `quad`, which requires as its first argument the function
    to be integrated and the integration bounds as the next two arguments. Here, the
    function to be integrated is just a simple one-liner and we use the keyword `lambda`
    to define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the function `lambda` can only consist of a single expression
    and, in particular, cannot contain loops. `lambda` functions are, just like other
    functions, objects and can be assigned to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 7.7.1 The lambda construction is always replaceable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to note that the `lambda` construction is only syntactic sugar
    in Python. Any `lambda` construction may be replaced by an explicit function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The main reason to use this construction is for very simple functions when a
    full function definition would be too cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda` functions provide a third way to make closures as we demonstrate by
    continuing with the previous example, [![](img/c651f3a5-f426-4197-8b0c-52b7da0dfa85.png)].'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the function `sin_omega` from [Section 7.6.1](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml),
    *Partial Application*, to compute the integral of the sine function for various
    frequencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 7.8 Functions as decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Section 7.6.1](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Partial application*,
    we saw how a function can be used to modify another function. A *decorator* is
    a syntax element in Python that conveniently allows us to alter the behavior of
    a function without changing the definition of the function itself. Let''s start
    with the following situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a function that determines tcitehe degree of sparsity of
    a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns an error if it is not called with an array object as
    input. More precisely, it will not work with an object that does not implement
    the method `reshape`. For instance, the function `how_sparse` will not work with
    a list, because lists have no method `reshape`. The following helper function
    modifies any function with one input parameter so that it tries to make a type
    conversion to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the modified function `how_sparse = cast2array(how_sparse)` can be applied
    to any object that can be cast to an array. The same functionality is achieved
    if the definition of `how_sparse` is decorated with this type conversion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To define a decorator, you need a callable object such as a function that modifies
    the definition of the function to be decorated. The main purposes are:'
  prefs: []
  type: TYPE_NORMAL
- en: To increase code readability by separating parts from a function that do not
    directly serve its functionality (for example, memoizing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put common preamble and epilogue parts of a family of similar functions in
    a common place (for example, type checking)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to easily switch off and on additional functionalities of a function
    (for example, test prints or tracing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended also to consider `functools.wraps`,  see also [[8]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are not only the ideal tools for making your program modular, but
    they also reflect mathematical thinking. You learned the syntax of function definitions
    and how to distinguish between defining and calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: We considered functions as objects that can be modified by other functions.
    When working with functions, it is important to be familiar with the notion of
    the scope of a variable and how information is passed into a function by parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is convenient to define functions on the fly with so-called anonymous
    functions. For this, we introduced the keyword `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex 1:** Write a function `polar_to_comp`, which takes two arguments ![](img/e834ef4c-2926-4ad9-9504-de4b2234bc13.png)
    and ![](img/4f3160df-59d2-427a-b19a-51eb90212f65.png) and returns the complex
    number ![](img/6e1ade86-768c-4fe4-9963-7bde1348f589.png). Use the NumPy function
    `exp` for the exponential function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex 2**: In the description of the Python module `functools`, [[8]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml),
    you find the following Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Explain and test this function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex 3**: Write a decorator for the function `how_sparse`, which cleans the
    input matrix `A` by setting the elements that are less than `1.e-16` to zero (consider
    the example in [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Functions
    as decorators*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex 4:** A continuous function ![](img/edafb426-3175-4e5d-af76-2d21dc0acd01.png)
    with ![](img/3c9e124d-b89a-4263-ab14-04b3293dfaea.png) changes its sign in the
    interval ![](img/bff068a9-97e1-48a0-a3f5-3f16aa97fd84.png) and has at least one
    root (zero) in this interval. Such a root can be found with the *bisection method*.
    This method starts from the given interval. Then it investigates the sign changes
    in the subintervals'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40f2d3ed-3d13-44bd-b5a0-7fe826182297.png) and ![](img/a4aff68c-105a-4e2e-93e1-a93487e3f53e.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the sign changes in the first subinterval, ![](img/aeb1a071-16be-4a0e-8dc7-06b3fb165cb3.png)
    is redefined to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55964a4d-c0f2-4cac-9220-584b8c3f556f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Otherwise, it is redefined in the same manner to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da78bd63-e2ee-44d6-a9e2-7ce4c207a3b2.png)'
  prefs: []
  type: TYPE_IMG
- en: The process is repeated until the length of the interval, ![](img/ac340bd1-abae-44ba-b90f-af0835bce7e6.png),
    is less than a given tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement this method as a function that takes as arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function ![](img/1b4d26a9-8021-47fc-86c0-d9eba66e8ae3.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial interval ![](img/d1d3fe72-5545-44ef-9b0c-f9eafcc6b766.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function `bisec` should return the final interval and its midpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the method with the function `arctan` and also with the polynomial [*![](img/a44ef6a3-4361-4334-a506-8ed64ba6ac2d.png)*]
    in the interval [![](img/cfac34a9-ed11-43cb-ad61-45b93d31b3ce.png)], and alternatively
    in [![](img/11738e6a-23a2-47bc-a263-9bd5d72fa98b.png)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ex. 5:** The greatest common divisor of two integers can be computed with
    *Euclid’s algorithm* described by the following recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a74e62b-aed2-4ba1-8520-8a46208dac88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write a function that computes the greatest common divisor of two integers.
    Write another function that computes the least common multiple of these numbers
    using the relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b854bc-725e-4380-8491-1321cefce918.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 6**: Study the recursive implementation of Chebyshev polynomials. Consider
    the example in [Section 7.4](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Recursive
    functions*. Rewrite the program in a non-recursive way and study computation time
    versus polynomial degree (see also the module `timeit`).'
  prefs: []
  type: TYPE_NORMAL
