<html><head></head><body>
		<div id="_idContainer072">
			<h1 id="_idParaDest-61"><em class="italic"><a id="_idTextAnchor060"/>Chapter 4</em>: Data Manipulation and Preparation, Paving the Way to Plotly Express</h1>
			<p>We saw that preparing data can take much more mental effort and code than the process of creating charts. Or, to put it differently, if we invest a good amount of time in preparing our data and making certain decisions about how and what we intend to do with it, the process of visualization can be made much easier. So far, we have used a small part of our dataset and didn't make any changes to its shape or format. And when making our charts, we followed the approach of building them from scratch by creating a figure and then adding different layers and options for traces, titles, and so on.</p>
			<p>In this chapter, we will go through a thorough familiarization with the dataset and reshape it to an intuitive and easy-to-use format. This will help us in using a new approach for creating visualizations, using <strong class="bold">Plotly Express</strong>. Instead of starting with an empty rectangle and building layers on top of it, we will start with the features (columns) of our dataset, and create visualizations based on them. In other words, instead of being screen- or chart-oriented, we will work with more of a data-oriented approach. We will also compare the two approaches and discuss when to use them.</p>
			<p>We will mainly cover the following topics:</p>
			<ul>
				<li>Understanding long format (tidy) data</li>
				<li>Understanding the role of data manipulation skills</li>
				<li>Learning Plotly Express</li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Technical requirements</h1>
			<p>Technically, no new packages will be used in this chapter, but as a major module of Plotly, we can consider Plotly Express to be a new one. We will also be extensively using <strong class="source-inline">pandas</strong> for data preparation, reshaping, and general manipulation. This will mainly be done in JupyterLab. Our dataset will consist of the files in the <strong class="source-inline">data</strong> folder in the root of the repository.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3suvKi4">https://bit.ly/3suvKi4</a>.</p>
			<p>Let's start by exploring the different formats in which we can have data, and what we can do about it.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Understanding long format (tidy) data</h1>
			<p>We have a moderately complex dataset that we will be working with. It consists of four CSV files, containing <a id="_idIndexMarker139"/>information on almost all the countries and regions in the world. We have more than 60 metrics spanning more than 40 years, which means that there are quite a lot of options and combinations to choose from.</p>
			<p>But before going through the process of preparing our dataset, I'd like to demonstrate our end goal with a simple example, so you have an idea of where we are heading. It will also hopefully show why we are investing time in making those changes.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Plotly Express example chart</h2>
			<p>Plotly Express ships with a few datasets for practicing and testing certain features whenever <a id="_idIndexMarker140"/>you want to do so. They fall <a id="_idIndexMarker141"/>under the <strong class="source-inline">data</strong> module of <strong class="source-inline">plotly.express</strong>, and calling them as functions returns the respective dataset. Let's take a look at the famous Gapminder dataset:</p>
			<p class="source-code">import plotly.express as px</p>
			<p class="source-code">gapminder = px.data.gapminder()</p>
			<p class="source-code">gapminder</p>
			<p>Running this code displays sample rows of the <strong class="source-inline">gapminder</strong> DataFrame as you can see in <em class="italic">Figure 4.1</em>:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B16780_04_1.jpg" alt="Figure 4.1 – The Gapminder dataset included in Plotly Express"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The Gapminder dataset included in Plotly Express</p>
			<p>The dataset structure seems straightforward. For each unique combination of <strong class="bold">country</strong>, <strong class="bold">continent</strong>, and <strong class="bold">year</strong>, we have three metrics: <strong class="bold">lifeExp</strong>, <strong class="bold">pop</strong>, and <strong class="bold">gdpPercap</strong>. The <strong class="bold">iso_alpha</strong> and <strong class="bold">iso_num</strong> columns seem to be encoded values for the countries.</p>
			<p>Let's see how we might summarize the <strong class="source-inline">gapminder</strong> <strong class="source-inline">data_frame</strong> with a <strong class="source-inline">scatter</strong> plot.</p>
			<p>On the <strong class="source-inline">x</strong> axis, we can have the <strong class="bold">gdpPercap</strong> values, and as a function of that, on the <strong class="source-inline">y</strong> axis, it would <a id="_idIndexMarker142"/>be good to see the <strong class="bold">lifeExp</strong> values and <a id="_idIndexMarker143"/>check whether/how they vary from each other. It would also be good to have the <strong class="source-inline">size</strong> of the markers reflect the population of the respective countries.</p>
			<p>We might also split the chart horizontally (<strong class="source-inline">facet_col</strong>), into sub-plots, one for each continent, on one row, and make the sub-plot titles reflect that as well. We can also assign a separate <strong class="source-inline">color</strong> to each continent's markers. For more clarity, we can set the <strong class="source-inline">title</strong> of the figure to <strong class="source-inline">'Life Expectancy and GDP per capita. 1952 – 2007'</strong>.</p>
			<p>To make them clearer, we can change the <strong class="source-inline">labels</strong> of the X and Y axes' titles from <strong class="source-inline">'gdpPercap'</strong> to <strong class="source-inline">'GDP per Capita'</strong>, and from <strong class="source-inline">'lifeExp'</strong> to <strong class="source-inline">'Life Expectancy'</strong> respectively.</p>
			<p>We would expect the GDP per capita to have outliers and not to be normally distributed, so we can set the type of the X-axis scale to logarithmic (<strong class="source-inline">log_x</strong>). The range of the Y-axis (<strong class="source-inline">range_y</strong>) should be the interval [20, 100], so we can see how life expectancy varies on a fixed vertical range.</p>
			<p>Hovering over the markers should show the full information for that particular country, and the title of the hover label (<strong class="source-inline">hover_name</strong>) should take the name of the country. Having the same chart overlaid on top of itself for all years would be really cluttered and almost impossible to read. So let's have a separate <strong class="source-inline">animation_frame</strong> for each of the years.</p>
			<p>It would <a id="_idIndexMarker144"/>be great if we could have a <a id="_idIndexMarker145"/>play button that would move the markers across years when clicked, one frame per year, like a video, with the option to stop it at a certain year.</p>
			<p>The <strong class="source-inline">height</strong> of the figure should be 600 pixels: </p>
			<p class="source-code">px.<strong class="bold">scatter</strong>(<strong class="bold">data_frame</strong>=gapminder,</p>
			<p class="source-code">           <strong class="bold">x</strong>='gdpPercap',</p>
			<p class="source-code">           <strong class="bold">y</strong>='lifeExp',</p>
			<p class="source-code">           <strong class="bold">size</strong>='pop',</p>
			<p class="source-code">           <strong class="bold">facet_col</strong>='continent',</p>
			<p class="source-code">           <strong class="bold">color</strong>='continent',</p>
			<p class="source-code">           <strong class="bold">title</strong>='Life Expectancy and GDP per capita. 1952 - 2007',</p>
			<p class="source-code">           <strong class="bold">labels</strong>={'gdpPercap': 'GDP per Capita',</p>
			<p class="source-code">                   'lifeExp': 'Life Expectancy'},</p>
			<p class="source-code">           <strong class="bold">log_x</strong>=True,</p>
			<p class="source-code">           <strong class="bold">range_y</strong>=[20, 100],</p>
			<p class="source-code">           <strong class="bold">hover_name</strong>='country',</p>
			<p class="source-code">           <strong class="bold">animation_frame</strong>='year',</p>
			<p class="source-code">           <strong class="bold">height</strong>=600,</p>
			<p class="source-code">           <strong class="bold">size_max</strong>=90)</p>
			<p>Running the preceding code would produce the visualization in <em class="italic">Figure 4.2</em>:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B16780_04_2.jpg" alt="Figure 4.2 – An interactive chart of the Gapminder dataset using Plotly Express"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – An interactive chart of the Gapminder dataset using Plotly Express</p>
			<p>My first observation for this process is that it took us much more text than code to describe the chart. Actually, it was a single line of code that produced it.</p>
			<p>Clicking the <a id="_idIndexMarker146"/>play button would <a id="_idIndexMarker147"/>animate the chart, and you would see a new frame for each year. You could also pause or move to a certain year if you want. This way you can see how the relationship between the two variables progressed through the years, like watching a short movie.</p>
			<p>You can also see that hovering over a certain marker representing a country would show all relevant data that was used to specify the location, size, color, and whatever other attributes we might have set. The <strong class="source-inline">hover_name</strong> argument was set to <strong class="source-inline">'country'</strong> and this is why you see it in bold as the title of the label.</p>
			<p>In most cases, we have markers overlapping, which makes it difficult to understand the chart. Because Plotly figures are interactive by default, we can easily use the modebar buttons to zoom in/out, or we can manually select a certain rectangle to zoom into.</p>
			<p>Zooming into Africa by selecting the rectangle that contains only its markers, <em class="italic">Figure 4.3</em> shows how the chart changes, and now it is much easier to read the African sub-plot:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B16780_04_3.jpg" alt="Figure 4.3 – Zooming into specific regions in charts"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Zooming into specific regions in charts</p>
			<p>Note that all <a id="_idIndexMarker148"/>other continent <a id="_idIndexMarker149"/>charts were also zoomed in to the same zoom level of Africa. Feel free to explore more of the interactive features, but I hope this shows how powerful and intuitive this approach is.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There are many colored charts in this chapter. I did my best to make sure you can easily distinguish between colored markers as much as possible. It's still better to refer to the color version of the book, which is available online, if you are reading the print version.</p>
			<p>There are two main reasons that allowed us to create such a rich chart with one line of code. First, Plotly Express has powerful features and is specially designed to produce such charts with minimal code. This will be covered in more detail later. Second, the structure of the dataset plays an important role in the process. Once we have our data in a consistent format, it becomes easy to model, visualize, or run any kind of analysis.</p>
			<p>Let's take a look at the main aspects of this data format.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Main attributes of long format (tidy) data</h2>
			<p>One of the key features of this structure is that it allows each marker on the chart to be independently <a id="_idIndexMarker150"/>represented by a row. Each value in those rows belongs to a distinct column. In turn, those columns each represent a separate variable and have their own data types. This makes it easy to map color, size, or whatever visual attributes we want, simply by declaring which column values we want to express with which visual attribute.</p>
			<p>Notice that what I just said is close to the definition of a DataFrame:</p>
			<ul>
				<li>A set of columns, where each has exactly one type of data.</li>
				<li>Columns in a DataFrame can be of different types.</li>
				<li>All columns have the same length, even though they might contain missing values.</li>
			</ul>
			<p>From a conceptual point of view, the main difference between a long form DataFrame and a regular one is having one observation per row (country, person, brand, or a combination of them), and one variable per column (population, size, length, height, revenue, and so on). For example, the <strong class="bold">country</strong> column contains countries and only countries. Additionally, countries are only present in this column. So, there is no ambiguity about where or how to access them.</p>
			<p>This format is not required and is not any more "correct" than other formats. It is simply intuitive, consistent, and easy to use. The actual requirement for producing the visualization we just did is to have a set of values for the X axis and another set of values of the same length for the Y axis. For other features such as color and size, we also need sets of numbers or names of the same length, so we can properly map them together. The DataFrame is a natural fit for such a requirement.</p>
			<p>In the chart we just produced, you can easily see that we can have all markers the same size, simply by removing the <strong class="source-inline">size</strong> argument. Changing <strong class="source-inline">facet_col</strong> to <strong class="source-inline">facet_row</strong> would immediately have the sub-plots vertically stacked on top of one another as opposed to side by side. Minimal tweaks allow us to introduce big changes to our visualizations. This is as simple as flipping switches on a dashboard, pun intended!</p>
			<p>I hope the end goal is now clear. We want to check the four files of our dataset and see how to generate long format (tidy) DataFrames. As a result, every column would contain data about one variable (year, population, Gini index, and so on), and every row would describe an observation (a combination of country, year, metric, and other values). Once that <a id="_idIndexMarker151"/>is done, we should be able to look at the data, specify what we want, and express that with a concise Plotly Express function call.</p>
			<p>The process will be much clearer once we start the preparation, so let's start right away.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Understanding the role of data manipulation skills</h1>
			<p>In practical situations, we rarely have our data in the format that we want; we usually have different <a id="_idIndexMarker152"/>datasets that we want to merge, and often, we need to normalize and clean up the data. For these reasons, data manipulation and preparation will always play a big part in any data visualization process. So, we will be focusing on this in this chapter and throughout the book.</p>
			<p>The plan for preparing our dataset is roughly the following:</p>
			<ol>
				<li value="1">Explore the different files one by one.</li>
				<li>Check the available data and data types and explore how each can help us categorize and analyze the data.</li>
				<li>Reshape the data where required.</li>
				<li>Combine different DataFrames to add more ways to describe our data.</li>
			</ol>
			<p>Let's go through these steps right away.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Exploring the data files</h2>
			<p>We start <a id="_idIndexMarker153"/>by reading in the files in the <strong class="source-inline">data</strong> folder:</p>
			<p class="source-code">import os</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">pd.options.display.max_columns = None</p>
			<p class="source-code">os.listdir('data')</p>
			<p class="source-code">['PovStats<strong class="bold">Series</strong>.csv',</p>
			<p class="source-code"> 'PovStats<strong class="bold">Country</strong>.csv',</p>
			<p class="source-code"> 'PovStats<strong class="bold">Country-Series</strong>.csv',</p>
			<p class="source-code"> 'PovStats<strong class="bold">Data</strong>.csv',</p>
			<p class="source-code"> 'PovStats<strong class="bold">FootNote</strong>.csv']</p>
			<p>To make <a id="_idIndexMarker154"/>things clear, I'll use the distinct part of each filename as the variable name for each DataFrame: <strong class="source-inline">'PovStats&lt;name&gt;.csv'</strong>.</p>
			<h3>The series file</h3>
			<p>We start <a id="_idIndexMarker155"/>by exploring the <strong class="source-inline">series</strong> file, using the following code:</p>
			<p class="source-code">series = pd.DataFrame('data/'PovStatsSeries.csv')</p>
			<p class="source-code">print(series.shape)</p>
			<p class="source-code">series.head()</p>
			<p>This will <a id="_idIndexMarker156"/>display the <strong class="source-inline">shape</strong> attribute of the DataFrame, as well as the first five rows, as you can see in <em class="italic">Figure 4.4</em>:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B16780_04_4.jpg" alt="Figure 4.4 – The first few rows and columns of the PovStatsSeries file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – The first few rows and columns of the PovStatsSeries file</p>
			<p>It seems we have 64 different indicators, and for each one of them, we have 21 attributes, explanations, and notes. This is already in long format – columns contain data about one attribute, and rows are complete representations of an indicator, so there is nothing to change. We just need to explore what data is available and get familiar with this table.</p>
			<p>Using this information, you can easily imagine creating a special dashboard for each indicator and placing it on a separate page. Each row seems to have enough information to produce <a id="_idIndexMarker157"/>an independent page with a title, description, details, and so on. The main <a id="_idIndexMarker158"/>content area of the page could be a visualization of that indicator, for all countries and across all years. This is just one idea.</p>
			<p>Let's take a closer look at some interesting columns: </p>
			<p class="source-code">series['Topic'].value_counts()</p>
			<p class="source-code"><strong class="bold">Poverty: Poverty rates           45</strong></p>
			<p class="source-code"><strong class="bold">Poverty: Shared prosperity       10</strong></p>
			<p class="source-code"><strong class="bold">Poverty: Income distribution      8</strong></p>
			<p class="source-code"><strong class="bold">Health: Population: Structure     1</strong></p>
			<p class="source-code"><strong class="bold">Name: Topic, dtype: int64</strong></p>
			<p>We can see that the indicators are spread across four topics, the counts of which can be seen above.</p>
			<p>There is a column for <strong class="source-inline">Unit of measure</strong>, which might be interesting to explore:</p>
			<p class="source-code">series['Unit of measure'].value_counts(dropna=False)</p>
			<p class="source-code"><strong class="bold">%             39</strong></p>
			<p class="source-code"><strong class="bold">NaN           22</strong></p>
			<p class="source-code"><strong class="bold">2011 PPP $     3</strong></p>
			<p class="source-code"><strong class="bold">Name: Unit of measure, dtype: int64</strong></p>
			<p>It seems we have indicators whose units of measure are either percentages (rates) or not available (<strong class="source-inline">NaN</strong>). This might help us later in grouping certain types of charts together.</p>
			<p>Another important column is the <strong class="bold">Limitations and exceptions</strong> column. Usually, this kind of metadata is extremely important, because it tells us about where the biases might be, or what we should keep in mind while exploring our data. You can read those limitations, and it might be interesting to count them and see whether they fall under certain groups, or whether <a id="_idIndexMarker159"/>they are duplicated. The following code groups <a id="_idIndexMarker160"/>the <strong class="source-inline">series</strong> DataFrame by the <strong class="bold">Topic</strong> column, and then summarizes the <strong class="bold">Limitations and Exceptions</strong> column values by their count and number of unique values:</p>
			<p class="source-code">(series</p>
			<p class="source-code"> .groupby('Topic')</p>
			<p class="source-code"> ['Limitations and exceptions']</p>
			<p class="source-code"> .agg(['count', pd.Series.nunique])</p>
			<p class="source-code"> .style.set_caption('Limitations and Exceptions'))</p>
			<p>The output can be seen in <em class="italic">Figure 4.5</em>:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B16780_04_5.jpg" alt="Figure 4.5 – Counts and unique values of Limitations and Exceptions"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Counts and unique values of Limitations and Exceptions</p>
			<p>It looks like this is going to be a good reference point for us to learn more about the different indicators that we have. It would also be very helpful for the users so they can also get a better understanding of what they are analyzing.</p>
			<h3>The country file</h3>
			<p>Let's now take a look at the next file, <strong class="source-inline">'PovStatsCountry.csv'</strong>:</p>
			<p class="source-code">country =\</p>
			<p class="source-code">pd.read_csv('data/PovStatsCountry.csv',na_values='',</p>
			<p class="source-code">                      keep_default_na=False)</p>
			<p class="source-code">print(country.shape)</p>
			<p class="source-code">country.head()</p>
			<p>This will <a id="_idIndexMarker161"/>display the shape of the DataFrame as well as a sample <a id="_idIndexMarker162"/>of rows and columns, as in <em class="italic">Figure 4.6</em>: </p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B16780_04_6.jpg" alt="Figure 4.6 – Sample rows and columns from the country file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Sample rows and columns from the country file</p>
			<p>In the call to <strong class="source-inline">read_csv</strong>, we have specified <strong class="source-inline">keep_default_na=False</strong> and <strong class="source-inline">na_values=''</strong>. The reason is that <strong class="source-inline">pandas</strong> interprets strings such as <strong class="source-inline">NA</strong> and <strong class="source-inline">NaN</strong> as indicators of missing values. One of the countries, Namibia, has a <strong class="bold">2-alpha code</strong> value of <strong class="source-inline">NA</strong>, so it was missing from the DataFrame. That's why we had to make this change. That's a very good example of how things might go wrong in unexpected ways.</p>
			<p>This is very interesting metadata about the countries and regions in our dataset. It is a very small dataset but can be very useful in enriching our understanding, as well as giving us more options to filter and group our countries. It is also in long (tidy) format. Let's take a look at some of its interesting columns.</p>
			<p>The <strong class="bold">Region</strong> column seems straightforward. We can check to see what regions are available, as well as the counts of countries in each region:</p>
			<p class="source-code">country['Region'].value_counts(dropna=False).to_frame().style.background_gradient('cividis')</p>
			<p>The result can be seen in <em class="italic">Figure 4.7</em>:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B16780_04_7.jpg" alt="Figure 4.7 – Counts of countries per region"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Counts of countries per region</p>
			<p>Another <a id="_idIndexMarker163"/>column that might be helpful is <strong class="bold">Income Group</strong>. Once we <a id="_idIndexMarker164"/>have this properly mapped to the right values, we might consider splitting our sub-plots by income group, as we previously did with continents in the first example of this chapter:</p>
			<p class="source-code">country['Income Group'].value_counts(dropna=False)</p>
			<p class="source-code"><strong class="bold">Upper middle income    52</strong></p>
			<p class="source-code"><strong class="bold">Lower middle income    47</strong></p>
			<p class="source-code"><strong class="bold">High income            41</strong></p>
			<p class="source-code"><strong class="bold">Low income             29</strong></p>
			<p class="source-code"><strong class="bold">NaN                    15</strong></p>
			<p class="source-code"><strong class="bold">Name: Income Group, dtype: int64</strong></p>
			<p>Having fifteen <strong class="source-inline">NaN</strong> values is consistent with the number of regions and classifications combined, which we will see shortly. The income level of countries is independent of their geographic locations.</p>
			<p>If you look at the <strong class="bold">Short Name</strong> column, you will notice that not all entries are countries. There are geographic regions such as <strong class="bold">Middle East &amp; North Africa</strong>, as well as classifications, for example, <strong class="screen-inline">Lower middle income</strong>. I think it's important to distinguish between them, and we can easily create a special column for that, so we can differentiate between countries and non-countries.</p>
			<p>The <strong class="bold">Region</strong> column shows <a id="_idIndexMarker165"/>which region the entity in <strong class="bold">Short Name</strong> falls under. In the <a id="_idIndexMarker166"/>cases where it is a region, the value is missing. We can use this to make our distinction, and create an <strong class="source-inline">is_country</strong> Boolean column:</p>
			<p class="source-code">country['is_country'] = country['Region'].notna()</p>
			<p><em class="italic">Figure 4.8</em> shows a sample of rows containing countries and regions, as well as classifications:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B16780_04_8.jpg" alt="Figure 4.8 – A sample of countries and regions with the is_country column"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – A sample of countries and regions with the is_country column</p>
			<p>The full listing of those categories can be found by getting a subset of the <strong class="source-inline">country</strong> DataFrame where the <strong class="bold">Region</strong> column contains missing values and then getting the <strong class="bold">Short Name</strong> column:</p>
			<p class="source-code">country[country['Region'].isna()]['Short Name']</p>
			<p class="source-code"><strong class="bold">37     IDA countries classified as fragile situations</strong></p>
			<p class="source-code"><strong class="bold">42                                East Asia &amp; Pacific</strong></p>
			<p class="source-code"><strong class="bold">43                              Europe &amp; Central Asia</strong></p>
			<p class="source-code"><strong class="bold">50           Fragile and conflict affected situations</strong></p>
			<p class="source-code"><strong class="bold">70                                          IDA total</strong></p>
			<p class="source-code"><strong class="bold">92                          Latin America &amp; Caribbean</strong></p>
			<p class="source-code"><strong class="bold">93                                         Low income</strong></p>
			<p class="source-code"><strong class="bold">95                                Lower middle income</strong></p>
			<p class="source-code"><strong class="bold">96                                Low &amp; middle income</strong></p>
			<p class="source-code"><strong class="bold">105                        Middle East &amp; North Africa</strong></p>
			<p class="source-code"><strong class="bold">107                                     Middle income</strong></p>
			<p class="source-code"><strong class="bold">139                                        South Asia</strong></p>
			<p class="source-code"><strong class="bold">147                                Sub-Saharan Africa</strong></p>
			<p class="source-code"><strong class="bold">170                               Upper middle income</strong></p>
			<p class="source-code"><strong class="bold">177                                             World</strong></p>
			<p class="source-code"><strong class="bold">Name: Short Name, dtype: object</strong></p>
			<p>Going through <a id="_idIndexMarker167"/>this process is very important in helping you plan your dashboards <a id="_idIndexMarker168"/>and apps. For example, knowing that we have four classifications for income levels means that it makes sense to create sub-plots for them side by side. But if we had 20 classifications, it might not be a good idea to do so.</p>
			<p>Let's create one more column and then move on to the next file.</p>
			<p>Since we are dealing with countries, we can use flags as visual and easy-to-spot identifiers. Since flags are emojis, and they are basically Unicode characters, they can be rendered as text on our charts, just like other regular text. We can later consider using other emojis as symbols that make it easy for the reader to spot growth and decline, for example (using the relevant arrow symbols and colors). This can also be useful when you don't have much space and you still need to communicate something to the users, especially on smaller screens. An emoji is worth a thousand words!</p>
			<p>The interesting thing about country flag emojis is that they are a concatenation of two special letters whose name is <strong class="source-inline">"REGIONAL INDICATOR SYMBOL LETTER &lt;letter&gt;"</strong>. For example, these are the regional indicator symbols for the letters A and B:AB.</p>
			<p>You simply <a id="_idIndexMarker169"/>have to get the two-letter code of a certain country, and look <a id="_idIndexMarker170"/>up the name from the <strong class="source-inline">unicodedata</strong> Python Standard Library module. The <strong class="source-inline">lookup</strong> function takes the name of a character and returns the character itself:</p>
			<p class="source-code">from unicodedata import lookup</p>
			<p class="source-code">lookup('LATIN CAPITAL LETTER E')</p>
			<p class="source-code"><strong class="bold">'E'</strong></p>
			<p class="source-code">lookup("REGIONAL INDICATOR SYMBOL LETTER A")</p>
			<p class="source-code"><strong class="bold">'A'</strong></p>
			<p>Once we have two letters representing a country, we can look them up, and concatenate them to produce the respective country's flag. We can create a simple function that does that. We just need to handle the situation where the provided letters are either <strong class="source-inline">NaN</strong> or not part of the country code list.</p>
			<p>We can create a <strong class="source-inline">country_codes</strong> variable and check against it. If the provided letters are not in the list, we return the empty character, otherwise we create an emoji flag: </p>
			<p class="source-code">country_codes = country[country['is_country']]['2-alpha code'].dropna().str.lower().tolist()</p>
			<p>We can now easily define the <strong class="source-inline">flag</strong> function:</p>
			<p class="source-code">def flag(letters):</p>
			<p class="source-code">    if pd.isna(letters) or (letters.lower() not in country_codes):</p>
			<p class="source-code">        return ''</p>
			<p class="source-code">    L0 = lookup(f'REGIONAL INDICATOR SYMBOL LETTER {letters[0]}')</p>
			<p class="source-code">    L1 = lookup(f'REGIONAL INDICATOR SYMBOL LETTER {letters[1]}')</p>
			<p class="source-code">    return L0 + L1</p>
			<p>Using this function, we can create our <strong class="source-inline">flag</strong> column:</p>
			<p class="source-code">country['flag'] =\</p>
			<p class="source-code">[flag(code) for code in country['2-alpha code']]</p>
			<p><em class="italic">Figure 4.9</em> shows a <a id="_idIndexMarker171"/>random sample of countries, their flags, and <a id="_idIndexMarker172"/>the <strong class="bold">is_country</strong> column:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B16780_04_9.jpg" alt="Figure 4.9 – Sample of rows showing countries and their flags"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Sample of rows showing countries and their flags</p>
			<p>In the case where <strong class="bold">Short Name</strong> is not a country, we get an empty string. We used the empty string and didn't use <strong class="source-inline">NaN</strong> because in many cases we might want to concatenate the country name with its flag, for titles or labels for instance, and an empty string would not cause any issues. Note that if you save the DataFrame to a file and reopen it, <strong class="source-inline">pandas</strong> will interpret empty strings as <strong class="source-inline">NaN</strong>, and you will have to either convert them or prevent them from being interpreted as such.</p>
			<h3>The country-series file</h3>
			<p>Our next file "<strong class="source-inline">PovStatsCountry-Series.csv</strong>" simply contains a list of the country codes and shows <a id="_idIndexMarker173"/>the sources of their population data. We'll see if/when <a id="_idIndexMarker174"/>we might use this as metadata in a relevant chart.</p>
			<h3>The footnotes file</h3>
			<p>Next, we'll take a quick look at the footnotes file <strong class="source-inline">PovStatsFootNote.csv</strong>:</p>
			<p>There is <a id="_idIndexMarker175"/>an empty column <strong class="bold">Unnamed: 4</strong>, which we need to drop, and then <a id="_idIndexMarker176"/>convert the years to integers. They are represented as <strong class="source-inline">YR2015</strong> and that's why we extract the characters starting from index 2. We renamed the columns to make them consistent with the <strong class="source-inline">series</strong> DataFrame, to make it easy to merge them when needed:</p>
			<p class="source-code">footnote = pd.read_csv('data/PovStatsFootNote.csv')</p>
			<p class="source-code">footnote = footnote.drop('Unnamed: 4', axis=1)</p>
			<p class="source-code">footnote['Year'] = footnote['Year'].str[2:].astype(int)</p>
			<p class="source-code">footnote.columns = ['Country Code', Series Code', 'year', 'footnote']</p>
			<p class="source-code">footnote</p>
			<p><em class="italic">Figure 4.10</em> shows a few rows from the <strong class="source-inline">footnote</strong> DataFrame:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B16780_04_10.jpg" alt="Figure 4.10 – Sample of rows from the footnote file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – Sample of rows from the footnote file</p>
			<p>That looks like <a id="_idIndexMarker177"/>a large number of notes about the data. We should <a id="_idIndexMarker178"/>make sure to include them somehow, to make sure the readers get the full picture. Those footnotes seem to be based on combinations of country, indicator, and year. Since the three are encoded in a consistent way with other tables, it should be straightforward to incorporate and map them to the relevant values elsewhere.</p>
			<h3>The data file</h3>
			<p>Next is the <a id="_idIndexMarker179"/>main data file, which we have already worked with in previous chapters, but we want to now reshape and merge with other DataFrames, for a more intuitive and powerful view into our dataset.</p>
			<p>Let's now explore this file:</p>
			<p class="source-code">data = pd.read_csv('data/PovStatsData.csv')</p>
			<p class="source-code">data = data.drop('Unnamed: 50', axis=1)</p>
			<p class="source-code">print(data.shape)</p>
			<p class="source-code">data.sample(3)</p>
			<p>The preceding code removes the column named <strong class="bold">Unnamed: 50</strong>, prints the shape of the <strong class="source-inline">data</strong> DataFrame, and displays a random sample of rows, as you can see in <em class="italic">Figure 4.11</em>:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B16780_04_11.jpg" alt="Figure 4.11 – Sample of rows and columns from the data file"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – Sample of rows and columns from the data file</p>
			<p>It's always interesting to know how many missing values we have, and what percentage they form <a id="_idIndexMarker180"/>of all values. The interesting parts are the columns starting from <strong class="bold">1974</strong> till the end of the DataFrame. The <strong class="source-inline">isna</strong> method returns a <strong class="source-inline">Series</strong> of Booleans for each column. Taking the mean of that gets the percentage of missing values per column, as a <strong class="source-inline">Series</strong>. Running <strong class="source-inline">mean</strong> again gives the overall percentage of missing values:</p>
			<p class="source-code">data.loc[:, '1974':].isna().mean().mean()</p>
			<p class="source-code"><strong class="bold">0.9184470475910692</strong></p>
			<p>91.8% of our cells are empty. This has important implications for the results because most of the time we won't have enough data, or we won't have it for certain countries. Many countries didn't exist in their current form before the early nineties, for example, so this is one of the reasons. You can check out the <strong class="source-inline">series</strong> DataFrame and all the information about the indicators and the data collection issues where applicable.</p>
			<p>Let's now explore how we can reshape DataFrames to and from long format, and more importantly, why we would want to do so.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Melting DataFrames</h2>
			<p>One of the first things you probably noticed is that years are spread across columns, with the values <a id="_idIndexMarker181"/>corresponding to them, each in its respective cell under the respective year. The issue is that <strong class="source-inline">1980</strong> is not really a variable. A more useful way is to have a <strong class="source-inline">year</strong> variable, and in that column, the values would vary from 1974 to 2019. If you remember the way we created the first chart in this chapter, you can see how this makes our life much easier. Let me illustrate what I mean, using a small dataset so things are clear, and then we can implement the same approach with the <strong class="source-inline">data</strong> DataFrame.</p>
			<p><em class="italic">Figure 4.12</em> shows how we can have the same data structured differently while containing the same information:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B16780_04_12.jpg" alt="Figure 4.12 – Two datasets containing the same information in two different formats"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B16780_04_13.jpg" alt="Figure 4.12 – Two datasets containing the same information in two different formats"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Two datasets containing the same information in two different formats</p>
			<p>Our current DataFrame is structured like the table on the right, and it would be easier to have it in a format like the one on the left.</p>
			<p>The difficulty with the wide format is that the variables are presented in different ways. In some cases, they are displayed vertically in a column (<strong class="bold">country</strong> and <strong class="bold">indicator</strong>), while in others, they are displayed horizontally across the columns <strong class="bold">2015</strong> and <strong class="bold">2020</strong>. Accessing the same data in the long format DataFrame is straightforward: we simply specify the columns that we want. In addition to that, we get automatic mapping of values. For example, taking the columns <strong class="bold">year</strong> and <strong class="bold">value</strong> from the long DataFrame would automatically map 2015 to 100, 2015 to 10, and so on. At the same time, each row is a complete and independent representation of the case we are dealing with.</p>
			<p>The good news is <a id="_idIndexMarker182"/>that this is doable with one call to the <strong class="source-inline">melt</strong> method:</p>
			<p class="source-code">wide_df.melt(<strong class="bold">id_vars</strong>=['country', 'indicator'],</p>
			<p class="source-code">             <strong class="bold">value_vars</strong>=['2015', '2020'],</p>
			<p class="source-code">             <strong class="bold">var_name</strong>='year')</p>
			<p>Here is an <a id="_idIndexMarker183"/>overview of what the preceding code and parameters do:</p>
			<ul>
				<li><strong class="source-inline">id_vars</strong>: Keep these as rows and duplicate them as needed to keep the mapping in place.</li>
				<li><strong class="source-inline">value_vars</strong>: Take these columns and make them values, melt them into a new column, and make sure the mapping with other values remains consistent with the previous structure. If we don't specify <strong class="source-inline">value_vars</strong>, then this operation will be used for all unspecified columns (all columns except <strong class="source-inline">id_vars</strong>).</li>
				<li><strong class="source-inline">var_name</strong>: Optional. What you want this newly created column to be named – "<strong class="source-inline">year</strong>" in this case. </li>
			</ul>
			<p>Let's do <a id="_idIndexMarker184"/>this operation on our <strong class="source-inline">data</strong> DataFrame:</p>
			<p class="source-code">id_vars =['Country Name', 'Country Code', 'Indicator Name', 'Indicator Code']</p>
			<p class="source-code">data_melt = data.melt(<strong class="bold">id_vars</strong>=id_vars,</p>
			<p class="source-code">                      <strong class="bold">var_name</strong>='year').dropna(subset=['value'])</p>
			<p class="source-code">data_melt['year'] = data_melt['year'].astype(int)</p>
			<p class="source-code">print(data_melt.shape)</p>
			<p class="source-code">data_melt.sample(10)</p>
			<p>The code is almost identical to the previous example. We first created a list of <strong class="source-inline">id_vars</strong> and used it for the argument of the same name. Right after that, we removed the missing values under the <strong class="source-inline">value</strong> column. We could have changed the name of this column by using the <strong class="source-inline">value_name</strong> parameter, but "<strong class="source-inline">value</strong>" seems appropriate. We then converted the years to integers. Running this code displays the shape and a sample of the new <strong class="source-inline">data_melt</strong> DataFrame, shown in <em class="italic">Figure 4.13</em>:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B16780_04_14.jpg" alt="Figure 4.13 – The data DataFrame after being &quot;melted&quot;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – The data DataFrame after being "melted"</p>
			<p>The first four <a id="_idIndexMarker185"/>columns are the same as they were, with each unique combination intact. We now have all the year columns and their values, condensed into two columns, <strong class="bold">year</strong> and <strong class="bold">value</strong>.</p>
			<p>Now let's see how we can improve the structure further by doing the reverse operation on other columns.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Pivoting DataFrames</h2>
			<p>The <strong class="bold">Indicator Name</strong> column might be improved by doing the reverse of the operation that we just <a id="_idIndexMarker186"/>did to the years columns. Ideally, we should have a column for population, another one for poverty rates, and so on. Let's first do this using our long (melted) example DataFrame so it's clear.</p>
			<p>Assume we wanted to convert the unique values in the <strong class="bold">country</strong> column and make them column names. We use the <strong class="source-inline">pivot</strong> method for that. This can give us a "round trip" back where we came from, using the <strong class="source-inline">melt</strong> method. Here, I'm using it on different columns: </p>
			<p class="source-code">melted.pivot(index=['year', 'indicator'],</p>
			<p class="source-code">             columns='country',</p>
			<p class="source-code">             values='value').reset_index()</p>
			<p>Running this code would convert the melted DataFrame to a wide format (pivoted) DataFrame as you can see in <em class="italic">Figure 4.14</em>:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B16780_04_15.jpg" alt="Figure 4.14 – The conversion from long to wide format"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B16780_04_16.jpg" alt="Figure 4.14 – The conversion from long to wide format"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – The conversion from long to wide format</p>
			<p>The <strong class="bold">Indicator Name</strong> column in <strong class="source-inline">data_melt</strong> contains names that can be better used as column <a id="_idIndexMarker187"/>names, so each indicator can be represented independently in its own column, to be consistent with our data representation:</p>
			<p class="source-code">data_pivot =\</p>
			<p class="source-code">data_melt.pivot(index=['Country Name', 'Country Code', 'year'],</p>
			<p class="source-code">                             columns='Indicator Name',</p>
			<p class="source-code">                             values='value').reset_index()</p>
			<p class="source-code">print(data_pivot.shape)</p>
			<p class="source-code">data_pivot.sample(5)</p>
			<p>This will produce our <strong class="source-inline">data_pivot</strong> DataFrame, a sample of which you can see in <em class="italic">Figure 4.15</em>:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B16780_04_17.jpg" alt="Figure 4.15 – The long form (tidy) poverty DataFrame"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – The long form (tidy) poverty DataFrame</p>
			<p>If our work <a id="_idIndexMarker188"/>is correct, we should now have a unique combination of country and year in each row. That was the whole point of the exercise actually. Let's test that our work is correct:</p>
			<p class="source-code">data_pivot[['Country Code', 'year']].duplicated().any()</p>
			<p class="source-code"><strong class="bold">False</strong></p>
			<p>Rows now contain country names, codes, and years, as well as all the values for the different indicators. The country information can be enriched by including the metadata that we have in the <strong class="source-inline">country</strong> DataFrame. Let's take a look at the <strong class="source-inline">merge</strong> function, and after that, we'll start using Plotly Express.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>Merging DataFrames</h2>
			<p>First, let's look <a id="_idIndexMarker189"/>at a simple example of how merging works, and then we can merge the <strong class="source-inline">data_pivot</strong> and <strong class="source-inline">country</strong> DataFrames. <em class="italic">Figure 4.16</em> shows how two DataFrames can be merged:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B16780_04_18.jpg" alt="Figure 4.16 How DataFrames are merged"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 How DataFrames are merged</p>
			<p>The merge <a id="_idIndexMarker190"/>operation can be done with the <strong class="source-inline">merge</strong> function:</p>
			<p class="source-code">pd.merge(left=left, right=right, </p>
			<p class="source-code">         <strong class="bold">left_on</strong>='country', </p>
			<p class="source-code">         <strong class="bold">right_on</strong>='country', </p>
			<p class="source-code">         <strong class="bold">how</strong>='left')</p>
			<p>Here are the details of the preceding call to <strong class="source-inline">pd.merge</strong>:</p>
			<ul>
				<li><strong class="source-inline">left_on</strong>: The name of the column(s) from the <strong class="source-inline">left</strong> DataFrame to merge on.</li>
				<li><strong class="source-inline">right_on</strong>: The name of the column(s) from the <strong class="source-inline">right</strong> DataFrame to merge on.</li>
				<li><strong class="source-inline">how</strong>: The <strong class="source-inline">merge</strong> method. In this case, <strong class="source-inline">"left"</strong> means to take all the rows in <strong class="source-inline">left</strong> and only match them with rows in <strong class="source-inline">right</strong> that have the same values in the <strong class="bold">country</strong> columns. Matching rows will be duplicated if needed in the resulting DataFrame, as in this case. Rows in <strong class="source-inline">right</strong> that don't have matches in the <strong class="source-inline">country</strong> column will be discarded. The merged DataFrame should end up with the same number of rows as the left DataFrame.</li>
			</ul>
			<p>There are several other options for this function, and it's quite powerful. Make sure to check out the other merge methods: inner, outer, and right. For our case, we will be using the options shown in the previous example, so let's do it now. We will merge <strong class="source-inline">data_pivot</strong> with <strong class="source-inline">country</strong> the same way:</p>
			<p class="source-code">poverty = pd.merge(data_pivot, country, </p>
			<p class="source-code">                   left_on='Country Code',</p>
			<p class="source-code">                   right_on='Country Code',</p>
			<p class="source-code">                   how='left')</p>
			<p class="source-code">print(poverty.shape)</p>
			<p class="source-code">poverty</p>
			<p>This merge <a id="_idIndexMarker191"/>operation produces the <strong class="source-inline">poverty</strong> DataFrame, which you can see in <em class="italic">Figure 4.17</em>:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B16780_04_19.jpg" alt="Figure 4.17 – Merging data_pivot and country"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – Merging data_pivot and country</p>
			<p>A quick check to make sure our work is correct: </p>
			<p class="source-code">poverty[['Country Code', 'year']].duplicated().any()</p>
			<p class="source-code"><strong class="bold">False</strong></p>
			<p>The eight additional columns in the rectangle on the right are some of the additional columns that were added to our <strong class="source-inline">poverty</strong> DataFrame. Now it's very easy to take a certain region or income group, filter by its countries, color by its values, or group it however we want. This is now looking like the Gapminder dataset, only with many more indicators and years, and more metadata about countries.</p>
			<p>We now have a DataFrame that has a consistent structure.</p>
			<p>Every column contains data about one and only one variable. All values in columns are of the same data type (or missing). Each row can independently represent a complete observation, because it contains the full information available, like all other rows.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The main drawback of the long format is that it is inefficient for storage. From that perspective, we are unnecessarily repeating a lot of values, which takes a lot of space. We will tackle this later, but keep in mind that this format is extremely efficient in terms of your time as a developer. As we saw in several examples, once the mapping is consistent, creating and changing your visualizations becomes much easier.</p>
			<p>I highly recommend reading Hadley Wickham's <em class="italic">Tidy Data</em> paper, for a deeper discussion <a id="_idIndexMarker192"/>on several ways in which data might be formatted and different solutions for that. The examples shown here are inspired by those principles: <a href="https://www.jstatsoft.org/article/view/v059i10">https://www.jstatsoft.org/article/view/v059i10</a>.</p>
			<p>We are now ready to explore how to use Plotly Express, first with a toy dataset, and then with the dataset that we prepared.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Learning Plotly Express</h1>
			<p>Plotly Express is a higher-level plotting system, built on top of Plotly. Not only does it handle certain <a id="_idIndexMarker193"/>defaults for us, such as labeling axes and legends, it enables us to utilize our data to express many of its attributes using visual aesthetics (size, color, location, and so on). This can be done simply by declaring what attribute we want to express with which column of our data, given a few assumptions about the data structure. So, it mainly provides us with the flexibility to approach the problem from the data point of view, as mentioned at the beginning of the chapter. </p>
			<p>Let's first create a simple DataFrame: </p>
			<p class="source-code">df = pd.DataFrame({</p>
			<p class="source-code">    'numbers': [1, 2, 3, 4, 5, 6, 7, 8],</p>
			<p class="source-code">    'colors': ['blue', 'green', 'orange', 'yellow', 'black', 'gray', 'pink', 'white'],</p>
			<p class="source-code">    'floats': [1.1, 1.2, 1.3, 2.4, 2.1, 5.6, 6.2, 5.3],</p>
			<p class="source-code">    'shapes': ['rectangle', 'circle', 'triangle', 'rectangle', 'circle', 'triangle', 'rectangle', 'circle'],</p>
			<p class="source-code">    'letters': list('AAABBCCC')</p>
			<p class="source-code">})</p>
			<p class="source-code">df</p>
			<p>This will produce the DataFrame in <em class="italic">Figure 4.18</em>:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B16780_04_20.jpg" alt="Figure 4.18 – A simple example DataFrame"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – A simple example DataFrame</p>
			<p>We typically <a id="_idIndexMarker194"/>create charts with Plotly Express by calling the type of the chart as a function, <strong class="source-inline">px.line</strong>, <strong class="source-inline">px.histogram</strong>, and so on. Each function has its own set of parameters, based on its type.</p>
			<p>There are <a id="_idIndexMarker195"/>several ways of passing arguments to those functions, and we will focus on two main approaches:</p>
			<ul>
				<li>A DataFrame with column names: In most cases, the first parameter is <strong class="source-inline">data_frame</strong>. You set the DataFrame that you want to visualize, and then you specify the columns you want to use for the parameters that you want. For our example DataFrame, if we want to create a scatter plot with <strong class="bold">numbers</strong> on the X axis and <strong class="bold">floats</strong> on the Y axis, we call it like this: <strong class="source-inline">px.scatter(data_frame=df, x='numbers', y='floats')</strong>.</li>
				<li>Arrays as arguments: Another way of specifying parameters is by simply passing lists, tuples, or any array-like data structure, without a <strong class="source-inline">data_frame</strong> argument. We can create the same scatter plot by running: <strong class="source-inline">px.scatter(x=df['numbers'], y=df['floats'])</strong>. This is a straightforward and very fast approach, whenever you have lists that you want to explore.</li>
			</ul>
			<p>We can also mix the approaches. We can set a <strong class="source-inline">data_frame</strong> argument with a few column names as arguments, and we can pass separate lists for other arguments when needed. A few <a id="_idIndexMarker196"/>examples should illustrate these points easily. The following code shows how easy it is to create a scatter plot:</p>
			<p class="source-code">px.scatter(df, x='numbers', y='floats')</p>
			<p><em class="italic">Figure 4.19</em> shows the resulting figure in JupyterLab:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B16780_04_21.jpg" alt="Figure 4.19 – Creating a scatter plot with Plotly Express"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – Creating a scatter plot with Plotly Express</p>
			<p>I'm sure you noticed that we got the X- and Y-axis titles set for us by default. It takes the names of the arguments we gave (the DataFrame columns in this example) and uses them for that.</p>
			<p>We have several other variables in the DataFrame, and we might be interested in checking whether there are any relations between them. For example, let's check whether there is a relationship between <strong class="bold">floats</strong> and <strong class="bold">shapes</strong>.</p>
			<p>We can rerun the same code and add two parameters that allow us to distinguish which markers belong to which shape. We can use the <strong class="source-inline">color</strong> parameter for that, and it will assign a different <a id="_idIndexMarker197"/>color to each marker based on the <strong class="bold">shapes</strong> that it corresponds to (in the same row). If you are reading this book from the printed grayscale edition, the same argument to the <strong class="source-inline">symbol</strong> parameter was added, to make it easy to distinguish them. This also makes it easier for readers on a colored screen as well, by giving two signals to distinguish the markers:</p>
			<p class="source-code">Px.scatter(df,</p>
			<p class="source-code">           x='numbers',</p>
			<p class="source-code">           y='floats',</p>
			<p class="source-code">           color='shapes',</p>
			<p class="source-code">           symbol='shapes')</p>
			<p><em class="italic">Figure 4.20</em> shows the code and resulting figure in JupyterLab:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B16780_04_22.jpg" alt="Figure 4.20 – Assigning colors and symbols to markers"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.20 – Assigning colors and symbols to markers</p>
			<p>Note that <a id="_idIndexMarker198"/>we have a legend helping us to distinguish the markers by telling us which color and symbol belong to which shape. It also has its own title, all generated by default. </p>
			<p>There seems to be no relationship between floats and shapes. So, let's try coloring and setting symbols based on the <strong class="bold">letters</strong> column, which can be done with the following code:</p>
			<p class="source-code">px.scatter(df,</p>
			<p class="source-code">           x='numbers',</p>
			<p class="source-code">           y='floats',</p>
			<p class="source-code">           <strong class="bold">color='letters'</strong>,</p>
			<p class="source-code">           symbol='letters',</p>
			<p class="source-code">           size=[35] * 8)</p>
			<p><em class="italic">Figure 4.21</em> demonstrates this: </p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B16780_04_23.jpg" alt="Figure 4.21 – Setting marker sizes using an independent list"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.21 – Setting marker sizes using an independent list</p>
			<p>We can see a clear difference based on the letters now. This shows how easy it is to explore your datasets by quickly trying out different options. Note that we also mixed the approaches <a id="_idIndexMarker199"/>this time by setting a <strong class="source-inline">size</strong> for the markers. Size wasn't mapped to a value; it was set to make the symbols bigger and easier to see. So, we simply passed a list with the marker size that we wanted. The list had to have the same length as the other variables that we are visualizing.</p>
			<p>Let's explore bar charts with the same approach and using the same dataset. We can adjust how the bars are displayed using the <strong class="source-inline">barmode</strong> parameter like this:</p>
			<p class="source-code">px.bar(df, x='letters', y='floats', color='shapes', <strong class="bold">barmode='group'</strong>)</p>
			<p><em class="italic">Figure 4.22</em> shows two different ways of displaying the bars – the default, on top of each other, and "<strong class="source-inline">group</strong>," as you can see:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B16780_04_24.jpg" alt="Figure 4.22 – Creating bar charts using different display modes (barmode)"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B16780_04_25.jpg" alt="Figure 4.22 – Creating bar charts using different display modes (barmode)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22 – Creating bar charts using different display modes (barmode)</p>
			<p>The discussion <a id="_idIndexMarker200"/>about long (tidy) format data should make it very easy to understand how to use Plotly. You just need a basic understanding of the chart type, and how it works, and then you can easily set the arguments that you want.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Plotly Express does not require data to be in long format. It is very flexible and can handle wide, long, as well as mixed format data. Also, <strong class="source-inline">pandas</strong> and <strong class="source-inline">numpy</strong> are extremely flexible in data manipulation. I just believe it is better to use a consistent approach for your own productivity.</p>
			<p>Now let's <a id="_idIndexMarker201"/>see how Plotly Express relates to the <strong class="source-inline">Figure</strong> object and when to use which approach.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Plotly Express and Figure objects</h2>
			<p>It's helpful to know that all calls to the Plotly Express chart functions return a <strong class="source-inline">Figure</strong> object, the same <a id="_idIndexMarker202"/>one we discussed in <a href="B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Plotly's Figure Objects</em>. This is very important for customizing our charts after creating them, in case <a id="_idIndexMarker203"/>you want to change the defaults. Let's say you created a scatter plot, and after that, you wanted to add an annotation to it to explain something. You could do it just like we did in the previous chapter:</p>
			<p class="source-code">import plotly express as px</p>
			<p class="source-code">fig = <strong class="bold">px.scatter</strong>(x=[1, 2, 3], y=[23, 12, 34])</p>
			<p class="source-code">fig.add_annotation(x=1, y=23, text='This is the first value')</p>
			<p>Everything you know about the <strong class="source-inline">Figure</strong> object and how it is structured can be used with Plotly Express, so this builds on that knowledge.</p>
			<p>This naturally raises the question of when to use Plotly Express and when to use Plotly's <strong class="source-inline">graph_objects</strong> module for creating charts from a lower level.</p>
			<p>This question can be tackled by asking the more general question: Given two interfaces that do the same thing at different levels of abstraction, how do we choose between them?</p>
			<p>Consider three different approaches to having a pizza:</p>
			<ul>
				<li><strong class="bold">The ordering approach</strong>: You call a restaurant and order your pizza. It arrives at your doorstep in half an hour, and you start eating.</li>
				<li><strong class="bold">The supermarket approach</strong>: You go to a supermarket, buy dough, cheese, vegetables, and all other ingredients. You then make the pizza yourself.</li>
				<li><strong class="bold">The farm approach</strong>: You grow tomatoes in your backyard. You raise cows, milk them, and convert the milk to cheese, and so on.</li>
			</ul>
			<p>As we go up to higher-level interfaces, towards the ordering approach, the amount of knowledge required decreases a lot. Someone else holds responsibility, and quality is checked by the market forces of reputation and competition.</p>
			<p>The price we pay for this is the diminished freedom and options. Each restaurant has a set of options to choose from, and you have to choose from those options.</p>
			<p>Going down to lower levels, the amount of knowledge required increases, we have to handle more <a id="_idIndexMarker204"/>complexity, we hold more responsibility for the outcomes, and it takes much more time. What we gain here is much more freedom and power to customize <a id="_idIndexMarker205"/>our outcomes the way we want. Cost is a major benefit as well, but only on a large enough scale. If you only want to have a pizza today, it's probably cheaper to order it. But if you plan on having one every day, then you can expect major cost-savings if you do it yourself.</p>
			<p>This is the trade-off you have in choosing between the higher-level Plotly Express, and the lower-level Plotly <strong class="source-inline">graph_objects</strong>.</p>
			<p>Since Plotly Express returns <strong class="source-inline">Figure</strong> objects, then it's generally not a difficult decision, because you can retroactively modify them. In general, it's good to use the <strong class="source-inline">graph_objects</strong> module in the following cases:</p>
			<ul>
				<li><strong class="bold">Non-standard visualizations</strong>: Many diagrams created in this book were done <a id="_idIndexMarker206"/>with Plotly. To create such diagrams with Plotly Express would be quite difficult because they are not standard graphs.</li>
				<li><strong class="bold">When you have a lot of customizations</strong>: If you want to make a lot of changes <a id="_idIndexMarker207"/>to most aspects of your charts, you might end up writing the same amount of code and putting in the same amount of effort, so you might consider doing it directly using the <strong class="source-inline">graph_objects</strong> module.</li>
				<li><strong class="bold">Sub-plots</strong>: Sometimes <a id="_idIndexMarker208"/>you want to have multiple charts side by side, or in a grid. If these are different charts and not facets as we saw at the beginning of the chapter, then it's better to do them with <strong class="source-inline">graph_objects</strong>.</li>
			</ul>
			<p>In general, Plotly Express is usually a better starting point for creating your charts, as we saw how powerful and convenient it is.</p>
			<p>You are <a id="_idIndexMarker209"/>now ready to use the <strong class="source-inline">poverty</strong> dataset to specify <a id="_idIndexMarker210"/>the visualization that you want with Plotly Express, starting from the data.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Creating a Plotly Express chart using the dataset</h2>
			<p>Let's <a id="_idIndexMarker211"/>see how we might summarize the <strong class="source-inline">poverty</strong> <strong class="source-inline">data_frame</strong> with a scatter plot:</p>
			<ol>
				<li value="1">Create <a id="_idIndexMarker212"/>variables for <strong class="source-inline">year</strong>, <strong class="source-inline">indicator</strong>, and a grouping (<strong class="source-inline">grouper</strong>) metric to use in the visualization. The grouping metric will be used to distinguish between the markers (using color and symbol), and could take any categorical value from the dataset, such as region, income group, and so on:<p class="source-code">year = 2010</p><p class="source-code">indicator = 'Population, total'</p><p class="source-code">grouper = 'Region'</p></li>
				<li>Based on these variables, create a DataFrame, where the <strong class="source-inline">year</strong> column is equal to <strong class="source-inline">year</strong>, sort the values by <strong class="source-inline">indicator</strong>, and remove any missing values from the columns of <strong class="source-inline">indicator</strong> and <strong class="source-inline">grouper</strong>:<p class="source-code">df = (poverty[poverty['year'].eq(year)]</p><p class="source-code">      .sort_values(indicator)</p><p class="source-code">      .dropna(subset=[indicator, grouper]))</p></li>
				<li>Set the <strong class="source-inline">x</strong> axis values to <strong class="source-inline">indicator</strong> and set the <strong class="source-inline">y</strong> axis values to the column "<strong class="source-inline">Country Name</strong>". The <strong class="source-inline">color</strong> and <strong class="source-inline">symbol</strong> of the markers should be set using <strong class="source-inline">grouper</strong>. The X-axis values are expected to have outliers, and not to be normally distributed, so set <strong class="source-inline">log_x</strong> to <strong class="source-inline">True</strong>. The <strong class="source-inline">hover_name</strong> of each hover label should take the country name together with its flag. Set the <strong class="source-inline">title</strong> of the figure by concatenating <strong class="source-inline">indicator</strong>, "<strong class="source-inline">by</strong>", <strong class="source-inline">grouper</strong>, and <strong class="source-inline">year</strong>. Give markers a constant <strong class="source-inline">size</strong>, and set the <strong class="source-inline">height</strong> to <strong class="source-inline">700</strong> pixels:<p class="source-code">px.scatter(<strong class="bold">data_frame</strong>=df,</p><p class="source-code">           <strong class="bold">x</strong>=indicator,</p><p class="source-code">           <strong class="bold">y</strong>='Country Name',</p><p class="source-code">           <strong class="bold">color</strong>=grouper,</p><p class="source-code">           <strong class="bold">symbol</strong>=grouper,</p><p class="source-code">           <strong class="bold">log_x</strong>=True,</p><p class="source-code">           <strong class="bold">hover_name</strong>=df['Short Name'] + ' ' + df['flag'],</p><p class="source-code">           <strong class="bold">size</strong>=[1]* len(df),</p><p class="source-code">           <strong class="bold">title</strong>= ' '.join([indicator, 'by', grouper, str(year)]),</p><p class="source-code">           <strong class="bold">height</strong>=700)</p><p>This <a id="_idIndexMarker213"/>creates <a id="_idIndexMarker214"/>the chart in <em class="italic">Figure 4.23</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B16780_04_26.jpg" alt="Figure 4.23 – The Plotly Express figure using the poverty dataset"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23 – The Plotly Express figure using the poverty dataset</p>
			<p>By simply playing with the different combinations of <strong class="source-inline">year</strong>, <strong class="source-inline">grouper</strong>, and <strong class="source-inline">indicator</strong>, you can <a id="_idIndexMarker215"/>generate hundreds of charts. <em class="italic">Figure 4.24</em> shows <a id="_idIndexMarker216"/>some samples:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B16780_04_27.jpg" alt="Figure 4.24 – Other figures using the same dataset"/>
				</div>
			</div>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B16780_04_28.jpg" alt="Figure 4.24 – Other figures using the same dataset"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24 – Other figures using the same dataset</p>
			<p>With these powerful features, and with data formatted as observations by variables, we can easily visualize six or seven attributes of our data using several visual attributes: X axis, Y axis, marker size, marker symbol, marker color, facets (columns or rows), and animations. We can <a id="_idIndexMarker217"/>also add more context and information using hover labels, as well as annotations. Any combination of those attributes <a id="_idIndexMarker218"/>can be explored simply by selecting which column to map to which attribute.</p>
			<p>Let's now explore how easy it is to enrich our dataset with external resources.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>Adding new data and columns to our dataset</h2>
			<p>There are many ways to add more data, but I would like to highlight two very easy and effective ones:</p>
			<ul>
				<li><strong class="bold">Adding columns or features</strong>: We added our flag column by creating the respective <a id="_idIndexMarker219"/>emoji for each country using its two-letter code. You might be interested in segmenting or grouping countries according to other attributes. Maybe you suspect there might be something distinctive about countries using the euro, countries where Spanish or Arabic is spoken, or maybe signatories of a certain trade agreement. Wikipedia contains numerous such lists. Using the <strong class="source-inline">pandas</strong> <strong class="source-inline">read_html</strong> function, which downloads all tables on a web page, you can very easily download any such list. Assuming it has the country codes, you can merge it with the main DataFrame and start analyzing accordingly. This can also be a filtering mechanism, where you simply want a subset of all countries.</li>
				<li><strong class="bold">Adding new data</strong>: The <a id="_idIndexMarker220"/>World Bank has thousands of other similar datasets. For example, the population figures we have here are for the total population. There are many detailed and segmented population datasets that break the numbers down by gender, age, and other factors. Using the World Bank's API, you can easily obtain other data, merge it, and immediately enrich your analysis.</li>
			</ul>
			<p>Let's now review what we have done in this chapter and in <em class="italic">Part 1</em> of the book.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Summary</h1>
			<p>You now have enough information and have seen enough examples to create dashboards quickly. In <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>, we learned how apps are structured and learned how to build fully running apps, but without interactivity. In <a href="B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring the Structure of a Dash App</em>, we explored how interactivity works, through callback functions, and we added interactive features to our app. <a href="B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Plotly's Figure Objects</em>, introduced how Plotly's charts are created, their components, and how to manipulate them to achieve the results you want. Finally, in this chapter, we introduced Plotly Express, a high-level interface to Plotly that is easy to use but more importantly, follows an intuitive approach that is data-oriented, as opposed to being chart-oriented.</p>
			<p>One of the most important and biggest parts of creating visualizations is the process of preparing data in certain formats, after which it becomes relatively straightforward to create those visualizations. Investing in understanding how your dataset is structured, as well as investing time and effort in reshaping your data, pays well in the end, as we saw in the extensive example in this chapter.</p>
			<p>Armed with this knowledge and examples, as well as our familiarity with our dataset, and straightforward mechanisms to enrich it, we are now ready to explore in more detail different Dash components, as well as different types of charts.</p>
			<p><em class="italic">Part 2</em> will go deep into different chart types, how to use them, and the different ways we can combine them with the interactivity features that Dash provides.</p>
		</div>
	</body></html>