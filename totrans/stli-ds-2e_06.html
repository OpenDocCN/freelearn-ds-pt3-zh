<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer096">
    <h1 class="chapterNumber">6</h1>
    <h1 class="chapterTitle" id="_idParaDest-72">Beautifying Streamlit Apps</h1>
    <p class="normal">Welcome to <em class="italic">Section 2</em> of the book! In <em class="chapterRef">Section 1</em>, <em class="italic">Creating Basic Streamlit Applications</em>, we focused on the basics – visualization, deployment, and data munging – all the topics that are crucial to getting started with Streamlit. In this part of the book, the purpose is to explore Streamlit through more complex applications and use cases, with the intent of turning you into an expert Streamlit user. </p>
    <p class="normal">Throughout this chapter, we’ll work with elements (including sidebars, tabs, columns, and colors) to extend our ability to make beautiful Streamlit applications. Along with this, we’ll explore how to create multi-page applications to manage user flow, creating a cleaner and more structured user experience. </p>
    <p class="normal">By the end of this chapter, you should feel much more comfortable creating applications that are better than the <a id="_idIndexMarker221"/>average <strong class="keyWord">Minimum Viable Product</strong> (<strong class="keyWord">MVP</strong>). We’ll start by learning about columns and move on to the rest of the elements discussed, weaving each into the main Streamlit app for the chapter. </p>
    <p class="normal">Specifically, in this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Setting up the <strong class="keyWord">San Francisco</strong> (<strong class="keyWord">SF</strong>) Trees dataset</li>
      <li class="bulletList">Working with columns</li>
      <li class="bulletList">Working with tabs</li>
      <li class="bulletList">Exploring page configuration</li>
      <li class="bulletList">Using the Streamlit sidebar</li>
      <li class="bulletList">Picking colors with a color picker</li>
      <li class="bulletList">Multi-page apps</li>
      <li class="bulletList">Editable DataFrames</li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-73">Technical requirements</h1>
    <p class="normal">This chapter requires a free GitHub account, which can be obtained at <a href="https://www.github.com"><span class="url">https://www.github.com</span></a>. A full primer on GitHub, along with detailed setup instructions, can be found in the <em class="italic">A quick primer on GitHub</em> section in the previous chapter, <em class="chapterRef">Chapter 5</em>, <em class="italic">Deploying Streamlit with Streamlit Community Cloud</em>.</p>
    <h1 class="heading-1" id="_idParaDest-74">Setting up the SF Trees dataset</h1>
    <p class="normal">For this<a id="_idIndexMarker222"/> chapter, we will be working with the SF Trees dataset again, the same dataset that we used in <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>. As we did in the previous chapters, we need to follow this list of steps for the setup:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new folder for the chapter.</li>
      <li class="numberedList">Add our data to the folder.</li>
      <li class="numberedList">Create a Python file for our app.</li>
    </ol>
    <p class="normal">Let’s see each of these steps in detail.</p>
    <p class="normal">In our main <code class="inlineCode">streamlit_apps</code> folder, run the following code in your terminal to make a new folder cleverly called <code class="inlineCode">pretty_trees</code>. You can also create a new folder manually outside the terminal:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir pretty_trees
</code></pre>
    <p class="normal">Now, we need to move our data from <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>, into our folder for this chapter. The following code copies the data into the correct folder: </p>
    <pre class="programlisting con"><code class="hljs-con">cp trees_app/trees.csv pretty_trees
</code></pre>
    <p class="normal">If you do not have the <code class="inlineCode">trees_app</code> folder and have not yet completed <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>, you can also download the necessary data from <a href="https://github.com/tylerjrichards/Streamlit-for-Data-Science"><span class="url">https://github.com/tylerjrichards/Streamlit-for-Data-Science</span></a> within the folder titled <code class="inlineCode">trees_app</code>.</p>
    <p class="normal">Now that we have our data ready, we need to create a Python file to host our Streamlit app’s code; the following code does precisely this:</p>
    <pre class="programlisting con"><code class="hljs-con">touch pretty_trees.py
</code></pre>
    <p class="normal">The <code class="inlineCode">pretty_trees</code> file will hold our Python code, so go ahead and open it up in the text editor of your choice and<a id="_idIndexMarker223"/> the chapter can officially begin with us learning how to work with columns in Streamlit!</p>
    <h2 class="heading-2" id="_idParaDest-75">Working with columns in Streamlit</h2>
    <p class="normal">In all of our<a id="_idIndexMarker224"/> apps prior to this point, we have viewed each Streamlit task as a top-down experience. We output text as our title, collect some user input, and then put our visualizations below that. However, Streamlit allows us to format our app into dynamic columns using the <code class="inlineCode">st.columns()</code> feature.</p>
    <p class="normal">We can<a id="_idIndexMarker225"/> divide our Streamlit app into multiple columns of different lengths and then treat each column as its own unique space (called a container) in our app to include text, graphs, images, or anything else we would like. </p>
    <p class="normal">The syntax for columns in Streamlit uses the <code class="inlineCode">with</code> notation, which you may already have been familiar with for use cases such as resource management and dealing with opening and writing to files in Python. The easiest way to think about the <code class="inlineCode">with</code> notation in Streamlit columns is that they are self-contained blocks of code that tell Streamlit exactly where to place items in our apps. Let’s check out an example to see how it works. The following code imports our SF Trees dataset and creates three columns of equal length within it, writing text into each one: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
col1, col2, col3 = st.columns(<span class="hljs-number">3</span>)
<span class="hljs-keyword">with</span> col1:
    st.write(<span class="hljs-string">"Column 1"</span>)
<span class="hljs-keyword">with</span> col2:
    st.write(<span class="hljs-string">"Column 2"</span>)
<span class="hljs-keyword">with</span> col3:
    st.write(<span class="hljs-string">"Column 3"</span>)
</code></pre>
    <p class="normal">The preceding code will create the app shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_01.png"/></figure>
    <p class="packt_figref">Figure 6.1: First three columns</p>
    <p class="normal">As we <a id="_idIndexMarker226"/>can see, <code class="inlineCode">st.columns()</code> defines three columns of <a id="_idIndexMarker227"/>equal length, and we can use the <code class="inlineCode">with</code> notation to print some text in each. We can also call the <code class="inlineCode">st.write()</code> function (or any other Streamlit function that writes content to our Streamlit app) directly on our predefined columns for the same outcome, as shown in the following code. The following code will have the exact same output as the preceding code block:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
col1, col2, col3 = st.columns(<span class="hljs-number">3</span>)
col1.write(<span class="hljs-string">"Column 1"</span>)
col2.write(<span class="hljs-string">"Column 2"</span>)
col3.write(<span class="hljs-string">"Column 3"</span>)
</code></pre>
    <p class="normal">As we write more complex Streamlit apps with more content in each column, <code class="inlineCode">with</code> statements tend to make for cleaner apps that are easier to understand and debug. The majority of this book will use <code class="inlineCode">with</code> statements whenever possible. </p>
    <p class="normal">In Streamlit, the column width is relative to the size of the other defined columns. Because of this, if we scale up the width of each column to <code class="inlineCode">10</code> instead of <code class="inlineCode">1</code>, our app will not change at all. Additionally, we can also pass a single number into <code class="inlineCode">st.beta_columns()</code>, which will return that number of columns of equal width. The following code block shows three options for column width that all result in the same column width: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#option 1</span>
col1, col2, col3 = st.columns((<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))
<span class="hljs-comment">#option 2</span>
col1, col2, col3 = st.columns((<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))
<span class="hljs-comment">#option 3</span>
col1, col2, col3 = st.columns(<span class="hljs-number">3</span>)
</code></pre>
    <p class="normal">As a final <a id="_idIndexMarker228"/>example, the following code block allows the<a id="_idIndexMarker229"/> user input to determine the width of each column. Go ahead and play around with the resulting app to better understand how we can use columns to change the format behind our Streamlit apps: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
first_width = st.number_input(<span class="hljs-string">'First Width'</span>, min_value=<span class="hljs-number">1</span>, value=<span class="hljs-number">1</span>)
second_width = st.number_input(<span class="hljs-string">'Second Width'</span>, min_value=<span class="hljs-number">1</span>, value=<span class="hljs-number">1</span>)
third_width = st.number_input(<span class="hljs-string">'Third Width'</span>, min_value=<span class="hljs-number">1</span>, value=<span class="hljs-number">1</span>)
col1, col2, col3 = st.columns(
      (first_width,second_width,third_width))
<span class="hljs-keyword">with</span> col1:
     st.write(<span class="hljs-string">'First column'</span>)
<span class="hljs-keyword">with</span> col2:
     st.write(<span class="hljs-string">'</span><span class="hljs-string">Second column'</span>)
<span class="hljs-keyword">with</span> col3:
     st.write(<span class="hljs-string">'Third column'</span>)
</code></pre>
    <p class="normal">In <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>, we used the following code to show differences between the built-in Streamlit functions <code class="inlineCode">st.line_chart()</code>, <code class="inlineCode">st.bar_chart()</code>, and <code class="inlineCode">st.area_chart()</code>: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">'dbh'</span>]).count()[<span class="hljs-string">'tree_id'</span>])
df_dbh_grouped.columns = [<span class="hljs-string">'tree_count'</span>]
st.line_chart(df_dbh_grouped)
st.bar_chart(df_dbh_grouped)
st.area_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">The <a id="_idIndexMarker230"/>preceding <a id="_idIndexMarker231"/>code block creates the following Streamlit app, with three graphs of SF trees grouped by their width placed one right after the other (only the two graphs are shown for brevity):</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_02.png"/></figure>
    <p class="packt_figref">Figure 6.2: SF line and bar charts</p>
    <p class="normal">The point <a id="_idIndexMarker232"/>of this exercise was to better understand the<a id="_idIndexMarker233"/> three Streamlit functions, but how can we do that if we need to scroll to see them all? Let’s improve on this by putting our three graphs side by side using three columns. The following code predefines three equally wide columns and places one graph in each: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">'dbh'</span>]).count()[<span class="hljs-string">'tree_id'</span>])
df_dbh_grouped.columns = [<span class="hljs-string">'</span><span class="hljs-string">tree_count'</span>]
col1, col2, col3 = st.columns(<span class="hljs-number">3</span>)
<span class="hljs-keyword">with</span> col1:
     st.line_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> col2:
     st.bar_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> col3:
     st.area_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">When we<a id="_idIndexMarker234"/> run the preceding code, we get a strange<a id="_idIndexMarker235"/> result shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_03.png"/></figure>
    <p class="packt_figref">Figure 6.3: Skinny graphs</p>
    <p class="normal">This is most certainly not what we wanted! Each graph is far too narrow. Luckily for us, this brings us to our next mini-topic, page configuration in Streamlit.</p>
    <h2 class="heading-2" id="_idParaDest-76">Exploring page configuration</h2>
    <p class="normal">Streamlit allows <a id="_idIndexMarker236"/>us to configure a few essential page-specific features at the top of each Streamlit app. So far, we have been using the Streamlit defaults, but at the top of our Streamlit app, we can manually configure everything, from the page title shown on the web browser that is used to open our Streamlit apps, to the page layout, to the sidebar default state (we will cover the sidebar in the <em class="italic">Using the Streamlit sidebar</em> section!). </p>
    <p class="normal">The <a id="_idIndexMarker237"/>default for Streamlit apps is to have a centered page layout, which is why there is copious white space on the edges of our apps. The following code sets up our Streamlit app in a wide format instead of our default-centered one:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
st.set_page_config(layout=<span class="hljs-string">'wide'</span>)
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">'dbh'</span>]).count()[<span class="hljs-string">'tree_id'</span>])
df_dbh_grouped.columns = [<span class="hljs-string">'</span><span class="hljs-string">tree_count'</span>]
col1, col2, col3 = st.columns(<span class="hljs-number">3</span>)
<span class="hljs-keyword">with</span> col1:
     st.line_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> col2:
     st.bar_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> col3:
     st.area_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">When we run the preceding code, we now see that our three graphs are well spaced, and we can easily compare the three. The following screenshot shows the Streamlit app in a wide format: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_04.png"/></figure>
    <p class="packt_figref">Figure 6.4: Wide-format graphs</p>
    <p class="normal">There are <a id="_idIndexMarker238"/>two more bits of information that we need <a id="_idIndexMarker239"/>to know about Streamlit columns. The first is that we can also edit the gap between the column containers that we create, and the second is that we can also ensure that graphs stay within their columns and don’t bleed over into the other ones. For the gap part, the default is to leave a small gap between the columns, but we can change this to a medium or a large gap instead. This next bit of code adds a large gap between each of the three columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import </span>pandas<span class="hljs-keyword"> as </span>pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.set_page_config(layout=<span class="hljs-string">"</span><span class="hljs-string">wide"</span>)
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">"dbh"</span>]).count()[<span class="hljs-string">"tree_id"</span>])
df_dbh_grouped.columns = [<span class="hljs-string">"tree_count"</span>]
col1, col2, col3 = st.columns(<span class="hljs-number">3</span>, gap=<span class="hljs-string">"large"</span>)
<span class="hljs-keyword">with</span> col1:
    st.line_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> col2:
    st.bar_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> col3:
    st.area_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">Now, if we look between the graphs, we will notice a gap!</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_05.png"/></figure>
    <p class="packt_figref">Figure 6.5: Gap in the graphs</p>
    <p class="normal">As you <a id="_idIndexMarker240"/>may notice, Streamlit’s built-in charts that we’re using already ensure that the graphs stay in the columns as they’re supposed to<a id="_idIndexMarker241"/> and also sit flush with the end of the column. This is because the default on each is to set the parameter <code class="inlineCode">use_container_width</code> to <code class="inlineCode">True</code>, so what happens if we set it to <code class="inlineCode">False</code>, like this next bit of code?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> col1:
    st.line_chart(df_dbh_grouped, 
   use_container_width=<span class="hljs-literal">False</span>)
</code></pre>
    <p class="normal">As we can see in this next screenshot, the graph no longer sits flush with the column, thereby making our apps look worse (which is why the default has the value as <code class="inlineCode">True</code>!): </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_06.png"/></figure>
    <p class="packt_figref">Figure 6.6: Container width</p>
    <p class="normal">This concludes our exploration of using columns in Streamlit and also concludes our first look at page configuration defaults. We will increasingly use both of these skills in the remainder of the book. Our next topic is to introduce the Streamlit sidebar. </p>
    <h1 class="heading-1" id="_idParaDest-77">Using Streamlit tabs</h1>
    <p class="normal">There is a <a id="_idIndexMarker242"/>second way to organize your Streamlit app layout that is remarkably similar to the Streamlit column, called the tab. Tabs <a id="_idIndexMarker243"/>are useful when you have content that is too wide to break up into columns, even in wide mode, and also are useful when you want to focus attention by only showing one piece of content at a time. For example, if we had three very distinct graphs that only looked good in wide mode, but we didn’t want to put them vertically on top of each other, we could use tabs to selectively show them. Let’s explore exactly how this works!</p>
    <p class="normal"><code class="inlineCode">st.tabs</code> works very similarly to <code class="inlineCode">st.columns</code>, but instead of telling Streamlit the number of tabs we want, we instead pass along the names of the tabs and then use now-familiar <code class="inlineCode">with</code> statements to place content into the tab. The next bit of code turns the columns from our most recent Streamlit app into tabs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
 
st.set_page_config(layout=<span class="hljs-string">"wide"</span>)
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">"dbh"</span>]).count()[<span class="hljs-string">"tree_id"</span>])
df_dbh_grouped.columns = [<span class="hljs-string">"tree_count"</span>]
tab1, tab2, tab3 = st.tabs([<span class="hljs-string">"Line Chart"</span>, <span class="hljs-string">"</span><span class="hljs-string">Bar Chart"</span>, <span class="hljs-string">"Area Chart"</span>])
<span class="hljs-keyword">with</span> tab1:
    st.line_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> tab2:
    st.bar_chart(df_dbh_grouped)
<span class="hljs-keyword">with</span> tab3:
    st.area_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">From this, we will get the following app:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_07.png"/></figure>
    <p class="packt_figref">Figure 6.7: First tabs</p>
    <p class="normal">And that’s<a id="_idIndexMarker244"/> all there is to tabs! Tabs don’t have the gap parameter that columns do (because, well, what would a gap be for tabs?), but aside from this, we can map all the information we learned about columns onto our knowledge of tabs. Now, on to the Streamlit sidebar. </p>
    <h1 class="heading-1" id="_idParaDest-78">Using the Streamlit sidebar</h1>
    <p class="normal">As we have <a id="_idIndexMarker245"/>already seen in Streamlit, when we start to both accept large amounts of user input and also start to develop longer Streamlit apps, we often lose the ability for the user to see both their input and the output on the same screen. In other cases, we may want to put all the user input into its own section to clearly separate input and output in our Streamlit app. For both of these use cases, we can use the Streamlit sidebar, which allows us to place a minimizable sidebar on the left side of the Streamlit app and add any Streamlit component to it. </p>
    <p class="normal">To begin with, we can create a basic example that takes one of the graphs from our preceding app and filters the data behind it based on the user’s input. In this case, we can ask the user to <a id="_idIndexMarker246"/>specify the type of tree owner (for example, a private owner or the Department of Public Works) and filter on those conditions using the <code class="inlineCode">st.multiselect()</code> function, which allows the user to select multiple options from a list: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW.</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
owners = st.sidebar.multiselect(
    <span class="hljs-string">"Tree Owner Filter"</span>, 
    trees_df[<span class="hljs-string">"caretaker"</span>].unique())
<span class="hljs-keyword">if</span> owners:
    trees_df = trees_df[
trees_df[<span class="hljs-string">"</span><span class="hljs-string">caretaker"</span>].isin(owners)]
df_dbh_grouped = pd.DataFrame(
trees_df.groupby([<span class="hljs-string">"dbh"</span>]).count()[<span class="hljs-string">"tree_id"</span>])
df_dbh_grouped.columns = [<span class="hljs-string">"tree_count"</span>]
st.line_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">The preceding code will create the following Streamlit app. As we have done before, we hide the <code class="inlineCode">owners</code> variable within an <code class="inlineCode">if</code> statement, as we would like the app to run with the entire dataset if the user has yet to select from the options. The sidebar allows the user to easily see both the options they selected and the output to our app:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_08.png"/></figure>
    <p class="packt_figref">Figure 6.8: First sidebar</p>
    <p class="normal">Our next <a id="_idIndexMarker247"/>step for this app is going to be to add a few more visualizations, starting with the tree map we created in <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>, and then combine the sidebar with what we have already learned about columns in this chapter. </p>
    <p class="normal">The following code places the map of trees throughout SF, filtered by our multi-select box, below the histogram: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
 
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW. The dataset</span>
<span class="hljs-string">    is filtered by the owner of the tree as selected </span>
<span class="hljs-string">    in the sidebar!</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
owners = st.sidebar.multiselect(
    <span class="hljs-string">"Tree Owner Filter"</span>, 
    trees_df[<span class="hljs-string">"caretaker"</span>].unique())
<span class="hljs-keyword">if</span> owners:
    trees_df = trees_df[
        trees_df[<span class="hljs-string">"caretaker"</span>].isin(owners)]
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">"dbh"</span>]).count()[<span class="hljs-string">"tree_id"</span>])
df_dbh_grouped.columns = [<span class="hljs-string">"tree_count"</span>]
st.line_chart(df_dbh_grouped)
 
trees_df = trees_df.dropna(subset=[<span class="hljs-string">'longitude'</span>, <span class="hljs-string">'latitude'</span>])
trees_df = trees_df.sample(n = <span class="hljs-number">1000</span>, replace=<span class="hljs-literal">True</span>) 
st.<span class="hljs-built_in">map</span>(trees_df)
</code></pre>
    <p class="normal">The following<a id="_idIndexMarker248"/> screenshot shows the Streamlit app from the preceding code, with the line chart just above the new map of the trees in SF, filtered by the tree owner: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_09.png"/></figure>
    <p class="packt_figref">Figure 6.9: Filtered map with sidebar</p>
    <p class="normal">Our next step for this app will be to combine what we learned about columns with the sidebar by adding another graph on top of the map. In <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>, we created a histogram of the age of the trees. We can use that as our third graph in this Streamlit app using the Plotly library:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.page_config(layout=<span class="hljs-string">'wide'</span>)
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW. The dataset</span>
<span class="hljs-string">    is filtered by the owner of the tree as selected</span>
<span class="hljs-string">    in the sidebar!</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
today = pd.to_datetime(<span class="hljs-string">"today"</span>)
trees_df[<span class="hljs-string">"date"</span>] = pd.to_datetime(trees_df[<span class="hljs-string">"date"</span>])
trees_df[<span class="hljs-string">"age"</span>] = (today - trees_df[<span class="hljs-string">"date"</span>]).dt.days
unique_caretakers = trees_df[<span class="hljs-string">"caretaker"</span>].unique()
owners = st.sidebar.multiselect(
    <span class="hljs-string">"</span><span class="hljs-string">Tree Owner Filter"</span>, 
    unique_caretakers)
<span class="hljs-keyword">if</span> owners:
    trees_df = trees_df[trees_df[<span class="hljs-string">"caretaker"</span>].isin(owners)]
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">"dbh"</span>]).count()[<span class="hljs-string">"tree_id"</span>])
df_dbh_grouped.columns = [<span class="hljs-string">"tree_count"</span>]
</code></pre>
    <p class="normal">This<a id="_idIndexMarker249"/> first section:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Loads the trees dataset.</li>
      <li class="numberedList">Adds an age column based on the date column in our dataset.</li>
      <li class="numberedList">Creates a multi-select widget on the sidebar.</li>
      <li class="numberedList">Filters, based on the sidebar.</li>
    </ol>
    <p class="normal">Our next step is to create our three graphs:</p>
    <pre class="programlisting code"><code class="hljs-code">col1, col2 = st.columns(<span class="hljs-number">2</span>)
<span class="hljs-keyword">with</span> col1:
    fig = px.histogram(trees_df, x=trees_df[<span class="hljs-string">"</span><span class="hljs-string">dbh"</span>], title=<span class="hljs-string">"Tree Width"</span>)
    st.plotly_chart(fig)
 
<span class="hljs-keyword">with</span> col2:
    fig = px.histogram(
        trees_df, x=trees_df[<span class="hljs-string">"age"</span>], 
        title=<span class="hljs-string">"Tree Age"</span>)
    st.plotly_chart(fig)
 
st.write(<span class="hljs-string">"Trees by Location"</span>)
trees_df = trees_df.dropna(
    subset=[<span class="hljs-string">"longitude"</span>, <span class="hljs-string">"latitude"</span>])
trees_df = trees_df.sample(
    n=<span class="hljs-number">1000</span>, replace=<span class="hljs-literal">True</span>)
st.<span class="hljs-built_in">map</span>(trees_df)
</code></pre>
    <p class="normal">As we have<a id="_idIndexMarker250"/> already discussed in <em class="chapterRef">Chapter 3, </em><em class="italic">Data Visualization</em>, built-in Streamlit functions such as <code class="inlineCode">st.map()</code> and <code class="inlineCode">st.line_chart()</code> are useful for quick visualizations but lack some configuration options, such as proper titles or axis renaming. We can do so much more with Plotly! The following screenshot shows our Streamlit app with a few tree owner filters pre-set: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_10.png"/></figure>
    <p class="packt_figref">Figure 6.10: Three filtered graphs</p>
    <p class="normal">Our next feature to discuss in this chapter is how to add color input into Streamlit apps with a color picker! </p>
    <h1 class="heading-1" id="_idParaDest-79">Picking colors with a color picker</h1>
    <p class="normal">Colors<a id="_idIndexMarker251"/> are very difficult to take in as user input in apps. If a user wants red, do they want light red or dark red? Maroon or a pinkish red? Streamlit’s approach to this problem is <code class="inlineCode">st.color_picker()</code>, which lets the user pick a color as a part of their user input, and returns that color in a hex string (which is a unique string that defines very specific color shades used by most graphing libraries as input). The following code adds this color picker to our previous app and changes the color of the Seaborn graphs to be based on the color that the user selects: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.set_page_config(layout=<span class="hljs-string">"wide"</span>)
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""</span>
<span class="hljs-string">    This app analyses trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW. The dataset</span>
<span class="hljs-string">    is filtered by the owner of the tree as selected</span>
<span class="hljs-string">    in the sidebar!</span>
<span class="hljs-string">    """</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
today = pd.to_datetime(<span class="hljs-string">"today"</span>)
trees_df[<span class="hljs-string">"date"</span>] = pd.to_datetime(trees_df[<span class="hljs-string">"date"</span>])
trees_df[<span class="hljs-string">"age"</span>] = (today - trees_df[<span class="hljs-string">"date"</span>]).dt.days
unique_caretakers = trees_df[<span class="hljs-string">"caretaker"</span>].unique()
owners = st.sidebar.multiselect(<span class="hljs-string">"Tree Owner Filter"</span>, unique_caretakers)
graph_color = st.sidebar.color_picker(<span class="hljs-string">"Graph Colors"</span>)
<span class="hljs-keyword">if</span> owners:
    trees_df = trees_df[trees_df[<span class="hljs-string">"caretaker"</span>].isin(owners)]
</code></pre>
    <p class="normal">The change here from our previous app is to add the <code class="inlineCode">graph_color</code> variable, which is a result of the <code class="inlineCode">st.color_picker()</code> function. We added a name to this color picker and placed the color picker in the sidebar right under the owner’s multi-select widget. Now that we have the color input from the user, we can use this to change the colors in our graphs, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">col1, col2 = st.columns(<span class="hljs-number">2</span>)
<span class="hljs-keyword">with</span> col1:
    fig = px.histogram(
        trees_df,
        x=trees_df[<span class="hljs-string">"dbh"</span>],
        title=<span class="hljs-string">"Tree Width"</span>,
        color_discrete_sequence=[graph_color],
    )
    fig.update_xaxes(title_text=<span class="hljs-string">"Width"</span>)
    st.plotly_chart(fig, use_container_width=<span class="hljs-literal">True</span>)
 
<span class="hljs-keyword">with</span> col2:
    fig = px.histogram(
        trees_df,
        x=trees_df[<span class="hljs-string">"age"</span>],
        title=<span class="hljs-string">"Tree Age"</span>,
        color_discrete_sequence=[graph_color],
    )
    st.plotly_chart(fig, use_container_width=<span class="hljs-literal">True</span>)
st.write(<span class="hljs-string">'Trees by Location'</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">'longitude'</span>, <span class="hljs-string">'latitude'</span>])
trees_df = trees_df.sample(n = <span class="hljs-number">1000</span>, replace=<span class="hljs-literal">True</span>)
st.<span class="hljs-built_in">map</span>(trees_df)
</code></pre>
    <p class="normal">When <a id="_idIndexMarker252"/>you run this Streamlit app, you can see exactly how the color picker works (this book is published in grayscale, so it is not visible in the hard copy). It has a default color (in our case, black), which you can change by selecting the component and then clicking on your color of choice. The following screenshot shows both the component when clicked on and the result in our SF Trees app: </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_11.png"/></figure>
    <p class="packt_figref">Figure 6.11: Color picker</p>
    <p class="normal">Now that <a id="_idIndexMarker253"/>we know how to change the colors of visualizations in Streamlit, let’s move over to the last section of this chapter: creating multi-page apps. </p>
    <h1 class="heading-1" id="_idParaDest-80">Multi-page apps</h1>
    <p class="normal">Our Streamlit apps<a id="_idIndexMarker254"/> thus far have all been single pages, where all or nearly all the information in the app has been visible to us with a simple scroll. However, Streamlit also has multi-page functionality. Multi-page apps are a powerful tool for creating apps that are not limited to one page of content and can extend the user experience that comes with Streamlit. For example, the Streamlit data team currently primarily builds multi-page apps, having a new app for each project or team that they are creating Streamlit apps for. </p>
    <p class="normal">For our first multi-page app, we’re going to focus on separating the map section of the trees app from the rest of the graphs in two separate apps. The way Streamlit creates multi-page apps is it looks in the same directory as our Streamlit app for a folder called <code class="inlineCode">pages</code> and then runs each Python file inside the <code class="inlineCode">pages</code> folder as its own Streamlit app. To do this, create a new folder inside <code class="inlineCode">pretty_trees</code> called <code class="inlineCode">pages</code>, and then put a file inside <code class="inlineCode">pages</code> called <code class="inlineCode">map.py</code>. In your terminal from the base folder in the repository, you can run the following:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir pages
touch pages/map.py
</code></pre>
    <p class="normal">Now, when <a id="_idIndexMarker255"/>we run our Streamlit app, we should see the <strong class="screenText">map</strong> app on the sidebar as its own app:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_12.png"/></figure>
    <p class="packt_figref">Figure 6.12: Our first multi-page app</p>
    <p class="normal">When we click <strong class="screenText">map</strong> in the top left, it will be completely blank. Now, we need to take the map code and move it over into the <code class="inlineCode">map.py</code> file! Inside the <code class="inlineCode">map.py</code> file, we can include the following code (which is just copied and pasted from our original app): </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"SF Trees Map"</span>)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">"longitude"</span>, <span class="hljs-string">"</span><span class="hljs-string">latitude"</span>])
trees_df = trees_df.sample(n=<span class="hljs-number">1000</span>, replace=<span class="hljs-literal">True</span>)
st.<span class="hljs-built_in">map</span>(trees_df)
</code></pre>
    <p class="normal">When we click on the <strong class="screenText">map</strong> app, it should no longer be blank but should instead look like this:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_13.png"/></figure>
    <p class="packt_figref">Figure 6.13: Map MPA</p>
    <p class="normal">The last<a id="_idIndexMarker256"/> thing we need to do for this app is to remove the map code from the main file. Our main file’s code should now be much smaller and should look like this. Here is a snippet of the code:</p>
    <pre class="programlisting code"><code class="hljs-code">col1, col2 = st.columns(<span class="hljs-number">2</span>)
<span class="hljs-keyword">with</span> col1:
    fig = px.histogram(
        trees_df,
        x=trees_df[<span class="hljs-string">"dbh"</span>],
        title=<span class="hljs-string">"Tree Width"</span>,
        color_discrete_sequence=[graph_color],
    )
    fig.update_xaxes(title_text=<span class="hljs-string">"Width"</span>)
    st.plotly_chart(fig, use_container_width=<span class="hljs-literal">True</span>)
 
<span class="hljs-keyword">with</span> col2:
    fig = px.histogram(
        trees_df,
        x=trees_df[<span class="hljs-string">"age"</span>],
        title=<span class="hljs-string">"Tree Age"</span>,
        color_discrete_sequence=[graph_color],
    )
    st.plotly_chart(fig, use_container_width=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">If we wanted to add a new app, we would only need to add another file to the <code class="inlineCode">pages</code> folder, and Streamlit would handle all the rest. </p>
    <p class="normal">As you <a id="_idIndexMarker257"/>can see, multi-page apps can be extremely powerful. As our apps get longer and the user experience of our apps becomes more complicated, we can rely on multi-page apps to drive clarity in the user experience. With these, you can easily imagine creating one large multi-page app that has individual apps for your different business users (like your marketing team, your sales team, etc.) or even just as an elegant way to split up your larger apps. If you ever want to create a new app, just add another Python file to the <code class="inlineCode">pages</code> folder, and the new app will pop up in the sidebar! </p>
    <p class="normal">A member of the Streamlit data science team (Zachary Blackwood, <a href="https://github.com/blackary"><span class="url">https://github.com/blackary</span></a>) created a Python library called <code class="inlineCode">st-pages</code> that adds a host of new features on top of multi-page apps, like adding emojis to page links or creating sections for files. The library is fairly young but is a great additional resource if you are interested in creating even larger apps than we have worked on in this chapter. There is a large and vibrant community around Streamlit, and libraries like these are just our first foray into the wonders of open source Streamlit:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_14.png"/></figure>
    <p class="packt_figref">Figure 6.14: st-pages</p>
    <p class="normal">That is it for multi-page apps! Now on to editable DataFrames.</p>
    <h1 class="heading-1" id="_idParaDest-81">Editable DataFrames</h1>
    <p class="normal">So far in <a id="_idIndexMarker258"/>this book, we have assumed that we want the data used in these apps to be static. We have used mostly CSV files or programmatically generated datasets that remain unchanged by the users of our apps. </p>
    <p class="normal">This is very often the case, but we might want to give users the ability to alter or edit the underlying data in a very user-friendly way. To help solve this, Streamlit released <code class="inlineCode">st.experimental_data_editor</code>, a way to give users edit ability on top of an <code class="inlineCode">st.dataframe-style</code> interface. </p>
    <p class="normal">There are a massive number of potential apps for editing DataFrames, from using Streamlit as a quality control system to allowing for direct edits to configuration parameters to doing even more of the “what-if” analyses that we have done so far in this book. As a creator of many different apps in a work setting, I have noticed that people are often extremely comfortable with the everpresent spreadsheet and prefer that type of UI. </p>
    <p class="normal">For this example, let’s create a new app called <code class="inlineCode">data_quality.py</code> in the <code class="inlineCode">pages</code> folder, and try out the new editable DataFrame feature. Imagine that we’re a part of the data department in SF, and having missing data in privately owned trees is causing some issues for us. We want a few people to come and take a look at our data and edit anything that they see might be wrong, and then we also want to write that data back to our trusty data source, the CSV file. </p>
    <p class="normal">First, we can start by writing a small message at the top of our new file, filtering the data as we have done before, and showing the DataFrame to the user, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"SF Trees Data Quality App"</span>)
st.write(
    <span class="hljs-string">"""This app is a data quality tool for the SF trees dataset. Edit the data and save to a new file!"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">"longitude"</span>, <span class="hljs-string">"latitude"</span>])
trees_df_filtered = trees_df[trees_df[<span class="hljs-string">"legal_status"</span>] == <span class="hljs-string">"Private"</span>]
st.dataframe(trees_df)
</code></pre>
    <p class="normal">To make this data editable, we only need to change <code class="inlineCode">st.dataframe</code> to <code class="inlineCode">st.experimental_data_editor</code>, and then pass the result back to a new DataFrame:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
st.title(<span class="hljs-string">"SF Trees Data Quality App"</span>)
st.write(
    <span class="hljs-string">"""This app is a data quality tool for the SF trees dataset. Edit the data and save to a new file!"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">"longitude"</span>, <span class="hljs-string">"</span><span class="hljs-string">latitude"</span>])
trees_df_filtered = trees_df[trees_df[<span class="hljs-string">"legal_status"</span>] == <span class="hljs-string">"Private"</span>]
edited_df = st.experimental_data_editor(trees_df_filtered)
</code></pre>
    <p class="normal">This app, when<a id="_idIndexMarker259"/> it is run, looks like the following. I clicked on a cell and edited it to show that this works!</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_15.png"/></figure>
    <p class="packt_figref">Figure 6.15: st-experimental_data_editor</p>
    <p class="normal">The entire DataFrame is passed back by the data editor, so our last step is to edit the original, unfiltered DataFrame and then overwrite the CSV file. We want to make sure that the user is sure about their changes, so we can add a button that writes the result back to the original CSV file:</p>
    <pre class="programlisting code"><code class="hljs-code">import pandas <span class="hljs-keyword">as</span> pd
import streamlit <span class="hljs-keyword">as</span> <span class="hljs-keyword">st</span>
<span class="hljs-keyword">st</span>.title(<span class="hljs-string">"SF Trees Data Quality App"</span>)
<span class="hljs-keyword">st</span>.<span class="hljs-keyword">write</span>(
    <span class="hljs-string">"""This app is a data quality tool for the SF trees dataset. Edit the data and save to a new file!"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">"longitude"</span>, <span class="hljs-string">"latitude"</span>])
trees_df_filtered = trees_df[trees_df[<span class="hljs-string">"legal_status"</span>] == <span class="hljs-string">"Private"</span>]
edited_df = <span class="hljs-keyword">st</span>.experimental_data_editor(trees_df_filtered) 
trees_df.<span class="hljs-keyword">loc</span>[edited_df.<span class="hljs-built_in">index</span>] = edited_df
<span class="hljs-keyword">if</span> <span class="hljs-keyword">st</span>.button(<span class="hljs-string">"Save data and overwrite:"</span>):
    trees_df.to_csv(<span class="hljs-string">"trees.csv"</span>, <span class="hljs-built_in">index</span>=False)
    <span class="hljs-keyword">st</span>.<span class="hljs-keyword">write</span>(<span class="hljs-string">"Saved!"</span>)
</code></pre>
    <p class="normal">This app <a id="_idIndexMarker260"/>now looks like this. We can notice that the plot size measurements are missing for many of the rows in this dataset!</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_16.png"/></figure>
    <p class="packt_figref">Figure 6.16: Missing plot size measurements in SF Trees Data Quality App</p>
    <p class="normal">We can add them and then click the save data button to overwrite. Maybe we also noticed a<a id="_idIndexMarker261"/> data quality issue in the first row, where the x is capitalized (dissimilar from the rest!). Let’s edit that too:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_06_17.png"/></figure>
    <p class="packt_figref">Figure 6.17: Editing SF Trees Data Quality App</p>
    <p class="normal">Now, if we reload the app or have this data hosted on Streamlit Community Cloud and someone else visits the app, all the data is corrected. </p>
    <p class="normal">As of the time of writing this book, the data editor is an extremely new feature (it was released in Streamlit 1.19, and this book runs on Streamlit 1.20). I am sure that by the time you are reading this, there are even more cool new features built on top of the data editor and the DataFrame! Please check out the documentation (<a href="https://docs.streamlit.io/"><span class="url">https://docs.streamlit.io/</span></a>) for more data editor knowledge. Now on to the summary! </p>
    <h1 class="heading-1" id="_idParaDest-82">Summary</h1>
    <p class="normal">This concludes our adventures with the SF Trees dataset and learning about the various ways to make our Streamlit apps more aesthetically pleasing. We covered separating our apps into columns and page configuration, along with gathering user input in the sidebar, getting specific colors in user input through the <code class="inlineCode">st.color_picker()</code> feature, and finally learning how to use Streamlit multi-page apps and the new data editor. </p>
    <p class="normal">In the next chapter, we will learn about the open source community around Streamlit by understanding how to download and use Streamlit Components built by users. </p>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/sl"><span class="url">https://packt.link/sl</span></a></p>
    <p class="normal"><img alt="" role="presentation" src="../Images/QR_Code13440134443835796.png"/></p>
  </div>
</body></html>