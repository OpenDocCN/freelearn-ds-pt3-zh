<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer050">
    <h1 class="chapterNumber">3</h1>
    <h1 class="chapterTitle" id="_idParaDest-38">Data Visualization</h1>
    <p class="normal">Visualization is a fundamental tool for the modern data scientist. It is often the central lens used to understand items such as statistical models (for example, via an AUC chart), the distribution of a crucial variable (via a histogram), or even important business metrics.</p>
    <p class="normal">In the last two chapters, we used two popular Python graphing libraries (<strong class="keyWord">Matplotlib</strong> and <strong class="keyWord">Altair</strong>) in our examples. This chapter will focus on extending that ability to a broad range of Python graphing libraries, including some graphing functions native to Streamlit.</p>
    <p class="normal">By the end of this chapter, you should feel comfortable using Streamlit’s native graphing functions and visualization functions to place graphs made from major Python visualization libraries in your own Streamlit app. </p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">San Francisco</strong> (<strong class="keyWord">SF</strong>) Trees – a new dataset</li>
      <li class="bulletList">Streamlit’s built-in graphing functions</li>
      <li class="bulletList">Streamlit’s built-in visualization options</li>
      <li class="bulletList">Using Python visualization libraries in Streamlit. In this section, we will cover the following libraries:<ul>
          <li class="bulletList"><strong class="keyWord">Plotly</strong> (for interactive visualizations)</li>
          <li class="bulletList"><strong class="keyWord">Seaborn</strong> and <strong class="keyWord">Matplotlib</strong> (for classic statistical visualizations)</li>
          <li class="bulletList"><strong class="keyWord">Bokeh</strong> (for interactive visualization in web browsers)</li>
          <li class="bulletList"><strong class="keyWord">Altair</strong> (for declarative, interactive visualizations)</li>
          <li class="bulletList"><strong class="keyWord">PyDeck</strong> (for interactive map-based visualizations)</li>
        </ul>
      </li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-39">Technical requirements</h1>
    <p class="normal">In this chapter, we will be working with a new dataset that can be found at <a href="https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv"><span class="url">https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv</span></a>. A further explanation of the dataset can be found in the following section.</p>
    <h1 class="heading-1" id="_idParaDest-40">San Francisco Trees – a new dataset</h1>
    <p class="normal">We’re <a id="_idIndexMarker068"/>going to be working with all sorts of graphs in this chapter, so we’re going to need a new dataset that has much more info, especially dates and locations. Enter <strong class="keyWord">SF Trees</strong>. The department of public works in SF has a dataset (cleaned by the wonderful folks in the R community who run Tidy Tuesday, a weekly event where people publish interesting visualizations of new data each week) of every tree planted and maintained in the city of SF. They cleverly call this dataset <strong class="keyWord">EveryTreeSF – Urban Forest Map</strong> and update it every day. I have selected a random set of 10,000 trees with complete info and placed this data in the main GitHub repository under the <strong class="keyWord">trees</strong> folder (I’m not as clever as the data engineer in SF’s DPW, I know). The GitHub repo can be found at <a href="https://github.com/tylerjrichards/streamlit_apps"><span class="url">https://github.com/tylerjrichards/streamlit_apps</span></a>. If you would like to download the full dataset, the link is here: <a href="https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq"><span class="url">https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq</span></a>.</p>
    <p class="normal">From the main <code class="inlineCode">streamlit_apps</code> folder that we’ve been using throughout this book, start by creating a new folder, creating a new Python file, and then downloading our data into that folder, the same thing we did in <em class="chapterRef">Chapter 2</em>, <em class="italic">Uploading, Downloading, and Manipulating Data</em>, but with some new data! You can run the following code in your terminal to set this up:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir trees_app
cd trees_app
touch trees.py
curl https://raw.githubusercontent.com/tylerjrichards/streamlit_apps/main/trees_app/trees.csv &gt; trees.csv
</code></pre>
    <div class="note">
      <p class="normal">I’ll note here that if this does not work, or if you are on an operating system without these commands (such as Windows, for example), you can always go and download the CSV file directly by going to the GitHub repo mentioned in the preceding paragraph (<a href="https://github.com/tylerjrichards/streamlit_apps"><span class="url">https://github.com/tylerjrichards/streamlit_apps</span></a>).</p>
    </div>
    <p class="normal">Now that we have our setup, our next step is to open our <code class="inlineCode">trees.py</code> file in our favorite editor and start making our Streamlit app.</p>
    <div class="note">
      <p class="normal">We will follow these exact same steps at the beginning of the rest of the chapters, so in the future, we will not cover these explicitly.</p>
    </div>
    <p class="normal">Let’s start <a id="_idIndexMarker069"/>by titling our app and printing out some example rows using the following code: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
st.write(trees_df.head())
</code></pre>
    <p class="normal">We can then run the following command in our terminal and see the resulting Streamlit app in our browser:</p>
    <pre class="programlisting con"><code class="hljs-con">streamlit run trees.py
</code></pre>
    <p class="normal">Note that this is neither the easiest nor the best way to see the first few rows of a dataset, but we can do this purely because we already know that we’re going to build a Streamlit app using this data. The general workflow usually begins with some data exploration outside of Streamlit (in Jupyter notebooks, through SQL queries, or whatever the preferred workflow is for you as a data scientist or analyst). With that said, let’s continue our exploration of the dataset by looking at the output of the preceding code in the new Streamlit app in our browser:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_03_01.png"/></figure>
    <p class="packt_figref">Figure 3.1: The first few rows of trees</p>
    <p class="normal">This dataset <a id="_idIndexMarker070"/>contains a huge amount of info about the trees in SF, from their width (<strong class="screenText">dbh</strong>) to the longitude and latitude points, the species, their address, and even the date they were planted. Before we get started with graphing, let’s talk a bit about the visualization options in front of us. </p>
    <h1 class="heading-1" id="_idParaDest-41">Streamlit visualization use cases</h1>
    <p class="normal">Some<a id="_idIndexMarker071"/> Streamlit users are relatively experienced Python developers <a id="_idIndexMarker072"/>with well-tested workflows in visualization libraries of their choice. For these users, the best path forward is the one we’ve taken so far, which is to create graphs in our library of choice (Seaborn, Matplotlib, Bokeh, and so on) and then use the appropriate Streamlit function to write this to the app. </p>
    <p class="normal">Other Streamlit users will have less experience in Pythonic graphing, and especially for these users, Streamlit offers a few built-in functions. We’ll start with built-in libraries and move on to learning how to import the most popular and powerful libraries for our Streamlit apps. </p>
    <h1 class="heading-1" id="_idParaDest-42">Streamlit’s built-in graphing functions</h1>
    <p class="normal">There are<a id="_idIndexMarker073"/> four built-in functions for graphing – <code class="inlineCode">st.line_chart()</code>, <code class="inlineCode">st.bar_chart()</code>, <code class="inlineCode">st.area_chart()</code>, and <code class="inlineCode">st.map()</code>. They all work similarly by<a id="_idIndexMarker074"/> trying to figure out what variables you’re already trying to graph and then putting them into a line, bar, map, or area chart, respectively. In our dataset, we have a variable called <code class="inlineCode">dbh</code>, which is the width of the tree at chest height. First, we can group our DataFrame by <code class="inlineCode">dbh</code>, and then push that directly to the line chart, bar chart, and area chart. The following code should group our dataset by width, count the unique trees of each width, and then make a line, bar, and area chart of each:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">'dbh'</span>]).count()[<span class="hljs-string">'tree_id'</span>])
df_dbh_grouped.columns = [<span class="hljs-string">'tree_count'</span>]
st.line_chart(df_dbh_grouped)
st.bar_chart(df_dbh_grouped)
st.area_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">The preceding code should show our three graphs one right after another, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_03_02.png"/></figure>
    <p class="packt_figref">Figure 3.2: Lines, bars, area, and tree height</p>
    <p class="normal">We gave the<a id="_idIndexMarker075"/> function nothing except for the DataFrame, and it was able to guess correctly which items should be on the <em class="italic">x</em> and <em class="italic">y</em> axes and plot those<a id="_idIndexMarker076"/> to our Streamlit chart. Each of these charts is also interactive by default! We can zoom in or out, roll the mouse over points/bars/lines to see each data point, and even view the full screen out of the box. These Streamlit functions call a popular graphing library<a id="_idIndexMarker077"/> called <strong class="keyWord">Altair</strong> (the same one we used before in <em class="chapterRef">Chapter 2</em>!). </p>
    <p class="normal">Now that we see the basics of the built-in (it’s clear that the term <em class="italic">built-in</em> is fairly loose here, as Streamlit is built to be a great and convenient web application library, not a great visualization library) functions, let’s push these functions to see how they handle more data. First, we’re going <a id="_idIndexMarker078"/>to make a new column of random numbers between -500 and 500 in our <code class="inlineCode">df_dbh_grouped</code> DataFrame, using the <code class="inlineCode">numpy</code> library, and use the same plotting <a id="_idIndexMarker079"/>code that we used before. The following code plots two line charts, one before we added the new column, and one after: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
df_dbh_grouped = pd.DataFrame(trees_df.groupby([<span class="hljs-string">'dbh'</span>]).count()[<span class="hljs-string">'tree_id'</span>])
df_dbh_grouped.columns = [<span class="hljs-string">'tree_count'</span>]
st.line_chart(df_dbh_grouped)
df_dbh_grouped[<span class="hljs-string">'new_col'</span>] = np.random.randn(<span class="hljs-built_in">len</span>(df_dbh_grouped)) * <span class="hljs-number">500</span>
st.line_chart(df_dbh_grouped)
</code></pre>
    <p class="normal">This code should produce an app that looks like the following screenshot, with the two separate line charts vertically adjacent to each other. </p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_03_03.png"/></figure>
    <p class="packt_figref">Figure 3.3: Two sequential line charts</p>
    <p class="normal">Again, these <a id="_idIndexMarker080"/>functions <a id="_idIndexMarker081"/>put whatever is on the index on the <em class="italic">x</em> axis and use all the columns they can as variables on the <em class="italic">y </em>axis. These built-in functions are very useful if we have an incredibly straightforward graphing problem in front of us (as in the example). If we want, we can also explicitly tell Streamlit the variables that we want to plot on the <em class="italic">x</em><strong class="screenText"> </strong>and <em class="italic">y</em> axes; the following bit of code turns the index into its own column and then graphs a line chart: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
 
st.title(<span class="hljs-string">"SF Trees"</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">"trees.csv"</span>)
df_dbh_grouped = pd.DataFrame(
    trees_df.groupby([<span class="hljs-string">"dbh"</span>]).count()[<span class="hljs-string">"tree_id"</span>]
).reset_index()
df_dbh_grouped.columns = [<span class="hljs-string">"</span><span class="hljs-string">dbh"</span>, <span class="hljs-string">"tree_count"</span>]
st.line_chart(df_dbh_grouped, x=<span class="hljs-string">"dbh"</span>, y=<span class="hljs-string">"tree_count"</span>)
</code></pre>
    <p class="normal">When you run <a id="_idIndexMarker082"/>this code, you’ll see the same line chart we created <a id="_idIndexMarker083"/>before! These built-in functions are great but less flexible when compared to libraries with the sole purpose of visualization, and it may be difficult to debug the behavior behind these functions. </p>
    <p class="normal">The recommendation here is that if you want a fairly basic visualization, these functions will probably work just fine for you. But if you want something more complicated, you should use other graphing libraries (my personal favorite is Altair). </p>
    <p class="normal">There is one more built-in Streamlit graphing function that we should discuss here, <code class="inlineCode">st.map()</code>. Just like the preceding functions, this wraps around another Python graphing library, this time PyDeck instead of Altair, and finds columns that it thinks are longitude and latitude points by searching the DataFrame for columns with titles such as <strong class="keyWord">longitude</strong>, <strong class="keyWord">long</strong>, <strong class="keyWord">latitude</strong>, or <strong class="keyWord">lat</strong>. Then, it plots each row as its own point on a map, auto-zooms and focuses the map, and writes it to our Streamlit app. We should note that visualizing detailed maps is much more computationally intensive in comparison to the other forms of visualization that we have used so far, so we are going to sample 1,000 random rows from our DataFrame, remove <code class="inlineCode">null</code> values, and try out <code class="inlineCode">st.map()</code> using the following code: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
trees_df = trees_df.dropna(subset=[<span class="hljs-string">'longitude'</span>, <span class="hljs-string">'latitude'</span>])
trees_df = trees_df.sample(n = <span class="hljs-number">1000</span>)
st.<span class="hljs-built_in">map</span>(trees_df)
</code></pre>
    <p class="normal">This works <a id="_idIndexMarker084"/>perfectly well, right out of the box! We get a beautiful interactive <a id="_idIndexMarker085"/>map of trees in SF, as we can see in the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 3.4 – Default SF map of trees " src="../Images/B18444_03_04.png"/></figure>
    <p class="packt_figref">Figure 3.4: Default SF map of trees</p>
    <p class="normal">As with other functions, we don’t have many options for customization here other than an optional zoom parameter, but this works very well for quick visualization. </p>
    <p class="normal">As we’ve seen, these built-in functions can be useful to make Streamlit apps quickly, but we trade off speed<a id="_idIndexMarker086"/> for customizability. In practice, I rarely use these<a id="_idIndexMarker087"/> functions when I produce Streamlit apps, but I often use these when doing quick visualizations of data already in Streamlit. In production, more powerful libraries, such as Matplotlib, Seaborn, and PyDeck, would be able to give us the flexibility and customizability we want. The rest of this chapter will provide a walk-through of six different popular Python visualization libraries.</p>
    <h1 class="heading-1" id="_idParaDest-43">Streamlit’s built-in visualization options</h1>
    <p class="normal">For the <a id="_idIndexMarker088"/>rest of this chapter, we’re going to run through the rest of the Streamlit visualization options, which are Plotly, Matplotlib, Seaborn, Bokeh, Altair, and PyDeck. </p>
    <h2 class="heading-2" id="_idParaDest-44">Plotly</h2>
    <p class="normal">Plotly is an<a id="_idIndexMarker089"/> interactive visualization library that many data <a id="_idIndexMarker090"/>scientists use to visualize data in a Jupyter notebook, either locally in the browser or even hosted on a web platform <a id="_idIndexMarker091"/>such as <strong class="keyWord">Dash</strong> (the creator of Plotly). This library is very similar to Streamlit in its intent and is primarily used for internal or external dashboards (hence, the name Dash). </p>
    <p class="normal">Streamlit allows us to call plotly graphs from within Streamlit apps using the <code class="inlineCode">st.plotly_chart()</code> function, which makes it a breeze to port any Plotly or Dash dashboards. We’ll test this out by making a histogram of the height of trees in SF, essentially the same graph that we’ve made before. The following code makes our Plotly histogram:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
st.subheader(<span class="hljs-string">'Plotly Chart'</span>)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
fig = px.histogram(trees_df[<span class="hljs-string">'dbh'</span>])
st.plotly_chart(fig)
</code></pre>
    <p class="normal">As we’ll notice, all the interactivity native to Plotly works by default in Streamlit. Particularly, the user can scroll over histogram bars and get the exact info about each bar. There are<a id="_idIndexMarker092"/> a few other useful built-in features in Plotly that readily port over to Streamlit, such<a id="_idIndexMarker093"/> as the ability to zoom in and out, download the plot as a .<strong class="keyWord">png</strong>, and select a group of data points/bars/lines. The full features can be seen in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_03_05.png"/></figure>
    <p class="packt_figref">Figure 3.5: Our first Plotly chart</p>
    <p class="normal">Now that we’re comfortable with Plotly, we can move on to other popular visualization libraries, Matplotlib and Seaborn. </p>
    <h2 class="heading-2" id="_idParaDest-45">Matplotlib and Seaborn</h2>
    <p class="normal">Earlier<a id="_idIndexMarker094"/> in this <a id="_idIndexMarker095"/>book, we<a id="_idIndexMarker096"/> learned<a id="_idIndexMarker097"/> how to use the Matplotlib and Seaborn visualization libraries inside Streamlit, so we will just go over them briefly here. There is a column called <strong class="screenText">date</strong> in the trees dataset that corresponds to the date that the tree was planted. We can use the <code class="inlineCode">datetime</code> library to figure out the age of each tree in<a id="_idIndexMarker098"/> days, and plot that histogram using Seaborn and <a id="_idIndexMarker099"/>Matplotlib, respectively. The following code creates a new column<a id="_idIndexMarker100"/> called <code class="inlineCode">age</code>, which is the difference in days between the tree planting date and today’s date, and then graphs the histogram of the age using both Seaborn and Matplotlib:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns
<span class="hljs-keyword">import</span> datetime <span class="hljs-keyword">as</span> dt
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
trees_df[<span class="hljs-string">'age'</span>] = (pd.to_datetime(<span class="hljs-string">'today'</span>) -
                   pd.to_datetime(trees_df[<span class="hljs-string">'date'</span>])).dt.days
st.subheader(<span class="hljs-string">'Seaborn Chart'</span>)
fig_sb, ax_sb = plt.subplots()
ax_sb = sns.histplot(trees_df[<span class="hljs-string">'age'</span>])
plt.xlabel(<span class="hljs-string">'Age (Days)'</span>)
st.pyplot(fig_sb)
st.subheader(<span class="hljs-string">'Matploblib Chart'</span>)
fig_mpl, ax_mpl = plt.subplots()
ax_mpl = plt.hist(trees_df[<span class="hljs-string">'age'</span>])
plt.xlabel(<span class="hljs-string">'Age (Days)'</span>)
st.pyplot(fig_mpl)
</code></pre>
    <p class="normal">In the preceding<a id="_idIndexMarker101"/> code, we defined unique subplots for each graph, created a Seaborn or Matplotlib graph for each, and then used the <code class="inlineCode">st.pyplot()</code> function to insert each graph in successive order right inside our Streamlit app. The preceding code should show an app similar to the following screenshot (I say similar because, depending on when you run this, the age of the trees will be different, as <code class="inlineCode">pd.to_datetime</code> (<code class="inlineCode">'today'</code>) will return your current date):</p>
    <figure class="mediaobject"><img alt="Figure 3.6 – Seaborn and Matplotlib histograms " src="../Images/B18444_03_06.png"/></figure>
    <p class="packt_figref">Figure 3.6: Seaborn and Matplotlib histograms</p>
    <p class="normal">Whether <a id="_idIndexMarker102"/>you <a id="_idIndexMarker103"/>use <a id="_idIndexMarker104"/>Seaborn or Matplotlib, you’ll use the <code class="inlineCode">st.pyplot()</code> function in <a id="_idIndexMarker105"/>the same way. Now that we’re more comfortable with these libraries, we can learn about another interactive visualization library – <strong class="keyWord">Bokeh</strong>. </p>
    <h2 class="heading-2" id="_idParaDest-46">Bokeh</h2>
    <p class="normal">Bokeh<a id="_idIndexMarker106"/> is <a id="_idIndexMarker107"/>another web-based interactive visualization library that also has dashboarding products built on top of it. It is a direct competitor to Plotly and is, frankly, incredibly similar in use, but it has some stylistic differences. Either way, Bokeh is an extremely popular Python visualization package that Python users may be very comfortable using. </p>
    <p class="normal">We can call Bokeh graphs using the same format as Plotly. First, we create the Bokeh graph, and then we use the <code class="inlineCode">st.bokeh_chart()</code> function to write the app to Streamlit. In Bokeh, we have to first instantiate a Bokeh figure object, and then change aspects of that figure before we can plot it out. The important lesson here is that if we change an aspect of the Bokeh figure object after we call the <code class="inlineCode">st.bokeh_chart()</code> function, we will not change the graph shown on the Streamlit app. For example, when we run the following code, we will not see a new <strong class="screenText">x</strong> axis title at all:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> bokeh.plotting <span class="hljs-keyword">import</span> figure
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
st.subheader(<span class="hljs-string">'Bokeh Chart'</span>)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
scatterplot = figure(title = <span class="hljs-string">'Bokeh Scatterplot'</span>)
scatterplot.scatter(trees_df[<span class="hljs-string">'dbh'</span>], trees_df[<span class="hljs-string">'site_order'</span>])
st.bokeh_chart(scatterplot)
scatterplot.xaxis.axis_label = <span class="hljs-string">"dbh"</span>
</code></pre>
    <p class="normal">Instead, we’ll have to switch the order of the last two lines, which will now show up on our app. We’ll add a <strong class="screenText">y</strong> axis <a id="_idIndexMarker108"/>for good measure as well: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> bokeh.plotting <span class="hljs-keyword">import</span> figure
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(<span class="hljs-string">'This app analyzes trees in San Francisco using'</span>
        <span class="hljs-string">' a dataset kindly provided by SF DPW'</span>)
st.subheader(<span class="hljs-string">'Bokeh Chart'</span>)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
scatterplot = figure(title = <span class="hljs-string">'Bokeh Scatterplot'</span>)
scatterplot.scatter(trees_df[<span class="hljs-string">'dbh'</span>], trees_df[<span class="hljs-string">'site_order'</span>])
scatterplot.yaxis.axis_label = <span class="hljs-string">"site_order"</span>
scatterplot.xaxis.axis_label = <span class="hljs-string">"dbh"</span>
st.bokeh_chart(scatterplot)
</code></pre>
    <p class="normal">The <a id="_idIndexMarker109"/>preceding code will create a Bokeh chart of <code class="inlineCode">dbh</code> versus <code class="inlineCode">site_order</code>, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 3.7 – Bokeh scatterplot " src="../Images/B18444_03_07.png"/></figure>
    <p class="packt_figref">Figure 3.7: Bokeh scatterplot</p>
    <p class="normal">Now that we have<a id="_idIndexMarker110"/> our basic <a id="_idIndexMarker111"/>Bokeh plot of <code class="inlineCode">dbh</code> by site order, on to our next visualization library – Altair!</p>
    <h2 class="heading-2" id="_idParaDest-47">Altair</h2>
    <p class="normal">We’ve <a id="_idIndexMarker112"/>already used Altair in this chapter through Streamlit<a id="_idIndexMarker113"/> functions such as <code class="inlineCode">st.line_chart()</code> and <code class="inlineCode">st.map()</code>, and directly through <code class="inlineCode">st.altair_chart()</code>, so again we’ll cover this one briefly for completeness. </p>
    <p class="normal">Because we’ve made quite a few graphs with this dataset already, why don’t we explore a new column, the <code class="inlineCode">caretaker</code> column? This bit of data defines who is in charge of the tree (public or private) and, if public, what government organization is responsible for upkeep. Thrilling!</p>
    <p class="normal">The following code groups our DataFrame by caretaker, and then uses that grouped DataFrame from within Altair:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> altair <span class="hljs-keyword">as</span> alt
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
df_caretaker = trees_df.groupby([<span class="hljs-string">'caretaker'</span>]).count()[<span class="hljs-string">'tree_id'</span>].reset_index()
df_caretaker.columns = [<span class="hljs-string">'caretaker'</span>, <span class="hljs-string">'tree_count'</span>]
fig = alt.Chart(df_caretaker).mark_bar().encode(x = <span class="hljs-string">'caretaker'</span>, y = <span class="hljs-string">'tree_count'</span>)
st.altair_chart(fig)
</code></pre>
    <p class="normal">Altair also allows us to summarize our data directly within the <strong class="screenText">y</strong> value of <code class="inlineCode">mark_bar()</code>, so we can simplify this by instead using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> altair <span class="hljs-keyword">as</span> alt
st.title(<span class="hljs-string">'SF Trees'</span>) 
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
fig = alt.Chart(trees_df).mark_bar().encode(x = <span class="hljs-string">'caretaker'</span>, y = <span class="hljs-string">'count(*):Q'</span>)
st.altair_chart(fig)
</code></pre>
    <p class="normal">The preceding <a id="_idIndexMarker114"/>code will create a Streamlit app showing the <a id="_idIndexMarker115"/>count of trees by caretaker in SF, which is shown in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" role="presentation" src="../Images/B18444_03_08.png"/></figure>
    <p class="packt_figref">Figure 3.8: Altair bar chart</p>
    <p class="normal">This should be it for traditional visualization libraries, but Streamlit also allows us to use more complex visualization libraries such as PyDeck for geographical mapping. In fact, we have already used PyDeck through the native <code class="inlineCode">st.map()</code> function and will explore this in more depth in the following section. </p>
    <h2 class="heading-2" id="_idParaDest-48">PyDeck</h2>
    <p class="normal">PyDeck<a id="_idIndexMarker116"/> is a <a id="_idIndexMarker117"/>visualization library that plots visualizations as layers on top<a id="_idIndexMarker118"/> of <strong class="keyWord">Mapbox</strong> (a mapping company with a truly exceptional free tier) maps. Both Streamlit and PyDeck have a base set of limited features available without signing up for a Mapbox account, but they greatly expand their free features when we get a <strong class="keyWord">Mapbox</strong> token, which we will do in the next section. </p>
    <h2 class="heading-2" id="_idParaDest-49">Configuration options</h2>
    <p class="normal">In order<a id="_idIndexMarker119"/> to set up your own <strong class="keyWord">Mapbox</strong> token, which is optional, first go to <a href="http://www.Mapbox.com"><span class="url">www.Mapbox.com</span></a> and <a id="_idIndexMarker120"/>sign up for an account. Once you have verified your account, you can find your token at <a href="https://www.Mapbox.com/install/"><span class="url">https://www.Mapbox.com/install/</span></a>. We will not pass our token directly to Streamlit because, otherwise, we might accidentally push it to a public GitHub repository. Instead, Streamlit has a global configuration file called <code class="inlineCode">config.toml</code>. To view our current settings, we can run the following command anywhere in the terminal: </p>
    <pre class="programlisting con"><code class="hljs-con">streamlit config show
</code></pre>
    <p class="normal">There are four methods that Streamlit offers to change our default configuration settings; I’ll show you my recommended option and one of the other options, which should provide you with the majority of the use cases. If you find these options insufficient, the Streamlit documentation (<a href="https://docs.streamlit.io/library/advanced-features/configuration"><span class="url">https://docs.streamlit.io/library/advanced-features/configuration</span></a>) goes over all four options in great detail.</p>
    <p class="normal">The first option is to set global configuration options by directly editing the <code class="inlineCode">config.toml</code> file. We can edit the file directly by opening it in our text editor. The following command will open the file in VSCode. For other text editors (such as Vim and Atom), replace <code class="inlineCode">code</code> with the appropriate command or open the file directly from the text editor:</p>
    <pre class="programlisting con"><code class="hljs-con">code ~/.streamlit/config.toml
</code></pre>
    <p class="normal">If this fails, it likely means that we do not have the file generated already. To create our own file, we can run the following command: </p>
    <pre class="programlisting con"><code class="hljs-con">touch ~/.streamlit/config.toml
</code></pre>
    <p class="normal">Inside this file, you can either copy and paste the contents of <code class="inlineCode">'streamlit config show'</code>, or choose to start from scratch. Either one should be fine! Now, open the file in VS Code so that we can view and edit any of the config options directly. Make sure that there is a section in your config file that has your Mapbox token, which looks like this: </p>
    <pre class="programlisting code"><code class="hljs-code">[mapbox] 
token = <span class="hljs-string">"123my_large_mapbox_token456"</span>
</code></pre>
    <p class="normal">Of course, your<a id="_idIndexMarker121"/> token will look different than the one I clearly made up! This option is great for a config option such as a Mapbox token, as I will never have multiple Mapbox accounts with multiple tokens. </p>
    <p class="normal">However, some Streamlit apps may want to use, for example, different ports than the default <strong class="screenText">8501 serverPort</strong>. It would not make sense to change a global option for a project-specific change, which leads us to the second option for configuration changes. </p>
    <p class="normal">The second option is to create and edit a project-specific <code class="inlineCode">config.toml</code> file. Our previous config sets our default config options, while this option is specific to each Streamlit app. Here is where our individual project folders within the <code class="inlineCode">streamlit_apps</code> folder come in handy!</p>
    <p class="normal">Broadly speaking, we will do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Check our current working directory.</li>
      <li class="numberedList">Make a config file for our project.</li>
      <li class="numberedList">Use the config file within PyDeck.</li>
    </ol>
    <p class="normal">Our first step is to make sure our current working directory is the <code class="inlineCode">trees_app</code> folder by running the <code class="inlineCode">pwd</code> command in our terminal, which will show our current working directory and should end with <code class="inlineCode">trees_app</code> (for example, mine looks like <code class="inlineCode">Users/tyler/Documents/streamlit_apps/trees_app</code>).</p>
    <p class="normal">Now, we need to make a config file just for our project. First, we will make a folder called <code class="inlineCode">.streamlit</code>, and then we will repeat the Mac/Linux shortcut we used above:</p>
    <pre class="programlisting con"><code class="hljs-con">mkdir .streamlit
touch .streamlit/config.toml 
</code></pre>
    <p class="normal">We can then edit our config options just as we did before, but this will only be applicable to our Streamlit apps when we run Streamlit from our directory. </p>
    <p class="normal">Now, finally, we can go back to PyDeck graphing. Our first effort is going to be getting a base map of SF, which has a city center of <code class="inlineCode">37.77, -122.4</code>. We can do this using the following code, which first defines the initial state (where we want to start viewing the map), and <a id="_idIndexMarker122"/>then calls <code class="inlineCode">st.pydeck_chart()</code> using that initial state:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> pydeck <span class="hljs-keyword">as</span> pdk 
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'</span><span class="hljs-string">trees.csv'</span>)
sf_initial_view = pdk.ViewState(
     latitude=<span class="hljs-number">37.77</span>,
     longitude=-<span class="hljs-number">122.4</span>
     )
st.pydeck_chart(pdk.Deck(
     initial_view_state=sf_initial_view
     ))
</code></pre>
    <p class="normal">This code will produce a map of SF, which we can use to layer on data points. Notice a couple of things here. First, the black default map may be difficult to see, and second, we need to spend time zooming into SF to get the view that we need. We can fix both these items by using the defaults suggested in the Streamlit documentation (<a href="https://docs.streamlit.io/"><span class="url">https://docs.streamlit.io/</span></a>), as seen in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> pydeck <span class="hljs-keyword">as</span> pdk
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
sf_initial_view = pdk.ViewState(
     latitude=<span class="hljs-number">37.77</span>,
     longitude=-<span class="hljs-number">122.4</span>,
     zoom=<span class="hljs-number">9</span>
     )
st.pydeck_chart(pdk.Deck(
     map_style=<span class="hljs-string">'mapbox://styles/mapbox/light-v9'</span>,
     initial_view_state=sf_initial_view,
     ))
</code></pre>
    <p class="normal">The <a id="_idIndexMarker123"/>preceding code should create a map that looks like the following screenshot:</p>
    <figure class="mediaobject"><img alt="Figure 3.9 – PyDeck mapping: SF base map " src="../Images/B18444_03_09.png"/></figure>
    <p class="packt_figref">Figure 3.9: PyDeck mapping: SF base map</p>
    <p class="normal">This is exactly what we want! We can see the entire <strong class="screenText">SF Bay Area</strong>, and now we need to add our layer of trees. The PyDeck library has tooltips for interactivity, which do not deal well with <code class="inlineCode">null</code> values in our dataset, so we will remove <code class="inlineCode">null</code> values before we map these points in the following code. We’ll also increase the <code class="inlineCode">zoom</code> value to <code class="inlineCode">11</code> so that we can see each<a id="_idIndexMarker124"/> point better: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> pydeck <span class="hljs-keyword">as</span> pdk
st.title(<span class="hljs-string">'SF Trees'</span>) 
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
trees_df.dropna(how=<span class="hljs-string">'any'</span>, inplace=<span class="hljs-literal">True</span>)
sf_initial_view = pdk.ViewState(
     latitude=<span class="hljs-number">37.77</span>,
     longitude=-<span class="hljs-number">122.4</span>,
     zoom=<span class="hljs-number">11</span>
     )
sp_layer = pdk.Layer(
     <span class="hljs-string">'ScatterplotLayer'</span>,
     data = trees_df,
     get_position = [<span class="hljs-string">'longitude'</span>, <span class="hljs-string">'latitude'</span>],
     get_radius=<span class="hljs-number">30</span>)
st.pydeck_chart(pdk.Deck(
     map_style=<span class="hljs-string">'mapbox://styles/mapbox/light-v9'</span>,
     initial_view_state=sf_initial_view,
     layers = [sp_layer]
     ))
</code></pre>
    <p class="normal">The best values for both the <code class="inlineCode">zoom</code> and <code class="inlineCode">radius</code> parameters are dependent on your visualization preferences. Try a few options out to see what looks the best. The preceding code will make the following map: </p>
    <figure class="mediaobject"><img alt="Figure 3.10 – Mapping SF trees  " src="../Images/B18444_03_10.png"/></figure>
    <p class="packt_figref">Figure 3.10: Mapping SF trees</p>
    <p class="normal">As with previous <a id="_idIndexMarker125"/>maps, this is interactive by default, so we can zoom into different parts of SF to see where the places with the highest tree density are. For our next change to this map, we are going to add another layer, this time hexagons, which will be colored based on the density of the trees in SF. We can use the same code as above but change the scatterplot layer to a hexagon layer. We also will include the option to have the hexagon extrude vertically, making this graph more three-dimensional, which isn’t necessary but is certainly a fun visualization style.</p>
    <p class="normal">Our last change is to change the pitch or the angle at which we are viewing the map. The default pitch, as we can see, is nearly directly down on the city, which will not work if we try to view vertical hexagons on our map. The following code implements each one of these changes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> pydeck <span class="hljs-keyword">as</span> pdk
st.title(<span class="hljs-string">'SF Trees'</span>)
st.write(
    <span class="hljs-string">"""This app analyzes trees in San Francisco using</span>
<span class="hljs-string">    a dataset kindly provided by SF DPW"""</span>
)
trees_df = pd.read_csv(<span class="hljs-string">'trees.csv'</span>)
trees_df.dropna(how=<span class="hljs-string">'any'</span>, inplace=<span class="hljs-literal">True</span>)
sf_initial_view = pdk.ViewState(
     latitude=<span class="hljs-number">37.77</span>,
     longitude=-<span class="hljs-number">122.4</span>,
     zoom=<span class="hljs-number">11</span>,
     pitch=<span class="hljs-number">30</span>
     )
hx_layer = pdk.Layer(
     <span class="hljs-string">'HexagonLayer'</span>,
     data = trees_df,
     get_position = [<span class="hljs-string">'longitude'</span>, <span class="hljs-string">'latitude'</span>],
     radius=<span class="hljs-number">100</span>,
     extruded=<span class="hljs-literal">True</span>)
st.pydeck_chart(pdk.Deck(
     map_style=<span class="hljs-string">'mapbox://styles/mapbox/light-v9'</span>,
     initial_view_state=sf_initial_view,
     layers = [hx_layer]
     ))
</code></pre>
    <p class="normal">As with the <a id="_idIndexMarker126"/>previous map, the optimal radius and pitch parameters will change based on your visualizations. Try changing each one of these around a few times to see whether you can get the hang of it! The preceding code will produce the following app:</p>
    <figure class="mediaobject"><img alt="Figure 3.11 – Final San Francisco Trees map " src="../Images/B18444_03_11.png"/></figure>
    <p class="packt_figref">Figure 3.11: Final SF Trees map</p>
    <p class="normal">From this <a id="_idIndexMarker127"/>screenshot, we can see that PyDeck creates darker circles where there exists a higher density of trees in SF. We can observe from this many interesting details, such as the fact that the dataset seems to be missing trees from the famous Golden Gate Park on the west side of the city, and that the area around the Golden Gate Bridge also seems to have very few trees in the dataset.</p>
    <h1 class="heading-1" id="_idParaDest-50">Summary</h1>
    <p class="normal">After this chapter, you hopefully have a solid understanding of how to leverage several incredible open-source Python visualization libraries from within Streamlit. </p>
    <p class="normal">Let’s recap. First, we learned how to use the default visualization options, such as <code class="inlineCode">st.line_chart()</code> and <code class="inlineCode">st.map()</code>, and then we dove into interactive libraries such as Plotly, mapping libraries such as PyDeck, and everything in between.</p>
    <p class="normal">In our next chapter, we will move on to cover how to use machine learning and AI with Streamlit.</p>
    <h1 class="heading-1">Learn more on Discord</h1>
    <p class="normal">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/sl"><span class="url">https://packt.link/sl</span></a></p>
    <p class="normal"><img alt="" role="presentation" src="../Images/QR_Code13440134443835796.png"/></p>
  </div>
</body></html>