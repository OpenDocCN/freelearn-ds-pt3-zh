["```py\nimport sys\nprint(sys.version)\nprint(64 if sys.maxsize > 2**32 else 32)\n\n```", "```py\n    [build]\n    compiler = mingw32\n    ```", "```py\n    call \"C:\\Program Files\\Microsoft SDKs\\Windows\\v7.0\\Bin\\SetEnv.Cmd\" /x64 /release\n    set DISTUTILS_USE_SDK=1\n\n    ```", "```py\n    In [1]: import numpy as np\n    In [2]: size = 200\n            iterations = 100\n    ```", "```py\n    In [3]: def mandelbrot_python(m, size, iterations):\n                for i in range(size):\n                    for j in range(size):\n                        c = -2 + 3./size*j + 1j*(1.5-3./size*i)\n                        z = 0\n                        for n in range(iterations):\n                            if np.abs(z) <= 10:\n                                z = z*z + c\n                                m[i, j] = n\n                            else:\n                                break\n    ```", "```py\n    In [4]: m = np.zeros((size, size))\n            mandelbrot_python(m, size, iterations)\n    In [5]: import matplotlib.pyplot as plt\n            %matplotlib inline\n            plt.imshow(np.log(m), cmap=plt.cm.hot)\n            plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [6]: %%timeit m = np.zeros((size, size))\n            mandelbrot_python(m, size, iterations)\n    1 loops, best of 1: 6.18 s per loop\n    ```", "```py\n    In [7]: import numba\n            from numba import jit, complex128\n    ```", "```py\n    In [8]: @jit(locals=dict(c=complex128, z=complex128))\n            def mandelbrot_numba(m, size, iterations):\n                for i in range(size):\n                    for j in range(size):\n                        c = -2 + 3./size*j + 1j*(1.5-3./size*i)\n                        z = 0\n                        for n in range(iterations):\n                            if np.abs(z) <= 10:\n                                z = z*z + c\n                                m[i, j] = n\n                            else:\n                                break\n    ```", "```py\n    In [10]: %%timeit m = np.zeros((size, size))\n             mandelbrot_numba(m, size, iterations)\n    1 loops, best of 10: 44.8 ms per loop\n    ```", "```py\nIn [1]: import numpy as np\n        import matplotlib.pyplot as plt\n        %matplotlib inline\nIn [2]: def initialize(size):\n            x, y = np.meshgrid(np.linspace(-2, 1, size),\n                               np.linspace(-1.5, 1.5, size))\n            c = x + 1j*y\n            z = c.copy()\n            m = np.zeros((size, size))\n            return c, z, m\nIn [3]: size = 200\n        iterations = 100\n\n        def mandelbrot_numpy(c, z, m, iterations):\n            for n in range(iterations):\n                indices = np.abs(z) <= 10\n                z[indices] = z[indices]**2 + c[indices]\n                m[indices] = n\nIn [4]: %%timeit -n1 -r10 c, z, m = initialize(size)\n        mandelbrot_numpy(c, z, m, iterations)\n1 loops, best of 10: 245 ms per loop\n```", "```py\n    In [1]: import numpy as np\n            import numexpr as ne\n    ```", "```py\n    In [2]: x, y, z = np.random.rand(3, 1000000)\n    ```", "```py\n    In [3]: %timeit x + (y**2 + (z*x + 1)*3)\n    10 loops, best of 3: 48.1 ms per loop\n    ```", "```py\n    In [4]: %timeit ne.evaluate('x + (y**2 + (z*x + 1)*3)')\n    100 loops, best of 3: 11.5 ms per loop\n    ```", "```py\n    In [5]: ne.ncores\n    Out[5]: 4\n    In [6]: for i in range(1, 5):\n                ne.set_num_threads(i)\n                %timeit ne.evaluate('x + (y**2 + (z*x + 1)*3)')\n    10 loops, best of 3: 19.4 ms per loop\n    10 loops, best of 3: 14 ms per loop\n    10 loops, best of 3: 12.8 ms per loop\n    10 loops, best of 3: 11.5 ms per loop\n    ```", "```py\n    In [1]: %%writefile mandelbrot.c\n\n            // Needed when creating a DLL.\n            #define EXPORT __declspec(dllexport)\n\n            #include \"stdio.h\"\n            #include \"stdlib.h\"\n\n            // This function will be available in the DLL.\n            EXPORT void __stdcall mandelbrot(int size,\n                                             int iterations,\n                                             int *col)\n            {\n                // Variable declarations.\n                int i, j, n, index;\n                double cx, cy;\n                double z0, z1, z0_tmp, z0_2, z1_2;\n\n                // Loop within the grid.\n                for (i = 0; i < size; i++)\n                {\n                    cy = -1.5 + (double)i / size * 3;\n                    for (j = 0; j < size; j++)\n                    {\n                        // We initialize the loop of the \n                        // system.\n                        cx = -2.0 + (double)j / size * 3;\n                        index = i * size + j;\n                        // Let's run the system.\n                        z0 = 0.0;\n                        z1 = 0.0;\n                        for (n = 0; n < iterations; n++)\n                        {\n                            z0_2 = z0 * z0;\n                            z1_2 = z1 * z1;\n                            if (z0_2 + z1_2 <= 100)\n                            {\n                                // Update the system.\n                                z0_tmp = z0_2 - z1_2 + cx;\n                                z1 = 2 * z0 * z1 + cy;\n                                z0 = z0_tmp;\n                                col[index] = n;\n                            }\n                            else\n                            {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n    ```", "```py\n    In [2]: !cl /LD mandelbrot.c\n    /out:mandelbrot.dll\n    Creating library mandelbrot.lib and object mandelbrot.exp\n    ```", "```py\n    In [3]: import ctypes\n    In [4]: # Load the DLL file in Python.\n            lb = ctypes.CDLL('mandelbrot.dll')\n            lib = ctypes.WinDLL(None, handle=lb._handle)\n            # Access the mandelbrot function.\n            mandelbrot = lib.mandelbrot\n    ```", "```py\n    In [5]: from numpy.ctypeslib import ndpointer\n    In [6]: # Define the types of the output and arguments.\n            mandelbrot.restype = None\n            mandelbrot.argtypes = [ctypes.c_int, ctypes.c_int,\n                                   ndpointer(ctypes.c_int)]\n    ```", "```py\n    In [7]: import numpy as np\n            # We initialize an empty array.\n            size = 200\n            iterations = 100\n            col = np.empty((size, size), dtype=np.int32)\n            # We execute the C function.\n            mandelbrot(size, iterations, col)\n    In [8]: %timeit mandelbrot(size, iterations, col)\n    100 loops, best of 3: 12.5 ms per loop\n    ```", "```py\n    In [9]: from ctypes.wintypes import HMODULE\n            ctypes.windll.kernel32.FreeLibrary.argtypes = [HMODULE]\n            ctypes.windll.kernel32.FreeLibrary(lb._handle)\n    ```", "```py\n    In [6]: %load_ext cythonmagic\n    ```", "```py\n    In [6]: %%cython\n            import numpy as np\n            def mandelbrot_cython(m, size, iterations):\n                # The exact same content as in \n                # mandelbrot_python (first recipe of \n                # this chapter).\n    ```", "```py\n    In [7]: %%timeit -n1 -r1 m = np.zeros((size, size),\n                                          dtype=np.int32)\n            mandelbrot_cython(m, size, iterations)\n    1 loops, best of 1: 5.7 s per loop\n    ```", "```py\n    In [8]: %%cython\n            import numpy as np\n            def mandelbrot_cython(int[:,::1] m,\n                                  int size,\n                                  int iterations):\n                cdef int i, j, n\n                cdef complex z, c\n                for i in range(size):\n                    for j in range(size):\n                        c = -2 + 3./size*j + 1j*(1.5-3./size*i)\n                        z = 0\n                        for n in range(iterations):\n                            if z.real**2 + z.imag**2 <= 100:\n                                z = z*z + c\n                                m[i, j] = n\n                            else:\n                                break\n    ```", "```py\n    In [9]: %%timeit -n1 -r1 m = np.zeros((size, size),\n                                          dtype=np.int32)\n            mandelbrot_cython(m, size, iterations)\n    1 loops, best of 1: 230 ms per loop\n    ```", "```py\n    from distutils.core import setup\n    from distutils.extension import Extension\n    from Cython.Distutils import build_ext\n\n    setup(\n        cmdclass = {'build_ext': build_ext},\n        ext_modules = [Extension(\"mandelbrot\",\n                                 [\"mandelbrot.pyx\"])]\n    )\n    ```", "```py\n    In [3]: !python setup.py build_ext --inplace\n    running build_ext\n    cythoning mandelbrot.pyx to mandelbrot.c\n    building 'mandelbrot' extension\n    ```", "```py\n    In [4]: !dir mandelbrot.*\n    mandelbrot.c\n    mandelbrot.pyd\n    mandelbrot.pyx\n    ```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n    In [2]: %matplotlib inline\n    In [3]: w, h = 200, 200  # Size of the window in pixels.\n    ```", "```py\n    def normalize(x):\n        # This function normalizes a vector.\n        x /= np.linalg.norm(x)\n        return x\n    ```", "```py\n    def intersect_sphere(O, D, S, R):\n        # Return the distance from O to the intersection\n        # of the ray (O, D) and the sphere (S, R), or\n        # +inf if there is no intersection.\n        # O and S are 3D points, D (direction) is a\n        # normalized vector, R is a scalar.\n        a = np.dot(D, D)\n        OS = O - S\n        b = 2 * np.dot(D, OS)\n        c = np.dot(OS, OS) - R*R\n        disc = b*b - 4*a*c\n        if disc > 0:\n            distSqrt = np.sqrt(disc)\n            q = (-b - distSqrt) / 2.0 if b < 0 \\\n                else (-b + distSqrt) / 2.0\n            t0 = q / a\n            t1 = c / q\n            t0, t1 = min(t0, t1), max(t0, t1)\n            if t1 >= 0:\n                return t1 if t0 < 0 else t0\n        return np.inf\n    ```", "```py\n     def trace_ray(rayO, rayD):\n        # Find first point of intersection with the scene.\n        t = intersect_sphere(rayO, rayD, position, radius)\n        # No intersection?\n        if t == np.inf:\n            return\n        # Find the point of intersection on the object.\n        M = rayO + rayD * t\n        N = normalize(M - position)\n        toL = normalize(L - M)\n        toO = normalize(O - M)\n        # Ambient color.\n        col = ambient\n        # Diffuse color.\n        col += diffuse * max(np.dot(N, toL), 0) * color\n        # Specular color.\n        col += specular_c * color_light * \\\n            max(np.dot(N, normalize(toL + toO)), 0) \\\n               ** specular_k\n        return col\n    ```", "```py\n    def run():\n        img = np.zeros((h, w, 3))\n        # Loop through all pixels.\n        for i, x in enumerate(np.linspace(-1.,1.,w)):\n            for j, y in enumerate(np.linspace(-1.,1.,h)):\n                # Position of the pixel.\n                Q[0], Q[1] = x, y\n                # Direction of the ray going through the\n                # optical center.\n                D = normalize(Q - O)\n                depth = 0\n                rayO, rayD = O, D\n                # Launch the ray and get the\n                # color of the pixel.\n                col = trace_ray(rayO, rayD)\n                if col is None:\n                    continue\n                img[h - j - 1, i, :] = np.clip(col, 0, 1)\n        return img\n    ```", "```py\n    In [4]: # Sphere properties.\n            position = np.array([0., 0., 1.])\n            radius = 1.\n            color = np.array([0., 0., 1.])\n            diffuse = 1.\n            specular_c = 1.\n            specular_k = 50\n\n            # Light position and color.\n            L = np.array([5., 5., -10.])\n            color_light = np.ones(3)\n            ambient = .05\n\n            # Camera.\n            O = np.array([0., 0., -1.])  # Position.\n            Q = np.array([0., 0., 0.])  # Pointing to.\n    ```", "```py\n    In [5]: img = run()\n    In [6]: plt.imshow(img)\n            plt.xticks([]); plt.yticks([])\n    ```", "```py\n    In [7]: %timeit run()\n    1 loops, best of 1: 3.58 s per loop\n    ```", "```py\n    import numpy as np\n    cimport numpy as np\n    DBL = np.double\n    ctypedef np.double_t DBL_C\n    ```", "```py\n    from libc.math cimport sqrt\n    cdef normalize(np.ndarray[DBL_C, ndim=1] x):\n        cdef double n\n        n = sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2])\n        x[0] /= n\n        x[1] /= n\n        x[2] /= n\n        return x\n    ```", "```py\n    cdef tuple add(tuple x, tuple y):\n        return (x[0]+y[0], x[1]+y[1], x[2]+y[2])\n    ```", "```py\n    cdef struct Vec3:\n        double x, y, z\n    ```", "```py\n    cdef Vec3 vec3(double x, double y, double z):\n        cdef Vec3 v\n        v.x = x\n        v.y = y\n        v.z = z\n        return v\n    ```", "```py\n    cdef Vec3 add(Vec3 u, Vec3 v):\n        return vec3(u.x + v.x, u.y + v.y, u.z + v.z)\n    ```", "```py\n    from cython.parallel import prange\n    ```", "```py\n    cdef Vec3 add(Vec3 x, Vec3 y) nogil:\n        return vec3(x.x + y.x, x.y + y.y, x.z + y.z)\n    ```", "```py\n    with nogil:\n        for i in prange(w):\n            # ...\n    ```", "```py\n    In [1]: import pycuda.driver as cuda\n            import pycuda.autoinit\n            from pycuda.compiler import SourceModule\n            import numpy as np\n    ```", "```py\n    In [2]: size = 200\n            iterations = 100\n            col = np.empty((size, size), dtype=np.int32)\n    ```", "```py\n    In [3]: col_gpu = cuda.mem_alloc(col.nbytes)\n    ```", "```py\n    In [4]: code = \"\"\"\n            __global__ void mandelbrot(int size,\n                                       int iterations,\n                                       int *col) {\n                // Get the row and column of the thread.\n                int i = blockIdx.y * blockDim.y + threadIdx.y;\n                int j = blockIdx.x * blockDim.x + threadIdx.x;\n                int index = i * size + j;\n\n                // Declare and initialize the variables.\n                double cx, cy;\n                double z0, z1, z0_tmp, z0_2, z1_2;\n                cx = -2.0 + (double)j / size * 3;\n                cy = -1.5 + (double)i / size * 3;\n\n                // Main loop.\n                z0 = z1 = 0.0;\n                for (int n = 0; n < iterations; n++)\n                {\n                    z0_2 = z0 * z0;\n                    z1_2 = z1 * z1;\n                    if (z0_2 + z1_2 <= 100)\n                    {\n                        // Need to update both z0 and z1,\n                        // hence the need for z0_tmp.\n                        z0_tmp = z0_2 - z1_2 + cx;\n                        z1 = 2 * z0 * z1 + cy;\n                        z0 = z0_tmp;\n                        col[index] = n;\n                    }\n                    else break;\n                }\n            }\n            \"\"\"\n    ```", "```py\n    In [5]: prg = SourceModule(code)\n            mandelbrot = prg.get_function(\"mandelbrot\")\n    ```", "```py\n    In [6]: block_size = 10\n            block = (block_size, block_size, 1)\n            grid = (size // block_size, size // block_size, 1)\n    ```", "```py\n    In [7]: mandelbrot(np.int32(size),\n                       np.int32(iterations),\n                       col_gpu,\n                       block=block, grid=grid)\n    ```", "```py\n    In [8]: cuda.memcpy_dtoh(col, col_gpu)\n    ```", "```py\n    In [1]: import pyopencl as cl\n            import numpy as np\n    ```", "```py\n    In [2]: mf = cl.mem_flags\n    ```", "```py\n    In [3]: ctx = cl.create_some_context()\n            queue = cl.CommandQueue(ctx)\n    ```", "```py\n    In [4]: size = 200\n            iterations = 100\n            col = np.empty((size, size), dtype=np.int32)\n    ```", "```py\n    In [5]: col_buf = cl.Buffer(ctx,\n                                mf.WRITE_ONLY,\n                                col.nbytes)\n    ```", "```py\n    In [6]: code = \"\"\"\n            __kernel void mandelbrot(int size,\n                                     int iterations,\n                                     global int *col)\n            {\n                // Get the row and column index of the thread.\n                int i = get_global_id(1);\n                int j = get_global_id(0);\n                int index = i * size + j;\n\n                // Declare and initialize the variables.\n                double cx, cy;\n                double z0, z1, z0_tmp, z0_2, z1_2;\n                cx = -2.0 + (double)j / size * 3;\n                cy = -1.5 + (double)i / size * 3;\n\n                // Main loop.\n                z0 = z1 = 0.0;\n                for (int n = 0; n < iterations; n++)\n                {\n                    z0_2 = z0 * z0;\n                    z1_2 = z1 * z1;\n                    if (z0_2 + z1_2 <= 100)\n                    {\n                        // Need to update both z0 and z1.\n                        z0_tmp = z0_2 - z1_2 + cx;\n                        z1 = 2 * z0 * z1 + cy;\n                        z0 = z0_tmp;\n                        col[index] = n;\n                    }\n                    else break;\n                }\n            }\n            \"\"\"\n    ```", "```py\n    In [7]: prg = cl.Program(ctx, code).build()\n    Build on <pyopencl.Device 'Intel(R) Core(TM) i3-2365M CPU @ 1.40GHz' on 'Intel(R) OpenCL' at 0x765b188> succeeded.\n    ```", "```py\n    In [8]: prg.mandelbrot(queue, col.shape, None, np.int32(size), np.int32(iterations), col_buf).wait()\n    ```", "```py\n    In [9]: cl.enqueue_copy(queue, col, col_buf)\n    ```", "```py\n    In [2]: from IPython.parallel import Client\n            rc = Client()\n    ```", "```py\n    In [3]: rc.ids\n    Out[3]: [0, 1, 2, 3]\n    ```", "```py\n    In [4]: %%px\n            import os\n            print(\"Process {0:d}.\".format(os.getpid()))\n    [stdout:0] Process 2988.\n    [stdout:1] Process 5192.\n    [stdout:2] Process 4484.\n    [stdout:3] Process 1360.\n    ```", "```py\n    In [5]: %%px -t 1,2\n            # The os module has already been imported in\n            # the previous cell.\n            print(\"Process {0:d}.\".format(os.getpid()))\n    [stdout:1] Process 5192.\n    [stdout:2] Process 4484.\n    ```", "```py\n    In [6]: %%px -a\n            import time\n            time.sleep(5)\n    Out[6]: <AsyncResult: execute>\n    ```", "```py\n    In [7]: print(_.elapsed, _.ready())\n    (0.061, False)\n    ```", "```py\n    In [8]: %pxresult\n    In [9]: print(_.elapsed, _.ready())\n    (5.019, True)\n    ```", "```py\n    In [10]: v = rc[:]\n             res = v.map(lambda x: x*x, range(10))\n    In [11]: print(res.get())\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n    ```", "```py\n    with view.temp_flags(after=[arB, arC]):\n        arA = view.apply_async(f)\n    ```", "```py\n    In [1]: import time\n            import sys\n            from IPython import parallel\n            from IPython.display import clear_output, display\n            from IPython.html import widgets\n    ```", "```py\n    In [2]: rc = parallel.Client()\n    ```", "```py\n    In [3]: view = rc.load_balanced_view()\n    ```", "```py\n    In [4]: def f(x):\n                import time\n                time.sleep(.1)\n                return x*x\n    ```", "```py\n    In [5]: numbers = list(range(100))\n    ```", "```py\n    In [6]: ar = view.map_async(f, numbers)\n    ```", "```py\n    In [7]: ar.metadata[0]\n    Out[7]: {\n     'execute_result': None,\n     'engine_id': None,\n    ...\n     'submitted': datetime.datetime(2014, 1, 1, 10, 30, 38, 9487),\n     'follow': None}\n    ```", "```py\n    In [8]: for _ in ar:\n                print(_, end=', ')\n    0, 1, 4,..., 9409, 9604, 9801,\n    ```", "```py\n    In [9]: def progress_bar(ar):\n                # We create a progress bar.\n                w = widgets.IntProgressWidget()\n                # The maximum value is the number of tasks.\n                w.max = len(ar.msg_ids)\n                # We display the widget in the output area.\n                display(w)\n                # Repeat every second:\n                while not ar.ready():\n                    # Update the widget's value with the\n                    # number of tasks that have finished\n                    # so far.\n                    w.value = ar.progress\n                    time.sleep(1)\n                w.value = w.max\n    In [10]: ar = view.map_async(f, numbers)\n    In [11]: progress_bar(ar)\n    ```", "```py\n    In [12]: %%px -t 1\n             %qtconsole\n    ```", "```py\nconda install mpich2\nconda install mpi4py\n\n```", "```py\n    In [1]: !ipython profile create --parallel --profile=mpi\n    ```", "```py\n    In [2]: import numpy as np\n            from IPython.parallel import Client\n    In [3]: c = Client(profile='mpi')\n    ```", "```py\n    In [4]: view = c[:]\n    ```", "```py\n    In [5]: view.scatter('a', np.arange(16., dtype='float'))\n    Out[5]: <AsyncResult: scatter>\n    ```", "```py\n    In [6]: %%px\n            from mpi4py import MPI\n            import numpy as np\n            print MPI.COMM_WORLD.allreduce(np.sum(a), op=MPI.SUM)\n    [stdout:0] 120.0\n    [stdout:1] 120.0\n    ```", "```py\n    In [1]: println(\"Hello world!\")\n    Hello world!\n    ```", "```py\n    In [2]: f(z, c) = z.*z .+ c\n    Out[2]: f (generic function with 1 method)\n    ```", "```py\n    In [3]: f(2.0 + 1.0im, 1.0)\n    Out[3]: 4.0 + 4.0im\n    ```", "```py\n    In [4]: z = [-1.0 - 1.0im  1.0 - 1.0im;\n                 -1.0 + 1.0im  1.0 + 1.0im]\n    Out[4]: 2x2 Array{Complex{Float64},2}:\n     -1.0-1.0im  1.0-1.0im\n     -1.0+1.0im  1.0+1.0im\n    ```", "```py\n    In [5]: z[1,end]\n    Out[5]: 1.0 - 1.0im\n    ```", "```py\n    In [6]: f(z, 0)\n    Out[6]: 2x2 Array{Complex{Float64},2}:\n     0.0+2.0im  0.0-2.0im\n     0.0-2.0im  0.0+2.0im\n    ```", "```py\n    In [7]: function julia(z, c; maxiter=200)\n                for n = 1:maxiter\n                    if abs2(z) > 4.0\n                        return n-1\n                    end\n                    z = f(z, c)\n                end\n                return maxiter\n            end\n    Out[7]: julia (generic function with 1 method)\n    ```", "```py\n    In [8]: Pkg.add(\"PyCall\")\n            using PyCall\n    ```", "```py\n    In [9]: @pyimport numpy as np\n    ```", "```py\n    In [10]: z = np.linspace(-1., 1., 100)\n    Out[10]: 100-element Array{Float64,1}:\n     -1.0     \n     -0.979798\n    ...\n      0.979798\n      1.0\n    ```", "```py\n    In [11]: m = [julia(z[i], 0.5) for i=1:100]\n    Out[11]: 100-element Array{Int64,1}:\n     2\n    ...\n     2\n    ```", "```py\n    In [12]: Pkg.add(\"Gadfly\")\n             using Gadfly \n    In [13]: plot(x=1:100, y=m, Geom.point, Geom.line)\n    Out[13]: Plot(...)\n    ```", "```py\n    In [14]: @time m = [julia(complex(r, i), complex(-0.06, 0.67)) \n                        for i = 1:-.001:-1,\n                            r = -1.5:.001:1.5];\n    elapsed time: 0.881234749 seconds (48040248 bytes allocated)\n    ```", "```py\n    In [15]: Pkg.add(\"PyPlot\")\n             using PyPlot\n    In [16]: imshow(m, cmap=\"RdGy\", \n                    extent=[-1.5, 1.5, -1, 1]);\n    ```"]