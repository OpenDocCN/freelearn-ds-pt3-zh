- en: Classes
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, when we write ![](img/b1869c68-1acd-4903-8bde-c96d445836db.png),
    we refer to a mathematical object for which we know many methods from elementary
    calculus. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: We might want to evaluate [![](img/a629d68f-bc0d-4504-922b-d25a0ffd394a.png)]
    at [![](img/b8a07b49-896f-4d82-b58b-93e1134b360f.png)], that is, compute ![](img/5566ed05-3ece-4bd8-9e92-47a924e36044.png),
    which returns a real number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to compute its derivative, which gives us another mathematical
    object, **cos**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to compute the first three coefficients of its Taylor polynomial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods may be applied not only to **sin** but also to other sufficiently
    smooth functions. There are, however, other mathematical objects, for example,
    the number *5,* for which these methods would make no sense.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that have the same methods are grouped together in abstract classes,
    for example, functions. Every statement and every method that can be applied to
    functions in general applies in particular to **sin** or **cos**.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples for such classes might be a rational number, for which a denominator
    and numerator method exist; an interval, which has a left and right boundary method;
    an infinite sequence, for which we can ask whether it has a limit, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, ![](img/796b437a-5221-4fa9-af25-8c1efb98be48.png) is called an
    *instance* of the class. The mathematical phrase *Let g be a function...* is,
    in this context, called **instantiation**. Here, ![](img/b441010f-f760-498d-83b1-19bbbacf79ca.png)
    is the name of the function, one of many *attributes* that can be assigned to
    it. Another attribute might be its domain.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical object [![](img/792a1325-520d-43b7-a0e4-3bab90b0f537.png)]
    is just like the sine function. Every function method applies to ![](img/a10ad167-28bd-4fc6-9c5f-8a658b818ccb.png),
    but we can also define special methods for ![](img/5b332529-ae82-48ca-86f5-8858c45f7ae7.png).
    We might, for instance, ask for ![](img/4d4879f1-5b0b-4547-8323-dc47f88332e5.png)*'*s
    coefficients. These methods can be used to define the class of polynomials. As
    polynomials are functions, they additionally *inherit* all methods of the function
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, we often use the same operator symbol for completely different
    operations. For instance, in ![](img/b3530656-c09b-4bda-87e2-34e9dac3fec7.png)
    and ![](img/23af4c8e-d3ba-4c2a-b5be-9d1e88f67112.png), the operator symbol `+`
    has different meanings. By using the same symbol, similarities to corresponding
    mathematical operations are emphasized. We have introduced these terms from object-oriented
    programming by applying them to mathematical examples, such as classes, instance
    and instantiation, inheritance, methods, attributes, and operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bound and unbound methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class attributes and class methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclasses and inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes as decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will show how these concepts are used in Python and start
    with some fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Introduction to classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section introduces the most common terms of classes and their realization
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: First, we set up a guiding example.
  prefs: []
  type: TYPE_NORMAL
- en: '8.1.1 A guiding example: Rational numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will illustrate the concept of classes with the example of rational numbers,
    that is, numbers of the form ![](img/66f8f5f2-953a-4695-ba5d-a6ed3021626e.png),
    where ![](img/830cf1ec-1cf4-43f7-9771-6b50c9b2ed63.png) and ![](img/99434b20-95a8-41b5-b0fa-79fbd50f80f7.png)
    are integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure gives an example of a class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cecb5307-8e17-4e70-92d6-ac4927583d45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Example of a class declaration'
  prefs: []
  type: TYPE_NORMAL
- en: We use rational numbers here only as an example of the class concept. For future
    work in Python with rational numbers, use the Python module `fractions`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 Defining a class and making an instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition of a class is made by a block command with the keyword `class`,
    the name of the class, and some statements in the block (see *Figure 8.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of this class (or in other words, an object of the type `RationalNumber`)
    is created by `r = RationalNumber()` and the query `type(r)` returns the answer,
    `<class''__main__.RationalNumber''>`. If we want to investigate whether an object
    is an instance of this class, we can use the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have generated an object of the type `RationalNumber` that has no
    data yet. Furthermore, there are no methods defined to perform operations with
    these objects. This is the subject of the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.3 The __init__ method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we provide our example class with some attributes, that is, we give it
    defining data. In our case, this data will be the values of the denominator and
    the numerator. To this end, we have to define a method, `__init__`, used to initialize
    the class with these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we explain the special function `__init__`, which we added to the class,
    we demonstrate the instantiation of a `RationalNumber` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A new object of type `RationalNumber` is created by using the class name as
    if it were a function. This statement does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It first creates an empty object, `q`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it applies the `__init__` function to it; that is, `q.__init__(10, 20)`
    is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter of `__init__` refers to the new object itself. On a function
    call, this first parameter is replaced by the object's instance. This applies
    to all methods of the class and not just to the special method `__init__`. The
    special role of this first parameter is reflected by the convention to name it
    `self`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the function `__init__` defines two attributes of the
    new object, `numerator` and `denominator`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.4 Attributes and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the main reasons for working with classes is that objects can be grouped
    together and bound to a common object. We saw this already when looking at rational
    numbers; `denominator` and `numerator` are two objects that we bound to an instance
    of the class `RationalNumber`. They are called **attributes of the instance**.
    The fact that an object is an attribute of a class instance becomes apparent from
    the way they are referenced, which we have used tacitly before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of instantiation and attribute reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an instance is defined, we can set, change, or delete attributes of that
    particular instance. The syntax is the same as for regular variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing or deleting an attribute may have undesired side effects, which might
    even render the object useless. We will be learning more about this in [Section
    8.2](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Attributes that depend on each
    other*. As functions are objects too, we can also use functions as attributes;
    they are called methods of the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s add a method to the class `RationalNumber` that converts
    the number to a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this method takes as its first (and only) argument `self`, the reference
    to the object itself. We use this method with a regular function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note again that the object instance is inserted as the first argument of the
    function. This use of the first argument explains the error message that would
    occur if this particular method were used with additional arguments. The call
    `q.convert2float(15)` provokes this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The reason this does not work is that `q.convert2float(15)` is precisely equivalent
    to `RationalNumber.comvert2float(q,15)`, which fails because `RationalNumber.convert2float`
    takes only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5 Special methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special method `__repr__` gives us the ability to define the way the object
    is represented in a Python interpreter. For rational numbers, a possible definition
    of this method could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this method defined, just typing `q` returns `10 / 20`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to have a method that performs the addition of two rational numbers.
    A first attempt could result in a method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this method takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be much nicer if we could write `q + p` instead. But so far, the plus
    sign is not defined for the type `RationalNumber`. This is done by using the special
    method `__add__`. So, just renaming `add` to `__add__` allows using the plus sign
    for rational numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `q + p` is, in fact, an alias for the expression `q.__add__(p)`.
    In *Table 8.1*, you find special methods for binary operators such as `+`, `-`,
    or `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Method** | **Operator** | **Method** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | `__add__` | `+=` | `__iadd__` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | `__mul__` | `*=` | `__imul__` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `__sub__` | `-=` | `__isub__` |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | `__truediv__` | `/=` | `__itruediv__` |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | `__floordiv__` | `//=` | `__ifloordiv__` |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | `__pow__` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | `__eq__` | `!=` | `qD__ne__` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | `__le__` | `<` | `__lt__` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | `__ge__` | `>` | `__gt__` |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | `__call__` | `[]` | `__getitem__` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Some Python operators and corresponding class methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of those operators for a new class is called **operator
    overloading**. Another example of operator overloading is a method for examining
    whether two rational numbers are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations between objects belonging to different classes need special care:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By default, the operator `+` invokes the left operand's method, `__add__`. We
    programmed it so that it allows both objects of type `int` and objects of type
    `RationalNumber`. In the statement `5+p`, the operands are commuted and the method
    `__add__` of the built-in type `int` is invoked. This method returns an error
    as it cannot know how to handle rational numbers. This case can be handled by
    the method `__radd__`, with which we now will equip the class `RationalNumber`.
    The method `__radd__` is called **reverse addition**.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If operations such as `+` are applied to two operands of different types, the
    corresponding method (in this case, `__add__`) of the left operand is invoked
    first. If this raises an exception, the reverse method (here, `__radd__`) of the
    right operand is called. If this method does not exist, a `TypeError` exception
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable the operation [![](img/c395f657-6c03-422c-ba41-23a1b55c9001.png)],
    where [![](img/a1f1efad-32cf-4fb3-a1c6-e031ee758cc3.png)] is an instance of `RationalNumber`,
    we define `__radd__` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that `__radd__` interchanges the order of the arguments; `self` is the
    object of type `RationalNumber` while `other` is the object that has to be converted.
  prefs: []
  type: TYPE_NORMAL
- en: Methods mimicking function calls and iterables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a class instance together with parentheses or brackets*,* `()` or `[]`,
    invokes a call to one of the special methods `__call__` or `__getitem__`, giving
    the instance the behavior of a function or of an iterable; see also *Table 8.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Which now may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The special method `__getitem__` makes sense if the class provides an iterator
    (it is recommended that you review [Section 9.2.1](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Generators* before you consider the following example).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursion [![](img/deae62f4-7489-4c8f-9bd3-cf784904f150.png)] is called
    a **three*-*term recursion**. It plays an important role in applied mathematics,
    in particular in the construction of orthogonal polynomials. We can set up a three-term
    recursion as a class in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the method `__iter__` defines a generator object, which allows us to
    use an instance of the class as an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `__getitem__` enables us to directly access the iterations as if
    `r3` were a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we used `itertools.islice` when coding `__getitem__` (see [Section
    9.3.2](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Iterator tools* for more
    information).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Attributes that depend on each other
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes of an instance can be changed (or created) by simply assigning them
    a value. However, if other attributes depend on the one just changed, it is desirable
    to change them simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we consider an example: let''s define a class that defines
    an object for planar triangles from three given points. A first attempt to set
    up such a class could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of this triangle is created by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then its area is computed by calling the corresponding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change an attribute, say point *B*, the corresponding edges *a* and *c*
    are not automatically updated and the computed area is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A remedy is to define a method that is executed when an attribute is changed;
    such a method is called a **setter method**. Correspondingly, you might ask for
    a method that is executed when a value of an attribute is requested; such a method
    is called a **getter method**. We explain now how these two methods are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 The function property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special function `property` links an attribute to such a getter, setter,
    and deleter method. It might also be used to assign a documentation string to
    an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue with the previous example with a setter method and consider the
    class `Triangle` again. If the following statement is included in the definition
    of this class, the command `tr.B = <something>` invokes the setter method `set_B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the `Triangle` class accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the attribute `B` is changed, then the `set_B` method stores the new value
    in the internal attribute `_B` and changes all depending attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The way the deleter method is used here is to prevent the deletion of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The use of an underscore as a prefix of attribute names is a convention used
    to indicate attributes that are not designed to be accessed directly. They are
    intended to hold data for attributes handled by setters and getters. These attributes
    are not private in the sense of other programming languages; they are just not
    intended to be accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Bound and unbound methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now take a closer look at attributes that are methods. Let''s consider
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A little inspection shows us how the nature of `func` changes after creating
    an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling, for example, `A.func(3)` would result in an error message such as
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`instA.func(3)` is executed as expected. Upon creation of an instance, the
    method `func` is bound to the instance. The argument `self` gets the instance
    assigned as its value. Binding a method to an instance makes the method applicable
    as a function. Before that, it is of no use. Class methods, which we will consider
    in [Section 8.4.2](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Class methods*,
    are different in this aspect.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Class attributes and class methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen attributes and methods that are bound to an instance of
    a class. In this section, we introduce class attributes and class methods. They
    allow access to methods and data before an instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Class attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attributes specified in the class declaration are called **class attributes**.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Class attributes are useful for simulating default values and can be used if
    values have to be reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Both instances have an attribute, `tol`, with the value initialized in the
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Altering the class attribute automatically affects all the corresponding attributes
    of all instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Altering `tol` for one instance does not affect the other instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, `N2.tol` is detached from the class attribute. Changing `Newton.tol`
    no longer has any effect on `N2.tol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 8.4.2 Class methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in [Section 8.3](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Bound
    and unbound methods* how methods are either bound to an instance of a class or
    remain in a state as unbound methods. Class methods are different. They are always
    bound methods. They are bound to the class itself.'
  prefs: []
  type: TYPE_NORMAL
- en: We will first describe the syntactic details and then give some examples to
    show what these methods can be used for.
  prefs: []
  type: TYPE_NORMAL
- en: 'To indicate that a method is a class method, the decorator line precedes the
    method definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: While standard methods make a reference to an instance by the use of their first
    argument, the first argument of a class method refers to the class itself. By
    convention, the first argument is called `self` for standard methods and `cls`
    for class methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the standard case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is contrasted by an example of the `classmethod` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In practice, class methods may be useful for executing commands before an instance
    is created, for instance, in a preprocessing step. See the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we show how class methods can be used to prepare data before
    creating an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The class is designed so that a polynomial object is created by specifying its
    coefficients. Alternatively, the class method `by_points` allows us to define
    a polynomial by interpolation points.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform the interpolation data to the polynomial coefficients even
    when no instance of `Polynomial` is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of a class method is presented in [Section 8.7](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Classes as decorators*. There, a class method is used to access information related
    to several (or all) instances from this class.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Subclasses and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we introduce some central concepts from object-oriented programming:
    **abstract classes**, **subclasses**, and **inheritance**. To guide you through
    these concepts, we consider another mathematical example: one-step methods for
    solving a differential equation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic form of an ordinary initial value problem is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/984b6f95-b6c1-45b0-b4b9-a33b4a888ee6.png)'
  prefs: []
  type: TYPE_IMG
- en: The data is the right-hand side function ![](img/ae32d475-3b7f-42fc-ba19-35f6c70f1e90.png),
    the initial value ![](img/110bf954-0df2-465d-a569-e653d9b7bfec.png), and the interval
    of interest ![](img/84ce4328-754a-4cae-a02c-6149358e7cf5.png).
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is a function [![](img/aee7a0ad-6c39-4d75-88a7-dff14759956f.png)].
    A numerical algorithm gives this solution as a vector ![](img/6564bfaf-0da4-44ae-ae55-6e5e89f4e9ca.png)
    of discrete values ![](img/c623b321-35c6-4b22-9667-2847e637a603.png) being approximations
    to [![](img/4cb2ef0c-bb63-4b63-a245-f971704ba437.png)]. Here, [![](img/d1198a41-c4a7-4bd9-af0c-827318e13aad.png)]
    and [![](img/72ef7f04-3a16-4a59-99c6-340ae218054f.png)] are discretized values
    of the independent variable ![](img/b47fccf1-7514-4e00-bfb2-adfc999d7379.png),
    which in physical models often represents time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-step method constructs the solution values ![](img/39df427c-bf50-4e98-9e2d-be6e53c2b29f.png)
    by the recursion steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8b77557-6e14-4250-951f-c876172b3cad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![](img/c29823d2-ff3c-45aa-a1c1-b0ca44432554.png) is a step function
    that characterizes the individual methods, see also [[28]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit Euler: ![](img/991c703e-d8c4-4210-9328-b2f82309f864.png)_'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Midpoint rule: ![](img/c1d72a3a-495e-49e2-b4cd-5bc4162546a3.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Runge–Kutta 4: ![](img/ccd180d0-7786-4692-9697-1790a3f151a8.png)with ![](img/ae77b771-8d9e-4352-bbbf-38aa1f1c44a9.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we did here is the typical way of describing a mathematical algorithm.
    We first described a method by its idea, giving its steps in an abstract way.
    To actually use it, we have to fill in the parameters of a concrete method, in
    this example, the function [![](img/8e3a3508-cd7c-412c-ad83-961369b45912.png)].
    This is also the way things are explained in object-oriented programming. First,
    we set up a class with the abstract description of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This abstract class, with its methods, is used as a template for the individual
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the class definitions, the name of the abstract class that we
    used as a template, `OneStepMethod`, is given as an extra argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: That class is called the **parent class**. All methods and attributes of the
    parent class are inherited by the subclasses as long as they are not overridden.
    They are overridden if they are redefined in the subclass. The method `step` is
    redefined in the subclasses, while the method `generate` is generic for the entire
    family and therefore inherited from the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before considering further details, we will demonstrate how these three classes
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can avoid the repetition of common parameter lists by using the star operator
    (see [Section 7.2.5](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Variable number
    of arguments* for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the abstract class has never been used to create an instance. As the
    method `step` was not completely defined, calling it raises an exception of type
    `NotImplementedError`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you have to access the methods or attributes of a parent class. This
    is done using the command `super`. This is useful when the child class uses its
    own `__init__` method in order to extend the parent’s `__init__` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s assume that we want to give every solver class a string
    variable with the solver’s name. To this end, we provide the solver with an `__init__`
    method as it overrides the parent''s `__init__` method. In the case that both
    methods should be used, we have to refer to the parent’s method by the command
    `super`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note, you could have used the name of the parent class explicitly. The use of
    `super` instead allows us to change the name of the parent class without having
    to change all the references to the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the use of inheritance is impractical or even impossible. This motivates
    the use of encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explain the concept of encapsulation by considering Python functions,
    that is, objects of the Python type `function`, which we encapsulate in a new
    class, `Function`, and provide with some relevant methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the operations `__add__` and `__mul__` should return an instance of
    the same class. This is achieved by the statement `return type(self)(sum)`, which
    in this case is a more general form of writing `return Function(sum)`. We can
    now derive subclasses by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider as an example Chebyshev polynomials. They can be computed in the interval
    [![](img/542ff6cb-5696-4556-a905-85fbabbafda1.png)] by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/5213e4fc-3a20-4de8-a6af-a7bad2fa8e97.png)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'We construct a Chebyshev polynomial as an instance of the class `Function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Chebyshev polynomials are orthogonal in the sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5828d012-2424-4a0c-9c78-6055184edd76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This can easily be checked using this construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Without encapsulation, multiplying functions as simply as writing `weight *
    T5 * T6` would not have been possible.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Classes as decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Function as
    decorators*, we saw how functions can be modified by applying another function
    as a decorator. In [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods*, we saw how classes can be made to behave as functions as long
    as they are provided with the method `__call__`. We will use this here to show
    how classes can be used as decorators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to change the behavior of some functions in such
    a way that before the function is invoked, all input parameters are printed. This
    could be useful for debugging purposes. We take this situation as an example to
    explain the use of a decorator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this class to decorate function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the function as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'On the second call, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that both classes and functions can be used as decorators.
    Classes allow more possibilities, as they can be used to collect data as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we observe that:'
  prefs: []
  type: TYPE_NORMAL
- en: Every decorated function creates a new instance of the decorator class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data collected by one instance can be saved and made accessible to another
    instance by class attributes; see [Section 8.4](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Class* *attributes and class methods*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last point emphasizes the difference between function decorators. We show
    this now with a decorator that counts function calls and stores the result in
    a dictionary with the function as the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to analyze the performance of algorithms, it might be useful to count
    the calls of particular functions. We can get counter information without changing
    the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the class attribute `CountCalls.instances` to store the counters
    for each individual instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this decorator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 8.8 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important programming concepts in modern computer science is
    object-oriented programming. We learned in this chapter how to define objects
    as instances of classes, which we provide with methods and attributes. The first
    parameter of methods, usually denoted by `self`, plays an important and special
    role. You saw methods that can be used to define basic operations for your own
    classes such as `+` and `*`.
  prefs: []
  type: TYPE_NORMAL
- en: While in other programming languages attributes and methods can be protected
    against unintended use, Python allows a technique to hide attributes and access
    these hidden attributes through special getter and setter methods. To this end,
    you met an important function, `property`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a method simplify to the class `RationalNumber`. This method should return
    the simplified version of the fraction as a tuple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To provide results with confidence intervals, a special calculus, so-called
    interval arithmetic, is introduced in numerical mathematics. Define a class called
    `Interval` and provide it with methods for addition, subtraction, division, multiplication,
    and power (with positive integers only). These operations obey the following rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6b0c186-7c26-4084-8b79-d623f4f52a86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide this class with methods that allow operations of the type `a + I, a
    I, I + a, I a`, where `I` is an interval and `a` is an integer or float. Convert
    an integer or float into an interval `[a,a]` first. (Hint: you may want to use
    function decorators for this; see [Section](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)
    7.8: *Function as decorators*.) Furthermore, implement the method `__contains__`,
    which enables you to check whether a given number belongs to the interval using
    the syntax `x in I` for an object `I` of type `Interval`. Test your class by applying
    a polynomial `f=lambda x: 25*x**2-4*x+1` to an interval.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example in [Section 8.7](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Classes as decorators*. Extend this example to obtain a *function decorator*
    that counts how often a certain function is called; see also [Section](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml)
    7.8: *Functions as decorators.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compare the two ways to implement a method for reverse addition `__radd__`
    in the class `RationalNumber`: the one given in the example in [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods* and the one given here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you expect an error in this version? What is the error and how do you explain
    it? Test your answer by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the decorator class `CountCalls` as in the example in [Section 8.7](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Classes as decorators*. Provide this class with a method, `reset`, that sets
    the counters of all functions in the dictionary `CountCalls.instances` to `0`.
    What would happen if the dictionary were replaced by an empty dictionary instead?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
