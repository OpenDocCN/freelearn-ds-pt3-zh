<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Handling Data with pandas"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Handling Data with pandas</h1></div></div></div><p>In this chapter, we will <a class="indexterm" id="id289"/>introduce <span class="strong"><strong>pandas</strong></span>, a powerful and versatile Python library that provides tools for data handling and analysis. We will consider the two main pandas structures for storing data, the <code class="literal">Series</code> and <code class="literal">DataFrame</code> objects, in detail. You will learn how to create these structures and how to access and insert data into them. We also cover the <a class="indexterm" id="id290"/>important topic of <span class="strong"><strong>slicing</strong></span>, that is, how to access portions of data using the different indexing methods provided by pandas. Next, we'll discuss the computational and graphics tools offered by pandas, and finish the chapter by demonstrating how to work with a realistic dataset.</p><p>
<span class="emphasis"><em>pandas</em></span> is an extensive package for data-oriented manipulation, and it is beyond the scope of this book to realistically cover all aspects of the package. We will cover only some of the most useful data structures and functionalities. In particular, we will not cover the <code class="literal">Panel</code> data structure and multi-indexes. However, we will provide a solid foundation for readers who wish to expand their knowledge by consulting the official package documentation. Throughout this chapter, we assume the following imports:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%pylab inline</strong></span>
<span class="strong"><strong>from pandas import Series, DataFrame</strong></span>
<span class="strong"><strong>import pandas as pd</strong></span>
</pre></div><div class="section" title="The Series class"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>The Series class</h1></div></div></div><p>A <code class="literal">Series</code> object <a class="indexterm" id="id291"/>represents a one-dimensional, indexed series of data. It can be thought of as a dictionary, with one main difference: the indexes in a <code class="literal">Series</code> class are ordered. The following example constructs a <code class="literal">Series</code> object and displays it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1 = Series([76, 82, 78, 100],</strong></span>
<span class="strong"><strong>                 index = ['Alex', 'Robert', 'Minnie', 'Alice'],</strong></span>
<span class="strong"><strong>                 name = 'Assignment 1', dtype=float64)</strong></span>
<span class="strong"><strong>grades1</strong></span>
</pre></div><p>This produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex       76</strong></span>
<span class="strong"><strong>Robert     82</strong></span>
<span class="strong"><strong>Minnie     78</strong></span>
<span class="strong"><strong>Alice     100</strong></span>
<span class="strong"><strong>Name: Assignment 1, dtype: float64</strong></span>
</pre></div><p>Notice the format of the constructor call:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Series(&lt;data&gt;, index=&lt;indexes&gt;, name=&lt;name&gt;, dtype=&lt;type&gt;)</strong></span>
</pre></div><p>Both <code class="literal">data</code> and <code class="literal">indexes</code> are usually lists or <code class="literal">NumPy</code> arrays, but can be any Python iterable. The lists must have the same length. The <code class="literal">name</code> variable is a string that describes the data in the series. The <code class="literal">type</code> variable is a <code class="literal">NumPy</code> data type. The <code class="literal">indexes</code> and the <code class="literal">name</code> variables are optional (if <code class="literal">indexes</code> are omitted, they are set to integers—starting at 0). The data type is also optional, in which case it is inferred from the data.</p><p>A <code class="literal">Series</code> object supports <a class="indexterm" id="id292"/>the standard dictionary interface. As an example, run the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>print grades1['Minnie']</strong></span>
<span class="strong"><strong>grades1['Minnie'] = 80</strong></span>
<span class="strong"><strong>grades1['Theo'] = 92</strong></span>
<span class="strong"><strong>grades1</strong></span>
</pre></div><p>The output of the preceding command lines is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>78.0</strong></span>
<span class="strong"><strong>Alex       76</strong></span>
<span class="strong"><strong>Robert     82</strong></span>
<span class="strong"><strong>Minnie     80</strong></span>
<span class="strong"><strong>Alice     100</strong></span>
<span class="strong"><strong>Theo       92</strong></span>
<span class="strong"><strong>Name: Assignment 1, dtype: float64</strong></span>
</pre></div><p>Here is another interesting example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>for student in grades1.keys():</strong></span>
<span class="strong"><strong>    print '{} got {} points in {}'.format(student, grades1[student], grades1.name)</strong></span>
</pre></div><p>The preceding command lines produce the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex got 76.0 points in Assignment 1</strong></span>
<span class="strong"><strong>Robert got 82.0 points in Assignment 1</strong></span>
<span class="strong"><strong>Minnie got 80.0 points in Assignment 1</strong></span>
<span class="strong"><strong>Alice got 100.0 points in Assignment 1</strong></span>
<span class="strong"><strong>Theo got 92.0 points in Assignment 1</strong></span>
</pre></div><p>Note that the order of the output is exactly the same as the order in which each of the elements were inserted in the series. Contrary to a standard Python dictionary, the <code class="literal">Series</code> object keeps track of the order of the elements. In fact, elements can be accessed through an integer index, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1[2]</strong></span>
</pre></div><p>The preceding command returns the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>80.0</strong></span>
</pre></div><p>Actually, all of Python's list-access interface is supported. For instance, we can use slices, which return <code class="literal">Series</code> objects:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1[1:-1]</strong></span>
</pre></div><p>The preceding command gives the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Robert     82</strong></span>
<span class="strong"><strong>Minnie     80</strong></span>
<span class="strong"><strong>Alice     100</strong></span>
<span class="strong"><strong>Name: Assignment 1, dtype: float64</strong></span>
</pre></div><p>The indexing capabilities are even more flexible; this is illustrated in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1[['Theo', 'Alice']]</strong></span>
</pre></div><p>The preceding <a class="indexterm" id="id293"/>command returns the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Theo      92</strong></span>
<span class="strong"><strong>Alice    100</strong></span>
<span class="strong"><strong>dtype: float64</strong></span>
</pre></div><p>It is also possible to append new data to the series, by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1a = grades1.append(Series([79, 81], index=['Theo', 'Joe']))</strong></span>
<span class="strong"><strong>grades1a</strong></span>
</pre></div><p>The output of the preceding command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex       76</strong></span>
<span class="strong"><strong>Robert     82</strong></span>
<span class="strong"><strong>Minnie     80</strong></span>
<span class="strong"><strong>Alice     100</strong></span>
<span class="strong"><strong>Theo       92</strong></span>
<span class="strong"><strong>Kate       69</strong></span>
<span class="strong"><strong>Molly      74</strong></span>
<span class="strong"><strong>Theo       79</strong></span>
<span class="strong"><strong>Joe        81</strong></span>
<span class="strong"><strong>dtype: float64</strong></span>
</pre></div><p>Note that the series now contains two entries corresponding to the key, <code class="literal">Theo</code>. This makes sense, since in real-life data there could be more than one data value associated to the same index. In our example, a student might be able to hand in more than one version of the assignment. What happens when we try to access this data? pandas conveniently returns a <code class="literal">Series</code> object so that no data is lost:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1a['Theo']</strong></span>
</pre></div><p>The output of the preceding command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Theo    92</strong></span>
<span class="strong"><strong>Theo    79</strong></span>
<span class="strong"><strong>dtype: float64</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Note that the <a class="indexterm" id="id294"/>
<code class="literal">append()</code> method does not append the values to the existing <code class="literal">Series</code> object. Instead, it creates a new object that consists of the original <code class="literal">Series</code> object with the appended elements. This behavior is not the same as what happens when elements are appended to a Python list. Quite a few methods of the <code class="literal">Series</code> class display behavior that is different from their corresponding list counterparts. A little experimentation (or reading the documentation) may be required to understand the conventions that pandas uses.</p></div></div><p>Let's define a new <a class="indexterm" id="id295"/>series with the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades2 = Series([87, 76, 76, 94, 88],</strong></span>
<span class="strong"><strong>               index = ['Alex', 'Lucy', 'Robert', 'Minnie', 'Alice'],</strong></span>
<span class="strong"><strong>               name='Assignment 2',</strong></span>
<span class="strong"><strong>               dtype=float64)</strong></span>
<span class="strong"><strong>grades2</strong></span>
</pre></div><p>The preceding command lines give the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex      87</strong></span>
<span class="strong"><strong>Lucy      76</strong></span>
<span class="strong"><strong>Robert    76</strong></span>
<span class="strong"><strong>Minnie    94</strong></span>
<span class="strong"><strong>Alice     88</strong></span>
<span class="strong"><strong>Name: Assignment 2, dtype: float64</strong></span>
</pre></div><p>If we want to compute each student's average in the two assignments, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>average = 0.5 * (grades1 + grades2)</strong></span>
<span class="strong"><strong>average</strong></span>
</pre></div><p>On running the preceding code, we get the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex      81.5</strong></span>
<span class="strong"><strong>Alice     94.0</strong></span>
<span class="strong"><strong>Lucy       NaN</strong></span>
<span class="strong"><strong>Minnie    87.0</strong></span>
<span class="strong"><strong>Robert    79.0</strong></span>
<span class="strong"><strong>Theo       NaN</strong></span>
<span class="strong"><strong>dtype: float64</strong></span>
</pre></div><p>The value <code class="literal">NaN</code> <a class="indexterm" id="id296"/>stands for <span class="strong"><strong>Not a number</strong></span>, which is a special floating-point value that is used to indicate the result of an invalid operation, such as zero divided by zero. In pandas, it is used to represent a missing data value. We can locate the missing values in <code class="literal">Series</code> using the <code class="literal">isnull()</code> method. For example, run the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>averages.isnull()</strong></span>
</pre></div><p>Running the preceding <a class="indexterm" id="id297"/>command line produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex      False</strong></span>
<span class="strong"><strong>Alice     False</strong></span>
<span class="strong"><strong>Lucy       True</strong></span>
<span class="strong"><strong>Minnie    False</strong></span>
<span class="strong"><strong>Robert    False</strong></span>
<span class="strong"><strong>Theo       True</strong></span>
<span class="strong"><strong>dtype: bool</strong></span>
</pre></div><p>If we decide that the missing data can be safely removed from the series, we can use the <code class="literal">dropna()</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>average.dropna()</strong></span>
</pre></div><p>The preceding command line produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex      81.5</strong></span>
<span class="strong"><strong>Alice     94.0</strong></span>
<span class="strong"><strong>Minnie    87.0</strong></span>
<span class="strong"><strong>Robert    79.0</strong></span>
<span class="strong"><strong>dtype: float64</strong></span>
</pre></div><p>Notice that this is another case in which the original series is not modified.</p><p>The <code class="literal">Series</code> class provides a series of useful methods for its instances. For example, we can sort both the values and the indexes. To sort the values in-place, we use the <code class="literal">sort()</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1.sort()</strong></span>
<span class="strong"><strong>grades1</strong></span>
</pre></div><p>This generates the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex       76</strong></span>
<span class="strong"><strong>Minnie     80</strong></span>
<span class="strong"><strong>Robert     82</strong></span>
<span class="strong"><strong>Theo       92</strong></span>
<span class="strong"><strong>Alice     100</strong></span>
<span class="strong"><strong>Name: Assignment 1, dtype: float64</strong></span>
</pre></div><p>To sort the indexes of a series, use the <code class="literal">sort_index()</code> method. For example, consider the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades1.sort_index()</strong></span>
</pre></div><p>This produces the <a class="indexterm" id="id298"/>following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Alex       76</strong></span>
<span class="strong"><strong>Minnie     80</strong></span>
<span class="strong"><strong>Robert     82</strong></span>
<span class="strong"><strong>Theo       92</strong></span>
<span class="strong"><strong>Alice     100</strong></span>
<span class="strong"><strong>Name: Assignment 1, dtype: float64</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Note that the sorting is <span class="emphasis"><em>not</em></span> in-place this time, a new series object is returned.</p></div></div><p>For the next examples, we will use data on maximum daily temperatures for the month of June from a weather station nearby the author's location. The following command lines generates the series of temperatures for the days from June 6 to June 15:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>temps = Series([71,76,69,67,74,80,82,70,66,80],</strong></span>
<span class="strong"><strong>               index=range(6,16), </strong></span>
<span class="strong"><strong>               name='Temperatures', dtype=float64)</strong></span>
<span class="strong"><strong>temps</strong></span>
</pre></div><p>The preceding command produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>6     71</strong></span>
<span class="strong"><strong>7     76</strong></span>
<span class="strong"><strong>8     69</strong></span>
<span class="strong"><strong>9     67</strong></span>
<span class="strong"><strong>10    74</strong></span>
<span class="strong"><strong>11    80</strong></span>
<span class="strong"><strong>12    82</strong></span>
<span class="strong"><strong>13    70</strong></span>
<span class="strong"><strong>14    66</strong></span>
<span class="strong"><strong>15    80</strong></span>
<span class="strong"><strong>Name: Temperatures, dtype: float64</strong></span>
</pre></div><p>Let's first compute the mean and standard deviation of the temperatures using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>print temps.mean(), temps.std()</strong></span>
</pre></div><p>The result of the preceding computation is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>73.5 5.77831194112</strong></span>
</pre></div><p>If we want a quick overview of the data in the series, we can use the <code class="literal">describe()</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>temps.describe()</strong></span>
</pre></div><p>The preceding command <a class="indexterm" id="id299"/>produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>count    10.000000</strong></span>
<span class="strong"><strong>mean     73.500000</strong></span>
<span class="strong"><strong>std       5.778312</strong></span>
<span class="strong"><strong>min      66.000000</strong></span>
<span class="strong"><strong>25%      69.250000</strong></span>
<span class="strong"><strong>50%      72.500000</strong></span>
<span class="strong"><strong>75%      79.000000</strong></span>
<span class="strong"><strong>max      82.000000</strong></span>
<span class="strong"><strong>Name: Temperatures, dtype: float64</strong></span>
</pre></div><p>Note that the information is returned as a <code class="literal">Series</code> object, so it can be stored in case it is needed in further computations.</p><p>To draw a plot of the series, we <a class="indexterm" id="id300"/>use the <code class="literal">plot()</code> method. If we just need a quick graphical overview of the data, we can just run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>temps.plot()</strong></span>
</pre></div><p>However, it's also possible to produce nicely formatted, production-quality plots of the data, since all matplotlib features are supported in pandas. The following code illustrates how some of the graph formatting options discussed in <a class="link" href="ch03.html" title="Chapter 3. Graphics with matplotlib">Chapter 3</a>, <span class="emphasis"><em>Graphics with matplotlib</em></span>,<span class="emphasis"><em> </em></span>are being used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>temps.plot(style='-s', lw=2, color='green')</strong></span>
<span class="strong"><strong>axis((6,15,65, 85))</strong></span>
<span class="strong"><strong>xlabel('Day')</strong></span>
<span class="strong"><strong>ylabel('Temperature')</strong></span>
<span class="strong"><strong>title('Maximum daily temperatures in June')</strong></span>
<span class="strong"><strong>None # prevent text output</strong></span>
</pre></div><p>The preceding <a class="indexterm" id="id301"/>command lines produce the following plot:</p><div class="mediaobject"><img alt="The Series class" src="graphics/8341OS_04_01.jpg"/></div><p>Suppose we want to find the days in which the maximum temperature was above 75 degrees. This can be achieved with the following expression:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>temps[temps &gt; 75]</strong></span>
</pre></div><p>The preceding command returns the following series:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>7     76</strong></span>
<span class="strong"><strong>11    80</strong></span>
<span class="strong"><strong>12    82</strong></span>
<span class="strong"><strong>15    80</strong></span>
<span class="strong"><strong>Name: Temperatures, dtype: float64</strong></span>
</pre></div><p>There are many more useful methods provided by the <code class="literal">Series</code> class. Remember that in order to see all the available methods, we can use the code completion feature of IPython. Start typing <code class="literal">temps.</code> and you will get the available methods.</p><p>Then press the <span class="emphasis"><em>Tab</em></span> key. A <a class="indexterm" id="id302"/>window with a list of all available methods will pop up. You can then explore what is available.</p></div></div>
<div class="section" title="The DataFrame class"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>The DataFrame class</h1></div></div></div><p>The <code class="literal">DataFrame</code> <a class="indexterm" id="id303"/>class is used to represent two-dimensional data. To illustrate its use, let's create a <code class="literal">DataFrame</code> class containing student data as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades = DataFrame(</strong></span>
<span class="strong"><strong>    [['Alice',  80., 92., 84,],</strong></span>
<span class="strong"><strong>     ['Bob',    78., NaN, 86,],</strong></span>
<span class="strong"><strong>     ['Samaly', 75., 78., 88.]],</strong></span>
<span class="strong"><strong>    index = [17005, 17035, 17028],</strong></span>
<span class="strong"><strong>    columns = ['Name', 'Test 1', 'Test 2', 'Final']</strong></span>
<span class="strong"><strong>    )</strong></span>
</pre></div><p>This code demonstrates one of the most straightforward ways to construct a <code class="literal">DataFrame</code> class. In the preceding case, the data can be specified as any two-dimensional Python data structure, such as a list of lists (as shown in the example) or a <code class="literal">NumPy</code> array. The <code class="literal">index</code> option sets the row names, which are integers representing student IDs here. Likewise, the <code class="literal">columns</code> option sets the column names. Both the <code class="literal">index</code> and <code class="literal">column</code> arguments can be given as any one-dimensional Python structure, such as lists, <code class="literal">NumPy</code> arrays, or a <code class="literal">Series </code>object. </p><p>To display the output of the <code class="literal">DataFrame</code> class, run the following statement in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades</strong></span>
</pre></div><p>The preceding command displays a nicely formatted table as follows:</p><div class="mediaobject"><img alt="The DataFrame class" src="graphics/8341OS_04_02.jpg"/></div><p>The <code class="literal">DataFrame</code> class features an extremely flexible interface for initialization. We suggest that the reader run the following command to know more about it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>DataFrame?</strong></span>
</pre></div><p>This will display information about the construction options. Our goal here is not to cover all possibilities, but to give an idea of the offered flexibility. Run the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>idx = pd.Index(["First row", "Second row"])</strong></span>
<span class="strong"><strong>col1 = Series([1, 2], index=idx)</strong></span>
<span class="strong"><strong>col2 = Series([3, 4], index=idx)</strong></span>
<span class="strong"><strong>data = {"Column 1":col1, "Column2":col2}</strong></span>
<span class="strong"><strong>df = DataFrame(data)</strong></span>
<span class="strong"><strong>df</strong></span>
</pre></div><p>The preceding <a class="indexterm" id="id304"/>code produces the following table:</p><div class="mediaobject"><img alt="The DataFrame class" src="graphics/8341OS_04_03.jpg"/></div><p>This example illustrates a useful way of thinking of a <code class="literal">DataFrame</code> object: it consists of a dictionary of <code class="literal">Series</code> objects with a common <code class="literal">Index </code>object labeling the rows of the table. Each element in the dictionary corresponds to a column in the table. Keep in mind that this is simply a way to conceptualize a <code class="literal">DataFrame</code> object, and this is not a description of its internal storage.</p><p>Let's go back to our student data example. Let's add a column with the total score of each student, which is the average of the grades, with the final having weight two. This can be computed with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades.loc[:,'Score'] = 0.25 * (grades['Test 1'] + grades['Test 2'] + 2 * grades['Final']) </strong></span>
<span class="strong"><strong>grades</strong></span>
</pre></div><p>The output for the <a class="indexterm" id="id305"/>preceding command line is as follows:</p><div class="mediaobject"><img alt="The DataFrame class" src="graphics/8341OS_04_04.jpg"/></div><p>In the preceding command line, we used one of the following recommended methods of accessing elements from a <code class="literal">DataFrame</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">.loc</code>: This <a class="indexterm" id="id306"/>method is label-based, that is, the element positions are interpreted as labels (of columns or rows) in the table. This method was used in the preceding example.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.iloc</code>: This method <a class="indexterm" id="id307"/>is integer-based. The arguments must be integers and are interpreted as zero-based indexes for the rows and columns of the table. For example, <code class="literal">grades.iloc[0,1]</code> refers to the data in row 0 and column 1, which is Alice's grade in Test 1 in the preceding example.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.ix</code>: This indexing <a class="indexterm" id="id308"/>method supports mixed integer and label-based access. For example, both <code class="literal">grades.ix[17035, 4]</code> and <code class="literal">grades.ix[17035, 'Score']</code> refer to Bob's score in the course. Notice that pandas is smart enough to know that the row labels are integers, so that the index <code class="literal">17035</code> refers to a label, not a position in the table. Indeed, attempting to access the <code class="literal">grades.ix[1, 4]</code> element will flag an error because there is no row with label 1.</li></ul></div><p>To use any of these methods, the corresponding entry (or entries) in the <code class="literal">DataFrame</code> object must already exist. So, these methods cannot be used to insert or append new data.</p><p>Notice that Bob does not have a grade in his second test, indicated by the <code class="literal">NaN</code> entry (he was probably sick on the day of the test). When he takes a retest, his grade can be updated as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades.loc[17035,'Test 2'] = 98</strong></span>
<span class="strong"><strong>grades</strong></span>
</pre></div><p>In the output, you will notice that Bob's final score is not automatically updated. This is no surprise because a <code class="literal">DataFrame</code> object is not designed to work as a spreadsheet program. To perform the update, you must explicitly execute the cell that computes the score again. After you do <a class="indexterm" id="id309"/>that, the table will look like this:</p><div class="mediaobject"><img alt="The DataFrame class" src="graphics/8341OS_04_05.jpg"/></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>It is also possible to use regular indexing to access <code class="literal">DataFrame</code> entries, but that is frowned upon. For example, to refer to Samaly's grade in the final, we could use the <span class="strong"><strong>chained </strong></span><a class="indexterm" id="id310"/>
<span class="strong"><strong>reference</strong></span>, that is, by using <code class="literal">grades['Test 2'][17028]</code>. (Notice the order of the indexes!) We will avoid this usage.</p></div></div><p>The teacher is a little disappointed, because no student got an A grade (score above 90). So, students are given an extra credit assignment. To add a column with the new grade component beside the <code class="literal">Final</code> column, we can run the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades.insert(4, 'Extra credit', [2., 6., 10.])</strong></span>
<span class="strong"><strong>grades</strong></span>
</pre></div><p>Obviously, we can also insert rows. To add a new student we could use the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades.loc[17011,:] = ['George', 92, 88, 91, 9, NaN]</strong></span>
<span class="strong"><strong>grades</strong></span>
</pre></div><p>Of course, the scores have to be updated as follows to take the extra credit into account:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades.loc[:,'Score'] = 0.25 * (grades['Test 1'] + grades['Test 2'] + 2 * grades['Final']) + grades['Extra credit'] </strong></span>
<span class="strong"><strong>grades</strong></span>
</pre></div><p>Now, suppose we want to find all students who got an A and had a score of less than 78 in Test 1. We can do this by using a Boolean expression as index, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades[(grades['Score'] &gt;= 90) &amp; (grades['Test 1'] &lt; 78)]</strong></span>
</pre></div><p>Two important things should be noted from the preceding example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need to use the <code class="literal">&amp; </code>operator instead of the <code class="literal">and</code> operator</li><li class="listitem" style="list-style-type: disc">The parentheses are necessary due to the high precedence of the <code class="literal">&amp;</code> operator</li></ul></div><p>This will return a subtable with the rows that satisfy the condition expressed by the Boolean expression.</p><p>Suppose we want the names and scores of the students who have a score of at least 80, but less than 90 (these could represent the "B" students). The following command lines will be useful to do so:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grades[(80 &lt;= grades['Score']) &amp; grades['Score'] &lt; 90].loc[:,['Name', 'Score']]]</strong></span>
</pre></div><p>This is what this code does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The expression <code class="literal">grades[(80 &lt;= grades['Score']) &amp; grades['Score'] &lt; 90]</code> creates a <code class="literal">DataFrame</code> class that contains all student data for students who have a score of at least 80 but less than 90.</li><li class="listitem" style="list-style-type: disc">Then, <code class="literal">.loc[:,'Name', 'Score']</code> takes a slice of this <code class="literal">DataFrame</code> class, which consists of all rows in the columns labeled <code class="literal">Name</code> and <code class="literal">Score</code>.</li></ul></div><p>An important point about <a class="indexterm" id="id311"/>pandas data structures is that whenever data is referred to, the returned object may be either a copy or a view of the original data. Let's create a <code class="literal">DataFrame</code> class with pseudorandom data to see some examples. To make things interesting, each column will contain normal data with a given mean and standard deviation. The code is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>means = [0, 0, 1, 1, -1, -1, -2, -2]</strong></span>
<span class="strong"><strong>sdevs = [1, 2, 1, 2,  1,  2,  1,  2]</strong></span>
<span class="strong"><strong>random_data = {}</strong></span>
<span class="strong"><strong>nrows = 30</strong></span>
<span class="strong"><strong>for mean, sdev in zip(means, sdevs):</strong></span>
<span class="strong"><strong>    label = 'Mean={}, sd={}'.format(mean, sdev)</strong></span>
<span class="strong"><strong>    random_data[label] = normal(mean, sdev, nrows)</strong></span>
<span class="strong"><strong>row_labels = ['Row {}'.format(i) for i in range(nrows)]</strong></span>
<span class="strong"><strong>dframe = DataFrame (random_data, index=row_labels)</strong></span>
</pre></div><p>The preceding command lines create the data we need for the examples. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define the Python lists, <code class="literal">means</code> and <code class="literal">sdevs</code>, which contain the mean and standard deviation values of the distributions.</li><li class="listitem">Then, create a dictionary named <code class="literal">random_data</code>, with string keys that correspond to the column labels of the <code class="literal">DataFame</code> class that will be created.</li><li class="listitem">Each entry in the dictionary corresponds to a list of size <code class="literal">nrows</code> containing the data, which is generated by the function call to the <code class="literal">normal()</code> function of <code class="literal">NumPy</code>.</li><li class="listitem">Create a list named <code class="literal">row_labels</code>, which contains row labels of the <code class="literal">DataFrame</code> class.</li><li class="listitem">Use both the data, that is, the <code class="literal">random_data</code> dictionary and the <code class="literal">row_labels</code> list, in the <code class="literal">DataFrame</code> constructor.</li></ol></div><p>The preceding code will generate a table of 30 rows and 8 columns. You can see the table, as usual, by evaluating <code class="literal">dframe</code> by itself in a cell. Notice that even though the table is of a moderately large size, the IPython notebook does a good job of displaying it.</p><p>Let's now select a slice <a class="indexterm" id="id312"/>of the <code class="literal">DataFrame</code> class. For the purpose of demonstration, we will use the mixed indexing <code class="literal">.ix</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe_slice = dframe.ix['Row 3':'Row 11', 5:]</strong></span>
<span class="strong"><strong>dframe_slice</strong></span>
</pre></div><p>Notice how the ranges are specified:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The expression <code class="literal">'Row 3':'Row 11'</code> represents a range specified by labels. Notice that, contrary to the usual assumptions in Python, the range includes the last element (<code class="literal">Row 11</code>, in this case).</li><li class="listitem" style="list-style-type: disc">The expression <code class="literal">5:</code> (the number 5 followed by a colon) represents a range numerically, from the fifth column to the end of the table.</li></ul></div><p>Now, run the following command lines in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe_slice.loc['Row 3','Mean=1, sd=2'] = normal(1, 2)</strong></span>
<span class="strong"><strong>print dframe_slice.loc['Row 3','Mean=1, sd=2']</strong></span>
<span class="strong"><strong>print dframe.loc['Row 3','Mean=1, sd=2']</strong></span>
</pre></div><p>The first line resamples a single cell in the data table, and the other two rows print the result. Notice that the printed values are the same! This shows that no copying has taken place, and the variable <code class="literal">dframe_slice</code> refers to the same objects (memory area) that already existed in the <code class="literal">DataFrame</code> class referred to by the <code class="literal">dframe</code> variable. (This is the analogous to pointers in languages such as C, where more than one pointer can refer to the same memory. It is, actually, the standard way variables behave in Python: there is no default copying.)</p><p>What if we really want a copy? All pandas objects have a <code class="literal">copy()</code> method, so we can use the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe_slice_copy = dframe.ix['Row 3':'Row 11', 5:].copy()</strong></span>
<span class="strong"><strong>dframe_slice_copy</strong></span>
</pre></div><p>The preceding command lines will produce the same output as the previous example. However, notice what happens if we modify <code class="literal">dframe_slice_copy</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe_slice_copy.loc['Row 3','Mean=1, sd=2'] = normal(1, 2)</strong></span>
<span class="strong"><strong>print dframe_slice_copy.loc['Row 3','Mean=1, sd=2']</strong></span>
<span class="strong"><strong>print dframe.loc['Row 3','Mean=1, sd=2']</strong></span>
</pre></div><p>Now the printed values <a class="indexterm" id="id313"/>are different, confirming that only the copy was modified.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>In certain cases, it is important to know if the data is copied or simply referred to during a slicing operation. Care should be taken, specially, with more complex data structures. Full coverage of this topic is beyond the scope of this book. However, using <code class="literal">.loc</code>, <code class="literal">.iloc</code>, and <code class="literal">.ix</code> as shown in the preceding examples is sufficient to avoid <a class="indexterm" id="id314"/>trouble. For an example where <span class="emphasis"><em>chained indexing</em></span> can cause errors, see <a class="ulink" href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy">http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy</a> for more information.</p><p>If you ever encounter a warning referring to <code class="literal">SettingWithCopy</code>, check if you are trying to modify an entry of a <code class="literal">DataFrame</code> object using chained indexing, such as in <code class="literal">dframe_object['a_column']['a_row']</code>. Changing the object access to use <code class="literal">.loc</code> instead, for example, will eliminate the warning.</p></div></div><p>To finish this section, let's <a class="indexterm" id="id315"/>consider a few more examples of slicing a <code class="literal">DataFrame</code> <a class="indexterm" id="id316"/>as follows. In all of the following examples, there is no copying; only a new reference to the data is created.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Slicing with lists as indexes is performed using the following command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.ix[['Row 12', 'Row 3', 'Row 24'], [3, 7]]</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Slicing to reorder columns is performed using the following command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.iloc[:,[-1::-1]]</strong></span>
</pre></div><p>The preceding example reverses the column order. To have an arbitrary reordering, use a list with a permutation of the column positions:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.iloc[:,[2, 7, 0, 1, 3, 4, 6, 5]]</strong></span>
</pre></div><p>Note that there is no actual reordering of columns in the <code class="literal">dframe</code> object, since there is no copying of the data.</p></li><li class="listitem" style="list-style-type: disc">Slicing with Boolean operations is performed using the following command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.loc[dframe.loc[:,'Mean=1, sd=1']&gt;0, 'Mean=1, sd=1']</strong></span>
</pre></div><p>The preceding command line selects the elements in the column labeled <code class="literal">Mean=1, sd=1</code> (that are positive), and returns a <code class="literal">Series</code> object (since the data is one-dimensional). If you are having trouble understanding the way this works, run the following command line in a cell by itself:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.loc[:,'Mean=1, sd=1']&gt;0</strong></span>
</pre></div><p>This statement will return a <code class="literal">Series</code> object with Boolean values. The previous command line selects the rows of <code class="literal">dframe</code> corresponding to the positions that result as <code class="literal">True</code> in the <code class="literal">Series</code> object.</p></li><li class="listitem" style="list-style-type: disc">Slicing will, in general, return an object with a different shape than the original. The <code class="literal">where()</code> method can be used, as follows, in cases where the shape has to be preserved.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.where(dframe&gt;0)</strong></span>
</pre></div><p>The preceding command line returns a <code class="literal">DataFrame</code> class that has missing values (<code class="literal">NaN</code>) in the entries that correspond to non-negative values of the <a class="indexterm" id="id317"/>original <code class="literal">dframe</code> object.</p><p>We can also <a class="indexterm" id="id318"/>indicate a value to be replaced by the values that do not satisfy the given condition using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.where(dframe&gt;0, other=0)</strong></span>
</pre></div><p>This command line will replace the entries corresponding to non-negative values by 0.</p></li></ul></div></div>
<div class="section" title="Computational and graphics tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Computational and graphics tools</h1></div></div></div><p>The objects of <a class="indexterm" id="id319"/>pandas have a rich set of built-in computational tools. To illustrate some of this functionality, we will use the random data stored in the <code class="literal">dframe</code> object defined in the previous section. If you discarded that object, here is how to <a class="indexterm" id="id320"/>construct it again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>means = [0, 0, 1, 1, -1, -1, -2, -2]</strong></span>
<span class="strong"><strong>sdevs = [1, 2, 1, 2,  1,  2,  1,  2]</strong></span>
<span class="strong"><strong>random_data = {}</strong></span>
<span class="strong"><strong>nrows = 30</strong></span>
<span class="strong"><strong>for mean, sdev in zip(means, sdevs):</strong></span>
<span class="strong"><strong>    label = 'Mean={}, sd={}'.format(mean, sdev)</strong></span>
<span class="strong"><strong>    random_data[label] = normal(mean, sdev, nrows)</strong></span>
<span class="strong"><strong>row_labels = ['Row {}'.format(i) for i in range(nrows)]</strong></span>
<span class="strong"><strong>dframe = DataFrame (random_data, index=row_labels)</strong></span>
</pre></div><p>Let's explore some of this <a class="indexterm" id="id321"/>functionality of the built-in computational tools.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To get a list of the methods available for the object, start typing the following command in a cell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Then, press the <span class="emphasis"><em>Tab</em></span> key. The completion popup allows us to select a method by double clicking on it. For example, double click on <code class="literal">mean</code>. The cell text changes to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.mean</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">Now, add a question mark to the preceding command line and run the cell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.mean?</strong></span>
</pre></div><p>This will display information about the <code class="literal">mean</code> method (which, not surprisingly, computes the mean of the data).</p></li></ul></div><p>Using tab-completion and <a class="indexterm" id="id322"/>IPython's help features is an excellent way to learn about pandas' features. I recommend that you always display the documentation this way, at least the first few times a method is used. Learning about the features that pandas offers can be a real time-saver.</p><p>Now, let's continue with the functionalities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Let's say that we want to compute the column means for our random data. This can be done by evaluating the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.mean()</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">The standard deviation values can be computed with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.std()</strong></span>
</pre></div></li></ul></div><p>Note that the results for all of the immediately preceding command lines are returned as <code class="literal">Series</code> objects, which is the default object type that pandas uses for one-dimensional data. In particular, the column labels become the indexes of the objects. Let's say we want to create a <code class="literal">DataFrame</code> object containing the mean and standard deviation in two rows. pandas makes this a very easy task, using built-in conversions and constructors.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mean_series = dframe.mean()</strong></span>
<span class="strong"><strong>std_series = dframe.std()</strong></span>
<span class="strong"><strong>mean_std = DataFrame([dict(mean_series), </strong></span>
<span class="strong"><strong>                            dict(std_series)], </strong></span>
<span class="strong"><strong>                           index=['mean', 'std'])</strong></span>
<span class="strong"><strong>mean_std</strong></span>
</pre></div><p>In this code, we first <a class="indexterm" id="id323"/>compute the means and standard deviations and assign them to variables for clarity. Then, we call the <code class="literal">DataFrame</code> constructor that accepts a list of Python dictionaries. This is made easy because pandas allows conversion from a <code class="literal">Series</code> object to a dictionary in a convenient way: <code class="literal">dict(mean_series)</code> returns the representation of <code class="literal">mean_series</code> as a dictionary, using the indexes of the <code class="literal">Series</code> object as keys to the dictionary.</p><p>Let's say we want to standardize the data in all columns so that they all have a common mean value 100 and standard deviation value 20. This can be achieved using the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe_stnd = 100 + 20 * (dframe - mean_std.iloc[0,:]) / mean_std.iloc[1,:] </strong></span>
<span class="strong"><strong>dframe_stnd</strong></span>
</pre></div><p>The preceding command lines simply implement the definition of standardization: we subtract the means from the data, divide by the standard deviation, scale by the desired value of the deviation, and add the desired mean. To check that we get the expected results, run the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>print dframe_stnd.mean()</strong></span>
<span class="strong"><strong>print dframe_stnd.std()</strong></span>
</pre></div><p>To illustrate the possibilities, let's do a two-sided test of the hypothesis that the mean of each column is 0. We first compute the <a class="indexterm" id="id324"/>
<span class="strong"><strong>Z-scores</strong></span> for the columns. The Z-score of each column is just the deviation from the column mean to the model mean (0 in this case), properly scaled by the standard deviation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>zscores = mean_std.iloc[0,:] / (mean_std.iloc[1,:] / sqrt(len(dframe)))</strong></span>
<span class="strong"><strong>zscores </strong></span>
</pre></div><p>The scaling factor, <code class="literal">sqrt(len(dframe))</code>, is the square root of the number of data points, which is given by the number of rows in the table. The last step is to compute the <span class="strong"><strong>p-values</strong></span> for each <a class="indexterm" id="id325"/>column. The p-values are simply a measure of the probability that the data deviates from the mean by more than the corresponding Z-score, given the assumed distribution. These values are obtained from a normal distribution (technically, we should use a <span class="strong"><strong>t-distribution</strong></span>, since <a class="indexterm" id="id326"/>we are using the sample <a class="indexterm" id="id327"/>standard deviation, but in this example this does not really make any difference, since the data is normally generated, and the sample size is large enough). The following command lines use the normal distribution object, <code class="literal">norm</code>, from SciPy to compute the p-values as percentages:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from scipy.stats import norm</strong></span>
<span class="strong"><strong>pvalues = 2 * norm.cdf(-abs(zscores)) * 100</strong></span>
<span class="strong"><strong>pvalues_series = Series(pvalues, index = zscores.index)</strong></span>
<span class="strong"><strong>pvalues_series</strong></span>
</pre></div><p>The line that computes the p-values is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pvalues = 2 * norm.cdf(-abs(zscores)) * 100</strong></span>
</pre></div><p>We use the <code class="literal">cdf()</code> method, which computes the cumulative distribution function for the normal curve from the <code class="literal">norm</code> object. We then multiply it with <code class="literal">2</code>, since this is a two-sided test, and multiply by <code class="literal">100</code> to get a percentage.</p><p>The next line converts the p-values into a <code class="literal">Series</code> object. This is not necessary, but makes the results easier to visualize.</p><p>The following are the results obtained:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Mean=-1, sd=1    1.374183e-02</strong></span>
<span class="strong"><strong>Mean=-1, sd=2    1.541008e-01</strong></span>
<span class="strong"><strong>Mean=-2, sd=1    2.812333e-26</strong></span>
<span class="strong"><strong>Mean=-2, sd=2    1.323917e-04</strong></span>
<span class="strong"><strong>Mean=0, sd=1     2.840077e+01</strong></span>
<span class="strong"><strong>Mean=0, sd=2     6.402502e+01</strong></span>
<span class="strong"><strong>Mean=1, sd=1     2.182986e-06</strong></span>
<span class="strong"><strong>Mean=1, sd=2     5.678316e-01</strong></span>
<span class="strong"><strong>dtype: float64</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Please note that in the preceding example, you will get different numbers, since the data is randomly generated.</p></div></div><p>The results are what we expect, given the way the data was generated: the p-values are all very small, except for the columns that have mean <code class="literal">0</code>.</p><p>Now, let's explore some of the graphical capabilities provided by pandas. The pandas plots are produced using matplotlib, so the basic interface has already been discussed in <a class="link" href="ch03.html" title="Chapter 3. Graphics with matplotlib">Chapter 3</a>, <span class="emphasis"><em>Graphics with matplotlib</em></span>. In the examples that follow, we will assume that we are using the magic. Run the following command in the cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%pylab inline</strong></span>
</pre></div><p>Most of the plotting <a class="indexterm" id="id328"/>capabilities of pandas are implemented as methods of <code class="literal">Series</code> or <code class="literal">DataFrame</code> objects.</p><p>Let's define the following data in our table to include more data points:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>means = [0, 0, 1, 1, -1, -1, -2, -2]</strong></span>
<span class="strong"><strong>sdevs = [1, 2, 1, 2,  1,  2,  1,  2]</strong></span>
<span class="strong"><strong>random_data = {}</strong></span>
<span class="strong"><strong>nrows = 300</strong></span>
<span class="strong"><strong>for mean, sdev in zip(means, sdevs):</strong></span>
<span class="strong"><strong>    label = 'Mean={}, sd={}'.format(mean, sdev)</strong></span>
<span class="strong"><strong>    random_data[label] = normal(mean, sdev, nrows)</strong></span>
<span class="strong"><strong>row_labels = ['Row {}'.format(i) for i in range(nrows)]</strong></span>
<span class="strong"><strong>dframe = DataFrame (random_data, index=row_labels)</strong></span>
</pre></div><p>To display a grid of histograms of the data, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.hist(color='DarkCyan')</strong></span>
<span class="strong"><strong>subplots_adjust(left=0.5, right=2, top=2.5, bottom=1.0)</strong></span>
</pre></div><p>We use the <code class="literal">hist()</code> method to generate the histograms and use the <code class="literal">color</code> option as well, which is passed to the matplotlib function calls that actually do the drawing. The second line of code adds spaces to the plots so that the axis labels do not overlap. You may find that some of the histograms do not look normal. To fix their appearance, it is possible to fiddle with the <code class="literal">bins</code> and <code class="literal">range</code> options of the <code class="literal">hist()</code> method, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dframe.loc[:,'Mean=0, sd=2'].hist(bins=40, range=(-10,10), color='LightYellow')</strong></span>
<span class="strong"><strong>title('Normal variates, mean 0, standard deviation 2')</strong></span>
</pre></div><p>This will draw a histogram of the data in the column for a mean of <code class="literal">0</code> and standard deviation of <code class="literal">2</code>, with <code class="literal">40</code> bins in the range from <code class="literal">-10</code> to <code class="literal">10</code>. In other words, each bin will have a width of <code class="literal">0.5</code>. Note that the plot may not include all the range from <code class="literal">-10</code> to <code class="literal">10</code>, since pandas restricts the drawing to ranges that actually contain data.</p><p>For example, let's <a class="indexterm" id="id329"/>generate data according to <span class="strong"><strong>Geometrical Brownian Motion</strong></span> (<span class="strong"><strong>GBM</strong></span>), which is a model used in mathematical finance to represent the evolution of stock prices. (For details, see <a class="ulink" href="http://en.wikipedia.org/wiki/Geometric_Brownian_motion">http://en.wikipedia.org/wiki/Geometric_Brownian_motion</a>.) This model is defined in <a class="indexterm" id="id330"/>terms of two parameters, representing the <span class="strong"><strong>percentage drift</strong></span> and <a class="indexterm" id="id331"/>
<span class="strong"><strong>percentage volatility</strong></span> of the stock. We start by defining these two values in our model, as well as the initial value of the stock:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mu = 0.15</strong></span>
<span class="strong"><strong>sigma = 0.33</strong></span>
<span class="strong"><strong>S0 = 150</strong></span>
</pre></div><p>The simulation should run <a class="indexterm" id="id332"/>from time <code class="literal">0.0</code> to the maximum time <code class="literal">20.0</code>, and we want to generate 200 data points. The following command lines define these parameters:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>nsteps = 200</strong></span>
<span class="strong"><strong>tmax = 20.</strong></span>
<span class="strong"><strong>dt = tmax/nsteps</strong></span>
<span class="strong"><strong>times = arange(0, tmax, dt)</strong></span>
</pre></div><p>The stock model would naturally be represented by a time series (a <code class="literal">Series</code> object). However, to make the simulation simpler, we will use a <code class="literal">DataFame</code> object and build the simulation column by column. We will start with a very simple table containing only integer indexes and the simulation times:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data = DataFrame(times, columns=['t'], index=range(nsteps))</strong></span>
</pre></div><p>To see the first few rows of the table, we can use the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data.loc[:5,:]</strong></span>
</pre></div><p>You might want to run this command after each column is added in order to get a better idea of how the simulation progresses.</p><p>The basis for the <a class="indexterm" id="id333"/>GBM model is (unsurprisingly) a stochastic process called <span class="strong"><strong>Brownian Motion</strong></span> (<span class="strong"><strong>BM</strong></span>). This process has two parts. A deterministic component, called <a class="indexterm" id="id334"/>
<span class="strong"><strong>drift</strong></span>, is computed as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data['drift'] = (mu - sigma**2/2) * gbm_data.loc[:,'t']</strong></span>
</pre></div><p>The next component adds randomness. It is defined in terms of increments, which are normally distributed with mean zero and standard deviation given by the time interval multiplied by the percentage volatility:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data['dW'] = normal(0.0, sigma * dt, nsteps)</strong></span>
</pre></div><p>The BM component is then defined as the cumulative sum of the increments, as shown in the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data['W'] = gbm_data.loc[:,'dW'].cumsum()</strong></span>
<span class="strong"><strong>gbm_data.ix[0, 'W'] = 0.0</strong></span>
</pre></div><p>In the preceding command lines, we add the second line because we want the process to start at <code class="literal">0</code>, which is not the convention adopted by the <code class="literal">cumsum()</code> method.</p><p>We are now ready to compute <a class="indexterm" id="id335"/>the stock simulation. It is calculated by taking the drift component, adding to the BM component, taking the exponential of the result, and finally, multiplying it by the initial value of the stock. This is all done with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data['S'] = S0 * exp(gbm_data.loc[:,'drift'] + gbm_data.loc[:,'W'])</strong></span>
</pre></div><p>We are now ready to plot the result of the simulation using the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gbm_data.plot(x='t', y='S', lw=2, color='green',</strong></span>
<span class="strong"><strong>              title='Geometric Brownian Motion')</strong></span>
</pre></div><p>The preceding command lines produce the following graph. Obviously, the graph you will get will be different due to randomness.</p><div class="mediaobject"><img alt="Computational and graphics tools" src="graphics/8341OS_04_06.jpg"/></div></div>
<div class="section" title="An example with a realistic dataset"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>An example with a realistic dataset</h1></div></div></div><p>In this section, we <a class="indexterm" id="id336"/>will work with a realistic dataset of moderate size. We will use the <span class="strong"><strong>World Development Indicators</strong></span> dataset, which is provided free of charge by the World Bank. This is a reasonably sized dataset that is not too large or complex to experiment with.</p><p>In any real application, we will need to read data from some source, reformat it to our purposes, and save the reformatted data back to some storage system. pandas offers facilities for data retrieval and storage in multiple formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Comma-separated </strong></span><a class="indexterm" id="id337"/><span class="strong"><strong>values</strong></span> (<span class="strong"><strong>CSV</strong></span>) in text files</li><li class="listitem" style="list-style-type: disc">Excel</li><li class="listitem" style="list-style-type: disc">JSON</li><li class="listitem" style="list-style-type: disc">SQL</li><li class="listitem" style="list-style-type: disc">HTML</li><li class="listitem" style="list-style-type: disc">Stata</li><li class="listitem" style="list-style-type: disc">Clipboard data in text format</li><li class="listitem" style="list-style-type: disc">Python-pickled data</li></ul></div><p>The list of formats <a class="indexterm" id="id338"/>supported by pandas keeps growing with each new update to the library. Please refer to <a class="ulink" href="http://pandas.pydata.org/pandas-docs/stable/io.html">http://pandas.pydata.org/pandas-docs/stable/io.html</a> for a current list.</p><p>Treating all formats supported by pandas is not possible in a book with the current scope. We will restrict examples to CSV files, which is a simple text format that is widely used. Most software packages and data sources have options to format data as CSV files.</p><p>Curiously <a class="indexterm" id="id339"/>enough, CSV is not a formally described storage format. pandas does a good job of providing enough options to read the great majority of files. However, the format of the data may vary depending on the data source. Luckily, since CSV files are simply text files, we can open the files in a spreadsheet program or even a text editor to examine their structure.</p><p>The dataset <a class="indexterm" id="id340"/>for this section can be downloaded from <a class="ulink" href="http://data.worldbank.org/data-catalog/world-development-indicators">http://data.worldbank.org/data-catalog/world-development-indicators</a>, and is also available in the book website. If you choose to download the data from the original website, make sure you choose the CSV file format. The file is in compressed ZIP format, and is about 40 MB in size. Once the archive is decompressed, we get the following files.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_Country.csv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_CS_Notes.csv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_Data.csv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_Description.csv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_Footnotes.csv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_Series.csv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">WDI_ST_Notes.csv</code></li></ul></div><p>As is typical of any realistic dataset, there's always a lot of ancillary information associated with the data. This is <a class="indexterm" id="id341"/>called <span class="strong"><strong>metadata</strong></span> and is used to give information about the dataset, including things such as the labels used for rows and/or columns, data collection details, and explanations concerning the meaning of the data. The metadata is contained in the various files contained within the archive. The reader is encouraged to open the different files using spreadsheet software (or a text editor) to get a feel for the kind of information available. For us, the most important metadata file is <code class="literal">WDI_Series.csv</code>, which contains information on the meaning of data labels for the several time series contained in the data.</p><p>The actual data is in the <code class="literal">WDI_Data.csv</code> file. As this file contains some of the metadata information, we will be able to do all the work using this file only.</p><p>Make sure the <code class="literal">WDI_Data.csv</code> file is in the same directory that contains your IPython notebook files, and run the following command in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wdi = pd.read_csv('WDI_Data.csv')</strong></span>
</pre></div><p>This will read the file and store it in a <code class="literal">DataFrame</code> object that we assign to the variable, <code class="literal">wdi</code>. The first row in the file is assumed to contain the column labels by default. We can see the beginning of the table by running the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wdi.loc[:5]</strong></span>
</pre></div><p>Note that the <code class="literal">DataFrame</code> class is indexed by integers by default. It is possible to choose one of the columns in the data file as the index by passing the <code class="literal">index_col</code> parameter to the <code class="literal">read_csv()</code> method. The <a class="indexterm" id="id342"/>index column can be specified either by its position or by its label in the file. The many options available to <code class="literal">read_csv()</code> are discussed in detail at <a class="ulink" href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-read-csv-table">http://pandas.pydata.org/pandas-docs/stable/io.html#io-read-csv-table</a>.</p><p>An examination of the file shows that it will need some work to be put in a format that can be easily used. Each row of the file contains a time series of annual data corresponding to one country and economic indicator. One initial step is to get all the countries and economic indicators contained in the file. To get a list of unique country names, we can use the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>countries = wdi.loc[:,'Country Name'].unique()</strong></span>
</pre></div><p>To see how many countries are represented, run the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>len(countries)</strong></span>
</pre></div><p>Some of the entries in the file actually correspond to groups of countries, such as Sub-Saharan Africa.</p><p>Now, for indicators, we can run the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>indicators = wdi.loc[:,'Indicator Code'].unique()</strong></span>
</pre></div><p>There are more than 1300 different economic indicators in the file. This can be verified by running the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>len(indicators)</strong></span>
</pre></div><p>To show the different kinds of computation one might be interested in performing, let's consider a single country, for example, Brazil. Let's also suppose that we are only interested on the <a class="indexterm" id="id343"/>
<span class="strong"><strong>Gross Domestic Product</strong></span> (<span class="strong"><strong>GDP</strong></span>) information. Now, we'll see how to select the data we are interested in from the table. To make the example simpler, we will perform the selection in two steps. First, we select all rows for the country name <code class="literal">Brazil</code>, using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wdi_br = wdi.loc[wdi.loc[:,'Country Name']=='Brazil',:]</strong></span>
</pre></div><p>In the code preceding command line, consider the following expression:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wdi.loc[:,'Country Name']=='Brazil'</strong></span>
</pre></div><p>This selects all the rows in which the country name string is equal to <code class="literal">Brazil</code>. For these rows, we want to select all columns of the table, as indicated by the colon in the first term of the slicing operation.</p><p>Let's now select all the rows that refer to the GDP data. We start by defining a function that, given a string, determines if it contains the substring <code class="literal">GDP</code> (ignoring the case):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>select_fcn = lambda string: string.upper().find('GDP') &gt;= 0</strong></span>
</pre></div><p>We now want to select the rows in <code class="literal">wdi_br</code> that return <code class="literal">True</code> when <code class="literal">select_fcn</code> is applied to the <code class="literal">Indicator Code</code> column. This can be done with the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>criterion = wdi_br.loc[:,'Indicator Code'].map(select_fcn)</strong></span>
<span class="strong"><strong>wdi_br_gdp = wdi_br.loc[criterion,:]</strong></span>
</pre></div><p>The <code class="literal">map()</code> method of the <code class="literal">Series</code> object does exactly what we want: it applies a function to all elements of a series. We assign the result of this call to the variable, <code class="literal">criterion</code>. Then, we use <code class="literal">criterion</code> in the slicing operation that defines <code class="literal">wdi_br_gdp</code>. To see how many rows were selected, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>len(wdi_br_gdp)</strong></span>
</pre></div><p>In the dataset used at the writing of this book, the preceding command returns <code class="literal">32</code>. This means that there are 32 GDP-related indicators for the country named <code class="literal">Brazil</code>. Since we now have a manageable amount of data, we can display a table that has the indicator codes and their meanings using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wdi_br_gdp.loc[:,['Indicator Code', 'Indicator Name']]</strong></span>
</pre></div><p>The preceding command line generates a nicely formatted table of the indicator and corresponding names, as shown in the following table:</p><div class="mediaobject"><img alt="An example with a realistic dataset" src="graphics/8341OS_04_07.jpg"/></div><p>Let's say that we are interested only in four indicators: the GDP, annual GDP growth, GDP per capita, and GDP per capita growth. We can further trim the data with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>wdi_br_gdp = wdi_br_gdp.loc[[37858, 37860, 37864, 37865], :]</strong></span>
</pre></div><p>This produces quite a manageable table with 4 rows and 58 columns. Each row contains a time series of the corresponding GDP data starting with the year 1960.</p><p>The problem with this <a class="indexterm" id="id344"/>table as it is laid out is that it is the "transpose" of what is the usual convention in pandas: the time series are across the rows of the table, instead of being down the columns. So, we still need to do a little more work with our table. We want the indexes of our table to be the years. We also want to have one column for each economic indicator and want to use the economic indicator names (not the codes) as the labels of the columns. Here is how this can be done:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>idx = wdi_br_gdp.loc[:,'1960':].columns</strong></span>
<span class="strong"><strong>cols = wdi_br_gdp.loc[:,'Indicator Name']</strong></span>
<span class="strong"><strong>data = wdi_br_gdp.loc[:,'1960':].as_matrix()</strong></span>
<span class="strong"><strong>br_data = DataFrame(data.transpose(), columns=cols, index=idx)</strong></span>
</pre></div><p>The following is an explanation of what the preceding command lines do:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first define an <code class="literal">Index</code> object corresponding to the years in the table using the <code class="literal">columns</code> field of the <code class="literal">DataFrame</code> object. The object is stored in the variable <code class="literal">idx</code>.</li><li class="listitem">Then, we create an object containing the column names. This is a <code class="literal">Series</code> object stored in the variable <code class="literal">cols</code>.</li><li class="listitem">Next, we extract the data we are interested in, that is, the portion of the table corresponding to the years after 1960. We use the <code class="literal">as_matrix()</code> method of the <code class="literal">DataFrame</code> object to convert the data to a <code class="literal">NumPy</code> array, and store it in the variable <code class="literal">data</code>.</li><li class="listitem">Finally, we call the <code class="literal">DataFrame</code> constructor to create the new table.</li></ol></div><p>Now that we have the data we want in a nice format, it is a good time to save it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>br_data.to_csv('WDI_Brazil_GDP.csv')</strong></span>
</pre></div><p>At this point, we can open the <code class="literal">WDI_Brazil_GDP.csv</code> file in a spreadsheet program to view it.</p><p>Now, let's start playing with the data by creating a few plots. Let's first plot the GDP and GDP growth, starting in 1980. Since the data is given in dollars, we scale to give values in billions of dollars.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pdata = br_data.ix['1970':, 0] / 1E9</strong></span>
<span class="strong"><strong>pdata.plot(color='DarkRed', lw=2, </strong></span>
<span class="strong"><strong>           title='Brazil GDP, billions of current US$')</strong></span>
</pre></div><p>The preceding command lines produce the following chart: </p><div class="mediaobject"><img alt="An example with a realistic dataset" src="graphics/8341OS_04_08.jpg"/></div><p>As a final example, let's draw a chart comparing the percent growth of per capita GDP for the <span class="strong"><strong>BRIC</strong></span> (<span class="strong"><strong>Brazil, Russia, India, and China</strong></span>) countries in the period 2000 to 2010. Since we <a class="indexterm" id="id345"/>already have explored the structure of the data, the task is somewhat simpler:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bric_countries = ['Brazil', 'China', 'India', 'Russian Federation']</strong></span>
<span class="strong"><strong>gdp_code = 'NY.GDP.PCAP.KD.ZG'</strong></span>
<span class="strong"><strong>selection_fct = lambda s: s in bric_countries</strong></span>
<span class="strong"><strong>criterion = wdi.loc[:,'Country Name'].map(selection_fct)</strong></span>
<span class="strong"><strong>wdi_bric = wdi.loc[criterion &amp; (wdi.loc[:,'Indicator Code'] == gdp_code),:]</strong></span>
</pre></div><p>We first define a list with the names of the BRIC countries and a string with the indicator code for percent GDP growth per capita. Then, we define a selection function: a string is selected if it is one of the BRIC country names. The <code class="literal">map()</code> method is then used to apply the selection function to all entries of the <code class="literal">Country Name</code> column. The last command line performs the actual selection. Note the use of the Boolean operator <code class="literal">&amp;</code> to combine the two criteria used in the row selection.</p><p>We now perform the reformatting of the data to have the relevant data series along the columns of the table. The command lines are similar to the ones in the previous example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>df_temp = wdi_bric.loc[:, '2000':'2010']</strong></span>
<span class="strong"><strong>idx = df_temp.columns</strong></span>
<span class="strong"><strong>cols = wdi_bric.loc[:, 'Country Name']</strong></span>
<span class="strong"><strong>data = df_temp.as_matrix()</strong></span>
<span class="strong"><strong>bric_gdp = DataFrame(data.transpose(), columns=cols, index=idx)</strong></span>
</pre></div><p>Once this is done, plotting the data is straightforward:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bric_gdp.plot(lw=2.5,</strong></span>
<span class="strong"><strong>              title='Annual per capita GDP growth (%)')</strong></span>
</pre></div><p>The preceding command lines result in the following plot:</p><div class="mediaobject"><img alt="An example with a realistic dataset" src="graphics/8341OS_04_09.jpg"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we covered the objects of pandas, <code class="literal">Series</code> and <code class="literal">DataFrame</code>, which are specialized containers for data-oriented computations. We discussed how to create, access, and modify these objects, including advanced indexing and slicing operations. We also considered the computational and graphical capabilities offered by pandas. We then discussed how these capabilities can be leveraged to work with a realistic dataset.</p><p>In the next chapter, we will learn how to use SciPy to solve advanced mathematical problems of modeling, science, and engineering.</p></div></body></html>