<html><head></head><body>
		<div id="_idContainer093">
			<h1 id="_idParaDest-77"><em class="italic"><a id="_idTextAnchor076"/>Chapter 5</em>: Interactively Comparing Values with Bar Charts and Dropdown Menus</h1>
			<p>You now have all the basics you need to easily construct interactive features linking page elements and to produce interactive dashboards. The main concepts have been covered with the help of several examples, and we will now be focusing on specific types of charts and the different options that they provide. More importantly, we will go into additional details for customizing our charts and making them suitable for several purposes, firstly, in order to be good enough to publish and share with a wider audience, as opposed to just for your interactive use, and secondly, to ensure that they properly fit on a page that potentially contains other components, and making sure we utilize the available space in an optimal way. Another important aspect to cover is the dynamic nature of the charts that our users can generate. Based on the user's choice of option in an interactive component, the resulting dataset might contain 7 or maybe 70 elements to plot. In some cases, it might not contain any data. This dramatically affects the resulting charts and their usability, and can even make them difficult to read in certain cases. We will explore a few solutions to cater for these situations.</p>
			<p>In other words, we are trying to move from working with a prototype that simply does what it's supposed to do to working with a product that can be shared or published to a wide audience.</p>
			<p>The chapters in <em class="italic">Part 2</em> of this book will each focus on a chart type and an interactive component to explore their options. In this chapter, we will explore <strong class="bold">bar charts</strong> and how they can be used with <strong class="bold">drop-down</strong> components, from <strong class="bold">Dash Core Component</strong>. There is nothing in the nature of these components that links a certain component to a certain chart type. They are just used together for organization purposes. A dropdown can be used with any type of chart, and any type of interactive component can be used to manipulate a bar chart.</p>
			<p>We will be focusing on the following topics:</p>
			<ul>
				<li>Plotting bar charts vertically and horizontally</li>
				<li>Linking bar charts and dropdowns</li>
				<li>Exploring different ways of displaying multiple bar charts (stacked, grouped, overlaid, and relative)</li>
				<li>Using facets to split charts into multiple sub-charts – horizontally, vertically, or wrapped</li>
				<li>Exploring additional features of dropdowns (allowing multiple selections, adding placeholder text, and more) </li>
			</ul>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Technical requirements</h1>
			<p>We will continue to use the packages that we are now familiar with – <strong class="source-inline">JupyterDash</strong> and <strong class="source-inline">Dash</strong>, for prototyping and then integrating into our app, respectively. For data manipulation, we will be using <strong class="source-inline">pandas</strong>, and <strong class="source-inline">JupyterLab</strong> will be our starting point for building and testing various options. Then, we will use Dash Core Component, Dash HTML Components, and Dash Bootstrap Components to update our app.</p>
			<p>The dataset that we will be using is the same dataset, specifically the <strong class="source-inline">poverty</strong> DataFrame, that we created in the previous chapter. The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_05">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_05</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3ebv8sk">https://bit.ly/3ebv8sk</a>.</p>
			<p>Let's start by exploring the two main ways in which we can display bar charts – vertically and horizontally.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Plotting bar charts vertically and horizontally</h1>
			<p>The default display of <a id="_idIndexMarker221"/>bar charts is vertical. This is intuitive and easy to understand. Each category or item takes a separate position on the <em class="italic">x </em>axis, and the heights of the bars represent a certain quantity on the <em class="italic">y </em>axis. The same applies when the bars are displayed horizontally, only in this case, the width of the bars is what represents the quantity. Usually, with relatively <a id="_idIndexMarker222"/>fewer values, the vertical orientation is good. However, horizontal orientation can be more effective in two cases:</p>
			<ul>
				<li><strong class="bold">When we have many categories</strong>: In this case, the bars might not fit on the screen, and we might need to either make them much thinner than the default width, or we might need to force horizontal scrolling, which is not as natural as vertical scrolling.</li>
				<li><strong class="bold">When the names of the categories are relatively long</strong>: This is not really a big problem, and the solution is easy. Plotly already handles this for us, by automatically changing the angle at which the names (tick labels) are displayed. If needed, the names can be displayed vertically for maximum space utilization. Reading text displayed horizontally is the most natural though, and it is the most suitable way for these situations.</li>
			</ul>
			<p>Let's see this in action using our <strong class="source-inline">poverty</strong> DataFrame, so we can see the effects of these options, and also to get to know our dataset a little better. We will take a look at one of the most widely used <a id="_idIndexMarker223"/>measures of income/wealth inequality, the Gini index. It is also referred to as the Gini ratio, or coefficient. To learn a bit about it, we can use the <strong class="source-inline">series</strong> DataFrame, which contains information about the indicators that we will be working with:</p>
			<ol>
				<li value="1">Import <strong class="source-inline">pandas</strong> and create the <strong class="source-inline">series</strong> variable. The <a id="_idIndexMarker224"/>name of the variable was chosen based on the filename, as we did in the previous chapter. Please don't confuse this with the <strong class="source-inline">pandas.Series</strong> object:<p class="source-code">import pandas as pd</p><p class="source-code">series = pd.read_csv('data/PovStats<strong class="bold">Series</strong>.csv')</p></li>
				<li>Create a variable, <strong class="source-inline">gini</strong>, as a string, as an easier alternative to using the long name of the indicator:<p class="source-code">gini = 'GINI index (World Bank estimate)'</p></li>
				<li>Extract the long definition of the indicator by using the column of the same name:<p class="source-code">series[series['Indicator Name']==gini]['Long definition'].values[0]</p><p class="source-code"><strong class="bold">Gini index measures the extent to which the distribution of income (or, in some cases, consumption expenditure) among individuals or households within an economy deviates from a perfectly equal distribution. A Lorenz curve plots the cumulative percentages of total income received against the cumulative number of recipients, starting with the poorest individual or household. The Gini index measures the area between the Lorenz curve and a hypothetical line of absolute equality, expressed as a percentage of the maximum area under the line. Thus a Gini index of 0 represents perfect equality, while an index of 100 implies perfect inequality.</strong></p></li>
				<li>Knowing that the <a id="_idIndexMarker225"/>values vary between 0 and 100, let's check what the most extreme values are for all years and countries:<p class="source-code">poverty[gini].min(), poverty[gini].max()</p><p class="source-code"><strong class="bold">(20.2, 65.8)</strong></p></li>
				<li>We can also learn a little more <a id="_idIndexMarker226"/>about this column by using the <strong class="source-inline">describe</strong> method from <strong class="source-inline">pandas</strong>:<p class="source-code">Poverty[gini].describe()</p><p class="source-code"><strong class="bold">count    1674.000000</strong></p><p class="source-code"><strong class="bold">mean       38.557766</strong></p><p class="source-code"><strong class="bold">std         9.384352</strong></p><p class="source-code"><strong class="bold">min        20.200000</strong></p><p class="source-code"><strong class="bold">25%        31.300000</strong></p><p class="source-code"><strong class="bold">50%        36.400000</strong></p><p class="source-code"><strong class="bold">75%        45.275000</strong></p><p class="source-code"><strong class="bold">max        65.800000</strong></p><p class="source-code"><strong class="bold">Name: GINI index (World Bank estimate), dtype: float64</strong></p></li>
			</ol>
			<p>We will learn much more about this indicator and interactively explore and compare different countries across different years, but this statement from the <strong class="source-inline">Limitations and exceptions</strong> column stood out to me: <em class="italic">"Because the underlying household surveys differ in methods and types of welfare measures collected, data is not strictly comparable across countries or even across years within a country."</em></p>
			<p>So, we will have to be careful not to take those values precisely, as mentioned, and keep this limitation in mind.</p>
			<p>Now that we are a <a id="_idIndexMarker227"/>bit more familiar with the indicator, we are ready to explore various options for visualizing it with a bar chart:</p>
			<ol>
				<li value="1">We start by creating a subset of the <strong class="source-inline">poverty</strong> DataFrame, named <strong class="source-inline">df</strong>. This will be a subset where the <strong class="source-inline">year</strong> values are equal to an arbitrarily selected year. We then remove the missing values, and sort the available ones using the <strong class="source-inline">gini</strong> column:<p class="source-code">year = 1980</p><p class="source-code">df =\</p><p class="source-code">poverty[poverty['year']==year].sort_values(gini).dropna(subset=[gini]) </p></li>
				<li>We can now easily <a id="_idIndexMarker228"/>create our Gini index bar chart with Plotly Express. The code also dynamically generates the title by joining the name of the indicator to the selected year:<p class="source-code">import plotly.express as px</p><p class="source-code">px.bar(df,</p><p class="source-code">       x='Country Name',</p><p class="source-code">       y=gini, </p><p class="source-code">       title=' - '.join([gini, str(year)]))</p><p>Running the preceding code produces the chart in <em class="italic">Figure 5.1</em>:</p></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B16780_05_001.jpg" alt="Figure 5.1 – A bar chart of the Gini index for the year 1980"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – A bar chart of the Gini index for the year 1980</p>
			<p>For the year 1980, it seems we <a id="_idIndexMarker229"/>only have data for three countries, and having <a id="_idIndexMarker230"/>them displayed vertically seems fine, easily readable, and clear. Let's now repeat the same process for the year 1990, and see the result in <em class="italic">Figure 5.2</em>:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B16780_05_002.jpg" alt="Figure 5.2 – A bar chart of the Gini index for the year 1990"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – A bar chart of the Gini index for the year 1990</p>
			<p>We can read the country names, but not as naturally as we would if they were displayed horizontally as in <em class="italic">Figure 5.1</em>. Now, if users were reading the same chart on a narrower screen, the country names would be displayed vertically, and it becomes even more difficult to read them, as you can see in <em class="italic">Figure 5.3</em>:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B16780_05_003.jpg" alt="Figure 5.3 – A bar chart of the Gini index for the year 1990 with country names displayed vertically"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – A bar chart of the Gini index for the year 1990 with country names displayed vertically</p>
			<p>In more recent years, we <a id="_idIndexMarker231"/>have data for many more countries, and in<a id="_idIndexMarker232"/> those cases, there is not enough horizontal space to fit them. Some names are not even displayed, unless you hover over the respective bar, or zoom in to that part of the chart. As an example, you can see the same chart for the year 2010 in <em class="italic">Figure 5.4</em>:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B16780_05_004.jpg" alt="Figure 5.4 – A bar chart of the Gini index for the year 2010 with some country names not displayed"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – A bar chart of the Gini index for the year 2010 with some country names not displayed</p>
			<p>Based on the charts we just saw, we now have a better understanding of the challenge of making an interactive bar chart dynamically generated for the Gini index. If we want to let users select the year they are interested in, then we have a few points to deal with.</p>
			<p>First, the number of <a id="_idIndexMarker233"/>available values for this metric varies from 3 to more than 150, which is a very large range. Second, it would be better, and safer, to use <a id="_idIndexMarker234"/>horizontal orientation, because in all cases country names would be displayed horizontally, and no matter how long the names are, they would be easy to read. These issues can be easily solved by setting <strong class="source-inline">orientation='h'</strong> in our call to <strong class="source-inline">px.bar</strong>, but one challenge remains. We need to determine the optimal height of the chart, based on the number of available countries in the chosen year, knowing how big the range is, as we just saw. Let's first see what the bar chart looks like when displayed horizontally, and then design the solution for an interactive one. We will run the same code, but with two principal differences. The <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> arguments need to be swapped, as they will each take the opposite axis, and we also need to set the appropriate value for the <strong class="source-inline">orientation</strong> parameter, <strong class="source-inline">h</strong> for "horizontal" in this case:</p>
			<p class="source-code">year = 2000</p>
			<p class="source-code">px.bar(df,</p>
			<p class="source-code">       <strong class="bold">x=gini</strong>,</p>
			<p class="source-code">       <strong class="bold">y='Country Name</strong>',</p>
			<p class="source-code">       title=' - '.join([gini, str(year)]),</p>
			<p class="source-code">       <strong class="bold">orientation='h'</strong>)</p>
			<p>The preceding code produces the chart in <em class="italic">Figure 5.5</em> for the year 2000:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B16780_05_005.jpg" alt="Figure 5.5 – A horizontal bar chart of the Gini index for the year 2000 for all available countries"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – A horizontal bar chart of the Gini index for the year 2000 for all available countries</p>
			<p>Now the countries are very <a id="_idIndexMarker235"/>easily readable (the ones that are displayed at least), but the bars are too narrow and crowded. The chart looks unnecessarily wide (especially knowing that the minimum and maximum values are in the interval [20.2, 65.8]). We <a id="_idIndexMarker236"/>can manually set the width of the chart in our function call if we require, but we need to figure out a way to dynamically set the height of the chart, which can be set using the <strong class="source-inline">height</strong> parameter.</p>
			<p>One way to do this is to set a fixed height in pixels. Then, based on the number of countries in <strong class="source-inline">df</strong>, we can add 20 pixels per country. For example, if we have 10 countries in <strong class="source-inline">df</strong>, then our height would be 200 + (10x20) = 400 pixels. Once <strong class="source-inline">df</strong> has been created, we can easily count the number of countries it contains, and assign it to a variable, <strong class="source-inline">n_countries</strong>. The modified code to produce this looks like this:</p>
			<p class="source-code">year = 2000</p>
			<p class="source-code">df =\</p>
			<p class="source-code">poverty[poverty['year']==year].sort_values(gini).dropna(subset=[gini])</p>
			<p class="source-code"><strong class="bold">n_countries = len(df['Country Name'])</strong></p>
			<p class="source-code">px.bar(df,</p>
			<p class="source-code">       x=indicator,</p>
			<p class="source-code">       y='Country Name',</p>
			<p class="source-code">       title=' - '.join([gini, str(year)]),</p>
			<p class="source-code">       <strong class="bold">height=200 + (20*n_countries)</strong>,</p>
			<p class="source-code">       orientation='h')</p>
			<p>Running the <a id="_idIndexMarker237"/>preceding <a id="_idIndexMarker238"/>code over three years that have a different number of countries produces the charts in <em class="italic">Figure 5.6</em>:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B16780_05_006.jpg" alt="Figure 5.6 – Various horizontal bar charts with a dynamic height based on the number of countries"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6 – Various horizontal bar charts with a dynamic height based on the number of countries</p>
			<p>The long chart on the <a id="_idIndexMarker239"/>right was resized to fit on the page, but it is pretty <a id="_idIndexMarker240"/>much the same as the others in terms of the height of the bars and the readability of country names. All countries are visible, easy to read, and nothing is hidden.</p>
			<p>With this solution, we <a id="_idIndexMarker241"/>took care of the dynamic number of countries that can be <a id="_idIndexMarker242"/>selected by dynamically setting the total height of the figure, based on the number of countries.</p>
			<p>This approach can be thought of as a discovery approach. Users don't know exactly what they are looking for; they select a year and see whatever data is available for that year. After they select a few options, they might be interested in digging deeper to learn more about specific countries. For example, they might be interested in how a certain country's Gini index has progressed over time. We will do this next.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Creating vertical bar charts with many values</h2>
			<p>When we want to let users visualize how a country's Gini index (or any other indicator) has progressed over the years, we can do so with vertical bars. Because years represent a sequence of events, displaying <a id="_idIndexMarker243"/>them side by side is natural, because it shows a trend over time. And since years are numbers in a sequence, we don't have the readability issue that we had with country names. Even if the bars end up much thinner, and even if some of them weren't displayed, users can easily mentally "fill in the blanks" where required.</p>
			<p>The code to produce such a chart is very similar to the last one, and actually simpler, because we don't need to worry about dynamically setting the height. Instead of <strong class="source-inline">year</strong> as our dynamic variable, we will have <strong class="source-inline">Country Name</strong>. The definition of <strong class="source-inline">df</strong> will depend on the rows in our dataset that contain the chosen country: </p>
			<p class="source-code">country = "Sweden"</p>
			<p class="source-code">df = poverty[poverty['Country Name']==country].dropna(subset=[gini])</p>
			<p>And now we can generate the chart in a straightforward way with the following code: </p>
			<p class="source-code">px.bar(df,</p>
			<p class="source-code">       x='year',</p>
			<p class="source-code">       y=gini,</p>
			<p class="source-code">       title=' - '.join([gini, country]))</p>
			<p>Running the preceding code produces the chart in <em class="italic">Figure 5.7</em> for Sweden:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B16780_05_007.jpg" alt="Figure 5.7 – A vertical bar chart with years on the x axis"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – A vertical bar chart with years on the x axis</p>
			<p>Note that the years with <a id="_idIndexMarker244"/>missing values are still available on the <em class="italic">x</em> axis, even though there are no bars representing their value for those years. This is important because it shows where the gaps are in our data. It would be misleading otherwise if we only displayed years that contained data, giving the false impression of continuous data for all years.</p>
			<p>We have familiarized ourselves a bit with the Gini index data, and tested how to make two types of dynamic charts. We are now ready to create a "Gini Index" section and add it to our app, which we will be doing next.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Linking bar charts and dropdowns</h1>
			<p>We now want to put <a id="_idIndexMarker245"/>together everything that we've done so far. The plan is to have two <a id="_idIndexMarker246"/>dropdowns, side by side, with a chart underneath each. The first will provide years as options that will generate a horizontal bar chart. The second will generate a vertical bar chart, based on the selected country. The end goal is to produce a new section in our app that looks like <em class="italic">Figure 5.8</em>:</p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B16780_05_008.jpg" alt="Figure 5.8 – The Gini Index section in the app with two drop-down components and two bar charts"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – The Gini Index section in the app with two drop-down components and two bar charts</p>
			<p>Let's start by building this as a complete and independent app in JupyterLab, and make sure it works as expected:</p>
			<ol>
				<li value="1">We first run the <a id="_idIndexMarker247"/>necessary imports and instantiate the app. We already covered all these imports, except for the <strong class="source-inline">PreventUpdate</strong> exception. This is a useful tool when there is no value selected in a component that is handled by a <a id="_idIndexMarker248"/>callback function; for example, when a user first loads the app, or when there are no default values. In this case, the input value coming from <strong class="source-inline">Dropdown</strong> would be <strong class="source-inline">None</strong> and would most likely raise exceptions. In those situations, we can use this exception to freeze things, so to speak, until a proper input is passed to the callback function:<p class="source-code">from jupyter_dash import JupyterDash</p><p class="source-code">import dash_html_components as html</p><p class="source-code">import dash_core_components as dcc</p><p class="source-code">import dash_bootstrap_components as dbc</p><p class="source-code">from dash.dependencies import Output, Input</p><p class="source-code"><strong class="bold">from dash.exceptions import PreventUpdate</strong></p><p class="source-code">app = JupyterDash(__name__)</p></li>
				<li>Create <strong class="source-inline">gini_df</strong>, which is a subset of <strong class="source-inline">poverty</strong> that doesn't have missing values in the Gini index column:<p class="source-code">gini_df = poverty[poverty[gini].notna()]</p></li>
				<li>Create the app's layout using one top-level div, within which we will place all other components:<p class="source-code">app.layout  = html.Div()</p></li>
				<li>Inside the div we just <a id="_idIndexMarker249"/>created, we want to add a section title, as well as a <strong class="source-inline">dbc.Row</strong> component. This row will then contain two <strong class="source-inline">dbc.Col</strong> elements, which <a id="_idIndexMarker250"/>would, in turn, contain a dropdown and a chart each. Here is a list of elements that will be inserted in the div:<p class="source-code">[</p><p class="source-code">    html.H2('Gini Index - World Bank Data',</p><p class="source-code">             style={'textAlign': 'center'}),</p><p class="source-code">    dbc.Row([</p><p class="source-code">        dbc.Col([</p><p class="source-code">            dcc.Dropdown(id='<strong class="bold">gini_year_dropdown</strong>',</p><p class="source-code">                         options=[{'label': year, 'value': year}</p><p class="source-code">                         for year in gini_df['year'].drop_duplicates().sort_values()]),</p><p class="source-code">               dcc.Graph(id='<strong class="bold">gini_year_barchart</strong>')</p><p class="source-code">]),</p><p class="source-code">            dbc.Col([</p><p class="source-code">                dcc.Dropdown(id='<strong class="bold">gini_country_dropdown</strong>',</p><p class="source-code">                             options=[{'label': country, 'value': country}</p><p class="source-code">    for country in gini_df['Country Name'].unique()]),</p><p class="source-code">    dcc.Graph(id='<strong class="bold">gini_country_barchart</strong>')</p><p class="source-code">    ])</p><p class="source-code">])</p><p class="source-code">]</p></li>
				<li>The preceding code <a id="_idIndexMarker251"/>should take care of the layout once we insert it in the top-level div. Now we can create the first callback, which takes a year as input and returns <a id="_idIndexMarker252"/>the appropriate chart. Note how the <strong class="source-inline">PreventUpdate</strong> exception is used at the beginning of the function:<p class="source-code">@app.callback(Output('gini_year_barchart', 'figure'),</p><p class="source-code">              Input('gini_year_dropdown', 'value'))</p><p class="source-code">def plot_gini_year_barchart(year):</p><p class="source-code">    <strong class="bold">if not year:</strong></p><p class="source-code">        <strong class="bold">raise PreventUpdate</strong></p><p class="source-code">    df =\</p><p class="source-code">gini_df[gini_df['year'].eq(year)].sort_values(gini).dropna(subset=[gini])</p><p class="source-code">    n_countries = len(df['Country Name'])</p><p class="source-code">    fig = px.bar(df,</p><p class="source-code">                 x=gini,</p><p class="source-code">                 y='Country Name',</p><p class="source-code">                 orientation='h',</p><p class="source-code">                 height=200 + (n_countries*20),</p><p class="source-code">                 title=gini + ' ' + str(year))</p><p class="source-code">    return fig</p></li>
				<li>We can also do the <a id="_idIndexMarker253"/>same thing and create the other callback function that handles the <a id="_idIndexMarker254"/>second part of the Gini Index section:<p class="source-code">@app.callback(Output('gini_country_barchart', 'figure'),</p><p class="source-code">              Input('gini_country_dropdown', 'value'))</p><p class="source-code">def plot_gini_country_barchart(country):</p><p class="source-code">    <strong class="bold">if not country:</strong></p><p class="source-code">        <strong class="bold">raise PreventUpdate</strong></p><p class="source-code">    df = gini_df[gini_df['Country Name']==country].dropna(subset=[gini])</p><p class="source-code">    fig = px.bar(df,</p><p class="source-code">                 x='year',</p><p class="source-code">                 y=gini,</p><p class="source-code">                 title=' - '.join([gini, country]))</p><p class="source-code">    return fig</p></li>
				<li> Finally, we run the app:<p class="source-code">if __name__ == '__main__':</p><p class="source-code">    app.run_server(mode='inline')</p></li>
			</ol>
			<p>This should create a running app as shown in <em class="italic">Figure 5.8</em>.</p>
			<p>We now want to incorporate this new functionality into our existing app. All we have to do is insert the visual components wherever we want them to appear. The callbacks can be added below the app's <strong class="source-inline">layout</strong> attribute. You can go ahead and make a copy of the latest version of the app that we created in <a href="B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Plotly's Figure Objects</em>. You can insert the new components as a list between <strong class="source-inline">dcc.Graph(id='population_chart')</strong> and <strong class="source-inline">dbc.Tabs</strong>, as you can see in the following code snippet:</p>
			<p class="source-code">…</p>
			<p class="source-code">dcc.Graph(id='population_chart'),</p>
			<p class="source-code"><strong class="bold">html.Br(),</strong></p>
			<p class="source-code"><strong class="bold">html.H2('Gini Index - World Bank Data', style={'textAlign': 'center'}),</strong></p>
			<p class="source-code"><strong class="bold">html.Br(),</strong></p>
			<p class="source-code"><strong class="bold">dbc.Row([</strong></p>
			<p class="source-code"><strong class="bold">    dbc.Col([</strong></p>
			<p class="source-code"><strong class="bold">…</strong></p>
			<p class="source-code"><strong class="bold">        dcc.Graph(id='gini_country_barchart')</strong></p>
			<p class="source-code"><strong class="bold">    ]),</strong></p>
			<p class="source-code"><strong class="bold">]),</strong></p>
			<p class="source-code">dbc.Tabs([</p>
			<p class="source-code">    dbc.Tab([</p>
			<p class="source-code">…</p>
			<p>Using one indicator, we <a id="_idIndexMarker255"/>created two dynamic charts, the first allowing users to explore the data for a given year, showing all available countries, and the other allowing them to <a id="_idIndexMarker256"/>explore data for all years, for a certain country. We also explored the two ways of displaying bars, horizontally and vertically, and discussed when it can be better to use each of the orientations.</p>
			<p>We'll now move on to exploring how to plot multiple bar charts on the same figure, and see different ways of doing so. We will also explore a new set of indicators using those new techniques.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Exploring different ways of displaying multiple bar charts (stacked, grouped, overlaid, and relative)</h1>
			<p>When we want to display values for <a id="_idIndexMarker257"/>different countries but for the same years, we have several options for how to display multiple bars on each position of the <em class="italic">x</em> axis. <em class="italic">Figure 5.9</em> shows the different ways in which we can do that when visualizing two variables, <strong class="bold">a</strong> and <strong class="bold">b</strong>: </p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B16780_05_009.jpg" alt="Figure 5.9 – Multiple bar charts displayed using different &quot;barmode&quot; options"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – Multiple bar charts displayed using different "barmode" options</p>
			<p>The four bar charts in the preceding diagram show the same information, but in different ways. This can be set using the <strong class="source-inline">barmode</strong> parameter. With <strong class="bold">relative</strong>, bars are displayed on top of one another, with negative values below, and positive values above, the zero line. If you set it to <strong class="bold">group</strong>, then bars will be displayed next to one another. With <strong class="bold">overlay</strong>, bars are displayed in front of one another, and by default, we get some transparency in order to see both bars. Finally, if you set it to <strong class="bold">stack</strong>, you get them on top of one another, like relative, but in this case, the negative values cancel out the positives, as you can see for values 2 and 4 in the last chart. This is great if you want to compare proportions of each <a id="_idIndexMarker258"/>value to the total, especially if they all add up to the same total. This is what we will do with the income share indicators that are available in our dataset.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Creating the income share DataFrame</h2>
			<p>Let's take a look at the five columns that <a id="_idIndexMarker259"/>show the share of income for each of the five quintiles of countries' populations. We first create a subset of the <strong class="source-inline">poverty</strong> DataFrame, and call it <strong class="source-inline">income_share_df</strong>. This is done by filtering the columns using the regular expression shown here. We also drop missing values:</p>
			<p class="source-code">income_share_df =\</p>
			<p class="source-code">poverty.filter(regex='Country Name|^year$|Income share.*?20').dropna()</p>
			<p class="source-code">income_share_df</p>
			<p>Running the preceding code shows us a sample of rows from the newly created <strong class="source-inline">income_share_df</strong>, as you can see in <em class="italic">Figure 5.10</em>:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B16780_05_0010.jpg" alt="Figure 5.10 – Sample rows showing income share quintiles per country"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Sample rows showing income share quintiles per country</p>
			<p>For every country and year combination, we have five values. Each value shows the percentage of income of the respective group's share of the total for that country and year. We want to let users select a country and, as a result, display a chart showing how the split of those five values changes across all available years. To get an idea of the end result, take a look at <em class="italic">Figure 5.11</em> showing those values for the United States:</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B16780_05_0011.jpg" alt="Figure 5.11 – Income shares per quintile, shown for the selected country for all available years"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – Income shares per quintile, shown for the selected country for all available years</p>
			<p>Since these values all add up to 100 (with minor rounding errors), we can have clearly comparable bars <a id="_idIndexMarker260"/>across the years, because they all have the same total length. Since these are proportions, we are interested in seeing the split for a particular year, and also how that split changed across years.</p>
			<p>As you can see, it is very easy to see how things change for the rightmost and leftmost parts of the bars because they have the same baseline, whether at the beginning or the end. However, for the values in the middle, it's not easy to do so. The reason is that their size changes, as well as their baselines. So, the more divisions you add, the more difficult it gets to compare them across years. But since Plotly's charts are interactive, users can easily hover over the bars, get their exact values, and compare them.</p>
			<p>Producing this chart should be straightforward. We already created our DataFrame, and have our values. We can just set the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> values, and set <strong class="source-inline">orientation='h'</strong>, but the problem is that the categories are ordered alphabetically in the DataFrame, and we want them to be ordered according to their numeric meaning, from the lowest to the highest, so that their relative position can be easily understood by users. As usual, this is mainly a data manipulation challenge. So, let's do it:</p>
			<ol>
				<li value="1">We first need to rename the columns and order them by their value, from "lowest" to "highest." One way to do that is to prepend the column names with numbers and sort accordingly. This <a id="_idIndexMarker261"/>can easily be done using the <strong class="source-inline">rename</strong> method. After that, we sort the columns by using the <strong class="source-inline">sort_index</strong> method, and setting <strong class="source-inline">axis=1</strong>, which means the columns (as opposed to the index of the DataFrame):<p class="source-code">income_share_df = income_share_df.rename(columns={</p><p class="source-code">    'Income share held by lowest 20%': '1 Income share held by lowest 20%',</p><p class="source-code">    'Income share held by second 20%': '2 Income share held by second 20%',</p><p class="source-code">    'Income share held by third 20%': '3 Income share held by third 20%',</p><p class="source-code">    'Income share held by fourth 20%': '4 Income share held by fourth 20%',</p><p class="source-code">    'Income share held by highest 20%': '5 Income share held by highest 20%'</p><p class="source-code">}).sort_index(axis=1)</p></li>
				<li>Check to see that our work is correct:<p class="source-code">income_share_df.columns</p><p class="source-code"><strong class="bold">Index(['1 Income share held by lowest 20%',</strong></p><p class="source-code"><strong class="bold">       '2 Income share held by second 20%',</strong></p><p class="source-code"><strong class="bold">       '3 Income share held by third 20%',</strong></p><p class="source-code"><strong class="bold">       '4 Income share held by fourth 20%',</strong></p><p class="source-code"><strong class="bold">       '5 Income share held by highest 20%',</strong></p><p class="source-code"><strong class="bold">       'Country Name', 'year'],</strong></p><p class="source-code"><strong class="bold">     dtype='object')</strong></p></li>
				<li>We now want to remove the redundant part of the columns and keep the position indicator together with "20%." We can use the standard library's <strong class="source-inline">re</strong> module for that. We replace any digit followed by <strong class="source-inline">Income share held by</strong> with an empty string. After that, we change the casing of the resulting string to title case:<p class="source-code">import re</p><p class="source-code">income_share_df.columns = [\</p><p class="source-code">re.sub('\d Income share held by ', '', col).title() for col in income_share_df.columns</p><p class="source-code">]</p></li>
				<li>We now <a id="_idIndexMarker262"/>create a variable, <strong class="source-inline">income_share_cols</strong>, to refer to the columns that we are interested in:<p class="source-code">income_share_cols = income_share_df.columns[:-2]</p><p class="source-code">income_share_cols</p><p class="source-code"><strong class="bold">Index(['Lowest 20%', 'Second 20%', 'Third 20%', 'Fourth 20%', 'Highest 20%'], dtype='object')</strong></p></li>
				<li>Now, our DataFrame is ready for plotting with suitable and short names. We first create a <strong class="source-inline">country</strong> variable to use in filtering the DataFrame:<p class="source-code">country = 'China'</p></li>
				<li>Create the bar chart using <strong class="source-inline">px.bar</strong>. Note that when setting the value of the <strong class="source-inline">x</strong> parameter, we are using a list. Plotly Express can also work with wide format data, which is very convenient in such cases. We could have melted the DataFrame and used the approach we used in the previous chapter as well. We also set <strong class="source-inline">orientation='h'</strong> and <strong class="source-inline">barmode='stack'</strong>. The title will dynamically insert the country name, as you can see here: <p class="source-code">fig = \</p><p class="source-code">px.bar(income_share_df[income_share_df['Country Name']==country].dropna(),</p><p class="source-code">             <strong class="bold">x=income_share_cols</strong>,</p><p class="source-code">             y='Year',</p><p class="source-code">             hover_name='Country Name',</p><p class="source-code">             <strong class="bold">orientation='h'</strong>,</p><p class="source-code">             <strong class="bold">barmode='stack'</strong>,</p><p class="source-code">             height=600,</p><p class="source-code">             title=f'Income Share Quintiles - {country}')</p><p class="source-code">fig.show()</p></li>
				<li>You probably noticed that I assigned the <a id="_idIndexMarker263"/>result to a variable figure, and that is because we have a few minor details to improve. Running the preceding code produces the chart in <em class="italic">Figure 5.12</em>:<div id="_idContainer086" class="IMG---Figure"><img src="image/B16780_05_0012.jpg" alt="Figure 5.12 – Income shares per quintile, shown using the default options"/></div><p class="figure-caption">Figure 5.12 – Income shares per quintile, shown using the default options</p></li>
				<li>The titles of the <em class="italic">x</em> axis, <strong class="bold">value</strong>, and the legend, <strong class="bold">variable</strong>, are not really informative. We will modify them, and place the legend keys right under the chart, using their logical ascending sequence. This can make it easier for readers to associate the values, and for readers on a grayscale interface, it can slightly improve things as well. As discussed in <a href="B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Plotly's Figure Objects</em>, all these attributes belong under <strong class="source-inline">fig.layout</strong>, and setting them is straightforward. Note that the legend has the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> attributes to set its position in the figure. We set the legend's <strong class="source-inline">x</strong> attribute to 0.25 to indicate that we want the legend to start at quarter the distance from the origin of the figure:<p class="source-code">fig.layout.legend.orientation = 'h'</p><p class="source-code">fig.layout.legend.title = None</p><p class="source-code">fig.layout.xaxis.title = 'Percent of Total Income'</p><p class="source-code">fig.layout.legend.x = 0.25</p></li>
				<li>Running the preceding <a id="_idIndexMarker264"/>code for Indonesia produces the final chart in <em class="italic">Figure 5.13</em>:</li>
			</ol>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B16780_05_0013.jpg" alt="Figure 5.13 – Income shares per quintile, shown using customized options"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Income shares per quintile, shown using customized options</p>
			<p>Let's now put everything together and add the new features to our app.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Incorporating the functionality into our app</h2>
			<p>We are now ready to <a id="_idIndexMarker265"/>again add the new functionality to our app using the function and chart we just created. At this stage, not much explanation is <a id="_idIndexMarker266"/>required since we have done this enough times, but I will go through the main steps, and you can always refer to the code repository to check your work:</p>
			<ol>
				<li value="1">At the top of the module, we first make the DataFrame definitions, as well as column changes, as we did. Make sure that the following code is placed after creating the <strong class="source-inline">poverty</strong> DataFrame because it depends on it:<p class="source-code">income_share_df =\</p><p class="source-code">poverty.filter(regex='Country Name|^year$|Income share.*?20').dropna()</p><p class="source-code">income_share_df = income_share_df.rename(columns={</p><p class="source-code">    'Income share held by lowest 20%': '1 Income share held by lowest 20%',</p><p class="source-code">    'Income share held by second 20%': '2 Income share held by second 20%',</p><p class="source-code">    'Income share held by third 20%': '3 Income share held by third 20%',</p><p class="source-code">    'Income share held by fourth 20%': '4 Income share held by fourth 20%',</p><p class="source-code">    'Income share held by highest 20%': '5 Income share held by highest 20%'</p><p class="source-code">}).sort_index(axis=1)</p><p class="source-code">income_share_df.columns =\</p><p class="source-code">[re.sub('\d Income share held by ', '', col).title() for col in income_share_df.columns]</p><p class="source-code">income_share_cols = income_share_df.columns[:-2]</p></li>
				<li>For the layout part, we require an <strong class="source-inline">h2</strong> element as a title for the new section, a <strong class="source-inline">Dropdown</strong> component for countries, and a <strong class="source-inline">Graph</strong> component, right <a id="_idIndexMarker267"/>under the last charts we created for the Gini Index section:<p class="source-code">dcc.Dropdown(id='income_share_country_dropdown',</p><p class="source-code">             options=[{'label': country, 'value': country}</p><p class="source-code">                      for country in income_share_df['Country Name'].unique()]),</p><p class="source-code">dcc.Graph(id='income_share_country_barchart')</p></li>
				<li>The <strong class="source-inline">callback</strong> function <a id="_idIndexMarker268"/>can be easily constructed using the code we just worked with, and it ends up as follows:<p class="source-code">@app.callback(Output('income_share_country_barchart', 'figure'),</p><p class="source-code">              Input('income_share_country_dropdown', 'value'))</p><p class="source-code">def plot_income_share_barchart(country):</p><p class="source-code">    if country is None:</p><p class="source-code">        raise PreventUpdate</p><p class="source-code">    fig =\</p><p class="source-code">px.bar(income_share_df[income_share_df['Country Name']==country].dropna(),</p><p class="source-code">    x=income_share_cols,</p><p class="source-code">    y='Year',</p><p class="source-code">    barmode='stack',</p><p class="source-code">    height=600,</p><p class="source-code">    hover_name='Country Name',</p><p class="source-code">    title=f'Income Share Quintiles - {country}',</p><p class="source-code">    orientation='h')</p><p class="source-code">    fig.layout.legend.title = None</p><p class="source-code">    fig.layout.legend.orientation = 'h'</p><p class="source-code">    fig.layout.legend.x = 0.25</p><p class="source-code">    fig.layout.xaxis.title = 'Percent of Total Income'</p><p class="source-code">    return fig</p></li>
			</ol>
			<p>Adding this code in the right places should add the new functionality to our app. We now have multiple indicators that our users can interact with, and several of them provide different ways of looking at the data.</p>
			<p>The four ways of <a id="_idIndexMarker269"/>displaying bar charts can be interesting, but in our case, if we want to allow users to compare more than one country, it would quickly become <a id="_idIndexMarker270"/>almost impossible to read. Going back to our Gini index country chart, for example, each selected country typically displays 20 to 30 bars, depending on how much data is available. For four countries, we are talking about around 100 bars, on half a page, which is really difficult to read.</p>
			<p>How about allowing users to select as many countries as they want, and for each selected country, a separate chart is produced, so they can see the countries on multiple charts?</p>
			<p>This is what faceting is all about, which we will explore next.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Using facets to split charts into multiple sub-charts – horizontally, vertically, or wrapped</h1>
			<p>This is a very powerful technique <a id="_idIndexMarker271"/>that allows us to add a new dimension to our analysis. We can select any feature (column) from our dataset to split the chart by. If <a id="_idIndexMarker272"/>you are expecting a long explanation of how it works, and what you need to learn to master it, don't. Just like most other things in Plotly Express, if you have a long-form (tidy) dataset, all you have to do is select a column and use its name for the <strong class="source-inline">facet_col</strong> or <strong class="source-inline">facet_row</strong> parameter. That's it.</p>
			<p>Let's take a quick look at the available options for facets by looking at the relevant facet parameters:</p>
			<ul>
				<li><strong class="source-inline">facet_col</strong>: This means you want to split the chart into columns, and the selected column name will be used to split them. This results in the charts being displayed side by side (as columns).</li>
				<li><strong class="source-inline">facet_row</strong>: Similarly, if you want to split the chart into rows, you can use this parameter, which will split the chart into sub-charts displayed on top of one another.</li>
				<li><strong class="source-inline">facet_col_wrap</strong>: This is <a id="_idIndexMarker273"/>really useful when you have a dynamic number of facets to produce. If you know your users will be generating multiple charts, after how many charts should the following chart be displayed on the next row in the resulting grid of charts? The answer should be an integer, and Plotly Express <a id="_idIndexMarker274"/>makes sure that after that number, the charts are displayed in the next row of charts. This ensures that for every row, we have a maximum number of columns of charts.</li>
				<li><strong class="source-inline">facet_row_spacing</strong> and <strong class="source-inline">facet_col_spacing</strong>: As their names suggest, you can control the spacing between rows and columns by setting these values in the range [0, 1] as a fraction of the total figure size, horizontally or vertically.</li>
			</ul>
			<p>Let's run a quick example to make sure this is clear:</p>
			<ol>
				<li value="1">Create a list of countries to filter by:<p class="source-code">countries = ['Algeria', 'Japan']</p></li>
				<li>Modify the definition of <strong class="source-inline">df</strong> to filter the rows where <strong class="source-inline">'Country Name'</strong> is in <strong class="source-inline">countries</strong>. The <strong class="source-inline">pandas</strong> method <strong class="source-inline">isin</strong> can be used for this:<p class="source-code">df =\</p><p class="source-code">gini_df[gini_df['Country Name'].isin(countries)].dropna(subset=[gini])</p></li>
				<li>Run <strong class="source-inline">px.bar</strong> with the simple addition of <strong class="source-inline">facet_row='Country Name'</strong>:<p class="source-code">px.bar(df,</p><p class="source-code">       x='year',</p><p class="source-code">       y=gini,</p><p class="source-code">       <strong class="bold">facet_row='Country Name'</strong>)</p><p>Running this code produces the chart in <em class="italic">Figure 5.14</em>:</p><div id="_idContainer088" class="IMG---Figure"><img src="image/B16780_05_0014.jpg" alt="Figure 5.14 – Two bar charts generated using the facet_row parameter"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 5.14 – Two bar charts generated using the facet_row parameter</p></li>
				<li>It's very easy to <a id="_idIndexMarker275"/>extend our charts, as you can see, and we also get the sub-charts labeled for us with the correct country names. It still doesn't look as good as we would like it to be. The <em class="italic">y</em> axis titles are overlapping, and you <a id="_idIndexMarker276"/>have to look hard at the vertical titles to see which sub-chart belongs to which country. So let's improve things. Let's first start by modifying the <em class="italic">y</em> axis titles, which can be done using the <strong class="source-inline">labels</strong> parameter, by providing a dictionary and mapping the default name to the new name that we want:<p class="source-code">labels={gini: 'Gini Index'}</p></li>
				<li>We can also help the user to quickly identify the charts by coloring the bars by country. This will make them distinctive and will also produce a legend with colored guides, making it even easier to distinguish the charts. Again this is done by simply providing an argument to the <strong class="source-inline">color</strong> parameter, which is basically a selection of the column name that we want to use for that:<p class="source-code">color='Country Name' </p></li>
				<li>Another helpful <a id="_idIndexMarker277"/>thing would be to add a dynamic title to the figure as a whole. We can display the full indicator name, and underneath that, we can show a comma-separated list of the selected countries. Plotly annotations support some HTML tags, and we will use the <strong class="source-inline">&lt;br&gt;</strong> tag to separate the indicator name and the country list as follows:<p class="source-code">title='&lt;br&gt;'.join([gini, ', '.join(countries)])</p></li>
				<li>Having two <a id="_idIndexMarker278"/>countries on the chart is easy to read, but what if the users decide to select seven? As we did with the dynamic height of the Gini index horizontal bar chart, we also need to set a dynamic height for the faceted bar charts based on the number of selected countries. We will use the same technique, but with different values, because we are managing sub-plots, and not horizontal bars:<p class="source-code">height=100 + 250*len(countries)</p></li>
				<li>The full updated code can be seen here:<p class="source-code">px.bar(df,</p><p class="source-code">       x='year',</p><p class="source-code">       y=gini,</p><p class="source-code">       facet_row='Country Name',</p><p class="source-code">       labels={gini: 'Gini Index'},</p><p class="source-code">       color='Country Name',</p><p class="source-code">       title='&lt;br&gt;'.join([gini, ', '.join(countries)]),</p><p class="source-code">       height=100 + 250*len(countries))</p></li>
				<li>The final chart can be seen in <em class="italic">Figure 5.15</em>, shown for three countries:</li>
			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B16780_05_0015.jpg" alt="Figure 5.15 – Three bar charts generated using the facet_row parameter with customized options"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15 – Three bar charts generated using the facet_row parameter with customized options</p>
			<p>The figure and function <a id="_idIndexMarker279"/>have now been updated to produce faceted charts, based on the selected countries. The only remaining change that we have to make is to set the <a id="_idIndexMarker280"/>dropdown providing the options for this, to allow multiple selections. We will do this next, as well as taking a general view of our current dashboard, and see how to improve its layout and usability.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Exploring additional features of dropdowns</h1>
			<p>The <strong class="source-inline">Dropdown</strong> component has an <a id="_idIndexMarker281"/>optional parameter, <strong class="source-inline">multi</strong>, that takes a Boolean argument, which we can set to <strong class="source-inline">True</strong> to allow this:</p>
			<p class="source-code">dcc.Dropdown(id='gini_country_dropdown',</p>
			<p class="source-code">             <strong class="bold">multi=True</strong>,</p>
			<p class="source-code">             options=[{'label': country, 'value': country}</p>
			<p class="source-code">                      for country in gini_df['Country Name'].unique()]),</p>
			<p>You can now make the <a id="_idIndexMarker282"/>changes and use the Gini country bar chart for as many countries as you like. The height of that figure on the page dynamically expands/collapses based on the dynamic height that we set, so we also don't need to worry about this aspect of the layout. The users will manage it themselves while interacting with the components. Let's now see whether it's easy for a newcomer to use those options.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Adding placeholder text to dropdowns</h2>
			<p>If you look at the Gini Index section of the <a id="_idIndexMarker283"/>app for the first time, you will see two dropdowns that allow you to make a selection, as shown in <em class="italic">Figure 5.16</em>:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B16780_05_0016.jpg" alt="Figure 5.16 – Dropdowns without any placeholder text"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16 – Dropdowns without any placeholder text</p>
			<p>But select what exactly?</p>
			<p>The <strong class="source-inline">Dropdown</strong> component has an optional <strong class="source-inline">placeholder</strong> parameter, which can be very useful for users to know what exactly they are selecting.</p>
			<p>We can easily update our placeholder text for both <strong class="source-inline">Dropdown</strong> components to make it clearer to users:</p>
			<p class="source-code">placeholder="Select a year"</p>
			<p class="source-code">placeholder="Select one or more countries"</p>
			<p>We can make it even more explicit by using the <strong class="source-inline">Label</strong> component from Dash Bootstrap Components, which, as the name suggests, provides a label. These labels can be placed above the dropdowns:</p>
			<p class="source-code">dbc.Label("Year")</p>
			<p class="source-code">dbc.Label("Countries")</p>
			<p>Adding the new options results in the updated messages as shown in <em class="italic">Figure 5.17</em>:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B16780_05_0017.jpg" alt="Figure 5.17 – Dropdowns with placeholder text and labels"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – Dropdowns with placeholder text and labels</p>
			<p>I think it looks easier to use this way. We <a id="_idIndexMarker284"/>are also making it clear which one accepts a single option, and which accepts multiple ones. We can also do the same for the Income Share Distribution section by adding a similar label, Country, and a placeholder, Select a country.</p>
			<p>Our app is now getting bigger, and provides many more options. It's good to take a general look and see how to improve the overall look and feel of the app, make it easier to use, and use a consistent theme across all figures.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Modifying the app's theme</h2>
			<p>We already saw how <a id="_idIndexMarker285"/>easy it is to change the theme of our app, which can be done by providing a list as an argument to the <strong class="source-inline">external_style_sheets</strong> parameter while instantiating the app. You can play around with the available ones, and we can set it to <strong class="source-inline">COSMO</strong>:</p>
			<p class="source-code">app = dash.Dash(__name__,</p>
			<p class="source-code">                <strong class="bold">external_stylesheets=[dbc.themes.COSMO]</strong>)</p>
			<p>This should modify several visual elements of our app.</p>
			<p>Another thing we can consider doing is making our theme consistent with the theme of the charts that we are using. We can set the background color of the app to the same default color used in Plotly's figures. Using the <strong class="source-inline">style</strong> parameter in the top-level <strong class="source-inline">html.Div</strong>, we can set the background color to match that of the default Plotly color: </p>
			<p class="source-code">app.layout = html.Div([</p>
			<p class="source-code">…</p>
			<p class="source-code">], <strong class="bold">style={'backgroundColor': '#E5ECF6'}</strong>)</p>
			<p>One more change is needed to make this complete.</p>
			<p>Plotly's <strong class="source-inline">Figure</strong> object contains two main areas, the "plot" and the "paper" areas. The plot area is the inner rectangle within the <em class="italic">x</em> and <em class="italic">y</em> axes. In all the charts that we produced, this is the area colored light blue (or gray, if you are reading the printed book).</p>
			<p>The bigger rectangle <a id="_idIndexMarker286"/>enclosing the smaller one is the "paper" area. In the charts we have produced so far, it has been colored white. We can also set its color to the same color, making all background colors the same for our app. We simply have to add the following line to the callback functions that generate charts:</p>
			<p class="source-code">fig.layout.paper_bgcolor = '#E5ECF6'</p>
			<p>If we run the app now, we will get some empty figures with a white background for the ones where we did not set default values. For those, we also need to create empty figures, but set the background colors to be consistent with the whole app theme. Doing this is very simple, as we did in <a href="B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Plotly's Figure Objects</em>. The <strong class="source-inline">dcc.Graph</strong> component has a <strong class="source-inline">figure</strong> attribute, to which we can add the empty figures with the desired background colors. These will be modified when users make a selection. Because we have a few instances of those, it's better to create a function that can be used to create such figures whenever we want them. The following code achieves that:</p>
			<p class="source-code">import plotly.graph_objects as go</p>
			<p class="source-code">def make_empty_fig():</p>
			<p class="source-code">    fig = go.Figure()</p>
			<p class="source-code">    fig.layout.paper_bgcolor =  '#E5ECF6'</p>
			<p class="source-code">    fig.layout.plot_bgcolor = '#E5ECF6'</p>
			<p class="source-code">    return fig</p>
			<p>Now, we can <a id="_idIndexMarker287"/>add the call to <strong class="source-inline">make_empty_fig</strong> where required, as you can see in the following example:</p>
			<p class="source-code">dcc.Graph(id='gini_year_barchart',</p>
			<p class="source-code">          figure=<strong class="bold">make_empty_fig()</strong>)</p>
			<p>With this, we have chosen a new overall theme and made sure that we have consistent background colors across all the elements of our app.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Resizing components</h2>
			<p>Another thing we need to <a id="_idIndexMarker288"/>handle is how the resizing of the browser window affects the size and placement of our different components. The figures are responsive by default, but we need to make some decisions for the figures that are placed side by side. In the Gini Index section, we have two such charts, placed in two <strong class="source-inline">dbc.Col</strong> components next to each other. All we have to do is set the desired size for those charts for large-, <strong class="source-inline">lg</strong>, as well as medium-, <strong class="source-inline">md</strong>, sized screens: </p>
			<p class="source-code">dbc.Col([</p>
			<p class="source-code">…</p>
			<p class="source-code">], <strong class="bold">md=12, lg=5</strong>),</p>
			<p>When on a large screen, <strong class="source-inline">lg</strong>, the most likely scenario, each figure will have a size of 5 (out of 12), which is how the screen is split by Bootstrap. You can refer to the discussion on Bootstrap layouts, columns, and rows, as well as its grid system, in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>, if you want a refresher. On medium-sized screens, <strong class="source-inline">md</strong>, the figures will expand to occupy 12 out of 12 columns, which means that they will take the full width of the screen at that size.</p>
			<p>When we started learning about interactivity, we created a simple report at the top of our app. It displays the population of the selected country/region for the year 2010. We can remove this component, as it is very limited in functionality and was mainly used for illustration purposes. This can simply be done by deleting the component, together with the output area underneath it, as well as the callback that handles it.</p>
			<p>As a result of the work we have done in this chapter, you can see in <em class="italic">Figure 5.18</em> what our app now looks like:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B16780_05_0018.jpg" alt="Figure 5.18 – The final layout of the app"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18 – The final layout of the app</p>
			<p>I strongly encourage you to make these changes manually yourself, without looking at the code provided in the repository. I also encourage you to test out other layouts, play with different options, and generate lots of errors!</p>
			<p>Making changes all the time and being in control of your code requires a consistent naming convention of the components, callbacks, and variables. It also helps if you follow a certain logical flow in the organization of your components. We will be doing these things many times, and hopefully you will master these techniques along the way.</p>
			<p>Our app is now looking better, easier to use, and can even be shared with others if you want to. We covered many things in this chapter, taking our app to a new level, so let's recap the things that we covered.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Summary</h1>
			<p>We focused mainly on bar charts in this chapter. We also used <strong class="source-inline">Dropdown</strong> components in several ways. We saw the pros and cons of using horizontal and vertical orientation, and we actually implemented both in our app. We then analyzed the different ways in which multiple bar charts can be displayed together, and we implemented one showing the proportions of a total value. We then explored facets and saw how they enrich our figures and make them flexible and scalable. We also linked that to dropdowns, which allow multiple selections. After making sure that everything is working fine, we gave our app a facelift by choosing a new theme and making sure that all background colors are consistent. We also managed the layout for different screen sizes by setting different sizes for our figures for different screen sizes. A few helpful messages were added to make the app easier to use. Finally, we took a screenshot of the resulting app!</p>
			<p>In the next chapter, we will explore one of the most ubiquitous chart types – the scatter plot. We will also explore how to use it together with sliders that allow users to select and modify values or ranges of values.</p>
		</div>
	</body></html>