<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Selecting Subsets of Data</h1>
                </header>
            
            <article>
                
<p>Every dimension of data in a Series or DataFrame is labeled through an Index object. It is this Index that separates pandas data structures from NumPy's n-dimensional array. Indexes provide meaningful labels for each row and column of data, and pandas users have the ability to select data through the use of these labels. Additionally, pandas allow its users to select data by the integer location of the rows and columns. This dual selection capability, one using labels and the other using integer location, makes for powerful yet confusing syntax to select subsets of data.</p>
<p>Selecting data through the use of labels or integer location is not unique to pandas. Python dictionaries and lists are built-in data structures that select their data in exactly one of these ways. Both dictionaries and lists have precise instructions and limited use-cases for what may be passed to the indexing operator. A dictionary's key (its label) must be an immutable object, such as a string, integer, or tuple. Lists must either use integers or slice objects for selection. Dictionaries can only select one object at a time by passing the key to the indexing operator. In some sense, pandas is combining the ability to select data using integers, as with lists, and labels, as with dictionaries.</p>
<p class="CDPAlignLeft CDPAlign">In this chapter, we will cover the following topics:</p>
<ul>
<li>Selecting Series data</li>
<li>Selecting DataFrame rows</li>
<li>Selecting DataFrame rows and columns simultaneously</li>
<li>Selecting data with both integers and labels</li>
<li>Speeding up<span> </span>scalar<span> </span>selection</li>
<li>Slicing rows lazily</li>
<li>Slicing lexicographically</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting Series data</h1>
                </header>
            
            <article>
                
<p>Series and DataFrames are complex data containers that have multiple attributes that use the indexing operator to select data in different ways. In addition to the indexing operator itself, the <kbd>.iloc</kbd> and <kbd>.loc</kbd> <span>attributes</span> are available and use the indexing operator in their own unique ways. Collectively, these attributes are called the <strong>indexers</strong>.</p>
<div class="packt_infobox">The indexing terminology can get confusing. The term <strong>indexing operator</strong> is used here to distinguish it from the other indexers. It refers to the brackets, <kbd>[]</kbd> directly after a Series or DataFrame. <span>For instance, given a Series <kbd>s</kbd>, you can select data in the following ways: <kbd>s[item]</kbd> and <kbd>s.loc[item]</kbd></span>. The first uses the indexing operator. The second uses the <kbd>.loc</kbd> indexer.</div>
<p>Series and DataFrame indexers allow selection by integer location (like Python lists) and by label (like Python dictionaries). The <kbd>.iloc</kbd> <span>indexer</span> selects only by integer location and works similarly to Python lists. The <kbd>.loc</kbd> <span>indexer</span> selects only by index label, which is similar to how Python dictionaries work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Both <kbd>.loc</kbd> and .<kbd>iloc</kbd> work with Series and DataFrames. This recipe shows how to select Series data by integer location with <kbd>.iloc</kbd> and by label with <kbd>.loc</kbd>. These indexers not only take scalar values but also lists and slices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the college dataset with the institution name as the index, and select a single column as a Series with the indexing operator:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')<br/>&gt;&gt;&gt; city = college['CITY']<br/>&gt;&gt;&gt; city.head()<br/>INSTNM
Alabama A &amp; M University                   Normal
University of Alabama at Birmingham    Birmingham
Amridge University                     Montgomery
University of Alabama in Huntsville    Huntsville
Alabama State University               Montgomery
Name: CITY, dtype: object</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>The <kbd>.iloc</kbd> indexer makes selections only by integer location. Passing an integer to it returns a scalar value:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; city.iloc[3]<br/>Huntsville</pre>
<ol start="3">
<li>To select several different integer locations, pass a list to <kbd>.iloc</kbd>. This returns a Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; city.iloc[[10,20,30]]<br/>INSTNM
Birmingham Southern College                            Birmingham
George C Wallace State Community College-Hanceville    Hanceville
Judson College                                             Marion
Name: CITY, dtype: object</pre>
<ol start="4">
<li>To select an equally spaced partition of data, use slice notation:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; city.iloc[4:50:10]<br/>INSTNM
Alabama State University              Montgomery
Enterprise State Community College    Enterprise
Heritage Christian University           Florence
Marion Military Institute                 Marion
Reid State Technical College           Evergreen
Name: CITY, dtype: object</pre>
<ol start="5">
<li>Now we turn to the <kbd>.loc</kbd> indexer, which selects only with index labels. Passing a single string returns a scalar value:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">&gt;&gt;&gt; city.loc['Heritage Christian University']<br/>Florence</pre>
<ol start="6">
<li>To select several disjoint labels, use a list:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; np.random.seed(1)<br/>&gt;&gt;&gt; labels = list(np.random.choice(city.index, 4))<br/>&gt;&gt;&gt; labels<br/>['Northwest HVAC/R Training Center',
 'California State University-Dominguez Hills',
 'Lower Columbia College',
 'Southwest Acupuncture College-Boulder']<br/><br/>&gt;&gt;&gt; city.loc[labels]<br/>INSTNM<br/>Northwest HVAC/R Training Center                Spokane
California State University-Dominguez Hills      Carson
Lower Columbia College                         Longview
Southwest Acupuncture College-Boulder           Boulder
Name: CITY, dtype: object</pre>
<ol start="7">
<li>To select an equally spaced partition of data, use slice notation. Make sure that the start and stop values are strings. You can use an integer to specify the step size of the slice:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; city.loc['Alabama State University':<br/>             'Reid State Technical College':10]<br/>INSTNM<br/>Alabama State University              Montgomery
Enterprise State Community College    Enterprise
Heritage Christian University           Florence
Marion Military Institute                 Marion
Reid State Technical College           Evergreen
Name: CITY, dtype: object</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The values in a Series are referenced by integers beginning from 0. Step 2 selects the fourth element of the Series with the <kbd>.loc</kbd> indexer. Step 3 passes a three-item integer list to the indexing operator, which returns a Series with those integer locations selected. This feature is an enhancement over a Python list, which is incapable of selecting multiple disjoint items in this manner.</p>
<p>In step 4, slice notation with <kbd>start</kbd>, <kbd>stop</kbd>, and <kbd>step</kbd> values specified is used to select an entire section of a Series.</p>
<p>Steps 5 through 7 replicate steps 2 through 4 with the label-based indexer, <kbd>.loc</kbd>.  The labels must be exact matches of values in the index. To ensure our labels are exact, we choose four labels at random from the index in step 6 and store them to a list before selecting their values as a Series. Selections with the <kbd>.loc</kbd> indexer always include the last element, as seen in step 7.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>When passing a scalar value to the indexing operator, as with step 2 and step 5, a scalar value is returned. When passing a list or slice, as in the other steps, a Series is returned. This returned value might seem inconsistent, but if we think of a Series as a dictionary-like object that maps labels to values, then returning the value makes sense. To select a single item and retain the item in its Series, pass in as a single-item list rather than a scalar value:</p>
<pre>&gt;&gt;&gt; city.iloc[[3]]<br/>INSTNM<br/>University of Alabama in Huntsville    Huntsville<br/>Name: CITY, dtype: object</pre>
<p>Care needs to be taken when using slice notation with <kbd>.loc</kbd>. If the <kbd>start</kbd> index appears after the <kbd>stop</kbd> index, then an empty Series is returned without an exception raised:</p>
<pre>&gt;&gt;&gt; city.loc['Reid State Technical College':<br/>             'Alabama State University':10]<br/>Series([], Name: CITY, dtype: object)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation on indexing (<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html" target="_blank">http://bit.ly/2fdtZWu</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting DataFrame rows</h1>
                </header>
            
            <article>
                
<p>The most explicit and preferred way to select DataFrame rows is with the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers. They are capable of selecting rows or columns independently and simultaneously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe shows you how to select rows from a DataFrame using the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the college dataset, and set the index as the institution name:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')<br/>&gt;&gt;&gt; college.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/094f0eeb-dab6-43fd-8153-7542c88c2be8.png" style="width:63.08em;height:23.00em;"/></div>
<ol start="2">
<li>Pass an integer to the <kbd>.iloc</kbd> <span>indexer</span> to select an entire row at that position:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[60]<br/>CITY                  Anchorage
STABBR                       AK
HBCU                          0
                        ...    
UG25ABV                  0.4386
MD_EARN_WNE_P10           42500
GRAD_DEBT_MDN_SUPP      19449.5
Name: University of Alaska Anchorage, Length: 26, dtype: object</pre>
<ol start="3">
<li>To get the same row as the preceding step, pass the index label to the <kbd>.loc</kbd> indexer:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.loc['University of Alaska Anchorage']<br/>CITY                  Anchorage
STABBR                       AK
HBCU                          0
                        ...    
UG25ABV                  0.4386
MD_EARN_WNE_P10           42500
GRAD_DEBT_MDN_SUPP      19449.5
Name: University of Alaska Anchorage, Length: 26, dtype: object</pre>
<ol start="4">
<li>To select a disjointed set of rows as a DataFrame, pass a list of integers to the <kbd>.iloc</kbd> indexer:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[[60, 99, 3]]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/e7daa02f-de1a-4925-99c9-a5c5df191793.png" style="width:60.50em;height:15.17em;"/></div>
<ol start="5">
<li>The same DataFrame from step 4 may be reproduced using <kbd>.loc</kbd> by passing it a list of the exact institution names:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; labels = ['University of Alaska Anchorage',<br/>              'International Academy of Hair Design',<br/>              'University of Alabama in Huntsville']<br/>&gt;&gt;&gt; college.loc[labels]</pre>
<ol start="6">
<li>Use slice notation with <kbd>.iloc</kbd> to select an entire segment of the data:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[99:102]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/5dd7c6d4-8c2c-4e8d-898e-41d876967360.png" style="width:64.08em;height:16.25em;"/></div>
<ol start="7">
<li>Slice notation also works with the <kbd>.loc</kbd> indexer and is inclusive of the last label:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; start = 'International Academy of Hair Design'<br/>&gt;&gt;&gt; stop = 'Mesa Community College'<br/>&gt;&gt;&gt; college.loc[start:stop]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Passing a scalar value, a list of scalars, or a slice object to the <kbd>.iloc</kbd> or <kbd>.loc</kbd> indexers causes pandas to scan the index labels for the appropriate rows and return them. If a single scalar value is passed, a Series is returned. If a list or slice object is passed, then a DataFrame is returned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In step 5, the list of index labels can be selected directly from the DataFrame returned in step 4 without the need for copying and pasting:</p>
<pre style="padding-left: 30px">&gt;&gt;&gt; college.iloc[[60, 99, 3]].index.tolist()<br/>['University of Alaska Anchorage',
 'International Academy of Hair Design',
 'University of Alabama in Huntsville']</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the <em>Examining the Index object</em> recipe from <a href="a5777e1a-6de5-44f6-b291-429cbceb505f.xhtml" target="_blank">Chapter 12</a>, <em>Index Alignment.</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting DataFrame rows and columns simultaneously</h1>
                </header>
            
            <article>
                
<p>Directly using the indexing operator is the correct method to select one or more columns from a DataFrame. However, it does not allow you to select both rows and columns simultaneously. To select rows and columns simultaneously, you will need to pass both valid row and column selections separated by a comma to either the <kbd>.iloc</kbd> or <kbd>.loc</kbd> indexers.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>The generic form to select rows and columns will look like the following code:</p>
<pre>&gt;&gt;&gt; df.iloc[rows, columns]<br/>&gt;&gt;&gt; df.loc[rows, columns]</pre>
<p>The <kbd>rows</kbd> and <kbd>columns</kbd> <span>variables</span> may be scalar values, lists, slice objects, or boolean sequences.</p>
<div class="packt_infobox">Passing a boolean sequence to the indexers is covered in <a href="9f721370-ae04-4425-aab9-d525335b96b3.xhtml" target="_blank">Chapter 11</a>, <em>Boolean Indexing</em>.</div>
<p>In this recipe, each step shows a simultaneous row and column selection using <kbd>.iloc</kbd> and its exact replication using <kbd>.loc</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the college dataset, and set the index as the institution name. Select the first three rows and the first four columns with slice notation:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')<br/>&gt;&gt;&gt; college.iloc[:3, :4]<br/>&gt;&gt;&gt; college.loc[:'Amridge University', :'MENONLY']</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/791eb470-4192-49a3-9429-1f9223b2eb6b.png" style="width:32.75em;height:8.75em;"/></div>
<ol start="2">
<li>Select all the rows of two different columns:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[:, [4,6]].head()<br/>&gt;&gt;&gt; college.loc[:, ['WOMENONLY', 'SATVRMID']].head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/f80c5155-bf61-4a4a-970d-84ab736b3d2d.png" style="width:26.17em;height:12.83em;"/></div>
<ol start="3">
<li>Select disjointed rows and columns:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[[100, 200], [7, 15]]<br/>&gt;&gt;&gt; rows = ['GateWay Community College',<br/>            'American Baptist Seminary of the West']<br/>&gt;&gt;&gt; columns = ['SATMTMID', 'UGDS_NHPI']<br/>&gt;&gt;&gt; college.loc[rows, columns]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/08e1066e-11d4-4eac-9fbd-799884602e5f.png" style="width:30.42em;height:8.17em;"/></div>
<ol start="4">
<li>Select a single scalar value:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[5, -4]<br/>&gt;&gt;&gt; college.loc['The University of Alabama', 'PCTFLOAN']<br/>-.401</pre>
<ol start="5">
<li>Slice the rows and select a single column:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[90:80:-2, 5]<br/>&gt;&gt;&gt; start = 'Empire Beauty School-Flagstaff'<br/>&gt;&gt;&gt; stop = 'Arizona State University-Tempe'<br/>&gt;&gt;&gt; college.loc[start:stop:-2, 'RELAFFIL']<br/>INSTNM
Empire Beauty School-Flagstaff     0
Charles of Italy Beauty College    0
Central Arizona College            0
University of Arizona              0
Arizona State University-Tempe     0
Name: RELAFFIL, dtype: int64</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>One of the keys to selecting rows and columns simultaneously is to understand the use of the comma in the brackets. The selection to the left of the comma always selects rows based on the row index. The selection to the right of the comma always selects columns based on the column index.</p>
<p>It is not necessary to make a selection for both rows and columns simultaneously. Step 2 shows how to select all the rows and a subset of columns. The colon represents a slice object that simply returns all the values for that dimension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>When selecting a subset of rows, along with all the columns, it is not necessary to use a colon following a comma. The default behavior is to select all the columns if there is no comma present. The previous recipe selected rows in exactly this manner. You can, however, use a colon to represent a slice of all the columns. The following lines of code are equivalent:</p>
<pre>&gt;&gt;&gt; college.iloc[:10]<br/>&gt;&gt;&gt; college.iloc[:10, :]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting data with both integers and labels</h1>
                </header>
            
            <article>
                
<p>The <kbd>.iloc</kbd> and <kbd>.loc</kbd> <span>indexers</span> each select data by either integer or label location but are not able to handle a combination of both input types at the same time. In earlier versions of pandas, another indexer, <kbd>.ix</kbd>, was available to select data by both integer and label location. While this conveniently worked for those specific situations, it was ambiguous by nature and was a source of confusion for many pandas users. The <kbd>.ix</kbd> indexer has subsequently been deprecated and thus should be avoided.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Before the <kbd>.ix</kbd> deprecation, it was possible to select the first five rows and the columns of the college dataset from <kbd>UGDS_WHITE</kbd> through <kbd>UGDS_UNKN</kbd> using <kbd>college.ix[:5, 'UGDS_WHITE':'UGDS_UNKN']</kbd>. This is now impossible to do directly using <kbd>.loc</kbd> or <kbd>.iloc</kbd>. The following recipe shows how to find the integer location of the columns and then use <kbd>.iloc</kbd> to complete the selection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the college dataset and assign the institution name (<kbd>INSTNM</kbd>) as the index:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')</pre>
<ol start="2">
<li>Use the Index method <kbd>get_loc</kbd> to find the integer position of the desired columns:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; col_start = college.columns.get_loc('UGDS_WHITE')<br/>&gt;&gt;&gt; col_end = college.columns.get_loc('UGDS_UNKN') + 1<br/>&gt;&gt;&gt; col_start, col_end</pre>
<ol start="3">
<li>Use <kbd>col_start</kbd> and <kbd>col_end</kbd> to select columns by integer location using <kbd>.iloc</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.iloc[:5, col_start:col_end]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/b14e2086-ab61-424c-b881-db682c2fe4c7.png" style="width:63.92em;height:14.08em;"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Step 2 first retrieves the column index through the <kbd>columns</kbd> attribute. Indexes have a <kbd>get_loc</kbd> method, which accepts an index label and returns its integer location. We find both the start and end integer locations for the columns that we wish to slice. We add one because slicing with <kbd>.iloc</kbd> is exclusive of the last item. Step 3 uses slice notation with the rows and columns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We can do a very similar operation to make <kbd>.loc</kbd> work with a mixture of integers and positions. The following shows how to select the 10th through 15th (inclusive) rows, along with columns <kbd>UGDS_WHITE</kbd> through <kbd>UGDS_UNKN</kbd>:</p>
<pre>&gt;&gt;&gt; row_start = df_college.index[10]<br/>&gt;&gt;&gt; row_end = df_college.index[15]<br/>&gt;&gt;&gt; college.loc[row_start:row_end, 'UGDS_WHITE':'UGDS_UNKN']</pre>
<p>Doing this same operation with <kbd>.ix</kbd> (which is deprecated, so don't do this) would look like this:</p>
<pre>&gt;&gt;&gt; college.ix[10:16, 'UGDS_WHITE':'UGDS_UNKN']</pre>
<p>It is possible to achieve the same results by chaining <kbd>.loc</kbd> and <kbd>.iloc</kbd> together, but chaining indexers is typically a bad idea:</p>
<pre>&gt;&gt;&gt; college.iloc[10:16].loc[:, 'UGDS_WHITE':'UGDS_UNKN']</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Speeding up scalar selection</h1>
                </header>
            
            <article>
                
<p>Both the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers are capable of selecting a single element, a scalar value, from a Series or DataFrame. However, there exist the indexers, <kbd>.iat</kbd> and <kbd>.at</kbd>, which respectively achieve the same thing at faster speeds. Like <kbd>.iloc</kbd>, the <kbd>.iat</kbd> indexer uses integer location to make its selection and must be passed two integers separated by a comma. Similar to <kbd>.loc</kbd>, the <kbd>.at</kbd> index uses labels to make its selection and must be passed an index and column label separated by a comma.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe is valuable if computational time is of utmost importance. It shows the performance improvement of <kbd>.iat</kbd> and <kbd>.at</kbd> over <kbd>.iloc</kbd> and <kbd>.loc</kbd> when using scalar selection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the <kbd>college</kbd> scoreboard dataset with the institution name as the index. Pass <span>a college name and column name to</span> <kbd>.loc</kbd> in order to select a scalar value:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')<br/>&gt;&gt;&gt; cn = 'Texas A &amp; M University-College Station'<br/>&gt;&gt;&gt; college.loc[cn, 'UGDS_WHITE']<br/>.661</pre>
<ol start="2">
<li>Achieve the same result with <kbd>.at</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.at[cn, 'UGDS_WHITE']<br/>.661</pre>
<ol start="3">
<li>Use the <kbd>%timeit</kbd> magic command to find the difference in speed:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; %timeit college.loc[cn, 'UGDS_WHITE']<br/>8.97 µs ± 617 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)<br/><br/>&gt;&gt;&gt; %timeit college.at[cn, 'UGDS_WHITE']<br/>6.28 µs ± 214 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</pre>
<ol start="4">
<li>Find the integer locations of the preceding selections and then time the difference between <kbd>.iloc</kbd> and <kbd>.iat</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; row_num = college.index.get_loc(cn)<br/>&gt;&gt;&gt; col_num = college.columns.get_loc('UGDS_WHITE')<br/>&gt;&gt;&gt; row_num, col_num<br/>(3765, 10)<br/><br/>&gt;&gt;&gt; %timeit college.iloc[row_num, col_num]<br/>9.74 µs ± 153 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</pre>
<pre style="padding-left: 60px">&gt;&gt;&gt; %timeit college.iat[row_num, col_num]<br/>7.29 µs ± 431 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The scalar indexers, <kbd>.iat</kbd> and <kbd>.at</kbd>, only accept scalar values. They fail if anything else is passed to them. They are drop-in replacements for <kbd>.iloc</kbd> and <kbd>.loc</kbd> when doing scalar selection. The <kbd>timeit</kbd> magic command times entire blocks of code when preceded by two percentage signs and a single time when preceded by one percentage sign. It shows that about 2.5 microseconds are saved on average by switching to the scalar indexers. This might not be much but can add up quickly if scalar selection is repeatedly done in a program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Both <kbd>.iat</kbd> and <kbd>.at</kbd> work with Series as well. Pass them a single scalar value, and they will return a scalar:</p>
<pre>&gt;&gt;&gt; state = college['STABBR']   # Select a Series<br/>&gt;&gt;&gt; state.iat[1000]<br/>'IL'<br/><br/>&gt;&gt;&gt; state.at['Stanford University']<br/>'CA'</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slicing rows lazily</h1>
                </header>
            
            <article>
                
<p>The previous recipes in this chapter showed how the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers were used to select subsets of both Series and DataFrames in either dimension. A shortcut to select the rows exists with just the indexing operator itself. This is just a shortcut to show additional features of pandas, but the primary function of the indexing operator is actually to select DataFrame columns. If you want to select rows, it is best to use <kbd>.iloc</kbd> or <kbd>.loc</kbd>, as they are unambiguous.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we pass a slice object to both the Series and DataFrame indexing operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the college dataset with the institution name as the index and then select every other row from index 10 to 20:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')<br/>&gt;&gt;&gt; college[10:20:2]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/8bb0dd64-541a-437e-aedb-323fbe9b57d4.png" style="width:55.92em;height:19.83em;"/></div>
<ol start="2">
<li>This same slicing exists with Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; city = college['CITY']<br/>&gt;&gt;&gt; city[10:20:2]<br/>INSTNM
Birmingham Southern College              Birmingham
Concordia College Alabama                     Selma
Enterprise State Community College       Enterprise
Faulkner University                      Montgomery
New Beginning College of Cosmetology    Albertville
Name: CITY, dtype: object</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Both Series and DataFrames can slice by label as well with just the indexing operator:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; start = 'Mesa Community College'<br/>&gt;&gt;&gt; stop = 'Spokane Community College'<br/>&gt;&gt;&gt; college[start:stop:1500]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/84ef652c-f107-4bd0-aec4-8404794a1d74.png" style="width:60.58em;height:16.00em;"/></div>
<ol start="4">
<li>Here is the same slice by label with a Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; city[start:stop:1500]<br/>INSTNM
Mesa Community College                            Mesa
Hair Academy Inc-New Carrollton         New Carrollton
National College of Natural Medicine          Portland
Name: CITY, dtype: object</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The indexing operator changes behavior based on what type of object is passed to it. The following pseudocode outlines how DataFrame indexing operator handles the object that it is passed:</p>
<pre>&gt;&gt;&gt; df[item]  # Where `df` is a DataFrame and item is some object<br/><br/>If item is a string then<br/>    Find a column name that matches the item exactly<br/>    Raise KeyError if there is no match<br/>    Return the column as a Series<br/><br/>If item is a list of strings then<br/>    Raise KeyError if one or more strings in item don't match columns<br/>    Return a DataFrame with just the columns in the list</pre>
<pre>If item is a slice object then<br/>   Works with either integer or string slices<br/>   Raise KeyError if label from label slice is not in index<br/>   Return all ROWS that are selected by the slice<br/><br/>If item is a list, Series or ndarray of booleans then<br/>   Raise ValueError if length of item not equal to length of DataFrame<br/>   Use the booleans to return only the rows with True in same location</pre>
<p>The preceding logic covers all the most common cases but is not an exhaustive list. The logic for a Series is slightly different and actually more complex than it is for a DataFrame. Due to its complexity, it is probably a good idea to avoid using just the indexing operator itself on a Series and instead use the explicit <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers.</p>
<div class="packt_tip">One acceptable use case of the Series indexing operator is when doing boolean indexing. See <a href="7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml" target="_blank">Chapter 12</a>, <em>Index Alignment</em> for more details.</div>
<div>
<p>I titled this type of row slicing in this section as <em>lazy</em>, as it does not use the more explicit <kbd>.iloc</kbd> or <kbd>.loc</kbd>. Personally, I always use these indexers whenever slicing rows, as there is never a question of exactly what I am doing.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is important to be aware that this lazy slicing does not work for columns, just for DataFrame rows and Series. It also cannot be used to select both rows and columns simultaneously. Take, for instance, the following code, which attempts to select the first ten rows and two columns:</p>
<pre>&gt;&gt;&gt; college[:10, ['CITY', 'STABBR']]<br/>TypeError<span>: unhashable type: 'slice'<br/></span></pre>
<p>To make a selection in this manner, you need to use <kbd>.loc</kbd> or <kbd>.iloc</kbd>. Here is one possible way that selects all the institution labels first and then uses the label-based indexer <kbd>.loc</kbd>:</p>
<pre>&gt;&gt;&gt; first_ten_instnm = college.index[:10]<br/>&gt;&gt;&gt; college.loc[first_ten_instnm, ['CITY', 'STABBR']]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slicing lexicographically</h1>
                </header>
            
            <article>
                
<p>The <kbd>.loc</kbd> indexer typically selects data based on the exact string label of the index. However, it also allows you to select data based on the lexicographic order of the values in the index. Specifically, <kbd>.loc</kbd> allows you to select all rows with an index lexicographically using slice notation. This works only if the index is sorted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will first sort the index and then use slice notation inside the <kbd>.loc</kbd> indexer to select all rows between two strings.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Read in the college dataset, and set the institution name as the index:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv', index_col='INSTNM')</pre>
<ol start="2">
<li>Attempt to select all colleges with names lexicographically between <kbd>'Sp'</kbd> and <kbd>'Su'</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.loc['Sp':'Su']<br/><span class="ansi-red-fg">KeyError</span>: 'Sp'</pre>
<ol start="3">
<li>As the index is not sorted, the preceding command fails. Let's go ahead and sort the index:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = college.sort_index()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/eaefaacf-2f58-4a04-ae64-7f9a6321af9e.png" style="width:51.75em;height:20.17em;"/></div>
<ol start="4">
<li>Now, let's rerun the same command from step 2:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college.loc['Sp':'Su']</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/2fe10453-8789-4016-80eb-f99bf85cea0e.png" style="width:50.00em;height:24.83em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The normal behavior of <kbd>.loc</kbd> is to make selections of data based on the exact labels passed to it. It raises a <kbd>KeyError</kbd> when these labels are not found in the index. However, one special exception to this behavior exists whenever the index is lexicographically sorted, and a slice is passed to it. Selection is now possible between the <kbd>start</kbd> and <kbd>stop</kbd> labels of the slice, even if they are not exact values of the index.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>With this recipe, it is easy to select colleges between two letters of the alphabet. For instance, to select all colleges that begin with the letter <kbd>D</kbd> through <kbd>S</kbd>, you would use <kbd>college.loc['D':'T']</kbd>. Slicing like this is still inclusive of the last index so this would technically return a college with the exact name <kbd>T</kbd>.</p>
<p>This type of slicing also works when the index is sorted in the opposite direction. You can determine which direction the index is sorted with the index attribute, <kbd>is_monotonic_increasing</kbd> or <kbd>is_monotonic_decreasing</kbd>. Either of these must be <kbd>True</kbd> in order for lexicographic slicing to work. For instance, the following code lexicographically sorts the index from <kbd>Z</kbd> to <kbd>A</kbd>:</p>
<pre>&gt;&gt;&gt; college = college.sort_index(ascending=False)<br/>&gt;&gt;&gt; college.index.is_monotonic_decreasing<br/>True<br/>&gt;&gt;&gt; college.loc['E':'B']</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/ff1d8e8c-7a7e-4812-9426-1515879ecb40.png" style="width:47.42em;height:26.92em;"/></div>
<div class="packt_infobox"><span>Python sorts all capital letters before lowercase and all integers before capital letters.</span></div>


            </article>

            
        </section>
    </body></html>