<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Special Data Operations in pandas</h1>
                </header>
            
            <article>
                
<p class="mce-root">pandas has an array of special operators for generating, aggregating, transforming, reading, and writing data from and to a variety of data types, such as number, string, date, timestamp, and time series. The basic operators in pandas were introduced in the previous chapter. In this chapter, we will continue that discussion and elaborate on the methods, syntax, and usage of some of these operators.</p>
<p>Reading this chapter will allow you to perform the following tasks with confidence:</p>
<ul>
<li>Writing custom functions and applying them on a column or an entire DataFrame</li>
<li>Understanding the nature of missing values and handling them</li>
<li>Transforming and performing calculations on series using functions</li>
<li>Miscellaneous numeric operations on data </li>
</ul>
<p>Let's delve into it right away. For the most part, we will generate our own data to demonstrate the methods.</p>
<p>The following topics will be covered in this chapter: </p>
<ul>
<li>Writing and applying one-liner custom functions</li>
<li>Handling missing values</li>
<li>A survey of methods on series</li>
<li>pandas string methods</li>
<li>Binary operations on DataFrames and series</li>
<li>Binning values</li>
<li>Using mathematical methods on DataFrames</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing and applying one-liner custom functions</h1>
                </header>
            
            <article>
                
<p>Python provides lambda functions, which are a way to write one-liner custom functions so that we can perform certain tasks on a DataFrame's column(s) or the entire DataFrame. Lambda functions are similar to the traditional functions that are defined using the <kbd>def</kbd> keyword but are more elegant, are more amenable to apply on DataFrame columns, and have lucid and crisp syntax, much like a list comprehension for implementing for loops on lists. Let's look at how lambda functions are defined and applied.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">lambda and apply</h1>
                </header>
            
            <article>
                
<p>In order to see how the <kbd>lambda</kbd> keyword can be used, we need to create some data. We'll create data containing date columns. Handling date columns is a topic in itself, but we'll get a brief glimpse of this process here.</p>
<p>In the following code, we are creating two date columns:</p>
<ul>
<li><strong>Start Date</strong>: A sequence of 300 consecutive days starting from 2016-01-15</li>
<li><strong>End Date</strong>: A sequence of 300 days taken randomly from any day between 2010 and 2025</li>
</ul>
<p>Some date/time methods have been used to create these dates in the following code block. Please take note of them and ensure that you understand them:</p>
<pre>### Importing required libraries<br/>import datetime<br/>import pandas as pd<br/>from random import randint<br/><br/>### Creating date sequence of 300 (periods=300) consecutive days (freq='D') starting from 2016-01-15<br/>D1=pd.date_range('2016-01-15',periods=300,freq='D')<br/><br/>### Creating a date sequence with of 300 days with day (b/w 1-30), month (b/w 1-12) and year (b/w 2010-2025) chosen at random<br/>date_str=[]<br/>for i in range(300):<br/>   date_str1=str(randint(2010,2025))+'-'+str(randint(1,30))+'-            '+str(randint(3,12))<br/>    date_str.append(date_str1)<br/>D2=date_str<br/><br/>### Creating a dataframe with two date sequences and call them as Start Date and End Date<br/>Date_frame=pd.DataFrame({'Start Date':D1,'End Date':D2})<br/>Date_frame['End Date'] = pd.to_datetime(Date_frame['End Date'], format='%Y-%d-%m')</pre>
<p>The output DataFrame has two columns, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/68717efc-f9b8-48fd-ad2f-4b567e9d8b07.png" style="width:15.42em;height:13.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output DataFrame with <strong>Start Date</strong> and <strong>End</strong> <strong>Date</strong></div>
<p>Using this data, we will create some lambda functions to find the following:</p>
<ul>
<li>Number of days between today and start date or end date</li>
<li>Number of days between the start date and end date</li>
<li>Days in the start date or end date that come before a given date</li>
</ul>
<p>In the following code block, we have written the lambda functions carry out these tasks:</p>
<pre>f1=lambda x:x-datetime.datetime.today()<br/>f2=lambda x,y:x-y<br/>f3=lambda x:pd.to_datetime('2017-28-01', format='%Y-%d-%m')&gt;x</pre>
<p>Note how <kbd>x</kbd> and <kbd>y</kbd> have been used as placeholder arguments, that is, the parameters of the functions. While applying these functions to a column of data, these placeholders are replaced with the column name.</p>
<p>Lambda just helps to define a function. We need to call these functions with the actual arguments to execute these functions. Let's see how this is done. For example, to execute the functions we defined previously, we can do the following:</p>
<pre>Date_frame['diff1']=Date_frame['End Date'].apply(f1)<br/>Date_frame['diff2']=f2(Date_frame['Start Date'],Date_frame['End Date'])<br/>Date_frame['Before 28-07-17']=Date_frame['End Date'].apply(f3)</pre>
<p>The following will be the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99793a3c-26f8-4d1a-a585-27f467c880d2.png" style="width:25.17em;height:8.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Output DataFrame with calculated fields on the date columns</div>
<p>It should be noted that these functions can be called like so:</p>
<ul>
<li><strong>Like simple functions</strong>: With a function name and required argument</li>
<li><strong>With the apply method</strong>: The DataFrame column name for this to be applied on, followed by <kbd>apply</kbd>, which takes a function name as an argument</li>
</ul>
<p>Instead of <kbd>apply</kbd>, in this case, <kbd>map</kbd> would also work. Try the following and compare the results of <kbd>diff1</kbd> and <kbd>diff3</kbd>. They should be the same:</p>
<pre>Date_frame['diff3']=Date_frame['End Date'].map(f1)</pre>
<p>There are three related methods that perform similar kinds of work with subtle differences:</p>
<table style="border-collapse: collapse;width: 100%" class="MsoTable15Plain2" border="1">
<tbody>
<tr>
<td>
<p class="CDPAlignCenter CDPAlign"><strong>Name</strong></p>
</td>
<td>
<p><strong>What does it do?</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>map</kbd></p>
</td>
<td>
<p>Applies a function over a column or a list of columns.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>apply</kbd></p>
</td>
<td>
<p>Applies a function over a column, row, or a list of columns or rows.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>applymap</kbd></p>
</td>
<td>
<p class="CDPAlignLeft CDPAlign">Applies a function over the entire DataFrame, that is, each cell. Will work if the function is executable on each column.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Some use cases where these methods are very useful are as follows.</p>
<p>Suppose each row in a dataset represents daily sales of an SKU for a retail company for a year. Each column represents an SKU. We'll call this data <kbd>sku_sales</kbd>. Let's get started:</p>
<ol>
<li>To find the annual sales of each SKU, we will use the following code:</li>
</ol>
<pre style="padding-left: 60px">sku_sales.apply(sum,axis=0) # axis=0 represents summing across rows</pre>
<ol start="2">
<li>To find the daily sales across each SKU for each day, we will use the following code:</li>
</ol>
<pre style="padding-left: 60px">sku_sales.apply(sum,axis=1) # axis=1 represents summing across columns</pre>
<ol start="3">
<li>To find the mean daily sales for <kbd>SKU1</kbd> and <kbd>SKU2</kbd>, we will use the following code:</li>
</ol>
<pre style="padding-left: 60px">sku_sales[['SKU1','SKU2']].map(mean)</pre>
<ol start="4">
<li>To find the mean and standard deviation of daily sales for all SKUs, we will use the following code:</li>
</ol>
<pre style="padding-left: 60px">sku_sales.applymap(mean)<br/>sku_sales.applymap(sd)</pre>
<p><span><span>N</span></span>ow, you will be able to write and apply one-liner custom Lambda functions. Now, we'll look into how missing values can be handled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling missing values</h1>
                </header>
            
            <article>
                
<p>Missing values and NANs are commonplace occurrences in a dataset and need to be taken care of before data can be put to any use. We will look into various sources of missing values and the different types, as well as how to handle them in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sources of missing values</h1>
                </header>
            
            <article>
                
<p>A missing value can enter a dataset because of or during the following processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data extraction </h1>
                </header>
            
            <article>
                
<p>This entails the data that's available but we missed during its extraction from a source. It deals with engineering tasks such as the following:</p>
<ul>
<li>Scraping from a website</li>
<li>Querying from a database</li>
<li>Extracting from flat files</li>
</ul>
<p>There can be many sources of missing values, some of which are as follows:</p>
<ul>
<li>Regular expressions resulting in the wrong or non-unique results</li>
<li>Wrong query</li>
<li>A different data type storage</li>
<li>Incomplete download</li>
<li>Incomplete processing</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data collection </h1>
                </header>
            
            <article>
                
<p>This entails the data points that are not available or are difficult to collect. Suppose you are surveying 100,000 people for the type of electric car they own. In this case, if we encounter someone who doesn't own an electric car, we would have a missing value for that person's car type.</p>
<p>Missing values originating because of data extraction, in theory, can be rectified if we are able to identify the issue that led to the missing value and rerun the extraction process. Missing values originating from data collection issues are difficult to rectify.</p>
<p>How do you know your data has missing values? The easiest way to find this out is to run a summary of the dataset, which gives a count of rows as well. Since the rows containing missing values don't get counted, this count will be lower for columns containing a missing value. Take a look at the following diagram, which shows a summary of the famous <kbd>titanic</kbd> dataset, for an illustration of this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/00decef1-d9b5-4618-b122-43a23572fc8b.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Data summary table showing the differences in the count of columns, indicating missing values</div>
<p>The <strong>age</strong> and <strong>body</strong> columns have missing values as they have fewer rows than the others.</p>
<p>It is of prime importance to take care of missing values because they propagate the missing values to the results of numeric operations and can lead to incorrect interpretations of data. They don't allow many numeric computations to run. They may also lead to an incorrect hypothesis if only a sample of the data gets used.</p>
<p>There are other ways in which the origin of missing values can be classified. Let's go over them now.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data missing at random </h1>
                </header>
            
            <article>
                
<p>Here, there is no particular reason why the data may be missing. Taking the previous example of electric cars, a missing car type is the case of data missing at random.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data not missing at random </h1>
                </header>
            
            <article>
                
<p>In this case, there may be a particular reason why data may be missing. Continuing with the same example, suppose among the people who have cars, we have some license plate numbers missing in a certain pocket where they use a fancy font on their license plate and the OCR software is unable to decipher it properly and returns a missing value. This is a case of data not missing at random.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different types of missing values</h1>
                </header>
            
            <article>
                
<p>The following are different types of missing values:</p>
<ul>
<li><strong><span>Not a Number</span></strong> (<strong>NaN</strong>): NaN is a placeholder for missing values for any data type. These can be created using <kbd>numpy.nan</kbd>. NaNs that are created using <kbd>numpy.nan</kbd> can be assigned to a nullable integer datatype. The missing value of an integer type is saved as a NaN. It is the default identifier of a missing value in Python.</li>
<li><strong>NA</strong><span>: NA comes mostly from R, where NA is an identifier for a missing value.</span></li>
<li><strong>NaT</strong><span>: This is equivalent to a NaN for timestamp data points.</span></li>
<li><strong>None</strong><span>: This represents missing values of data types other than numeric.</span></li>
<li><strong>Null</strong><span>: This originates when a function doesn't return a value or if the value is undefined.</span></li>
<li><strong>Inf</strong><span>: <strong>Inf</strong> is <strong>infinity</strong>—<span>a</span> value that is greater than any other value. <kbd>inf</kbd> is, therefore, smaller than any other value. It is generated by all the calculations, leading to very large or very small values. Often, we need to treat <kbd>inf</kbd> as a missing value. This can be done by specifying the following options in</span> <kbd>pandas</kbd><span>:</span></li>
</ul>
<pre style="padding-left: 60px">pandas.options.mode.use_inf_as_na = True</pre>
<p>A placeholder infinity variable can also be generated for comparison purposes, as shown in the following example:</p>
<pre>import math<br/>test = math.inf<br/>test&gt;pow(10,10) #Comparing whether Inf is larger than 10 to the power 10</pre>
<p>It returns <kbd>True</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous analysis of missing values</h1>
                </header>
            
            <article>
                
<p>To get a sense of how mad the missing value problem is, you may want to find out about the following information:</p>
<ul>
<li>How many cells in a column have a missing value</li>
<li>Which cells in a column have a missing value</li>
<li>How many columns have missing values</li>
</ul>
<p>These tasks can be performed as follows:</p>
<ul>
<li>Finding cells that have missing values:</li>
</ul>
<pre style="padding-left: 60px">pd.isnull(data['body']) <em>#</em>returns TRUE if a cell has missing values<br/>pd.notnull(data['body']) <em>#</em>returns TRUE if a cell doesn't have missing values</pre>
<ul>
<li>Finding the number of missing values in a column:</li>
</ul>
<pre style="padding-left: 60px">pd.isnull(data['body']).values.ravel().sum() #returns the total number of missing values<br/>pd.nottnull(data['body']).values.ravel().sum()#returns the total number of non-missing values</pre>
<p>The third one has been left as an exercise for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strategies for handling missing values</h1>
                </header>
            
            <article>
                
<p>The following are the major strategies for handling missing values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deletion </h1>
                </header>
            
            <article>
                
<p><span>This will delete the entire row or column that contains the missing value.</span></p>
<p>Deletion leads to data loss and is not recommended unless there is no other way out.</p>
<p>Deletion can be performed as follows:</p>
<ul>
<li>Dropping all the rows where all the cells have missing values:</li>
</ul>
<pre style="padding-left: 60px">data.dropna(axis=0,how='all')# axis=0 means along rows</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li>Dropping all the rows where any of the cells have missing values:</li>
</ul>
<pre style="padding-left: 60px">data.dropna(axis=0,how='any')</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imputation</h1>
                </header>
            
            <article>
                
<p>This replaces the missing value with a number that makes sense.</p>
<p>There are various ways in which imputation can be performed. Some of them are as follows:</p>
<ul>
<li>Imputing all the missing values in a dataset with 0:</li>
</ul>
<pre style="padding-left: 60px">data.fillna(0)</pre>
<ul>
<li><span>Imputing </span>all the missing values with specified text:</li>
</ul>
<pre style="padding-left: 60px">data.fillna('text')</pre>
<ul>
<li><span>Imputing </span>only the missing values in the <kbd>body</kbd> column with 0:</li>
</ul>
<pre style="padding-left: 60px">data['body'].fillna(0)</pre>
<ul>
<li><span>Imputing </span>with a mean of non-missing values:</li>
</ul>
<pre style="padding-left: 60px">data['age'].fillna(data['age'].mean())</pre>
<ul>
<li><span>Imputing </span>with a forward fill <span>– </span>this works especially well for time series data. Here, a missing value is replaced with the value in the previous row (period):</li>
</ul>
<pre style="padding-left: 60px">data['age'].fillna(method='ffill')</pre>
<p style="padding-left: 60px">The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1789 image-border" src="assets/347e1fb1-2255-4b2b-9b33-601c5c077b8a.png" style="width:9.50em;height:12.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output DataFrame with missing values imputed with the forward fill method</div>
<ul>
<li>Imputing with a backward fill <span>– </span>this works especially well for time series data. Here, a missing value is replaced with the value in the previous row (period). You can control the number of rows that get filled after the first NaN using <kbd>pad</kbd> options. <kbd>Pad=1</kbd> means only 1 row will be filled forward or backward:</li>
</ul>
<pre style="padding-left: 60px">data['age'].fillna(method='backfill')</pre>
<p style="padding-left: 60px">The following is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1790 image-border" src="assets/c03ad3b9-4d2a-47d6-8170-f63193c5a7fb.png" style="width:12.00em;height:16.33em;"/></div>
<div class="mce-root CDPAlignCenter packt_figref CDPAlign">Output DataFrame with missing values imputed with the backward fill method</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interpolation </h1>
                </header>
            
            <article>
                
<p>Interpolation is a technique that uses two endpoints at the extremes of consecutive missing values to create a rough mathematical relationship to fill the missing values. By default, it does a linear interpolation (which assumes a linear relationship between data points), but there are many more methods, such as polynomial, spline, quadratic, and Akima (which assumes a polynomial or piece-wise polynomial relationship).</p>
<p>The <kbd>interpolate</kbd> method can be applied to a series or all the columns of a DataFrame directly:</p>
<pre>import numpy as np<br/>import pandas as pd<br/>A=[1,3,np.nan,np.nan,11,np.nan,91,np.nan,52]<br/>pd.Series(A).interpolate()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0f3d54e8-c4af-4915-8f49-f2d5f005c013.png" style="width:7.50em;height:10.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output DataFrame with missing values filled using simple interpolation</div>
<p>Instead, other methods, such as <kbd>spline</kbd>, can be used, which assume a piece-wise polynomial relationship:</p>
<pre style="padding-left: 30px">pd.Series(A).interpolate(method='spline',order=2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a9a24e57-a9a7-4da8-bb6b-a92e7c1bfc4b.png" style="width:7.50em;height:10.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output DataFrame with missing values filled using spline interpolation</div>
<p>Similarly, polynomial interpolation can be done like so:</p>
<pre style="padding-left: 30px">pd.Series(A).interpolate(method='polynomial',order=2)</pre>
<p>A different column can be created for each interpolation method in the same DataFrame to compare their results, as shown here:</p>
<pre style="padding-left: 30px">#Needed for generating plot inside Jupyter notebook<br/>%matplotlib inline<br/>#Setting seed for regenerating the same random number<br/>np.random.seed(10)<br/>#Generate Data<br/>A=pd.Series(np.arange(1,100,0.5)**3+np.random.normal(5,7,len(np.arange(1,100,0.5))))<br/>#Sample random places to introduce missing values<br/>np.random.seed(5)<br/>NA=set([np.random.randint(1,100) for i in range(25)])<br/>#Introduce missing values<br/>A[NA]=np.nan<br/>#Define the list of interpolation methods<br/>methods=['linear','quadratic','cubic']<br/>#Apply the interpolation methods and create a DataFrame <br/>df = pd.DataFrame({m: A.interpolate(method=m) for m in methods})<br/>#Find the mean of each column (each interpolation method)<br/>df.apply(np.mean,axis=0)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d5242e9-dccb-4806-8ca4-ba91c5ece93c.png" style="width:15.08em;height:5.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Comparing mean values after interpolating using different methods</div>
<p>As we can see, the means are slightly different for each column because separate interpolation methods were used.</p>
<p>You can also check the values where interpolations were made to see how different/similar they are. This can be done as follows:</p>
<pre>np.random.seed(5)<br/>NA1=[np.random.randint(1,100) for i in range(25)]<br/>df.iloc[NA1,:]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">KNN </h1>
                </header>
            
            <article>
                
<p><strong>K-nearest neighbors</strong> (<strong><span>KNN</span></strong>) is an unsupervised locality-based regression and classification method. It considers each row of data as a point in n-dimensional space and finds k similar (neighboring) points based on their distance (for example, Euclidean for numeric data and Hamming for categorical data). To find the value for that row and that column of data, it takes an average of all its neighboring rows for that column and assigns the average as a value.</p>
<p>To summarize, it can be said that it defines a locality around a point and calculates a local average instead of a global average. This makes sense most of the time and is used instead of the global average because neighborhood behavior is a better approximator of the behavior of a sample point.</p>
<p>Because of this property, KNN can be used for imputing missing values. The intuition is that missing value should have a value similar to its neighboring points. It is a local imputation method, in contrast with the <kbd>fillna</kbd> method, which is a global method.</p>
<p><kbd>kNeighborsClassifier</kbd> or <kbd>kNeighborsRegressor</kbd> from scikit-learn can be used for KNN and using the results for imputation. The following is an illustrated example where the following occurs, in order:</p>
<ol>
<li>Sample training data is generated.</li>
<li>NaNs are introduced in the same data.</li>
<li>A KNN model is fit on the sample training data.</li>
<li>The fitted model is used to predict/impute the missing values.</li>
</ol>
<p>This is represented in the following code block:</p>
<pre>#Creating training dataset<br/>A=np.random.randint(2,size=100)<br/>B=np.random.normal(7,3,100)<br/>C=np.random.normal(11,4,100)<br/>X=(np.vstack((A,B,C))).T<br/><br/>#Creating testing data by replacing column A (outcome variable) with NaNs<br/>X_with_nan = np.copy(X)<br/>X_with_nan[:,0]=np.nan<br/><br/># Load libraries<br/>import numpy as np<br/>from sklearn.neighbors import KNeighborsClassifier<br/><br/># Train KNN learner<br/>clf = KNeighborsClassifier(3, weights='uniform')<br/>trained_model = clf.fit(X[:,1:], X[:,0])<br/><br/>#Predicting/Imputing on test dataset<br/>imputed_values = trained_model.predict(X_with_nan[:,1:])<br/>imputed_values</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can print <kbd>A</kbd> and <kbd>imputed_values</kbd> to see the difference between them or to assess how accurately the values were imputed. The following screenshot shows the actual values of column A:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1592 image-border" src="assets/bddb164e-43c2-423e-aacf-99917397f62e.png" style="width:34.50em;height:5.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Actual values of column A</div>
<p>The following screenshot shows <kbd>imputed_values</kbd> of column A:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1593 image-border" src="assets/c113b7b4-23c5-4733-b36c-6ae72fa8fe93.png" style="width:34.50em;height:6.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Imputed values of column A</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A survey of methods on series</h1>
                </header>
            
            <article>
                
<p>Let's use the following DataFrame to understand some methods and functions that can be used with a series:</p>
<pre>sample_df = pd.DataFrame([["Pulp Fiction", 62, 46], ["Forrest Gump", 38, 46], ["Matrix", 26, 39], ["It's a Wonderful Life", 6, 0], ["Casablanca", 5, 6]], columns = ["Movie", "Wins", "Nominations"])<br/>sample_df</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2408e589-827a-49b0-b191-f7018e0a3c4b.png" style="width:15.50em;height:9.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Sample DataFrame—IMDB database</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The items() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>items()</kbd> method provides a means of iteratively accessing each row in a series or DataFrame. It performs a lazy evaluation to store each value in a row, along with the index in the form of a tuple. The results of this lazy evaluation can be obtained through an iterative process such as a <kbd>for</kbd> loop. Let's apply the <kbd>items</kbd> method on the <kbd>Wins</kbd> column of the DataFrame:</p>
<pre>for item in sample_df["Wins"].items():<br/>print(item)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1596 image-border" src="assets/34949d59-83f7-47eb-b1d5-d203718593c0.png" style="width:5.42em;height:7.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Looping with the items method</div>
<p>The <kbd>iteritems()</kbd> method behaves in a similar way to the <kbd>items()</kbd> method:</p>
<pre>for item in sample_df["Wins"].iteritems():<br/>print(item)</pre>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1597 image-border" src="assets/3f362b59-358d-4eb6-b9ff-c4545df8d482.png" style="width:5.25em;height:7.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Looping with the iteritems method</div>
<p>The <kbd>items</kbd> and iteritems methods return a zip type object. We need an iterative process to unzip the object. Applying the <kbd>items</kbd> or <kbd>iteritems</kbd> methods on a DataFrame give different results. In this case, each column is stacked within a tuple, along with the column name:</p>
<pre>for col in sample_df.items():<br/>print(col)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d003c701-a757-48e0-aecd-43503c6b8e93.png" style="width:19.25em;height:19.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Items method used on a DataFrame</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The keys() method</h1>
                </header>
            
            <article>
                
<p>When used with a series, the <kbd>keys()</kbd> method returns the row-labels or index of the series and serves the same function it does when accessing the index attribute of a DataFrame or series. The <kbd>keys()</kbd> method shows different behaviors when used with a DataFrame and with a series; it returns the column labels when used on a DataFrame and the row index when used with a series:</p>
<pre>In: sample_df["Wins"].keys()<br/>Out: RangeIndex(start=0, stop=5, step=1)<br/><br/>In: sample_df.keys()<br/>Out: Index(['Movie', 'Wins', 'Nominations'], dtype='object')</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pop() method</h1>
                </header>
            
            <article>
                
<p>If you are familiar with lists in Python, the <kbd>pop()</kbd> method will ring a bell. The <kbd>pop()</kbd> method in series and DataFrames behaves exactly the same as it does with lists. It helps remove entire columns from DataFrames or specific rows from series. Upon being called, the <kbd>pop()</kbd> method returns the popped out entity (row or column).</p>
<p class="mce-root"/>
<p>The following snippet demonstrates the use of <kbd>pop()</kbd> with a series. Let's pop the item with row index 2 from the <kbd>"Wins"</kbd> column:</p>
<pre>In: sample_df["Wins"].pop(2)<br/>Out: 26</pre>
<p>Now, let's print the <kbd>Wins</kbd> <span>series:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66128494-9754-452d-a267-2cbcc4b59b4d.png" style="width:12.33em;height:5.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of the <kbd>pop</kbd> method</div>
<p>It can be seen that index 2 is no longer present in the series. The same method can be applied to a DataFrame as well. Let's pop the <kbd>Nominations</kbd> column to understand this:</p>
<pre>sample_df.pop("Nominations")</pre>
<p><span>The following is the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d1860777-0ae1-4fca-b74d-6c3e43359175.png" style="width:13.17em;height:5.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Pop applied on the DataFrame</div>
<p>The following command is used to show the DataFrame result after popping:</p>
<pre>sample_df</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1598 image-border" src="assets/ec436cc9-02d0-421a-aa6c-90decc73b3c5.png" style="width:10.17em;height:8.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">DataFrame result after popping</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The apply() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>apply()</kbd> method provides us with a fast and efficient way to apply a function to all the values in a series. The function could be a built-in function such as a NumPy function or a user-defined function.</p>
<p>In the following snippet, <kbd>apply()</kbd> has been used to find the exponential value of all the rows in the <kbd>Wins</kbd> series:</p>
<pre>sample_df["Wins"].apply(np.exp)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a110368-2a66-46b0-b139-dd97bc9e1c89.png" style="width:15.25em;height:7.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Apply method on series</div>
<p>You can also define your own function and apply it to a series. Let's demonstrate this with a simple function to divide values by 100:</p>
<pre>def div_by_100(x):<br/>return x/100<br/><br/>sample_df["Nominations"].apply(div_by_100)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2b499660-15aa-4ca2-bc1a-878a436a8bbd.png" style="width:16.92em;height:7.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Apply for user-defined functions</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The map() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>map()</kbd> method is similar to the <kbd>apply</kbd> method as it helps in making elementwise changes that have been defined by functions. However, in addition, the <kbd>map</kbd> function also accepts a series or dictionary to define these elementwise changes.</p>
<p>Using the map function, let's change some of the values in the <kbd>"Wins"</kbd> column:</p>
<pre>sample_df["Wins"].map({62 : 60, 38 : 20})</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1600 image-border" src="assets/0205330f-3da8-4262-89cf-070657f823a7.png" style="width:14.33em;height:7.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Map method used on a series</div>
<p>Values for which the mapping is not defined are replaced with NAs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The drop() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>drop()</kbd> method is another useful method that removes entire rows or columns from a DataFrame or a series. Indices can be dropped along any axis <span>– </span>row indices can be dropped along axis 0 and column indices can be dropped along axis 1.</p>
<p>Let's drop indices 0 and 2 from the <kbd>Wins</kbd> series. The indices to be removed can be defined through a list. The default setting for the axis is 0, and hence no change is needed in this case:</p>
<pre>sample_df["Wins"].drop([0, 2])</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b8a54d51-7aaa-484d-aaac-33d47e826477.png" style="width:14.75em;height:5.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Drop method used on a series</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As we can see, the result does not have 0 and 2 and indexes. The following snippet shows the use of the <kbd>drop</kbd> method to remove columns from DataFrames:</p>
<pre>sample_df.drop(labels=["Wins", "Nominations"], axis = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1601 image-border" src="assets/72725fd0-1417-4b06-a3b6-10fd33ed57ef.png" style="width:10.83em;height:11.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Using the drop method on a DataFrame</div>
<p>Indices can also be effectively removed when there is multi-level indexing. The level parameter of drop helps us do this. Consider the following DataFrame with multi-level indexing:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/32f81cd2-5039-43cf-87a8-c92ec9a34bde.png" style="width:24.25em;height:14.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Multi-level indexed DataFrame</div>
<p>To remove a specific movie from the <kbd>Movie</kbd> column, the <kbd>level</kbd> parameter should be set to 1. By default, <kbd>level</kbd> is set to 0. The following snippet removes the movie <kbd>Matrix</kbd>:</p>
<pre>multidf.drop(["Matrix"], level = 1 )</pre>
<p class="mce-root"/>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1468418b-8e50-486c-be4d-3ffe2f0d30b9.png" style="width:22.50em;height:12.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Dropping index for a hierarchical index</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The equals() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>equals()</kbd> method checks whether two series or DataFrames are equal in terms of values, datatype, and shape. The column headers could be of different data types. The output is a Boolean. A practical application of this function is shown here. Let's create a new series that we can compare with the existing <kbd><span>sample_df</span></kbd> DataFrame:</p>
<pre>In: compare_series = pd.Series([62, 38, 26, 6, 5])<br/>In: sample_df["Wins"].equals(compare_series)<br/>Out: True</pre>
<p>This function can be applied this way to compare two DataFrames or two series within the same DataFrame.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The sample() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>sample()</kbd> method can be used for the random sampling of a DataFrame or series. The parameters of the <kbd>sample</kbd> function support sampling across either axis and also sampling with and without replacement. For sampling, either the number of records to be sampled or the fraction of records to be sampled must be specified.</p>
<p>Let's sample three records from the <span><kbd>Movie</kbd> </span>series:</p>
<pre>sample_df["Movie"].sample(3)\</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fea04d34-f602-475d-a39e-890c0d470872.png" style="width:16.33em;height:5.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Sample function for series</div>
<p>Now, let's sample 50% of the columns from the DataFrame:</p>
<pre>sample_df.sample(frac = 0.5, axis = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82cefaaf-9cfe-484e-b4fe-d8912594c8bb.png" style="width:15.33em;height:13.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Column sampling with the fraction parameter</div>
<p>The replace parameter can be set to <kbd>True</kbd> or <kbd>False</kbd> so that we can sample with or without replacement; the default is <kbd>False</kbd>. The random state parameter helps in setting the seed of the random number generator and it depends on the <kbd>Random</kbd> module of the NumPy package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ravel() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>ravel()</kbd> function flattens out a series into a one-dimensional array. It is fundamentally similar to the <kbd>numpy.ravel</kbd> function. The <kbd>ravel</kbd> function cannot be applied on DataFrames:</p>
<pre>In: sample_df["Wins"].ravel()<br/>Out: array([62, 38, 26, 6, 5], dtype=int64)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The value_counts() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>value_counts()</kbd> function works only on series, and not DataFrames. It counts the number of times each variable occurs and provides a frequency table-like output:</p>
<pre>pd.Series(["Pandas", "Pandas", "Numpy", "Pandas", "Numpy"]).value_counts()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/759c18ec-05a9-4b26-a066-66e28e74ef3e.png" style="width:8.58em;height:4.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Frequency count for categorical series</div>
<p>The <kbd>value_counts()</kbd> function can also be applied to a numeric column. It results in a count of each time a value occurs:</p>
<pre>sample_df["Nominations"].value_counts()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f3e40a26-c972-46de-a42d-f8c951490c7a.png" style="width:19.17em;height:7.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The value_counts function used on the numeric column</div>
<p>It is more useful to count the occurrence of numeric values within the range of bins. The <kbd>bins</kbd> parameter of <kbd>value_counts</kbd> groups data into bins before counting:</p>
<pre>sample_df["Nominations"].value_counts(bins = 2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9842f0d0-801d-4955-84f6-b835d8541e0a.png" style="width:19.33em;height:4.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>value_counts</kbd> function with binning for the <kbd>numeric</kbd> columns</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The interpolate() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>interpolate()</kbd> function provides an efficient way to handle missing data. Through this method, the NaNs can be replaced with a value through linear interpolation or polynomial interpolation, or even simple padding. This function fits the series to a function such as a <kbd>spline</kbd> or <kbd>quadratic</kbd> and then computes the possible missing data.</p>
<p>Consider the following series:</p>
<pre>lin_series = pd.Series([17,19,np.NaN,23,25,np.NaN,29])</pre>
<p>Since the values are all equally spaced apart, linear interpolation is the most suitable method here. Linear interpolation is the default value of the <kbd>method</kbd> parameter of the <kbd>interpolate</kbd> function:</p>
<pre>lin_series.interpolate()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/98d37fb5-735c-43ed-948d-df9a1ce1c368.png" style="width:7.67em;height:9.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Linear interpolation</div>
<p>The direction in which interpolation should take place can be specified. Let's consider the preceding example and fill in the NaNs through backward padding, as shown here:</p>
<pre>lin_series.interpolate(method = "pad", limit_direction = "backward")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9aad3f3b-5bf7-4648-a650-3397a5b7558d.png" style="width:8.08em;height:8.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Backward interpolation with padding</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The align() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>align()</kbd> function takes two objects, reindexes both objects based on a <kbd>join</kbd> condition (inner, outer, and so on), and returns a tuple with both objects:</p>
<pre>s1 = pd.Series([5,6,7,8,9], index = ["a","b","c","d","e"])<br/>s2 = pd.Series([1,2,3,4,5], index = ["d","b","g","f","a"])<br/>s1.align(s2, join="outer")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/86de389c-c622-497e-a162-44dd849e1bde.png" style="width:12.83em;height:16.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Align with outer join</div>
<p>Since the alignment was based on an outer join, the indexes that were found in both series are found in the output. For an inner join, only the common indexes are returned, such as <kbd>a</kbd>, <kbd>b</kbd>, and <kbd>d</kbd>:</p>
<pre>s1.align(s2, join="inner")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/28fdb72a-bc1b-42fa-82fe-d7f57ef14414.png" style="width:11.67em;height:8.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Align with inner join</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas string methods</h1>
                </header>
            
            <article>
                
<p>This section talks about the pandas string methods. These methods are useful when dealing with messy text data. These methods clean the text data, structure it, segment it, and search important chunks of it. Let's look into these methods and find out what each of them contains.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">upper(), lower(), capitalize(), title(), and swapcase()</h1>
                </header>
            
            <article>
                
<p>String methods such as <kbd>upper()</kbd>, <kbd>lower()</kbd>, <kbd>capitalize()</kbd>, <kbd>title()</kbd>, and <kbd>swapcase()</kbd> help when we wish to convert all the string elements into an entire series. The <kbd>upper</kbd> and <kbd>lower</kbd> methods convert the entire string into uppercase or lowercase. The following command shows converting a series into uppercase:</p>
<pre>sample_df["Movie"].str.upper()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b9dabc7-2a14-4708-885f-6f00ca566f9e.png" style="width:12.33em;height:6.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Converting a series into uppercase</div>
<p>The following command shows converting a series into lowercase:</p>
<pre>sample_df["Movie"].str.lower()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a6c0566-ef4d-45e6-9654-14653dc46d68.png" style="width:13.58em;height:7.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Converting a series into lowercase</div>
<p>The <kbd>capitalize()</kbd> method converts the first letter into uppercase and the rest into lowercase:</p>
<pre>pd.Series(["elon musk", "tim cook", "larry page", "jeff bezos"]).str.capitalize()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b6f4fe24-6945-45d6-83b1-5fd4892e579c.png" style="width:11.00em;height:7.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Capitalize function for a series</div>
<p>The <kbd>title()</kbd> method ensures that the first letter of each word of a string is capitalized while the rest are in lowercase:</p>
<pre>pd.Series(["elon musk", "tim cook", "larry page", "jeff bezos"]).str.title()</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f01cafb0-1108-49d1-a12b-8ae89b43c19f.png" style="width:9.67em;height:6.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Title case conversion for a string</div>
<p>The <kbd>swapcase()</kbd> method switches uppercase to lowercase and vice versa:</p>
<pre>sample_df["Movie"].str.swapcase()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b903886d-a9fb-44b6-be72-9bdcebd6604c.png" style="width:14.25em;height:7.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The swapcase() function</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">contains(), find(), and replace()</h1>
                </header>
            
            <article>
                
<p>The <kbd>contains()</kbd> method returns checks for the presence of a substring or pattern in all the elements of the series and returns a series of Booleans:</p>
<pre>sample_df["Movie"].str.contains("atr")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0f2b731d-58e5-4d89-9c05-b9910c482099.png" style="width:14.58em;height:8.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Contains function for string type series</div>
<p>Since <kbd>Matrix</kbd> is the only movie that contains the <kbd>atr</kbd> substring, <kbd>True</kbd> is returned at index <kbd>2</kbd>. The substring can also be a regex pattern. To use a regex pattern for string matching, the <kbd>regex</kbd> parameter should be set to <kbd>True</kbd>. For example, let's identify a string that contains either <kbd>atr</kbd> or <kbd>der</kbd>:</p>
<pre>sample_df["Movie"].str.contains("atr|der", regex = True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e456ffe7-21e8-45c0-9424-0efad202619a.png" style="width:14.67em;height:7.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Contains function with a regex</div>
<p>As we can see, two matches have been identified. Setting the <kbd>case</kbd> parameter to <kbd>True</kbd> ensures case sensitivity when pattern matching is executed:</p>
<pre>sample_df["Movie"].str.contains("cas", case = True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8c8e55b7-5c27-4c1a-901c-6a1b826b8ed2.png" style="width:12.42em;height:7.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Handling case sensitivity in the contains function</div>
<p>The <kbd>flags</kbd> parameter can be used to indicate any regex condition, such as ignoring case:</p>
<pre>import re<br/>sample_df["Movie"].str.contains("MATrix", flags = re.IGNORECASE, regex=True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/586354c1-6d40-42c6-b8df-4a1f8381bb74.png" style="width:12.42em;height:6.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Regex flags for the contains function</div>
<p>Note that the <kbd>re</kbd> package should be imported before defining any regex flags.</p>
<p>The <kbd>find</kbd> function returns the lowest index at which the substring could be found. Consider the following series:</p>
<pre>find_series = pd.Series(["abracadabra", "mad man"])</pre>
<p>Let's use the <kbd>find</kbd> function to get the index of the <kbd>ra</kbd> substring from the previous series:</p>
<pre>find_series.str.find("ra")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a0742189-4baa-4254-8bec-5d12b1812173.png" style="width:6.25em;height:3.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Find function for a series</div>
<p>In the first element, <kbd>abracadabra</kbd>, the first occurrence of <kbd>ra</kbd> was at index position <kbd>2</kbd>. Hence, <kbd>2</kbd> is returned. The second element, <kbd>mad man</kbd>, did not show a string match, and so <kbd>-1</kbd> is returned.</p>
<p>The <kbd>find</kbd> function has a <kbd>start</kbd> parameter that can be used to specify the left-most index to begin the search from. Equivalently, there is an <kbd>end</kbd> parameter to define the right-most index until which search is permissible. <kbd>start</kbd> is set to <kbd>0</kbd> and <kbd>end</kbd> is set to <kbd>None</kbd> by default:</p>
<pre>find_series.str.find("a", start = 2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3b73f4b6-4b63-4103-a142-1dc0c7cb15f1.png" style="width:7.92em;height:4.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The find function with a start limit specified</div>
<p>In the preceding example, we can see that by specifying the starting index, <kbd>a</kbd>, index 0 and 1 are ignored.</p>
<p>The <kbd>replace</kbd> function can be considered as an extension of the <kbd>contains</kbd> function since most of the parameters are similar. Functionally, <kbd>replace</kbd> finds a substring within a string in a series and substitutes it with a replacement string. Parameters such as <kbd>flags</kbd>, <kbd>case</kbd>, and <kbd>regex</kbd>, which are found in the <kbd>contains</kbd> function, are also found here, and they serve the same purpose. Let's replace the letter <kbd>I</kbd> in the series with the <kbd>rep</kbd> substring:</p>
<pre>sample_df["Movie"].str.replace("i","'rep'")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5211976-e7e0-45de-95ca-43394c185071.png" style="width:17.33em;height:7.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The replace function for a series</div>
<p>Note that in cases where there is more than one occurrence of <kbd>i</kbd>, multiple replacements are made. The number of replacements can be controlled with the <kbd>n</kbd> parameter:</p>
<pre>sample_df["Movie"].str.replace("i","'rep'", n = 1)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/36a7d778-1b44-45fc-b53d-3addc6672878.png" style="width:16.33em;height:7.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The replace function with the number of replacements specified</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">strip() and split()</h1>
                </header>
            
            <article>
                
<p>The <kbd>strip()</kbd> function can come in quite handy in data cleaning. It removes trailing whitespaces or any specific pattern of a string from textual content in series. If the substring to be removed is not specified, trailing whitespaces are trimmed by default. The following example demonstrates an application of the <kbd>strip</kbd> function with stray whitespaces:</p>
<pre>strip_series = pd.Series(["\tChina", "U.S.A ", "U\nK"])<br/>strip_series</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/186be31b-2115-435c-b8b6-be4df7f46122.png" style="width:7.75em;height:4.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Series with stray whitespaces</div>
<p class="mce-root">The following example demonstrates an application of the <kbd>strip()</kbd> function with trailing whitespaces:</p>
<pre>strip_series.strip()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/15fe8b2f-58ec-438a-9493-0efb5efa0b7f.png" style="width:7.67em;height:4.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Stripping trailing whitespaces</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This shows that <kbd>strip()</kbd> only removes trailing whitespaces and not those in the middle. Now, let's use <kbd>strip()</kbd> to remove a specific string:</p>
<pre>sample_df["Movie"].str.strip("opnf")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dce382c0-e1fc-43c0-9010-d1c7a7476dca.png" style="width:12.92em;height:6.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The strip function for removing string sequences</div>
<p>In the preceding example, the <kbd>strip()</kbd> function strips out any of the characters of the substring found in the trailing ends of the series elements.</p>
<p>The <kbd>split()</kbd> function splits a string at specified delimiters. Consider the following series:</p>
<pre>split_series = pd.Series(["Black, White", "Red, Blue, Green", "Cyan, Magenta, Yellow"])<br/>split_series</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/da181a01-a186-4737-9cca-ebed82dc3187.png" style="width:13.25em;height:4.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Sample series for the split function</div>
<p>Each element has two to three items separated by <kbd>,</kbd>. Let's use this as a delimiter to separate the items stacked together in each row of the series:</p>
<pre>split_series.str.split(", ")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1ea22bf-0079-4ed2-81c5-22142aec804e.png" style="width:13.50em;height:4.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Splitting as a list</div>
<p class="mce-root"/>
<p>The result is a list of items in each row. The <kbd>expand()</kbd> parameter creates a separate column for each item. By default, <kbd>expand</kbd> is set to <kbd>False</kbd>, which leads to a list being created in each row:</p>
<pre>split_series.str.split(", ", expand = True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/393771c4-bae4-4575-9dbd-18f85f9fd98e.png" style="width:13.92em;height:9.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Splitting multiple columns</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">startswith() and endswith()</h1>
                </header>
            
            <article>
                
<p>While the <kbd>contains()</kbd> function helps evaluate whether a substring is present in each element of a series, the <kbd>startswith()</kbd> and <kbd>endswith()</kbd> functions specifically look for the presence of the substring at the start and the end of strings, respectively:</p>
<pre>start_series = pd.Series(["strange", "stock", "cost", "past", "state"])<br/>start_series.str.startswith("st")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a633eb2e-d188-47f8-bfcb-056411e9d359.png" style="width:7.42em;height:8.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>startswith</kbd> function</div>
<p>Similarly, <kbd>endswith</kbd> can be used as shown here:</p>
<pre>end_series= pd.Series(["ramen", "program", "cram", "rammed", "grammer"])<br/>end_series.str.endswith("ram")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4aaa09de-958c-4e09-b9cc-45a1fcf07d65.png" style="width:8.50em;height:9.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>endswith</kbd> function</div>
<p>However, unlike <kbd>contains()</kbd>, these functions do not accept regular expressions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The is...() functions</h1>
                </header>
            
            <article>
                
<p>The following table lists a group of functions that help ascertain other properties of the string elements of a series. For example, the <kbd>isupper</kbd> function returns <kbd>True</kbd> if all the characters of a string are in uppercase. These functions return a Boolean output corresponding to each row in the series:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Function</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Returns true when all characters are...</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isalnum()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Alphanumeric</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isalpha()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Alphabetic</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isdigit()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Digits</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isspace()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Whitespace</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>islower()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Lowercase</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isupper()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Uppercase</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>istitle()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Title case</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isnumeric()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Numeric</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>isdecimal()</kbd></td>
<td class="CDPAlignCenter CDPAlign">Decimal</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Some examples of the preceding functions are as follows: </p>
<pre>pd.Series(["ui26", "ui", "26"]).str.isalpha()</pre>
<p>The following is the output:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13c6abee-f0e4-47c1-b37a-5bb31f029f60.png" style="width:7.33em;height:6.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The isalpha function</div>
<p>This is a example of the <kbd>isalnum</kbd> function:</p>
<pre>pd.Series(["ui26", "ui", "26"]).str.isalnum()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd5ae6ea-6396-47a9-8c64-4b78be246383.png" style="width:9.00em;height:6.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The isalnum function</div>
<p>This is an example of the <kbd>isnumeric</kbd> function:</p>
<pre>pd.Series(["ui26", "ui", "26"]).str.isnumeric()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4e397795-5ed4-4686-ac0a-36040579326b.png" style="width:8.75em;height:6.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The isnumeric function</div>
<p>These functions are only applicable to strings and not to other data types. Using these with other data types results in <kbd>NaN</kbd> being returned.</p>
<p>The following is an example of the <kbd>isdigit()</kbd> function:</p>
<pre>pd.Series(["ui26", "ui", 26]).str.isdigit()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1604 image-border" src="assets/b19fc19a-9970-49cc-86b0-5c2c41a919ec.png" style="width:7.50em;height:5.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The isdigit function</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binary operations on DataFrames and series</h1>
                </header>
            
            <article>
                
<p>Some binary functions such as, <kbd>add</kbd>, <kbd>sub</kbd>, <kbd>mul</kbd>, <kbd>div</kbd>, <kbd>mod</kbd>, and <kbd>pow</kbd>, perform common arithmetic operations involving two DataFrames or series.</p>
<p>The following example shows the addition of two DataFrames. One of the DataFrames has the shape (2,3) while the other has the shape (1,3). The add function performs an elementwise addition. When a corresponding element is missing in any of the DataFrames, the missing values are filled with NaNs:</p>
<pre>df_1 = pd.DataFrame([[1,2,3],[4,5,6]])<br/>df_2 = pd.DataFrame([[6,7,8]])<br/>df_1.add(df_2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0659c30-48e4-4d2e-835d-7c5f104164d9.png" style="width:10.50em;height:6.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Adding two DataFrames elementwise</div>
<p>Instead of using NaNs, we can choose to fill it with any value using the <kbd>fill_value</kbd> argument. Let's explore this through the <kbd>mul</kbd> function for multiplication:</p>
<pre>df_1.mul(df_2, fill_value = 0)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1605 image-border" src="assets/476387db-1077-4054-94bd-caf32aaf0cee.png" style="width:10.00em;height:7.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The fill_value parameter in binary operators in pandas</div>
<p>The second value that's used for the arithmetic operation doesn't necessarily need be a DataFrame or series; it can also be a scalar, as shown here:</p>
<pre>df_1.sub(2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1ee09dee-6899-4ac0-90a6-777ffb3425a3.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Binary operation with a scalar</div>
<p>In the preceding cases, the two DataFrames were uniformly indexed. Elements are compatible for operations that are across the same index labels:</p>
<pre>pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd']).pow(pd.Series([4, 3, 2, 1], index=['a', 'b', 'd', 'e']))</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1606 image-border" src="assets/f43c4c20-d308-4435-9854-8d21f9d05f6e.png" style="width:9.83em;height:9.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Binary operations being used on a series with different indexes</div>
<p>For indexes that aren't in both series, <kbd>NaN</kbd> is returned. Similar behavior will be seen with respect to column labels. Only elements sharing a similar column name can be used together. This is shown in the following code:</p>
<pre>pd.DataFrame([[27, 33, 44]], columns=["a", "b", "c"]).mod(pd.DataFrame([[7, 6, 2]], columns=["b", "a", "d"])).</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/55468323-1ca2-43e2-8b9f-fbd0f11f3d64.png" style="width:11.50em;height:4.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Binary operations used on DataFrames with different columns</div>
<p>Now, consider the following two DataFrames, one of which shows hierarchical indexing:</p>
<pre>df = pd.DataFrame([[1, 4, 6], [np.NaN, 5, 3], [2, 7, np.NaN], [5, 9, 4], [1, np.NaN, 11]], columns = ["ColA", "ColB", "ColC"], index = ["a", "b", "c", "d", "e"])<br/><br/>df</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1608 image-border" src="assets/20cd2e42-4df4-452e-97a1-9ecc541b3622.png" style="width:10.42em;height:11.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Sample DataFrame</div>
<p>The following code block is an example of a multi-indexed DataFrame:</p>
<pre>df_multi = df.iloc[0:4, :]<br/>df_multi.index = pd.MultiIndex.from_tuples([(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a')])<br/>df_multi</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efe5edcf-5c00-40b8-a2e8-749eef7f518f.png" style="width:16.42em;height:12.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Multi-indexed DataFrame</div>
<p>To divide <kbd>df</kbd> by the elements of <kbd>df_multi</kbd>, or to perform any of the aforementioned binary operations, the level parameter can be used to specify the <kbd>level</kbd> of the index that is shared by both DataFrames:</p>
<pre>df.div(df_multi, level = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7d1431ec-4b7c-4688-b749-7849b158a1f4.png" style="width:16.50em;height:12.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Binary operations used for DataFrames with a hierarchical index</div>
<p>The <kbd>lt</kbd>, <kbd>le</kbd>, <kbd>gt</kbd>, and <kbd>ge</kbd> functions help with DataFrame comparisons by establishing the truth of <em>less than</em>, <em>less than or equal to</em>, <em>greater than</em>, and <em>greater than or equal to</em> comparisons. They have the same parameters as the functions we discussed previously and show similar behaviors in all those scenarios. Let's compare <kbd>df</kbd> and <kbd>df_multi</kbd>:</p>
<pre>df.lt(df_multi, level = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d80bc522-99b0-43cf-bd6d-33c6aa2bef61.png" style="width:14.33em;height:11.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Less than function</div>
<p>The following code block shows the <kbd>le</kbd> function:</p>
<pre>df.le(df_multi, level = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8f0460c6-9f7e-4709-8a67-1f283920e2bf.png" style="width:14.83em;height:11.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Less than or equal to function</div>
<p>The <kbd>round</kbd> function rounds decimals to the desired number of places, as specified by the <kbd>decimals</kbd> parameter:</p>
<pre>pd.Series([6.78923, 8.02344, 0.1982]).round()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88f9bee5-8b96-40fa-8eff-d4793c1818e9.png" style="width:9.83em;height:6.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The round function</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>By default, rounding off takes place to make the input a whole number (<kbd>decimals = 0</kbd>):</p>
<pre>pd.Series([6.78923, 8.02344, 0.1982]).round(2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a6e2ed8-144a-41c1-96e0-0641ebe00fa9.png" style="width:7.25em;height:4.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The round function with a number of places set</div>
<p>The <kbd>combine</kbd> function takes two overlapping DataFrames and executes the function defined within them. Let's combine two series and find the maximum of the two. Note that a comparison takes place, with the index as a reference:</p>
<pre>pd.Series([9, 10, 11]).combine(pd.Series([7, 15, 12]), max)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99c8ea57-7ad6-4044-b7a1-188fff0b269d.png" style="width:6.83em;height:4.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> The combine function</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binning values</h1>
                </header>
            
            <article>
                
<p>The pandas <kbd>cut()</kbd> function bins values in a 1-dimensional array. Consider the following 1-dimensional array with 10 values. Let's group it into three bins:</p>
<pre>bin_data = np.array([1, 5, 2, 12, 3, 25, 9, 10, 11, 4])<br/>pd.cut(bin_data, bins = 3)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75641e12-5a07-462d-8231-ff5fef914d71.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">pandas cut function with three bins</div>
<p>Each of the 10 elements is mapped to one of the three bins. The <kbd>cut</kbd> function maps the items to a bin and provides information about each bin. Instead of specifying the number of bins, the boundaries of the bins could also be provided in a sequence:</p>
<pre>pd.cut(bin_data, bins = [0.5, 7, 10, 20, 30])</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1610 image-border" src="assets/600f7098-daa5-42e6-930a-c5eb88b32d15.png" style="width:81.00em;height:5.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">pandas cut function with bin values</div>
<p>The intervals for binning can be directly defined using the pandas <kbd>interval_range</kbd> function. Consider the following example, demonstrating the creation of a pandas <kbd>IntervalIndex</kbd> object:</p>
<pre>interval = pd.interval_range(start = 0, end = 30, periods = 5)<br/>interval</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd09961d-6c76-4904-8e4a-2aced11cb297.png" style="width:34.00em;height:4.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">pandas IntervalIndex</div>
<p>This interval can be directly passed to the <kbd>cut</kbd> function:</p>
<pre>pd.cut(bin_data, bins = interval)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/04a60603-87d5-401d-91e3-86e26339ebf9.png" style="width:52.92em;height:3.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">pandas cut function with the interval index</div>
<p>Setting the <kbd>right</kbd> parameter to <kbd>True</kbd> includes the right interval in the bin, while setting the <kbd>right</kbd> parameter to <kbd>False</kbd> excludes it from the bin range. The default setting is <kbd>True</kbd>:</p>
<pre>pd.cut(bin_data, bins = [0.5, 7, 10, 20, 30], right = False)</pre>
<p>The following is<span> the output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/62348564-86f6-414e-8434-54a16ef80c9e.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Open right interval</div>
<p>Equivalently, the <kbd>include_lowest</kbd> parameter decides whether the lowest interval should be included. By default, it is set to <kbd>False</kbd>:</p>
<pre>pd.cut(bin_data, bins = [0.5, 7, 10, 20, 30], include_lowest= True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0513d85e-5958-44a7-ab53-5c0e498129ce.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Including the lowest value in the left range</div>
<p>The function returns the bins when <kbd>retbins</kbd> is set to <kbd>True</kbd>:</p>
<pre>pd.cut(bin_data, bins = 5, retbins = True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1612 image-border" src="assets/ec0a959d-585d-4eb3-9f6f-80888af2be29.png" style="width:81.33em;height:6.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Returning bins</div>
<p>The second value in the output tuple is an array of the bin values.</p>
<p>The bins can be assigned labels by passing a list of label names to the <kbd>labels</kbd> parameter:</p>
<pre>pd.cut(bin_data, bins = 3, labels = ["level1", "level2", "level3"])</pre>
<p>The following is the output:</p>
<p> </p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c5f8005-9ddd-4f60-aeaa-81997e6b845c.png" style="width:37.83em;height:3.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Label bins</div>
<p class="mce-root"/>
<p>When the bins that are passed contain duplicates, an error is raised by default. This is because the duplicates parameter is set to <kbd>raise</kbd> by default. Setting it to <kbd>drop</kbd> will drop the duplicates:</p>
<pre>pd.cut(bin_data, bins = [0.5, 7, 10, 30, 30], duplicates = "drop")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/eaf56718-eddb-48ca-997d-6d05d2ef079f.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Handling duplicates in bins</div>
<p>The precision of digits up to which the bins are created and stored can be set by the <kbd>precision</kbd> parameter:</p>
<pre>pd.cut(bin_data, bins = 3, precision = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bdc0653-e4dd-49d6-b2b8-7031195e36cc.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Setting precision in bins</div>
<p>The <kbd>qcut</kbd> function is similar to the <kbd>cut</kbd> function, with the exception that bins can be created by specifying the number of quantiles based on which the bins are to be created:</p>
<pre>pd.qcut(bin_data, q = 5)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7af0fc2c-9a4f-4af1-b34a-65150bc474d7.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The qcut function</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using mathematical methods on DataFrames</h1>
                </header>
            
            <article>
                
<p>Computations such as sum, mean, and median can be performed with ease on pandas DataFrames using the built-in mathematical methods in the pandas library. Let's make use of a subset of the sales data to explore the mathematical functions and methods in pandas. While applying these mathematical functions, it should be ensured that the selected columns are numeric. The following screenshot shows the data with five rows and three columns, all of which will be used in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f6a8b8b8-2173-42bb-a910-35849975f88c.png" style="width:13.33em;height:10.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Sample sales data</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The abs() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>abs()</kbd> function returns the absolute values of records in the DataFrame. For columns with complex values in the form x+yj, the absolute value is computed as <img class="fm-editor-equation" src="assets/eda1f3fa-ea77-4427-a19f-b174c53d7584.png" style="width:4.17em;height:2.00em;"/>:</p>
<pre>abs_df = pd.DataFrame({"Integers": [-1, -2, -3, 0, 2], "Complex": [5+2j, 1+1j, 3+3j, 2+3j, 4+2j]})<br/>abs_df.abs()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa02a787-d40f-4a8a-8029-7a52fe83a414.png" style="width:8.50em;height:8.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The abs() function</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">corr() and cov()</h1>
                </header>
            
            <article>
                
<p>The <kbd>corr()</kbd> function returns the correlation coefficient of each combination of variables in the DataFrame. If any NAs are present, they are excluded for correlation computation. The <kbd>corr()</kbd> function accepts the Pearson, Kendall, and Spearman methods. By default, the Pearson correlation coefficient is calculated:</p>
<pre>sales_df.corr()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/909bfd77-7725-42a9-928c-01dafea21849.png" style="width:19.42em;height:8.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The corr() function</div>
<p>Just like the correlation function, the <kbd>cov()</kbd> function returns the covariance matrix:</p>
<pre>sales_df.cov()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4590bcbf-8146-4093-a6fe-d96c3790afb1.png" style="width:22.17em;height:9.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The cov() function</div>
<p>The <kbd>min_periods</kbd> argument in <kbd>corr()</kbd> and <kbd>cov()</kbd> decides the minimal presence of non-NA values in the DataFrame.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">cummax(), cumin(), cumsum(), and cumprod()</h1>
                </header>
            
            <article>
                
<p>The <kbd>cummax()</kbd>, <kbd>cummin()</kbd>, <kbd>cumsum()</kbd>, and <kbd>cumprod()</kbd> functions compute the maximum, minimum, sum, and product on a cumulative basis, respectively. Let's understand this by applying the <kbd>cummax()</kbd> function on the sample DataFrame:</p>
<pre>sales_df.cummax()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/064a2bf2-bb86-498c-98e2-ce8485760f7e.png" style="width:16.92em;height:13.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The cummax() function</div>
<p>The <kbd>skipna</kbd> parameter in these functions provides control over handling NAs. It is set to <kbd>True</kbd> by default, and NAs are excluded. Consider the following DataFrame with NAs to understand the function of this parameter:</p>
<pre>sales_df_na</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f9776827-9504-4cc5-8eb1-52646a3d74f7.png" style="width:16.58em;height:13.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Sample data with NAs</div>
<p class="mce-root"><span>The </span><kbd>cumsum()</kbd><span> method can be applied as shown here:</span></p>
<pre>sales_df_na.cumsum()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1112b092-89d2-4947-aef7-59eafea31094.png" style="width:16.00em;height:11.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The cumsum() function</div>
<p>We can choose to not ignore NAs while doing a cumulative sum by setting <kbd>skipna</kbd> to <kbd>False</kbd>:</p>
<pre>sales_df_na.cumsum(skipna=False)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/38c77232-e746-4f4b-8fa6-0d1798d42bfd.png" style="width:16.42em;height:11.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The cumulative function with skipna</div>
<p>By default, the aggregation is performed across the row axis since the <kbd>axis</kbd> parameter is set to <kbd>0</kbd> by default. Using the <kbd>axis</kbd> parameter, cumulative aggregation can also be performed across columns:</p>
<pre>sales_df.cumprod(axis = 1)</pre>
<p class="mce-root"/>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a511ae4a-d276-406a-be33-3e8d76c352f8.png" style="width:16.25em;height:11.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The cumprod() function</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The describe() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>describe()</kbd> function provides a representation of the distribution of data and computes some useful summary statistics. It serves quite useful for <strong>exploratory data analysis</strong> (<strong>EDA</strong>) techniques:</p>
<pre>sales_df.describe()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/030729c7-6d6d-4e33-b683-d07e19b76981.png" style="width:17.42em;height:16.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The describe() function </div>
<p>The <kbd>describe()</kbd> function can be applied to numeric and categorical variables. The <kbd>include</kbd> and <kbd>exclude</kbd> parameters of the <kbd>describe</kbd> function set the data type of the function it should evaluate. By default, <kbd>include</kbd> is set to <kbd>numeric</kbd>. Hence, any categorical variables in the Dataframe will be ignored. Let's apply <kbd>describe</kbd> on the following DataFrame by setting the <kbd>include</kbd> parameter to the <kbd>object</kbd> data type:</p>
<pre>sales_df_full</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5a3deecc-a6d6-4b50-85f0-1b38e9dd1c06.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Sample data with mixed datatypes</div>
<p>Take a look at the following:</p>
<pre>sales_df_full.describe(include = np.object)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/337bc1ad-b82f-4401-95e7-e7f120b0f962.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The describe() function for categorical variables</div>
<p>All the datatypes can be included by setting <kbd>include</kbd> to <kbd>all</kbd>. Similarly, the <kbd>exclude</kbd> parameter can also be used to exclude certain datatypes.</p>
<p>For numeric variables, <kbd>describe</kbd> evaluates the percentiles at 0.25, 0.5, 0.75, and 1. This can be customized like so:</p>
<pre>sales_df.describe(percentiles = [0.1, 0.2, 0.3, 0.4, 0.5])</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/017a1dc1-3e58-4534-b588-cce4cb6dc905.png" style="width:15.83em;height:16.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Custom percentiles in the describe function</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The diff() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>diff()</kbd> function computes the difference between subsequent rows in the same column or subsequent columns in the same row. <kbd>diff()</kbd> can be evaluated along a row or column by setting the <kbd>axis</kbd> parameter, which is set to 0 by default. Therefore, computation takes place by row:</p>
<pre>sales_df.diff()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aab6fa7e-2546-42c6-825c-f24ab052feae.png" style="width:12.08em;height:8.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The diff() function</div>
<p class="mce-root">The <kbd>diff</kbd> method can be applied as shown here:</p>
<pre>sales_df.diff(axis = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4e3e20e0-c8d7-4d14-9442-1705a24ed8f8.png" style="width:14.08em;height:10.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The diff() function applied along axis 1</div>
<p>The <kbd>periods()</kbd> parameter can be used to find the difference of the nth previous row. A negative value would allow us to find the difference from the nth row that follows:</p>
<pre>sales_df.diff(periods = 2)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/001f6e9f-cfc2-4ebb-8874-d79826c23b62.png" style="width:14.08em;height:11.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">diff() being used at different periodic intervals</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The rank() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>rank()</kbd> function returns a DataFrame with the rank of each value that was estimated along the specified axis. Ranking takes place in ascending order by default:</p>
<pre>sales_df.rank()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/70dab829-f10d-43fa-99b9-2d543d2f0dfc.png" style="width:9.75em;height:8.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Ranking function result</div>
<p>The <kbd>rank()</kbd> method can be applied as shown here:</p>
<pre>sales_df.rank(ascending = False)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea5b41be-b19e-432a-b012-8970e77d519c.png" style="width:9.75em;height:8.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Ranking in descending order</div>
<p class="mce-root">Ranking can also be obtained as a percentage, as shown here:</p>
<pre>sales_df.rank(pct = True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3070fb9d-8481-4e11-97b3-fc6465effa57.png" style="width:10.33em;height:9.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Ranking with percentiles</div>
<p>The <kbd>method()</kbd> argument helps settle ties. By default, the average of the range of ranks that could possibly be occupied by items in a tie is shown in the result. It can also be modified to show the minimum rank, maximum rank, the order in which values appear, or dense ranking:</p>
<pre>sales_df.rank(method = "min")</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f1e18e41-4d28-4689-b2b9-998e5c02b5bb.png" style="width:11.25em;height:10.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Using the ranking method to find the minimum value for a tiebreaker</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The quantile() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>quantile()</kbd> function returns the value for every column for the specified quantiles. It accepts a single quantile value or an array of quantile values:</p>
<pre>sales_df.quantile(q = [0.1, 0.9])</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2ebabbc-b3fc-4466-851b-9cae14407fc6.png" style="width:15.17em;height:5.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Finding the quantiles for a DataFrame</div>
<p>Quantiles can also be computed for timestamps. We can achieve this by setting the <kbd>numeric_only</kbd> parameter to <kbd>False</kbd>:</p>
<pre>time_col = pd.DataFrame({"time": pd.date_range("2017-01-01", "2017-12-31")})<br/>time_col.quantile(q = [0.1, 0.5], numeric_only = False)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6374dfd5-754f-4174-af75-5a2a7cf85095.png" style="width:8.83em;height:5.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Quantiles for the datetime value</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The round() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>round()</kbd> function helps in rounding off decimals. By default, the values are rounded off to a whole number:</p>
<pre>sales_df.round()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1614 image-border" src="assets/ff14f7fd-af30-44f4-86e6-6f4c49b73fcd.png" style="width:11.00em;height:8.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>round()</kbd> function's results</div>
<p>The <kbd>round</kbd> function can be applied as shown here:</p>
<pre>sales_df.round(decimals = 10)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ad4f15c5-ade2-426b-b79b-0e9891992189.png" style="width:10.75em;height:8.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>round()</kbd> function for <kbd>decimals = 10</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pct_change() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>pct_change()</kbd> function works similar to the <kbd>diff</kbd> function and computes the percentage of the difference between two different values in the DataFrame. Just like in <kbd>diff()</kbd>, the <kbd>periods</kbd> parameter provides flexibility so that we can evaluate between different elements that are spaced apart by a few rows:</p>
<pre>sales_df.pct_change()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c77c376d-0209-425e-b664-090c9017ed1c.png" style="width:16.67em;height:12.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Percentage change across rows</div>
<p>The <kbd>fill_method</kbd> parameter allows NAs to be handled by methods such as padding prior to computation. The <kbd>limit</kbd> parameter helps set a threshold on a permissible number of NAs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">min(), max(), median(), mean(), and mode()</h1>
                </header>
            
            <article>
                
<p>These functions accept a similar set of parameters and compute the aggregates (min, max, median, or mode) for each column or row based on the axis parameter setting:</p>
<pre>sales_df.min()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b2b3c5db-ba68-4348-99f5-63cf87bbe5ee.png" style="width:11.08em;height:5.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>min()</kbd> result</div>
<p>The <kbd>max</kbd> method can be applied as shown here:</p>
<pre>sales_df.max(axis = 1)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c3f5c0f1-f20b-4883-807c-140ae916f5c6.png" style="width:6.58em;height:6.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>max()</kbd> result</div>
<p>The <kbd>skipna</kbd> parameter helps us handle NAs. Consider the following DataFrame:</p>
<pre>sales_df_na</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/132d2fd7-32c9-411a-980e-20d08f5ddcb1.png" style="width:13.92em;height:11.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">DataFrame with NAs</div>
<p>By default, the NAs are skipped during evaluation, as the <kbd>skipna</kbd> parameter is set to <kbd>True</kbd>:</p>
<pre>sales_df_na.median()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2d09307e-9c2a-4c9d-bfe2-f1b8dc47e93d.png" style="width:9.58em;height:4.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>median()</kbd> function</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>By default, NAs are ignored in mean calculations. If <kbd>skipna</kbd> is set to <kbd>False</kbd>, the calculation also result to NA if there is a missing value:</p>
<pre>sales_df_na.median(skipna = False)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/73773c33-7696-459e-87d9-b38ea0d72767.png" style="width:13.33em;height:6.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>median()</kbd> function with <kbd>skipna</kbd></div>
<p>Consider the following multi indexed DataFrame. Let's compute the mean for it:</p>
<pre>multileveldf</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8528079d-141d-4743-9f5f-f8425394041c.png" style="width:23.50em;height:24.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Multi indexed DataFrame</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The mean of this multi-index dataset can be obtained as shown here:</p>
<pre>multileveldf.mean()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dafe3a03-8403-463b-a734-151464b11488.png" style="width:14.50em;height:4.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The mean of the multi indexed DataFrame</div>
<p>The <kbd>level</kbd> parameter computes the aggregate across any level of index in a multi-indexed DataFrame:</p>
<pre>multileveldf.mean(level = 0)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6dc322d1-d642-4662-962b-61fa46cc92ce.png" style="width:20.92em;height:11.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><kbd>mean()</kbd> for a specific index level</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">all() and any()</h1>
                </header>
            
            <article>
                
<p>The <kbd>all()</kbd> and <kbd>any()</kbd> functions help us test for the presence of <kbd>False</kbd> values or zeros in a DataFrame. If all the values along the chosen axis are <kbd>True</kbd>, then the <kbd>all()</kbd> function returns <kbd>True</kbd>. The <kbd>any()</kbd> function requires at least a single value to be <kbd>True</kbd> to return <kbd>True</kbd>. Let's apply <kbd>all()</kbd> and <kbd>any()</kbd> on the following DataFrame:</p>
<pre>all_any = pd.DataFrame({"A": [True, False, False, True, True], "B": [1, 1, 1, 1, 1], "C": [10, 11, 20, 22, 33], "D": ["abc", "xyz", "pqr", "ijk", "def"], "E": [False, False, False, False, False]})<br/>all_any</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f96a54f-450f-4a4e-b01e-af421bb45fb9.png" style="width:11.00em;height:9.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Sample DataFrame</div>
<p>All the values are <kbd>True</kbd> in columns B, C, and D. Hence, <kbd>all()</kbd> returns <kbd>True</kbd> for these columns. Column E, which has no <kbd>True</kbd> values, returns <kbd>False</kbd> with <kbd>any()</kbd>:</p>
<pre>all_any.all()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b58a4e51-fd8e-4b81-a41f-8e7075f9423f.png" style="width:6.25em;height:7.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>all()</kbd> result</div>
<p class="mce-root">Similarly, <kbd>any()</kbd> can be applied as shown here:</p>
<pre>all_any.any()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5e5a67cf-7e0f-48b5-aec1-4c08cb8f2191.png" style="width:6.58em;height:7.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The <kbd>any()</kbd> result</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>all()</kbd> and <kbd>any()</kbd> functions have the <kbd>axis</kbd>, <kbd>skipna</kbd>, and <kbd>level</kbd> parameters, just like some of the functions we discussed previously. The <kbd>bool_only</kbd> parameter can be used to include or exclude datatypes other than Booleans:</p>
<pre>all_any.all(bool_only = True)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6b9ad684-efac-4446-9c4b-3bd247439657.png" style="width:6.83em;height:4.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>The bool_only parameter</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The clip() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>clip()</kbd> function specifies a lower limit and upper limit. Values in the DataFrame exceeding the upper limit, are reduced to the upper limit and values under the lower limit are raised to this lower limit:</p>
<pre>sales_df.clip(8, 3000)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1615 image-border" src="assets/0014d934-58e5-4bbe-9f08-6166593f4fc5.png" style="width:15.83em;height:12.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">clip() result</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The count() function</h1>
                </header>
            
            <article>
                
<p>The <kbd>count()</kbd> function helps count the total non-NA values in the DataFrame:</p>
<pre>sales_df_na</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5ef7d318-a7cc-45d8-b4fa-811385cc1921.png" style="width:14.00em;height:10.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">DataFrame with NA</div>
<p>The count method can be applied as shown here:</p>
<pre>sales_df_na.count()</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5d374bae-d1ba-43e6-b154-6522a932961a.png" style="width:8.17em;height:4.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">count() result</div>
<p>The <kbd>count()</kbd> function has the <kbd>axis</kbd>, <kbd>level</kbd>, and <kbd>numeric_only</kbd> parameters, just like several other functions we discussed previously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter provided a collection of special methods that show the flexibility and usefulness of pandas. This chapter has been like an illustrated glossary in which each function serves a very unique purpose. Now, you should have an idea of how to create and apply one-liner functions in pandas, and you should understand the concepts of missing values and the methods that take care of them. This is also a compendium of all the miscellaneous methods that can be applied to a series and the numeric methods that can be applied to any kind of Python data structure.</p>
<p>In the next chapter, we will take a look at how we can handle time series data and plot it using <kbd>matplotlib</kbd>. We will also have a look into the manipulation of time series data by looking at rolling, resampling, shifting, lagging, and time element separation. </p>


            </article>

            
        </section>
    </body></html>