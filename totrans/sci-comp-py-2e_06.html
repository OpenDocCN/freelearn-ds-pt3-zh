<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Plotting
                </header>
            
            <article>
                
<p>Plotting in Python can be done with the<span> </span><kbd>pyplot</kbd><span> </span>part of the module Matplotlib. With <kbd>matplotlib</kbd><span>, </span>you can create high-quality figures and graphics and also plot and visualize your results. Matplotlib is open source and freely available software. The Matplotlib website also contains excellent documentation with examples, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">35</a>. In this section, we will show you how to use the most common features. The examples in the upcoming sections assume that you have imported the module as:</p>
<pre>from matplotlib.pyplot import *</pre>
<p>In case you want to use the plotting commands in IPython, it is recommended that you run the <em>magic command</em><span> </span><kbd>%matplotlib</kbd><span> </span>directly after starting the IPython shell. This prepares IPython for interactive plotting.</p>
<h1 id="uuid-32f5009d-05fa-4395-b81b-870834305ac2">6.1 Making plots with basic plotting commands</h1>
<p>In this section, we will create plots by means of basic commands. It is the entry point for studying how to make graphical representations of mathematical objects and data using Python.</p>
<h2 id="uuid-29859b09-2148-46c2-96eb-82c3a4b4d1af">6.1.1 Using the plot command and some of its variants</h2>
<p>The standard plotting function is<span> </span><kbd>plot</kbd>. Calling<span> </span><kbd>plot(x,y)</kbd><span> </span>creates a figure window with a plot of<span> </span><img class="fm-editor-equation" src="assets/0bebbcfd-cc30-44ee-a0a3-5e07f610d63b.png" style="width:0.50em;height:0.92em;"/> as a function of <img class="fm-editor-equation" src="assets/17e2c94a-5fd0-415b-a4e3-217aebb2fa23.png" style="width:0.75em;height:0.83em;"/>. The input arguments are arrays (or lists) of equal length. It is also possible to use<span> </span><kbd>plot(y)</kbd>, in which case the values in<span> </span><span><img class="fm-editor-equation" src="assets/77346714-da93-4af9-97f6-a5ccf7e135d1.png" style="width:0.50em;height:0.92em;"/></span> will be plotted against their index, that is,<span> </span><kbd>plot(y)</kbd><span> </span>is a short form of<span> </span><kbd>plot(range(len(y)),y)</kbd>.</p>
<p>Here is an example that shows how to plot <img class="fm-editor-equation" src="assets/d15e859d-6238-4437-987e-6f989435ab76.png" style="width:11.17em;height:1.33em;"/> using 200 sample points and with markers at every fourth point:</p>
<pre># plot sin(x) for some interval
x = linspace(-2*pi,2*pi,200)
plot(x,sin(x))

# plot marker for every 4th point
samples = x[::4]
plot(samples,sin(samples),'r*')

# add title and grid lines
title('Function sin(x) and some points plotted')
grid()</pre>
<p>The result is shown in the following figure (<em>Figure 6.1</em>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f8bca15b-e7cd-42d6-bc6b-1dc72d497cd7.png" style="width:33.08em;height:26.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.1: A plot of the function sin(x) with grid lines shown</div>
<p>As you can see, the standard plot is a solid<span> </span>blue<span> </span>curve. Each axis gets automatically scaled to fit the values, but can also be set manually. Color and plot options can be given after the first two input arguments. Here,<span> </span><kbd>r*</kbd><span> </span>indicates red star-shaped markers. Formatting is covered in more detail in the next section. The command<span> </span><kbd>title</kbd><span> </span>puts a title text string above the plot area.</p>
<p>Calling<span> </span><kbd>plot</kbd><span> </span>multiple times will overlay the plots in the same window. To get a new clean figure window, use<span> </span><kbd>figure()</kbd>. The command<span> </span><kbd>figure</kbd> might contain an integer, for example,<span> </span><kbd>figure(2)</kbd>, which can be used to switch between figure windows. If there is no figure window with that number, a new one is created, otherwise, the window is activated for plotting and all subsequent plotting commands apply to that window.</p>
<p>Multiple plots can be explained by using the function<span> </span><kbd>legend</kbd>, along with adding labels to each plot call. The following example fits polynomials to a set of points using the commands<span> </span><kbd>polyfit</kbd><span> </span>and<span> </span><kbd>polyval</kbd>, and plots the result with a legend:</p>
<pre># —Polyfit example—
x = range(5)
y = [1,2,1,3,5]
p2 = polyfit(x,y,2) # coefficients of degree 2 polynomial
p4 = polyfit(x,y,4) # coefficients of degree 4 polynomial 

# plot the two polynomials and points
xx = linspace(-1,5,200) 
plot(xx, polyval(p2, xx), label='fitting polynomial of degree 2')
plot(xx, polyval(p4, xx),
                label='interpolating polynomial of degree 4') 
plot(x,y,'*')

# set the axis and legend
axis([-1,5,0,6])
legend(loc='upper left', fontsize='small')</pre>
<p>Here, you can also see how to manually set the range of the axis using<span> </span><kbd>axis([xmin,xmax,ymin,ymax])</kbd>. The command<span> </span><kbd>legend</kbd><span> </span>takes optional arguments on placement and formatting; in this case, the legend is put in the upper-left corner and typeset with a small font size, as shown in the following figure (<em>Figure 6.2</em>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a14516df-6320-4707-9dde-d9e1f12eb6ce.png" style="width:36.00em;height:28.75em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.2: Two polynomials fitted to the same points</div>
<p>As final examples for basic plotting, we demonstrate how to do scatter plots and logarithmic plots in two dimensions.</p>
<p>Here is an example of a 2D point scatter plot:</p>
<pre># create random 2D points
import numpy
x1 = 2*numpy.random.standard_normal((2,100))
x2 = 0.8*numpy.random.standard_normal((2,100)) + array([[6],[2]])
plot(x1[0],x1[1],'*')
plot(x2[0],x2[1],'r*')
title('2D scatter plot')</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1abff8af-22ad-4ced-b8a8-6d55a08d1841.png" style="width:34.25em;height:27.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.3(a): An example of a scatter plot</div>
<p>The following code is an example of a logarithmic plot using<span> </span><kbd>loglog</kbd>:</p>
<pre># log both x and y axis 
x = linspace(0,10,200) 
loglog(x,2*x**2, label = 'quadratic polynomial',
                            linestyle = '-', linewidth = 3)
loglog(x,4*x**4, label = '4th degree polynomial',
                            linestyle = '-.', linewidth = 3)
loglog(x,5*exp(x), label = 'exponential function', linewidth = 3)
title('Logarithmic plots')
legend(loc = 'best')</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/79c6a098-ec45-455b-8a16-454ae29cd3b2.png" style="width:28.00em;height:22.00em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.3(b): An example of a plot with logarithmic <em>x</em> and <em>y</em> axes</div>
<p>The examples shown in the preceding figure (<em>Figure 6.3(a)</em><span> </span>and<span> </span><em>Figure 6.3(b)</em>) used some parameters of<span> </span><kbd>plot</kbd><span> </span>and<span> </span><kbd>loglog</kbd><span>, </span>which allow special formatting. In the next section, we will explain the parameters in more detail.</p>
<h2 id="uuid-45f0de32-9ad0-41dd-90d7-d78946182c90">6.1.2 Formatting</h2>
<p>The appearance of figures and plots can be styled and customized to look how you want them to look. Some important variables are<span> </span><kbd>linewidth</kbd>, which controls the thickness of plot lines,<span> </span><kbd>xlabel</kbd> and <kbd>y<span>label</span></kbd>, which set the axis labels,<span> </span><kbd>color</kbd><span> </span>for plot colors, and<span> </span><kbd>transparent</kbd><span> </span>for transparency.</p>
<p>This section will tell you how to use some of them. The following is an example with more keywords:</p>
<pre>k = 0.2
x = [sin(2*n*k) for n in range(20)]
plot(x, color='green', linestyle='dashed', marker='o', 
                       markerfacecolor='blue', markersize=12, linewidth=6)</pre>
<p>There are short commands that can be used if you only need basic style changes, for example, setting the color and line style. The following table (<em>Table 6.1</em>) shows some examples of these formatting commands. You may use either the short string syntax<span> </span><kbd>plot(...,'ro-')</kbd>, or the more explicit<span> </span>syntax<span> </span><kbd>plot(..., marker='o', color='r', linestyle='-')</kbd>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/eb6fd063-8472-4188-8a3e-a95226d58bad.png" style="width:30.92em;height:24.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Table 6.1: Some common plot formatting arguments</div>
<p>To set the color to green with the marker<span> </span><kbd>'o'</kbd>, we write the following:</p>
<pre>plot(x,'go')</pre>
<p>To plot histograms instead of regular plots, the command<span> </span><kbd>hist</kbd> is used:</p>
<pre># random vector with normal distribution
sigma, mu = 2, 10
x = sigma*numpy.random.standard_normal(10000)+mu 
hist(x,50,density=True)
z = linspace(0,20,200)
plot(z, (1/sqrt(2*pi*sigma**2))*exp(-(z-mu)**2/(2*sigma**2)),'g')
# title with LaTeX formatting 
title(fr'Histogram with $\mu={mu}, \sigma={sigma}')</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9d2b730a-47c1-40ff-b0cd-b5ff99327b78.png" style="width:28.33em;height:22.08em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.4: Normal distribution with 50 bins and a green curve indicating the true distribution</div>
<p>The resulting plot looks similar to <em>Figure 6.4</em>. The title, and any other text, can be formatted using LaTeX to show mathematical formulas. LaTeX formatting is enclosed within a pair of<span> </span><kbd>$</kbd><span> </span>signs. Also, note the string formatting done using the method<span> </span><kbd>format</kbd>; see <a href="879c0554-386f-4bb1-8fa8-b86c43927545.xhtml">Section 2.4.3</a>, <em>String formatting</em>.</p>
<p>Sometimes, the brackets for the string formatting interfere with LaTeX bracket environments. If this occurs, replace the LaTeX bracket with a double bracket; for example,<span> </span><kbd>x_{1}</kbd><span> </span>should be replaced with<span> </span><kbd>x_{{1}}</kbd>. The text might contain sequences that overlap with string escape sequences,<span> </span><span>for example,</span> <kbd>\tau</kbd><span> </span>will be interpreted as the tab character,<span> </span><kbd>\t</kbd>. An easy workaround is to add<span> </span><kbd>r</kbd><span> </span>before the string, for example, <kbd>r'\tau'</kbd>. This makes it a raw string.</p>
<p>Placing several plots in one figure window can be done using the command<span> </span><kbd>subplot</kbd>. Consider the following example, which iteratively averages out the noise on a sine curve.</p>
<pre>def avg(x):
    """ simple running average """
    return (roll(x,1) + x + roll(x,-1)) / 3
# sine function with noise
x = linspace(-2*pi, 2*pi,200)
y = sin(x) + 0.4*numpy.random.standard_normal(200)

# make successive subplots
for iteration in range(3):
    subplot(3, 1, iteration + 1)
    plot(x,y, label = '{:d} average{}'.format(iteration, 's' if iteration &gt; 1 else ''))
    yticks([])
    legend(loc = 'lower left', frameon = False)
    y = avg(y) #apply running average 
subplots_adjust(hspace = 0.7)</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4ece0cd7-35f1-4ea1-80a4-606d8f8b4633.png" style="width:24.00em;height:16.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.5: An example of plotting several subplots in the same figure window</div>
<p>The function<span> </span><kbd>avg</kbd> uses the NumPy function <kbd>roll</kbd><span> </span>to shift all values of the array.<span> </span><kbd>subplot</kbd><span> </span>takes three arguments: the number of vertical plots, the number of horizontal plots, and an index indicating which location to plot in (counted row-wise). Note that we used the command<span> </span><kbd>subplots_adjust</kbd><span> </span>to add extra space to adjust the distance between the subplots.</p>
<p>A useful command is<span> </span><kbd>savefig</kbd><span>, </span>which lets you save a figure as an image (this can also be done from the figure window). Many image and file formats are supported by this command; they are specified by the filename's extension as:</p>
<pre>savefig('test.pdf')  # save to pdf</pre>
<p>or</p>
<pre>savefig('test.svg')  # save to svg (editable format)</pre>
<p>You can place the image against a non-white background, for example, a web page. For this, the parameter <kbd>transparent</kbd><span> </span>can be set to make the figure's background transparent:</p>
<pre>savefig('test.pdf', transparent=True)</pre>
<p>If you intend to embed a figure into a LaTeX document, it is recommended that you reduce the surrounding white space by<span> </span>setting the figure's bounding box tight<span> </span>around the drawing, as shown here:</p>
<pre>savefig('test.pdf', bbox_inches='tight')</pre>
<h2 id="uuid-08f2c996-0050-4ef0-ba06-659cc9a8bcf8">6.1.3 Working with meshgrid and contours</h2>
<p>A common task is a graphical representation of a scalar function over a rectangle:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/bf7a60e2-808a-4314-8834-89fbc8f13bed.png" style="width:13.67em;height:1.75em;"/></p>
<p>For this, first we have to generate a grid on the rectangle <img class="fm-editor-equation" src="assets/b8fbb3cc-da62-4469-b2e1-8882e423bac6.png" style="width:5.75em;height:1.33em;"/>. This is done using the command<span> </span><kbd>meshgrid</kbd><span> </span>:</p>
<pre>n = ... # number of discretization points along the x-axis<br/>m = ... # number of discretization points along the x-axis <br/>X,Y = meshgrid(linspace(a,b,n), linspace(c,d,m))</pre>
<p class="CDPAlignLeft CDPAlign"><kbd>X</kbd><span> </span>and<span> </span><kbd>Y</kbd> are arrays with an<span> </span><kbd>(n,m)</kbd><span> </span>shape such that <kbd>X[i,j]</kbd> and <kbd>Y[i,j]</kbd> contain the coordinates of the grid point <sub><span><img class="fm-editor-equation" src="assets/30c2ef7b-8ed9-474e-a2c7-fb9dea5e92f3.png" style="width:1.33em;height:1.17em;"/></span></sub>, as shown in <em>Figure 6.6</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f5b1481f-1499-4c11-8758-b8049dd174cb.png" style="width:26.00em;height:14.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.6: A rectangle discretized by meshgrid.</div>
<p>A rectangle discretized by <kbd>meshgrid</kbd> will be used in the next section to visualize the behavior of an iteration, while we will use it <span>here </span>to plot the level curves of a function. This is done by the command <kbd>contour</kbd>.</p>
<p> </p>
<p>As an example, we choose Rosenbrock's banana function:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/3ea8cf3c-24a2-416a-a130-2cefe007da25.png" style="width:14.92em;height:1.33em;"/></p>
<p>It is used to challenge optimization methods, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[27]</a>. The function values descend toward a banana-shaped valley, which itself decreases slowly toward the function's global minimum at (1, 1).</p>
<p>First, we display the level curves using<span> </span><kbd>contour</kbd>:</p>
<pre>rosenbrockfunction = lambda x,y: (1-x)**2+100*(y-x**2)**2 
X,Y = meshgrid(linspace(-.5,2.,100), linspace(-1.5,4.,100))
Z = rosenbrockfunction(X,Y) 
contour(X,Y,Z,logspace(-0.5,3.5,20,base=10),cmap='gray') 
title('Rosenbrock Function: ')
xlabel('x')
ylabel('y')</pre>
<p>This plots the level curve at the levels given by the fourth parameter and uses the colormap<span> </span><kbd>gray</kbd>. Furthermore, we used logarithmically spaced steps from 10<sup>0.5</sup><span> </span>to 10<sup>3</sup> using the function<span> </span><kbd>logscale</kbd><span> </span>to define the levels, see <em>Figure 6.7</em>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/297117a6-be35-49fb-bd9a-e882ec0a0d08.png" style="width:28.50em;height:23.00em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.7: A contour plot of the Rosenbrock function</div>
<p>In the<span> </span>preceding example, an anonymous function indicated by the keyword<span> </span><kbd>lambda</kbd><span> </span>is used to keep the code compact. Anonymous functions are explained in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.7</a>, <em>Anonymous Functions </em>. If levels are not given as arguments to<span> </span><kbd>contour</kbd>, the function chooses appropriate levels by itself.</p>
<p>The function <kbd>contourf</kbd><span> </span>performs the same task as<span> </span><kbd>contour</kbd><span>, </span>but fills the plot with colors according to different levels. Contour plots are ideal for visualizing the behavior of a numerical method. We illustrate this here by showing the iterations of an optimization method.</p>
<p>We continue the preceding example and depict the steps toward the minimum of the Rosenbrock function generated by Powell's method, which we will apply to find the minimum of the Rosenbrock function:</p>
<pre>import scipy.optimize as so
rosenbrockfunction = lambda x,y: (1-x)**2+100*(y-x**2)**2
X,Y=meshgrid(linspace(-.5,2.,100),linspace(-1.5,4.,100))
Z=rosenbrockfunction(X,Y)
cs=contour(X,Y,Z,logspace(0,3.5,7,base=10),cmap='gray')
rosen=lambda x: rosenbrockfunction(x[0],x[1])
solution, iterates = so.fmin_powell(rosen,x0=array([0,-0.7]),retall=True)
x,y=zip(*iterates)
plot(x,y,'ko') # plot black bullets
plot(x,y,'k:',linewidth=1) # plot black dotted lines
title("Steps of Powell's method to compute a minimum")
clabel(cs)</pre>
<p class="CDPAlignLeft CDPAlign">The iterative method<span> </span><kbd>fmin_powell</kbd><span> </span>applies Powell's method to find a minimum. It is started by a given start value <em><sub><img class="fm-editor-equation" src="assets/2cc00c09-516b-4d00-828a-1c36ee601c4f.png" style="width:1.25em;height:1.00em;"/></sub></em> and reports all iterates when the option<span> </span><kbd>retall=True</kbd><span> </span>is given. After 16 iterations, the solution <img class="fm-editor-equation" src="assets/899aeac0-4ed8-4a07-aa68-aefa0abcfbf9.png" style="width:5.33em;height:1.08em;"/> was found. . The iterations are depicted as bullets in the contour plot; see <em>Figure 6.8.</em></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8264e8e-e652-40ce-b542-cd5933ccb2b3.png" style="width:27.00em;height:21.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.8: A contour plot of the Rosenbrock function with a search path of an optimization method</div>
<p>The function <kbd>contour</kbd><span> </span>also creates a contour set object that we assigned to the variable<span> </span><kbd>cs</kbd>. This is then used by<span> </span><kbd>clabel</kbd><span> </span>to annotate the levels of the corresponding function values, as shown in the <em>Figure 6.8</em>.</p>
<h2 id="uuid-7e52ceff-dab1-4a20-b9d2-193fcb344dc0">6.1.4 Generating images and contours</h2>
<p>Let's take a look at some examples of visualizing arrays as images. The following function will create a matrix of color values for the Mandelbrot fractal, see also <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[20]</a>.<span> </span>Here, we consider a fixed-point iteration, which depends on a complex parameter, <img class="fm-editor-equation" src="assets/7da969b2-9b13-46c2-8302-ac87dcd6ea89.png" style="width:0.67em;height:1.00em;"/>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/94a571d8-b85c-4c81-b346-4715ff922487.png" style="width:22.33em;height:1.83em;"/></p>
<p>Depending on the choice of this parameter, it may or may not create a bounded sequence of complex values, <img class="fm-editor-equation" src="assets/79494086-b942-40d5-8ddd-9d5909102f58.png" style="width:1.50em;height:1.17em;"/>.</p>
<p>For every value of <img class="fm-editor-equation" src="assets/8f79f3af-5180-4652-be25-3ac505e9c0e1.png" style="width:0.67em;height:1.00em;"/>,<span> we check whether</span> <sub><span><img class="fm-editor-equation" src="assets/e18e3d50-d5e0-4d92-9a5b-729259d50640.png" style="width:1.50em;height:1.17em;"/></span></sub><span> </span><span>exceeds a prescribed bound. If it remains below the bound within</span><span> </span><kbd>maxit</kbd><span> </span><span>iterations, we assume the sequence to be bounded.</span></p>
<p>Note how, in the following piece of code,<kbd>meshgrid</kbd><span> </span>is used to generate a matrix of complex parameter values, <em><img class="fm-editor-equation" src="assets/23c90700-fa16-49ff-a92c-4d06ad22376d.png" style="width:0.67em;height:1.00em;"/></em>:</p>
<pre>def mandelbrot(h,w, maxit=20):
    X,Y = meshgrid(linspace(-2, 0.8, w), linspace(-1.4, 1.4, h))
    c = X + Y*1j
    z = c
    exceeds = zeros(z.shape, dtype=bool)

    for iteration in range(maxit):
        z  = z**2 + c
        exceeded = abs(z) &gt; 4
        exceeds_now = exceeded &amp; (logical_not(exceeds))  
        exceeds[exceeds_now] = True        
        z[exceeded] = 2  # limit the values to avoid overflow
    return exceeds

imshow(mandelbrot(400,400),cmap='gray')
axis('off')</pre>
<p>The command<span> </span><kbd>imshow</kbd> displays the matrix as an image. The selected color map shows the regions where the sequence appeared unbounded in white and others in black. Here, we used<span> </span><kbd>axis('off')</kbd><span> </span>to turn off the axis as this might not be so useful for images.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/509af838-00f1-4ec8-acce-bf44d789faa4.png" style="width:16.75em;height:16.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.9: An example of using imshow to visualize a matrix as an image</div>
<p>By default,<span> </span><kbd>imshow</kbd><span> </span>uses interpolation to make the images look nicer. This is clearly seen when the matrices are small. The next figure shows the difference between using:</p>
<pre>imshow(mandelbrot(40,40),cmap='gray')</pre>
<p>and</p>
<pre>imshow(mandelbrot(40,40), interpolation='nearest', cmap='gray')</pre>
<p>In the second example, pixel values are just replicated, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[30]</a>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae936a8e-16d1-4fd1-8a10-bc1a5c07efba.png" style="width:23.08em;height:11.00em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.10: The difference between using the linear interpolation of imshow compared to using nearest-neighbor interpolation</div>
<p class="CDPAlignLeft CDPAlign">For more details on working and plotting with images using Python.</p>
<p>After having seen how to make plots in the "command-way," we will consider a more object-oriented approach <span>in the following sections</span>. Although slightly more complicated, it opens up a vast range of applications.</p>
<h1 id="uuid-7c1aa95f-c767-4a30-9290-b016200f9ee5">6.2 Working with Matplotlib objects directly</h1>
<p>Till now, we have used the<span> </span><kbd>pyplot</kbd><span> </span>module of matplotlib. This module makes it easy for us to use the most important plot commands directly. Mostly, we are interested in creating a figure and displaying it immediately. Sometimes, though, we want to generate a figure that should be modified later by changing some of its attributes. This requires us to work with graphical objects in an object-oriented way. In this section, we will present some basic steps to modify figures. For a more sophisticated object-oriented approach to plotting in Python, you have to leave<span> </span><kbd>pyplot</kbd><span> </span>and have to dive directly into<span> </span><kbd>matplotlib</kbd><span> </span>with its extensive documentation.</p>
<h2 id="uuid-f566025c-7757-4940-b284-8ae221602b10">6.2.1 Creating axes objects</h2>
<p>When creating a plot that should be modified later, we need references to a figure and an axes object. For this, we have to create a figure first and then define some axes and their location in the figure, and we should not forget to assign these objects to a variable:</p>
<pre>fig = figure()
ax = subplot(111)</pre>
<p>A figure can have several axes objects depending on the use of<span> </span><kbd>subplot</kbd>. In a second step, plots are associated with a given axes object:</p>
<pre>fig = figure(1) <br/>ax = subplot(111) <br/>x = linspace(0,2*pi,100) # We set up a function that modulates the <br/>                         # amplitude of the sin function <br/>amod_sin = lambda x: (1.-0.1*sin(25*x))*sin(x) <br/># and plot both... <br/>ax.plot(x,sin(x),label = 'sin') <br/>ax.plot(x, amod_sin(x), label = 'modsin')</pre>
<p>Here, we used an anonymous function indicated by the keyword<span> </span><kbd>lambda</kbd>. We will explain this construct later in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.7</a>, <em>Anonymous functions</em><span>.</span><span> </span>In fact, these two plot commands fill the list<span> </span><kbd>ax.lines</kbd><span> </span>with two<span> </span><kbd>Lines2D</kbd><span> </span>objects:</p>
<pre>ax.lines #[&lt;matplotlib.lines.Line2D at ...&gt;, &lt;matplotlib.lines.Line2D at ...&gt;]</pre>
<p>It is a good practice to use labels so that we can later identify objects in an easy way:</p>
<pre>for il,line in enumerate(ax.lines):
    if line.get_label() == 'sin':
       break</pre>
<p><span class="fontstyle0">We have now set things up in a way that allows further modifications. The figure we have obtained thus far is shown in <em>Figure</em></span><span> </span><em><span class="fontstyle2">6</span><span class="fontstyle0">.</span><span class="fontstyle2">11</span><span class="fontstyle0">, (left).</span></em></p>
<h2 id="uuid-9e20b719-3b4a-433b-ab44-20c4b1b6c0c7">6.2.2 Modifying line properties</h2>
<p>We just identified a particular line object by its label. It is an element of the list<span> </span><kbd>ax.lines</kbd><span> </span>with the index<span> </span><kbd>il</kbd>. All of its properties are collected in a dictionary:</p>
<pre>dict_keys(['marker', 'markeredgewidth', 'data', 'clip_box', 'solid_capstyle', 'clip_on', 'rasterized', 'dash_capstyle', 'path', 'ydata', 'markeredgecolor', 'xdata', 'label', 'alpha', 'linestyle', 'antialiased', 'snap', 'transform', 'url', 'transformed_clip_path_and_affine', 'clip_path', 'path_effects', 'animated', 'contains', 'fillstyle', 'sketch_params', 'xydata', 'drawstyle', 'markersize', 'linewidth', 'figure', 'markerfacecolor', 'pickradius', 'agg_filter', 'dash_joinstyle', 'color', 'solid_joinstyle', 'picker', 'markevery', 'axes', 'children', 'gid', 'zorder', 'visible', 'markerfacecoloralt'])</pre>
<p>This can be obtained by the following command:</p>
<pre>ax.lines[il].properties()</pre>
<p>They can be changed by corresponding setter methods. Let's now change the line style of the sine curve:</p>
<pre>ax.lines[il].set_linestyle('-.')
ax.lines[il].set_linewidth(2)</pre>
<p>We can even modify the data, as shown:</p>
<pre>ydata=ax.lines[il].get_ydata()
ydata[-1]=-0.5
ax.lines[il].set_ydata(ydata)</pre>
<p>The result is shown in <em>Figure 6.11, (right)</em>:</p>
<div class="CDPAlignCenter CDPAlign"> <img src="assets/fb85293c-d3b5-49dc-b8b7-c982db0cf062.png" style="width:36.17em;height:15.83em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.11: The amplitude-modulated sine function (left) and a curve with the last data point corrupted (right)</div>
<h2 id="uuid-1719f07d-637c-447b-a935-d64571bfff5f">6.2.3 Making annotations</h2>
<p>One useful axes method is<span> </span><kbd>annotate</kbd>. It sets an annotation at a given position and points, with an arrow, to another position in the drawing. The arrow can be given properties in a dictionary:</p>
<pre>annot1=ax.annotate('amplitude modulated\n curve', (2.1,1.0),(3.2,0.5),
       arrowprops={'width':2,'color':'k', <br/>                   'connectionstyle':'arc3,rad=+0.5', 
                   'shrink':0.05},
       verticalalignment='bottom', horizontalalignment='left',fontsize=15, 
                   bbox={'facecolor':'gray', 'alpha':0.1, 'pad':10})
annot2=ax.annotate('corrupted data', (6.3,-0.5),(6.1,-1.1),
       arrowprops={'width':0.5,'color':'k','shrink':0.1},
       horizontalalignment='center', fontsize=12)</pre>
<p>In the first annotation example above, the arrow points to a point with the coordinates (<em>2.1, 1.0</em>), and the left-bottom coordinate of the text is (<em>3.2, 0.5</em>). If not otherwise specified, the coordinates are given in the convenient data coordinate system, which refers to the data used to generate the plots.</p>
<p>Furthermore, we demonstrated a couple of arrow properties specified by the <span>dictionary</span><span> </span><kbd>arrowprop</kbd>. You can scale the arrow by the <span>key</span> <kbd>shrink</kbd>. The setting<span> </span><kbd>'shrink':0.05</kbd><span> </span>reduces the arrow size by 5% to keep a distance to the curve it points to. You can let the arrow<span> </span>take the form of a spline arc or give it other shapes using the key <kbd>connectionstyle</kbd>.</p>
<p>Text properties, or even a bounding box around the text, can be made by extra keyword arguments to the annotate method, see <em>Figure 6.12, (left</em>).</p>
<p>Experimenting with annotations sometimes requires several attempts and we need<span><span> </span></span>to reject some of those. Therefore, we assigned the annotate object to a variable, which allows us to remove the annotation by its <kbd>remove</kbd> method:</p>
<pre>annot1.remove()</pre>
<h2 id="uuid-ab08f7ae-8f50-48bb-ad94-b2bd39a3ef4f">6.2.4 Filling areas between curves</h2>
<p>Filling is an ideal tool for highlighting differences between curves, such as noise on top of expected data and approximations versus exact functions.</p>
<p>Filling is done by the axis method, <kbd>fill_between</kbd>:</p>
<pre>ax.fill_between(x,y1,y2)</pre>
<p>For the next figure, we used the following command:</p>
<pre>axf = ax.fill_between(x, sin(x), amod_sin(x), facecolor='gray')</pre>
<p> </p>
<p>From the last chapter, we already know the NumPy method, <kbd>where</kbd>. In the context here, <kbd>where</kbd> is a very convenient parameter that requires a Boolean array to specify the additional filling conditions:</p>
<pre>axf = ax.fill_between(x, sin(x), amod_sin(x),where=amod_sin(x)-sin(x) &gt; 0, facecolor=’gray’)</pre>
<p>The Boolean array that selects the regions to fill is given by the condition <kbd>amod_sin(x)-sin(x) &gt; 0</kbd>.</p>
<p>The next figure shows the curve with both variants of filling areas:</p>
<div class="CDPAlignCenter CDPAlign"> <span><img src="assets/67407da9-48ee-4d76-9731-3596707d1634.png" style="width:51.00em;height:23.25em;"/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.12: The amplitude-modulated sine function with annotations and filled areas (left), and a modified figure with only partially filled areas, by using the where parameter (right)</div>
<p>If you test these commands yourself, do not forget to remove the complete filling before you try out the partial filling, otherwise you will not see any change:</p>
<pre>axf.remove()</pre>
<p>Related filling commands are<span> </span><kbd>fill</kbd><span> for filling polygons </span>and<span> </span><kbd>fill_betweenx</kbd> for filling the areas in horizontal directions.</p>
<h2 id="uuid-aa10c40a-25f0-42c0-a996-555f44db5abc"> 6.2.5 Defining ticks and tick labels</h2>
<p>Figures in talks, posters, and publications look much nicer if they are not overloaded with unnecessary information. You want to direct the spectator to those parts that contain the message. In our example, we clean up the picture by removing ticks from the<span> </span><em>x </em>axis and<span> the </span><em>y </em>axis and by introducing problem-related tick labels:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/cc6a84f4-c69e-4d7d-ad83-e4bf7c748600.png" style="width:21.75em;height:17.08em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.13: The completed example of the amplitude-modulated sine function, with annotations and filled areas and modified ticks and tick labels</div>
<p>The ticks in <em>Figure 6.13</em> were set by the following commands. Note the LaTeX-way of setting labels with Greek letters:</p>
<pre>ax.set_xticks(array([0,pi/2,pi,3/2*pi,2*pi]))
ax.set_xticklabels(('$0$','$\pi/2$','$\pi$','$3/2 \pi$','$2 \pi$'),fontsize=18)
ax.set_yticks(array([-1.,0.,1]))
ax.set_yticklabels(('$-1$','$0$','$1$'),fontsize=18)</pre>
<p>Note that we used LaTeX formatting in the strings to represent Greek letters, to set formulas correctly, and to use a LaTeX font. It is also a good practice to increase the font size so that the resulting figure can be scaled down into a text document without affecting the readability of the axes. The final result of this guiding example is shown in <em>Figure 6.13</em>.</p>
<p> </p>
<h2 id="uuid-038d3674-b7f2-42d6-9bed-78c08815dd21">6.2.6 Setting spines makes your plot more instructive – a comprehensive example</h2>
<p>Spines are the lines with ticks and labels displaying the coordinates in a figure. If you do not take a special action, Matplotlib places them as four lines – bottom, right, top, and left, forming a frame defined by the axis parameters.</p>
<p>Often, pictures look better when not framed, and frequently there is a more instructive place to put the spines. In this section, we demonstrate different ways to alter the position of spines.</p>
<p>Let's start with a guiding example, see <em>Figure</em> 6.14.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/edcc56e5-af01-4b23-918a-f5ea1413c186.png" style="width:36.67em;height:27.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.14: A Matplotlib figure with a non-automatic placement of the spines</div>
<p>In this example, we choose to display only two of the four spines.</p>
<p>We deselected the spines at the top and on the right by using the method <kbd>set_visible</kbd>, and positioned the left and bottom spines in data coordinates by using the method <kbd>set_position</kbd>:</p>
<pre><br/>fig = figure(1)<br/>ax = fig.add_axes((0.,0.,1,1))<br/>ax.spines["left"].set_position(('data',0.))<br/>ax.spines["bottom"].set_position(("data",0.))<br/>ax.spines["top"].set_visible(False)<br/>ax.spines["right"].set_visible(False)<br/>x=linspace(-2*pi,2*pi,200)<br/>ax.plot(x,arctan(10*x), label=r'$\arctan(10 x)$')<br/>ax.legend()</pre>
<p class="mce-root">Spines carry ticks and tick labels. Normally, they are set automatically, but often placing them manually is advantageous.</p>
<p>In the following example, we even exploited the possibility of two sets of ticks, with different placement parameters. Matplotlib refers to these sets as '<em>minor</em>' and '<em>major</em>'. One of these sets was used for horizontally aligning the tick labels on the left side of the <em>y</em> axis:</p>
<pre>ax.set_xticks([-2*pi,-pi,pi,2*pi])<br/>ax.set_xticklabels([r"$-2\pi$",r"$-\pi$",r"$\pi$", r"$2\pi$"])<br/>ax.set_yticks([pi/4,pi/2], minor=True)<br/>ax.set_yticklabels([r"$\pi/4$", r"$\pi/2$"], minor=True)<br/>ax.set_yticks([-pi/4,-pi/2], minor=False,)<br/>ax.set_yticklabels([r"$-\pi/4$", r"$-\pi/2$"], minor=False) # major label set<br/>ax.tick_params(axis='both', which='major', labelsize=12)<br/>ax.tick_params(axis='y', which='major',pad=-35) # move labels to the right<br/>ax.tick_params(axis='both', which='minor', labelsize=12)</pre>
<p>The result is shown in Figure 6.15.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dd735ee6-c02a-436f-b715-02b266371708.png" style="width:34.92em;height:26.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.15: Changing the position of ticks and labels</div>
<p>This example can be elaborated much more by adding more axes and annotations. We refer to <em>Exercise 7</em> and <em>Figure 6.20</em>.</p>
<p>So far, we have considered 2D plots. We turn now in the next section to the visualization of 3D mathematical objects.</p>
<h1 id="uuid-45e4aa09-dfbe-46e5-864c-37939cfe3e38">6.3 Making 3D plots</h1>
<p>There are some useful<span> </span><kbd>matplotlib</kbd><span> </span>toolkits and modules that can be used for a variety of special purposes. In this section, we describe a method for producing 3D plots.</p>
<p>The toolkit<span> </span><kbd>mplot3d</kbd><span> </span>provides the 3D plotting of points, lines, contours, surfaces, and all other basic components, as well as 3D rotation and scaling. A 3D plot is generated by adding the keyword<span> </span><kbd>projection='3d'</kbd><span> </span>to the axes object, as shown in the following example:</p>
<pre>from mpl_toolkits.mplot3d import axes3d

fig = figure()
ax = fig.gca(projection='3d')
# plot points in 3D
class1 = 0.6 * random.standard_normal((200,3))
ax.plot(class1[:,0],class1[:,1],class1[:,2],'o')
class2 = 1.2 * random.standard_normal((200,3)) + array([5,4,0])
ax.plot(class2[:,0],class2[:,1],class2[:,2],'o')
class3 = 0.3 * random.standard_normal((200,3)) + array([0,3,2])
ax.plot(class3[:,0],class3[:,1],class3[:,2],'o')</pre>
<p>As you can see, you need to import the type<span> </span><kbd>axes3D</kbd><span> </span>from<span> </span><kbd>mplot3d</kbd>. The resulting plot displays the scattered 3D data, which can be seen in <em>Figure 6.16</em>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9827dbe5-eab1-4a5d-b0ba-1a75281e3a42.png" style="width:24.92em;height:21.50em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.16: Plotting 3D data using the mplot3d toolkit</div>
<p>Plotting surfaces is just as easy. The following example uses the built-in function<span> </span><kbd>get_test_data</kbd><span> </span>to create sample data for plotting a surface. Consider the following example of a surface plot with transparency:</p>
<pre>X,Y,Z = axes3d.get_test_data(0.05)

fig = figure()
ax = fig.gca(projection='3d')
# surface plot with transparency 0.5 
ax.plot_surface(X,Y,Z,alpha=0.5)</pre>
<p>The<span> </span><em>alpha</em><span> </span>value sets the transparency. The surface plot is shown <em>Figure 6.17.</em></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/acf60e0f-5670-40bc-863f-5156dc8d1cb3.png" style="width:28.25em;height:23.75em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.17: Example of plotting a surface mesh </div>
<p class="CDPAlignLeft CDPAlign">You can also plot contours in any of the coordinate projections, as in the following example:</p>
<pre>fig = figure()
ax = fig.gca(projection = '3d')
ax.plot_wireframe(X,Y,Z,rstride = 5,cstride = 5)

# plot contour projection on each axis plane
ax.contour(X,Y,Z, zdir='z',offset = -100)
ax.contour(X,Y,Z, zdir='x',offset = -40)
ax.contour(X,Y,Z, zdir='y',offset = 40)

# set axis limits
ax.set_xlim3d(-40,40)
ax.set_ylim3d(-40,40)
ax.set_zlim3d(-100,100)

# set labels
ax.set_xlabel('X axis')
ax.set_ylabel('Y axis')
ax.set_zlabel('Z axis')</pre>
<p>Note the commands for setting the axis limits. The standard<span> </span><kbd>matplotlib</kbd><span> </span>command for setting the axis limits is <kbd>axis([-40, 40, -40, 40])</kbd>. This works fine for 2D plots. However, <kbd>axis([-40,40,-40,40,-40,40])</kbd> does not work. For 3D plots, you need to use the object-oriented version of this command,<span> </span><kbd>ax.set_xlim3d(-40,40)</kbd>. The same goes for labeling the axis; note the commands for setting the labels. For 2D plots, you can do<span> </span><kbd>xlabel(’X axis’)</kbd><span> </span>and<span> </span><kbd>ylabel(’Y axis’)</kbd><span>, </span>but there is no command<span> </span><kbd>zlabel</kbd>. Instead, in 3D plots, you need to use<span> </span><kbd>ax.set_xlabel(’X axis’)</kbd> and likewise for the other labels, as shown in the preceding example.</p>
<p>The resulting figure from this code is the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/90bbde60-4d49-4366-9efe-c6304645e46c.png" style="width:27.25em;height:22.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.18: A 3D plot with additional contour plots in the three coordinate projections</div>
<p>There are many options for formatting the appearance of the plots, including color and the transparency of surfaces. The<span> </span><kbd>mplot3d</kbd><span> </span>documentation website <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[23]</a>, has the details.</p>
<p>Mathematical objects are sometimes better visualized dynamically by a sequence of pictures or even movies. This is the topic of the next section.</p>
<h1 id="uuid-64d340dc-b1a8-44f7-8412-edd6d1adea87">6.4 Making movies from plots</h1>
<p>If you have data that evolves, you might want to save it as a movie as well as showing it in a figure window, similar to the <span>command</span><span> </span><kbd>savefig</kbd>. One way to do this is with the <span>module</span><span> </span><kbd>visvis</kbd>, see <a href="">[37]</a>. </p>
<p>Here is a simple example of evolving a circle using an implicit representation. Let the circle be represented by the zero level,<span> </span></p>
<p><img class="fm-editor-equation" src="assets/53d5e400-f103-4d73-8d95-1d9f771a7e14.png" style="width:8.92em;height:1.75em;"/> of a function <img class="fm-editor-equation" src="assets/3cad0783-6c67-4da2-8bed-6f3de9a998f8.png" style="width:7.50em;height:1.92em;"/>.</p>
<p>Alternatively, consider the disk <img class="fm-editor-equation" src="assets/4f11df5a-0c9f-413a-9548-2dc4796ac29b.png" style="width:8.92em;height:1.75em;"/> inside the zero set of <img class="fm-editor-equation" src="assets/6f82cbed-2f3f-4614-9e23-eca35223238a.png" style="width:0.83em;height:1.67em;"/>. If the value of <img class="fm-editor-equation" src="assets/2b7a8922-2cce-4811-8ef9-6fce4d09ab58.png" style="width:0.83em;height:1.67em;"/>decreases at a rate <span><img class="fm-editor-equation" src="assets/66d4131e-1c59-423c-8242-933277ff6eba.png" style="width:0.83em;height:1.00em;"/></span>, then the circle will move outward at the rate <img class="fm-editor-equation" src="assets/cc1d309a-3955-4e88-980a-1c4eff3b32a9.png" style="width:5.25em;height:1.75em;"/>.</p>
<p>This can be implemented as:</p>
<pre>import visvis.vvmovie as vv

# create initial function values
x = linspace(-255,255,511)
X,Y = meshgrid(x,x)
f = sqrt(X*X+Y*Y) - 40 #radius 40

# evolve and store in a list
imlist = []
for iteration in range(200):
    imlist.append((f&gt;0)*255)
    f -= 1 # move outwards one pixel
vv.images2swf.writeSwf('circle_evolution.swf',imlist)</pre>
<p>The result is a flash movie (<kbd>*.swf</kbd> file) of a growing black circle, as shown in <em>Figure 6.19.</em></p>
<div class="CDPAlignCenter CDPAlign"><span><img src="assets/0683ec0e-d3db-4236-aac8-c127bc6ebfd6.png" style="width:5.75em;height:5.42em;"/> <img src="assets/af022cbe-d334-4cd1-8b0f-a3179199221e.png" style="width:6.17em;height:5.92em;"/></span><span> <img src="assets/cb4d0486-dedf-456f-a4ad-60e895a754cd.png" style="width:7.25em;height:6.75em;"/></span><span> <img src="assets/03a96259-8454-4516-85ef-f3a9a87f52ff.png" style="width:8.58em;height:8.25em;"/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.19: An example of evolving a circle</div>
<p>In this example, a list of arrays was used to create the movie. The module<span> </span><kbd>visvis</kbd><span> </span>can also save a GIF animation and, on certain platforms, an AVI animation (<kbd>*.gif</kbd> and <kbd>*.avi</kbd> files), and there is also the possibility of capturing movie frames directly from the figure window. These options, however, require some more packages to be installed on your system (for example,<span> </span><kbd>PyOpenGL</kbd><span> </span>and<span> </span><kbd>PIL</kbd>, the Python Imaging Library). See the documentation on the<span> </span><kbd>visvis</kbd> web page for more details.</p>
<p>Another option is to use<span> </span><kbd>savefig</kbd><span> </span>to create images, one for each frame. The following code example creates a sequence of 200 picture files, which can then be combined into a video:</p>
<pre># create initial function values
x = linspace(-255,255,511)
X,Y = meshgrid(x,x)
f = sqrt(X*X+Y*Y) - 40 #radius 40
for iteration in range(200):
    imshow((f&gt;0)*255, aspect='auto')
    gray()
    axis('off')
    savefig('circle_evolution_{:d}.png'.format(iteration))
    f -= 1</pre>
<p>These images can then be combined using standard video editing software, for example, Mencoder or ImageMagick. This approach has the advantage that you can make high-resolution videos by saving high-resolution images.</p>
<h1 id="uuid-5925b1de-41d2-4f78-a123-277242a4c088">6.5 Summary</h1>
<p>A graphical representation is the most compact form in which to present mathematical results or the behavior of an algorithm. This chapter provided you with the basic tools for plotting and introduced you to a more sophisticated way to work with graphical objects, such as figures, axes, and lines in an object-oriented way.</p>
<p>In this chapter, you learned how to make plots, not only classical <em>x/y</em> plots, but also 3D plots and histograms. We gave you an appetizer on making films. You also saw how to modify plots, considering them to be graphical objects with related methods and attributes that can be set, deleted, or modified. </p>
<h1 id="uuid-786f41bf-e23d-42c4-80b1-9cc40db4435b">6.6 Exercises</h1>
<p><strong>Ex. 1:</strong> Write a function that plots an ellipse given its center coordinates (<em>x,y</em>), the half axis<span> </span><em>a,</em><span> </span>and<span> </span><em>b</em><span> </span>rotation angle <img class="fm-editor-equation" src="assets/41ba9462-862e-42f9-9719-4723a30ee33d.png" style="width:0.75em;height:1.33em;"/>.</p>
<p><strong>Ex. 2:</strong> Write a short program that takes a 2D array, for example, the preceding Mandelbrot contour image, and iteratively replace each value by the average of its neighbors. Update a contour plot of the array in a figure window to animate the evolution of the contours. Explain the behavior.</p>
<p><strong>Ex. 3:</strong> Consider an <img class="fm-editor-equation" src="assets/ab1805a6-ee8e-44b4-a1e3-043c630fc03e.png" style="width:4.67em;height:1.33em;"/> matrix or image with integer values. The mapping</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6fb1559c-a1fb-45f5-b477-e3ba88bd5d7e.png" style="width:23.00em;height:1.75em;"/></p>
<p>is an example of a mapping of a toroidal square grid of points onto itself. This has the interesting property that it distorts the image by shearing and then moving the pieces outside the image back using the modulo function,<span> </span><kbd>mod</kbd>. Applied iteratively, this results in randomizing the image in a way that eventually returns the original. Implement the following sequence,</p>
<p class="CDPAlignCenter CDPAlign"><span><img class="fm-editor-equation" src="assets/58f5266a-a958-4494-a86e-0fec0a7dca8d.png" style="width:32.67em;height:2.08em;"/>,</span></p>
<p>and save out the first <img class="fm-editor-equation" src="assets/324ad186-7011-4d4f-8639-4ce386dfdc15.png" style="width:0.92em;height:0.83em;"/> steps to files or plot them in a figure window.</p>
<p>As an example image, you can use the classic 512<span> </span><em>×</em><span> </span>512 Lena test image from<span> </span><kbd>scipy.misc</kbd>:</p>
<pre>from scipy.misc import lena
I = lena()</pre>
<p>The result should look like this:</p>
<table>
<tbody>
<tr>
<td><img src="assets/1c2ca42a-82c1-49a3-a149-d04714f1d85e.png"/></td>
<td><img src="assets/862a99ab-c967-4f3d-9632-cffe8776bc6c.png"/></td>
<td>…</td>
<td><img src="assets/e4cea046-8a57-4eba-a979-c88ea1971f44.png"/></td>
<td>…</td>
<td><img src="assets/122156fe-df35-41e5-a1e2-6b26cb575482.png"/></td>
<td>…</td>
<td><img src="assets/3173fa79-21df-4333-8883-f524e70bc76a.png"/></td>
<td><img src="assets/f7dc2216-0045-488d-a339-020a20ed5fa6.png"/></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td> </td>
<td>128</td>
<td> </td>
<td>256</td>
<td> </td>
<td>511</td>
<td>512</td>
</tr>
</tbody>
</table>
<p class="mce-root">Compute the<span> </span><em>x</em><span> </span>and<span> </span><em>y</em><span> </span>mappings and use array indexing (see <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.3</a>: <em><span>Array indexing</span></em><span>) to copy the pixel values.</span></p>
<p><strong>Ex. 4:</strong> Reading and plotting on images. SciPy comes with the function <kbd>imread</kbd><span> </span>(in the<span> </span><kbd>scipy.misc</kbd><span> </span>module) for reading images (see <a href="f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml">Section 14.6</a>: <em>Reading and Writing Images</em>). Write a short program that reads an image from file and plots the image contour at a given gray-level value overlaid on the original image. You can get a grey-level version of the image by averaging the color channels like this:<span> </span><kbd>mean(im,axis=2)</kbd></p>
<p><strong>Ex. 5:</strong> Image edges. The zero crossings of the 2D Laplacian are a good indication of image edges. Modify the program in the previous exercise to use the<span> </span><kbd>gaussian_laplace</kbd><span> </span>or<span> </span><kbd>laplace</kbd><span> </span>function from the<span> </span><kbd>scipy.ndimage</kbd><span> </span>module to compute the 2D Laplacian and overlay the edges on top of the image.</p>
<p><strong>Ex. 6:</strong> Reformulate the Mandelbrod fractal example <a href="86c61820-e645-486c-9418-10079ffac7f8.xhtml">Section 6.1.4</a>: <em>Generating images and contours</em><em><span> </span></em>by using<span> </span><kbd>orgid</kbd><span> </span>instead of<span> </span><kbd>meshgrid</kbd><span>. S</span>ee also the explanation of <kbd>ogrid</kbd> in<span> <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.5.3</a>, <em>Typical examples</em></span>. What is the difference between<span> </span><kbd>orgid</kbd>,<span> </span><kbd>mgrid</kbd>, and<span> </span><kbd>meshgrid</kbd>?</p>
<p><strong>Ex. 7:</strong><span> </span>In <em>Figure</em> <em>6.20</em>, the use of the arctan function for approximating a jump (Heaviside function) is studied. A section of this curve is zoomed in to visualize the quality of the approximation. Reproduce this picture by means of your own code.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b9ee6bc2-3edd-4d2b-b244-2d86f5b611aa.png" style="width:37.92em;height:28.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 6.20: Approximation of the Heaviside function (jump function) by arctan functions</div>


            </article>

            
        </section>
    </body></html>