<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Iterating
                </header>
            
            <article>
                
<p>In this chapter, we will present iterations using loops and iterators. We will show examples of how this can be used with lists and generators. Iteration is one of the fundamental operations a computer is useful for. Traditionally, iteration is achieved with a<span> </span><kbd>for</kbd><span> </span>loop. A<span> </span><kbd>for</kbd><span> </span>loop is a repetition of a block of instructions a certain number of times. Inside the loop, you have access to a loop variable, in which the iteration number is stored.</p>
<p><span>A </span><kbd>for</kbd><span> </span>loop in Python is primarily designed to exhaust a list, that is, to repeat the same sequence of commands for each element of that list. The effect is similar to the repetition effect just described if you use a list containing the first <sub><img class="fm-editor-equation" src="assets/884f8125-1635-4209-8092-168269add126.png" style="width:0.83em;height:0.83em;"/></sub> integers.</p>
<p>A <kbd>for</kbd><span> </span>loop only needs one element of the list at a time. It is therefore desirable to use a <kbd>for</kbd><span> </span>loop with objects that are able to create those elements on demand, one at a time, instead of providing a complete list. This is what iterators achieve in Python. </p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>The for statement</li>
<li>Controlling the flow inside the loop</li>
<li>Iterable objects</li>
<li>List-filling patterns</li>
<li>When iterators behave as lists</li>
<li>Iterator objects</li>
<li>Infinite iterations</li>
</ul>
<p class="mce-root"/>
<h1 id="uuid-703ce219-1970-4b7a-b287-3b7253ead2bd">9.1 The for statement</h1>
<p>The primary aim of the <kbd>for</kbd><span> </span>statement is to traverse a list, that is, to apply the same sequence of commands to each element of a given list:</p>
<pre>for s in ['a', 'b', 'c']:
    print(s) # a b c</pre>
<p>In this example, the loop variable<span>, <kbd>s</kbd></span>, is successively assigned to one element of the list. Notice that the loop variable is available after the loop has terminated. This may sometimes be useful; see, for instance, the example in <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.2</a>:<em> Controlling the flow inside the loop</em><em>.</em></p>
<p>One of the most frequent uses of a<span> </span><kbd>for</kbd><span> </span>loop is to repeat, that is, to apply the same sequence of commands to each element of a given list: a given task a defined number of times, using the function<span> </span><kbd>range</kbd>, see <a href="cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml">Section 1.3.1</a><span>: <em>Lists</em></span>.</p>
<pre>for iteration in range(n): # repeat the following code n times
    ...</pre>
<p>If the purpose of a loop is to go through a list, many languages (including Python) offer the following pattern:</p>
<pre>for k in range(...):
    ...
    element = my_list[k]</pre>
<p>If the purpose of that code were to go through the list<span> </span><kbd>my_list</kbd>, the preceding code would not make it very clear. For this reason, a better way to express this is as follows: </p>
<pre>for element in my_list:
    ...</pre>
<p>It is now clear at first glance that the preceding piece of code goes through the list<span> </span><kbd>my_list</kbd>. Note that if you really need the index variable <span><sub><img class="fm-editor-equation" src="assets/63a53532-5287-44f2-8eda-69d97e13fc06.png" style="width:0.83em;height:1.33em;"/></sub></span>, you may replace the preceding code with this (see also <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.3.3</a>: <em>Iterator tools</em>):</p>
<pre>for k, element in enumerate(my_list):
    ...</pre>
<p>The intent of this piece of code is to go through<span> </span><kbd>my_list</kbd> while keeping the index variable <kbd>k</kbd> available. A similar construction for arrays is the command<span> </span><kbd>ndenumerate</kbd>:</p>
<pre>a=ones((3,5))<br/>for k,el in ndenumerate(a):<br/>    print(k,el)       <br/># prints something like this:  (1, 3) 1.0</pre>
<h1 id="uuid-0f5af4f9-6e54-4b10-8b85-555f0cb9698b">9.2 Controlling the flow inside the loop</h1>
<p>Sometimes it is necessary to jump out of the loop or to go directly to the next loop iteration. These two operations are performed by the commands<span> </span><kbd>break</kbd><span> </span>and<span> </span><kbd>continue</kbd>.  </p>
<p>The keyword<span> </span><kbd>break</kbd> is used to terminate the loop before it is completely executed—it breaks the loop.</p>
<p>Two situations can occur in loops with a <strong><kbd>break</kbd></strong> statement:</p>
<ul>
<li>The loop is completely executed.</li>
</ul>
<ul>
<li>The loop is left <span>when reaching </span><kbd>break</kbd> before it was completely executed.</li>
</ul>
<p>For the first case, special actions can be defined in an<span> </span><kbd>else</kbd> block, which is executed if the whole list is traversed. This is useful in general if the purpose of the<span> </span><kbd>for</kbd><span> </span>loop is to find something and stop. Examples might be searching for one element satisfying a certain property inside a list. If such an element is not found, the<span> </span><kbd>else</kbd><span> </span>block is executed.</p>
<p>Here is a common usage in scientific computing: Quite often, we use an iterating algorithm that is not guaranteed to succeed. In that case, it is preferable to use a (big) finite loop so that the program does not get caught in an infinite loop. The<span> </span><kbd>for</kbd>/<kbd>else</kbd><span> </span>construct allows such an implementation:</p>
<pre>maxIteration = 10000
for iteration in range(maxIteration):
    residual = compute() # some computation
    if residual &lt; tolerance:
        break
else: # only executed if the for loop is not broken
    raise Exception("The algorithm did not converge")
print(f"The algorithm converged in {iteration + 1} steps")</pre>
<h1 id="uuid-7e443d7d-b209-445d-abdd-977e9c7d5a92">9.3 Iterable objects</h1>
<p>A<span> </span><kbd>for</kbd><span> </span>loop is primarily used to traverse a list, but it picks the elements of the list one at a time. In particular, there is no need to store the whole list in memory for the loop to work properly. The mechanism that allows<span> </span><kbd>for</kbd><span> </span>loops to work without lists is that of iterators.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>An iterable object produces objects to be passed to a loop. Such an object may be used inside a<span> </span>loop as if it were a list:</p>
<pre>for element in obj:
    ...</pre>
<p>The notion of iterable objects thus generalizes the idea of lists.</p>
<p>The simplest example of an iterable object is given by lists. The produced objects are simply the objects stored in the list:</p>
<pre>L = ['A', 'B', 'C']
for element in L:
    print(element)</pre>
<p>An iterable object need not produce existing objects. The objects may, instead, be produced on the fly.</p>
<p>A typical iterable is the object returned by the function<span> </span><kbd>range</kbd>. This function works as if it would generate a list of integers, but instead, the successive integers are produced on the fly when they are needed:</p>
<pre>for iteration in range(100000000):
    # Note: the 100000000 integers are not created at once
    if iteration &gt; 10:
        break</pre>
<p>If you really need a list with all integers between 0 and 100,000,000, then it has to be formed explicitly:</p>
<pre class="mce-root">l=list(range(100000000))</pre>
<p class="mce-root">Iterable objects have a method called <kbd>__iter__</kbd>. That's how you can check whether a given object in Python is iterable.</p>
<p>So far, we have met the following datatypes, which are iterable objects:</p>
<ul>
<li><kbd>lists</kbd></li>
<li><kbd>tuples</kbd></li>
<li><kbd>strings</kbd></li>
<li><kbd>range</kbd> objects</li>
<li><kbd>dictionaries</kbd></li>
<li><kbd>arrays</kbd></li>
<li><kbd>enumerate</kbd> and <kbd>ndenumerate</kbd> objects</li>
</ul>
<p class="mce-root"/>
<p class="mce-root">By executing the method <kbd>__iter__</kbd> on an iterable object, an iterator is created. This is tacitly done when a <kbd>for</kbd> loop is invoked. An iterator has a <kbd>__next__</kbd> method, which returns the next element of a sequence:<strong><br/></strong></p>
<pre>l=[1,2] <br/>li=l.__iter__() <br/>li.__next__() # returns 1 <br/>li.__next__() # returns 2 <br/>li.__next__() # raises StopIteration exception </pre>
<h2 id="uuid-298eb4e3-4c5e-44d1-bb44-0c3d6517c155">9.3.1 Generators</h2>
<p>You can create your own iterator by using the keyword <kbd>yield</kbd>. For example, a generator for odd numbers smaller than <img class="fm-editor-equation" src="assets/4348dffe-7c52-4c93-b2ed-4ebcba289e27.png" style="width:1.08em;height:1.08em;"/> can be defined by:</p>
<pre>def odd_numbers(n): <br/>    "generator for odd numbers less than n" <br/>    for k in range(n): <br/>        if k % 2 == 1: <br/>           yield k</pre>
<p>Then you can use it as follows:</p>
<pre>g = odd_numbers(10)
for k in g:
    ...    # do something with k</pre>
<p>Or even like this:</p>
<pre>for k in odd_numbers(10):
    ... # do something with k</pre>
<h2 id="uuid-5bc4a34f-a554-4fc1-8828-33faf039f24b">9.3.2 Iterators are disposable</h2>
<p>One salient feature of iterators is that they may be used only once. In order to use the iterator again, you will have to create a new iterator object. Note that an iterable object is able to create new iterators as many times as necessary. Let's examine the case of a list:</p>
<pre>L = ['a', 'b', 'c']
iterator = iter(L)
list(iterator) # ['a', 'b', 'c']
list(iterator) # [] empty list, because the iterator is exhausted
<br/><br/>new_iterator = iter(L) # new iterator, ready to be used
list(new_iterator) # ['a', 'b', 'c']</pre>
<p>Each time a generator object is called, it creates a new iterator. Hence, when that iterator is exhausted, you have to call the generator again to obtain a new iterator:</p>
<pre>g = odd_numbers(10)
for k in g:
    ... # do something with k

# now the iterator is exhausted:
for k in g: # nothing will happen!!
    ...

# to loop through it again, create a new one:
g = odd_numbers(10)
for k in g:
    ...</pre>
<h2 id="uuid-fd551cca-0703-4e4e-9ff3-fe85a8c9dea3">9.3.3 Iterator tools</h2>
<p>Now, we will introduce a couple of iterator tools that often come in very handy:</p>
<ul>
<li><kbd>enumerate</kbd><span> </span>is used to enumerate another iterator. It produces a new iterator that yields pairs (<kbd>iteration</kbd>, element), where<span> </span><kbd>iteration</kbd><span> </span>stores the index of the iteration:</li>
</ul>
<pre style="padding-left: 60px">A = ['a', 'b', 'c']
for iteration, x in enumerate(A):
    print(iteration, x)     # result: (0, 'a') (1, 'b') (2, 'c')</pre>
<ul>
<li><kbd>reversed</kbd><span> </span>creates an iterator from a list by going through that list backward. Notice that this is different from creating a reversed list:</li>
</ul>
<pre style="padding-left: 60px">A = [0, 1, 2]
for elt in reversed(A):
    print(elt)      # result: 2 1 0</pre>
<ul>
<li><kbd>itertools.count</kbd><span> </span>is a possibly infinite iterator of integers:</li>
</ul>
<pre style="padding-left: 60px">for iteration in itertools.count():
    if iteration &gt; 100:
       break # without this, the loop goes on forever
       print(f'integer: {iteration}')
       # prints the 100 first integer</pre>
<ul>
<li><kbd>intertools.islice</kbd><span> </span>truncates an iterator using the familiar<span> </span><kbd>slicing</kbd><span> </span>syntax; see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.1</a>: <em>Slicing</em>. One application is creating a finite iterator from an infinite one:</li>
</ul>
<pre style="padding-left: 60px">from itertools import count, islice
for iteration in islice(count(), 10): 
     # same effect as range(10)
          ...</pre>
<p>For example, let's find some odd numbers by combining<span> </span><kbd>islice</kbd><span> </span>with an infinite generator. First, we modify the generator for odd numbers so that it becomes an infinite generator:</p>
<pre>def odd_numbers():
    k=-1
    while True:  # this makes it an infinite generator
        k+=1
        if k%2==1:
           yield k</pre>
<p>Then, we use it with<span> </span><kbd>islice</kbd><span> </span>to get a list of some odd numbers:</p>
<pre>list(itertools.islice(odd_numbers(),10,30,8)) <br/># returns [21, 37, 53]</pre>
<p>This command takes from an assumed list of all odd numbers, the one with index 10 to index 29 in steps of 8.</p>
<h2 id="uuid-bb109db9-d55e-4969-ba25-18f64c8ef9d9">9.3.4 Generators of recursive sequences</h2>
<p>Assume that a sequence is given by an induction formula. For instance, consider the Fibonacci sequence, defined by the recurrence formula:<span> </span></p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/a432e87d-4a3b-481f-9e74-d3d47460e116.png" style="width:8.67em;height:1.08em;"/>.</p>
<p>This sequence depends on two initial values, namely <sub><span><img class="fm-editor-equation" src="assets/51fb6836-fce2-4b89-9a06-a75e2c6bad68.png" style="width:1.33em;height:1.00em;"/></span></sub> and <sub><img class="fm-editor-equation" src="assets/bb815d4b-45f2-4d4a-a045-61875a23df13.png" style="width:1.33em;height:1.00em;"/></sub>, although for the standard Fibonacci sequence those numbers are taken as 0 and 1 respectively. A nifty way of programming the generation of such a sequence is by using generators, as follows:</p>
<pre>def fibonacci(u0, u1):
    """
    Infinite generator of the Fibonacci sequence.
    """
    yield u0
    yield u1
    while True:
        u0, u1 = u1, u1 + u0  <br/>        # we shifted the elements and compute the new one
        yield u1</pre>
<p>This may then be used, for instance, like this:</p>
<pre># sequence of the 100 first Fibonacci numbers:
list(itertools.islice(fibonacci(0, 1), 100))</pre>
<h2 id="uuid-1c70be0a-4103-467c-a3f7-6319d8a8678d">9.3.5 Examples for iterators in mathematics</h2>
<h3 id="uuid-c9c8309b-9b6f-4025-994a-5e23d05e0662"><span>Arithmetic geometric mean</span></h3>
<p>A more elaborate example for a generator is its use for an iteration based on iteratively computing arithmetic and geometric means – the so-called <strong>AGM iteration,</strong> see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[1]</a>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4a450656-718a-4c79-b8b8-038fd2a7dabf.png" style="width:6.75em;height:3.67em;"/></p>
<p>We demonstrate this iteration here in the context of computing elliptic integrals for determining the period of a mathematical pendulum.</p>
<p>When started with the values <img class="fm-editor-equation" src="assets/3f4b7ed9-ab08-4774-8cce-cb9ff9ac209b.png" style="width:9.75em;height:1.25em;"/>, the AGM iteration generates a sequence of numbers with the following (astonishing) property:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/33038d29-70ff-42b2-96ed-d194ec4800c7.png" style="width:18.50em;height:3.17em;"/></p>
<p>The integral on the right-hand side is called a complete elliptic integral of the first kind. We'll now proceed to compute this elliptic integral. We use a generator to describe the iteration:</p>
<pre>def arithmetic_geometric_mean(a, b):
    """
    Generator for the arithmetic and geometric mean
    a, b initial values
    """ 
    while True:    # infinite loop
         a, b = (a+b)/2, sqrt(a*b)
         yield a, b</pre>
<p>As the sequences <sub><img class="fm-editor-equation" src="assets/307dffaf-3613-428b-bbaf-de773830e787.png" style="width:6.25em;height:1.25em;"/></sub> converge to the same value, the sequence <sub><img class="fm-editor-equation" src="assets/f595ec23-48f9-4f3c-9269-6c7e1ad570c2.png" style="width:1.92em;height:1.25em;"/></sub> defined by <sub><img class="fm-editor-equation" src="assets/0b22114b-d670-41ce-999b-dc4c47cef153.png" style="width:5.33em;height:1.17em;"/></sub> converges to zero—a fact that will be used to terminate the iteration in the program to compute the elliptic integral:</p>
<pre>def elliptic_integral(k, tolerance=1.e-5):
    """
    Compute an elliptic integral of the first kind.
    """
    a_0, b_0 = 1., sqrt(1-k**2)
    for a, b in arithmetic_geometric_mean(a_0, b_0):
        if abs(a-b) &lt; tolerance:
            return pi/(2*a)</pre>
<p>We have to make sure that the algorithm stops. Note that this code fully relies on the mathematical statement that the arithmetic-geometric mean iteration converges (fast). In practical computing, we have to be careful while applying theoretical results, as they might no longer be valid in limited-precision arithmetic. The right way to make the preceding code safe is to use<span> </span><kbd>itertools.islice</kbd>. The safe code is as follows:</p>
<pre>from itertools import islice
def elliptic_integral(k, tolerance=1e-5, maxiter=100):
    """
    Compute an elliptic integral of the first kind.
    """
    a_0, b_0 = 1., sqrt(1-k**2)
    for a, b in islice(arithmetic_geometric_mean(a_0, b_0), maxiter):
        if abs(a-b) &lt; tolerance:
            return pi/(2*a)
    else:
        raise Exception("Algorithm did not converge")</pre>
<p>As an application, elliptic integrals may be used to compute the period <sub><img class="fm-editor-equation" src="assets/2305b79a-4aba-47f8-9a9f-5a6b6b1f9df4.png" style="width:0.92em;height:1.00em;"/></sub> of a pendulum<span> </span>of length<span> </span><sub><span><img class="fm-editor-equation" src="assets/0f853c58-6445-4d8e-a411-e073c213f108.png" style="width:0.67em;height:0.83em;"/></span></sub> starting at an angle <sub><img class="fm-editor-equation" src="assets/1de0db74-1210-4943-896d-5de9701da0bc.png" style="width:0.50em;height:0.92em;"/></sub> using:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/09a6b1af-cedc-48c1-be1e-093174af6636.png" style="width:10.17em;height:3.17em;"/>.</p>
<p>Using this formula, the period of the pendulum is easily obtained, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[18]</a>:</p>
<pre>def pendulum_period(L, theta, g=9.81):
    return 4*sqrt(L/g)*elliptic_integral(sin(theta/2))</pre>
<h3 id="uuid-ec304295-e715-4162-8bb1-5a4410c46f51">Convergence acceleration</h3>
<p>We'll give an example of the application of generators for convergence acceleration. This presentation closely follows the example given in <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[9]</a>.</p>
<p>Note that a generator may take another generator as an input parameter. For instance, suppose that we have defined a generator that generates the elements of a converging sequence. It is then possible to improve the convergence by an acceleration technique due to<span> </span><em>Euler</em><span> </span>and<span> </span><em>Aitken</em>, often called Aitken's Δ<sup>2</sup>-method, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[33]</a><em>.</em><span> </span>It transforms a sequence<span> </span><sub><span><img class="fm-editor-equation" src="assets/7a713aba-765a-4631-9538-03b54ca291c3.png" style="width:1.42em;height:1.33em;"/></span></sub> into another by defining </p>
<p style="padding-left: 150px"><img src="assets/d3bc7362-d7f9-48b9-99c7-f8e1e0dd100f.png" style="width:16.75em;height:3.58em;"/></p>
<p>Both sequences have the same limit, but the sequence <sub><img class="fm-editor-equation" src="assets/f14f54e1-ea9a-485e-bbe3-f139d46526d7.png" style="width:0.83em;height:1.17em;"/></sub> converges significantly faster. One possible implementation is as follows:</p>
<pre>def Euler_accelerate(sequence):
    """
    Accelerate the iterator in the variable `sequence`.
    """
    s0 = sequence.__next__() # Si
    s1 = sequence.__next__() # Si+1
    s2 = sequence.__next__() # Si+2
    while True:
        yield s0 - ((s1 - s0)**2)/(s2 - 2*s1 + s0)
<em>      </em>  s0, s1, s2 = s1, s2, sequence.__next__()</pre>
<p>As an example, we use the series <em><img class="fm-editor-equation" src="assets/1b9d4037-f4c4-4c8c-a638-aa4362709ad7.png" style="width:8.25em;height:3.42em;"/>, </em>which converges to <img class="fm-editor-equation" src="assets/131e9ae0-b279-4681-8a12-69d0eb6ca6e1.png" style="width:1.25em;height:1.00em;"/>.</p>
<p>We<span> </span>implement this series as a generator in the following code:</p>
<pre>def pi_series():
    sum = 0.
    j = 1
    for i in itertools.cycle([1, -1]):
        yield sum
        sum += i/j
        j += 2</pre>
<p>We may now use the accelerated version of that sequence using this:</p>
<pre>Euler_accelerate(pi_series())</pre>
<p>Accordingly, the first<span> </span><em>N</em><span> </span>elements of that accelerated sequence are obtained with:</p>
<pre>list(itertools.islice(Euler_accelerate(pi_series()), N))</pre>
<p class="mce-root">Note, here we stacked three generators: <kbd>pi_series</kbd>, <kbd>Euler_accelerate</kbd>, and <kbd>itertools.islice</kbd>.</p>
<p><em>Figure 9.1</em> shows the convergence rate of the log of the error for the standard version of the sequence defined by the preceding formula and its accelerated version:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f3d3fdf4-b5ce-4e86-9657-ae04d17361f2.png" style="width:30.00em;height:23.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.1: Comparison between the sequence and its accelerated version</div>
<h1 id="uuid-e52cdb91-e195-4172-acb4-c7ce8d7d28d0">9.4 List-filling patterns</h1>
<p>In this section, we will compare different ways to fill lists. They are different in computational efficiency and also in code readability.</p>
<h2 id="uuid-db7e45d4-ab9c-4641-ac18-95de0feaf285">9.4.1 List filling with the append method</h2>
<p>A ubiquitous programming pattern is to compute elements and store them in a list:</p>
<pre>L = []
for k in range(n):
    # call various functions here
    # that compute "result"
    L.append(result)</pre>
<p>This approach has a number of disadvantages:</p>
<ul>
<li>The number of iterations is decided in advance. If there is a<span> </span><kbd>break</kbd><span> </span>instruction, then the preceding code takes care of both generating values and deciding when to stop. This is not desirable and lacks flexibility.</li>
<li>It makes the assumption that the user wants the whole history of the computation, for all the iterations. Suppose we are only interested in the sum of all the computed values. If there are many computed values, it does not make sense to store them, as it is much more efficient to add them one at a time.</li>
</ul>
<h2 id="uuid-647cab9e-0f9c-4500-93b9-f8bf5ccbe6cf">9.4.2 List from iterators</h2>
<p>Iterators provide us with an elegant solution to problems discussed previously:</p>
<pre>def result_iterator():
    for k in itertools.count(): # infinite iterator
        # call various functions here
        # that t lists compute "result"
        ...
        yield result</pre>
<p>With iterators, we separate the task of generating the computed values without bothering about the stopping condition or about the storage.</p>
<ul>
<li>If the user of that code wants to store the<span> </span><sub><img class="fm-editor-equation" src="assets/c8b7f35d-215d-4049-8d4d-564c7bfa755a.png" style="width:1.08em;height:1.08em;"/></sub> first values, it is easily done using the<span> </span><kbd>list</kbd><span> </span>constructor:</li>
</ul>
<pre style="padding-left: 60px">L = list(itertools.islice(result_iterator(), n)) # no append needed!</pre>
<ul>
<li>If the user wants the sum of the first <em>n</em> generated values, this construction is recommended:</li>
</ul>
<pre style="padding-left: 60px"># make sure that you do not use numpy.sum here
s = sum(itertools.islice(result_iterator(), n))</pre>
<ul>
<li>If the user wants to generate all elements until a certain condition is fulfilled, the function <kbd>itertools.takewhile</kbd> comes in handy:</li>
</ul>
<pre style="padding-left: 60px">L=list(itertools.takewhile(lambda x: abs(x) &gt; 1.e-8, result_iterator()))</pre>
<p style="padding-left: 60px">The function <kbd>takewhile</kbd> takes as a first argument a function that returns a Boolean. Its second argument is a generator. The generator is iterated as long as the function evaluates to <kbd>True</kbd>.</p>
<p style="padding-left: 60px">What we did here was separate the generation of elements on one hand, and store those elements on the other.</p>
<ul>
<li>If the purpose is really to build a list, and when the result at each step does not depend on previously computed elements, you may use the list comprehension syntax (see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml"/><a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.6</a>: <em>List Comprehension</em>):</li>
</ul>
<pre style="padding-left: 60px">L = [some_function(k) for k in range(n)]</pre>
<p>When iteratively computing values that depend on the previously computed values, list comprehensions cannot help.</p>
<h2 id="uuid-d5260b35-74b9-4a0a-b6b6-02add6f0b9b7">9.4.3 Storing generated values</h2>
<p>Using iterators to fill out lists will work nicely most of the time, but there are complications to this pattern when the algorithm computing the new values is liable to throw an exception; if the iterator raises an exception along the way, the list will not be available! The following example illustrates this problem.</p>
<p>Suppose we generate the sequence defined recursively by <sub><img class="fm-editor-equation" src="assets/dc077bef-8013-4d4a-ba02-89f971e6ea90.png" style="width:5.08em;height:1.42em;"/></sub>. This sequence quickly diverges to infinity if the initial data <sub><span><img class="fm-editor-equation" src="assets/f660ed0a-4dcc-4c12-beb2-af8ae2327ab3.png" style="width:1.58em;height:1.17em;"/></span></sub><span> </span>is greater than one. Let's generate it with a generator:</p>
<pre>import itertools
def power_sequence(u0):
    u = u0
    while True:
        yield u
        u = u**2</pre>
<p>If you try to obtain the first<span> </span><em>20</em><span> </span>elements of the sequence (initialized by <sub><span><img class="fm-editor-equation" src="assets/83467fe6-ed62-4c7a-82f5-b2866a8021c2.png" style="width:3.42em;height:1.25em;"/></span></sub>) by executing:</p>
<pre>list(itertools.islice(power_sequence(2.), 20))</pre>
<p>An <kbd>OverflowError</kbd> exception will be raised and no list will be available, not even the list of elements before the exception was raised. There is currently no way to obtain a partially filled list from a possibly faulty generator. The only way around this is to use the method <kbd>append</kbd> wrapped in an exception-catching block (see <a href="9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml">Section 12.1</a>: <em>What are exceptions?</em>, for more details):</p>
<pre>generator = power_sequence(2.)
L = []
for iteration in range(20):
    try:
        L.append(next(generator))
    except Exception:
        break</pre>
<h1 id="uuid-c61eed11-7be0-4c99-a10d-d818c6581567">9.5 When iterators behave as lists</h1>
<p>Some list operations also work on iterators. We will now examine the equivalents of <em>list comprehensions</em><span> </span>and<span> </span><em>list zipping</em><span> </span>(see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.6</a>: <em>List Comprehension</em>, and <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.5</a>: <em>Merging Lists</em>).</p>
<h2 id="uuid-afae940a-71bd-4e15-b790-9e7aca168c4c">9.5.1 Generator expressions</h2>
<p>There is an equivalent of list comprehension for generators. Such a construction is called a generator expression:</p>
<pre>g = (n for n in range(1000) if not n % 100)
# generator for  100, 200, ... , 900</pre>
<p>This is useful in particular for computing sums or products because those operations are incremental; they only need one element at a time:</p>
<pre>sum(n for n in range(1000) if not n % 100) <br/># returns 4500 (sum is here the built-in function)</pre>
<p>In that code, you notice that the<span> </span><kbd>sum</kbd><span> </span>function is given one argument, which is a generator expression. Note that Python syntax allows us to omit the enclosing parentheses of generators when a generator is used as the<span> </span><em>only</em><span> </span>argument of a function.</p>
<p>Let's compute the Riemann zeta function <sub><span><img class="fm-editor-equation" src="assets/e733c4da-13fa-4f7d-9d9f-a04d2b99d8b6.png" style="width:0.58em;height:1.33em;"/></span></sub>, whose expression is</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/bbfb420f-4add-41a5-b7d7-2aaac00e3234.png" style="width:5.92em;height:2.50em;"/></p>
<p>With a generator expression, we may compute a partial sum of this series in one line:</p>
<pre>sum(1/n**s for n in itertools.islice(itertools.count(1), N))</pre>
<p>Note that we could also have defined a generator of the sequence <sub><img class="fm-editor-equation" src="assets/49cf6b79-a417-44e4-8edf-604afaef358d.png" style="width:2.50em;height:1.33em;"/></sub><span> </span>as follows:</p>
<pre>def generate_zeta(s):
    for n in itertools.count(1):
        yield 1/n**s</pre>
<p>Then we simply obtain the sum of the first<span> </span><em>N</em><span> </span>terms using:</p>
<pre>def zeta(N, s):
    # make sure that you do not use the scipy.sum here
    return sum(itertools.islice(generate_zeta(s), N))</pre>
<p>We point out that we used this way of computing the zeta (<img class="fm-editor-equation" src="assets/4e60ab18-0e48-49d9-9e83-1d599478085e.png" style="width:0.75em;height:1.67em;"/>) function as a demonstration of the use of generators in an elegant way. It is certainly not the most accurate and computationally efficient way to evaluate this function.</p>
<h2 id="uuid-cefdf99b-c236-4a88-924d-6dee8dbda3b5">9.5.2 Zipping iterators</h2>
<p>We saw in <span><a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.5</a>: </span><em>Merging Lists</em> that it is possible to create a list out of two or more lists by zipping them together. The same operation exists for iterators:</p>
<pre>xg = x_iterator()  # some iterator
yg = y_iterator()  # another iterator

for x, y in zip(xg, yg):
    print(x, y)</pre>
<p>The zipped iterator stops as soon as one of the iterators is exhausted. This is the same behavior as the operation zip on lists.</p>
<h1 id="uuid-f1a93cf7-b694-4720-ba4b-f12a445b2986">9.6 Iterator objects</h1>
<p>As we mentioned earlier, a<span> </span><kbd>for</kbd><span> </span>loop only needs an iterable object. Lists, in particular, are iterable objects. This means that a list is able to create an iterator from its contents. In fact, this is true for any object (not only lists): any object may be made iterable.</p>
<p>This is achieved via the <span>method</span><span> </span><kbd>__iter__</kbd>, which should return an iterator. Here we give an example where the <span>method</span><span> </span><kbd>__iter__</kbd><span> </span>is a generator:</p>
<pre>class OdeStore:
    """
    Class to store results of ode computations
    """
    def __init__(self, data):
        "data is a list of the form [[t0, u0], [t1, u1],...]"
        self.data = data
    
    def __iter__(self):
        "By default, we iterate on the values u0, u1,..."
        for t, u in self.data:
            yield u

store = OdeStore([[0, 1], [0.1, 1.1], [0.2, 1.3]])
for u in store:
    print(u)
# result: 1, 1.1, 1.3
list(store) # [1, 1.1, 1.3]</pre>
<p>If you try to use the features of an iterator with an object that is not iterable, an exception will be raised:</p>
<pre>&gt;&gt;&gt; list(3)
TypeError: 'int' object is not iterable</pre>
<p>In this example, the <span>function</span> list tries to iterate through object<span> </span><em>3</em><span> </span>by calling the <span>method</span><span> </span><kbd>__iter__</kbd>. But this method is not implemented for integers and thus the exception is raised. The same would happen if we tried to cycle through a non-iterable object:</p>
<pre>&gt;&gt;&gt; for iteration in 3: pass
TypeError: 'int' object is not iterable</pre>
<h1 id="uuid-969bfabd-6550-41d3-b9c1-8bba0a5a1371">9.7 Infinite iterations</h1>
<p>Infinite iterations are obtained either with an infinite iterator, with a<span> </span><kbd>while</kbd><span> </span>loop, or by recursion. Obviously, in practical cases, some condition stops the iteration. The difference with finite iterations is that it is impossible to say from a cursory examination of the code whether the iteration will stop or not.</p>
<h2 id="uuid-d0e35684-ea19-4ff6-9241-fd7b175e41d8">9.7.1 The while loop</h2>
<p>The<span> </span><kbd>while</kbd><span> </span>loop may be used to repeat a code block until a condition is fulfilled:</p>
<pre>while condition:
    &lt;code&gt;</pre>
<p>A<span> </span><kbd>while</kbd><span> </span>loop is equivalent to the following code:</p>
<pre>for iteration in itertools.count():
    if not condition:
        break
    &lt;code&gt;</pre>
<p>So a<span> </span><kbd>while</kbd><span> </span>loop used to repeat a code block until a condition is fulfilled is equivalent to an infinite iterator, which might be stopped if a condition is fulfilled. The danger of such a construction is obvious: the code may be trapped in an infinite loop if the condition is never fulfilled.</p>
<p>The problem in scientific computing is that you are not always sure that an algorithm will converge. Newton iteration, for instance, might not converge at all. If that algorithm were implemented inside a<span> </span><kbd>while</kbd><span> </span>loop, the corresponding code would be trapped in an infinite loop for some choices of initial conditions.</p>
<p>We, therefore, advise that finite iterators are often better suited for such a task. The following construction replaces, often advantageously, the use of a<span> </span><kbd>while</kbd><span> </span>loop:</p>
<pre>maxit = 100
for nb_iterations in range(maxit):
    ...
else:
    raise Exception(f"No convergence in {maxit} iterations")</pre>
<p>The first advantage is that the code is guaranteed to execute in a finite time no matter what happens. The second advantage is that the variable<span> </span><kbd>nb_iterations</kbd><span> </span>contains the number of iterations that were necessary for the algorithm to converge.</p>
<h2 id="uuid-fecd482a-077b-4682-aa9d-abe3b580b80e">9.7.2 Recursion</h2>
<p>Recursion occurs when a function calls itself (see <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.4</a>: <em>Recursive functions</em>).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When doing recursions, it is the recursion depth, which is the number of iterations, that brings your computer to its limits. We demonstrate this here by considering a simple recursion, which actually contains no computations at all. It assigns to the iterates only the value zero:</p>
<pre>def f(N):
    if N == 0: 
        return 0
    return f(N-1)</pre>
<p>Depending on your system, this program may choke for <sub><img class="fm-editor-equation" src="assets/aa5d7601-eb3e-462c-998a-82481eb1cb19.png" style="width:4.92em;height:1.00em;"/></sub><span> </span>(too much memory is used). The result is that the Python interpreter crashes without further exception. Python provides a mechanism to raise an exception when a too high recursion depth is detected. This maximum recursion depth may be changed by executing:</p>
<pre>import sys 
sys.setrecursionlimit(1000)</pre>
<p>Be aware though, that choosing too high a number may imperil the stability of your code since Python might crash before that maximum depth is reached. It is therefore often wise to leave the recursion limit as it is. <span>The actual value of the recursion limit can be obtained with </span><kbd>sys.getrecursionlimit()</kbd><span>.</span></p>
<p>By comparison, the following, non-recursive, program runs ten of millions of iterations without any problem:</p>
<pre>for iteration in range(10000000):
    pass</pre>
<p>We advocate that, if possible, recursion should be avoided in Python. This applies obviously only if there is an appropriate alternative iterative algorithm available. The first reason is that a recursion of depth <em><strong>N</strong></em><span> </span>involves <em><strong>N</strong></em><span> </span>function calls at the same time, which might result in significant overhead. The second reason is that it is an infinite iteration, that is, it is difficult to give an upper bound to the number of steps necessary before the recursion is over.</p>
<p>Note that in some very special cases (tree traversal) recursion is unavoidable. Besides, in some cases (with small recursion depths), recursive programs might be preferred due to readability.</p>
<h1 id="uuid-6c83da16-fe72-4056-ad92-d30b1fc72096">9.8 Summary</h1>
<p>In this chapter, we studied iterators, a programming construct very near to a mathematical description of iterative methods. You saw the <span>keyword</span><span> </span><kbd>yield</kbd> and met finite and infinite iterators.</p>
<p>We showed that an iterator can be exhausted. More special aspects such as iterator comprehension and recursive iterators were introduced and demonstrated with the help of examples. </p>
<h1 id="uuid-5383a7c4-1e06-4cb1-92ff-41d2db985571">9.9 Exercises</h1>
<p><strong>Ex. 1:</strong> Compute the value of the sum:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0b05ec3f-b024-4e2b-a7eb-f19551a2a39f.png" style="width:4.17em;height:4.00em;"/></p>
<p><strong>Ex. 2:</strong> Create a generator that computes the sequence defined by the relation:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/22f0a02e-8752-4d58-834b-0b735ce239ee.png" style="width:6.50em;height:1.42em;"/></div>
<p><strong>Ex. 3:</strong> Generate all the even numbers.</p>
<p><strong>Ex. 4:</strong> Let<span> <sub><img class="fm-editor-equation" src="assets/537c8f39-479d-4a88-aa87-8baf6d233dc6.png" style="width:8.17em;height:2.58em;"/></sub></span>. In calculus, it is shown that <sub><img class="fm-editor-equation" src="assets/88618432-dea1-4b8a-90ee-8d86ec945649.png" style="width:7.08em;height:2.33em;"/></sub><span> </span>. Determine experimentally the smallest number <span><img class="fm-editor-equation" src="assets/c07910ea-e646-4704-b8cf-570ab0119311.png" style="width:0.92em;height:0.92em;"/></span><span> </span>such that <span><sub><img class="fm-editor-equation" src="assets/6c5d2fa8-5a02-4ec7-804a-5eaacc778498.png" style="width:8.92em;height:1.58em;"/></sub></span>. Use a generator for this task.</p>
<p><strong>Ex. 5:</strong> Generate all prime numbers less than a given integer. Use the<span> </span>algorithm<span> </span>called <em>Sieve of Eratosthenes</em>.</p>
<p><strong>Ex. 6:</strong> Solving the differential equation <sub><img class="fm-editor-equation" src="assets/58410877-2e15-408b-837f-556aafbd0813.png" style="width:6.17em;height:1.25em;"/></sub><span> </span>by applying the explicit Euler method results in the recursion:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/18d7bbb3-ac62-4a96-b4e0-f7f158ae0e14.png" style="width:11.75em;height:1.42em;"/> </div>
<p>Write a generator that computes the solution values <span><img class="fm-editor-equation" src="assets/ba1d483f-8eeb-4757-b16a-41b8eebb06f3.png" style="width:1.67em;height:1.17em;"/></span><span> </span>for a given initial value <span><img class="fm-editor-equation" src="assets/2c063d73-e6ca-4631-b913-13da8ed5304f.png" style="width:1.58em;height:1.17em;"/></span><span> </span>and for a given value of the time step <span><img class="fm-editor-equation" src="assets/0968c1ee-c6bc-4419-971d-41367ac5c23e.png" style="width:0.75em;height:1.08em;"/></span>.</p>
<p><strong>Ex. 7:</strong> Compute π using the formula:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1a41172d-85e9-497c-874c-b4136baa9345.png" style="width:9.75em;height:3.25em;"/></div>
<p>The integral can be approximated using the composite trapezoidal rule, that is, with this formula:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/716db66e-5e6b-4b0b-b857-3c23f53d434d.png" style="width:22.17em;height:3.67em;"/></div>
<p>where <span><img class="fm-editor-equation" src="assets/016f2ebf-9dc1-4d3a-aea3-a79cf4d62594.png" style="width:11.67em;height:2.42em;"/></span>.</p>
<p>Program a<span> </span><em>generator</em><span> </span>for the values <span><sub><img class="fm-editor-equation" src="assets/5b6bfda4-c20d-4d09-9ae9-de27d85f262a.png" style="width:5.50em;height:1.42em;"/></sub></span>and evaluate the formula by summing one term after the other. Compare your results with the<span> </span><kbd>quad</kbd><span> </span>function of SciPy.</p>
<p><strong>Ex. 8:</strong> Let <kbd>x<span> </span>= [1, 2, 3]</kbd> and<span> </span><kbd>y<span> </span>= [-1, -2, -3]</kbd>. What is the effect of the code<span> </span><kbd>zip(*zip(x, y))</kbd>? Explain how it works.</p>
<p><strong>Ex. 9:</strong> Complete elliptic integrals can be computed by the function<span> </span><kbd>scipy.special.ellipk</kbd>. Write a function that counts the number of iterations needed with the AGM iteration until the result coincides up to a given tolerance (note that the input parameter<span> </span><em>m</em><span> </span>in<span> </span><kbd>ellipk</kbd><span> </span>corresponds to <span><img class="fm-editor-equation" src="assets/133737ff-4444-4eea-be8a-fd8203c3c069.png" style="width:1.08em;height:1.17em;"/></span><em><sup> </sup></em>in the definition in <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.3.5</a>: <em><span>Examples for iterators in mathematics</span></em><em>)</em>.</p>
<p><strong>Ex. 10:</strong> Consider the sequence <img class="fm-editor-equation" src="assets/75a5ddd1-5690-43e0-b573-1cefd1970ee0.png" style="width:4.25em;height:1.42em;"/> defined by:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/71ce32bd-58ef-4de2-a1fa-2f20fa5758f0.png" style="width:10.25em;height:3.08em;"/></div>
<p>It converges monotonically to zero: <span><img class="fm-editor-equation" src="assets/afb2bccf-36b3-4806-9e84-8584f4e91519.png" style="width:8.75em;height:1.00em;"/></span>. By integration by parts, we can show that the sequence <span><img class="fm-editor-equation" src="assets/2c8e757e-4b77-48b0-bab8-042394496e33.png" style="width:1.92em;height:1.58em;"/></span><span> </span>fulfills the following recursion:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f0047906-eee8-4a58-84ad-dd88feabca58.png" style="width:26.42em;height:3.00em;"/></div>
<p class="mce-root"/>
<p>Compute the first 20 terms of the recursion by using an appropriate generator and compare the results with those obtained by numerical integration with<span> </span><kbd>scipy.integrate.quad</kbd>. Do the same by reversing the recursion:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cd183bb8-3c5a-40c3-9e70-21cf9c912900.png" style="width:17.08em;height:2.25em;"/> </div>
<p>Use the function<span> </span><kbd>exp</kbd> to evaluate the exponential function. What do you observe? Do you have an explanation? See also <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[29]</a>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/885ef052-42d3-4c73-8d41-d022a0029e9c.png" style="width:28.25em;height:21.92em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.2: A convergence study of functions approximating <sub><img class="fm-editor-equation" src="assets/4ecef828-561f-47fa-a43d-b48302a5c823.png" style="width:2.33em;height:1.00em;"/></sub></div>
<p><strong>Ex. 11:</strong> The sine-function can be expressed due to Euler as:</p>
<p style="padding-left: 120px" class="CDPAlignLeft CDPAlign"><img src="assets/0d5b517e-f89b-47f2-9ba0-429b35442493.png" style="width:29.33em;height:4.33em;"/></p>
<p>Write a generator that generates the function values <em><strong>P<sub>k</sub>(x)</strong></em>. Set<span> </span><kbd>x=linspace(-1,3.5*pi,200)</kbd><span> </span>and demonstrate graphically how well <em><strong>P<sub>k</sub>(x)</strong></em> approximates <strong>sin</strong> for increasing<span> </span><em>k</em>. In <em>Figure 9.2</em>, the possible result is shown. Consult also Theorem 5.2, p. 65 in <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[11]</a>.</p>


            </article>

            
        </section>
    </body></html>