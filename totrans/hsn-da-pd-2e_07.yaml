- en: '*Chapter 5*: Visualizing Data with Pandas and Matplotlib'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with data strictly in a tabular format. However,
    the human brain excels at picking out visual patterns; hence, our natural next
    step is learning how to visualize our data. Visualizations make it much easier
    to spot aberrations in our data and explain our findings to others. However, we
    should not reserve data visualizations exclusively for those we present our conclusions
    to, as visualizations will be crucial in helping us understand our data quickly
    and more completely in our exploratory data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous types of visualizations that go way beyond what we may have
    seen in the past. In this chapter, we will cover the most common plot types, such
    as line plots, histograms, scatter plots, and bar plots, along with several other
    plot types that build upon these. We won't be covering pie charts—they are notorious
    for being difficult to read properly, and there are better ways to get our point
    across.
  prefs: []
  type: TYPE_NORMAL
- en: Python has many libraries for creating visualizations, but the main one for
    data analysis (and other purposes) is `matplotlib`. The `matplotlib` library can
    be a little tricky to learn at first, but thankfully, `pandas` has its own wrappers
    around some of the `matplotlib` functionality, allowing us to create many different
    types of visualizations without needing to write a single line with `matplotlib`
    (or, at least, very few). For more complicated plot types that aren't built into
    `pandas` or `matplotlib`, we have the `seaborn` library, which we will discuss
    in the next chapter. With these three at our disposal, we should be able to create
    most (if not all) of the visualizations we desire. Animations and interactive
    plots are beyond the scope of this book, but you can check out the *Further reading*
    section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting with pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pandas.plotting module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The materials for this chapter can be found on GitHub at [https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_05](https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_05).
    We will be working with three datasets, all of which can be found in the `data/`
    directory. In the `fb_stock_prices_2018.csv` file, we have the daily opening,
    high, low, and closing prices of Facebook stock from January through December
    2018, along with the volume traded. This was obtained using the `stock_analysis`
    package, which we will build in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*. The stock market is closed
    on the weekends, so we only have data for the trading days.
  prefs: []
  type: TYPE_NORMAL
- en: The `earthquakes.csv` file contains earthquake data collected from the `mag`
    column), the scale it was measured on (the `magType` column), when (the `time`
    column) and where (the `place` column) it occurred, and the `parsed_place` column
    for the state or country where the earthquake occurred (we added this column back
    in [*Chapter 2*](B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035), *Working with
    Pandas DataFrames*). Other unnecessary columns have been removed.
  prefs: []
  type: TYPE_NORMAL
- en: In the `covid19_cases.csv` file, we have an export from the *daily number of
    new reported cases of COVID-19 by country worldwide* dataset provided by the **European
    Centre for Disease Prevention and Control** (**ECDC**), which can be found at
    [https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide).
    For scripted or automated collection of this data, the ECDC makes the current
    day's CSV file available via [https://opendata.ecdc.europa.eu/covid19/casedistribution/csv](https://opendata.ecdc.europa.eu/covid19/casedistribution/csv).
    The snapshot we will be using was collected on September 19, 2020 and contains
    the number of new COVID-19 cases per country from December 31, 2019 through September
    18, 2020, with partial data for September 19, 2020\. For this chapter, we will
    look at the 8-month span from January 18, 2020 through September 18, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be working through three notebooks. These are
    numbered in the order they will be used—one for each of the main sections of this
    chapter. We will begin our discussion of plotting in Python with an introduction
    to `matplotlib` in the `1-introducing_matplotlib.ipynb` notebook. Then, we will
    learn how to create visualizations using `pandas` in the `2-plotting_with_pandas.ipynb`
    notebook. Finally, we will explore some additional plotting options that `pandas`
    provides in the `3-pandas_plotting_module.ipynb` notebook. You will be prompted
    when it is time to switch between the notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plotting capabilities in `pandas` and `seaborn` are powered by `matplotlib`:
    both of these packages provide wrappers around the lower-level functionality in
    `matplotlib`. Consequently, we have many visualization options at our fingertips
    with minimal code to write; however, this comes at a price: reduced flexibility
    in what we can create.'
  prefs: []
  type: TYPE_NORMAL
- en: We may find that the `pandas` or `seaborn` implementation isn't quite meeting
    our needs, and, indeed, it may be impossible to override a particular setting
    after creating the plot with them, meaning we will have to do some of the legwork
    with `matplotlib`. Additionally, many of the tweaks that will be made to the final
    appearance of the visualization will be handled with `matplotlib` commands, which
    we will discuss in the next chapter. Therefore, it would greatly benefit us to
    have some understanding of how `matplotlib` works.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `matplotlib` package is rather large since it encompasses quite a bit of
    functionality. Fortunately for us, for most of our plotting tasks, all we need
    is the `pyplot` module, which provides a MATLAB-like plotting framework. Occasionally,
    we will need to import additional modules for other tasks, such as animations,
    changing the style, or altering the default parameters; we will see some examples
    of this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than importing the whole `matplotlib` package, we will only import the
    `pyplot` module using the dot (`.`) notation; this reduces the amount of typing
    we need to do in order to access what we need, and we don''t take up more space
    in memory with code we won''t use. Note that `pyplot` is traditionally aliased
    as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before we look at our first plots, let's cover how to actually view them. Matplotlib
    will create our visualizations with the plot commands; however, we won't see the
    visualization until we request to see it. It is done in this fashion so that we
    can continually tweak the visualization with additional code, until we are ready
    to finalize it. Unless we save a reference to our plot, once it is displayed,
    we will have to recreate it to change something. This is because the reference
    to the last plot will have been destroyed to free up resources in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib uses the `plt.show()` function to display the visualization. It must
    be called after each visualization we create. When using the Python shell, it
    will also prevent additional code from being executed until the window is closed
    because it is a blocking function. In Jupyter Notebooks, we can simply use the
    `%matplotlib inline` `%` sign) once, and our visualizations will be automatically
    displayed when the cell with our visualization code is executed. Magic commands
    (or *magics* for short) are run as regular code within a Jupyter Notebook cell.
    If, up to this point in the book, you haven't been keen on using Jupyter Notebooks
    and would like to get that set up now, you can refer to [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Introduction to Data Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `%matplotlib inline` magic embeds static images of the plot into our notebook.
    Another common option is the `%matplotlib notebook` magic. It provides a small
    level of interactivity to the plot by allowing actions such as resizing and zooming,
    though note that this requires some additional setup if you''re using JupyterLab
    and can lead to some confusing bugs, depending on the code that''s running in
    the notebook. Check out this article for more information: [https://medium.com/@1522933668924/using-matplotlib-in-jupyter-notebooks-comparing-methods-and-some-tips-python-c38e85b40ba1](mailto:https://medium.com/@1522933668924/using-matplotlib-in-jupyter-notebooks-comparing-methods-and-some-tips-python-c38e85b40ba1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first plot in the `1-introducing_matplotlib.ipynb` notebook,
    using the Facebook stock prices data from the `fb_stock_prices_2018.csv` file
    in the repository for this chapter. First, we need to import `pyplot` and `pandas`
    (in this example, we will use `plt.show()`, so we don''t need to run the magic
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we read in the CSV file and specify the index as the `date` column, since
    we know what the data looks like from previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how Facebook''s stock has evolved over time, we can create a
    line plot of the daily opening price. For this task, we will use the `plt.plot()`
    function, providing the data to be used on the *x*-axis and *y*-axis, respectively.
    We will then follow up with a call to `plt.show()` to display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Our first plot with matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Our first plot with matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: If we want to present this visualization, we would have to go back and add our
    axis labels, plot title, legend (if applicable), and possibly fix the *y*-axis
    range; this will be covered in the next chapter when we discuss formatting and
    customizing the appearance of our plots. Pandas and `seaborn` will take care of
    some of this for us, at least.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the remainder of this book, we will be using the `%matplotlib inline` magic
    command (remember, this needs to be used in a Jupyter Notebook to work), so we
    won''t be calling `plt.show()` after our plotting code. The following code gives
    the same output as the preceding block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to run the `%matplotlib inline` magic command now if you are using a
    Jupyter Notebook. This ensures that the plotting code in the rest of this chapter
    displays the output automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `plt.plot()` function to generate scatter plots, provided
    that we specify a format string for the plot as the third argument. A format string
    is of the form `''[marker][linestyle][color]''`; for example, `''--k''` for a
    black dashed line. Since we don''t want a line for the scatter plot, we omit the
    `linestyle` component. We can make a scatter plot of red circles with the `''or''`
    format string; here, `o` is for circles and `r` is for the color red. The following
    code generates a scatter plot of high price versus low price. Notice that we can
    pass our dataframe in the `data` argument and then use the string names for the
    columns, instead of passing the series as `x` and `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Barring days of large fluctuations, we would expect the points to be in the
    form of a line, since the high and low prices won''t be far from each other. This
    is true for the most part, but be careful of the scale that was generated automatically—the
    *x*-axis and the *y*-axis don''t line up perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Making a scatter plot with matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Making a scatter plot with matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is some flexibility in specifying the format string. For instance,
    a format string of the form `''[color][marker][linestyle]''` will work unless
    it is ambiguous. The following table shows some examples of how to formulate a
    format string for a variety of plot styles; the complete list of options can be
    found in the **Notes** section in the documentation at [https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Styling shortcuts for matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Styling shortcuts for matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: The format string is a handy way of specifying many options at once, and the
    good news, as we will see in the *Plotting with pandas* section, is that it works
    with the `plot()` method in `pandas` as well. However, if we would rather specify
    each option separately, we can use the `color`, `linestyle`, and `marker` arguments;
    check out the values we can pass as keyword arguments to `plt.plot()` in the documentation—`pandas`
    will also pass these down to `matplotlib` for us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to defining styles per variable being plotted, consider trying
    out `cycler` from the `matplotlib` team to specify which combinations `matplotlib`
    should cycle between ([https://matplotlib.org/gallery/color/color_cycler.html](https://matplotlib.org/gallery/color/color_cycler.html)).
    We will see an example of this in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create histograms with `matplotlib`, we use the `hist()` function instead.
    Let''s make a histogram of the earthquake magnitudes in the `earthquakes.csv`
    file, using those measured with the `ml` magnitude type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting histogram gives us an idea of the range of earthquake magnitudes
    we can expect using the `ml` measurement technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Making a histogram with matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Making a histogram with matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'As we could have guessed, the magnitudes tend to be small, and the distribution
    appears to be somewhat normal. However, a word of caution regarding histograms—bin
    size matters. There are cases where we can change the number of bins the data
    is divided into and change what the histogram indicates the distribution to be.
    For example, if we make two histograms for this data using different numbers of
    bins, the distributions look different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the distribution appears unimodal in the left subplot, but seems
    bimodal in the right subplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Different bin sizes can drastically change a histogram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Different bin sizes can drastically change a histogram
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Some common rules of thumb for selecting the number of bins can be found at
    [https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width](https://en.wikipedia.org/wiki/Histogram#Number_of_bins_and_width).
    However, note that, in some cases, a bee swarm plot can be easier to interpret
    than a histogram; this can be created with `seaborn`, as we will see in [*Chapter
    6*](B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125), *Plotting with Seaborn and
    Customization Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of additional things to note from this example, which we
    will address in the next section on plot components:'
  prefs: []
  type: TYPE_NORMAL
- en: We can make subplots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting functions in `pyplot` can also be used as methods of `matplotlib` objects,
    such as `Figure` and `Axes` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One last thing regarding basic usage that we will find handy is saving plots
    as images—we shouldn't be limited to showing the figures in Python only. We can
    save the last figure with the `plt.savefig()` function by passing in the path
    to save the image at; for example, `plt.savefig('my_plot.png')`. Note that, if
    `plt.show()` was called prior to saving, the file will be empty, since the reference
    to the last plot will be gone after the call to `plt.show()` (`matplotlib` closes
    the `Figure` object to free up resources in memory). With the `%matplotlib inline`
    magic command, we can both see and save our image in the same cell.
  prefs: []
  type: TYPE_NORMAL
- en: Plot components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the prior examples using `plt.plot()`, we didn't have to create a `Figure`
    object—`matplotlib` took care of creating it for us in the background. However,
    as we saw when creating *Figure 5.5*, anything beyond a basic plot will require
    a little more legwork, including creating a `Figure` object ourselves. The `Figure`
    class is the top level for `matplotlib` visualizations. It contains the `Axes`
    objects, which themselves contain additional plot objects, such as lines and ticks.
    In the case of subplots, the `Figure` object contains `Axes` objects with additional
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `plt.figure()` function to create `Figure` objects; these will have
    zero `Axes` objects until a plot is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plt.subplots()` function creates a `Figure` object with `Axes` objects
    for subplots in the arrangement specified. If we ask `plt.subplots()` for one
    row and one column, a `Figure` object with one `Axes` object will be returned.
    This can be useful when writing functions that generate subplot layouts based
    on the input, since we don''t need to worry about needing a special case to handle
    a single subplot. Here, we will specify an arrangement of one row and two columns;
    this returns a `(Figure, Axes)` tuple, which we can unpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the `%matplotlib inline` magic command, we will see the figure that
    was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Creating subplots'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Creating subplots
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to using `plt.subplots()` would be to use the `add_axes()`
    method on the `Figure` object that we get after running `plt.figure()`. The `add_axes()`
    method takes a list in the form of `[left, bottom, width, height]` as proportions
    of the figure dimensions, representing the area in the figure this subplot should
    occupy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables the creation of plots inside of plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Plot with an inset plot using matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Plot with an inset plot using matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'If our goal is to keep all the plots separate but not all equally sized, we
    can use the `add_gridspec()` method on a `Figure` object to create a grid for
    the subplots. Then, we can run `add_subplot()`, passing in the area(s) from the
    grid that the given subplot should occupy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Building custom plot layouts with matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Building custom plot layouts with matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed how to save visualizations using `plt.savefig()`
    but we also can use the `savefig()` method on `Figure` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very useful to remember since with `plt.<func>()`, we only have access
    to the last `Figure` object; however, if we save the references to our `Figure`
    objects, we can work with any of them, regardless of when they were created. Additionally,
    this foreshadows an important concept that you will notice throughout this chapter:
    `Figure` and `Axes` objects have methods with similar or identical names to their
    `pyplot` function counterparts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s convenient to have references to all of the `Figure` objects we
    create, it is good practice to close them when we are done with them so that we
    don''t waste any resources. This can be accomplished with the `plt.close()` function.
    If we don''t pass in anything, it will close the last `Figure` object; however,
    we can pass in a specific `Figure` object to close only that one or `''all''`
    to close all of the `Figure` objects we have open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It's important to get comfortable working with `Figure` and `Axes` objects directly
    as it enables more fine-grained control of the resulting visualizations. This
    will become evident in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Additional options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few of our visualizations looked a little squished. To remedy this, we can
    pass in a value for `figsize` in our call to `plt.figure()` or `plt.subplots()`.
    We specify the dimensions with a `(width, height)` tuple in inches. The `plot()`
    method we will see with `pandas` also accepts the `figsize` parameter, so bear
    this in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that these subplots are more square-shaped than the subplots in *Figure
    5.6* when we didn''t specify `figsize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Specifying plot size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.9_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Specifying plot size
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not too bad specifying the `figsize` parameter for our plots one by one.
    However, if we find that we are resizing everything to the same size, there''s
    a better alternative. Matplotlib houses its defaults in `rcParams`, which acts
    like a dictionary, meaning we can easily overwrite what we wish for our session
    and get the defaults back when we restart our Python session. Since there are
    many options in this dictionary (over 300 at the time of writing), let''s randomly
    select a few of them to get an idea of what is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are many options we can tinker with here. Let''s check
    what the current default value for `figsize` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To change this for our current session, simply set it equal to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on, let''s restore the default settings by using the `mpl.rcdefaults()`
    function. The default value for `figsize` is actually different than what we had
    previously; this is because `%matplotlib inline` sets different values for a few
    of the plot-related parameters when it is first run ([https://github.com/ipython/ipykernel/blob/master/ipykernel/pylab/config.py#L42-L56](https://github.com/ipython/ipykernel/blob/master/ipykernel/pylab/config.py#L42-L56)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can also use the `plt.rc()` function to update a particular setting
    if we know its group (`figure`, in this case) and parameter name (`figsize`).
    As we did previously, we can use `plt.rcdefaults()` to reset the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If we find ourselves making the same changes every time we start Python, we
    should look into reading our configuration in rather than updating the default
    values each time. Consult the `mpl.rc_file()` function for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both `Series` and `DataFrame` objects have a `plot()` method that allows us
    to create several different plots and control some aspects of their formatting,
    such as subplot layout, figure size, titles, and whether to share an axis across
    subplots. This makes plotting our data much more convenient, as the bulk of the
    work to create presentable plots is achieved with a single method call. Under
    the hood, `pandas` is making several calls to `matplotlib` to produce our plot.
    Some of the most frequently used arguments to the `plot()` method include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Frequently used pandas plotting arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Frequently used pandas plotting arguments
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having separate functions for each plot type, as we saw during our
    discussion of `matplotlib`, the `plot()` method from `pandas` allows us to specify
    the type of plot we want using the `kind` argument. The choice of plot will determine
    which other arguments are required. We can use the `Axes` object that's returned
    by the `plot()` method to further modify our plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore this functionality in the `2-plotting_with_pandas.ipynb` notebook.
    Before we begin, we need to handle our imports for this section and read in the
    data we will be using (Facebook stock prices, earthquakes, and COVID-19 cases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the next few sections, we will discuss how to generate an appropriate visualization
    for a specific analysis goal, such as showing the evolution over time or the relationship
    between the variables in the data. Note that, wherever possible, the plots have
    been styled so that they can be interpreted in black and white for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Evolution over time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with time series data (such as the Facebook stock data stored
    in the `fb` variable), we often want to show how the data has changed over time.
    To do this, we use line plots and, in some cases, bar plots (covered in the *Counts
    and frequencies* section). In the case of a line plot, we simply provide `kind=''line''`
    to `plot()`, indicating which columns will be `x` and `y`. Note that we actually
    don''t need to provide a column for `x` because `pandas`, by default, will use
    the index (this also makes it possible to generate the line plot of a `Series`
    object). Additionally, notice that we can provide a format string to the `style`
    argument, just like we did with the `matplotlib` plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a plot similar to what we achieved with `matplotlib`; however,
    in this single method call, we specified the figure size for this plot only, turned
    off the legend, and gave it a title:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Our first plot with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Our first plot with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `matplotlib`, we don''t have to use the style format strings—instead,
    we can pass each component separately with its associated keyword. For example,
    the following code gives us the same result as the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We aren''t limited to plotting one line at a time with the `plot()` method;
    we can also pass in a list of columns to plot and style them individually. Note
    that we actually don''t need to specify `kind=''line''` because that is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following plot, where each line is styled differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Plotting multiple columns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Plotting multiple columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can easily have `pandas` plot all our columns in that same
    call. The `x` and `y` arguments can take a single column name or a list of them;
    if we provide nothing, `pandas` will use all of them. Note that the columns must
    be passed as the `y` argument when `kind=''line''`; however, other plot types
    support passing lists of columns to `x` as well. In this case, it may be helpful
    to ask for subplots instead of having all the lines on the same plot. Let''s visualize
    all the columns in the Facebook data as line plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `layout` argument, we told `pandas` how to arrange our subplots (three
    rows and two columns):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Creating subplots with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Creating subplots with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the subplots automatically share the *x*-axis, since they share
    an index. The *y*-axis is not shared because the `volume` time series is on a
    different scale. We can alter this behavior in some plot types by passing the
    `sharex` or `sharey` argument with a Boolean to `plot()`. The legend will be rendered
    by default, so, for each subplot, we have a single item in the legend indicating
    which data it contains. We didn''t provide a list of subplot titles with the `title`
    argument in this case, since the legend served that purpose; however, we passed
    a single string for the title of the plot as a whole. To summarize, when working
    with subplots, we have two options when it comes to the title:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a single string for the title of the figure as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a list of strings to use as the title for each subplot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, we want to make subplots where each has a few variables in them
    for comparison. This can be achieved by first creating the subplots with `plt.subplots()`
    and then providing the `Axes` objects to the `ax` parameter. To illustrate this,
    let''s take a look at daily new cases of COVID-19 in China, Spain, Italy, the
    USA, Brazil, and India. This is long format data, so we must first pivot it so
    that the dates (which we set as the index when we read in the CSV file) are in
    the index of the pivot table and the countries (`countriesAndTerritories`) are
    in the columns. Since there is a lot of fluctuation in these values, we will plot
    the 7-day moving average of new cases using the `rolling()` method introduced
    in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082), *Aggregating
    Pandas DataFrames*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than create a separate plot for each country (which makes it harder
    to compare) or plot them all together (which will make it difficult to see the
    smaller values), we will plot countries that have had a similar number of cases
    in the same subplot. We will also use different line styles in order to distinguish
    between them in black and white:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By directly using `matplotlib` to generate the `Axes` objects for each subplot,
    we gained a lot more flexibility in the resulting layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Controlling which data gets plotted in each of the subplots'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – Controlling which data gets plotted in each of the subplots
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous plot, we were able to compare countries with similar levels
    of daily new COVID-19 cases, but we couldn''t compare all of them in the same
    subplot due to scale. One way to get around this is to use an **area plot**, which
    makes it possible for us to visualize the overall 7-day rolling average of new
    COVID-19 cases and, at the same time, how much each country is contributing to
    the total. In the interest of readability, we will group Italy and Spain together
    and create another category for countries other than the USA, Brazil, and India:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For those viewing the resulting plot in black and white, Brazil is the bottom
    layer, with India on top of it and so on. The combined height of the plot areas
    is the overall value, and the height of a given shaded region is the value for
    that country. This shows us that more than half of the daily new cases are in
    Brazil, India, Italy, Spain, and the USA combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Creating an area plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Creating an area plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to visualize evolution over time is to look at the cumulative sum
    over time. Let''s plot the cumulative number of COVID-19 cases in China, Spain,
    Italy, the USA, Brazil, and India, using the `ax` parameter to once again to create
    subplots. To calculate the cumulative sum over time, we group by the location
    (`countriesAndTerritories`) and the date, which is our index, so we use `pd.Grouper()`;
    this time, we will use `groupby()` and `unstack()` to pivot our data into wide
    format for the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewing the cumulative COVID-19 cases shows that while China and Italy appear
    to have COVID-19 cases under control, Spain, the USA, Brazil, and India are struggling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Plotting the cumulative sum over time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – Plotting the cumulative sum over time
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We used dotted and dashed lines multiple times in this section to ensure that
    the resulting plots could be interpreted in black and white; note, however, that
    accepting the default colors and line styles will suffice when presenting these
    plots in color. Often, different line styles signify a difference in the data
    types—for example, we could use a solid line for the evolution over time and a
    dashed line to represent the rolling average.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we want to visualize the relationship between variables, we often begin
    with scatter plots, which show us the value of the `y` variable at different values
    of the `x` variable. This makes it very easy for us to spot correlations and possible
    non-linear relationships. In the previous chapter, when we looked at the Facebook
    stock data, we saw that the days of high volume traded appeared to be correlated
    with large drops in stock price. We can use a scatter plot to visualize this relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There appears to be a relationship, but it does not seem linear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Making scatter plots with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – Making scatter plots with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try taking the logarithm (log) of the volume. To do so, we have a couple
    of options:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new column that is the log of the volume using `np.log()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a logarithmic scale for the *x*-axis by passing in `logx=True` to the `plot()`
    method or calling `plt.xscale('log')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, it makes the most sense to simply change how we display our data,
    since we aren''t going to use the new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying the *x*-axis scale, we get the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Applying a logarithmic scale to the x-axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Applying a logarithmic scale to the *x*-axis
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plot()` method from `pandas` has three arguments for logarithmic scales:
    `logx`/`logy` for single axis adjustments and `loglog` for setting both to the
    logarithmic scale.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem with scatter plots is that it can be very difficult to discern
    the concentration of points in a given area, since they are simply plotted one
    of top of the other. We can use the `alpha` argument to control the transparency
    of the points; this argument takes values from `0` to `1`, where `0` is entirely
    transparent and `1` is completely opaque. By default, they are opaque (value of
    `1`); however, if we make them more transparent, we should be able to see some
    of the overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now begin to make out the density of points in the lower-left region
    of the plot, but it''s still relatively difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Modifying transparency to visualize overlap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – Modifying transparency to visualize overlap
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we have another plot type at our disposal: `hexbin`. **Hexbins**
    form a two-dimensional histogram by dividing the plot into a grid of hexagons
    and shading them based on the concentration of points in each bin. Let''s view
    this data as hexbins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The colorbar on the side indicates the relationship between color and the number
    of points in that bin. The colormap we chose (`gray_r`) shades the bins darker
    (toward black) for high density, and lighter (toward white) for low density. By
    passing in `gridsize=20`, we are specifying that 20 hexagons should be used across
    the *x*-axis, and then having `pandas` determine how many to use along the *y*-axis
    so that they are approximately regular in shape; we can, however, pass a tuple
    to choose the number in both directions. A larger value for `gridsize` will make
    the bins harder to see, while a smaller one will result in fuller bins that take
    up more space on the plot—we must strike a balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Plotting hexbins with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Plotting hexbins with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if we simply want to visualize the correlation between variables,
    we can plot a correlation matrix. A `pandas` and either the `plt.matshow()` or
    `plt.imshow()` function from `matplotlib`. Since there is a lot of code that needs
    to be run in the same cell, we will discuss the purpose of each section immediately
    after this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A `seismic` colormap and then setting the limits of the color scale to [-1,
    1], since the correlation coefficient has those bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to read the resulting heatmap, we need to label the rows and columns
    with the names of the variables in our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'While the color scale will make it easy for us to differentiate between weak
    and strong correlations, it is often helpful to annotate the heatmap with the
    actual correlation coefficients. This can be accomplished by using the `text()`
    method on the `Axes` object containing the plot. For this plot, we placed white,
    center-aligned text indicating the value of the Pearson correlation coefficient
    for each variable combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in an annotated heatmap showing the correlations between the variables
    in the Facebook dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Visualizing correlations as a heatmap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.21_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – Visualizing correlations as a heatmap
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5.21*, we can easily see strong positive correlations among the OHLC
    time series, as well as among the volume traded and maximum absolute value of
    change. However, there are weak negative correlations between these groups. Furthermore,
    we can see that taking the logarithm of the volume does indeed increase the coefficient
    of correlation with `max_abs_change` from 0.64 to 0.73\. When we discuss `seaborn`
    in the next chapter, we will learn an easier way to generate a heatmap, and also
    cover annotations in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we want to visualize the distribution of our data to see what values
    it takes on. Depending on the type of data we have, we may choose to use histograms,
    **kernel density estimates** (**KDEs**), box plots, or **empirical cumulative
    distribution functions** (**ECDFs**). When working with discrete data, histograms
    are a good place to start. Let''s take a look at the histogram of daily volume
    traded in Facebook stock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a great example of real-world data that is, most definitely, not normally
    distributed. The volume traded is right skewed, with a long tail to the right.
    Recall that in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, when we discussed binning and looked at low,
    medium, and high volume traded, almost all of the data fell in the low bucket,
    which aligns with what we see in this histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Creating a histogram with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.22_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.22 – Creating a histogram with pandas
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As with the `plt.hist()` function from `matplotlib`, we can provide a custom
    value for the number of bins with the `bins` argument. However, we must be careful
    that we don't misrepresent the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create multiple histograms on the same plot to compare distributions
    by using the `ax` parameter to specify the same `Axes` object for each plot. In
    this case, we must use the `alpha` parameter to see any overlaps. Given that we
    have many different measurement techniques for earthquakes (the `magType` column),
    we may be interested in comparing the different ranges of magnitudes they yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us that `ml` is the most common `magType`, followed by `md`, and
    that they yield similar ranges of magnitudes; however, `mb`, which is the third-most
    common, yields higher magnitudes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Plotting overlapping histograms with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Plotting overlapping histograms with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with continuous data (such as stock prices), we can use KDEs.
    Let''s take a look at the KDE of the daily high price for Facebook stock. Note
    that we can pass either `kind=''kde''` or `kind=''density''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting density curve has some left skew:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Visualizing the KDE with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – Visualizing the KDE with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also want to visualize the KDE superimposed on top of the histogram.
    Pandas allows us to pass the `Axes` object we want to plot on, and also returns
    one after creating the visualization, which makes this a cinch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we had to pass `density=True` when we generated the histogram to
    make sure that the *y*-axis for the histogram and KDE were on the same scale.
    Otherwise, the KDE would have been too small to see. The histogram then gets plotted
    with density on the *y*-axis so that we can better understand how the KDE got
    its shape. We also increased the transparency of the histogram so that we could
    see the KDE line on top. Note that if we remove the `color=''blue''` part of the
    KDE call, we don''t need to change the value of `alpha` in the histogram call
    because the KDE and histogram will be different colors; we are plotting them both
    in blue since they represent the same data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Combining a KDE and a histogram with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.25_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.25 – Combining a KDE and a histogram with pandas
  prefs: []
  type: TYPE_NORMAL
- en: The KDE shows us an estimated **probability density function** (**PDF**), which
    tells us how probability is distributed over the values of the data. However,
    in some cases, we are more interested in the probability of getting less than
    or equal to (or greater than or equal to) some value, which we can see with the
    **cumulative distribution function** (**CDF**).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: With a CDF, the values for the *x* variable go along the *x*-axis, while the
    cumulative probability of getting, at most, a given *x* goes along the *y*-axis.
    This cumulative probability is between 0 and 1 and is written as *P(X ≤ x)*, where
    the lowercase (*x*) is the value for comparison and the uppercase (*X*) is the
    random variable, *X*. More information can be found at [https://www.itl.nist.gov/div898/handbook/eda/section3/eda362.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda362.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `statsmodels` package, we can estimate the CDF giving us the `ml`
    magnitude type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following ECDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Visualizing the ECDF'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.26_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.26 – Visualizing the ECDF
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be very useful in gaining a better understanding of our data when
    we conduct our EDA. However, we must be careful how we interpret this and how
    we explain it to others, if we choose to do so. Here, we can see that if this
    distribution is indeed representative of the population, the probability of the
    `ml` magnitude of the earthquake being less than or equal to **3** is **98%**
    for earthquakes measured with that measurement technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Interpreting the ECDF'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – Interpreting the ECDF
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can use box plots to visualize potential outliers and the distribution
    using quartiles. As an example, let''s visualize the OHLC prices for Facebook
    stock across the whole dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we do lose some information we had in the other plots. We no longer
    have an idea of the density of points throughout the distribution; with the box
    plot, we focus on the 5-number summary instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Creating box plots with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – Creating box plots with pandas
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We can create a notched box plot by passing in `notch=True`. The notch marks
    a 95% confidence interval around the median, which can be helpful when comparing
    differences between groups. There is an example in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also call the `boxplot()` method after calling `groupby()`. Let''s examine
    how the box plots change when we calculate them based on the volume traded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember from [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames,* that most of the days fell in the low volume
    traded bucket, so we would expect to see more variation there because of what
    the stock data looked like over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Box plots per group with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.29_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.29 – Box plots per group with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use this technique to see the distribution of earthquake magnitudes
    based on which `magType` was used and compare it with the expected ranges on the
    USGS website ([https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The USGS website mentions situations in which certain measurement techniques
    can''t be used and the range of magnitudes each measurement technique is authoritative
    for (when outside that range, other techniques are used). Here, we can see that,
    together, the techniques cover a wide spectrum of magnitudes, while none of them
    cover everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – Box plots per group in a single plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – Box plots per group in a single plot
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: While histograms, KDEs, ECDFs, and box plots are all ways of looking at the
    distribution of the data, we saw that each visualization showed us a different
    aspect of it. It's important to visualize the data from many angles before drawing
    any conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: Counts and frequencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with categorical data, we can create bar plots for displaying counts
    of our data or frequencies of particular values. The bars can be vertical (`kind='bar'`)
    or horizontal (`kind='barh'`). Vertical bar plots are useful when we have many
    categories or there is some order to the categories (for example, an evolution
    over time). Horizontal bar plots make it easy to compare the size of each category
    while allowing sufficient space on the margin for long category names (without
    the need to rotate them).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a horizontal bar plot to see which places in the `quakes` dataframe
    have had the most earthquakes. First, we call the `value_counts()` method on the
    `parsed_place` series and take the top 15 places for earthquakes. Next, we reverse
    the order so that the smallest ones in this list are on top, which will sort the
    highest to the top of the bar plot that we will make. Note that we could reverse
    the sort order as an argument to `value_counts()`, but since we would still have
    to grab the top 15, we are doing both in a single `iloc` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, slicing notation is `[start:stop:step]`, and in this case, since
    the step is negative, the order is reversed; we start at index `14` (the 15th
    entry) and get closer to index `0` each time. By passing `kind=''barh''`, we get
    a horizontal bar plot that shows that most of the earthquakes in this dataset
    occur in Alaska. Perhaps it is surprising to see the number of earthquakes over
    such a short time period, but many of these earthquakes are so small in magnitude
    that people don''t even feel them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – Plotting horizontal bars with pandas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.31_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.31 – Plotting horizontal bars with pandas
  prefs: []
  type: TYPE_NORMAL
- en: 'Our data also contains information about whether the earthquake was accompanied
    by a tsunami. Let''s use `groupby()` to make a bar plot of the top 10 places that
    were hit by tsunamis during the time period we have in our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this time, we used `iloc[-10:,]`, which starts at the 10th largest
    value (since `sort_values()` sorts in ascending order by default) and goes to
    the largest value, giving us the top 10\. Here, we can see that Indonesia had
    many more tsunamis than the other places during this time period:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – Plotting the result of a group by calculation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.32_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.32 – Plotting the result of a group by calculation
  prefs: []
  type: TYPE_NORMAL
- en: 'After seeing something like this, we may be prompted to look further into the
    number of tsunamis in Indonesia each day. We can visualize this evolution over
    time as a line plot or with a vertical bar plot by using `kind=''bar''`. Here,
    we will use bars to avoid interpolating the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On September 28, 2018, we can see a spike in both earthquakes and tsunamis
    in Indonesia; on this date a 7.5 magnitude earthquake occurred, causing a devastating
    tsunami:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – Comparing counts over time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.33_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.33 – Comparing counts over time
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create grouped bars from a single column''s values by using `groupby()`
    and `unstack()`. This makes it possible for us to generate bars for each distinct
    value in the column. Let''s use this strategy to take a look at the frequency
    of a tsunami accompanying an earthquake, as a percentage. We can handle this using
    the `apply()` method, as we learned in [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, along `axis=1` (to apply row by row). For illustration
    purposes, we will look at the seven places with the highest percentage of earthquakes
    accompanied by a tsunami:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Christmas Island had one earthquake during this time period, but it was accompanied
    by a tsunami. Papua New Guinea, on the other hand, had tsunamis alongside roughly
    40% of its earthquakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – Bar plot with a group by'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.34_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.34 – Bar plot with a group by
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When saving the preceding plots, long category names may get cut off; if that's
    the case, try running `plt.tight_layout()` before saving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use vertical bars to see which methods of measuring earthquake
    magnitude are most prevalent by using `kind=''bar''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that `ml` is, by far, the most common method for measuring earthquake
    magnitudes. This makes sense since it is the *original magnitude relationship
    defined by Richter and Gutenberg in 1935 for local earthquakes*, according to
    the USGS page explaining the `magType` field in the dataset we are using ([https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types](https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Comparing category counts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.35_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.35 – Comparing category counts
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to see how many earthquakes of a given magnitude there were and
    to distinguish them by `magType`. This shows us a few things in a single plot:'
  prefs: []
  type: TYPE_NORMAL
- en: Which magnitudes occur most often across `magType`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relative ranges of magnitude that each `magType` yields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common values for `magType`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do so, we can make a stacked bar plot. First, we will round all magnitudes
    down to the nearest integer. This means that all earthquakes will be marked as
    the part of the magnitude before the decimal point (for example, 5.5 gets marked
    as 5, just like 5.7, 5.2, and 5.0). Next, we will need to create a pivot table
    with the magnitude in the index and the magnitude type along the columns; we will
    count the number of earthquakes for the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the pivot table, we can create a stacked bar plot by passing in
    `stacked=True` when plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following plot, which shows that most of the earthquakes
    are measured with the `ml` magnitude type and have magnitudes below four:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36 – Stacked bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.36_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.36 – Stacked bar plot
  prefs: []
  type: TYPE_NORMAL
- en: 'The other bars are dwarfed in comparison to `ml`, which makes it difficult
    for us to see which magnitude types assign higher magnitudes to earthquakes. To
    address this, we can make a normalized stacked bar plot. Rather than showing the
    count of earthquakes for each combination of magnitude and `magType`, we will
    show what percentage of earthquakes of a given magnitude used each `magType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can easily see that `mww` yields higher magnitudes and that `ml` appears
    to be spread across the lower end of the spectrum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – Normalized stacked bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.37_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.37 – Normalized stacked bar plot
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can also use this strategy with a call to the `groupby()` and
    then `unstack()` methods. Let''s revisit the frequency of a tsunami accompanying
    an earthquake plot, but rather than use grouped bars, we will stack them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This stacked bar plot makes it very easy for us to compare the frequencies
    of tsunamis across different places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38 – Normalized stacked bar plot with a group by'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.38_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.38 – Normalized stacked bar plot with a group by
  prefs: []
  type: TYPE_NORMAL
- en: Categorical data limits us in terms of the types of plots we can use, but there
    are some alternatives to the bar plot. We will take a look at them in the *Utilizing
    seaborn for advanced plotting* section in the next chapter; for now, let's take
    a look at the `pandas.plotting` module.
  prefs: []
  type: TYPE_NORMAL
- en: The pandas.plotting module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Plotting with pandas* section, we covered standard plots that `pandas`
    has provided easier implementations for. However, `pandas` also has a module (which
    is appropriately named `plotting`) with special plots that we can use on our data.
    Note that the customization options of these may be more limited because of how
    they are composed and returned to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be working in the `3-pandas_plotting_module.ipynb` notebook for this
    section. As usual, we will begin with our imports and reading in the data; we
    will only be using the Facebook data here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a tour of some of the plots available in the `pandas.plotting`
    module and learn how we can utilize the resulting visualizations in our EDA.
  prefs: []
  type: TYPE_NORMAL
- en: Scatter matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we discussed using scatter plots to show relationships
    among variables. Often, we want to see these for each combination of variables
    in the data, which can be tedious to execute. The `pandas.plotting` module contains
    the `scatter_matrix()` function, which makes this much easier. Let''s use it to
    view the scatter plots for each combination of columns in our Facebook stock prices
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following plot matrix, which is often used in machine learning
    to see which variables could be useful in building a model. We can easily see
    that we have strong positive correlations between the opening, high, low, and
    closing prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39 – Pandas scatter matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.39_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.39 – Pandas scatter matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, on the diagonal, where the column is paired with itself, we get
    its histogram. Alternatively, we can ask for the KDE by passing in `diagonal=''kde''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a scatter matrix with KDEs along the diagonal instead of histograms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – Scatter matrix with KDEs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.40_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.40 – Scatter matrix with KDEs
  prefs: []
  type: TYPE_NORMAL
- en: While a scatter matrix makes it easy to examine the relationships between our
    variables, sometimes, we are interested in **autocorrelation**, which means that
    the time series is correlated with a lagged version of itself. One way to visualize
    this is with a lag plot.
  prefs: []
  type: TYPE_NORMAL
- en: Lag plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a `data[:-1]` (all but the last entry) and `data[1:]` (from the second
    entry to the last one).
  prefs: []
  type: TYPE_NORMAL
- en: 'If our data is random, this plot will have no pattern. Let''s test this with
    some random data generated with NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The random data points don''t indicate any pattern, just random noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.41 – Lag plot of random noise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.41_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.41 – Lag plot of random noise
  prefs: []
  type: TYPE_NORMAL
- en: 'With our stock data, we know that the prices on a given day are determined
    by what happened the day before; therefore, we would expect to see a pattern in
    the lag plot. Let''s use the closing price of Facebook''s stock to test whether
    our intuition is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this results in a linear pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.42 – Lag plot of Facebook stock prices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.42_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.42 – Lag plot of Facebook stock prices
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify the number of periods to use for the lag. The default lag
    is one, but we can change this with the `lag` parameter. For example, we can compare
    each value to the value of the week prior with `lag=5` (remember that the stock
    data only contains data for weekdays since the market is closed on the weekends):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This still yields a strong correlation, but, compared to *Figure 5.42*, it
    definitely looks weaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.43 – Customizing the number of periods for the lag plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.43_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.43 – Customizing the number of periods for the lag plot
  prefs: []
  type: TYPE_NORMAL
- en: While lag plots help us visualize autocorrelation, they don't show us how many
    periods of autocorrelation our data contains. For this purpose, we can use autocorrelation
    plots.
  prefs: []
  type: TYPE_NORMAL
- en: Autocorrelation plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pandas provides an additional way for us to look for autocorrelation in our
    data with the `autocorrelation_plot()` function, which shows the autocorrelation
    by the number of lags. Random data will be near an autocorrelation of zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did when discussing lag plots, let''s first examine what this looks like
    for random data generated with NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, the autocorrelation is near zero, and the line is within the confidence
    bands (99% is dashed; 95% is solid):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.44 – Autocorrelation plot of random data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.44_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.44 – Autocorrelation plot of random data
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore what the autocorrelation plot looks like for the closing price
    of Facebook''s stock, since the lag plots indicated several periods of autocorrelation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that there is autocorrelation for many lag periods before
    it becomes noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.45 – Autocorrelation plot of Facebook stock prices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.45_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.45 – Autocorrelation plot of Facebook stock prices
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [*Chapter 1*](B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015), *Introduction
    to Data Analysis*, that one of the components in an ARIMA model is the autoregressive
    component. The autocorrelation plot can be used to help determine the number of
    time lags to use. We will build an ARIMA model in [*Chapter 7*](B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146),
    *Financial Analysis – Bitcoin and the Stock Market*.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pandas also provides a plotting function for assessing the uncertainty of common
    summary statistics via `samples` and `size` parameters, respectively) and calculate
    the summary statistics. Then, it will return a visualization of the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the uncertainty for the summary statistics of the volume traded
    data looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following subplots, which we can use to assess the uncertainty
    in the mean, median, and midrange (the midpoint of the range):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.46 – Pandas bootstrap plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.46_B16834.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.46 – Pandas bootstrap plot
  prefs: []
  type: TYPE_NORMAL
- en: This was a sample of a few of the functions in the `pandas.plotting` module.
    For the full list, check out [https://pandas.pydata.org/pandas-docs/stable/reference/plotting.html](https://pandas.pydata.org/pandas-docs/stable/reference/plotting.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've completed this chapter, we are well-equipped to quickly create
    a variety of visualizations in Python using `pandas` and `matplotlib`. We now
    understand the basics of how `matplotlib` works and the main components of a plot.
    Additionally, we discussed various plot types and the situations in which to use
    them—a crucial component of data visualization is choosing the appropriate plot.
    Be sure to check out the *Choosing the appropriate visualization* section in the
    *Appendix* for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the best practices for visualization don't just apply to the plot
    type, but also to the formatting of the plot, which we will discuss in the next
    chapter. In addition to this, we will build upon the foundation we laid here to
    discuss additional plots using `seaborn` and how to customize our plots using
    `matplotlib`. Be sure to complete the end-of-chapter exercises to practice plotting
    before moving on, as we will be building on this chapter's material.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following visualizations using what you have learned up to this
    point in this book. Use the data from this chapter''s `data/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Plot the rolling 20-day minimum of the Facebook closing price using `pandas`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a histogram and KDE of the change from open to close in the price of
    Facebook stock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the earthquake data, create box plots for the magnitudes of each `magType`
    used in Indonesia.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a line plot of the difference between the weekly maximum high price and
    the weekly minimum low price for Facebook. This should be a single line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Plot the 14-day moving average of the daily change in new COVID-19 cases in
    Brazil, China, India, Italy, Spain, and the USA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) First, use the `diff()` method that was introduced in the *Working with time
    series data* section of [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, to calculate the day-over-day change in new cases.
    Then, use `rolling()` to calculate the 14-day moving average.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'b) Make three subplots: one for China; one for Spain and Italy; and one for
    Brazil, India, and the USA.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using `matplotlib` and `pandas`, create two subplots side-by-side showing the
    effect that after-hours trading has had on Facebook''s stock prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) The first subplot will contain a line plot of the daily difference between
    that day's opening price and the prior day's closing price (be sure to review
    the *Working with time series data* section of [*Chapter 4*](B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082),
    *Aggregating Pandas DataFrames*, for an easy way to do this).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b) The second subplot will be a bar plot showing the net effect this had monthly,
    using `resample()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'c) Bonus #1: Color the bars according to whether there are gains in the stock
    price (green) or drops in the stock price (red).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'd) Bonus #2: Modify the *x*-axis of the bar plot to show the three-letter abbreviation
    for the month.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following resources for additional information on the concepts
    that were discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bootstrapping (statistics)*: [https://en.wikipedia.org/wiki/Bootstrapping_(statistics)](https://en.wikipedia.org/wiki/Bootstrapping_(statistics))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data Visualization – Best Practices and Foundations*: [https://www.toptal.com/designers/data-visualization/data-visualization-best-practices](https://www.toptal.com/designers/data-visualization/data-visualization-best-practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to Create Animated Graphs in Python (with matplotlib)*: [https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1](https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interactive Plots with JavaScript (D3.js)*: [https://d3js.org/](https://d3js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Intro to Animations in Python (with plotly)*: [https://plot.ly/python/animations/](https://plot.ly/python/animations/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IPython: Built-in magic commands*: [https://ipython.readthedocs.io/en/stable/interactive/magics.html](https://ipython.readthedocs.io/en/stable/interactive/magics.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Importance of Integrity: How Plot Parameters Influence Interpretation*:
    [https://www.t4g.com/insights/plot-parameters-influence-interpretation/](https://www.t4g.com/insights/plot-parameters-influence-interpretation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*5 Python Libraries for Creating Interactive Plots*: [https://mode.com/blog/python-interactive-plot-libraries/](https://mode.com/blog/python-interactive-plot-libraries/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
