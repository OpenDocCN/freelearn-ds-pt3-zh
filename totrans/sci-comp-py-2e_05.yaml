- en: Advanced Array Concepts
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explain some more advanced aspects of arrays. First,
    we will cover the notion of an array view – a concept that a NumPy programmer
    absolutely must be aware of to avoid hard-to-debug programming errors. Then, Boolean
    arrays will be introduced along with the ways to compare arrays. Furthermore,
    we will briefly describe indexing and vectorization, explaining special topics
    such as broadcasting and sparse matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Array views and copies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance and vectorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparse matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1 Array views and copies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to control precisely how memory is used, NumPy offers the concept of
    a view of an array. Views are smaller arrays that share the same data as a larger
    array. This works just like a reference to one single object.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 Array views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest example of a view is given by a slice of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding slice `v ` is a view of `M`. It shares the same data as `M`.
    Modifying `v` will modify `M` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to access the object that owns the data using the array attribute `base`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If an array owns its data, the attribute base is `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 5.1.2 Slices as views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are precise rules on which slices will return views and which ones will
    return copies. Only basic slices (mainly index expressions with `:`) return views,
    whereas any advanced selections (such as slicing with a Boolean) will return a
    copy of the data. For instance, it is possible to create new matrices by indexing
    with lists (or arrays):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the array `b` is not a view, whereas the array `c`,
    obtained with a simpler slice, is a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an especially simple slice of an array that returns a view of the
    whole array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 5.1.3 Generating views by transposing and reshaping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some other important operations return views. For instance, transposing an
    array returns a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies to all  reshaping operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 5.1.4 Array copies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it is necessary to explicitly request that the data be copied. This
    is simply achieved with the NumPy function called `array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the data has indeed been copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you saw the concept of array views. NumPy works with views
    instead of copies of a given array to save memory, which – especially for large
    arrays – can be crucial. On the other hand, unintentionally using views may cause
    programming errors that are hard to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Comparing arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Comparing two arrays is not as simple as it may seem. Consider the following
    code, which is intended to check whether two matrices are close to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code raises the following exception when the `if` statement is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we'll explain why this is so and how to remedy this state of
    affairs.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Boolean arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boolean arrays are useful for advanced array indexing (also see [Section 5.3.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    Indexing with Boolean arrays). A Boolean array is simply an array for which the
    entries have the type `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Any comparison operator acting on arrays will create a Boolean array instead
    of a simple Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that because array comparison creates Boolean arrays, one cannot use array
    comparison directly in conditional statements, for example, `if` statements. The
    solution is to use the methods `all` and `any` to create a simple `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, the use of one of the methods `all` and `any` results in a "scalar" Boolean,
    which now allows array comparisons in `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 Checking for array equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking the equality of two float arrays is not straightforward, because two
    floats may be very close without being equal. In NumPy, it is possible to check
    for equality with `allclose`. This function checks for the equality of two arrays
    up to a given precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The tolerance is given in terms of a relative tolerance bound, `rtol`, and
    an absolute error bound, `atol`. The command `allclose` is a short form of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `allclose` can be also applied to scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 5.2.3 Boolean operations on arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You cannot use `and`, `or`, and `not` on Boolean arrays. Indeed, those operators
    force the casting from array to Boolean, which is not permitted. Instead, we can
    use the operators given in Table 5.1 for component-wise logical operations on
    Boolean arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logic operator** | **Replacement for Boolean arrays** |'
  prefs: []
  type: TYPE_TB
- en: '| `A and B` | `A & B` |'
  prefs: []
  type: TYPE_TB
- en: '| `A or B` | `A &#124; B` |'
  prefs: []
  type: TYPE_TB
- en: '| `not A` | `~ A` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 5.1: Logical operators for component-wise logical array operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example usage of logical operators with Boolean arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we have a sequence of data that is marred with some measurement
    error. Suppose further that we run a regression and it gives us a deviation for
    each value. We wish to obtain all the exceptional values and all the values with
    a little deviation that are lower than a given threshold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first created a data vector and then we perturbed it with
    some deviations sampled from normally distributed random numbers. We demonstrated
    two alternative ways of finding elements of data with large perturbations in absolute
    values, and finally, we collected only small data values for small perturbations.
    Here, we used a Boolean array instead of indexes when working with the array `data`.
    This technique will be explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Array indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that we can index arrays with combinations of slices and
    integers – this is a basic slicing technique. There are, however, many more possibilities
    that allow for a variety of ways to access and modify array elements.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Indexing with Boolean arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often useful to access and modify only parts of an array, depending on
    its value. For instance, you might want to access all the positive elements of
    an array. This turns out to be possible using Boolean arrays, which act like masks
    to select only some elements of an array. The result of such indexing is *always* a
    vector. For instance, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the command `M[B]` is equivalent to `M[B].flatten()`. You can then
    replace the resulting vector with another vector. For instance, you can replace
    all the elements with zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can replace all the selected values with others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining the creation of Boolean arrays (`M > 2`), smart indexing (indexing
    with a Boolean array), and broadcasting, you can use the following elegant syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression broadcasting here refers to the tacit conversion of the scalar
    `0` to a vector of an appropriate shape (also see [Section 5.5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml):
    *Broadcasting*).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 Using the command where
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The command `where` gives a useful construct that can take a Boolean array as
    a condition and either return the indexes of the array elements satisfying the
    condition or return different values depending on the values in the Boolean array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will return values from `a` when the condition is `True` and values from `b` when
    it is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider a *Heaviside* function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/460877e6-45a6-42bb-b9a6-c002278d76c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'and its implementation with the command `where`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second and third arguments can be either arrays of the same size as the
    condition (the Boolean array) or scalars. We''ll give two more examples to demonstrate
    how to manipulate elements from an array or a scalar depending on a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the second and third arguments are omitted, then a tuple containing the indexes
    of the elements satisfying the condition is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the use of `where` with only one argument in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates how to find out indexes of those elements of a Boolean
    array that are `True`. The command `where` is a very handy tool to search in an
    array for elements fulfilling a given condition.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you saw various use cases of Boolean arrays. Whenever your
    code contains `for` loops operating on conditions and arrays, check if the concept
    of Boolean arrays could help to remove unnecessary `for` loops and increase at
    least the readability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Performance and vectorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to the performance of your Python code, it often boils down to
    the difference between interpreted code and compiled code. Python is an interpreted
    programming language and basic Python code is executed directly without any intermediate
    compilation to machine code. With a compiled language, the code needs to be translated to
    machine instructions before execution.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of an interpreted language are many but interpreted code cannot
    compete with compiled code for speed. To make your code faster, you can write
    some parts in a compiled language such as FORTRAN, C, or C++. This is what NumPy
    and SciPy do.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, it is best to use functions in NumPy and SciPy over interpreted
    versions whenever possible. NumPy array operations such as matrix multiplication,
    matrix-vector multiplication, matrix factorization, scalar products, and so on
    are much faster than any pure Python equivalent. Consider the simple case of scalar
    products. The scalar product is much slower than the compiled NumPy function `dot(a,b)` (more
    than 100 times slower for arrays with about 100 elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Measuring the speed of your functions is an important aspect of scientific
    computing. See [Section 15.3](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Measuring
    execution time* for details on measuring execution times.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Vectorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve performance, you have often to vectorize the code. Replacing `for` loops
    and other slower parts of the code with NumPy slicing, operations, and functions
    can give significant improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the simple addition of a scalar to a vector by iterating over
    the elements is very slow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But using NumPy''s addition is much faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Using NumPy slicing can also give significant speed improvements over iterating
    with `for` loops. To demonstrate this, let''s consider forming the average of
    neighbors in a two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These functions both assign each element the average of its four neighbors.
    The second version, using slicing, is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides replacing `for` loops and other slower constructions with NumPy functions,
    there is a useful function called `vectorized` (see [Section 4.8](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Functions acting on arrays*). This takes a function and creates a vectorized
    version that applies the function on all elements of an array using functions
    wherever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function which we will use to demonstrate how to vectorize
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this function on elements of a vector ![](img/4586f943-368a-4d03-9422-88fe5ca55f9a.png) with
    100 elements in a non-vectorized way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'is nearly three times slower than using it in the vectorized way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we showed several examples of the vectorization of computations
    with NumPy arrays. An active use of this concept is recommended not only for speeding
    up the execution of your code but also for improving the readability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadcasting in NumPy denotes the ability to guess a common, compatible shape
    between two arrays. For instance, when adding a vector (one-dimensional array)
    and a scalar (zero-dimensional array), the scalar is extended to a vector, in
    order to allow for the addition. The general mechanism is called broadcasting.
    We will first review that mechanism from a mathematical point of view, and then
    proceed to give the precise rules for broadcasting in NumPy. The mathematical
    view might give a mathematically trained reader easier access to broadcasting,
    while other readers might want to skip the mathematical details and directly continue
    reading [Section 5.5.2](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Broadcasting
    arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.1 Mathematical views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broadcasting is often performed in mathematics, mainly implicitly. Examples
    are expressions such as ![](img/69891ec8-0b8d-4396-9e75-2192d35dd16f.png) or ![](img/92db4562-4d42-4820-a1e6-0d22d11a35e1.png).
    We will give an explicit description of that technique in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have in mind the very close relationship between functions and NumPy arrays,
    as described in [Section 4.2.1](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Arrays
    as functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Constant functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most common examples of broadcasting is the addition of a function
    and a constant; if ![](img/66a23cd3-5e96-4255-9e41-2491f350b5da.png) is a scalar,
    we often write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef17988a-4b0c-4195-8d65-d04ad4f6c07d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an abuse of notation since you should not be able to add functions
    and constants. Constants are, however, implicitly broadcast to functions. The
    broadcast version of the constant ![](img/371dcbce-b9e2-4331-8072-7038d84c16ef.png)
    is the function ![](img/6c1b9471-8cc7-4600-bff9-b0720043b17e.png) defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f15a1f56-1c7a-429c-a38b-e1481f7436e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it makes sense to add two functions together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfba5757-8042-4e11-ad24-6e7b231cc428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not being pedantic for the sake of it, but because a similar situation
    may arise for arrays, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, everything happens as if the scalar `1.` had been converted
    to an array of the same length as `vector`, that is, `array([1.,1.,1.,1.])`, and
    then added to `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: This example is exceedingly simple, so we'll proceed to show less obvious situations.
  prefs: []
  type: TYPE_NORMAL
- en: Functions of several variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more intricate example of broadcasting arises when building functions of
    several variables. Suppose, for instance, that we were given two functions of
    one variable, ![](img/ac094d60-643a-4288-aaa0-a59873bf1149.png) and *![](img/fb48d608-1c7e-47ed-92f8-b8348723c3a9.png)*,
    and that we want to construct a new function, *![](img/568707f0-40b8-4f1a-9483-66297d555257.png)*,
    according to the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ee8e56a-18e9-423a-b540-587e6a6997a9.png)'
  prefs: []
  type: TYPE_IMG
- en: This is clearly a valid mathematical definition. We would like to express this
    definition as the sum of two functions in two variables defined as
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a348796b-1a2e-4cfe-9fe5-b78373d683e4.png),'
  prefs: []
  type: TYPE_NORMAL
- en: 'and now we may simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdb81504-466e-467b-abc2-3c8b78df504c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The situation is similar to that arising when adding a column matrix and a
    row matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is especially useful when sampling functions of two variables, as shown
    in [Section 5.5.3](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Typical examples*.
  prefs: []
  type: TYPE_NORMAL
- en: General mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how to add a function and a scalar and how to build a function
    of two variables from two functions of one variable. Let''s now focus on the general
    mechanism that makes this possible. The general mechanism consists of two steps:
    *reshaping* and *extending*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the function ![](img/b3f744ae-3eb2-4a0d-ad22-e109b90e4b30.png) is *reshaped* to
    the function ![](img/744ec18e-d9c8-48ae-90bc-52778afdef85.png), which takes two
    arguments. One of these arguments is a dummy argument, which we take to be zero,
    as a convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba7c8aec-ae56-4b15-877a-7936cbb1b6f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Mathematically, the domain of the definition of ![](img/c1a4c9a1-5a05-4bb5-936f-fd31524e29dc.png)
    is now ![](img/ec7c650c-102d-4c3a-820b-99effb8c4af3.png) Then the function ![](img/d442142f-b300-4b26-9f85-a94741d9e562.png)
    is *reshaped* in a way similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af5cef49-26d4-4daf-b64c-119ed180760a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now both ![](img/e3bf73d2-a1a3-44fb-af5e-c0779496df1f.png)and ![](img/13afea47-b115-429d-b132-28d5905a513f.png)
    take two arguments, although one of them is always zero. We proceed to the next
    step, *extending*. It is the same step that converted a constant into a constant
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function ![](img/5d7e6e3f-a7df-408b-9161-38c50b311745.png) is *extended*
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bf12815-d1ac-4df8-8ec5-b93901699031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The function ![](img/0b274b2e-637a-4aaa-b3ce-7e34acb94f31.png) is extended
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de132c36-12e2-42e2-9f1d-8cc0137eb711.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the function of two variables, ![](img/a8620c7e-d435-4557-85d9-be15cbafb7d3.png),
    which was sloppily defined by ![](img/eed2403f-0afd-4741-bfc4-11fd7ab13a03.png),
    may be defined without reference to its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8de1d5f3-13e4-4d33-afff-95477ad21e9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, let''s describe the preceding mechanism for constants. A constant
    is a scalar, that is, a function of zero arguments. The *reshaping step* is thus
    to define the function of one (empty) variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15e63522-e49d-4dd7-8114-35a33fab1d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the *extension step* proceeds simply with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e4751c9-6b14-4d2e-a08b-95f9cb52e64e.png)'
  prefs: []
  type: TYPE_IMG
- en: Conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last ingredient is the convention for how to add the extra arguments to
    a function, that is, how the reshaping is automatically performed. By convention,
    a function is automatically reshaped by adding zeros on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a function ![](img/dbd64242-e716-4805-b924-487009f23a49.png)
    of two arguments has to be reshaped to three arguments, the new function will
    be defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35e31143-4398-41a3-be36-f193b706925d.png)'
  prefs: []
  type: TYPE_IMG
- en: After having seen a more mathematical motivation for broadcasting, we now show
    how this applies to NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.2 Broadcasting arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll now repeat the observation that arrays are merely functions of several
    variables (see [Section](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml) 4.2: *Mathematical
    preliminaries*). Array broadcasting thus follows exactly the same procedure as
    explained above for mathematical functions. Broadcasting is done automatically
    in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Figure 5.1, we show what happens when adding a matrix of shape (4, 3) to
    a matrix of size (1, 3). The resulting matrix is of the shape (4, 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2e7cf3e-17d3-4938-a31f-0456a76e19ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Broadcasting between a matrix and a vector'
  prefs: []
  type: TYPE_NORMAL
- en: The broadcasting problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When NumPy is given two arrays with different shapes and is asked to perform
    an operation thatwould require the two shapes to be the same, both arrays are
    broadcast to a common shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the two arrays have shapes ![](img/f5574319-181a-4f32-aba0-71d06d7ba0de.png) and ![](img/5b47ea61-2df0-4ea2-a664-f16987b19b1a.png).
    Broadcasting consists of the two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shape ![](img/c3046fe0-1e71-44e6-9b37-66789ee79b95.png) is shorter than
    the shape ![](img/30589aa2-56ff-41ea-a6a0-670c80e814e1.png), that is, `len(s1)
    < len(s2)`, then ones are added on the left of the shape ![](img/00af5683-394d-4b11-b526-a0d661fd1445.png).
    This is reshaping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the shapes have the same length, the first array is extended to match the
    shape *s[2]* (if possible).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose we want to add a vector of shape ![](img/c3a599e3-145d-4a1b-9155-a668ffca988f.png)
    to a matrix of shape ![](img/cd2275cc-e7d9-4129-b18d-4fba55afaea3.png). The vector
    needs to be broadcast. The first operation is reshaping; the shape of the vector
    is converted from (3, ) to (1, 3). The second operation is an extension; the shape
    is converted from (1, 3) to (4, 3).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose a vector ![](img/25dcaa7c-1ab6-48ef-8f60-2d002c90f591.png)
    of size *n* is to be broadcast to the shape (*m, n*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d012613e-decb-42fa-aba9-5d3fe7dc155b.png) is automatically reshaped
    to (1, *n*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/077eabe8-be98-4d56-b46c-6424aa64c9e1.png) is extended to (*m*, *n*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To demonstrate this, we consider a matrix defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'and a vector given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we may add `M` and `v` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f0e0965-3ef7-48ff-9dbf-25c7ab17f013.png)'
  prefs: []
  type: TYPE_IMG
- en: Shape mismatch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not possible to automatically broadcast a vector `v` of length `n` to
    the shape `(n,m)`. This is illustrated in *Figure 5.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c77c88d-e3f2-4a51-a36b-d8ce883f6059.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Failure of broadcasting due to shape mismatch'
  prefs: []
  type: TYPE_NORMAL
- en: 'The broadcasting fails, because the shape `(n,)` may not be automatically broadcast
    to the shape `(m, n)`. The solution is to manually reshape `v` to the shape `(n,1)`.
    The broadcasting will now work as usual (by extension only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is illustrated by the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a matrix with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and a vector with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now automatic broadcasting will fail because automatic reshaping does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is thus to take care of the reshaping manually. What we want in
    that case is to add 1 on the right, that is, transform the vector into a column
    matrix. The broadcasting then works directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '(For the shape parameter `-1`, see [Section 4.6.3](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Reshape.*) The result is this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 5.5.3 Typical examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's examine some typical examples where broadcasting may come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Rescale rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose `M` is an *![](img/8c502202-49f7-4a8e-a850-142921b05540.png)* matrix
    and we want to multiply each row by a coefficient. The coefficients are stored
    in a vector `coeff` with *n* components. In that case, automatic reshaping will
    not work, and we have to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Rescale columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The setup is the same here, but we would like to rescale each column with a
    coefficient stored in a vector `coeff` of length *m*. In this case, automatic
    reshaping will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we may also do the reshaping manually and achieve the same result
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Functions of two variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose ![](img/1c262619-1c75-4291-970a-1daad2e23f1b.png) and ![](img/d304100a-0ec4-4653-8315-abc1a427de3a.png)
    are vectors and we want to form the matrix ![](img/52654bb6-2f26-451d-8b06-9d16eb84a766.png)
    with elements ![](img/e082400a-96c1-4e39-9567-2b20d7548b88.png). This would correspond
    to the function ![](img/44feaca2-8d65-40cf-86ee-4f32300f2b0b.png). The matrix ![](img/6d1d25c9-5da6-4eb1-95e0-2f78f4318103.png)
    is merely defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the vectors *![](img/7c329343-7ce8-40d9-b58e-ee57831cc5b8.png)* and ![](img/a8a0819d-b28c-415e-aa33-3a8748d54267.png)
    are ![](img/5abfef87-142c-4971-801d-95e0dfa50d20.png) and ![](img/e875b9e9-c719-4c4c-beb9-7a506626e90d.png) respectively,
    the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, suppose that we want to sample the function ![](img/514d009e-f785-4285-8728-cf6a0e8ae6d9.png).
    Supposing that the vectors ![](img/ca628e79-cf1c-413b-94b4-d13cdef8c319.png) and ![](img/6146f5d4-8840-4353-8999-f0bc24d15203.png)
    are defined, the matrix ![](img/0c41556d-bccb-4901-9eac-0370087b4249.png) of sampled
    values is obtained with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is very frequently used in combination with `ogrid`. The vectors
    obtained from `ogrid` are already conveniently shaped for broadcasting. This allows
    for the following elegant sampling of the function ![](img/e25a91bf-92cb-4797-8317-39708a208778.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax of `ogrid` needs some explanation: First, `ogrid` is not a function.
    It is an instance of a class with a `__getitem__` method (see [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods*). That is why it is used with brackets instead of parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two commands are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The stride parameter in the preceding example is a complex number. This is
    to indicate that it is the number of steps instead of the step size. The rules
    for the stride parameter might be confusing at first glance:'
  prefs: []
  type: TYPE_NORMAL
- en: If the stride is a real number, then it defines the size of the steps between
    start and stop and stop is not included in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the stride is a complex number `s`, then the integer part of `s.imag` defines
    the number of steps between start and stop and stop is included in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of `ogrid` is a tuple with two arrays, which can be used for broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'which is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 5.6\. Sparse matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrices with a small number of nonzero entries are called *sparse matrices*.
    Sparse matrices occur, for example, in scientific computing when describing discrete
    differential operators in the context of numerically solving partial differential
    equations.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse matrices often have large dimensions, sometimes so large that the entire
    matrix (with zero entries) would not even fit in the available memory. This is
    one motivation for a special datatype for sparse matrices. Another motivation
    is better performance of operations where zero matrix entries can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: There are only a very limited number of algorithms for general, unstructured
    sparse matrices in linear algebra. Most of them are iterative in nature and based
    on efficient implementations of matrix-vector multiplication for sparse matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of sparse matrices are diagonal or banded matrices. The simple pattern
    of these matrices allows straightforward storing strategies; the principal diagonal
    and the sub- and super-diagonals are stored in 1D arrays. Conversion from a sparse
    representation to the classical array type and vice versa can be done with the
    NumPy command `diag`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, there is not such a simple structure and the description of sparse
    matrices requires special techniques and standards.
  prefs: []
  type: TYPE_NORMAL
- en: An example of such a matrix is shown in Figure 5.3\. There, the pixels denote
    nonzero entries in the 1250 × 1250 matrix.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we present a row and a column-oriented type for sparse matrices,
    both available through the module `scipy.sparse`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f80bc23d-f23a-4f62-bd62-7fa64296e1ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: A stiffness matrix from a finite element model of an elastic plate.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1 Sparse matrix formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The module `scipy.sparse` provides many different storing formats for sparse matrices.
    Here, we''ll describe only the most important ones: CSR, CSC, and LIL. The LIL
    format should be used for generating and altering sparse matrices; CSR and CSC
    are efficient formats for matrix-matrix and matrix-vector operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Compressed sparse row format (CSR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **compressed sparse row** (**CSR**) format uses three arrays: `data`, `indptr`,
    and `indices`:'
  prefs: []
  type: TYPE_NORMAL
- en: The 1D array `data` stores all the nonzero values in order. It has as many elements
    as there are nonzero elements, often denoted by the variable `nnz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1D array `indptr` contains integers such that `indptr[i]` is the index of
    the element in `data`, which is the first nonzero element of row *i*. If the entire
    row *i* is zero, then `indptr[i]==indptr[i+1]`. If the original matrix has *m* rows,
    then `len(indptr)==m+1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 1D array `indices` contains the column index information in such a way that `indices[indptr[i]:indptr[i+1]]` is
    an integer array with the column indexes of the nonzero elements in row *i*. Obviously, `len(indices)==len(data)==nnz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSR format of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3637523e-fddf-44da-8c67-6286fe700b5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'is given by the three arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The module `scipy.sparse` provides a type, `csr_matrix`, with a constructor,
    which can be used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: With a 2D array as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a matrix in one of the other sparse formats in `scipy.sparse`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a shape argument, `(m,n)`, to generate a zero matrix in CSR format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By a 1D array for `data` and an integer array `ij` with the shape `(2,len(data))` such
    that `ij[0,k]` is the row index and `ij[1,k]` is the column index of `data[k]` of
    the matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three arguments, `data`, `indptr`, and `indices`, can be given to the constructor
    directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two options are there for conversion purposes while the last two directly
    define the sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the above example; in Python, it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Among others, the following attributes are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Compressed sparse column format (CSC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CSR format has a column-oriented twin – the **compressed sparse column**
    (**CSC**) format. The only difference in it compared to the CSR format is the
    definition of the `indptr` and `indices` arrays, which are now column-related.
    The type for the CSC format is `csc_matrix` and its use corresponds to `csr_matrix`,
    explained previously in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the same example in CSC format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Row-based linked list format (LIL)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The linked list sparse format stores the nonzero matrix entries row-wise in
    a list `data` such that `data[k]` is a list of the nonzero entries in row *k*.
    If all entries in that row are 0, it contains an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second list, `rows`, contains at position *k* a list of column indexes of
    the nonzero elements in row *k*. Here is an example in row-based **linked list**
    (**LIL**) format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Altering and slicing matrices in LIL format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The LIL format is the one best suited for slicing, that is, extracting submatrices
    in LIL format, and for changing the sparsity pattern by inserting nonzero elements.
    Slicing is demonstrated by the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The insertion of a new nonzero element automatically updates the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: These operations are discouraged in the other sparse matrix formats as they
    are extremely inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.2 Generating sparse matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NumPy commands `eye`, `identity`, `diag`, and `rand` have their sparse counterparts.
    They take an additional argument; it specifies the sparse matrix format of the
    resulting matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands generate the identity matrix but in different sparse
    matrix formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `sp.rand` takes an additional argument describing the density of
    the generated random matrix. A dense matrix has density 1 while a zero matrix
    has density 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no direct correspondence to the NumPy command `zeroes`. Matrices completely
    filled with zeros are generated by instantiating the corresponding type with the
    shape parameters as constructor parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After having studied different sparse matrix formats, we now turn to special
    methods for a sparse matrix, mainly conversion methods.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3 Sparse matrix methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are methods to convert one sparse type into another or into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The type of a sparse matrix can be inspected by the methods `issparse`, `isspmatrix_lil`,
    `isspmatrix_csr`, and `isspmatrix_csc`.
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise operations `+`, `*`, `/`, and `**` on sparse matrices are defined
    as for NumPy arrays. Regardless of the sparse matrix format of the operands, the
    result is always `csr_matrix`. Applying elementwise operating functions to sparse
    matrices requires first transforming them to either CSR or CSC format and applying
    the functions to their `data` attribute, as demonstrated by the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elementwise sine of a sparse matrix can be defined by an operation on its `data` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For matrix-matrix or matrix-vector multiplications, there is a sparse matrix
    method, `dot`. It returns either a `csr_matrix` or a 1D NumPy `array`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function on which we will demonstrate how to vectorize
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Avoid using NumPy's command `dot` on sparse matrices, as this might lead to
    unexpected results. Use the command `dot` from `scipy.sparse` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Other linear algebra operations such as system solving, least squares, eigenvalues,
    and singular values are provided by the module `scipy.sparse.linalg`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of views is one of the important topics you should have learned
    from this chapter. Missing this topic will give you a hard time when debugging
    your code. Boolean arrays occur at various places throughout this book. They are
    handy and compact tools for avoiding lengthy `if` constructions and loops when
    working with arrays. In nearly all large computational projects, sparse matrices
    become an issue. You have seen how they are handled and which related methods
    are available.
  prefs: []
  type: TYPE_NORMAL
