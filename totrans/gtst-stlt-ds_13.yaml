- en: '*Chapter 10*: The Data Project – Prototyping Projects in Streamlit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to create Streamlit applications that
    are specific to job applications. Another fun application of Streamlit is to try
    out new and interesting data science ideas and create interactive apps for others.
    Some examples of this include applying a new machine learning model to an existing
    dataset, carrying out an analysis on some data uploaded by users, or creating
    an interactive analysis on a private dataset. There are numerous reasons for making
    a project like this, such as personal education or community contribution.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of personal education, often, the best way to learn a new topic is
    to observe how it actually works by applying it to the world around you or a dataset
    that you know closely. For instance, if you are trying to learn how *Principal
    Component Analysis* works, you can always learn about it in a textbook or watch
    someone else apply it to a dataset. However, I have found that my comprehension
    of a topic goes through the roof when I actually apply it myself in practice.
    Streamlit is perfect for this. It allows you to give new ideas a shot in a responsive,
    fun environment that can be easily shared with others. Learning data science can
    be collaborative, which leads me to the next reason for creating data projects
    in Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of community contribution, one of the best parts of Streamlit – and,
    frankly, data science – is the growing community around the tools and toys we
    routinely play with. By learning with others and sharing Streamlit apps on Twitter
    ([https://twitter.com/tylerjrichards](https://twitter.com/tylerjrichards)), LinkedIn,
    and the Streamlit forums ([https://discuss.streamlit.io/](https://discuss.streamlit.io/)),
    we can turn away from the zero-sum experience that is taught in most schools and
    universities (where if your classmate gets a good grade, that usually comparatively
    hurts you) and toward a positive-sum experience, where you directly benefit from
    the lessons learned by others. To use the previous example, if you create an app
    that helped you understand the statistics behind principal component analysis,
    sharing that with others will probably teach them something, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will run through one thorough data project from end to
    end, starting with an idea and ending with the final product. Specifically, we
    will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data science ideation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting and cleaning data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a **Minimum Viable Product** (**MVP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative improvement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting and promotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will utilize the website *Goodreads.com*, which is a popular
    website owned by Amazon, that is used to track everything about a user's reading
    habits, from when they started and finished books to what they would like to read
    next. It is recommended that you first head over to [https://www.goodreads.com/](https://www.goodreads.com/),
    sign up for an account, and explore around a little (perhaps you can even add
    your own book lists!).
  prefs: []
  type: TYPE_NORMAL
- en: Data science ideation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, coming up with a new idea for a data science project is the most daunting
    part. You might have numerous doubts. What if I start a project that no one likes?
    What if my data actually doesn't work out well? What if I can't think of anything?
    The good news is that if you are creating projects that you actually do care about
    and would use, then the worst-case scenario is that you have an audience of one!
    And if you send me (*tylerjrichards@gmail.com*)your project, I promise to read
    it. So that makes it an audience of two at the very least.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples I have either created or observed in the wild include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Recording ping-pong games for a semester to determine the best player with an
    Elo model ([http://www.tylerjrichards.com/Ping_pong.html](http://www.tylerjrichards.com/Ping_pong.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using natural language processing to determine the quality of Wi-Fi in hostels
    ([https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/](https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing thousands of pizza reviews to find the best NYC pizza near you ([https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1](https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing your reading habits with Goodreads data ([http://www.tylerjrichards.com/books_reco.html](http://www.tylerjrichards.com/books_reco.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only one of these data projects uses Streamlit, as the rest came out before
    the library was released. However, all of these could have been improved by deploying
    them on Streamlit rather than just uploading them to a Jupyter Notebook (*project
    #1*) or a Word document/HTML file (*projects #2 and #3*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different methods that you can use to come up with your own
    idea for a data project, but the most popular methods generally fall into three
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding data that only you could gather (for example, your friend's ping-pong
    games)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding data that you care about (for example, Goodreads' reading data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking of an analysis/app you wish existed to solve a problem you have and
    executing it (for example, hostel Wi-Fi analysis or finding the best pizza near
    you in NYC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try one of these or start with another idea that you have already. The
    best method is the one that works best for you! For this chapter, we will walk
    through and recreate the Goodreads Streamlit app, in depth, as an example of a
    data project. You can access it again at [http://www.tylerjrichards.com/books_reco.html](http://www.tylerjrichards.com/books_reco.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This app is designed to scrape a user''s Goodreads history and create a set
    of graphs to inform them about their reading habits since they started using Goodreads.
    The sets of graphs should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 10.1 – Examples of Goodreads'' graphs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Examples of Goodreads' graphs
  prefs: []
  type: TYPE_NORMAL
- en: I came up with this idea by doing a personal analysis of my book history, and
    then thinking to myself that others might also be interested in this analysis!
    There really was no better reason than that, and often, the most fun projects
    start out that way. To begin, we will work on collecting and cleaning the user
    data that exists on Goodreads.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting and cleaning data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways in which to get data from Goodreads: through their **Application
    Programming Interface** (**API**), which allows developers to programmatically
    access data about books, and through their manual exporting function. Sadly, Goodreads
    is deprecating their API in the near future and, as of December 2020, are not
    giving access to more developers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original Goodreads app uses the API, but our version will rely on the manual
    exporting function that the Goodreads website has instead. To get your data, head
    over to [https://www.goodreads.com/review/import](https://www.goodreads.com/review/import)
    and download your own data. If you do not have a Goodreads account, feel free
    to use my personal data for this, which can be found at [https://github.com/tylerjrichards/goodreads_book_demo](https://github.com/tylerjrichards/goodreads_book_demo).
    I have saved my Goodreads data in a file, called `goodreads_history.csv`, in a
    new folder, called `streamlit_goodreads_book`. To make your own folder with the
    appropriate setup, run the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to get started. We really have no idea what this data looks
    like or what is in this dataset, so our first steps are to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Put titles and an explanation at the top of our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to upload their own data with ours as the default if they have
    no data of their own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the first few rows of data to the app so that we can take a look at it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block does all of this. Feel free to change the text so
    that your app has your name, and also add links to a profile of you that people
    can view! As of now, around 10 percent of the traffic to my personal website comes
    from the Streamlit apps I have produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this Streamlit app, we should get an app that looks similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The first five rows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – The first five rows
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get a dataset where each book is a unique row. Additionally,
    we get a ton of data about each book, including the title and author, the average
    rating of the book, your rating of the book, the number of pages, and even if
    you have read the book, are planning to read the book, or are in the middle of
    reading the book. The data looks mostly clean but with some weirdness; for instance,
    the data having both a publication year and an original publication year, and
    the fact that the ISBN (International Standard Book Number) comes in the format
    of *="1400067820"*, which is just odd. Now that we know more about the data at
    hand, we can switch over to try to build some interesting graphs for users.
  prefs: []
  type: TYPE_NORMAL
- en: Making an MVP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at our data, we can start by asking a basic question: what are the
    most interesting questions I can answer with this data? After looking at the data
    and thinking about what information I would want from my Goodreads reading history,
    here are a few questions that I have thought of:'
  prefs: []
  type: TYPE_NORMAL
- en: How many books do I read each year?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long does it take for me to finish a book that I have started?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long are the books that I have read?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How old are the books that I have read?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do I rate books compared to other Goodreads users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can take these questions, figure out how to modify our data to visualize
    them well, and then make the first go at our product by printing out all of the
    graphs.
  prefs: []
  type: TYPE_NORMAL
- en: How many books do I read each year?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the first question about books read per year, we have the `Date Read` column
    with the data presented in the format of *yyyy/mm/dd*. The following code block
    will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert our column into datetime format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the year from the `Date Read` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group the books by this column and make a count for books per year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph this using Plotly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block does this, starting with the datetime conversion.
    It is important to note here that as with all things, I didn''t get this right
    on the very first try. In fact, it took me some time to figure out exactly how
    I needed to manage and convert this data. When you are creating projects of your
    own, do not feel bad if you find that data cleaning and converting are taking
    a long time! Very often, it is the hardest step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block will create the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Year Finished bar plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Year Finished bar plot
  prefs: []
  type: TYPE_NORMAL
- en: We actually made an assumption here, that is, we assumed the year in the `Date
    Read` column represents when we read the book. But what if we start a book in
    the middle of December and finish it on January 2? Or, what if we start a book
    in 2019 but only get a few pages into it, and then pick it back up during 2021?
    We know this will not be a perfect approximation of the number of books read per
    year, but it will be better to express this as the number of books finished per
    year.
  prefs: []
  type: TYPE_NORMAL
- en: How long does it take for me to finish a book that I have started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next question is about the time it takes for us to finish a book once we
    have started it. To answer this, we need to find the difference between two columns:
    the `Date Read` column and the `Date Added` column. Again, this is going to be
    an approximation, as we do not have the date of when the user started reading
    the book but only when they added the book to Goodreads. Given this, our next
    steps include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the two columns into datetime format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the difference between the two columns in days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot this difference in a histogram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code block starts with the conversion, as we have done previously,
    and then moves through our list of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code block can be added to the bottom of your current Streamlit
    app, which, when run, should show a new graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The days to finish graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – The days to finish graph
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the most helpful graph for my data. It looks as though, at some
    point, I added books that I had read in the past to Goodreads, which show up in
    this chart. We also have a set of books that have not been finished yet or are
    on the to-read bookshelf, which exist as null values in this dataset. We can do
    a few things here, such as filtering the dataset to just include books where the
    number of days is positive and filtering the data to only finished books, which
    the following code block does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This change in our code makes the graph significantly better. It makes some
    assumptions, but it also provides a more accurate analysis. The finished graph
    can be viewed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – The improved days to finish graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – The improved days to finish graph
  prefs: []
  type: TYPE_NORMAL
- en: This looks much better! Now, let's move on to the next question.
  prefs: []
  type: TYPE_NORMAL
- en: How long are the books that I have read?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data for this question is already in a fairly good state. We have a single
    column called `Number of Pages`, which, you guessed it, has the number of pages
    in each book. We just need to pass that column to another histogram, and we will
    be good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce something similar to the following screenshot, showing
    a histogram of book length as measured in pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The Number of Pages histogram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The Number of Pages histogram
  prefs: []
  type: TYPE_NORMAL
- en: This makes sense to me; a ton of books are in the 300–400 page range, with a
    few giant books that have 1,000+ pages. Now, let's move on to the age of these
    books!
  prefs: []
  type: TYPE_NORMAL
- en: How old are the books that I have read?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next graph should be straightforward. How do we figure out how old the
    books that we read are? Are our tendencies to go for the newest set of books that
    are published or to shoot toward reading classics? There are two columns that
    we can get this information from, the publication year and the original publication
    year. There is very little documentation on this dataset, but I think we can safely
    assume that the original publication year is what we are looking for, and the
    publication year exists for when a publisher republishes a book. The following
    code block checks this assumption by printing out all the books where the original
    publication year is later than the publication year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, the app should return zero books with the original publication
    year as greater than the year published. Now that we have checked this assumption,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Group the books by the original publication year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot this on a bar chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code block takes two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this app, we should get the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Book Age Plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Book Age Plot
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, this graph does not appear to be incredibly useful, as there
    are quite a few books written so far back in history (for example, Plato''s writings
    in -375 BCE) that the entire graph is hard to read. However, Plotly is interactive
    by default, and it allows us to zoom into sections of history that we care about
    more than others. For example, the following screenshot shows us what happens
    when we zoom into the period of 1850 to the present, where most of the books that
    I''ve read happen to be in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Zooming in on Year Published'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Zooming in on Year Published
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a much better graph! There are a couple of options going forward. We
    can start with the graph that is not as useful and tell users to zoom in, we can
    filter our dataset for only younger books (which would defeat the main purpose
    of the graph), or we can set a default zoom state for the graph and also alert
    users at the bottom that they can zoom in as they''d like. I think the third option
    is the best one. The following code implements this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code, we should get our final plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – A default zoom with helpful text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – A default zoom with helpful text
  prefs: []
  type: TYPE_NORMAL
- en: Four questions down, we have one to go!
  prefs: []
  type: TYPE_NORMAL
- en: How do I rate books compared to other Goodreads users?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this final question, we really need two separate graphs. First, we need
    to plot how we have rated the books. Then, second, we need to plot how other users
    have rated the books that we also rated. This isn''t a perfect analysis, because
    Goodreads just shows us the average rating of the books – we have not read the
    distribution. For example, if we had read *The Snowball*, a biography of Warren
    Buffett, and rated it 3 stars, and half of Goodreads'' readers rated it a 1 star
    while the other half rated it 5 stars, we would have rated it exactly the same
    as the average rating, but we would not have rated it the same as any individual
    rater! However, we do what we can with the data we have. So, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Filter the books according to the ones we have rated (and, therefore, read).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a histogram of the average rating per book for our first graph.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create another histogram for your own ratings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This next code block does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, the first graph with the user rating
    distribution looks great. It looks as though I mainly rate books either 4 or 5
    stars, which are, overall, pretty lenient ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The User Rating distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – The User Rating distribution
  prefs: []
  type: TYPE_NORMAL
- en: 'When we also look at the second graph, we see a fairly clean distribution.
    However, we run into the problem that we have addressed before – all the rating
    averages are more tightly bundled than the user ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Average Goodreads Ratings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Average Goodreads Ratings
  prefs: []
  type: TYPE_NORMAL
- en: 'We can always set the *x*-axis range to 1–5 for both graphs, but this will
    not help our actual problem. Instead, we can leave both of the graphs but also
    calculate whether, on average, we rate books higher or lower than the Goodreads
    average. The following code block will calculate this and add it underneath the
    average Goodreads rating graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block makes our average and creates a dynamic string that will either
    say that the Goodreads user rates books higher or lower than the average Goodreads
    user. The result for my data is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Adding an average difference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Adding an average difference
  prefs: []
  type: TYPE_NORMAL
- en: 'This is better and completes our MVP. Our app is in a decent state, and the
    difficult manipulation and visualization steps are pretty much complete. However,
    our app certainly doesn''t look great and is just a bunch of graphs that appear
    in a row. This might be good for an MVP, but we need to add some styling to really
    improve our state. That leads us to our next section: iterating on this idea to
    make it even better.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterative improvement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been almost purely in production mode with this app. Iterative
    improvement is all about editing the work we have already done and organizing
    it in a way that makes the app more usable and, frankly, nicer to look at. There
    are a few improvements that we can shoot for here:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautification via animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organization using columns and width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Narrative building through text and additional statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by using animations to make our apps a bit prettier!
  prefs: []
  type: TYPE_NORMAL
- en: Beautification via animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074), *Exploring*
    *Streamlit Components*, we explored the use of various Streamlit components: one
    of these was a component called `streamlit-lottie`, which gives us the ability
    to add animation to our Streamlit applications. We can improve our current app
    by adding an animation to the top of our current Streamlit app using the following
    code. If you want to learn more about Streamlit components, please head back over
    to [*Chapter 7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074)*, Exploring Streamlit
    Components*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This Lottie file is an animation of a book flipping its pages, as shown in
    the following screenshot. These animations are always a nice touch for longer
    Streamlit apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Goodreads animation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – Goodreads animation
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added our animation, we can move on to how to organize our
    app a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: Organization using columns and width
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, our app does not look very good with each graph appearing
    one after the other. Another improvement we can make is to allow our app to be
    in wide, rather than narrow, format, and then put our apps side by side in each
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, at the top of our app, we need the first Streamlit call to be the
    one that sets the configuration of our Streamlit app to wide rather than narrow,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set our Streamlit to our wide format. So far, in our app, we have
    called each graph a unique name (such as `fig_year_finished`) to make this next
    step easier. We can now remove all of our `st.plotly_chart()` calls, and create
    a set of two columns and three rows where we can place our six graphs. The following
    code creates each of these. We name each space first, and then fill them with
    one of our graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will create the app that appears in the following screenshot, which
    has been cropped to the top two graphs for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – The wide format example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – The wide format example
  prefs: []
  type: TYPE_NORMAL
- en: This makes our graphs much easier to read and easily allows us to compare them.
    We have intentionally paired our two graphs according to ratings, and the rest
    also appear to fit quite well next to each other. Our final step is to add a bit
    more text to make the entire app easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Narrative building through text and additional statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These graphs are already quite helpful for understanding how the user reads,
    but we can bolster the readability of this app by adding some useful statistics
    and text underneath each graph and at the beginning of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right above where we start to define our columns, we can add an initial section
    that shows the unique number of books that we have read, the unique authors, and
    our favorite author, all in one. We can use these basic statistics to kick off
    the app and tell the user that each graph is also interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add four new text sections below the four graphs that do not
    have any annotated text as of yet. For the first three graphs, the following code
    will add some statistics and text to each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'One example graph here is the histogram on book length. The preceding code
    adds an average length and some text below the graph, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The average number of pages text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_10_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – The average number of pages text
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final set of graphs, we can add text to the ones without context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This completes our section on adding text and additional statistics! Now, our
    final step is to deploy this on Streamlit Sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting and promotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our final step is to host this app on Streamlit Sharing. To do this, we need
    to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a GitHub repository for this work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `requirements.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use 1-click deployment on Streamlit Sharing to deploy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already covered this extensively in [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, so give it a shot now without instruction.
    If you get stuck, head over to [*Chapter 5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056),
    *Deploying Streamlit with Streamlit Sharing*, to find the exact instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What a fun chapter! We have learned so much here – from how to come up with
    data science projects of our own to how to create initial MVPs, to the iterative
    improvement of our apps. We have done this all through the lens of our Goodreads
    dataset, and we have taken this app from just an idea to a fully functioning app
    hosted on Streamlit Sharing. I look forward to seeing all the different types
    of Streamlit apps that you create. Please create something fun and send it to
    me on Twitter at *@tylerjrichards*. In the next chapter, we will focus on learning
    how to use Streamlit at work with the new Streamlit product, *Streamlit for Teams*.
    See you there!
  prefs: []
  type: TYPE_NORMAL
