- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Visualizations for the Identification of Unexpected Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We dipped our toes in the water on visualizations in several recipes in the
    previous chapter. We used histograms and QQ plots to examine the distribution
    of a single variable, and scatter plots to view how two variables are related.
    But we were just scratching the surface of the rich visualization tools available
    in the Matplotlib and Seaborn libraries. Getting comfortable with these tools,
    and their seemingly inexhaustible capabilities, can help us uncover patterns and
    oddities that are not obvious when we run the standard battery of descriptives.
  prefs: []
  type: TYPE_NORMAL
- en: Boxplots, for example, are a great tool for visualizing values outside of a
    certain range. These can be extended with grouped boxplots or violin plots that
    allow us to compare distributions across subsets of data. We can also do much
    more with scatter plots than we did in the last chapter, including getting some
    sense of multivariate relationships. Histograms, too, can sometimes offer additional
    insight if we display several histograms on one plot or create a stacked histogram.
    We explore all of these capabilities in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the recipes in this chapter demonstrate the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using histograms to examine the distribution of continuous variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using boxplots to identify outliers for continuous variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using grouped boxplots to uncover unexpected values in a particular group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining both distribution shape and outliers with violin plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using scatter plots to view bivariate relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using line plots to examine trends in continuous variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a heat map based on a correlation matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need Pandas, Numpy, Matplotlib, and Seaborn to complete the recipes
    in this chapter. I used `pandas 2.1.4`, but the code will run on `pandas 1.5.3`
    or later.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this chapter can be downloaded from the book’s GitHub repository,
    `https://github.com/PacktPublishing/Python-Data-Cleaning-Cookbook-Second-Edition`.
  prefs: []
  type: TYPE_NORMAL
- en: Using histograms to examine the distribution of continuous variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The go-to visualization tool for statisticians trying to understand how single
    variables are distributed is the histogram. Histograms plot a continuous variable
    on the *x* axis in bins determined by the researcher, and the frequency of occurrence
    on the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms provide a clear and meaningful illustration of the shape of a distribution,
    including central tendency, skewness (symmetry), excess kurtosis (relatively fat
    tails), and spread. This matters for statistical testing, as many tests make assumptions
    about a variable’s distribution. Moreover, our expectation of what data values
    to expect should be guided by our understanding of the distribution’s shape. For
    example, a value at the 90^(th) percentile has very different implications when
    it comes from a normal distribution rather than from a uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first tasks I ask introductory statistics students to do is to construct
    a histogram manually from a small sample. We do boxplots in the following class.
    Together, histograms and boxplots provide a solid foundation for subsequent analysis.
    In my data science work, I try to remember to construct histograms and boxplots
    on all continuous variables of interest shortly after the initial importing and
    cleaning of data. We create histograms in this recipe, and boxplots in the following
    two recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the `Matplotlib` library to generate histograms. Some tasks can
    be done quickly and straightforwardly in Matplotlib. Histograms are one of those
    tasks. We will switch between Matplotlib and Seaborn (which is built on Matplotlib)
    in this chapter depending on which tool gets us to the required graphic more easily.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the `statsmodels` library. You can install Matplotlib and statsmodels
    with pip using `pip install matplotlib` and `pip install statsmodels`.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with data covering Earth surface temperatures and COVID-19 cases
    in this recipe. The surface temperature DataFrame has one row per weather station.
    The COVID-19 DataFrame has one row per country with total cases and demographic
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The surface temperature DataFrame has the average temperature reading (in °C)
    in 2023 from over 12,000 stations across the world, though a majority of the stations
    are in the United States. The raw data was retrieved from the Global Historical
    Climatology Network integrated database. It is made available for public use by
    the United States National Oceanic and Atmospheric Administration at [https://www.ncei.noaa.gov/products/land-based-station/global-historical-climatology-network-monthly](https://www.ncei.noaa.gov/products/land-based-station/global-historical-climatology-network-monthly).
  prefs: []
  type: TYPE_NORMAL
- en: '*Our World in Data* provides COVID data for public use at [https://ourworldindata.org/covid-cases](https://ourworldindata.org/covid-cases).
    The data used in this recipe was downloaded on March 3, 2024.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We take a close look at the distribution of surface temperatures by weather
    station in 2023 and total COVID-19 cases per million in population for each country.
    We start with a few descriptive statistics before doing a QQ plot, histograms,
    and stacked histograms:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `pandas`, `matplotlib`, and `statsmodels` libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, load the data on surface temperatures and COVID-19 cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Show some of the station temperature rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `latabs` column is the value of latitude without the north or south indicators;
    so, Cairo, Egypt at approximately 30 degrees north, and Porto Alegre, Brazil at
    about 30 degrees south have the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Show some descriptive statistics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, look at skewness and kurtosis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do a histogram of average temperatures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, draw a line at the overall mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Histogram of average temperatures across weather stations in 2019'
  prefs: []
  type: TYPE_NORMAL
- en: Run a QQ plot to examine where the distribution deviates from a normal distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that much of the distribution of temperatures falls along the red line
    (all dots would fall on the red line if the distribution were perfectly normal,
    but the tails fall off dramatically from normal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following QQ plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Plot of average temperature by station compared with a normal distribution'
  prefs: []
  type: TYPE_NORMAL
- en: Show the skewness and kurtosis for total COVID-19 cases per million.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is from the COVID-19 DataFrame, which has one row for each country:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Do a stacked histogram of the COVID-19 case data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select data from four of the regions. (Stacked histograms can get messy with
    any more categories than that.) Define a `getcases` function that returns a Series
    for `total_cases_pm` for the countries of a region. Pass those Series to the `hist`
    method (`[getcases(k) for k in showregions]`) to create the stacked histogram.
    Notice how much unlike the other regions Western Europe is, accounting for almost
    all countries with cases per million above 500,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following stacked histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Stacked histogram of the number of countries per region at different
    levels of cases per million'
  prefs: []
  type: TYPE_NORMAL
- en: Show multiple histograms on one figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This allows different *x* and *y* axis values. We need to loop through each
    axis and select a different region from `showregions` for each subplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following histograms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Histograms of numbers of countries by region at different levels
    of cases per million'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding steps demonstrated how to visualize the distribution of a continuous
    variable using histograms and QQ plots.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Step 4* shows how easy it is to display a histogram. This can be done by passing
    a Series to the `hist` method of Matplotlib’s `pyplot` module. (We use an alias
    of `plt` for Matplotlib.) We could have also passed any `ndarray`, or even a list
    of data Series.'
  prefs: []
  type: TYPE_NORMAL
- en: We also get great access to the attributes of the figure and its axes. We can
    set the labels for each axis, as well as the tick marks and tick labels. We can
    also specify the content and look and feel of the legend. We will be taking advantage
    of this functionality often in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We pass multiple Series to the `hist` method in *Step 7* to produce the stacked
    histogram. Each Series is the `total_cases_pm` (cases per million of the population)
    value for the countries in a region. To get the Series for each region, we call
    the `getcases` function for each item in `showregions`. We choose colors for each
    Series rather than allowing them to be applied automatically. We also use the
    `showregions` list to select labels for the legend.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 8*, we start by indicating that we want four subplots, in two rows
    and two columns. That is what we get with `plt.subplots(2, 2)`, which returns
    both a figure and the four axes. We loop through the axes with `for j, ax in enumerate(axes)`.
    Within each loop, we select a different region for the histogram from `showregions`.
    Within each axis, we loop through the tick labels and change the rotation. We
    also adjust the start of the subplots to make enough room for the figure title.
    Note that we need to use `suptitle` to add a title in this case. Using `title`
    would add the title to a subplot.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The land temperature data is not quite normally distributed, as the histograms
    and the skew and kurtosis measures in *Steps 3-5* show. It is skewed to the left
    (skew of `-0.39`) and has tails that are close to normal (kurtosis of 2.79, compared
    with 3). Although there are some extreme values, there are not that many of them
    relative to the overall size of the dataset. While it is not perfectly bell-shaped,
    the land temperature DataFrame is a fair bit easier to deal with than the COVID-19
    case data.
  prefs: []
  type: TYPE_NORMAL
- en: The skew and kurtosis of the COVID-19 `cases per million` variable show that
    it is some distance from normal. The skew of 0.83 and kurtosis of -0.43 indicate
    a somewhat positive skew and much skinnier tails than with a normal distribution.
    This is also reflected in the histograms, even when we look at the numbers by
    region. There are a number of countries at very low levels of cases per million
    in most regions, and just a few countries with high levels of cases. The *Using
    grouped boxplots to uncover unexpected values in a particular group* recipe in
    this chapter shows that there are outliers in almost every region.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you work through all of the recipes in this chapter, and you are relatively
    new to Matplotlib and Seaborn, you will find those libraries either usefully flexible
    or confusingly flexible. It is difficult to even pick one strategy and stick with
    it because you might need to set up your figure and axes in a particular way to
    get the visualization you want. It is helpful to keep two things in mind when
    working through these recipes: first, you will generally need to create a figure
    and one or more subplots; and second, the main plotting functions work similarly
    regardless, so `plt.hist` and `ax.hist` will both often work.'
  prefs: []
  type: TYPE_NORMAL
- en: Using boxplots to identify outliers for continuous variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boxplots are essentially a graphical representation of our work in the *Identifying
    outliers with one variable* recipe in *Chapter 4*, *Identifying Outliers in Subsets
    of Data*. There, we used the concept of **interquartile range** (**IQR**)—the
    distance between the value at the first quartile and the value at the third quartile—to
    determine outliers. Any value greater than (`1.5 * IQR`) + the third quartile
    value, or less than the first quartile value – (`1.5 * IQR`), was considered an
    outlier. That is precisely what is revealed in a boxplot.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work with cumulative data on COVID-19 cases and deaths by country, and
    the **National Longitudinal Surveys** (**NLS**) data. You will need the Matplotlib
    library to run the code on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use boxplots to show the shape and spread of **Scholastic Assessment Test**
    (**SAT**) scores, weeks worked, and COVID-19 cases and deaths:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `pandas` and `matplotlib` libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, load the NLS and COVID-19 data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Do a boxplot of SAT verbal scores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Produce some descriptives first. The `boxplot` method produces a rectangle
    that represents the IQR, the values between the first and third quartile. The
    whiskers go from that rectangle to 1.5 times the IQR. Any values above or below
    the whiskers (what we have labeled the outlier threshold) are considered outliers
    (we use `annotate` to point to the first and third quartile points, the median,
    and to the outlier thresholds):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following boxplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Boxplot of SAT verbal scores with labels for interquartile range
    and outliers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, show some descriptives on weeks worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do boxplots of weeks worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Boxplots of two variables side by side'
  prefs: []
  type: TYPE_NORMAL
- en: Show some descriptives for the COVID-19 data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a list of labels (`totvarslabels`) for columns to use in a later step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a boxplot of cases and deaths per million:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Boxplots of two variables side by side'
  prefs: []
  type: TYPE_NORMAL
- en: Show boxplots as separate subplots on one figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is hard to view multiple boxplots on one figure when the variable values
    are very different, as is true for COVID-19 cases and deaths. Fortunately, Matplotlib
    allows us to create multiple subplots on each figure, each of which can use different
    *x* and *y* axes. We can also present the data in thousands to improve readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Boxplots with different y axes'
  prefs: []
  type: TYPE_NORMAL
- en: Boxplots are a relatively straightforward but exceedingly useful way to view
    how variables are distributed. They make it easy to visualize spread, central
    tendency, and outliers, all in one graphic.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is fairly easy to create a boxplot with Matplotlib, as *Step 2* shows. Passing
    a series to pyplot is all that is required (we use the `plt` alias). We call pyplot’s
    `show` method to show the figure. This step also demonstrates how to use `annotate`
    to add text and symbols to your figure. We show multiple boxplots in *Step 4*
    by passing multiple series to pyplot.
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to show multiple boxplots in a single figure when the scales
    are very different, as is the case with the COVID-19 outcome data (cases, deaths,
    cases per million, and deaths per million). *Step 7* shows one way to deal with
    that. We can create several subplots on one plot. We start by indicating that
    we want four subplots, in two columns and two rows. That is what we get with `plt.subplots(2,
    2)`, which returns both a figure and the four axes. We can then loop through the
    axes, calling `boxplot` on each one. Nifty!
  prefs: []
  type: TYPE_NORMAL
- en: However, it is still hard to see the IQR for cases and deaths because of some
    of the extreme values. In the next recipe, we remove some of the extreme values
    to give us a better visualization of the remaining data.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The boxplot of SAT verbal scores in *Step 2* suggests a relatively normal distribution.
    The median is close to the center of the IQR. This is not surprising given that
    the descriptives we ran show that the mean and median have the same value. There
    is, however, substantially more room for outliers at the lower end than at the
    upper end. (Indeed, the very low SAT verbal scores seem implausible and should
    be checked.)
  prefs: []
  type: TYPE_NORMAL
- en: The boxplots of weeks worked in 2020 and 2021 in *Step 4* show variables that
    are distributed much differently than SAT scores. The medians are much higher
    than the mean. This suggests a negative skew. Also, notice that there are no whiskers
    or outliers at the upper end of the distribution for the 2020 value as the median
    is at, or near, the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of these boxplots suggest that the data we are examining is not normally
    distributed. The *Identifying outliers with one variable* recipe in *Chapter 4*
    covers some normal distribution tests. It also shows how to take a closer look
    at the values outside of the outlier thresholds: the circles in the boxplots.'
  prefs: []
  type: TYPE_NORMAL
- en: Using grouped boxplots to uncover unexpected values in a particular group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in the previous recipe that boxplots are a great tool for examining the
    distribution of continuous variables. They can also be useful when we want to
    see if those variables are distributed differently for parts of our dataset, such
    as salaries for different age groups, number of children by marital status, or
    litter sizes of different mammal species. Grouped boxplots are a handy and intuitive
    way to view differences in variable distribution by categories in our data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work with the NLS and the COVID-19 case data. You will need Matplotlib
    and Seaborn installed on your computer to run the code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We generate descriptive statistics of weeks worked by highest degree earned.
    We then use grouped boxplots to visualize the spread of the weeks worked distribution
    by degree, and of COVID-19 cases by region:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `pandas`, `matplotlib`, and `seaborn` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: View the median, and first and third quartile values for weeks worked for each
    degree attainment level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, define a function that returns those values as a Series, then use `apply`
    to call it for each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Do a boxplot of weeks worked by highest degree earned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Seaborn for these boxplots. First, create a subplot and name it `myplt`.
    This makes it easier to access subplot attributes later. Use the `order` parameter
    of `boxplot` to order by highest degree earned. Notice that there are no outliers
    or whiskers at the lower end for individuals with no degree ever received. This
    is because the IQR for those individuals covers almost all of the range of values.
    The value at the 25^(th) percentile is 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Boxplots of weeks worked with IQR and outliers by highest degree'
  prefs: []
  type: TYPE_NORMAL
- en: View the minimum, maximum, median, and first- and third-quartile values for
    total cases per million by region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `gettots` function defined in *Step 2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do boxplots of cases per million by region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Flip the axes since there are a large number of regions. Also, do a swarm plot
    to give some sense of the number of countries by region. The swarm plot displays
    a dot for each country in each region. Some of the IQRs are hard to see because
    of the extreme values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Boxplots and swarm plots of cases per million by region, with
    IQR and outliers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Show the highest values for cases per million:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Redo the boxplots without the extreme values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following boxplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Boxplots of cases per million by region without the extreme values'
  prefs: []
  type: TYPE_NORMAL
- en: These grouped boxplots reveal how much the distribution of cases, adjusted by
    population, varies by region.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use Seaborn for the figures we create in this recipe. We could have also
    used Matplotlib. Seaborn is actually built on top of Matplotlib, extending it
    in some areas, and making some things easier. It sometimes produces more aesthetically
    pleasing figures with the default settings than Matplotlib does.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good idea to have some descriptives in front of us before creating
    figures with multiple boxplots. In *Step* *2*, we get the first and third quartile
    values, and the median, for each degree attainment level. We do this by first
    creating a function called `gettots`, which returns a series with those values.
    We apply `gettots` to each group in the DataFrame with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `groupby` method creates a DataFrame with grouping information, which is
    passed to the `apply` function. `gettots` then calculates summary values for each
    group. `unstack` reshapes the returned rows, from multiple rows per group (one
    for each summary statistic) to one row per group, with columns for each summary
    statistic.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step* *3*, we generate a boxplot for each degree attainment level. We do
    not normally need to name the subplot object we create when we use Seaborn’s `boxplot`
    method. We do so in this step, naming it `myplt`, so that we can easily change
    attributes—such as tick labels—later. We rotate the labels on the *x* axis using
    `set_xticklabels` so that the labels do not run into each other.
  prefs: []
  type: TYPE_NORMAL
- en: We flip the axes for the boxplots in *Step 5* since there are more group levels
    (regions) than there are ticks for the continuous variable, cases per million.
    We do that by making `total_cases_pm` the value for the first argument, rather
    than the second. We also do a swarm plot to give some sense of the number of observations
    (countries) in each region.
  prefs: []
  type: TYPE_NORMAL
- en: Extreme values can sometimes make it difficult to view a boxplot. Boxplots show
    both the outliers and the IQR, but the IQR rectangle will be so small that it
    is not viewable when outliers are several times the third or first quartile value.
    In *Step 7*, we remove all values of `total_cases_pm` greater than or equal to
    512,388\. This improves the presentation of some details on the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The boxplots of weeks worked by educational attainment in *Step* *3* reveal
    high variation in weeks worked, something that is not obvious in univariate analysis.
    The lower the educational attainment level, the greater the spread in weeks worked.
    There is substantial variability in weeks worked in 2021 for individuals with
    less than a high-school degree, and very little variability for individuals with
    college degrees.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite relevant, of course, to our understanding of what an outlier is
    in terms of weeks worked. For example, someone with a college degree who worked
    20 weeks is an outlier, but they would not be an outlier if they had less than
    a high-school diploma.
  prefs: []
  type: TYPE_NORMAL
- en: The *Cases Per Million* boxplots also invite us to think more flexibly about
    what an outlier is. For example, none of the outliers for cases per million in
    North Africa would be a high outlier for the dataset as a whole. The maximum value
    for North Africa is actually lower than the first quartile value for Western Europe.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things I notice when looking at a boxplot is where the median
    is in the IQR. When the median is not at all close to the center, I know I am
    not dealing with a normally distributed variable. It also gives me a good sense
    of the direction of the skew. If it is near the bottom of the IQR, meaning that
    the median is much closer to the first quartile than the third, then there is
    a positive skew. Compare the boxplot for Eastern Europe to that of Western Europe.
    A large number of low values and a few high values bring the median close to the
    first quartile value for Eastern Europe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We work much more with `groupby` in *Chapter 9*, *Fixing Messy Data When Aggregating*.
    We work more with `stack` and `unstack` in *Chapter 11*, *Tidying and Reshaping
    Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Examining both distribution shape and outliers with violin plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Violin plots combine histograms and boxplots in one plot. They show the IQR,
    median, and whiskers, as well as the frequency of observations at all ranges of
    values. It is hard to visualize how that is possible without seeing an actual
    violin plot. We generate a few violin plots on the same data we used for boxplots
    in the previous recipe, to make it easier to grasp how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work with the NLS data. You need Matplotlib and Seaborn installed on
    your computer to run the code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We do violin plots to view both the spread and shape of the distribution on
    the same graphic. We then do violin plots by groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load `pandas`, `matplotlib`, and `seaborn`, and the NLS data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do a violin plot of the SAT verbal score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following violin plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Violin plot of SAT verbal score with labels for IQR and outlier
    threshold'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get some descriptives for weeks worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Show weeks worked for 2020 and 2021.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use a more object-oriented approach to make it easier to access some axes’
    attributes. Notice that the `weeksworked` distributions are bimodal, with bulges
    near the top and the bottom of the distribution. Also, note the very different
    IQR for 2020 and 2021:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following violin plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Violin plots showing the spread and shape of the distribution
    for two variables side by side'
  prefs: []
  type: TYPE_NORMAL
- en: Do a violin plot of wage income by gender and marital status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, create a collapsed marital status column. Specify gender for the *x*
    axis, salary for the *y* axis, and a new collapsed marital status column for `hue`.
    The `hue` parameter is used for grouping, which will be added to any grouping
    already used for the *x* axis. We also indicate `scale="count"` to generate violin
    plots sized according to the number of observations in each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following violin plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Violin plots showing the spread and shape of the distribution
    across two different groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do violin plots of weeks worked by highest degree attained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following violin plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Violin plots showing the spread and shape of the distribution
    by group'
  prefs: []
  type: TYPE_NORMAL
- en: These steps show just how much violin plots can tell us about how continuous
    variables in our DataFrame are distributed, and how that might vary by group.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to boxplots, violin plots show the median, the first and third quartiles,
    and the whiskers. They also show the relative frequency of variable values. (When
    the violin plot is displayed vertically, the relative frequency is the width at
    a given point.) The violin plot produced in *Step 2*, and the associated annotations,
    provide a good illustration. We can tell from the violin plot that the distribution
    of SAT verbal scores is not dramatically different from normal, other than the
    extreme values at the lower end. The greatest bulge (greatest width) is at the
    median, declining fairly symmetrically from there. The median is relatively equidistant
    from the first and third quartiles.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a violin plot in Seaborn by passing one or more data Series to
    the `violinplot` method. We can also pass a whole DataFrame of one or more columns.
    We do that in *Step 4* because we want to plot more than one continuous variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We sometimes need to experiment with the legend a bit to get it to be both
    informative and unobtrusive. In *Step 5*, we used the following command to remove
    the legend title (since it is clear from the values), locate the legend in the
    best place on the figure, and make the box transparent (`framealpha=0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you get the hang of violin plots, you will appreciate the enormous amount
    of information they make available on one figure. We get a sense of the shape
    of the distribution, its central tendency, and its spread. We can also easily
    show that information for different subsets of our data.
  prefs: []
  type: TYPE_NORMAL
- en: The distribution of weeks worked in 2020 is different enough from weeks worked
    in 2021 to give the careful analyst pause. The IQR is quite different—31 for 2020
    (21 to 52) and 15 for 2021 (35 to 50). (The weeks worked in 2020 distribution
    was likely impacted by the pandemic.)
  prefs: []
  type: TYPE_NORMAL
- en: An unusual fact about the distribution of wage income is revealed when examining
    the violin plots produced in *Step 5*. There is a bunching-up of incomes at the
    top of the distribution for married males, and somewhat for married females. That
    is quite unusual for a wage income distribution. As it turns out, it looks like
    there is a ceiling on wage income of $380,288\. This is something that we definitely
    want to take into account in future analyses that include wage income.
  prefs: []
  type: TYPE_NORMAL
- en: The income distributions have a similar shape across gender and marital status,
    with bulges slightly below the median and extended positive tails. The IQRs have
    relatively similar lengths. However, the distribution for married males is noticeably
    higher (or to the right, depending on chosen orientation) than that for the other
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: The violin plots of weeks worked by degree attained show very different distributions
    by group, as we also discovered in the boxplots of the same data in the previous
    recipe. What is more clear here, though, is the bimodal nature of the distribution
    at lower levels of education. There is a bunching at low levels of weeks worked
    for individuals without college degrees. Individuals without high-school diplomas
    were nearly as likely to work 5 or fewer weeks in 2021 as they were to work 50
    or more weeks.
  prefs: []
  type: TYPE_NORMAL
- en: We used Seaborn exclusively to produce violin plots in this recipe. Violin plots
    can also be produced with Matplotlib. However, the default graphics in Matplotlib
    for violin plots look very different from those for Seaborn.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might be helpful to compare the violin plots in this recipe to histograms,
    boxplots, and grouped boxplots in the previous recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using scatter plots to view bivariate relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My sense is that there are few plots that data analysts rely more on than scatter
    plots, with the possible exception of histograms. We are all very used to looking
    at relationships that can be illustrated in two dimensions. Scatter plots capture
    important real-world phenomena (the relationship between variables) and are quite
    intuitive for most people. This makes them a valuable addition to our visualization
    toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need Matplotlib and Seaborn for this recipe. We will be working with
    the `landtemps` dataset, which provides the average temperature in 2023 for 12,137
    weather stations across the world.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We level up our scatter plot skills from the previous chapter and visualize
    more complicated relationships. We display the relationship between average temperature,
    latitude, and elevation by showing multiple scatter plots on one chart, creating
    3D scatter plots, and showing multiple regression lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load `pandas`, `numpy`, `matplotlib` and `seaborn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run a scatter plot of latitude (`latabs`) by average temperature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Scatter plot of latitude by average temperature'
  prefs: []
  type: TYPE_NORMAL
- en: Show the high elevation points in red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create low and high elevation DataFrames. Notice that the high elevation points
    are generally lower (that is, cooler) on the figure at each latitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Scatter plot of latitude by average temperature and elevation'
  prefs: []
  type: TYPE_NORMAL
- en: View a three-dimensional plot of temperature, latitude, and elevation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It looks like there is a somewhat steeper decline in temperature, with increases
    in latitude for high-elevation stations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: 3D scatter plot of latitude and elevation by average temperature'
  prefs: []
  type: TYPE_NORMAL
- en: Show a regression line of latitude on temperature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `regplot` to get a regression line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Scatter plot of latitude by average temperature with regression
    line'
  prefs: []
  type: TYPE_NORMAL
- en: Show separate regression lines for low- and high-elevation stations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use `lmplot` this time instead of `regplot`. The two methods have similar
    functionality. Unsurprisingly, high-elevation stations appear to have both lower
    intercepts (where the line crosses the *y* axis) and steeper negative slopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Scatter plot of latitude by temperature with separate regression
    lines for elevation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Show some stations above the low- and high-elevation regression lines. We can
    use the `high` and `low` DataFrames we created in *Step 3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Scatter plots are a great way to view the relationship between two variables.
    These steps also show how we can display that relationship for different subsets
    of our data.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can run a scatter plot by just providing column names for `x` and `y` and
    a DataFrame. Nothing more is required. We get the same access to the attributes
    of the figure and its axes as we get when we run histograms and boxplots—titles,
    axis labels, tick marks and labels, and so on. Note that to access attributes
    such as labels on an axis (rather than on the figure), we use `set_xlabels` or
    `set_ylabels`, not `xlabels` or `ylabels`.
  prefs: []
  type: TYPE_NORMAL
- en: 3D plots are a little more complicated. First we set the projection of our axes
    to `3d`—`plt.axes(projection='3d')`, as we did in *Step 4*. We can then use the
    `scatter3D` method for each subplot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since scatter plots are designed to illustrate the relationship between a regressor
    (the `x` variable) and a dependent variable, it is quite helpful to see a least-squares
    regression line on the scatter plot. Seaborn provides two methods for doing that:
    `regplot` and `lmplot`. I use `regplot` typically, since it is less resource-intensive.
    But sometimes, I need the features of `lmplot`. We use `lmplot` and its `hue`
    attribute in *Step 6* to generate separate regression lines for each elevation
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 7*, we view some of the outliers: those stations with temperatures
    much higher than the regression line for their group. We would want to investigate
    the data for the `LAJES_AB` station in Portugal and the `YEREVAN` station in Armenia
    (`(high.latabs>38) & (high.avgtemp>=18)`). The average temperatures are higher
    than would be predicted at the given latitude and elevation level.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We see the expected relationship between latitude and average temperatures.
    Temperatures fall as latitude increases. But elevation is another important factor.
    Being able to visualize all three variables at once helps us identify outliers
    more easily. Of course, there are additional factors that matter for temperatures,
    such as warm ocean currents. That data is not in this dataset, unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: Scatter plots are great for visualizing the relationship between two continuous
    variables. With some tweaking, Matplotlib’s and Seaborn’s scatter plot tools can
    also provide some sense of relationships between three variables—by adding a third
    dimension, via the creative use of colors (when the third dimension is categorical),
    or by changing the size of the dots (the *Using linear regression to identify
    data points with high influence* recipe in *Chapter 4*, *Identifying Outliers
    in Subsets of Data*, provides an example of that).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a chapter on visualization, and identifying unexpected values through
    visualizations. But these figures also scream out for the kind of multivariate
    analyses we did in *Chapter 4*, *Identifying Outliers in Subsets of Data*. In
    particular, linear regression analysis, and a close look at the residuals, would
    be useful for identifying outliers.
  prefs: []
  type: TYPE_NORMAL
- en: Using line plots to examine trends in continuous variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical way to visualize values for a continuous variable over regular intervals
    of time is through a line plot, though sometimes bar charts are used for small
    numbers of intervals. We will use line plots in this recipe to display variable
    trends and examine sudden deviations in trends and differences in values over
    time by groups.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work with daily COVID-19 case data in this recipe. In previous recipes,
    we have used totals by country. The daily data provides us with the number of
    new cases and new deaths each day by country, in addition to the same demographic
    variables we used in other recipes. You will need Matplotlib installed to run
    the code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use line plots to visualize trends in daily COVID-19 cases and deaths. We
    create line plots by region, and stacked plots to get a better sense of how much
    one country can drive the number of cases for a whole region:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `pandas`, `matplotlib`, and the `matplotlib.dates` and date-formatting
    utilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View a couple of rows of the COVID-19 daily data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Calculate new cases and deaths by day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select dates between July 1, 2023, and March 3, 2024, and then use `groupby`
    to summarize cases and deaths across all countries for each day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Show line plots for new cases and new deaths by day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Show the cases and deaths on different subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following line plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: Daily trend lines of worldwide COVID-19 cases and deaths'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate new cases and deaths by day and region:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Show line plots of new cases by selected regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop through the regions in `showregions`. Do a line plot of the total `new_cases`
    by day for each region. Use the `gca` method to get the *x* axis and set the date
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following line plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_22.png)Figure 5.22: Daily trend lines of COVID-19 cases by
    region'
  prefs: []
  type: TYPE_NORMAL
- en: Use a stacked plot to examine the trend in a region more closely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See if one country (Brazil) in South America is driving the trend line. Create
    a DataFrame (`sa`) for `new_cases` by day for South America. Add a Series for
    `new_cases` in Brazil to the `sa` DataFrame. Then, create a new Series in the
    `sa` DataFrame for South America cases minus Brazil cases (`sacasesnobr`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following stacked plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_23.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Stacked daily trends of cases in Brazil and the rest of South
    America
  prefs: []
  type: TYPE_NORMAL
- en: These steps show how to use line plots to examine trends in a variable over
    time, and how to display trends for different groups on one figure.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to do some manipulation of the daily COVID-19 data before we do the
    line charts. We use `groupby` in *Step 3* to summarize new cases and deaths over
    all countries for each day. We use `groupby` in *Step 5* to summarize cases and
    deaths for each region and day.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step* *4*, we set up our first subplot with `plt.subplot(2,1,1)`. That will
    give us a figure with two rows and one column. The `1` for the third argument
    indicates that this subplot will be the first, or top, subplot. We can pass a
    data Series for date and for the values for the *y* axis. So far, this is pretty
    much what we have done with the `hist`, `scatterplot`, `boxplot`, and `violinplot`
    methods. But since we are working with dates here, we take advantage of Matplotlib’s
    utilities for date formatting and indicate that we want only the month to show,
    with `xaxis.set_major_formatter(DateFormatter("%b"))`. Since we are working with
    subplots, we use `set_xlabel` rather than `xlabel` to indicate the label we want
    for the *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: We show line plots for four selected regions in *Step 6*. We do this by calling
    `plot` for each region that we want plotted. We could have done it for all of
    the regions, but it would have been too difficult to view.
  prefs: []
  type: TYPE_NORMAL
- en: We have to do some additional manipulation in *Step 7* to pull the new Brazil
    cases out of the cases for South America. Once we do that, we can do a stacked
    plot with the South America cases (minus Brazil) and Brazil. This figure suggests
    that the trends in new cases in South America in 2023 were largely driven by trends
    in Brazil.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The figure produced in *Step 6* reveals a couple of potential data issues. There
    is an unusual spike in April of 2023 in East Asia. It is important to examine
    these totals to check whether there is a data collection error.
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to miss how much the trends differ by region. There are substantive
    reasons for this, of course. The different lines reflect what we know to be reality
    about different rates of spread by country and region. However, it is worth exploring
    any significant change in the direction or slope of trend lines to make sure that
    we can confirm that the data is accurate.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We cover `groupby` in more detail in *Chapter 9*, *Fixing Messy Data When Aggregating*.
    We go over merging data, as we did in *Step 7*, in *Chapter 10*, *Addressing Data
    Issues When Combining Data Frames*.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a heat map based on a correlation matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The correlation between two variables is a measure of how much they move together.
    A correlation of 1 means that the two variables are perfectly positively correlated.
    As one variable increases in size, so does the other. A value of -1 means that
    they are perfectly negatively correlated. As one variable increases in size, the
    other decreases. Correlations of 1 or -1 only rarely happen, but correlations
    above 0.5 or below -0.5 might still be meaningful. There are several tests that
    can tell us whether the relationship is statistically significant (such as Pearson,
    Spearman, and Kendall). Since this is a chapter on visualizations, we will focus
    on viewing important correlations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need Matplotlib and Seaborn installed to run the code in this recipe.
    Both can be installed by using `pip`, with the `pip install matplotlib` and `pip
    install seaborn` commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first show part of a correlation matrix of the COVID-19 data, and scatter
    plots of some key relationships. We then show a heat map of the correlation matrix
    to visualize the correlations between all variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `matplotlib` and `seaborn`, and load the COVID-19 totals data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Generate a correlation matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'View part of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Show scatter plots of median age and **gross domestic product** (**GDP**) per
    capita by cases per million.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Indicate that we want the subplots to share *y*-axis values with `sharey=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following scatter plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Scatter plots of median age and GDP by cases per million side
    by side'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a heat map of the correlation matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following heat map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18596_05_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Heat map of COVID-19 data, with strongest correlations in red
    and peach'
  prefs: []
  type: TYPE_NORMAL
- en: Heat maps are a great way to visualize how all key variables in our DataFrame
    are correlated with one another.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `corr` method of a DataFrame generates correlation coefficients of all numeric
    variables by all other numeric variables. We display part of that matrix in *Step
    2*. In *Step 3*, we make scatter plots of median age by cases per million, and
    GDP per capita by cases per million. These plots give a sense of what it looks
    like when the correlation is 0.74 (median age and cases per million) and when
    it is 0.66 (GDP per capita and cases per million). Countries with higher median
    ages or higher GDP per capita tend to have higher cases per million of population.
  prefs: []
  type: TYPE_NORMAL
- en: The heat map provides a visualization of the correlation matrix we created in
    *Step 2*. All of the red squares are correlations of 1.0 (which is the correlation
    of the variable with itself). The peach rectangles indicate the substantially
    positive correlations, such as those between median age, GDP per capita, and human
    development index and cases per million. The dark rectangles indicate that the
    relationships are strongly negative, such as that between vaccinations per 100,000
    of the population and deaths per million.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I find it helpful to always have a correlation matrix or heat map close by when
    I am doing exploratory analysis or statistical modeling. I understand the data
    much better when I am able to keep these bivariate relationships in mind.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We go over tools for examining the relationship between two variables in more
    detail in the *Identifying outliers and unexpected values in bivariate relationships*
    recipe in *Chapter 4*, *Identifying Outliers in Subsets of Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Histograms, boxplots, scatter plots, violin plots, line plots, and heat maps
    are all essential tools for understanding how variables are distributed. Scatter
    plots, violin plots, and heat maps can also help us better understand relationships
    between variables, whether they are continuous or categorical. We created visualizations
    with all of those tools in this chapter. In the next chapter, we will examine
    how to create new Series in pandas, or modify values in an existing Series.
  prefs: []
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_copy.png)'
  prefs: []
  type: TYPE_IMG
