["```py\n    In [1]: import numpy as np\n            import networkx as nx\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: n = 10  # Number of nodes in the graph.\n            # Each node is connected to the two next nodes,\n            # in a circular fashion.\n            adj = [(i, (i+1)%n) for i in range(n)]\n            adj += [(i, (i+2)%n) for i in range(n)]\n    ```", "```py\n    In [3]: g = nx.Graph(adj)\n    ```", "```py\n    In [4]: print(g.nodes())\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    In [5]: print(g.edges())\n    [(0, 8), (0, 1), (0, 2), ..., (7, 9), (8, 9)]\n    In [6]: print(nx.adjacency_matrix(g))\n    [[ 0\\.  1\\.  1\\.  0\\.  0\\.  0\\.  0\\.  0\\.  1\\.  1.]\n     [ 1\\.  0\\.  1\\.  1\\.  0\\.  0\\.  0\\.  0\\.  0\\.  1.]\n     ...\n     [ 1\\.  0\\.  0\\.  0\\.  0\\.  0\\.  1\\.  1\\.  0\\.  1.]\n     [ 1\\.  1\\.  0\\.  0\\.  0\\.  0\\.  0\\.  1\\.  1\\.  0.]]\n    ```", "```py\n    In [7]: nx.draw_circular(g)\n    ```", "```py\n    In [8]: g.add_node(n, color='#fcff00')\n            # We add an edge from every existing \n            # node to the new node.\n            for i in range(n):\n                g.add_edge(i, n)\n    ```", "```py\n    In [9]: # We define custom node positions on a circle\n            # except the last node which is at the center.\n            t = np.linspace(0., 2*np.pi, n)\n            pos = np.zeros((n+1, 2))\n            pos[:n,0] = np.cos(t)\n            pos[:n,1] = np.sin(t)\n            # A node's color is specified by its 'color'\n            # attribute, or a default color if this attribute\n            # doesn't exist.\n            color = [g.node[i].get('color', '#88b0f3')\n                     for i in range(n+1)]\n            # We now draw the graph with matplotlib.\n            nx.draw_networkx(g, pos=pos, node_color=color)\n            plt.axis('off')\n    ```", "```py\n    In [10]: nx.draw_spectral(g, node_color=color)\n             plt.axis('off')\n    ```", "```py\n    In [1]: import math\n            import json\n            import twitter\n            import numpy as np\n            import pandas as pd\n            import networkx as nx\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n            from IPython.display import Image\n    ```", "```py\n    In [2]: (CONSUMER_KEY,\n             CONSUMER_SECRET, \n             OAUTH_TOKEN,\n             OAUTH_TOKEN_SECRET) = open(\n                      'twitter.txt', 'r').read().splitlines()\n    ```", "```py\n    In [3]: auth = twitter.oauth.OAuth(OAUTH_TOKEN,\n                                       OAUTH_TOKEN_SECRET,\n                                       CONSUMER_KEY,\n                                       CONSUMER_SECRET)\n            tw = twitter.Twitter(auth=auth)\n    ```", "```py\n    In [4]: me = tw.account.verify_credentials()\n    In [5]: myid = me['id']\n    ```", "```py\n    In [6]: def get_followers_ids(uid=None):\n                # Retrieve the list of followers' ids of the\n                # specified user.\n                return tw.followers.ids(user_id=uid)['ids']\n    In [7]: # We get the list of my followers.\n            my_followers_ids = get_followers_ids()\n    ```", "```py\n    In [8]: def get_users_info(users_ids, max=500):\n                n = min(max, len(users_ids))\n                # Get information about those users,\n                # using batch requests.\n                users = [tw.users.lookup(\n                   user_id=users_ids[100*i:100*(i+1)])\n                       for i in range(int(math.ceil(n/100.)))]\n                # We flatten this list of lists.\n                users = [item for sublist in users \n                         for item in sublist]\n                return {user['id']: user for user in users}\n    In [9]: users_info = get_users_info(my_followers_ids)\n    In [10]: # Let's save this dictionary on the disk.\n             with open('my_followers.json', 'w') as f:\n                 json.dump(users_info, f, indent=1)\n    ```", "```py\n    In [11]: adjacency = {myid: my_followers_ids}\n    ```", "```py\n    In [12]: my_followers_python = \\[user \n                for user in users_info.values()\n                  if 'python' in user['description'].lower()]\n    In [13]: my_followers_python_best = \\\n              sorted(my_followers_python, \n                key=lambda u: u['followers_count'])[::-1][:10]\n    ```", "```py\n    In [14]: tw.application.rate_limit_status(\n                 resources='followers') \\\n                 ['resources']['followers']['/followers/ids']\n    Out[14]: {u'limit': 15, \n              u'remaining': 0, \n              u'reset': 1388865551}\n    In [15]: for user in my_followers_python_best:\n                 # The call to get_followers_ids is \n                 # rate-limited.\n                 adjacency[user['id']] = list(set(\n                     get_followers_ids(user['id'])). \\\n                     intersection(my_followers_ids))\n    ```", "```py\n    In [16]: g = nx.Graph(adjacency)\n    In [17]: # We only restrict the graph to the users\n             # for which we were able to retrieve the profile.\n             g = g.subgraph(users_info.keys())\n    In [18]: # We also save this graph on disk.\n             with open('my_graph.json', 'w') as f:\n                 json.dump(nx.to_dict_of_lists(g), f, indent=1)\n    In [19]: # We remove isolated nodes for simplicity.\n             g.remove_nodes_from([k \n                    for k, d in g.degree().items()\n                                  if d <= 1])\n    In [20]: # Since I am connected to all nodes, \n             # by definition, we can remove me for simplicity.\n             g.remove_nodes_from([myid])\n    ```", "```py\n    In [21]: len(g.nodes()), len(g.edges())\n    Out[21]: (197, 1037)\n    ```", "```py\n    In [22]: # Update the dictionary.\n             deg = g.degree()\n             for user in users_info.values():\n                 fc = user['followers_count']\n                 sc = user['statuses_count']\n                 # Is this user a Pythonista?\n                 user['python'] = 'python' in \\ \n                                  user['description'].lower()\n                 # We compute the node size as a function of \n                 # the number of followers.\n                 user['node_size'] = math.sqrt(1 + 10 * fc)\n                 # The color is function of its activity\n                 user['node_color'] = 10 * math.sqrt(1 + sc)\n                 # We only display the name of the most \n                 # followed users.\n                 user['label'] = user['screen_name'] \\\n                                     if fc > 2000 else ''\n    ```", "```py\n    In [23]: node_size = [users_info[uid]['node_size']\n                          for uid in g.nodes()]\n    In [24]: node_color = [users_info[uid]['node_color']\n                           for uid in g.nodes()]\n    In [25]: labels = {uid: users_info[uid]['label']\n                       for uid in g.nodes()}\n    In [26]: nx.draw(g, cmap=plt.cm.OrRd, alpha=.8,\n                     node_size=node_size,\n                     node_color=node_color,\n                     labels=labels, font_size=4, width=.1)\n    ```", "```py\n    In [1]: import json\n            import apt\n            cache = apt.Cache()\n    ```", "```py\n    In [2]: graph = {}\n    ```", "```py\n    In [3]: def get_dependencies(package):\n                if package not in cache:\n                    return []\n                pack = cache[package]\n                ver = pack.candidate or pack.versions[0]\n                # We flatten the list of dependencies,\n                # and we remove the duplicates.\n                return sorted(set([item.name \n                        for sublist in ver.dependencies \n                        for item in sublist]))\n    ```", "```py\n    In [4]: def get_dep_recursive(package):\n                if package not in cache:\n                    return []\n                if package not in graph:\n                    dep = get_dependencies(package)\n                    graph[package] = dep\n                for dep in graph[package]:\n                    if dep not in graph:\n                        graph[dep] = get_dep_recursive(dep)\n                return graph[package]\n    ```", "```py\n    In [5]: get_dep_recursive('ipython')\n    ```", "```py\n    In [6]: with open('data/apt.json', 'w') as f:\n                json.dump(graph, f, indent=1)\n    ```", "```py\n    In [7]: import json\n            import numpy as np\n            import networkx as nx\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [8]: with open('data/apt.json', 'r') as f:\n                graph = json.load(f)\n    ```", "```py\n    In [9]: g = nx.DiGraph(graph).reverse()\n    ```", "```py\n    In [10]: nx.is_directed_acyclic_graph(g)\n    Out[10]: False\n    ```", "```py\n    In [11]: set([cycle[0] for cycle in nx.simple_cycles(g)])\n    Out[11]: {u'coreutils', u'libc6', u'multiarch-support',\n              u'python-minimal', u'tzdata'}\n    ```", "```py\n    In [12]: g.remove_nodes_from(_)\n    In [13]: nx.is_directed_acyclic_graph(g)\n    Out[13]: True\n    ```", "```py\n    In [14]: ug = g.to_undirected()\n             deg = ug.degree()\n    In [15]: # The size of the nodes depends on the number \n             # of dependencies.\n             nx.draw(ug, font_size=6, \n                  node_size=[20*deg[k] for k in ug.nodes()])\n    ```", "```py\n    In [16]: nx.topological_sort(g)\n    Out[16]: [u'libexpat1',\n              u'libdb5.1',\n              u'debconf-2.0',\n              ...\n              u'python-pexpect',\n              u'python-configobj',\n              u'ipython']\n    ```", "```py\n    In [1]: import itertools\n            import numpy as np\n            import networkx as nx\n            import matplotlib.colors as col\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: n = 10\n    In [3]: img = np.random.randint(size=(n, n), \n                                    low=0, high=3)\n    ```", "```py\n    In [4]: g = nx.grid_2d_graph(n, n)\n    ```", "```py\n    In [5]: def show_image(img, **kwargs):\n                plt.imshow(img,\n                           origin='lower',\n                           interpolation='none',\n                           **kwargs)\n                plt.axis('off')\n    In [6]: def show_graph(g, **kwargs):\n                nx.draw(g,\n                  pos={(i, j): (j, i) \n                       for (i, j) in g.nodes()},\n                  node_color=[img[i, j] \n                              for (i, j) in g.nodes()],\n                  linewidths=1, edge_color='w',\n                  with_labels=False, node_size=30, **kwargs)\n    In [7]: cmap = plt.cm.Blues\n    ```", "```py\n    In [8]: show_image(img, cmap=cmap, vmin=-1)\n            show_graph(g, cmap=cmap, vmin=-1)\n    ```", "```py\n    In [9]: g2 = g.subgraph(zip(*np.nonzero(img==2)))\n    In [10]: show_image(img, cmap=cmap, vmin=-1)\n             show_graph(g2, cmap=cmap, vmin=-1)\n    ```", "```py\n    In [11]: components = [np.array(comp)\n                 for comp in nx.connected_components(g2)\n                 if len(comp)>=3]\n             len(components)\n    Out[11]: 3\n    ```", "```py\n    In [12]: # We copy the image, and assign a new label\n             # to each found component.\n             img_bis = img.copy()\n             for i, comp in enumerate(components):\n                 img_bis[comp[:,0], comp[:,1]] = i + 3\n    In [13]: # We create a new discrete color map extending\n             # the previous map with new colors.\n             colors = [cmap(.5), cmap(.75), cmap(1.), \n                       '#f4f235', '#f4a535', '#f44b35']\n             cmap2 = col.ListedColormap(colors, 'indexed')\n    In [14]: show_image(img_bis, cmap=cmap2)\n    ```", "```py\n    In [1]: import numpy as np\n            import pandas as pd\n            import scipy.spatial as spatial\n            import matplotlib.pyplot as plt\n            import matplotlib.path as path\n            import matplotlib as mpl\n            import smopy\n            %matplotlib inline\n    ```", "```py\n    In [2]: df = pd.read_csv('data/ratp.csv',\n                             sep='#', header=None)\n    In [3]: df[df.columns[1:]].tail(2)\n    Out[3]:   1      2              3              4     5\n    11609  2.30  48.93        TIMBAUD  GENNEVILLIERS  tram\n    11610  2.23  48.91   VICTOR BASCH       COLOMBES  tram\n    ```", "```py\n    In [4]: metro = df[(df[5] == 'metro')]\n    In [5]: metro[metro.columns[1:]].tail(3)\n    Out[5]:\n    305  2.308  48.841  Volontaires  PARIS-15EME  metro\n    306  2.379  48.857     Voltaire  PARIS-11EME  metro\n    307  2.304  48.883       Wagram  PARIS-17EME  metro\n    ```", "```py\n    In [6]: # We only extract the district from stations\n            # in Paris.\n            paris = metro[4].str.startswith('PARIS').values\n    In [7]: # We create a vector of integers with the district\n            # number of the corresponding station, or 0 \n            # if the station is not in Paris.\n            districts = np.zeros(len(paris), dtype=np.int32)\n            districts[paris] = metro[4][paris].\\\n                         str.slice(6, 8).astype(np.int32)\n            districts[~paris] = 0\n            ndistricts = districts.max() + 1\n    ```", "```py\n    In [8]: lon = metro[1]\n            lat = metro[2]\n    ```", "```py\n    In [9]: box = (lat[paris].min(), lon[paris].min(), \n                   lat[paris].max(), lon[paris].max())\n            m = smopy.Map(box, z=12)\n    ```", "```py\n    In [10]: vor = spatial.Voronoi(np.c_[lat, lon])\n    ```", "```py\n    In [11]: def voronoi_finite_polygons_2d(vor, radius=None):\n                 \"\"\"Reconstruct infinite Voronoi regions in a \n                 2D diagram to finite regions.\"\"\"\n                 ...\n    ```", "```py\n    In [12]: regions, vertices = \\\n                         voronoi_finite_polygons_2d(vor)\n             cells = [m.to_pixels(vertices[region])\n                      for region in regions]\n    ```", "```py\n    In [13]: cmap = plt.cm.Set3\n             # We generate colors for districts using\n             # a color map.\n             colors_districts = cmap(\n                       np.linspace(0., 1., ndistricts))[:,:3]\n             # The color of every polygon, grey by default.\n             colors = .25 * np.ones((len(districts), 3))\n             # We give each polygon in Paris the color of \n             # its district.\n             colors[paris] = colors_districts[districts[paris]]\n    ```", "```py\n    In [14]: ax = m.show_mpl()\n             ax.add_collection(\n                 mpl.collections.PolyCollection(cells,\n                    facecolors=colors, edgecolors='k',\n                    alpha=0.35,))\n    ```", "```py\nconda install gdal\nconda install fiona\nconda install basemap\n\n```", "```py\npip install shapely\npip install descartes\n\n```", "```py\n    In [1]: import numpy as np\n            import matplotlib.pyplot as plt\n            import matplotlib.collections as col\n            from mpl_toolkits.basemap import Basemap\n            import fiona\n            import shapely.geometry as geom\n            from descartes import PolygonPatch\n            %matplotlib inline\n    ```", "```py\n    In [2]: # Natural Earth data\n            countries = fiona.open(\n                           \"data/ne_10m_admin_0_countries.shp\")\n    ```", "```py\n    In [3]: africa = [c for c in countries \n                if c['properties']['CONTINENT'] == 'Africa']\n    ```", "```py\n    In [4]: m = Basemap(llcrnrlon=-23.03,\n                        llcrnrlat=-37.72,\n                        urcrnrlon=55.20,\n                        urcrnrlat=40.58)\n    ```", "```py\n    In [5]: def _convert(poly, m):\n                if isinstance(poly, list):\n                    return [_convert(_, m) for _ in poly]\n                elif isinstance(poly, tuple):\n                    return m(*poly)\n    In [6]: for _ in africa:\n                _['geometry']['coordinates'] = _convert(\n                    _['geometry']['coordinates'], m)\n    ```", "```py\n    In [7]: def get_patch(shape, **kwargs):\n                \"\"\"Return a matplotlib PatchCollection from a \n                geometry object loaded with fiona.\"\"\"\n                # Simple polygon.\n                if isinstance(shape, geom.Polygon):\n                    return col.PatchCollection(\n                          [PolygonPatch(shape, **kwargs)],\n                          match_original=True)\n                # Collection of polygons.\n                elif isinstance(shape, geom.MultiPolygon):\n                    return col.PatchCollection(\n                           [PolygonPatch(c, **kwargs)\n                            for c in shape],\n                           match_original=True)\n    In [8]: def get_patches(shapes, fc=None, \n                            ec=None, **kwargs):\n                \"\"\"Return a list of matplotlib PatchCollection \n                objects from a Shapefile dataset.\"\"\"\n                # fc and ec are the face and edge colors of the \n                # countries. We ensure these are lists of \n                # colors, with one element per country.\n                if not isinstance(fc, list):\n                    fc = [fc] * len(shapes)\n                if not isinstance(ec, list):\n                    ec = [ec] * len(shapes)\n                # We convert each polygon to a matplotlib \n                # PatchCollection object.\n                return [get_patch(geom.shape(s['geometry']), \n                                  fc=fc_, ec=ec_, **kwargs) \n                        for s, fc_, ec_ in zip(shapes, fc, ec)]\n    ```", "```py\n    In [9]: def get_colors(field, cmap):\n                \"\"\"Return one color per country, depending on a \n                specific field in the dataset.\"\"\"\n                values = [country['properties'][field]\n                          for country in africa]\n                values_max = max(values)\n                return [cmap(v / values_max) for v in values]\n    ```", "```py\n    In [10]: # Display the countries color-coded with\n             # their population.\n             ax = plt.subplot(121)\n             m.drawcoastlines()\n             patches = get_patches(africa, \n                                   fc=get_colors('POP_EST',\n                                                 plt.cm.Reds), \n                                   ec='k')\n             for p in patches:\n                 ax.add_collection(p)\n             plt.title(\"Population\")\n             # Display the countries color-coded with\n             # their population.\n             ax = plt.subplot(122)\n             m.drawcoastlines()\n             patches = get_patches(africa, \n                                   fc=get_colors('GDP_MD_EST',\n                                                 plt.cm.Blues), \n                                   ec='k')\n             for p in patches:\n                 ax.add_collection(p)\n             plt.title(\"GDP\")\n    ```", "```py\n    In [1]: import networkx as nx\n            import numpy as np\n            import pandas as pd\n            import json\n            import smopy\n            import matplotlib.pyplot as plt\n            %matplotlib inline\n    ```", "```py\n    In [2]: g = nx.read_shp(\"data/tl_2013_06_prisecroads.shp\")\n    ```", "```py\n    In [3]: sgs = list(nx.connected_component_subgraphs(\n                       g.to_undirected()))\n            largest = np.argmax([len(sg) \n                                 for sg in sgs])\n            sg = sgs[largest]\n            len(sg)\n    Out[3]: 464\n    ```", "```py\n    In [4]: pos0 = (36.6026, -121.9026)\n            pos1 = (34.0569, -118.2427)\n    ```", "```py\n    In [5]: def get_path(n0, n1):\n                \"\"\"If n0 and n1 are connected nodes in the \n                graph, this function returns an array of point\n                coordinates along the road linking these\n                two nodes.\"\"\"\n                return np.array(json.loads(\n                          sg[n0][n1]['Json'])['coordinates'])\n    ```", "```py\n    In [6]: EARTH_R = 6372.8\n            def geocalc(lat0, lon0, lat1, lon1):\n                \"\"\"Return the distance (in km) between two\n                points in geographical coordinates.\"\"\"\n                lat0 = np.radians(lat0)\n                lon0 = np.radians(lon0)\n                lat1 = np.radians(lat1)\n                lon1 = np.radians(lon1)\n                dlon = lon0 - lon1\n                y = np.sqrt(\n                      (np.cos(lat1)*np.sin(dlon))**2\n                      +(np.cos(lat0)*np.sin(lat1) \n                        -np.sin(lat0)*np.cos(lat1)* \\\n                         np.cos(dlon))**2)\n                x = np.sin(lat0)*np.sin(lat1) + \\\n                    np.cos(lat0)*np.cos(lat1)*np.cos(dlon)\n                c = np.arctan2(y, x)\n                return EARTH_R * c\n    ```", "```py\n    In [7]: def get_path_length(path):\n                return np.sum(geocalc(\n                                path[1:,0], path[1:,1],\n                                path[:-1,0], path[:-1,1]))\n    ```", "```py\n    In [8]: # Compute the length of the road segments.\n            for n0, n1 in sg.edges_iter():\n                path = get_path(n0, n1)\n                distance = get_path_length(path)\n                sg.edge[n0][n1]['distance'] = distance\n    ```", "```py\n    In [9]: nodes = np.array(sg.nodes())\n            # Get the closest nodes in the graph.\n            pos0_i = np.argmin(np.sum(\n                                   (nodes[:,::-1] - pos0)**2,\n                                   axis=1))\n            pos1_i = np.argmin(np.sum(\n                                   (nodes[:,::-1] - pos1)**2,\n                                  axis=1))\n    ```", "```py\n    In [10]: # Compute the shortest path.\n             path = nx.shortest_path(sg, \n                            source=tuple(nodes[pos0_i]), \n                            target=tuple(nodes[pos1_i]),\n                            weight='distance')\n             len(path)\n    Out[10]: 19\n    ```", "```py\n    In [11]: roads = pd.DataFrame([\n                         sg.edge[path[i]][path[i + 1]] \n                                 for i in range(len(path)-1)], \n                         columns=['FULLNAME', 'MTFCC', \n                                 'RTTYP', 'distance'])\n             roads\n    Out[11]:  FULLNAME  MTFCC RTTYP    distance\n    0      State Rte 1  S1200     S  100.657768\n    1      State Rte 1  S1200     S   33.419581\n    ...\n    16   Hollywood Fwy  S1200     M   14.087627\n    17   Hollywood Fwy  S1200     M    0.010107\n    ```", "```py\n    In [12]: roads['distance'].sum()\n    Out[12]: 508.66421585288725\n    ```", "```py\n    In [13]: map = smopy.Map(pos0, pos1, z=7, margin=.1)\n    ```", "```py\n    In [14]: def get_full_path(path):\n                 \"\"\"Return the positions along a path.\"\"\"\n                 p_list = []\n                 curp = None\n                 for i in range(len(path)-1):\n                     p = get_path(path[i], path[i+1])\n                     if curp is None:\n                         curp = p\n                     if np.sum((p[0]-curp)**2) > \\\n                                      np.sum((p[-1]-curp)**2):\n                         p = p[::-1,:]\n                     p_list.append(p)\n                     curp = p[-1]\n                 return np.vstack(p_list)\n    ```", "```py\n    In [15]: linepath = get_full_path(path)\n             x, y = map.to_pixels(linepath[:,1], linepath[:,0])\n    ```", "```py\n    In [16]: map.show_mpl()\n             # Plot the itinerary.\n             plt.plot(x, y, '-k', lw=1.5)\n             # Mark our two positions.\n             plt.plot(x[0], y[0], 'ob', ms=10)\n             plt.plot(x[-1], y[-1], 'or', ms=10)\n    ```"]