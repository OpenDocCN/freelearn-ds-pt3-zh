<html><head></head><body>
  <div id="_idContainer529">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-240" class="chapterTitle">Understanding the Tableau Data Model, Joins, and Blends</h1>
    <p class="normal">In this chapter, we'll gain a deeper understanding of how to model and structure data with Tableau. We've seen the <strong class="bold">Data Source</strong> screen in previous chapters and briefly explored how to drag and drop tables to form relationships. Now, we'll explore some of Tableau's more complex features to gain a good understanding of how Tableau allows you to relate multiple tables together, either logically or physically.</p>
    <p class="normal">We'll start with a broad overview of Tableau's new data model and then examine some details of different types of joins and blends. The data model and blending apply primarily to Tableau Desktop (and Server), but pay special attention to the discussion of joins, as a good understanding of join types will aid you greatly when we discuss Tableau preparation in <em class="italics">Chapter 15</em>, <em class="italics">Taming Data with Tableau Prep</em>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The data model is only available in Tableau 2020.2 and later. If you are using an older version, the explanation of joins and blends will be directly applicable, while the explanation of the data model will serve as inspiration for you to upgrade!</p>
    </div>
    <p class="normal">In this chapter, we'll cover the following topics:</p>
    <ul>
      <li class="list">Explanation of the sample data used in this chapter</li>
      <li class="list">Exploring the Tableau data model</li>
      <li class="list">Using joins</li>
      <li class="list">Using blends</li>
      <li class="list">When to use a data model, joins, or blends</li>
    </ul>
    <p class="normal">We'll start by understanding the sample dataset included in the workbook for this chapter. This is so that you have a good foundation of knowledge before working through the examples.</p>
    <h1 id="_idParaDest-241" class="title">Explanation of the sample data used in this chapter</h1>
    <p class="normal">For this chapter, we'll use a sample dataset of patient visits to the hospital. The data itself is contained in the Excel file <code class="Code-In-Text--PACKT-">Hospital Visits.xlsx</code> in the <code class="Code-In-Text--PACKT-">Learning Tableau\Chapter 13</code> directory. The tabs of the Excel file represent tables of data, just as you might find in any relational database as multiple files, or simply as literal tabs in an Excel file! The relationship between those tables is illustrated here:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.1: The four tabs of the Excel file illustrated as four tables with relationships</p>
    <p class="normal">Excel does not explicitly define the relationships, but they are shown here as they might exist in a relational database using foreign key lookups. Here is a brief explanation of the tables and their relationships:</p>
    <ul>
      <li class="list"><strong class="screen-text">Hospital Visit</strong>: This is the primary table that records the admission and diagnosis of a single patient on a single visit to the hospital. It contains attributes, such as <strong class="screen-text">Admit Type</strong> and <strong class="screen-text">Location</strong>, and a measure of <strong class="screen-text">Minutes to Service</strong>.</li>
      <li class="list"><strong class="screen-text">Patient</strong>: This table contains additional information for a single patient, such as their <strong class="screen-text">Name</strong> and <strong class="screen-text">Birthdate</strong>, and a measure of their <strong class="screen-text">Age at Most Recent Admit</strong>.</li>
      <li class="list"><strong class="screen-text">Discharge Details</strong>: This table gives additional information for the discharge of a patient, such as the <strong class="screen-text">Discharge Date</strong> and the <strong class="screen-text">Disposition</strong> (the condition under which they were discharged and where they went after being discharged). It also contains a measure <strong class="screen-text">How did the patient feel about care? (1-10)</strong> that ranks the patient's feelings about the level of care, with 1 being the lowest and 10 being the highest.</li>
      <li class="list"><strong class="screen-text">Patient &amp; Doctor Interaction</strong>: This<strong class="bold"> </strong>table defines the interaction between a patient and a doctor during the visit. It includes the <strong class="screen-text">Doctor Name</strong>, <strong class="screen-text">Notes</strong>, and measures how long the doctor spent with the patient (<strong class="screen-text">Minutes spent with Patient</strong>).</li>
    </ul>
    <p class="normal">The tables relate to each other in different ways. Here are some details:</p>
    <ul>
      <li class="list"><strong class="screen-text">Hospital Visit</strong> to <strong class="screen-text">Patient</strong>: Each visit has a single patient, so <strong class="screen-text">Hospital Visit</strong> will always have a <strong class="screen-text">Patient ID</strong> field that points to a single record in the <strong class="screen-text">Patient</strong> table. We will also find additional patients in the <strong class="screen-text">Patient</strong> table who do not have recorded visits. Perhaps they are historical records from a legacy system or the patient's interaction with the hospital occurred in a manner other than a visit.</li>
      <li class="list"><strong class="screen-text">Hospital Visit</strong> to <strong class="screen-text">Discharge Details</strong>: Each visit may have a single discharge, but some patients may still be in the hospital. In a well-designed data structure, we should be able to count on a record in the <strong class="screen-text">Discharge Details</strong> table that indicates "still in the hospital." In our Excel data, however, there may or may not be a <strong class="screen-text">Discharge Details ID</strong>, meaning there won't always be a matching <strong class="screen-text">Discharge Details</strong> record for every <strong class="screen-text">Hospital Visit</strong>.</li>
      <li class="list"><strong class="screen-text">Patient &amp; Doctor Interaction</strong> to <strong class="screen-text">Hospital Visit</strong>: Throughout the patient's visit, there may be one or more doctors who interact with a patient. It's also possible that no doctor records any interaction. So, we'll sometimes find multiple records in the <strong class="screen-text">Patient &amp; Doctor Interaction</strong> that reference a single <strong class="screen-text">Visit ID</strong>, sometimes only a single record, and sometimes no records at all for a visit that exists in the <strong class="screen-text">Hospital Visit</strong> table.</li>
    </ul>
    <p class="normal">With a solid grasp of the sample data source, let's turn our attention to how we might build a data model in Tableau.</p>
    <h1 id="_idParaDest-242" class="title">Exploring the Tableau data model</h1>
    <p class="normal">You'll find the data<a id="_idIndexMarker1078"/> model as a new feature in Tableau 2020.2 and later. Every data source will use the data model. Data sources created in previous versions will be updated to the data model but will be contained in a single object, so, functionally, they will work in the same way as the previous version.</p>
    <p class="normal">Previous versions of Tableau allow you to leverage joining tables and blending data sources together, and we'll consider those options at the end of this chapter. For now, we'll look at creating a <a id="_idIndexMarker1079"/>data model and understanding the paradigm.</p>
    <h2 id="_idParaDest-243" class="title">Creating a data model</h2>
    <p class="normal">We've briefly looked at<a id="_idIndexMarker1080"/> the <strong class="bold">Data Source</strong> screen in <em class="italics">Chapter 2</em>, <em class="italics">Connecting to Data in Tableau</em>. Now, we'll take a deeper look at the concepts behind the interface. Feel free to follow along with the following example in the <code class="Code-In-Text--PACKT-">Chapter 13 Starter.twb</code> workbook, or examine the end results in <code class="Code-In-Text--PACKT-">Chapter 13 Complete.twbx</code>.</p>
    <p class="normal">We'll start by creating a connection to the <code class="Code-In-Text--PACKT-">Hospital Visits.xlsx</code> file in the <code class="Code-In-Text--PACKT-">Chapter 13</code> directory. The <strong class="bold">Data Source </strong>screen will look like this upon first connecting to the file:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.2: The Data Source screen lists the tabs in the Excel workbook and invites you to start a data model</p>
    <p class="normal">We'll build the data model by dragging and dropping tables onto the canvas. We'll add all four tables. Tableau will suggest relationships for each new table added based on any matching field names and types. For our tables, we'll accept the default settings because the <code class="Code-In-Text--PACKT-">ID</code> fields that indicate the correct relationship are identically named and typed.</p>
    <p class="normal">The first table added is the root and forms the start of the data model. In this example, the order in which you add the tables won't matter, though you may notice a slightly different display depending on which table you start with. In the following screenshot, we've started with <strong class="screen-text">Hospital Visit</strong> (which is the primary table and, therefore, makes sense to be the<a id="_idIndexMarker1081"/> root table) and then added all of the other tables:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.3: All tables have been added to the data model</p>
    <p class="normal">You'll notice the <strong class="screen-text">Edit Relationship</strong> dialog box is open for the relationship between <strong class="screen-text">Hospital Visit</strong> and <strong class="screen-text">Patient</strong>. Tableau automatically created our relationships because the ID fields had the same name and type between both tables. If necessary, you could manually edit the relationships to change which fields define the relationship.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">A <strong class="bold">relationship</strong> simply defines which fields connect the tables together. It does not define exactly how the tables relate to each other. We'll discuss the concepts of join types (for example, left join or inner join) later on in this chapter, but relationships are not restricted to a certain join type. Instead, Tableau will use the appropriate kind of join as well as the correct aggregations depending on which fields you use in your view. For the most part, you won't have to think about what Tableau is doing behind the scenes, but we'll examine some unique behaviors in the next section.</p>
      <p class="Information-Box--PACKT-">The ability to write calculations to define relationships is not available in 2020.2, but is a feature in 2020.3.</p>
    </div>
    <p class="normal">Also, notice<a id="_idIndexMarker1082"/> the <strong class="screen-text">Performance Options</strong> drop-down menu in the relationship editor, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.4: The Edit Relationship dialog box includes options to improve performance</p>
    <p class="normal">These performance options allow Tableau to generate more efficient queries if the nature of the relationship is known. If you do not know the exact nature of the relationship, it is best to leave the options in their default settings as an incorrect setting can lead to incorrect results.</p>
    <p class="normal">There are two basic concepts covered by the performance options:</p>
    <ul>
      <li class="list"><strong class="screen-text">Cardinality</strong>: This term indicates how many records in one table could potentially relate to the records of another table. For example, we know that one visit matches to only one patient. However, we also know that many<strong class="bold"> </strong>doctors could potentially interact with a patient during one visit.</li>
      <li class="list"><strong class="screen-text">Referential Integrity</strong>: This term indicates whether we expect all records to find a match or whether some records could potentially be unmatched. For example, we know (from <a id="_idIndexMarker1083"/>the preceding description) that there are patients in the <strong class="screen-text">Patient</strong> table that will not have a match in the <strong class="screen-text">Hospital Visit</strong> table. We also know that some patients will not have discharge records as they are still in the hospital.</li>
    </ul>
    <p class="normal">If Tableau is able to determine constraints from a relational database, those constraints will be used. Otherwise, Tableau will set the defaults to <strong class="screen-text">Many</strong> and <strong class="screen-text">Some records match</strong>. For the examples in this chapter, we do know the precise nature of the relationships (they are described in the previous section), but we'll accept the performance defaults as the dataset is small enough that there won't be any perceptible performance gain in modifying them.</p>
    <p class="normal">With our initial data model created, let's take a moment to explore the two layers of the data model paradigm.</p>
    <h2 id="_idParaDest-244" class="title">Layers of the data model</h2>
    <p class="normal">A data model consists<a id="_idIndexMarker1084"/> of two layers:</p>
    <ul>
      <li class="list">The <strong class="bold">logical layer</strong>: A semantic<a id="_idIndexMarker1085"/> layer made up of logical tables or objects that are related. Each logical table might be made up of one or more physical tables.</li>
      <li class="list">The <strong class="bold">physical layer</strong>: A layer <a id="_idIndexMarker1086"/>made up of the physical tables that come from the underlying data source. These tables may be joined or unioned together with conventional joins or unions or created from custom SQL statements.</li>
    </ul>
    <p class="normal">Consider the following screenshot of a canvas containing our four tables:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.5: The logical layer of the data model</p>
    <p class="normal">This initial canvas <a id="_idIndexMarker1087"/>defines the <strong class="bold">logical tables</strong> of the data model. A logical table is a collection of data that defines a single structure or object that relates to other logical structures of data. Double-click on the <strong class="screen-text">Hospital Visit</strong> table on the canvas, and you'll see another layer beneath the logical layer:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.6: The physical layer of the physical tables that make up Hospital Visit</p>
    <p class="normal">This is the physical layer for the logical <strong class="screen-text">Hospital Visit</strong> table. This physical layer is made up of physical tables of data—potentially unioned or joined together. In this case, we are informed that <strong class="screen-text">Hospital Visit is made of 1 table</strong>. So, in this case, the logical layer of <strong class="screen-text">Hospital Visit</strong> is identical to the physical layer underneath. In the <em class="italics">Using joins </em>section of this chapter, we'll explore examples of how we might extend the complexity of the physical layer with multiple tables while still treating the collection of tables as a single object.</p>
    <p class="normal">Go ahead and <a id="_idIndexMarker1088"/>close the physical layer of <strong class="screen-text">Hospital Visit</strong> with the <strong class="screen-text">X</strong> icon in the upper-right corner. Then navigate to the <strong class="screen-text">Analysis</strong> tab of the workbook for this chapter, and we'll explore how the data model works in practice.</p>
    <h2 id="_idParaDest-245" class="title">Using the data model</h2>
    <p class="normal">For the most part, working <a id="_idIndexMarker1089"/>with the data model will be relatively intuitive. If you've worked with previous Tableau versions, you'll notice some slight interface changes, and there are a few data model behaviors you should learn to expect. Once you are comfortable with them, your analysis will exceed expectations!</p>
    <h3 id="_idParaDest-246" class="title">The new data pane interface</h3>
    <p class="normal">One thing you may <a id="_idIndexMarker1090"/>notice is the difference in the <strong class="screen-text">Data</strong> pane, which will look something like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.7: The Data pane is organized by logical tables and shows a separation of dimensions and measures per table</p>
    <p class="normal">You'll notice that the <strong class="screen-text">Data</strong> pane is organized by logical tables, with fields belonging to each table. Measures <a id="_idIndexMarker1091"/>and dimensions are separated by a thin line rather than appearing in different sections as they did previously. This makes it easier to find the fields relevant to your analysis and also helps you to understand the expected behavior of the data model. Also different from previous versions is that each logical table has its own <code class="Code-In-Text--PACKT-">number of records</code> field that is named using the convention <strong class="screen-text">Table Name (Count)</strong>. You'll find the calculations you can add along with <strong class="screen-text">Measure Names</strong>/<strong class="screen-text">Measure Values</strong> at the bottom of the list of fields.</p>
    <p class="normal">Following this<a id="_idIndexMarker1092"/> overview of some of the UI changes, let's look at some behaviors you can expect from the data model.</p>
    <h3 id="_idParaDest-247" class="title">Data model behaviors</h3>
    <p class="normal">In the <strong class="screen-text">Analysis</strong> tab<a id="_idIndexMarker1093"/> of the <code class="Code-In-Text--PACKT-">Starter</code> workbook, experiment with creating different visualizations. Especially note dimensions, what values are shown, and how measures are aggregated. We'll walk through a few examples to illustrate (which you can replicate in the <code class="Code-In-Text--PACKT-">Starter</code> workbook or examine in the <code class="Code-In-Text--PACKT-">Complete</code> workbook).</p>
    <p class="normal">First, notice that dragging <strong class="screen-text">Name</strong> from the <strong class="screen-text">Patient</strong> table to <strong class="screen-text">Rows</strong> reveals 10 patients. It turns out that not all of these patients have hospital visits, but when we use one or more dimensions from the same logical table, we see the full domain of values in Tableau. That is, we see all the patients, whether or not they had visited the hospital. We can verify how many visits each patient had by adding the <strong class="screen-text">Hospital Visit (Count)</strong> field, resulting in the following view:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.8: All patients are shown, even those with 0 visits</p>
    <p class="normal">But if we add <strong class="screen-text">Primary Diagnosis</strong> to the table, notice that only 6 out of the 10 patients are shown:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.9: Only patients with visits are shown; most patients had a single visit with a given diagnosis, but one came in twice with the same diagnosis</p>
    <p class="normal">This highlights another <a id="_idIndexMarker1094"/>behavior: when you include dimensions from two or more tables, only matching values are shown. In essence, when you add <strong class="screen-text">Name</strong> and <strong class="screen-text">Primary Diagnosis</strong>, Tableau is showing you patients who exist in both the <strong class="screen-text">Patient</strong> and <strong class="screen-text">Hospital Visit</strong> tables. This is great if you want to focus on only patients who had visited the hospital.</p>
    <p class="normal">But what if you truly want to see all patients and a diagnosis where applicable? To accomplish that, simply add a measure from the table of the field where you want to see the full domain. In this case, we could add either the <strong class="screen-text">Age at Most Recent Admit</strong> or <strong class="screen-text">Patient (Count)</strong> measures, as both come from the <strong class="screen-text">Patient</strong> table. Doing so results in the following view:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.10: All patients are once again shown</p>
    <p class="normal">Even though the <strong class="screen-text">Age at Most Recent Admit</strong> value is <code class="Code-In-Text--PACKT-">NULL</code> for patients who have never been admitted, simply<a id="_idIndexMarker1095"/> adding the measure to the view instructs Tableau to show all patients. This demonstrates a third behavior: including a measure from the same table as a dimension will force Tableau to show the full domain of values for that dimension.</p>
    <p class="normal">Another basic principle of data model behavior is also displayed here. Notice that <strong class="screen-text">Age at Most Recent Admit</strong> is shown for each patient and each diagnosis. However, Tableau does not incorrectly duplicate the value in totals or subtotals. If you were to add subtotals for each patient in the <strong class="screen-text">Age at Most Recent Admit</strong> and <strong class="screen-text">Count of Hospital Visit</strong> columns, as has been done in the following view, you'll see that Tableau has the correct values:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.11: Tableau calculates the subtotals correctly, even though traditional join behavior would have duplicated the values</p>
    <p class="normal">This final behavior <a id="_idIndexMarker1096"/>of the data model can be stated as: aggregates are calculated at the level of detail defined by the logical table of the measure. This is<a id="_idIndexMarker1097"/> similar to how you might use a <strong class="bold">Level of Detail</strong> (<strong class="bold">LOD</strong>) expression to avoid a LOD duplication, but you didn't have to write the expression or break your flow of thought to solve the problem. The Tableau data model did the hard work for you!</p>
    <p class="normal">Take some additional time to build out views and visualizations with the data model you've created. And review the following behaviors so you know what to expect and how to control the analysis you want to perform:</p>
    <ul>
      <li class="list">When you use one or more dimensions from the same logical table, you'll see the full domain of values in Tableau</li>
      <li class="list">When you include dimensions from two or more logical tables, only matching values are shown</li>
      <li class="list">Including a measure from the same logical table as a dimension will force Tableau to show the full domain of values for that dimension (even when the previous behavior was in effect)</li>
      <li class="list">Aggregates are calculated at the level of detail defined by the logical table of the measure</li>
    </ul>
    <p class="normal">With just a bit of practice, you'll find that the behaviors feel natural, and you'll especially appreciate Tableau<a id="_idIndexMarker1098"/> performing aggregations at the correct level of detail.</p>
    <div class="packt_tip">
      <p>When you first create a new data model, it is helpful to run through a couple of quick checks similar to the preceding examples. That will help you gain familiarity with the data model as well as help you validate that the relationships are working as you expect.</p>
    </div>
    <p class="normal">We'll now turn our focus to learn how to relate data in the physical layer using joins.</p>
    <h1 id="_idParaDest-248" class="title">Using joins</h1>
    <p class="normal">A <strong class="bold">join</strong> at the physical <a id="_idIndexMarker1099"/>level is a row-by-row matching of the data between tables. We'll look at some different types of joins and then consider how to leverage them in the physical layer of a data model.</p>
    <h2 id="_idParaDest-249" class="title">Types of joins</h2>
    <p class="normal">In the physical layer, you <a id="_idIndexMarker1100"/>may specify the following types of joins:</p>
    <ul>
      <li class="list"><strong class="bold">Inner</strong>: Only records<a id="_idIndexMarker1101"/> that match the join condition from both the table on the left and the table on the right will be kept. In the following example, only three matching rows are kept in the results:
    <figure class="mediaobject"><img src="../Images/B16021_13_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.12: Inner join</p>
	</li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Left</strong>: All records from<a id="_idIndexMarker1102"/> the table on the left will be kept. Matching records from the table on the right will have values in the resulting table, while unmatched records will contain <code class="Code-In-Text--PACKT-">NULL</code> values for all fields from the table on the right. In the following example, the five rows from the left table are kept, with <code class="Code-In-Text--PACKT-">NULL</code> results for any values in the right table that were not matched:
    <figure class="mediaobject"><img src="../Images/B16021_13_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.13: Left join</p>
	</li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Right</strong>: All records from the table on the right will be kept. Matching records from the table on <a id="_idIndexMarker1103"/>the left will result in values, while unmatched records will contain <code class="Code-In-Text--PACKT-">NULL</code> values for all fields from the table on the left. Not every data source supports a right join. If it is not supported, the option will be disabled. In the following example, the five rows from the right table are kept, with <code class="Code-In-Text--PACKT-">NULL</code> results for any values from the left table that were not matched:
    <figure class="mediaobject"><img src="../Images/B16021_13_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.14: Right join</p>
	</li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Full Outer</strong>: All records from tables on both sides will be kept. Matching records will have values<a id="_idIndexMarker1104"/> from the left and the right. Unmatched records will have <code class="Code-In-Text--PACKT-">NULL</code> values where either the left or the right matching record was not found. Not every data source supports a full outer join. If it is not supported, the option will be disabled. In the following example, all rows are kept from both sides with <code class="Code-In-Text--PACKT-">NULL</code> values where matches were not found:
    <figure class="mediaobject"><img src="../Images/B16021_13_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.15: Full Outer join</p>
	</li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Spatial</strong>: This joins <a id="_idIndexMarker1105"/>together records that match based on the <strong class="bold">intersection</strong> (overlap) of spatial objects (we discussed Tableau's spatial features in <em class="italics">Chapter 12</em>, <em class="italics">Exploring Mapping and Advanced Geospatial Features</em>). For example, a point based on the latitude and longitude might fall inside the complex shape defined by a shapefile. Records will be kept for any records where the spatial object in one table overlaps with the spatial object specified for the other:
    <figure class="mediaobject"><img src="../Images/B16021_13_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.16: Spatial join</p>
	</li>
    </ul>
    <p class="normal">When you select spatial <a id="_idIndexMarker1106"/>objects from the left and right tables, you'll need to specify <strong class="screen-text">Intersects</strong> as the operator between the fields to accomplish a spatial join, as shown in <em class="italics">Figure 13.17</em>:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.17: Assuming the two fields selected represent spatial objects, the Intersects option will be available</p>
    <p class="normal">With a solid understanding of join types, let's consider how to use them in the physical layer of Tableau's data model.</p>
    <h2 id="_idParaDest-250" class="title">Joining tables</h2>
    <p class="normal">Most databases have <a id="_idIndexMarker1107"/>multiple tables of data that are related in some way. Additionally, you are able to join together tables of data across various data connections for many different data sources.</p>
    <p class="normal">For our examples here, let's once again consider the tables in the hospital database, with a bit of simplification:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.18: The primary Hospital Visit table with Patient and Discharge Details as they might exist in a relational database</p>
    <p class="normal">Let's consider how we might build a data source using some joins in the physical layer. To follow along, create a new Excel data source in the <code class="Code-In-Text--PACKT-">Chapter 13 Starter.twbx</code> workbook that references the <code class="Code-In-Text--PACKT-">Hospital Visits (Joins).xlsx</code> file in the <code class="Code-In-Text--PACKT-">Chapter 13</code> directory. You may also examine the connection in the <code class="Code-In-Text--PACKT-">Chapter 13 Complete.twbx</code> workbook.</p>
    <p class="normal">Just as we did before, we'll start by dragging the <strong class="screen-text">Hospital Visit</strong> table onto the data source canvas such that we have a <strong class="screen-text">Hospital Visit</strong> object in the logical layer, like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.19: After dragging the table onto the canvas, the Hospital Visit object is created in the logical layer</p>
    <p class="normal">At this point, the logical<a id="_idIndexMarker1108"/> layer object simply contains a single physical table. But we'll extend that next. Double-click on the <strong class="screen-text">Hospital Visit</strong> object to expand the physical layer. It will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.20: The physical layer, which currently consists of a single physical table</p>
    <p class="normal">You can extend the physical model by adding additional tables. We'll do that here, by adding <strong class="screen-text">Discharge Detail </strong>and <strong class="screen-text">Patient</strong>. As we add them, Tableau will prompt you with a dialog box to adjust the details of the join. It will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.21: Joining Discharge Detail to Hospital Visit in the physical layer</p>
    <p class="normal">The <strong class="screen-text">Join</strong> dialog allows you to specify the join type (<strong class="screen-text">Inner</strong>, <strong class="screen-text">Left</strong>, <strong class="screen-text">Right</strong>, or <strong class="screen-text">Full Outer</strong>) and to specify one or<a id="_idIndexMarker1109"/> more fields on which to join. Between the fields, you may select which kind of operator joins the fields. The default is equality (<strong class="screen-text">=</strong>; the fields must be equal), but you may also select inequality (<code class="Code-In-Text--PACKT-">&lt;&gt;</code>; the fields must not be equal), less than (<code class="Code-In-Text--PACKT-">&lt;</code>), less than or equal to (<code class="Code-In-Text--PACKT-">&lt;=</code>), greater than (<code class="Code-In-Text--PACKT-">&gt;</code>), or greater than or equal to (<code class="Code-In-Text--PACKT-">&gt;=</code>). The type of join and the field relationships that define the join will determine how many records are returned from the join. We'll take a look at the details in the next section.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Typically, you'll want to start by dragging the primary table onto the physical layer canvas. In this case, <strong class="screen-text">Hospital Visit</strong> contains keys to join additional tables. Additional tables should be dragged and dropped after the primary table.</p>
    </div>
    <p class="normal">For now, accept the fields that Tableau automatically detects as shared between the tables (<strong class="screen-text">Discharge Details ID</strong> for <strong class="screen-text">Discharge Details</strong> and <strong class="screen-text">Patient ID</strong> for <strong class="screen-text">Patient</strong>). Change the join to <strong class="screen-text">Discharge Details</strong> to a left join. This means that all hospital visits will be included, even if there has not yet been a discharge. Leave <strong class="screen-text">Patient</strong> as an inner join. This will return only records that are shared between the tables so that only patients with visits will be retained.</p>
    <p class="normal">Ultimately, the physical layer for <strong class="screen-text">Hospital Visit</strong> will look like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.22: The physical layer is made up of three tables joined together</p>
    <p class="normal">When you close <a id="_idIndexMarker1110"/>the physical layer, you'll once again see the logical layer, which contains a single object: <strong class="screen-text">Hospital Visit</strong>. That object now contains a join icon, indicating that it is made up of joined physical tables. But it remains a single object in the logical layer of the data model and looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.23: The logical layer contains a single object that is made up of three physical tables</p>
    <p class="normal">All the joins create what you might think of as one flat table, which can be related together with other objects in the data model. Those objects, in turn, might each be made up of a single physical table or multiple physical tables joined together.</p>
    <p class="normal">If you are following <a id="_idIndexMarker1111"/>along with the example, rename this data source <strong class="screen-text">Hospital Visits (Joins)</strong>. We'll leverage this data source for one more example at the end of this chapter. In the meantime, let's consider a few additional details related to joins.</p>
    <h2 id="_idParaDest-251" class="title">Other join considerations</h2>
    <p class="normal">We conclude this section <a id="_idIndexMarker1112"/>with some further possibilities to leverage joins, as well as a caution regarding a potential problem that can arise from their use.</p>
    <h3 id="_idParaDest-252" class="title">Join calculations</h3>
    <p class="normal">In the previous <a id="_idIndexMarker1113"/>example, we noted that Tableau <strong class="bold">joins</strong> row-by-row based on fields in <a id="_idIndexMarker1114"/>the data. You may come across cases where you need to join based on values that are not present in the data but can be derived from the existing data. For example, imagine that there is a <strong class="screen-text">Patient Profile</strong> table that would add significant value to your dataset. However, it lacks a <strong class="screen-text">Patient ID</strong><strong class="bold"> </strong>and only has <strong class="screen-text">First Name</strong> and <strong class="screen-text">Last Name</strong> fields.</p>
    <p class="normal">To join this to our <strong class="screen-text">Patient</strong> table, we can use a <strong class="bold">join calculation</strong>. This is a calculation that exists only for the purpose of joining tables together. To create a join calculation, use the drop-down list of fields in the <strong class="screen-text">Join</strong> dialog box and select the final option, <strong class="screen-text">Create Join Calculation</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.24: You can create a join calculation to aid in forming the correct joins</p>
    <p class="normal">Selecting this option allows you to write row-level calculations that can be used in the join. For example, our join calculation might have code like <code class="Code-In-Text--PACKT-">[First Name] + " " + [Last Name]</code> to return values that match with the <strong class="screen-text">Name</strong> field.</p>
    <div class="packt_tip">
      <p>Try to avoid joining on text fields, especially in larger datasets for performance reasons. Joining on integers is far more efficient. Also, it is entirely possible for two separate people to share first and last names, so a real-world dataset that followed the structure in this example would be subject to false matches and errors.</p>
    </div>
    <p class="normal">You may also<a id="_idIndexMarker1115"/> leverage the geospatial functions mentioned in <em class="italics">Chapter 12</em>, <em class="italics">Exploring Mapping and Advanced Geospatial Features</em>, to create a spatial join between two<a id="_idIndexMarker1116"/> sources, even when one or both lack specific spatial objects on which to join. For example, if you have <code class="Code-In-Text--PACKT-">Latitude</code> and <code class="Code-In-Text--PACKT-">Longitude</code>, you might create a join calculation with the code <code class="Code-In-Text--PACKT-">MAKEPOINT([Latitude], [Longitude])</code> to find the intersection with another spatial object in another table.</p>
    <p class="normal">Join calculations can also help when you are missing a field for a join. What if the data you want to join is in another database or file completely? In this scenario, we would consider cross-database joins.</p>
    <h3 id="_idParaDest-253" class="title">Cross-database joins</h3>
    <p class="normal">With Tableau, you have the ability to join (at the row level) across multiple different data connections. Joining across<a id="_idIndexMarker1117"/> different data connections is referred to as a <strong class="bold">cross-database join</strong>. For example, you can join SQL Server tables with text files or Excel files, or join tables in one database with tables in another, even if they are on a different server. This opens up all kinds of possibilities for supplementing your data or analyzing data from disparate sources.</p>
    <p class="normal">Consider the hospital data. Though not part of the data included the <code class="Code-In-Text--PACKT-">Chapter 13</code> file set, it would not be uncommon for billing data to be in a separate system from patient care data. Let's say you had a file for patient billing that contained data you wanted to include in your analysis of hospital visits. You would be able to accomplish this by adding the text file as a data connection and then joining it to the existing tables, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.25: Joining tables or files based on separate data connections</p>
    <p class="normal">You'll notice that the interface on the <strong class="bold">Data Source</strong> screen includes an <strong class="screen-text">Add</strong> link that allows you to add data connections to a data source. Clicking on each connection will allow you to drag<a id="_idIndexMarker1118"/> and drop tables from that connection into the <strong class="bold">Data Source</strong> designer and specify the joins as you desire. Each data connection will be color-coded so that you can immediately identify the source of various tables in the designer.</p>
    <p class="normal">You may also use multiple data sources in the logical layer.</p>
    <p class="normal">Another consideration with joins is an unintentional error, which we'll consider next.</p>
    <h3 id="_idParaDest-254" class="title">The unintentional duplication of data</h3>
    <p class="normal">Finally, we conclude<a id="_idIndexMarker1119"/> with a warning about joins—if you are not careful, you could potentially end up with a few extra rows or many times the number of records than you were expecting. Let's consider a theoretical example:</p>
    <p class="normal">Let's say you have a <code class="Code-In-Text--PACKT-">Visit</code> table like this:</p>
    <table id="table001-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Visit ID</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Patient Name</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Doctor ID</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Kirk</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">1</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Picard</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">3</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Sisko</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">3</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">And a <code class="Code-In-Text--PACKT-">Doctor</code> table like this:</p>
    <table id="table002-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Doctor ID</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Doctor Name</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">McCoy</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Crusher</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">3</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Bashir</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Pulaski</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Notice that the value <code class="Code-In-Text--PACKT-">2</code> for <code class="Code-In-Text--PACKT-">Doctor ID</code> occurs twice in the <code class="Code-In-Text--PACKT-">Doctor</code> table. Joining the table on equality between the <code class="Code-In-Text--PACKT-">Doctor ID</code> value will result in duplicate records, regardless of which join type is used. Such a join would result in the following dataset:</p>
    <table id="table003-1" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Visit ID</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Patient Name</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Doctor ID</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Doctor Name</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Kirk</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">1</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">McCoy</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Picard</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Crusher</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">3</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Sisko</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">3</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Bashir</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Picard</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">2</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">Pulaski</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">This will greatly impact your analysis. For example, if you were counting the number of rows to determine <a id="_idIndexMarker1120"/>how many patient visits had occurred, you'd overcount. There are times when you may want to intentionally create duplicate records to aid in analysis; however, often, this will appear as an unintentional error.</p>
    <div class="packt_tip">
      <p>In addition to the danger of unintentionally duplicating data and ending up with extra rows, there's also the possibility of losing rows where values you expected to match didn't match exactly. Get into the habit of verifying the row count of any data sources where you use joins.</p>
    </div>
    <p class="normal">A solid understanding of joins will not only help you as you leverage Tableau Desktop and Tableau Server, but it will also give you a solid foundation when we look at Tableau Prep in <em class="italics">Chapter 15</em>, <em class="italics">Taming Data with Tableau Prep</em>. For now, let's wrap up this chapter with a brief look at blends.</p>
    <h1 id="_idParaDest-255" class="title">Using blends</h1>
    <p class="normal"><strong class="bold">Data blending</strong> allows <a id="_idIndexMarker1121"/>you to use data from multiple data sources in the same view. Often, these sources may be of different types. For example, you can blend data from Oracle with data from Excel. You can blend Google Analytics data with a spatial file. Data blending also allows you to compare data at different levels of detail. Let's consider the basics and a simple example.</p>
    <p class="normal">Data blending is done at an aggregate level and involves different queries sent to each data source, unlike joining, which is done at the row level and (conceptually) involves a single query to a single data source. A simple data blending process involves several steps, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.26: How Tableau accomplishes blending</p>
    <p class="normal">We can see the <a id="_idIndexMarker1122"/>following from the preceding diagram:</p>
    <ol>
      <li class="list">Tableau issues a query to the primary data source.</li>
      <li class="list">The underlying data engine returns aggregate results.</li>
      <li class="list">Tableau issues another query to the secondary data source. This query is filtered based on the set of values returned from the primary data source for dimensions that link the two data sources.</li>
      <li class="list">The underlying data engine returns aggregate results from the secondary data source.</li>
    
      <li class="list" value="5">The aggregated results from the primary data source and the aggregated results from the secondary data source are blended together in the cache.</li>
    </ol>
    <p class="normal">It is important to note that data blending is different from joining. Joins are accomplished in a single query and results are matched row-by-row. Data blending occurs by issuing two separate queries and then blending together the aggregate results.</p>
    <p class="normal">There can only be one primary source, but there can be as many secondary sources as you desire. <em class="italics">Steps 3</em> and <em class="italics">4</em> are repeated for each secondary source. When all aggregated results have been returned, Tableau matches the aggregated rows based on linking fields.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">When you have more than one data source in a Tableau workbook, whichever source you use first in a view becomes the primary source for that view.</p>
      <p class="Information-Box--PACKT-">Blending is view-specific. You can have one data source as the primary in one view and the same data source as the secondary in another. Any data source can be used in a blend, but OLAP cubes, such as in SQL Server Analysis Services, must be used as the primary source.</p>
    </div>
    <p class="normal">In many ways, blending is similar to creating a data model with two or more objects. In many cases, the data<a id="_idIndexMarker1123"/> model will give you exactly what you need without using blending. However, you have a lot more flexibility with blending because you can change which fields are related at a view level rather than at an object level.</p>
    <p class="normal"><strong class="bold">Linking fields</strong> are<a id="_idIndexMarker1124"/> dimensions that are used to match data blended between primary and secondary data sources. Linking fields define the level of detail for the secondary source. Linking fields are automatically assigned if fields match by name and type between data sources. </p>
    <p class="normal">Otherwise, you can manually assign relationships between fields by selecting, from the menu, <strong class="screen-text">Data</strong> | <strong class="screen-text">Edit Blend Relationships</strong>, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.27: Defining blending relationships between data sources</p>
    <p class="normal">The <strong class="screen-text">Relationships</strong> window will display the relationships recognized between different data sources. You can switch from <strong class="screen-text">Automatic</strong> to <strong class="screen-text">Custom</strong> to define your own linking fields.</p>
    <p class="normal">Linking fields can be activated or deactivated to blend in a view. Linking fields used in the view will usually be active by default, while other fields will not. You can, however, change whether a linking field is active or not by clicking on the link icon next to a linking field in the data pane.</p>
    <div class="packt_tip">
      <p>Additionally, use the <strong class="screen-text">Edit Data Relationships</strong> screen to define the fields that will be<a id="_idIndexMarker1125"/> used for <strong class="bold">cross-data source filters</strong>. When you use the <a id="_idIndexMarker1126"/>drop-down menu of a field on <strong class="screen-text">Filters</strong> in a view, and select <strong class="screen-text">Apply to Worksheets</strong> | <strong class="screen-text">All Using Related Data Sources</strong>, the filter works across data sources.</p>
    </div>
    <p class="normal">Let's take this from the conceptual to the practical with an example.</p>
    <h2 id="_idParaDest-256" class="title">A blending example</h2>
    <p class="normal">Let's look at a quick <a id="_idIndexMarker1127"/>example of blending in action. Let's say you have the following table representing the service goals of various locations throughout the hospital when it comes to serving patients:</p>
    <table id="table004" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Location</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Avg. Minutes to Service Goal</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Inpatient Surgery</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">30</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Outpatient Surgery</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">40</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">ICU</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">30</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">OBGYN</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">25</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Lab</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">120</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">This data is contained in a simple text file, named <code class="Code-In-Text--PACKT-">Location Goals.txt</code>, in the <code class="Code-In-Text--PACKT-">Chapter 13</code> directory. Both the starter and complete workbooks already contain a data source defined for the file.</p>
    <p class="normal">We'll start by creating a simple bar chart from the <strong class="screen-text">Hospital Visit (Joins)</strong><strong class="bold"> </strong>data source you created previously, showing the <strong class="screen-text">Average Minutes to Service by Location</strong> like so:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.28: Average Minutes to Service by Location</p>
    <p class="normal">Then, in <a id="_idIndexMarker1128"/>the <strong class="screen-text">Data</strong> pane, we'll select the <strong class="screen-text">Location Goals</strong> data source. Observe the <strong class="screen-text">Data</strong> pane shown here:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.29: Hospital Visit (Joins) is shown as the Primary data source and Location in the Location Goals data source is indicated as a linking field</p>
    <p class="normal">The blue checkmark on the <strong class="screen-text">Hospital Visit (Joins)</strong> data source (numbered <strong class="screen-text">1</strong> in <em class="italics">Figure 13.29</em>) indicates that the data source is primary. Tableau recognizes <strong class="screen-text">Location</strong> as a linking field and indicates that it is active with a connected link icon (numbered <strong class="screen-text">2</strong> in <em class="italics">Figure 13.29</em>). It is active because you have used <strong class="screen-text">Location</strong> from the primary data source in the current view. If you had not, Tableau would still show the link, but it would not be active by default. You may click on the link icon to switch from active to inactive or vice versa to control the level of detail at which aggregations are done in the secondary source.</p>
    <p class="normal">For now, click on <strong class="screen-text">Avg. Minutes to Service Goal</strong> in the data pane and select <strong class="screen-text">Bullet Graph</strong> from <strong class="screen-text">Show Me</strong>, as<a id="_idIndexMarker1129"/> indicated here:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.30: You may drag and drop fields from secondary sources into the view or use Show Me </p>
    <p class="normal">You may have to right-click on the <strong class="screen-text">Avg. Minutes to Service</strong> axis in the view and select the <strong class="screen-text">Swap Reference Line</strong> fields to ensure the goal is the reference line and the bar is the actual metric. Your view should now look like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.31: A view created from a primary source and a secondary source</p>
    <p class="normal">Notice that both the <strong class="screen-text">Hospital Visits (Joins)</strong> data source and the <strong class="screen-text">Location Goals</strong> data source are used in this view. <strong class="screen-text">Hospital Visit (Joins)</strong> is the primary data source (indicated by a blue<a id="_idIndexMarker1130"/> checkmark), while <strong class="screen-text">Location Goals</strong> is the secondary source (indicated by the orange checkmark). The <strong class="screen-text">Avg. Minutes to Service Goal</strong> field on <strong class="screen-text">Detail</strong> in the <strong class="screen-text">Marks</strong> card is secondary and also indicated by an icon with an orange checkmark.</p>
    <p class="normal">You may also notice that <strong class="screen-text">Main Hospital</strong> and <strong class="screen-text">Intensive Care</strong> do not have goals indicated in the view. Recall that the primary data source is used to determine the full list of values shown in the view. <strong class="screen-text">Main Hospital</strong> is in the primary source but does not have a match in the secondary source. It is shown in the view, but it does not have a secondary source value.</p>
    <p class="normal"><strong class="screen-text">Intensive Care</strong> also does not have a secondary value. This is because the corresponding value in the secondary source is <strong class="screen-text">ICU</strong>. Values must match exactly between the primary and secondary sources for a blend to find matches. However, blends do also take into account aliases.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">An <strong class="bold">alias</strong> is an alternate value for a dimension value that will be used for display and data blending. Aliases for dimensions can be changed by right-clicking on row headers or using the menu on the field in the view or the data pane and selecting the <strong class="screen-text">Aliases</strong> option.</p>
    </div>
    <p class="normal">We can change the alias of a field by right-clicking on the row header in the view and using the <strong class="screen-text">Edit Alias…</strong> option, as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_32.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.32: Using the Edit Alias... option</p>
    <p class="normal">If we change the<a id="_idIndexMarker1131"/> alias to <strong class="screen-text">ICU</strong>, a match is found in the secondary source and our view reflects the secondary value:</p>
    <figure class="mediaobject"><img src="../Images/B16021_13_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.33: ICU now finds a match in the secondary source</p>
    <p class="normal">A final value for <strong class="screen-text">Location</strong>, <strong class="screen-text">Lab</strong>, only occurs in the <code class="Code-In-Text--PACKT-">Location Goals.txt</code> source and is, therefore, not shown in this view. If we were to create a new view and use <strong class="screen-text">Location Goals</strong> as the primary source, it would show.</p>
    <p class="normal">We've covered<a id="_idIndexMarker1132"/> quite a few options regarding how to relate data in this chapter. Let's just take a moment to consider when to use these different techniques.</p>
    <h1 id="_idParaDest-257" class="title">When to use a data model, joins, or blends</h1>
    <p class="normal">In one sense, every <a id="_idIndexMarker1133"/>data source you create using the latest versions of Tableau<a id="_idIndexMarker1134"/> will use a data model. Even data sources using one physical table will<a id="_idIndexMarker1135"/> have a corresponding object in the logical layer of a data model. But when should you relate tables using the data model, when should you join them together in the physical layer, and when should you employ blending?</p>
    <p class="normal">Most of the time, there's no single right or wrong answer. However, here are some general guidelines to help you think through when it's appropriate to use a given approach.</p>
    <p class="normal">In general, use a <strong class="bold">data model</strong> to relate tables:</p>
    <ul>
      <li class="list">When joins would<a id="_idIndexMarker1136"/> make correct aggregations impossible or require complex LOD expressions to get accurate results</li>
      <li class="list">When joins would result in the duplication of data</li>
      <li class="list">When you need flexibility in showing full domains of dimensions versus only values that match across relationships</li>
      <li class="list">When you are uncertain of a data source and wouldn't know what type of join to use</li>
    </ul>
    <p class="normal">In general, use <strong class="bold">joins</strong> at the <a id="_idIndexMarker1137"/>physical level:</p>
    <ul>
      <li class="list">When you must use an operator other than equality between fields</li>
      <li class="list">When you want to do a spatial join</li>
      <li class="list">When you want to specifically control the type of join used in your analysis</li>
      <li class="list">When the performance of the data model is less efficient than it would be with the use of joins</li>
    </ul>
    <p class="normal">In general, use <strong class="bold">blending</strong> when:</p>
    <ul>
      <li class="list">You need to relate data<a id="_idIndexMarker1138"/> sources that cannot be joined or related using a data model (such as OLAP cubes)</li>
      <li class="list">You need flexibility to "fix" matching using aliases</li>
      <li class="list">You need flexibility to adjust which fields define the relationship differently in different views</li>
    </ul>
    <p class="normal">As you grow in confidence while using each of these approaches, you'll be able to better determine which makes sense in a given circumstance.</p>
    <h1 id="_idParaDest-258" class="title">Summary</h1>
    <p class="normal">You now have several techniques to turn to when you need to relate tables of data together. The data model, a new feature in the latest versions of Tableau, gives a new paradigm for relating logical tables of data together. It introduces a few new behaviors when it comes to showing the full and partial domains of dimensional values, but it also greatly simplifies aggregations by taking into account the natural level of detail for the aggregation. In the physical layer, you have the option of joining together physical tables.</p>
    <p class="normal">We covered the various types of joins and discussed possibilities for using join calculations and cross-database joins for ultimate flexibility. We briefly discussed how data blending works and saw a practical example. Finally, you examined a broad outline of when to turn to each approach. You now have a broad toolset to tackle data in different tables or even in different databases or files.</p>
    <p class="normal">We'll expand that toolset quite a bit more in the next chapter as we look at Tableau Prep Builder. Tableau Prep gives you incredible power and sophistication, allowing you to bring together data from various sources, clean it, and structure it in any way you like!</p>
  </div>
</body></html>