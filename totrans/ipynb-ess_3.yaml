- en: Chapter 3. Graphics with matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter explores matplotlib, an IPython library for production of publication-quality
    graphs. In this chapter, the following topics will be discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: Two-dimensional plots using the `plot` function and setting up line widths,
    colors, and styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plot configuration and annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three-dimensional plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being an IPython library, matplotlib consists of a hierarchy of classes, and
    it is possible to code using it in the usual object-oriented style. However, matplotlib
    also supports an **interactive** mode. In this mode, the graphs are constructed
    step-by-step, thus adding and configuring each component at a time. We lay emphasis
    on the second approach since it is designed for the rapid production of graphs.
    The object-oriented style will be explained whenever it is needed or leads to
    better results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sense in which the word *interactive* is used in this context is somewhat
    different from what is understood today. Graphs produced by matplotlib are not
    interactive in the sense that the user can manipulate the graphs once they have
    been rendered in the notebook. Instead, the terminology comes from the time when
    matplotlib was used mostly in command-line mode, and each new line of code modified
    the existing plots. Curiously, the software that was the original inspiration
    for matplotlib still uses a command line-based interface.
  prefs: []
  type: TYPE_NORMAL
- en: The plot function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `plot()` function is the workhorse of the matplotlib library. In this section,
    we will explore the line-plotting and formatting capabilities included in this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a bit more concrete, let''s consider the formula for **logistic
    growth**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The plot function](img/8341OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This model is frequently used to represent growth that shows an initial exponential
    phase, and then is eventually limited by some factor. The examples are the population
    in an environment with limited resources and new products and/or technological
    innovations, which initially attract a small and quickly growing market but eventually
    reach a saturation point.
  prefs: []
  type: TYPE_NORMAL
- en: A common strategy to understand a mathematical model is to investigate how it
    changes as the parameters defining it are modified. Let's say, we want to see
    what happens to the shape of the curve when the parameter *b* changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to do what we want more efficiently, we are going to use a **function
    factory**. This way, we can quickly create logistic models with arbitrary values
    for *r*, *a*, *b*, and *c*. Run the following code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The function factory pattern takes advantage of the fact that functions are
    **first-class objects** in Python. This means that functions can be treated as
    regular objects: they can be assigned to variables, stored in lists in dictionaries,
    and play the role of arguments and/or return values in other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we define the `make_logistic()` function, whose output is itself
    a Python function. Notice how the `f_logistic()` function is defined *inside*
    the body of `make_logistic()` and then returned in the last line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the function factory to create three functions representing
    logistic curves, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first fix the values of `r`, `a`, and `c`, and define
    three logistic curves for different values of *b*. The important point to notice
    is that `logistic1`, `logistic2`, and `logistic3` are functions. So, for example,
    we can use `logistic1(2.5)` to compute the value of the first logistic curve at
    the time 2.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now plot the functions using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line in the preceding code sets the maximum time value, `tmax`, to
    be `40`. Then, we define the set of times at which we want the functions evaluated
    with the assignment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `linspace()` function is very convenient to generate points for plotting.
    The preceding code creates an array of 300 equally spaced points in the interval
    from `0` to `tmax`. Note that, contrary to other functions, such as `range()`
    and `arange()`, the right endpoint of the interval is included by default. (To
    exclude the right endpoint, use the `endpoint=False` option.)
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining the array of time values, the `plot()` function is called to
    graph the curves. In its most basic form, it plots a single curve in a default
    color and line style. In this usage, the two arguments are two arrays. The first
    array gives the horizontal coordinates of the points being plotted, and the second
    array gives the vertical coordinates. A typical example will be the following
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables `x` and `y` must refer to `NumPy` arrays (or any Python iterable
    values that can be converted into an array) and must have the same dimensions.
    The points plotted have coordinates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce the following plot, displaying the three
    logistic curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The plot function](img/8341OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may have noticed that before the graph is displayed, there is a line of
    text output that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the return value of the last call to the `plot()` function, which is
    a list (or with a single element) of objects of the `Line2D` type. One way to
    prevent the output from being shown is to enter `None` as the last row in the
    cell. Alternatively, we can assign the return value of the last call in the cell
    to a dummy variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plot()` function supports plotting several curves in the same function
    call. We need to change the contents of the cell that are shown in the following
    code and run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This form saves some typing but turns out to be a little less flexible when
    it comes to customizing line options. Notice that the text output produced now
    is a list with three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This output can be useful in some instances. For now, we will stick with using
    one call to `plot()` for each curve, since it produces code that is clearer and
    more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change the line options in the plot and set the plot bounds. Change
    the contents of the cell to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command lines will produce the following plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The plot function](img/8341OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The options set in the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first curve is plotted with a line width of `1.5`, with the HTML color of
    `DarkGreen`, and a filled-line style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second curve is plotted with a line width of `2.0`, colored with the RGB
    value given by the hexadecimal string `#8B0000`, and a dotted-line style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third curve is plotted with a line width of `3.0`, colored with the RGB
    components, `(0.0, 0.0, 0.5)`, and a dashed-line style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that there are different ways of specifying a fixed color: a HTML color
    name, a hexadecimal string, or a tuple of floating-point values. In the last case,
    the entries in the tuple represent the intensity of the red, green, and blue colors,
    respectively, and must be floating-point values between `0.0` and `1.0`. A complete
    list of HTML name colors can be found at [http://www.w3schools.com/html/html_colornames.asp](http://www.w3schools.com/html/html_colornames.asp).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line styles are specified by a symbolic string. The allowed values are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol string | Line style |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ''`-`'' | Solid (the default) |'
  prefs: []
  type: TYPE_TB
- en: '| ''`--`'' | Dashed |'
  prefs: []
  type: TYPE_TB
- en: '| ''`:`'' | Dotted |'
  prefs: []
  type: TYPE_TB
- en: '| ''`-.`'' | Dash-dot |'
  prefs: []
  type: TYPE_TB
- en: '| ''`None`'', '''', `or` '''' | Not displayed |'
  prefs: []
  type: TYPE_TB
- en: 'After the calls to `plot()`, we set the graph bounds with the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The argument to `axis()` is a four-element list that specifies, in this order,
    the maximum and minimum values of the horizontal coordinates, and the maximum
    and minimum values of the vertical coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem non-intuitive that the bounds for the variables are set after the
    plots are drawn. In the interactive mode, matplotlib remembers the state of the
    graph being constructed, and graphics objects are updated in the background after
    each command is issued. The graph is only rendered when all computations in the
    cell are done so that all previously specified options take effect. Note that
    starting a new cell clears all the graph data. This interactive behavior is part
    of the `matplotlib.pyplot` module, which is one of the components imported by
    `pylab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides drawing a line connecting the data points, it is also possible to draw
    markers at specified points. Change the graphing commands indicated in the following
    code snippet, and then run the cell again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the graph will look as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The plot function](img/8341OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only difference from the previous code is that now we added options to
    draw markers. The following are the options we use:'
  prefs: []
  type: TYPE_NORMAL
- en: The `marker` option specifies the shape of the marker. Shapes are given as symbolic
    strings. In the preceding examples, we use `'o'` for a circular marker, `'s'`
    for a square, and `'*'` for a star. A complete list of available markers can be
    found at [http://matplotlib.org/api/markers_api.html#module-matplotlib.markers](http://matplotlib.org/api/markers_api.html#module-matplotlib.markers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `markevery` option specifies a stride within the data points for the placement
    of markers. In our example, we place a marker after every 50 data points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `markercolor` option specifies the color of the marker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `markersize` option specifies the size of the marker. The size is given
    in pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a large number of other options that can be applied to lines in matplotlib.
    A complete list is available at [http://matplotlib.org/api/artist_api.html#module-matplotlib.lines](http://matplotlib.org/api/artist_api.html#module-matplotlib.lines).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a title, labels, and a legend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to add a title and labels for the axes. Just before the `None`
    line, add the following three lines of code to the cell that creates the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we call the `title()` function to set the title of the plot.
    The argument can be any Python string. In our example, we use a formatted string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We use the `format()` method of the string class. The formats are placed between
    braces, as in `{:5.2f}`, which specifies a floating-point format with five spaces
    and two digits of precision. Each of the format specifiers is then associated
    sequentially with one of the data arguments of the method. Some of the details
    of string formatting are covered in [Appendix B](apb.html "Appendix B. A Brief
    Review of Python"), *A Brief Review of Python*, and the full documentation is
    available at [https://docs.python.org/2/library/string.html](https://docs.python.org/2/library/string.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The axis labels are set in the calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As in the `title()` functions, the `xlabel()` and `ylabel()` functions accept
    any Python string. Note that in the '`$t$`' and '`$N(t)=a/(b+ce^{-rt}$`' strings,
    we use LaTeX to format the mathematical formulas. This is indicated by the dollar
    signs, `$...$`, in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the addition of a title and labels, our graph looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a title, labels, and a legend](img/8341OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need a way to identify each of the curves in the picture. One way
    to do that is to use a `legend`, which is indicated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `legend()` function accepts a list of strings. Each string is associated
    with a curve in the order they are added to the plot. Notice that we are again
    using formatted strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the preceding code does not produce great results. The legend,
    by default, is placed in the top-right corner of the plot, which, in this case,
    hides part of the graph. This is easily fixed using the `loc` option in the `legend`
    function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code, we obtain the final version of our logistic growth plot,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a title, labels, and a legend](img/8341OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The legend location can be any of the strings: `''best''`, `''upper right''`,
    `''upper left''`, `''lower left''`, `''lower right''`, `''right''`, `''center
    left''`, `''center right''`, `''lower center''`, `''upper center''`, and `''center''`.
    It is also possible to specify the location of the legend precisely with the `bbox_to_anchor`
    option. To see how this works, modify the code for the legend as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `bbox_to_anchor` option, by default, uses a coordinate system
    that is not the same as the one we specified for the plot. The *x* and *y* coordinates
    of the box in the preceding example are interpreted as a fraction of the width
    and height, respectively, of the whole figure. A little trial-and-error is necessary
    to place the legend box precisely where we want it. Note that the legend box can
    be placed outside the plot area. For example, try the coordinates `(1.32,1.02)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `legend()` function is quite flexible and has quite a few other options
    that are documented at [http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend](http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend).
  prefs: []
  type: TYPE_NORMAL
- en: Text and annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, we will show how to add annotations to plots in matplotlib.
    We will build a plot demonstrating the fact that the tangent to a curve must be
    horizontal at the highest and lowest points. We start by defining the function
    associated with the curve and the set of values at which we want the curve to
    be plotted, which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line in the preceding code uses a lambda expression to define the
    `f()` function. We use this approach here because the formula for the function
    is a simple, one-line expression. The general form of a lambda expression is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This expression by itself creates an anonymous function that can be used in
    any place that a function object is expected. Note that the return value must
    be a single expression and cannot contain any statements.
  prefs: []
  type: TYPE_NORMAL
- en: The formula for the function may seem unusual, but it was chosen by trial-and-error
    and a little bit of calculus so that it produces a nice graph in the interval
    from `0` to `5`. The `xvalues` array is defined to contain 200 equally spaced
    points on this interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an initial plot of our curve, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code in this segment is explained in the previous section. The only
    new bit is that we use the `grid()` function to draw a grid. Used with no arguments,
    the grid coincides with the tick marks on the plot. As everything else in matplotlib,
    grids are highly customizable. Check the documentation at [http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid](http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.grid).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding code is executed, the following plot is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text and annotations](img/8341OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the curve has a highest point (*maximum*) and a lowest point (*minimum*).
    These are collectively called the *extreme values* of the function (on the displayed
    interval, this function actually grows without bounds as *x* becomes large). We
    would like to locate these on the plot with annotations. We will first store the
    relevant points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables, `x_min` and `f_min`, are defined to be (approximately) the coordinates
    of the lowest point in the graph. Analogously, `x_max` and `f_max` represent the
    highest point. Don''t be concerned with how these points were found. For the purposes
    of graphing, even a rough approximation by trial-and-error would suffice. In [Chapter
    5](ch05.html "Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro"),
    *Advanced Computing with SciPy, Numba, and NumbaPro*, we will see how to solve
    this kind of problem accurately via SciPy. Now, add the following code to the
    cell that draws the plot, right below the `title()` command, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the cell to produce the plot shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text and annotations](img/8341OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code, start by assigning the variables `arrow_props`, `delta`, and `offset`,
    which will be used to set the arguments in the calls to `annotate()`. The `annotate()`
    function adds a textual annotation to the graph with an optional arrow indicating
    the point being annotated. The first argument of the function is the text of the
    annotation. The next two arguments give the locations of the arrow and the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xy`: This is the point being annotated and will correspond to the tip of the
    arrow. We want this to be the maximum/minimum points, `p_min` and `p_max`, but
    we add/subtract the `delta` vector so that the tip is a bit removed from the actual
    point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xytext`: This is the point where the text will be placed as well as the base
    of the arrow. We specify this as offsets from `p_min` and `p_max` using the `offset`
    vector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other arguments of `annotate()` are formatting options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrowprops`: This is a Python dictionary containing the arrow properties.
    We predefine the dictionary, `arrow_props`, and use it here. Arrows can be quite
    sophisticated in matplotlib, and you are directed to the documentation for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalalignment` and `horizontalalignment`: These specify how the arrow
    should be aligned with the text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fontsize`: This signifies the size of the text. Text is also highly configurable,
    and the reader is directed to the documentation for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `annotate()` function has a huge number of options; for complete details
    of what is available, users should consult the documentation at [http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate](http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.annotate)
    for the full details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to add a comment for what is being demonstrated by the plot by
    adding an explanatory textbox. Add the following code to the cell right after
    the calls to `annotate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `text()`function is used to place text at an arbitrary position of the plot.
    The first two arguments are the position of the textbox, and the third argument
    is a string containing the text to be displayed. Notice the use of `'\n'` to indicate
    a line break. The other arguments are configuration options. The `bbox` argument
    is a dictionary with the options for the box. If omitted, the text will be displayed
    without any surrounding box. In the example code, the box is a rectangle with
    rounded corners, with a border width of 2 pixels and the face color, beige.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final detail, let''s add the tangent lines at the extreme points. Add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the tangents are segments of straight lines, we simply give the coordinates
    of the endpoints. The reason to add the code for the tangents at the top of the
    cell is that this causes them to be plotted first so that the graph of the function
    is drawn at the top of the tangents. This is the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text and annotations](img/8341OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The examples we have seen so far only scratch the surface of what is possible
    with matplotlib. The reader should read the matplotlib documentation for more
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Three-dimensional plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we present methods to display three-dimensional plots, that
    is, plots of mathematical objects in space. Examples include surfaces and lines
    that are not confined to a plate.
  prefs: []
  type: TYPE_NORMAL
- en: 'matplotlib has excellent support for three-dimensional plots. In this section,
    we will present an example of a surface plot and corresponding contour plot. The
    types of plot available in the three-dimensional library include wireframe plots,
    line plots, scatterplots, triangulated surface plots, polygon plots, and several
    others. The following link will help you to understand the types of plots that
    are not treated here: [http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial](http://matplotlib.org/1.3.1/mpl_toolkits/mplot3d/tutorial.html#mplot3d-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we need to import the three-dimensional library objects we
    need using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s draw our surface plot by running the following code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by specifying the `fsurface()` function, which defines the surface.
    The details of the function definition are not relevant; we will just note that
    this is a surface of revolution that has a dip at the center, surrounded by a
    ridge. We then start setting up the figure with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This time, we specifically construct the `Figure` object because we want to
    specify its size explicitly. The size here is defined as an `8` x `8` inch square,
    but this is not quite accurate since the actual size of the figure will depend
    on the resolution of the display and the magnification factor of the browser.
    We then create a subplot and set its projection type to `'3d'`. The `subplot()`
    function will be treated with more detail later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the grid of points where the function is computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important point here is the use of the `meshgrid()` function, which
    is a part of the `NumPy` package. This function takes two one-dimensional arrays,
    with *x* and *y* values and computes two matrices that define the corresponding
    grid of points on the plane. To understand how this works, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The two matrices produced, `XX` and `YY`, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `XX` matrix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `YY` matrix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that, if we take the elements of `XX` and the corresponding entries in
    `YY`, we get the set of points (1,4), (1,5), (1,6), (2,4),…, (3,5), (3,6), which
    are on a regularly spaced grid on the plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to call the function that computes the surface and plot it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first line computes the `Z` array, containing the *z* coordinates of the
    surface. This call makes heavy use of a feature of `NumPy` called **broadcasting**
    in the background. This is a set of rules that tells us how `NumPy` deals with
    operations for arrays with different sizes. For more information, see [http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to call the `plot_surface()` method, which does the actual
    plotting. The first three arguments define the data being plotted, that is, the
    arrays `X`, `Y`, and `Z`. The `cstride` and `rstride` options can be used to skip
    points in the data arrays. Set these to values greater than 1 to skip points in
    the grid, in the event the data set is too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using a **colormap** feature specified by the `cmap=cm.coolwarm` option.
    The colormap feature tells matplotlib how to assign a color to each height in
    the plot. A large number of built-in colormaps are available. To see a complete
    list, run the following lines of code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that three-dimensional surface plots are, by default, not antialiased,
    so we set the `antialiased=True` option in the code to produce a better image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add a contour plot to the graph. We want the three-dimensional surface
    plot and the contour graph to appear side-by-side. To achieve that, modify the
    code in the cell to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the code is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three-dimensional plots](img/8341OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's first concentrate on the `contours()` method. The first argument, `levels`,
    specifies the values (heights) for which the contours are plotted. This argument
    can be left out, and matplotlib will try to choose the heights in a way that makes
    sense. The other arguments are options for how to display the contours. We specify
    the colormap and line width in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The `clabel()` method adds labels to the contours. The first argument, `levels[1::2]`,
    specifies that every second contour is to be labeled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the code that is used to place two axes in the same figure. The axes are
    defined by the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The general form of the `subplot()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies an `Axes` object in an array with `nrows` rows and `ncols` columns.
    The position of the axis is an integer from 1 to `nrows*ncols`. The following
    figure illustrates how the axes are numbered in the case of a 3 x 2 array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Three-dimensional plots](img/8341OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image was generated with the help of the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After defining the figure size in the usual way, we set the number of rows and
    columns of the grid of axes we want to generate. Then, each of the `Axes` objects
    is created and configured in the loop. Look carefully at how the positions of
    the axes are identified. Note also that we show how to set the background color
    of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will finish the chapter with a more complex example that illustrates the
    power that matplotlib gives us. We will create an animation of a forced pendulum,
    a well-known and much studied example of a dynamic system exhibiting deterministic
    chaos.
  prefs: []
  type: TYPE_NORMAL
- en: Since this section involves more sophisticated code, we will refrain from using
    `pylab` and adopt the generally recommended way of importing modules. This makes
    the code easier to export to a script if we so wish. We also give samples of some
    of the object-oriented features of matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of animating a pendulum (or any physical process) is actually very
    simple: we compute the position of the pendulum at a finite number of times and
    display the corresponding images in quick succession. So, the code will naturally
    break down into the following three pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: A function that displays a pendulum in an arbitrary position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the computation of the position of the pendulum at an arbitrary time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code that actually computes the position of the pendulum and displays the
    corresponding images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We start by importing all the modules and functions we need to set up the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will define a function that draws a simple sketch
    of a pendulum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes as the first argument an `Axes` object. The other arguments
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The angle, `theta`, of the pendulum with the vertical surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `length` of the rod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `radius` of the bob
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding quantities are indicated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations](img/8341OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we define a `NumPy` vector, `v`, which holds the position of the pendulum
    relative to the origin. The following statements define the objects to be drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ax.axhline()`: This function draws a horizontal line across the plot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rod`: This is a `lines.Line2D` object (incidentally, this is the object that
    is used to draw most plots in matplotlib)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bob` and `peg`: These are objects of the `patches.Circle` type; matplotlib
    patches represent essentially any kind of object that can be placed in a figure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following lines of code can be used to test the drawing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code in the previous cell will produce the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Animations](img/8341OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following comments indicate how the code in the preceding example works:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines define the variables, `fig` and `ax`, that hold the `Figure`
    and `Axes` objects, respectively. In matplotlib, a `Figure` object is a container
    that holds all other plotting objects. Each `Figure` can contain several `Axes`,
    which contain individual plots. Note the use of the `figsize=(5,5)` argument to
    set the size of the figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we set the axis limits. The `set_aspect()` method of the `ax` object is
    used to set the aspect ratio to be the same in both directions. Without this,
    the circles will be drawn as ellipses. Then, the `set_xlim()` and `set_ylim()`
    methods specify the bounds for the axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then call the `draw_pendulum()` function, which does all the drawing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use `ax.set_xticks([])` and `set_yticks([])` to remove the tick
    marks from the axes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to set up what is needed to find the trajectory to the pendulum.
    The dynamics of a pendulum are given by a system of differential equations, which
    is defined in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code starts by defining the `pendulum_eq()` function, which stipulates
    the differential equations for a pendulum. The derivation of the equations is
    beyond the scope of this book. The remaining code in the cell configures an object
    of the `ode()` type, which is a part of the `scipy.integrate` module. We will
    not discuss the details here, but this module is discussed in [Chapter 5](ch05.html
    "Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro"), *Advanced Computing
    with SciPy, Numba, and NumbaPro*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to run the animation by executing the following code in a
    cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is probably the most complex code segment in the book so far, but most
    of it has already been covered. The variables `tmax` and `dt` hold the maximum
    time for the animation and the time increment, respectively. We then set the `Figure`
    and `Axes` objects for the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then comes a `while` loop, where the animation is actually executed. This is
    the general skeleton of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not discuss in detail the code used to solve the differential equation
    since it will be presented in detail in [Chapter 5](ch05.html "Chapter 5. Advanced
    Computing with SciPy, Numba, and NumbaPro"), *Advanced Computing with SciPy, Numba,
    and NumbaPro*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop has `True` as the looping condition so this is potentially an infinite
    loop. However, inside the loop, we check if the current time is larger than the
    maximum time for the animation, and if that is the case, we break from the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do in the loop is to call the `clear_output()` function.
    This function, as the name indicates, removes the output of the current cell and
    is at the heart of doing simple animations in the notebook. The `wait=True` argument
    tells the function to wait until the next image is fully drawn before clearing
    the output, which prevents flickering.
  prefs: []
  type: TYPE_NORMAL
- en: The `time.sleep(1./20)` argument pauses the computation for a brief period of
    time to prevent the animation from running too fast. Then, a new position of the
    pendulum is computed and plotted. Then, `display(fig)` is called to show the figure.
    This is needed here because, contrary to the case of static graphs, we don't want
    the plot to be shown only at the end of the cell.
  prefs: []
  type: TYPE_NORMAL
- en: The final detail is to call `plt.close()` at the end of the loop. This prevents
    the pendulum image from being drawn one extra time when the loop is exited. Placing
    this call inside the loop also helps to avoid flicker.
  prefs: []
  type: TYPE_NORMAL
- en: The reader is encouraged to play with the parameters of the animation, specially
    the time interval, `dt`; the maximum time, `tmax`; and the `time.sleep()` parameter.
    A bit of trial-and-error is needed to get satisfactory animation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use matplotlib to produce presentation-quality
    plots. We covered two-dimensional plots and how to set plot options, and annotate
    and configure plots. You also learned how to add labels, titles, and legends.
    We also learned how to draw three-dimensional surface plots and how to create
    simple animations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to work with data in the notebook using
    the pandas library.
  prefs: []
  type: TYPE_NORMAL
