<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Namespaces, Scopes, and Modules
                </header>
            
            <article>
                
<p>In this chapter, we'll cover Python modules. Modules are files containing functions and class definitions. The concept of a namespace and the scope of variables across functions and modules are also explained in this chapter.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Namespaces</li>
<li>The scope of a variable</li>
<li>Modules</li>
</ul>
<h1 id="uuid-fa29f837-5dc4-4ab4-bf10-6356272c4053">13.1 Namespaces</h1>
<p>Names of Python objects, such as the names of variables, classes, functions, and modules, are collected in namespaces. Modules and classes have their own named namespaces with the same name as these objects. These namespaces are created when a module is imported or a class is instantiated. The lifetime of a namespace of a module is as long as the current Python session. The lifetime of a namespace of a class instance is until the instance is deleted.</p>
<p>Functions create a local namespace when they are executed (invoked). It is deleted when the function stops the execution with a regular return or an exception. Local namespaces are unnamed.</p>
<p>The concept of namespaces puts a variable name in its context. For example, there are several functions with the name<span> </span><kbd>sin</kbd><span> </span>and they are distinguished by the namespace they belong to, as shown in the following code:</p>
<pre>import math
import numpy
math.sin
numpy.sin</pre>
<p>They are indeed different, as <kbd><span>numpy</span>.sin</kbd><span> </span>is a universal function accepting lists or arrays as input, while <kbd>math.sin</kbd><span> </span>takes only floats. A list with all the names in a particular namespace can be obtained with the command<span> </span><kbd>dir(&lt;name of the namespace&gt;)</kbd>. It contains two special names,<span> </span><kbd>__name__</kbd><span> </span>and<span> </span><kbd>__doc__</kbd>. The former refers to the name of the module and the latter to its docstring:</p>
<pre>math.__name__ # returns math
math.__doc__ # returns 'This module provides access to .....'</pre>
<p>There is a special namespace,<span> </span><kbd>__builtin__</kbd>, which contains names that are available in Python without any<span> </span><kbd>import</kbd>. It is a named namespace but its name needs not be given when referring to a built-in object:</p>
<pre>'float' in dir(__builtin__) # returns True <br/>float is __builtin__.float # returns True</pre>
<p>Let's learn about the scope of a variable in the next section.</p>
<h1 id="uuid-6ac1f097-1049-4ce6-ba7d-f7cb8f3e9f1e">13.2 The scope of a variable</h1>
<p>A variable defined in one part of a program does not need to be known in other parts. All program units to which a certain variable is known are called the <em>scope</em> of that variable. We'll first give an example. Let's consider the two nested functions:</p>
<pre>e = 3
def my_function(in1):
    a = 2 * e
    b = 3
    in1 = 5
    def other_function():
       c = a
       d = e
       return dir()
    print(f"""
          my_function's namespace: {dir()} 
          other_function's namespace: {other_function()}
          """)
    return a</pre>
<p>The execution of<span> </span><kbd>my_function(3)</kbd><span> </span>results in:</p>
<pre>my_function's namespace: ['a', 'b', 'in1', 'other_function'] 
other_function's namespace: ['a', 'c', 'd']</pre>
<p>The variable<span> </span><kbd>e</kbd> is in the namespace of the program unit that encloses the function<span> </span><kbd>my_function</kbd>. The variable<span> </span><kbd>a</kbd> is in the namespace of this function, which itself encloses the innermost function<span> </span><kbd>other_function</kbd>. For the two functions,<span> </span><kbd>e</kbd><span> </span>is a global variable, that is, it is not in the local namespace and not listed by <kbd>dir()</kbd> but its value is available.</p>
<p>It is a good practice to pass information to a function only by its parameter list and not use the construction from the preceding example. An exception can be found in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.7</a>: <em>Anonymous functions</em>, where global variables are used for closures.</p>
<p>By assigning it a value, a variable automatically becomes a local variable:</p>
<pre>e = 3
def my_function():
    e = 4
    a = 2
    print(f"my_function's namespace: {dir()}")</pre>
<p>This can be seen when executing the following code block:</p>
<pre>e = 3
my_function()
e # has the value 3</pre>
<p>The output of the preceding code gives shows us the local variables of <kbd>my_function</kbd>:</p>
<pre>my_function's namespace: ['a', 'e']</pre>
<p>Now, <kbd>e</kbd><span> </span>became a local variable. In fact, this piece of code now has two variables<span> </span><kbd>e</kbd><span> </span>belonging to different namespaces.</p>
<p>By using the<span> </span><kbd>global</kbd><span> </span>declaration statement, a variable defined in a function can be made global, that is, its value will be accessible even outside this function. The use of a<span> </span><kbd>global</kbd><span> </span>declaration is demonstrated as follows:</p>
<pre>def fun():
    def fun1():
        global a
        a = 3
    def fun2():
        global b
        b = 2
        print(a)
    fun1()
    fun2() # prints a
    print(b)</pre>
<p class="mce-root">It would be advisable to avoid using this construct and the use of<span> </span><kbd>global</kbd>. Code using <kbd>global</kbd> is hard to debug and maintain. The use of classes makes the use of <kbd>global</kbd><span> </span>mainly obsolete.</p>
<h1 id="uuid-bd751e11-6b87-432a-9c23-1c7768304308">13.3 Modules</h1>
<p>In Python, a module is simply a file containing classes and functions. By importing the file in your session or script, the functions and classes become usable.</p>
<h2 id="uuid-acc9b64d-0f81-4e9d-b8fa-2d69459246d5">13.3.1 Introduction</h2>
<p>Python comes with many different libraries by default. You may also want to install more of those for specific purposes, such as optimization, plotting, reading/writing file formats, image handling, and so on. NumPy and SciPy are two important examples of such libraries, Matplotlib for plotting is another one. At the end of this chapter, we will list some useful libraries.</p>
<p>To use a library, you may either</p>
<ul>
<li>load only certain objects from a library, for example, from NumPy:</li>
</ul>
<pre style="padding-left: 60px">from numpy import array, vander</pre>
<ul>
<li>load the entire library:</li>
</ul>
<pre style="padding-left: 60px">from numpy import *</pre>
<ul>
<li>or give access to an entire library by creating a namespace with the library name:</li>
</ul>
<pre style="padding-left: 60px">import numpy
...
numpy.array(...)</pre>
<p style="padding-left: 60px">Prefixing a function from the library with the namespace gives access to this function and distinguishes this function from other objects with the same name.</p>
<p>Furthermore, the name of a namespace can be specified together with the<span> </span><kbd>import</kbd><span> </span>command:</p>
<pre>import numpy as np
...
np.array(...)</pre>
<p>Which of these alternatives you use affects the readability of your code as well as the possibilities for mistakes. A common mistake is shadowing:</p>
<pre>from scipy.linalg import eig
A = array([[1,2],[3,4]])
(eig, eigvec) = eig(A)
...
(c, d) = eig(B) # raises an error</pre>
<p>A way to avoid this unintended effect is to use<span> </span><kbd>import</kbd> instead of <kbd>from</kbd> and then access the command by referring to the namespace, here <kbd>sl</kbd>:</p>
<pre>import scipy.linalg as sl
A = array([[1,2],[3,4]])
(eig, eigvec) = sl.eig(A) # eig and sl.eig are different objects
...
(c, d) = sl.eig(B)</pre>
<p>Throughout this book, we have used many commands, objects, and functions. These were imported into the local namespace by statements such as:</p>
<pre>from scipy import *</pre>
<p>Importing objects in this manner does not make the module from which they are imported evident. Some examples are given in the following table (<em>Table 13.1</em>):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Libraries</strong></p>
</td>
<td>
<p><strong>Methods</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>numpy</kbd></p>
</td>
<td>
<p><kbd>array</kbd>,<span> </span><kbd>arange</kbd>,<span> </span><kbd>linspace</kbd>,<span> </span><kbd>vstack</kbd>,<span> </span><kbd>hstack</kbd>,<span> </span><kbd>dot</kbd>,<span> </span><kbd>eye</kbd>,<span> </span><kbd>identity</kbd>, and<span> </span><kbd>zeros</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>scipy.linalg</kbd></p>
</td>
<td>
<p><kbd>solve</kbd>,<span> </span><kbd>lstsq</kbd>,<span> </span><kbd>eig</kbd>, and <kbd>det</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>matplotlib.pyplot</kbd></p>
</td>
<td>
<p><kbd>plot</kbd>,<span> </span><kbd>legend</kbd>, and <kbd>cla</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>scipy.integrate</kbd></p>
</td>
<td>
<p><kbd>quad</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>copy</kbd></p>
</td>
<td>
<p><kbd>copy</kbd> and <kbd>deepcopy</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Table 13.1: Examples of modules and corresponding imported functions</div>
<h2 id="uuid-305f9ffb-8789-4146-ac54-7dad18faff1e">13.3.2 Modules in IPython</h2>
<p>IPython is used in code development. A typical scenario is that you work on a file with some function or class definitions that you change within a development cycle. To load the contents of such a file into the shell, you may use<span> </span><kbd>import</kbd><span> </span>but the file is loaded only once. Changing the file has no effect on later imports. That is where IPython's <em>magic command</em><span> </span><kbd>run</kbd><span> </span>enters the stage.</p>
<h3 id="uuid-a07fceb9-22ba-46b7-9c88-50e60f0faf78">The IPython magic command – run</h3>
<p>IPython has a special <em>magic command</em><span> </span>named<span> </span><kbd>run</kbd> that executes a file as if you were running it directly in Python. This means that the file is executed independently of what is already defined in IPython. This is the recommended method to execute files from within IPython when you want to test a script intended as a standalone program. You must import all you need in the executed file in the same way as if you were executing it from the command line. A typical example of running code in<span> </span><kbd>myfile.py</kbd><span> </span>is:</p>
<pre>from numpy import array
...
a = array(...)</pre>
<p>This script file is executed in Python by<span> </span><kbd>exec(open('myfile.py').read())</kbd>. Alternatively, in IPython the <em>magic command<span> </span></em><kbd>run myfile</kbd><span> </span>can be used if you want to make sure that the script runs independently of the previous imports. Everything that is defined in the file is imported into the IPython workspace.</p>
<h2 id="uuid-5317ad0d-3612-4484-b176-44d305ae377e">13.3.3 The variable __name__</h2>
<p>In any module, the special variable<span> </span><kbd>__name__</kbd><span> </span>is defined as the name of the current module. In the command line (in IPython), this variable is set to<span> </span><kbd>__main__</kbd>. This fact allows the following trick:</p>
<pre># module
import ...

class ...

if __name__ == "__main__":
   # perform some tests here</pre>
<p>The tests will be run only when the file is directly run, <em>not</em> when it is imported as, when imported, the variable <kbd>__name__</kbd> takes the name of the module instead of <kbd>__main__</kbd>.</p>
<h2 id="uuid-4ea23f4a-137a-4a26-9cc5-73f8b8ad159a">13.3.4 Some useful modules</h2>
<p> </p>
<p> </p>
<p>The list of useful Python modules is vast. In the following table, we have given a very short segment of such a list, focused on modules related to mathematical and engineering applications (<em>Table 13.2)</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Module</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>scipy</kbd></p>
</td>
<td>
<p>Functions used in scientific computing</p>
</td>
</tr>
<tr>
<td>
<p><kbd>numpy</kbd></p>
</td>
<td>
<p>Support arrays and related methods</p>
</td>
</tr>
<tr>
<td>
<p><kbd>matplotlib</kbd></p>
</td>
<td>
<p>Plotting and visualization </p>
</td>
</tr>
<tr>
<td>
<p><kbd>functools</kbd></p>
</td>
<td>
<p>Partial application of functions</p>
</td>
</tr>
<tr>
<td>
<p><kbd>itertools</kbd></p>
</td>
<td>
<p>Iterator tools to provide special capabilities, such as slicing to generators</p>
</td>
</tr>
<tr>
<td>
<p><kbd>re</kbd></p>
</td>
<td>
<p>Regular expressions for advanced string handling</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sys</kbd></p>
</td>
<td>
<p>System-specific functions</p>
</td>
</tr>
<tr>
<td>
<p><kbd>os</kbd></p>
</td>
<td>
<p>Operating system interfaces such as directory listing and file handling</p>
</td>
</tr>
<tr>
<td>
<p><kbd>datetime</kbd></p>
</td>
<td>
<p>Representing dates and date increments</p>
</td>
</tr>
<tr>
<td>
<p><kbd>time</kbd></p>
</td>
<td>
<p>Returning wall clock time</p>
</td>
</tr>
<tr>
<td>
<p><kbd>timeit</kbd></p>
</td>
<td>
<p>Measuring execution time</p>
</td>
</tr>
<tr>
<td>
<p><kbd>sympy</kbd></p>
</td>
<td>
<p>Computer arithmetic package (symbolic computations)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>pickle</kbd></p>
</td>
<td>
<p>Pickling, a special file input and output format</p>
</td>
</tr>
<tr>
<td>
<p><kbd>shelves</kbd></p>
</td>
<td>
<p>Shelves, a special file input and output format</p>
</td>
</tr>
<tr>
<td>
<p><kbd>contextlib</kbd></p>
</td>
<td>
<p>Tools for context managers</p>
</td>
</tr>
</tbody>
</table>
<div class="CDPAlignCenter CDPAlign packt_figref">Table 13.2: A non-exhaustive list of useful Python packages for engineering applications</div>
<p class="mce-root">We advise against the use of the mathematics module <kbd>math</kbd> and favor <kbd>numpy</kbd> instead. The reason for this is that many of NumPy's functions, such as <kbd>sin</kbd> operate on arrays, while the corresponding functions in <kbd>math</kbd> don't.</p>
<h1 id="uuid-8d1f8f89-c4b4-4ce4-a3ae-01e479b6bd6a">13.4 Summary</h1>
<p>We started the book by telling you that you had to import SciPy and other useful modules. Now you fully understand what importing means. We introduced namespaces and discussed the difference between<span> </span><kbd>import</kbd><span> </span>and<span> </span><kbd>from ... import *</kbd>. The scope of a variable was already introduced in <span><a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml"/><a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.2.3</a>:</span> <span><em>Access to variables defined outside the local</em><br/>
<em>namespace</em></span><em>,</em> but now you have a more complete picture of the importance of that concept.</p>


            </article>

            
        </section>
    </body></html>