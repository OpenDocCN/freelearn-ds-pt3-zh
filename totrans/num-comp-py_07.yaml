- en: Visualizing Online Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have already covered the basics of creating and customizing
    plots using Matplotlib. In this chapter, we begin the journey of understanding
    more advanced Matplotlib usage through examples in specialized topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the visualization of a concept, the following important factors
    have to be considered carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: Source of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choosing the right plot type for the data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visualizing the trend of data:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Line chart, area chart, and stacked area chart
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visualizing univariate distribution:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bar chart, histogram, and kernel density estimation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visualizing bivariate distribution:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter plot, KDE density chart, and hexbin chart
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visualizing categorical data:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Categorical scatter plot, box plot, swarm plot, violin plot
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting figure aesthetics for effective storytelling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover these topics via the use of demographic and financial data. First,
    we will discuss typical data formats when we fetch data from the **Application
    Programming Interface** (**API**). Next, we will explore how we can integrate
    Matplotlib 2.0 with other Python packages such as Pandas, Scipy, and Seaborn for
    the visualization of different data types.
  prefs: []
  type: TYPE_NORMAL
- en: Typical API data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many websites offer their data via an API, which bridges applications via standardized
    architecture. While we are not going to cover the details of using APIs here as
    site-specific documentation is usually available online; we will show you the
    three most common data formats as used in many APIs.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CSV** (**Comma-Separated Values**) is one of the oldest file formats, which
    was introduced long before the internet even existed. However, it is now becoming
    deprecated as other advanced formats, such as JSON and XML, are gaining popularity.
    As the name suggests, data values are separated by commas. The preinstalled `csv` package
    and the `pandas` package contain classes to read and write data in CSV format.
    This CSV example defines a population table with two countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**) is gaining popularity these days
    due to its efficiency and simplicity. JSON allows the specification of number,
    string, Boolean, array, and object. Python provides the default `json` package
    for parsing JSON. Alternatively, the `pandas.read_json` class can be used to import
    JSON as a Pandas dataframe. The preceding population table can be represented
    as JSON in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**XML** (**eXtensible Markup Language**) is the Swiss Army knife of data formats,
    and it has become the default container for Microsoft Office, Apple iWork, XHTML,
    SVG, and more. XML''s versatility comes with a price, as it makes XML verbose
    and slower. There are several ways to parse XML in Python, but `xml.etree.ElementTree`
    is recommended due to its Pythonic interface, backed by an efficient C backend.
    We are not going to cover XML parsing in this book, but good tutorials exist elsewhere
    (such as [http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree](http://eli.thegreenplace.net/2012/03/15/processing-xml-in-python-with-elementtree)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the same population table can be transformed into XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Introducing pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Beside NumPy and SciPy, pandas is one of the most common scientific computing
    libraries for Python. Its authors aim to make pandas the most powerful and flexible
    open source data analysis and manipulation tool available in any language, and
    in fact, they are almost achieving that goal. Its powerful and efficient library
    is a perfect match for data scientists. Like other Python packages, Pandas can easily be
    installed via PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First introduced in version 1.5, Matplotlib supports the use of pandas DataFrame
    as the input in various plotting classes. Pandas DataFrame is a powerful two-dimensional
    labeled data structure that supports indexing, querying, grouping, merging, and
    some other common relational database operations. DataFrame is similar to spreadsheets
    in the sense that each row of the DataFrame contains different variables of an
    instance, while each column contains a vector of a specific variable across all
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: pandas DataFrame supports heterogeneous data types, such as string, integer,
    and float. By default, rows are indexed sequentially and columns are composed
    of pandas Series. Optional row labels or column labels can be specified through
    the index and columns attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Importing online population data in the CSV format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by looking at the steps to import an online CSV file as a pandas
    DataFrame. In this example, we are going to use the annual population summary
    published by the Department of Economic and Social Affairs, United Nations, in
    2015\. Projected population figures towards 2100 were also included in the dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **LocID** | **Location** | **VarID** | **Variant** | **Time** | **MidPeriod**
    | **SexID** | **Sex** | **AgeGrp** | **AgeGrpStart** | **AgeGrpSpan** | **Value**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 0-4 | 0
    | 5 | 630.044 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 5-9 | 5
    | 5 | 516.205 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 10-14 |
    10 | 5 | 461.378 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 15-19 |
    15 | 5 | 414.368 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 20-24 |
    20 | 5 | 374.110 |'
  prefs: []
  type: TYPE_TB
- en: The `pandas.read_csv` class is extremely versatile, supporting column headers,
    custom delimiters, various compressed formats (for example, `.gzip`, `.bz2`, `.zip`,
    and `.xz`), different text encodings, and much more. Readers can consult the documentation
    page ([http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: By calling the `.head()` function of the Pandas DataFrame object, we can quickly
    observe the first five rows of the data.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this chapter, we are going to integrate this population
    dataset with other datasets in Quandl. However, Quandl uses three-letter country
    codes (ISO 3166 alpha-3) to denote geographical locations; therefore we need to
    reformat the location names accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pycountry` package is an excellent choice for conversion of country names
    according to ISO 3166 standards. Similarly, `pycountry` can be installed through
    PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing the previous code example, we are going to add a new `country` column
    to the dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **-** | **LocID** | **Location** | **VarID** | **Variant** | **Time** | **MidPeriod**
    | **SexID** | **Sex** | **AgeGrp** | **AgeGrpStart** | **AgeGrpSpan** | **Value**
    | **country** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 0-4 | 0 | 5
    | 630.044 | AFG |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 5-9 | 5 | 5
    | 516.205 | AFG |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 10-14 | 10
    | 5 | 461.378 | AFG |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 15-19 | 15
    | 5 | 414.368 | AFG |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | Afghanistan | 2 | Medium | 1950 | 1950.5 | 1 | Male | 20-24 | 20
    | 5 | 374.110 | AFG |'
  prefs: []
  type: TYPE_TB
- en: Importing online financial data in the JSON format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will also draw upon financial data from Quandl's API to
    create insightful visualizations. If you are not familiar with Quandl, it is a
    financial and economic data warehouse that stores millions of datasets from hundreds
    of publishers. The best thing about Quandl is that these datasets are delivered
    via the unified API, without worrying about the procedures to parse the data correctly.
    Anonymous users can get up to 50 API calls per day, and you get up to 500 free
    API calls if you are a registered user. Readers can sign up for a free API key
    at [https://www.quandl.com/?modal=register](https://www.quandl.com/?modal=register).
  prefs: []
  type: TYPE_NORMAL
- en: At Quandl, every dataset is identified by a unique ID, as defined by the Quandl
    Code on each search result webpage. For example, the Quandl code GOOG/NASDAQ_SWTX
    defines the historical NASDAQ index data published by Google Finance. Every dataset
    is available in three formats--CSV, JSON, and XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although an official Python client library is available from Quandl, we are
    not going to use that for the sake of demonstrating the general procedures of
    importing JSON data. According to Quandl''s documentation, we can fetch JSON formatted
    data tables through the following API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET https://www.quandl.com/api/v3/datasets/{Quandl code}/data.json`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to get the Big Mac index data from Quandl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| - | **Date** | **local_price** | **dollar_ex** | **dollar_price** | **dollar_ppp**
    | **dollar_valuation** | **dollar_adj_valuation** | **euro_adj_valuation** | **sterling_adj_valuation**
    | **yen_adj_valuation** | **yuan_adj_valuation** | **country** |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 2017-01-31 | 55.0 | 15.85750 | 3.468390 | 10.869565 | -31.454736
    | 6.26715 | 8.26976 | 29.6269 | 32.7146 | 13.6258 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 2016-07-31 | 50.0 | 14.93500 | 3.347841 | 9.920635 | -33.574590 |
    2.07261 | 0.402248 | 17.5645 | 19.7638 | 11.6431 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 2016-01-31 | 33.0 | 13.80925 | 2.389703 | 6.693712 | -51.527332 |
    -24.8619 | -18.714 | -18.7209 | 0.40859 | -17.029 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 2015-07-31 | 28.0 | 9.13500 | 3.065134 | 5.845511 | -36.009727 |
    -4.7585 | -0.357918 | -6.01091 | 30.8609 | 5.02868 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | 2015-01-31 | 28.0 | 8.61000 | 3.252033 | 5.845511 | -32.107881 |
    0.540242 | -0.804495 | -2.49468 | 34.3905 | 6.01183 | ARG |'
  prefs: []
  type: TYPE_TB
- en: The Big Mac index was invented by The Economist in 1986 as a lighthearted guide
    to check whether currencies are at their correct level. It is based on the theory
    of **purchasing power parity** (**PPP**) and is considered an informal measure
    of currency exchange rates at PPP. It measures their value against a similar basket
    of goods and services, in this case, a Big Mac. Differing prices at market exchange
    rates would imply that one currency is undervalued or overvalued.
  prefs: []
  type: TYPE_NORMAL
- en: The code for parsing JSON from the Quandl API is a bit more complicated, and
    thus extra explanations might help you to understand it. The first function, `get_bigmac_codes()`,
    parses the list of all available dataset codes in the Quandl Economist database
    as a pandas DataFrame. Meanwhile, the second function, `get_quandl_dataset(api_key,
    code)`, converts the JSON response of a Quandl dataset API query to a pandas DataFrame.
    All datasets obtained are concatenated using `pandas.concat()`.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the trend of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have imported the two datasets, we can set out on a further visualization
    journey. Let's begin by plotting the world population trends from 1950 to 2017\.
    To select rows based on the value of a column, we can use the following syntax: `df[df.variable_name
    == "target"]` or `df[df['variable_name'] == "target"]`, where `df` is the dataframe
    object. Other conditional operators, such as larger than > or smaller than <,
    are also supported. Multiple conditional statements can be chained together using
    the "and" operator &, or the "or" operator |.
  prefs: []
  type: TYPE_NORMAL
- en: 'To aggregate the population across all age groups within a year, we are going
    to rely on `df.groupby().sum()`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f5dd839a-cb94-48c2-a532-bf2005cf3771.png)'
  prefs: []
  type: TYPE_IMG
- en: Area chart and stacked area chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we may want to shade the area under the line plot with color for
    a greater visual impact. This can be achieved via the `fill_between` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By default, `fill_between` shades the region between `y=0` and the line when
    `y2` is not specified. More complex shading behavior can be specified using the
    where, interpolate, and step keyword arguments. Readers can refer to the following
    link for more information: [https://matplotlib.org/examples/pylab_examples/fill_between_demo.html.](https://matplotlib.org/examples/pylab_examples/fill_between_demo.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to plot a more detailed chart by separating the two genders. We
    are going to explore the relative contribution of males and females towards the
    population growth. To do that, we can prepare a stacked area chart using the `stackplot`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a7eff28b-2fbb-4d2a-91f5-66abcfebd085.png)'
  prefs: []
  type: TYPE_IMG
- en: Introducing Seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seaborn by Michael Waskom is a statistical visualization library that is built
    on top of Matplotlib. It comes with handy functions for visualizing categorical
    variables, univariate distributions, and bivariate distributions. For more complex
    plots, various statistical methods such as linear regression models and clustering
    algorithms are available. Like Matplotlib, Seaborn also supports Pandas dataframes
    as input, plus automatically performing the necessary slicing, grouping, aggregation,
    and statistical model fitting to produce informative figures.
  prefs: []
  type: TYPE_NORMAL
- en: 'These Seaborn functions aim to bring publication-quality figures through an
    API with a minimal set of arguments, while maintaining the full customization
    capabilities of Matplotlib. In fact, many functions in Seaborn return a Matplotlib
    axis or grid object when invoked. Therefore, Seaborn is a great companion of Matplotlib.
    To install Seaborn through PyPI, you can issue the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Seaborn will be imported as `sns` throughout this book. This section will not
    be a documentation of Seaborn. Rather our goal is to give a high-level overview
    of Seaborn's capabilities from the perspective of Matplotlib users. Readers can
    refer to the official Seaborn site ([http://seaborn.pydata.org/index.html](http://seaborn.pydata.org/index.html))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing univariate distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Seaborn makes the task of visualizing the distribution of a dataset much easier.
    Starting with the population data as discussed before, let''s see how it distributes
    among different countries in 2017 by plotting a bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/56262850-c1ee-41e9-a1f7-64ecdcd0773c.png)'
  prefs: []
  type: TYPE_IMG
- en: Bar chart in Seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `seaborn.barplot()` function shows a series of data points as rectangular
    bars. If multiple points per group are available, confidence intervals will be
    shown on top of the bars to indicate the uncertainty of the point estimates. Like
    most other Seaborn functions, various input data formats are supported, such as
    Python lists, Numpy arrays, pandas Series, and pandas DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: A more traditional way to show the population structure is through the use of
    a population pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: So what is a population pyramid? As its name suggests, it is a pyramid-shaped
    plot that shows the age distribution of a population. It can be roughly classified
    into three classes, namely constrictive, stationary, and expansive for populations
    that are undergoing negative, stable, and rapid growth respectively. For instance,
    constrictive populations have a lower proportion of young people, so the pyramid
    base appears to be constricted. Stable populations have a more or less similar
    number of young and middle-aged groups. Expansive populations, on the other hand,
    have a large proportion of youngsters, thus resulting in pyramids with enlarged
    bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build a population pyramid by plotting two bar charts on two subplots
    with a shared y-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/91b3a3a5-fb14-4335-9b3c-2d09f36fdb79.png)'
  prefs: []
  type: TYPE_IMG
- en: Since Seaborn is built on top of the solid foundations of Matplotlib, we can
    customize the plot easily using built-in functions of Matplotlib. In the preceding
    example, we used `matplotlib.axes.Axes.invert_xaxis()` to flip the male population
    plot horizontally, followed by changing the location of the tick labels to the
    right-hand side using `matplotlib.axis.YAxis.tick_right()`. We further customized
    the titles and axis labels for the plot using a combination of `matplotlib.axes.Axes.set_title()`,
    `matplotlib.axes.Axes.set()`, and `matplotlib.figure.Figure.suptitle()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to plot the population pyramids for Cambodia and Japan as well by
    changing the line `population_df.Location == 'United States of America'` to `population_df.Location
    == 'Cambodia'` or `population_df.Location == 'Japan'`. Can you classify the pyramids
    into one of the three population pyramid classes?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b728e146-f453-4ef9-b6cb-3a3f26fab503.png)![](img/6e1566cb-b049-4965-8d57-00b608cdd74f.png)'
  prefs: []
  type: TYPE_IMG
- en: To see how Seaborn simplifies the code for relatively complex plots, let's see
    how a similar plot can be achieved using vanilla Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, like the previous Seaborn-based example, we create two subplots with
    shared y-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we plot horizontal bar charts using `matplotlib.pyplot.barh()` and set
    the location and labels of ticks, followed by adjusting the subplot spacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the same code to further customize the look and feel of the
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/15c72474-c183-42d7-b957-a88958c89c46.png)'
  prefs: []
  type: TYPE_IMG
- en: When compared to the Seaborn-based code, the pure Matplotlib implementation
    requires extra lines to define the tick positions, tick labels, and subplot spacing.
    For some other Seaborn plot types that include extra statistical calculations
    such as linear regression, and pearson correlation, the code reduction is even
    more dramatic. Therefore, Seaborn is a "batteries-included" statistical visualization
    package that allows users to write less verbose code.
  prefs: []
  type: TYPE_NORMAL
- en: Histogram and distribution fitting in Seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the population example, the raw data was already binned into different age
    groups. What if the data is not binned (for example, the BigMac Index data)? Turns
    out, `seaborn.distplot` can help us to process the data into bins and show us
    a histogram as a result. Let''s look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c013bf79-99a6-4605-910d-05b2dfa1162d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `seaborn.distplot` function expects either pandas Series, single-dimensional
    numpy.array, or a Python list as input. Then, it determines the size of the bins
    according to the Freedman-Diaconis rule, and finally it fits a **kernel density
    estimate** (**KDE**) over the histogram.
  prefs: []
  type: TYPE_NORMAL
- en: KDE is a non-parametric method used to estimate the distribution of a variable.
    We can also supply a parametric distribution, such as beta, gamma, or normal distribution,
    to the `fit` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are going to fit the normal distribution from the `scipy.stats`
    package over the Big Mac Index dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/834e6988-4fef-4f3c-bb46-d2c348144fff.png)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing a bivariate distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should bear in mind that the Big Mac index is not directly comparable between
    countries. Normally, we would expect commodities in poor countries to be cheaper
    than those in rich ones. To represent a fairer picture of the index, it would
    be better to show the relationship between Big Mac pricing and **Gross Domestic
    Product** (**GDP**) per capita.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to acquire GDP per capita from Quandl's **World Bank World Development
    Indicators** (**WWDI**) dataset. Based on the previous code example of acquiring
    JSON data from Quandl, can you try to adapt it to download the GDP per capita
    dataset?
  prefs: []
  type: TYPE_NORMAL
- en: 'For those who are impatient, here is the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Date | Value | country |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2015-12-31 | 10501.660269 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2014-12-31 | 10334.780146 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2013-12-31 | 10711.229530 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2012-12-31 | 10558.265365 | ARG |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2011-12-31 | 10780.342508 | ARG |'
  prefs: []
  type: TYPE_TB
- en: We can see that the GDP per capita dataset is not available for four geographical
    locations, but we can ignore that for now.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will merge the two DataFrames that contain Big Mac Index and GDP per
    capita respectively using `pandas.merge()`. The most recent record in WWDI's GDP
    per capita dataset was collected at the end of 2015, so let's pair that up with
    the corresponding Big Mac index dataset in the same year.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those who are familiar with the SQL language, `pandas.merge()` supports
    four modes, namely left, right, inner, and outer joins. Since we are interested
    in rows that have matching countries in both DataFrames only, we are going to
    choose inner join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|  | Date_x | local_price | dollar_ex | dollar_price | dollar_ppp | dollar_valuation
    | dollar_adj_valuation | euro_adj_valuation | sterling_adj_valuation | yen_adj_valuation
    | yuan_adj_valuation | country | Date_y | Value |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2015-01-31 | 28.00 | 8.610000 | 3.252033 | 5.845511 | -32.107881 | 0.540242
    | -0.804495 | -2.49468 | 34.3905 | 6.01183 | ARG | 2015-12-31 | 10501.660269 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2015-01-31 | 5.30 | 1.227220 | 4.318705 | 1.106472 | -9.839144 | -17.8995
    | -18.9976 | -20.3778 | 9.74234 | -13.4315 | AUS | 2015-12-31 | 54688.445933 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2015-01-31 | 13.50 | 2.592750 | 5.206827 | 2.818372 | 8.702019 | 68.4555
    | 66.2024 | 63.3705 | 125.172 | 77.6231 | BRA | 2015-12-31 | 11211.891104 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2015-01-31 | 2.89 | 0.661594 | 4.368235 | 0.603340 | -8.805115 | 3.11257
    | 1.73343 | 0 | 37.8289 | 8.72415 | GBR | 2015-12-31 | 41182.619517 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2015-01-31 | 5.70 | 1.228550 | 4.639616 | 1.189979 | -3.139545 | -2.34134
    | -3.64753 | -5.28928 | 30.5387 | 2.97343 | CAN | 2015-12-31 | 50108.065004 |'
  prefs: []
  type: TYPE_TB
- en: Scatter plot in Seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A scatter plot is one of the most common plots in the scientific and business
    worlds. It is particularly useful for displaying the relationship between two
    variables. While we can simply use `matplotlib.pyplot.scatter` to draw a scatter
    plot, we can also use Seaborn to build similar plots with more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: The two functions `seaborn.regplot()` and `seaborn.lmplot()` display a linear
    relationship in the form of a scatter plot, a regression line, plus the 95% confidence
    interval around that regression line. The main difference between the two functions
    is that `lmplot()` combines `regplot()` with `FacetGrid` such that we can create
    color-coded or faceted scatter plots to show the interaction between three or
    more pairs of variables. We will demonstrate the use of `lmplot()` later in this
    chapter and the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of `seaborn.regplot()` supports numpy arrays, pandas Series,
    or pandas DataFrames as input. The regression line and the confidence interval
    can be removed by specifying `fit_reg=False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to investigate the hypothesis that Big Macs are cheaper in poorer
    countries, and vice versa, checking whether there is any correlation between the
    Big Mac index and GDP per capita:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d36ae630-7dc2-486c-9bd5-26840c2e65fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far so good! It looks like the Big Mac index is positively correlated with
    GDP per capita. Let''s turn the regression line back on and label a few countries
    that show extreme Big Mac index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aab88b3-8ea2-4e0f-a530-a0040339e8b3.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that many countries fall within the confidence interval of the regression
    line. Given the GDP per capita level for each country, the linear regression model
    predicts the corresponding Big Mac index. The currency value shows signs of under-
    or over-valuation if the actual index deviates from the regression model.
  prefs: []
  type: TYPE_NORMAL
- en: By labeling the countries that show extremely high or low values, we can clearly
    see that the average price of a Big Mac in Brazil and Switzerland is overvalued,
    while it is undervalued in India, Russia, and Ukraine even if the differences
    in GDP are considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Seaborn is not a package for statistical analysis, we would need to rely
    on other packages, such as `scipy.stats` or `statsmodels`, to obtain the parameters
    of a regression model. In the next example, we are going to get the `slope` and
    `intercept` parameters from the regression model, and apply different colors for
    points that are above or below the regression line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a7c33727-4494-44f6-b659-ab2f314cd1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Contrary to popular belief, it looks like China's currency was not significantly
    under-valued in 2015 since its marker lies well within the 95% confidence interval
    of the regression line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better illustrate the distribution of values, we can combine histograms
    of `x` or `y` values with scatter plots using `seaborn.jointplot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e59c5502-83f1-483a-81e8-790b6d4df877.png)'
  prefs: []
  type: TYPE_IMG
- en: By additionally specifying the `kind` parameter in `jointplot` to `reg`, `resid`,
    `hex`, or `kde`, we can quickly change the plot type to regression, residual,
    hex bin, or KDE contour plot respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28dec103-04b7-40ff-a72e-eb2f1b82571f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a big disclaimer: with the data in our hands, it is still too early
    to make any conclusions about the valuation of currencies! Different business
    factors such as labor cost, rent, raw material costs, and taxation can all contribute
    to the pricing model of Big Mac, but this is beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing categorical data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Towards the end of this chapter, let's try to integrate all datasets that we
    have processed so far. Remember that we briefly introduced the three categories
    of population structures (that is, constrictive, stable, and expansive) earlier
    in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to implement a naive algorithm for classifying
    populations into one of the three categories. After that, we will explore different
    techniques of visualizing categorical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most references online discuss visual classification of population pyramids
    only (for example, [https://www.populationeducation.org/content/what-are-different-types-population-pyramids](https://www.populationeducation.org/content/what-are-different-types-population-pyramids)).
    Clustering-based methods do exist (for example, Korenjak-Cˇ erne, Kejžar, Batagelj
    (2008). *Clustering of Population Pyramids*. Informatica. 32.), but to date, mathematical
    definitions of population categories are scarcely discussed. We will build a naive
    classifier based on the ratio of populations between "0-4" and "50-54" age groups
    in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Date_x | local_price | dollar_ex | dollar_price | dollar_ppp | dollar_valuation
    | dollar_adj_valuation | euro_adj_valuation | sterling_adj_valuation | yen_adj_valuation
    | yuan_adj_valuation | country | Date_y | Value | ratio | population type |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 2015-01-31 | 28.00 | 8.610000 | 3.252033 | 5.845511 | -32.107881 | 0.540242
    | -0.804495 | -2.49468 | 34.3905 | 6.01183 | ARG | 2015-12-31 | 10501.660269 |
    1.695835 | expansive |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2015-01-31 | 5.30 | 1.227220 | 4.318705 | 1.106472 | -9.839144 | -17.8995
    | -18.9976 | -20.3778 | 9.74234 | -13.4315 | AUS | 2015-12-31 | 54688.445933 |
    0.961301 | stable |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2015-01-31 | 13.50 | 2.592750 | 5.206827 | 2.818372 | 8.702019 | 68.4555
    | 66.2024 | 63.3705 | 125.172 | 77.6231 | BRA | 2015-12-31 | 11211.891104 | 1.217728
    | expansive |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2015-01-31 | 2.89 | 0.661594 | 4.368235 | 0.603340 | -8.805115 | 3.11257
    | 1.73343 | 0 | 37.8289 | 8.72415 | GBR | 2015-12-31 | 41182.619517 | 0.872431
    | stable |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2015-01-31 | 5.70 | 1.228550 | 4.639616 | 1.189979 | -3.139545 | -2.34134
    | -3.64753 | -5.28928 | 30.5387 | 2.97343 | CAN | 2015-12-31 | 50108.065004 |
    0.690253 | constrictive |'
  prefs: []
  type: TYPE_TB
- en: Categorical scatter plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the data classified into categories, we can check whether different population
    types exhibit different Big Mac index distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `seaborn.lmplot` to dissect the data and create a categorical scatter
    plot. As a recap, `lmplot()` combines `regplot()` with `FacetGrid` for visualization
    of three or more pairs of variables in faceted grids or color-coded scatter plots.
    In the upcoming examples, we are going to assign the population type variable
    to the `col`, `row`, or `hue` parameters of `lmplot()`. Let''s see how the results
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code excerpt generates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16f3a772-128b-4ce5-a459-4d800fe6be9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, if we set `row="population type"` instead of `col="population
    type"` in the code excerpt, the following plot will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67e697a9-e0c3-417c-afce-88e886b33e97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, by changing `col="population type"` to `hue="population type"` , a
    color-coded categorical scatter plot will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a1cc962-df10-4723-9b8d-c44045acb922.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, `col`, `row`, and `hue` can be mixed together to create a rich faceted
    grid. This is particularly useful when there are lots of dimensions in your data.
    Further discussion of facet grids will be available in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Strip plot and swarm plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A strip is basically a scatter plot where the *x-*axis represents a categorical
    variable. Typical uses of a strip plot involve applying a small random jitter
    value to each data point such that the separation between points becomes clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e4e4391d-bc58-4a57-bb5f-326427efab08.png)'
  prefs: []
  type: TYPE_IMG
- en: A swarm plot is very similar to a strip plot, yet the locations of points are
    adjusted automatically to avoid overlap even if the jitter value is not applied.
    These plots resemble bees swarming a position, and are likewise named.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the Seaborn function call from `sns.stripplot` to `sns.swarmplot`
    in the preceding code excerpt, the result will be changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4ba8226-f575-468f-aaa5-f2756bf1ff60.png)'
  prefs: []
  type: TYPE_IMG
- en: Box plot and violin plot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way a strip plot and swarm plot represent data makes comparison difficult.
    Suppose you want to find out whether the stable or constrictive population type
    has a higher median BigMac index value. Can you do that based on the two previous
    example plots?
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to think that the constrictive group has a higher median
    value because of the higher maximum data point, but in fact, the stable group
    has a higher median value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Could there be a better plot type for comparing the distribution of categorical
    data? Here you go! Let''s try a box plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bfdeb24-db50-4d68-afe2-db7f168ad864.png)'
  prefs: []
  type: TYPE_IMG
- en: The box represents quartiles of the data, the center line denotes the median
    value, and the whiskers represent the full range of the data. Data points that
    deviate by more than 1.5 times the interquartile range from the upper or lower
    quartile are deemed to be outliers and show as fliers.
  prefs: []
  type: TYPE_NORMAL
- en: A violin plot combines the kernel density estimate of our data with the box
    plot. Both box plot and violin plot display the median and interquartile range,
    but a violin plot goes one step further by showing the full estimated probability
    distribution that is fit to the data. Therefore, we can tell whether there are
    peaks within the data and also compare their relative amplitude.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change the Seaborn function call from `sns.boxplot` to `sns.violinplot`
    in the code excerpt, the result would be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38295ea3-2e32-4184-b1a0-a36920164742.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also overlay a strip plot or swarm plot on top of the box plot or swarm
    plot in order to get the best of both worlds. Here is an example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dafadade-eb00-4342-a389-eeb43e92bd97.png)'
  prefs: []
  type: TYPE_IMG
- en: Controlling Seaborn figure aesthetics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can use Matplotlib to customize the figure aesthetics, Seaborn comes
    with several handy functions to make customization easier. If you are using Seaborn
    version 0.8 or later, `seaborn.set()` must be called explicitly after import if
    you would like to enable the beautiful Seaborn default theme. In earlier versions,
    `seaborn.set()` was called implicitly on import.
  prefs: []
  type: TYPE_NORMAL
- en: Preset themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The five default themes in Seaborn, namely darkgrid, whitegrid, dark, white,
    and ticks, can be selected by calling the `seaborn.set_style()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`seaborn.set_style()` must be called before issuing any plotting commands in
    order to display the theme properly.![](img/bce26e90-c0f9-46b7-9e0e-36e05a8045d1.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Removing spines from the figure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To remove or adjust the positions of spines, we can make use of the `seaborn.despine`
    function. By default, the spines on the top and right side of a figure are removed,
    and additional spines can be removed by setting `left=True` or `bottom=True`.
    Through the use of offset and trim parameters, the location of the spines can
    be adjusted as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`seaborn.despine` has to be called after calling the Seaborn plotting functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results of different combinations of parameters in the `seaborn.despine`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f326188-f03d-4b94-93a7-1a22173aac6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Changing the size of the figure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To control the height and width of the figure, we can rely on `matplotlib.pyplot.figure(figsize=(WIDTH,HEIGHT))` as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are going to change the size of the previous histogram
    example to 8 inches wide and 4 inches tall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the expected output from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23c2759b-5997-492d-a47d-994d9e936d04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Seaborn also comes with the `seaborn.set_context()` function to control the
    scale of plot elements. There are four preset contexts, paper, notebook, talk,
    and poster, which are in ascending order of size. By default, the Notebook style
    is chosen. This is an example of setting the context to `poster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the expected output from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc0cc554-44ee-4cfe-bd19-1cba41ff9859.png)'
  prefs: []
  type: TYPE_IMG
- en: Fine-tuning the style of the figure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost every element in a Seaborn figure can be further customized via `seaborn.set`.
    Here is the list of parameters that are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context`: One of the preset contexts--{paper, notebook, talk, poster}.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: One of the axes'' styles--{darkgrid, whitegrid, dark, white, ticks}.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`palette`: One of the color palettes as defined in [https://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette](https://seaborn.pydata.org/generated/seaborn.color_palette.html#seaborn.color_palette).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font`: A supported font or font family name, such as serif, sans-serif, cursive,
    fantasy, or monospace. For more information, visit [https://matplotlib.org/api/font_manager_api.html](https://matplotlib.org/api/font_manager_api.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font_scale`: An independent scaling factor of font elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rc`: A dictionary of extra `rc` parameters mappings. To obtain the full list
    of all `rc` parameters, we can run `seaborn.axes_style()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RC parameters that are not defined in the currently used preset context or axis
    style cannot be overridden. For more information on `seaborn.set()`, please visit
    [https://seaborn.pydata.org/generated/seaborn.set.html#seaborn.set](https://seaborn.pydata.org/generated/seaborn.set.html#seaborn.set).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to increase the font scale, increase the line width of the KDE plot,
    and change the color of several plot elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The code generates the following histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c428fb8-6c10-4ca1-85ad-44a045e0e4de.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, only functions that control global aesthetics were introduced. What
    if we want to change the style of a specific plot only?
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, most Seaborn plotting functions come with specific parameters for
    the customization of styles. This also means that there isn''t a universal styling
    tutorial for all Seaborn plotting functions. However, we can take a closer look
    at this `seaborn.distplot()` code excerpt to get an idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e36290b7-95b4-4879-b185-053078956c6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some Seaborn functions support a more direct approach of customizing aesthetics.
    For example, `seaborn.barplot` can pass through keyword arguments such as `facecolor`,
    `edgecolor`, `ecolor`, and `linewidth` to the underlying `matplotlib.pyplot.bar`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a19813ac-e20d-45de-8a2e-9c1cb51b255b.png)'
  prefs: []
  type: TYPE_IMG
- en: More about colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Color is perhaps the most important aspect of figure style, and thus it deserves
    its own subsection. There are many great resources that discuss the principles
    of choosing colors in visualizations (for example, [https://betterfigures.org/2015/06/23/picking-a-colour-scale-for-scientific-graphics/](https://betterfigures.org/2015/06/23/picking-a-colour-scale-for-scientific-graphics/)
    and [https://earthobservatory.nasa.gov/blogs/elegantfigures/2013/08/05/subtleties-of-color-part-1-of-6/](https://earthobservatory.nasa.gov/blogs/elegantfigures/2013/08/05/subtleties-of-color-part-1-of-6/)).
    The official Matplotlib documentation also contains a good overview of color maps
    ([http://matplotlib.org/users/colormaps.html](http://matplotlib.org/users/colormaps.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Effective use of color adds sufficient contrast to make something stand out
    and draw your audience's attention. Colors can also evoke emotions; for example,
    red is often associated with important or passionate, while green is often associated
    with natural or stable. If you are trying to deliver a story from your plots,
    do try to use an appropriate color scheme. It's estimated that 8% of men and 0.5%
    of women suffer from red-green color blindness, so we need to pick colors with
    these individuals in mind as well.
  prefs: []
  type: TYPE_NORMAL
- en: Color scheme and color palettes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three general kinds of color palettes available in seaborn--qualitative,
    diverging, and sequential:'
  prefs: []
  type: TYPE_NORMAL
- en: Qualitative palettes are best for data with discrete levels or nominal or categorical
    data. Custom qualitative palettes can be created by providing a list of Matplotlib
    colors to `seaborn.color_palette`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diverging palettes are used for highlighting low and high values in a figure,
    with a neutrally colored midpoint. Custom diverging palettes can be created by
    passing two hue values plus the optional lightness and saturation values for the
    extremes to the `seaborn.diverging_palette` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential palettes are usually used for quantitative data that progresses continuously
    from low to high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom sequential palettes can be created by providing a single Matplotlib color
    to `seaborn.light_palette` or `seaborn.dark_palette`, which produces a palette
    that changes gradually from light or dark desaturated values to the seed color.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the next example, we are going to plot the most commonly used qualitative,
    diverging, and sequential palettes, as well as a few custom palettes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/350e9195-9024-4abe-968d-8132a67660b8.png)'
  prefs: []
  type: TYPE_IMG
- en: To change the color scheme of a Seaborn plot, we can use either the `color` or
    `palette` parameter available in most Seaborn functions. The `color` parameter
    supports a single color that will be applied to all of the elements. On the other
    hand, `palette` supports a range of colors to differentiate levels of the `hue` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Some Seaborn functions support the `color` parameter only (for example, dist
    plot), while others can support both `color` and `palette` (for example, bar plot
    and box plot). Readers can refer to the official documentation to see which parameter
    is supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three code excerpts demonstrate the use of the `color` or `palette`
    parameter in a dist plot, bar plot, and box plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5e4191a4-96db-4e82-8f8f-c743638be797.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a40ff9dd-aa78-4012-b2f2-85475fb98618.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f80e3932-a7f3-4cf6-866e-41f6d36ddd76.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You just learned how we can parse online data in CSV or JSON formats using the
    versatile Pandas package. You further learned how to filter, subset, merge, and
    process data into insights. You have now equipped yourself with the knowledge
    to visualize time series, univariate, bivariate, and categorical data. The chapter
    concluded with a number of useful techniques to customize figure aesthetics for
    effective storytelling.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! We have just completed a long chapter, so go grab a burger, have a break,
    and relax.
  prefs: []
  type: TYPE_NORMAL
