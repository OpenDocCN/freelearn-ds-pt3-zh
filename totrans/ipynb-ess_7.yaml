- en: Appendix B. A Brief Review of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This appendix will give you a brief tour of the Python syntax. This is not
    intended to be a course on Python programming, but can be used by readers who
    are unfamiliar with the language as a quick introduction. The following topics
    will be covered in this appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic types, expressions, and variables and their assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions, objects, and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic types, expressions, and variables and their assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any data that can be referred to in a Python code is considered an **object**.
    Objects are used to represent everything from *atomic* data, such as numbers,
    to very complex data structures, such as multidimensional arrays, database connections,
    and documents in several formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root of the object hierarchy are the numeric data types. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integers**: There are three types of integers in Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plain integers**: They are represented in the native architecture, which,
    in most systems, will be either 32- or 64-bit signed values.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long integers**: They are integers with unlimited range, subject to available
    memory. Most of the time, the programmer does not need to be concerned with the
    distinction between plain and long integers. Python deals with conversions between
    the types in a transparent way.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Booleans**: They represent the values `False` and `True`. In most situations,
    they are equivalent to `0` and `1`, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floats**: They represent the native double-precision floating-point numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex**: They represent complex numbers, represented as a pair of double-precision
    floating-point numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table has examples of **literals** (that is, **constants**) for
    each data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Literals |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Integers** | `0`, `2`, `4`, …, `43882838388``5L`, `5l` (long integer)`0xFE4`
    (hexadecimal)`03241` (octal) |'
  prefs: []
  type: TYPE_TB
- en: '| **Real numbers (float)** | `5.34`, `1.2`, `3.`, `0``1.4e-32` (scientific
    notation) |'
  prefs: []
  type: TYPE_TB
- en: '| **Complex** | `1.0+3.4j`, `1+2j`, `1j`, `0j`, `complex(4.3, 2.5)` |'
  prefs: []
  type: TYPE_TB
- en: The imaginary unit is represented by `j`, but only if it follows a number literal
    (otherwise, it represents the variable named `j`). So, to represent the imaginary
    unit we must use `1j` and the complex zero is `0j`. The real and imaginary part
    of a complex number are always stored as double-precision floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the set of numeric types is greatly extended by `NumPy` to allow efficient
    numeric computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The assignment statement is used to store values in variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Python supports *multiple simultaneous assignments* of values, so the previous
    four lines of code could be equivalently written in a single line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a multiple assignment, all expressions in the right-hand side are evaluated
    before the assignments are made. For example, a common idiom to exchange the values
    of two variables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise, the reader can try to predict the result of the following statement,
    given the preceding variable assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to compute the two solutions of a quadratic
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we force the variables `a`, `b`, and `c` to be floating-point values
    by using a decimal point. This is good practice when performing numerical computations.
    The following table contains a partial list of Python operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operators | Python operators |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Arithmetic** | `+` (Addition)`-` (Subtraction, unary minus)`*` (Multiplication)`/`
    (Division, *see the note below the table*)`//` (Integer division)`%` (Remainder)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Comparison** | `==` (Equal to)`>` (Greater than)`<` (Less than)`>=` (Greater
    than or equal to)`<=` (Less than or equal to)`!=` (Not equal to) |'
  prefs: []
  type: TYPE_TB
- en: '| **Boolean** | `and``or``not` |'
  prefs: []
  type: TYPE_TB
- en: '| **Bitwise Boolean** | `&` (AND)`&#124;` (OR)`^` (XOR)`~` (NOT) |'
  prefs: []
  type: TYPE_TB
- en: '| **Bitwise shift** | `<<` (Left shift)`>>` (Right shift) |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Care should be taken with the division operator (`/`). If the operands are
    integers, the result of this operation is the integer quotient. For example, `34/12`
    results `2`. To get the floating point result, we must either enter floating point
    operands, as in `34./12.`, or add the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `//` operator always represents integer division.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operators follow the rules for the order of operations that may
    be altered with the use of parenthesis. Comparison operators have lower precedence
    than arithmetic operators, and the `or`, `and`, and `not` operators have even
    lower precedence. So, an expression like the following one produces the expected
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the preceding command line is parsed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The logical operators `and` and `or` short circuit, so, for example, the second
    comparison is never evaluated in the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The precedence rules for the bitwise and shift operators may not be as intuitive,
    so it is recommended to always use parenthesis to specify the order of operations,
    which also adds clarity to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also supports augmented assignments. For example, the following command
    lines first assign the value `5` to `a`, and then increment the value of `a` by
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python does not have increment/decrement operators, such as a++ and ++a, as
    in the C language.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Python operators have a corresponding augmented assignment statement. The
    general semantic for any operator `$` is the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `$` is not a valid Python operator, it is just being used as a placeholder
    for a generic operator.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python sequence types are used to represent ordered collections of objects.
    They are classified into **mutable** and **immutable** sequence types. Here, we
    will only discuss `lists` (mutable) and `tuples` and `strings` (both immutable).
    Other sequence types are mentioned at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example shows how to construct a list in Python and assign it
    to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual entries in the list are accessed with index notation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that indexing always starts with `0`. Negative indices are allowed and
    they represent positions starting at the end of the list. For example, `numbers[-1]`
    is the last entry, `numbers[-2]` is the next-to-last entry, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since lists are a mutable sequence type, we are allowed to modify the entries
    in-place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another important way to refer to elements in a Python sequence type is slices,
    which allow the extraction of sublists from a list. Since this topic is very important
    for `NumPy` arrays, we defer the discussion to [Appendix C](apc.html "Appendix C. NumPy
    Arrays"), *NumPy Arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python lists have a nice set of features, a few of which are illustrated in
    the following code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the length of a list, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To reverse a list in place, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To append a new element, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To sort the list in-place, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To insert a value at a position, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To extend a list, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Python has a few handy ways to construct frequently used lists. The `range()`
    function returns a list of equally spaced integers. The simplest form returns
    a list of successive integers starting at `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command returns the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the last element is one less than the argument given in the function
    call. The rule of thumb is that `range(n)` returns a list with `n` elements starting
    at zero so that the last element is `n-1`. To start at a nonzero value, use the
    two-argument version as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A third argument specifies an *increment*. The following command line produces
    a list of all positive multiples of 6 that are less than 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative increments can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists support concatenation, which is represented by the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that for the `NumPy` arrays, the `+` operator is redefined to represent
    vector/matrix addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The multiplication operator (`*`) can be used to construct a list by repeating
    the elements of a given list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The most flexible way to construct a list in Python is to use a list comprehension.
    A full discussion is beyond the scope of this appendix, but the following examples
    illustrate some of the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the list of the squares of the integers from `0` to `10` (inclusive),
    use the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To display the list of divisors of an integer, use the following command lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To display the list of prime numbers up to 100, use the following command line
    (very inefficient):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To display the list of tuples of points with integers coordinates and their
    distances to the origin, use the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are similar to lists, but are immutable—once created, their elements
    cannot
  prefs: []
  type: TYPE_NORMAL
- en: 'be changed. The following command lines will result in an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples have a few specialized uses in Python. They can be used as indexes in
    dictionaries (because they are immutable). They also consist of the mechanism
    that Python uses to return more than one value from a function. For example, the
    built-in function `divmod()` returns both the integer quotient and remainder in
    a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tuples support the same sequence interface as lists, except for methods that
    would modify the tuple. For example, there is no method named `sort()` that sorts
    a tuple in place.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Python string represents an immutable sequence of characters. There are two
    string types: `str`, representing ASCII strings, and `unicode`, representing Unicode
    strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A string literal is a sequence of characters enclosed by either single quotes
    or double quotes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no semantic difference between single quotes and double quotes, except
    that a single-quoted string can contain double quotes and a double quoted string
    can contain single quotes. For example, the following command lines are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are used for two main purposes: as dictionary indexes and to print
    messages. When printing messages, strings have the `format()` method that allows
    easy display of information. We use this feature frequently to add annotations
    to graphics. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, there are two format specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{:d}`: This specifies a decimal format for an integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{:8.5f}`: This specifies a field of width `8` and `5` decimals for a floating-point
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format specifications are matched (in order) with the arguments, in this
    case `n` and `n ** 0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Strings have a rich interface. If you need to code something with strings, it
    is very likely that there is a built-in function that does the job with very little
    modification. A list of all available string methods, as well as formatting features,
    is available at [https://docs.python.org/2/library/stdtypes.html#string-methods](https://docs.python.org/2/library/stdtypes.html#string-methods).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python dictionaries are a data structure that contains key-item pairs. The
    keys must be immutable types, usually strings or tuples. Here is an example that
    shows how to construct a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an item, we provide the key as an index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries are mutable, so we can change the item values using them. If Jodi
    does extra work to improve her grade, we can change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To add an entry to a dictionary, just assign a value to a new key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: However, attempting to access a nonexistent key yields an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to realize is that dictionaries are not ordered. The following
    code is a standard idiom to iterate over a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The main point here is that the output is not at all related to the order in
    which the entries were added to the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the dictionary interface, you can refer to [https://docs.python.org/2/library/stdtypes.html#mapping-types-dict](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict).
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Control structures allow changes to the flow of the execution of code. There
    are two types of structures that are of interest to us: **branching** and **looping**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Branching allows the execution of different code depending on the result of
    a test. The following example shows an improved version of code to solve quadratic
    equations. An `if-then-else` structure is used to handle the cases of real and
    imaginary solutions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code starts by computing the discriminant of the quadratic. Then,
    an `if-then-else` statement is used to decide if the roots are real or imaginary,
    according to the sign of the discriminant. Note the indentation of the code. Indentation
    is used in Python to define the boundaries of blocks of statements. The general
    form of the `if-then-else` structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: First, the condition `<condition>` is evaluated. If it is `True`, the statement
    `<statement block T>` is executed. Otherwise, `<statement block F>` is executed.
    The `else:` clause can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common looping structure in Python is the `for` statement. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining a list of integers. The `for` statement makes the variable
    `n` assume each value in the list numbers in succession and execute the indented
    block for each value. Note that there is an `if-then-else` structure inside the
    `for` loop. Also, the `print` statements are doubly-indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop is frequently used to perform simple searches. A common scenario
    is the need to step out of the loop when a certain condition is met. The following
    code finds the first perfect square in a range of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For each value of `n` in the given range, we take the square root of `n`, take
    the integer part, and then calculate its square. If the result is equal to `n`,
    then we go into the `if` block, print `n`, and then break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if there are no perfect squares in the range? Change the preceding function,
    `range(30, 60)`, to `range(125, 140)`. When the command line is run, nothing is
    printed, since there are no perfect squares between `125` and `140`. Now, change
    the command line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `else` clause is only executed if the execution does not break out of the
    loop, in which case the message is printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another frequent situation is when some values in the iteration must be skipped.
    In the following example, we print the square roots of a sequence of random numbers
    between `-1` and `1`, but only if the numbers are positive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When Python meets the `continue` statement in a loop, it skips the rest of the
    execution block and continues with the next value of the control variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another control structure that is frequently used is the `while` loop. This
    structure executes a block of commands as long as a condition is true. For example,
    suppose we want to compute the running sum of a list of randomly generated values,
    but only until the sum is above a certain value. This can be done with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common situation that occurs more often than one might expect requires
    a pattern known as the **forever loop**. This happens when the condition to be
    checked is not available at the beginning of the loop. The following code, for
    example, implements the famous `3n+1` game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The game starts with an arbitrary integer, `7` in this case. Then, in each
    iteration, we test whether `n` is even. If it is, we divide it by `2`; otherwise,
    multiply it by `3` and add `1`. Then, we check whether we reached `1`. If yes,
    we break from the loop. Since we don''t know if we have to break until the end
    of the loop, we use a forever loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Some programmers avoid this construct, since it may easily lead to infinite
    loops if one is careless. However, it turns out to be very handy in certain situations.
    By the way, it is an open problem if the loop in the `3n+1` problem stops for
    all initial values! Readers may have some fun trying the initial value `n=27`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions, objects, and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now come to the constructs that really make Python so flexible and powerful,
    its object-oriented features. We have already seen some examples of object-oriented
    code in the previous sections (the object-oriented paradigm is so integral to
    Python that is hardly possible to write any code without using it), but now we
    will have a more specific treatment of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already seen many examples of functions being used. For example, the
    `len()` function is used to compute the length of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The most basic syntax for calling a function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `arg1`, `arg2`, …, `argn` are called **positional arguments**,
    since they are matched according to the position in which they appear. As an example,
    let''s consider the built-in function, `pow()`. This function takes up to three
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In this form, the preceding function uses an optimized algorithm to compute
    `b` raised to the power `n` modulo `m`. (If you are wondering, this is an important
    operation in public key cryptography, for example.) The arguments `b`, `n`, and
    `m` are associated by their position. For example, to compute `12` raised to the
    tenth power modulo `15`, we use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also supports sequences of arguments of arbitrary size. For example,
    the `max()` function computes the maximum of an arbitrary sequence of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command returns the value `8`.
  prefs: []
  type: TYPE_NORMAL
- en: A third way to pass arguments to a function is to use **keyword arguments**.
    This turns out to be very useful, since it is in general difficult to remember
    the exact order of positional arguments. (I would prefer not to write a function
    with more than three or four positional arguments, for example.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the built-in `int()` function can be used to convert a string
    to an integer. The optional keyword argument, `base`, lets us specify the base
    for conversion. For example, the following command line assigns to `n`, an integer
    given in base `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Keyword arguments always have a default value. In our example, if the base is
    not specified, it is assumed to be `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We often need to write our own functions. This is done with the keyword, `def`.
    As an example, let''s consider writing code to implement the well-known `bisection`
    method to solve equations numerically. A possible solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function takes three important and necessary arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The `f` function accepts a float value as input and returns a float value as
    output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The floating-point values, `a` and `b`, which specify an interval that contains
    a zero of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other two arguments are optional. The argument `tol` specifies the desired
    tolerance in the result and `itermax` specifies the maximum number of iterations.
    To use the `bisection()` function, we must first define the function `f`. We will
    take the opportunity to display another way to define a function in Python, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to call the function with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we designed the function to return an interval containing the zero.
    The length of the interval is less than `tol`, unless the maximum number of iterations
    is reached. If we want a smaller tolerance, we could use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose that we are concerned with the time the computation is taking.
    We can limit the maximum number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order in which the keyword arguments are given is irrelevant and
    the desired tolerance is not reached in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects are the most general data abstraction in Python. Actually, in Python,
    everything is an object from the point of view of the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: An object is nothing more than a collection of structured data, together with
    an interface to operate on this data. Objects are defined using the `class` construct,
    but our goal here is not to show how to define classes. Although designing a new
    class is an advanced topic, using existing classes is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s explore the built-in type `str`. Let''s start by defining
    a `str` object we can play with as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To start, let''s convert the message to uppercase as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We say that the preceding statement calls the `upper()` method of the `message`
    object. A method is simply a function that is associated to an object. The following
    are a few other methods of the `str` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the first occurrence of a substring (returns `-1` if the string is
    not found), use the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To split the string in words, use the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To count the number of occurrences of `s` substring, use the following command
    line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To replace a substring by something else, use the following command line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the preceding methods do not change the original string object, but
    return new modified strings. Strings are immutable. For mutable objects, methods
    are free to change the data in the object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we gave an overview of the Python syntax and features, covering
    basic types, expressions, variables, and assignment, basic data structures, functions,
    objects, and methods.
  prefs: []
  type: TYPE_NORMAL
