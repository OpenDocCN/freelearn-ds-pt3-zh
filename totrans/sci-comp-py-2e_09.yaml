- en: Iterating
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will present iterations using loops and iterators. We will
    show examples of how this can be used with lists and generators. Iteration is
    one of the fundamental operations a computer is useful for. Traditionally, iteration
    is achieved with a `for` loop. A `for` loop is a repetition of a block of instructions
    a certain number of times. Inside the loop, you have access to a loop variable,
    in which the iteration number is stored.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop in Python is primarily designed to exhaust a list, that is, to
    repeat the same sequence of commands for each element of that list. The effect
    is similar to the repetition effect just described if you use a list containing
    the first [![](img/884f8125-1635-4209-8092-168269add126.png)] integers.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop only needs one element of the list at a time. It is therefore desirable
    to use a `for` loop with objects that are able to create those elements on demand,
    one at a time, instead of providing a complete list. This is what iterators achieve
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The for statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the flow inside the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List-filling patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When iterators behave as lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterator objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinite iterations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1 The for statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary aim of the `for` statement is to traverse a list, that is, to apply
    the same sequence of commands to each element of a given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the loop variable, `s`, is successively assigned to one element
    of the list. Notice that the loop variable is available after the loop has terminated.
    This may sometimes be useful; see, for instance, the example in [Section 9.2](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):* Controlling
    the flow inside the loop**.*
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most frequent uses of a `for` loop is to repeat, that is, to apply
    the same sequence of commands to each element of a given list: a given task a
    defined number of times, using the function `range`, see [Section 1.3.1](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml): *Lists*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the purpose of a loop is to go through a list, many languages (including
    Python) offer the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the purpose of that code were to go through the list `my_list`, the preceding
    code would not make it very clear. For this reason, a better way to express this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now clear at first glance that the preceding piece of code goes through
    the list `my_list`. Note that if you really need the index variable [![](img/63a53532-5287-44f2-8eda-69d97e13fc06.png)],
    you may replace the preceding code with this (see also [Section 9.3.3](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Iterator tools*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent of this piece of code is to go through `my_list` while keeping the
    index variable `k` available. A similar construction for arrays is the command `ndenumerate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 9.2 Controlling the flow inside the loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is necessary to jump out of the loop or to go directly to the next
    loop iteration. These two operations are performed by the commands `break` and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `break` is used to terminate the loop before it is completely executed—it
    breaks the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two situations can occur in loops with a **`break`** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: The loop is completely executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop is left when reaching `break` before it was completely executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first case, special actions can be defined in an `else` block, which
    is executed if the whole list is traversed. This is useful in general if the purpose
    of the `for` loop is to find something and stop. Examples might be searching for
    one element satisfying a certain property inside a list. If such an element is not
    found, the `else` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a common usage in scientific computing: Quite often, we use an iterating
    algorithm that is not guaranteed to succeed. In that case, it is preferable to
    use a (big) finite loop so that the program does not get caught in an infinite
    loop. The `for`/`else` construct allows such an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 9.3 Iterable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `for` loop is primarily used to traverse a list, but it picks the elements
    of the list one at a time. In particular, there is no need to store the whole
    list in memory for the loop to work properly. The mechanism that allows `for` loops
    to work without lists is that of iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterable object produces objects to be passed to a loop. Such an object
    may be used inside a loop as if it were a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The notion of iterable objects thus generalizes the idea of lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest example of an iterable object is given by lists. The produced
    objects are simply the objects stored in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: An iterable object need not produce existing objects. The objects may, instead,
    be produced on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical iterable is the object returned by the function `range`. This function
    works as if it would generate a list of integers, but instead, the successive
    integers are produced on the fly when they are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really need a list with all integers between 0 and 100,000,000, then
    it has to be formed explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Iterable objects have a method called `__iter__`. That's how you can check whether
    a given object in Python is iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have met the following datatypes, which are iterable objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lists`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tuples`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dictionaries`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arrays`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerate` and `ndenumerate` objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By executing the method `__iter__` on an iterable object, an iterator is created.
    This is tacitly done when a `for` loop is invoked. An iterator has a `__next__`
    method, which returns the next element of a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 9.3.1 Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create your own iterator by using the keyword `yield`. For example,
    a generator for odd numbers smaller than ![](img/4348dffe-7c52-4c93-b2ed-4ebcba289e27.png)
    can be defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 9.3.2 Iterators are disposable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One salient feature of iterators is that they may be used only once. In order
    to use the iterator again, you will have to create a new iterator object. Note
    that an iterable object is able to create new iterators as many times as necessary.
    Let''s examine the case of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time a generator object is called, it creates a new iterator. Hence, when
    that iterator is exhausted, you have to call the generator again to obtain a new
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 9.3.3 Iterator tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will introduce a couple of iterator tools that often come in very handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enumerate` is used to enumerate another iterator. It produces a new iterator
    that yields pairs (`iteration`, element), where `iteration` stores the index of
    the iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`reversed` creates an iterator from a list by going through that list backward.
    Notice that this is different from creating a reversed list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`itertools.count` is a possibly infinite iterator of integers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`intertools.islice` truncates an iterator using the familiar `slicing` syntax;
    see [Section 3.1.1](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Slicing*. One
    application is creating a finite iterator from an infinite one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s find some odd numbers by combining `islice` with an infinite
    generator. First, we modify the generator for odd numbers so that it becomes an
    infinite generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use it with `islice` to get a list of some odd numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command takes from an assumed list of all odd numbers, the one with index
    10 to index 29 in steps of 8.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.4 Generators of recursive sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume that a sequence is given by an induction formula. For instance, consider
    the Fibonacci sequence, defined by the recurrence formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a432e87d-4a3b-481f-9e74-d3d47460e116.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This sequence depends on two initial values, namely [![](img/51fb6836-fce2-4b89-9a06-a75e2c6bad68.png)]
    and [![](img/bb815d4b-45f2-4d4a-a045-61875a23df13.png)], although for the standard
    Fibonacci sequence those numbers are taken as 0 and 1 respectively. A nifty way
    of programming the generation of such a sequence is by using generators, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This may then be used, for instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 9.3.5 Examples for iterators in mathematics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic geometric mean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more elaborate example for a generator is its use for an iteration based
    on iteratively computing arithmetic and geometric means – the so-called **AGM
    iteration,** see [[1]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a450656-718a-4c79-b8b8-038fd2a7dabf.png)'
  prefs: []
  type: TYPE_IMG
- en: We demonstrate this iteration here in the context of computing elliptic integrals
    for determining the period of a mathematical pendulum.
  prefs: []
  type: TYPE_NORMAL
- en: 'When started with the values ![](img/3f4b7ed9-ab08-4774-8cce-cb9ff9ac209b.png),
    the AGM iteration generates a sequence of numbers with the following (astonishing)
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33038d29-70ff-42b2-96ed-d194ec4800c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The integral on the right-hand side is called a complete elliptic integral
    of the first kind. We''ll now proceed to compute this elliptic integral. We use
    a generator to describe the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As the sequences [![](img/307dffaf-3613-428b-bbaf-de773830e787.png)] converge
    to the same value, the sequence [![](img/f595ec23-48f9-4f3c-9269-6c7e1ad570c2.png)]
    defined by [![](img/0b22114b-d670-41ce-999b-dc4c47cef153.png)] converges to zero—a
    fact that will be used to terminate the iteration in the program to compute the
    elliptic integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure that the algorithm stops. Note that this code fully relies
    on the mathematical statement that the arithmetic-geometric mean iteration converges
    (fast). In practical computing, we have to be careful while applying theoretical
    results, as they might no longer be valid in limited-precision arithmetic. The
    right way to make the preceding code safe is to use `itertools.islice`. The safe
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As an application, elliptic integrals may be used to compute the period [![](img/2305b79a-4aba-47f8-9a9f-5a6b6b1f9df4.png)]
    of a pendulum of length [![](img/0f853c58-6445-4d8e-a411-e073c213f108.png)] starting
    at an angle [![](img/1de0db74-1210-4943-896d-5de9701da0bc.png)] using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a6b1af-cedc-48c1-be1e-093174af6636.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this formula, the period of the pendulum is easily obtained, see [[18]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Convergence acceleration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll give an example of the application of generators for convergence acceleration.
    This presentation closely follows the example given in [[9]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Note that a generator may take another generator as an input parameter. For
    instance, suppose that we have defined a generator that generates the elements
    of a converging sequence. It is then possible to improve the convergence by an
    acceleration technique due to *Euler* and *Aitken*, often called Aitken's Δ²-method,
    see [[33]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml)*.* It transforms a sequence [![](img/7a713aba-765a-4631-9538-03b54ca291c3.png)]
    into another by defining
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3bc7362-d7f9-48b9-99c7-f8e1e0dd100f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both sequences have the same limit, but the sequence [![](img/f14f54e1-ea9a-485e-bbe3-f139d46526d7.png)] converges
    significantly faster. One possible implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As an example, we use the series *![](img/1b9d4037-f4c4-4c8c-a638-aa4362709ad7.png), *which
    converges to ![](img/131e9ae0-b279-4681-8a12-69d0eb6ca6e1.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement this series as a generator in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We may now use the accelerated version of that sequence using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, the first *N* elements of that accelerated sequence are obtained
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note, here we stacked three generators: `pi_series`, `Euler_accelerate`, and
    `itertools.islice`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.1* shows the convergence rate of the log of the error for the standard
    version of the sequence defined by the preceding formula and its accelerated version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3d3fdf4-b5ce-4e86-9657-ae04d17361f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Comparison between the sequence and its accelerated version'
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 List-filling patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will compare different ways to fill lists. They are different
    in computational efficiency and also in code readability.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.1 List filling with the append method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ubiquitous programming pattern is to compute elements and store them in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach has a number of disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of iterations is decided in advance. If there is a `break` instruction,
    then the preceding code takes care of both generating values and deciding when
    to stop. This is not desirable and lacks flexibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the assumption that the user wants the whole history of the computation,
    for all the iterations. Suppose we are only interested in the sum of all the computed
    values. If there are many computed values, it does not make sense to store them,
    as it is much more efficient to add them one at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.4.2 List from iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterators provide us with an elegant solution to problems discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With iterators, we separate the task of generating the computed values without
    bothering about the stopping condition or about the storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user of that code wants to store the [![](img/c8b7f35d-215d-4049-8d4d-564c7bfa755a.png)] first
    values, it is easily done using the `list` constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user wants the sum of the first *n* generated values, this construction
    is recommended:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user wants to generate all elements until a certain condition is fulfilled,
    the function `itertools.takewhile` comes in handy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The function `takewhile` takes as a first argument a function that returns a
    Boolean. Its second argument is a generator. The generator is iterated as long
    as the function evaluates to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: What we did here was separate the generation of elements on one hand, and store
    those elements on the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the purpose is really to build a list, and when the result at each step
    does not depend on previously computed elements, you may use the list comprehension
    syntax (see [Section 3.1.6](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *List
    Comprehension*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When iteratively computing values that depend on the previously computed values,
    list comprehensions cannot help.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.3 Storing generated values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using iterators to fill out lists will work nicely most of the time, but there
    are complications to this pattern when the algorithm computing the new values
    is liable to throw an exception; if the iterator raises an exception along the
    way, the list will not be available! The following example illustrates this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we generate the sequence defined recursively by [![](img/dc077bef-8013-4d4a-ba02-89f971e6ea90.png)].
    This sequence quickly diverges to infinity if the initial data [![](img/f660ed0a-4dcc-4c12-beb2-af8ae2327ab3.png)] is
    greater than one. Let''s generate it with a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to obtain the first *20* elements of the sequence (initialized by
    [![](img/83467fe6-ed62-4c7a-82f5-b2866a8021c2.png)]) by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'An `OverflowError` exception will be raised and no list will be available,
    not even the list of elements before the exception was raised. There is currently
    no way to obtain a partially filled list from a possibly faulty generator. The
    only way around this is to use the method `append` wrapped in an exception-catching
    block (see [Section 12.1](9bd2d3f3-b846-4421-931c-7ebfbdc8fbea.xhtml): *What are
    exceptions?*, for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 9.5 When iterators behave as lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some list operations also work on iterators. We will now examine the equivalents
    of *list comprehensions* and *list zipping* (see [Section 3.1.6](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *List Comprehension*, and [Section 3.1.5](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    *Merging Lists*).'
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.1 Generator expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is an equivalent of list comprehension for generators. Such a construction
    is called a generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful in particular for computing sums or products because those operations
    are incremental; they only need one element at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In that code, you notice that the `sum` function is given one argument, which
    is a generator expression. Note that Python syntax allows us to omit the enclosing
    parentheses of generators when a generator is used as the *only* argument of a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's compute the Riemann zeta function [![](img/e733c4da-13fa-4f7d-9d9f-a04d2b99d8b6.png)],
    whose expression is
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbfb420f-4add-41a5-b7d7-2aaac00e3234.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With a generator expression, we may compute a partial sum of this series in
    one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we could also have defined a generator of the sequence [![](img/49cf6b79-a417-44e4-8edf-604afaef358d.png)] as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we simply obtain the sum of the first *N* terms using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We point out that we used this way of computing the zeta (![](img/4e60ab18-0e48-49d9-9e83-1d599478085e.png))
    function as a demonstration of the use of generators in an elegant way. It is
    certainly not the most accurate and computationally efficient way to evaluate
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2 Zipping iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in [Section 3.1.5](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Merging
    Lists* that it is possible to create a list out of two or more lists by zipping
    them together. The same operation exists for iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The zipped iterator stops as soon as one of the iterators is exhausted. This
    is the same behavior as the operation zip on lists.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Iterator objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, a `for` loop only needs an iterable object. Lists,
    in particular, are iterable objects. This means that a list is able to create
    an iterator from its contents. In fact, this is true for any object (not only
    lists): any object may be made iterable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is achieved via the method `__iter__`, which should return an iterator.
    Here we give an example where the method `__iter__` is a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to use the features of an iterator with an object that is not iterable,
    an exception will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the function list tries to iterate through object *3* by calling
    the method `__iter__`. But this method is not implemented for integers and thus
    the exception is raised. The same would happen if we tried to cycle through a
    non-iterable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 9.7 Infinite iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infinite iterations are obtained either with an infinite iterator, with a `while` loop,
    or by recursion. Obviously, in practical cases, some condition stops the iteration.
    The difference with finite iterations is that it is impossible to say from a cursory
    examination of the code whether the iteration will stop or not.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.1 The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop may be used to repeat a code block until a condition is fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A `while` loop is equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So a `while` loop used to repeat a code block until a condition is fulfilled
    is equivalent to an infinite iterator, which might be stopped if a condition is
    fulfilled. The danger of such a construction is obvious: the code may be trapped
    in an infinite loop if the condition is never fulfilled.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem in scientific computing is that you are not always sure that an
    algorithm will converge. Newton iteration, for instance, might not converge at
    all. If that algorithm were implemented inside a `while` loop, the corresponding
    code would be trapped in an infinite loop for some choices of initial conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, therefore, advise that finite iterators are often better suited for such
    a task. The following construction replaces, often advantageously, the use of
    a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first advantage is that the code is guaranteed to execute in a finite time
    no matter what happens. The second advantage is that the variable `nb_iterations` contains
    the number of iterations that were necessary for the algorithm to converge.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7.2 Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursion occurs when a function calls itself (see [Section 7.4](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Recursive functions*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing recursions, it is the recursion depth, which is the number of iterations,
    that brings your computer to its limits. We demonstrate this here by considering
    a simple recursion, which actually contains no computations at all. It assigns
    to the iterates only the value zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your system, this program may choke for [![](img/aa5d7601-eb3e-462c-998a-82481eb1cb19.png)] (too
    much memory is used). The result is that the Python interpreter crashes without
    further exception. Python provides a mechanism to raise an exception when a too
    high recursion depth is detected. This maximum recursion depth may be changed
    by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Be aware though, that choosing too high a number may imperil the stability of
    your code since Python might crash before that maximum depth is reached. It is
    therefore often wise to leave the recursion limit as it is. The actual value of
    the recursion limit can be obtained with `sys.getrecursionlimit()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By comparison, the following, non-recursive, program runs ten of millions of
    iterations without any problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We advocate that, if possible, recursion should be avoided in Python. This applies
    obviously only if there is an appropriate alternative iterative algorithm available.
    The first reason is that a recursion of depth ***N*** involves ***N*** function
    calls at the same time, which might result in significant overhead. The second
    reason is that it is an infinite iteration, that is, it is difficult to give an
    upper bound to the number of steps necessary before the recursion is over.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in some very special cases (tree traversal) recursion is unavoidable.
    Besides, in some cases (with small recursion depths), recursive programs might
    be preferred due to readability.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied iterators, a programming construct very near to
    a mathematical description of iterative methods. You saw the keyword `yield` and
    met finite and infinite iterators.
  prefs: []
  type: TYPE_NORMAL
- en: We showed that an iterator can be exhausted. More special aspects such as iterator
    comprehension and recursive iterators were introduced and demonstrated with the
    help of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Compute the value of the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b05ec3f-b024-4e2b-a7eb-f19551a2a39f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 2:** Create a generator that computes the sequence defined by the relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22f0a02e-8752-4d58-834b-0b735ce239ee.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 3:** Generate all the even numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4:** Let [![](img/537c8f39-479d-4a88-aa87-8baf6d233dc6.png)]. In calculus,
    it is shown that [![](img/88618432-dea1-4b8a-90ee-8d86ec945649.png)] . Determine
    experimentally the smallest number ![](img/c07910ea-e646-4704-b8cf-570ab0119311.png) such
    that [![](img/6c5d2fa8-5a02-4ec7-804a-5eaacc778498.png)]. Use a generator for
    this task.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5:** Generate all prime numbers less than a given integer. Use the algorithm called
    *Sieve of Eratosthenes*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6:** Solving the differential equation [![](img/58410877-2e15-408b-837f-556aafbd0813.png)] by
    applying the explicit Euler method results in the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18d7bbb3-ac62-4a96-b4e0-f7f158ae0e14.png)'
  prefs: []
  type: TYPE_IMG
- en: Write a generator that computes the solution values ![](img/ba1d483f-8eeb-4757-b16a-41b8eebb06f3.png) for
    a given initial value ![](img/2c063d73-e6ca-4631-b913-13da8ed5304f.png) and for
    a given value of the time step ![](img/0968c1ee-c6bc-4419-971d-41367ac5c23e.png).
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 7:** Compute π using the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a41172d-85e9-497c-874c-b4136baa9345.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The integral can be approximated using the composite trapezoidal rule, that
    is, with this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/716db66e-5e6b-4b0b-b857-3c23f53d434d.png)'
  prefs: []
  type: TYPE_IMG
- en: where ![](img/016f2ebf-9dc1-4d3a-aea3-a79cf4d62594.png).
  prefs: []
  type: TYPE_NORMAL
- en: Program a *generator* for the values [![](img/5b6bfda4-c20d-4d09-9ae9-de27d85f262a.png)]and
    evaluate the formula by summing one term after the other. Compare your results
    with the `quad` function of SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 8:** Let `x = [1, 2, 3]` and `y = [-1, -2, -3]`. What is the effect of
    the code `zip(*zip(x, y))`? Explain how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 9:** Complete elliptic integrals can be computed by the function `scipy.special.ellipk`.
    Write a function that counts the number of iterations needed with the AGM iteration
    until the result coincides up to a given tolerance (note that the input parameter *m* in `ellipk` corresponds
    to ![](img/133737ff-4444-4eea-be8a-fd8203c3c069.png)in the definition in [Section
    9.3.5](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Examples for iterators in
    mathematics**)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 10:** Consider the sequence ![](img/75a5ddd1-5690-43e0-b573-1cefd1970ee0.png) defined
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71ce32bd-58ef-4de2-a1fa-2f20fa5758f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It converges monotonically to zero: ![](img/afb2bccf-36b3-4806-9e84-8584f4e91519.png).
    By integration by parts, we can show that the sequence ![](img/2c8e757e-4b77-48b0-bab8-042394496e33.png) fulfills
    the following recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0047906-eee8-4a58-84ad-dd88feabca58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Compute the first 20 terms of the recursion by using an appropriate generator
    and compare the results with those obtained by numerical integration with `scipy.integrate.quad`.
    Do the same by reversing the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd183bb8-3c5a-40c3-9e70-21cf9c912900.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the function `exp` to evaluate the exponential function. What do you observe?
    Do you have an explanation? See also [[29]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/885ef052-42d3-4c73-8d41-d022a0029e9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: A convergence study of functions approximating [![](img/4ecef828-561f-47fa-a43d-b48302a5c823.png)]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 11:** The sine-function can be expressed due to Euler as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d5b517e-f89b-47f2-9ba0-429b35442493.png)'
  prefs: []
  type: TYPE_IMG
- en: Write a generator that generates the function values ***P[k](x)***. Set `x=linspace(-1,3.5*pi,200)` and
    demonstrate graphically how well ***P[k](x)*** approximates **sin** for increasing *k*.
    In *Figure 9.2*, the possible result is shown. Consult also Theorem 5.2, p. 65
    in [[11]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
