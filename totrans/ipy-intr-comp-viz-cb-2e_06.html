<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 6. Advanced Visualization"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Advanced Visualization</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making nicer matplotlib figures with prettyplotlib</li><li class="listitem" style="list-style-type: disc">Creating beautiful statistical plots with seaborn</li><li class="listitem" style="list-style-type: disc">Creating interactive web visualizations with Bokeh</li><li class="listitem" style="list-style-type: disc">Visualizing a NetworkX graph in the IPython notebook with D3.js</li><li class="listitem" style="list-style-type: disc">Converting matplotlib figures to D3.js visualizations with mpld3</li><li class="listitem" style="list-style-type: disc">Getting started with Vispy for high-performance interactive data visualizations</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Introduction</h1></div></div></div><p>Visualization is a central theme of this book. We create graphics in most recipes because that's the most efficient way to communicate quantitative information. In most cases, we use matplotlib to create plots. In this chapter, we will see more advanced visualization features in Python.</p><p>First, we will see a few packages that let us improve the default styling of matplotlib figures and the MATLAB-like pyplot interface. There are other high-level visualization programming interfaces that can be more convenient in some situations.</p><p>Also, the Web platform is getting closer and closer to Python. The IPython notebook is a good example of this trend. In this chapter, we will see a few techniques and libraries to create interactive Web visualizations in Python. These techniques will let us combine the power of Python for data analysis and the power of the Web for interactivity.</p><p>Finally, we will introduce Vispy, a new high-performance interactive visualization library for big data.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Making nicer matplotlib figures with prettyplotlib"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Making nicer matplotlib figures with prettyplotlib</h1></div></div></div><p>matplotlib<a id="id877" class="indexterm"/> is sometimes criticized for the default appearance of its figures. For example, the default color maps are neither aesthetically appealing nor do they present perceptually clear information.</p><p>There are many attempts to circumvent this problem. In this recipe, we will present <a id="id878" class="indexterm"/><span class="strong"><strong>prettyplotlib</strong></span>, created by Olga Botvinnik. This lightweight Python library considerably improves the default styling of many kinds of matplotlib figures.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec207"/>Getting ready</h2></div></div></div><p>You will find the installation instructions of <a id="id879" class="indexterm"/>prettyplotlib on the project's page at <a class="ulink" href="http://github.com/olgabot/prettyplotlib">http://github.com/olgabot/prettyplotlib</a>. You can basically just do <code class="literal">pip install prettyplotlib</code> in a terminal.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec208"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's first <a id="id880" class="indexterm"/>import NumPy and<a id="id881" class="indexterm"/> matplotlib:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        import matplotlib as mpl
        %matplotlib inline</pre></div></li><li class="listitem">We then draw several curves with matplotlib:<div class="informalexample"><pre class="programlisting">In [2]: np.random.seed(12)
        for i in range(8):
            x = np.arange(1000)
            y = np.random.randn(1000).cumsum()
            plt.plot(x, y, label=str(i))
        plt.legend()</pre></div><div class="mediaobject"><img src="images/4818OS_06_01.jpg" alt="How to do it…"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>If you're reading the printed version of this book, you won't see the colors. You can find the colored images on the book's website.</p></div></div></li><li class="listitem">Now, we <a id="id882" class="indexterm"/>create the exact same plot with <a id="id883" class="indexterm"/>prettyplotlib. We just replace the <code class="literal">matplotlib.pyplot</code> namespace with <code class="literal">prettyplotlib</code>:<div class="informalexample"><pre class="programlisting">In [3]: import prettyplotlib as ppl
        np.random.seed(12)
        for i in range(8):
            x = np.arange(1000)
            y = np.random.randn(1000).cumsum()
            ppl.plot(x, y, label=str(i))
        ppl.legend()</pre></div><div class="mediaobject"><img src="images/4818OS_06_02.jpg" alt="How to do it…"/></div></li><li class="listitem">Let's show another<a id="id884" class="indexterm"/> example with an<a id="id885" class="indexterm"/> image. We first use matplotlib's <code class="literal">pcolormesh()</code> function<a id="id886" class="indexterm"/> to display a 2D array as an image:<div class="informalexample"><pre class="programlisting">In [4]: np.random.seed(12)
        plt.pcolormesh(np.random.rand(16, 16))
        plt.colorbar()</pre></div><div class="mediaobject"><img src="images/4818OS_06_03.jpg" alt="How to do it…"/></div><p>The default <span class="emphasis"><em>rainbow</em></span> color map is known to cause visualized data to be misinterpreted.</p></li><li class="listitem">Now, we use prettyplotlib to display the exact same image:<div class="informalexample"><pre class="programlisting">In [5]: np.random.seed(12)
        ppl.pcolormesh(np.random.rand(16, 16))</pre></div><div class="mediaobject"><img src="images/4818OS_06_04.jpg" alt="How to do it…"/></div><p>This visualization is much clearer, in that high or low values are more obvious than with the rainbow color map.</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec209"/>How it works…</h2></div></div></div><p>prettyplotlib<a id="id887" class="indexterm"/> merely tweaks the default styling <a id="id888" class="indexterm"/>options of matplotlib. The plotting interface is basically the same as matplotlib. To understand how to modify matplotlib's styling, it is worthwhile looking at prettyplotlib's code.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec210"/>There's more…</h2></div></div></div><p>There are other ways to improve<a id="id889" class="indexterm"/> matplotlib's styling:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A blog post by Randal Olson explains how to make clean and beautiful plots with matplotlib; this is available at <a class="ulink" href="http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/">http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/</a></li><li class="listitem" style="list-style-type: disc">There is some work in progress in matplotlib to add style sheet support; more information can be found at <a class="ulink" href="http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst">http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst</a></li><li class="listitem" style="list-style-type: disc">Information about why rainbow color maps are misleading, at <a class="ulink" href="http://eagereyes.org/basics/rainbow-color-map">http://eagereyes.org/basics/rainbow-color-map</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec211"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating beautiful statistical plots with seaborn</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating beautiful statistical plots with seaborn"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Creating beautiful statistical plots with seaborn</h1></div></div></div><p>matplotlib comes with a high-level plotting API called<a id="id890" class="indexterm"/> <span class="strong"><strong>pyplot</strong></span>. Inspired by MATLAB (a widespread commercial software for numerical computing), this interface may be a bit too low-level for scientists, in that it can lead to boilerplate code that is difficult to read and <a id="id891" class="indexterm"/>maintain. Yet, it is probably one of the most widely used <a id="id892" class="indexterm"/>plotting interfaces in the scientific Python community.</p><p>There exist higher-level, more convenient plotting interfaces. In this recipe, we present <span class="strong"><strong>seaborn</strong></span><a id="id893" class="indexterm"/> created by Michael Waskom. This library exposes a high-level plotting API that is specifically adapted to statistical figures. It also integrates nicely with pandas.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec212"/>Getting ready</h2></div></div></div><p>You will find the installation instructions of<a id="id894" class="indexterm"/> seaborn on the project's page at <a class="ulink" href="http://github.com/mwaskom/seaborn">http://github.com/mwaskom/seaborn</a>. You can just type <code class="literal">pip install seaborn</code> in a terminal.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec213"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy, matplotlib, and seaborn:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        import seaborn as sns
        %matplotlib inline</pre></div></li><li class="listitem">We generate a random dataset (following the example on seaborn's website at <a class="ulink" href="http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb">http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb</a>):<div class="informalexample"><pre class="programlisting">In [2]: x1 = np.random.randn(80)
        x2 = np.random.randn(80)
        x3 = x1 * x2
        y1 = .5 + 2 * x1 - x2 + 2.5 * x3 + \
             3 * np.random.randn(80)
        y2 = .5 + 2 * x1 - x2 + 2.5 * np.random.randn(80)
        y3 = y2 + np.random.randn(80)</pre></div></li><li class="listitem">Seaborn implements many easy-to-use statistical plotting functions. For example, here is how to create a <a id="id895" class="indexterm"/><span class="strong"><strong>violin plot</strong></span>. This type of plot allows us to show the detailed distribution of sets of points, instead of just quartiles like in box plots:<div class="informalexample"><pre class="programlisting">In [3]: sns.violinplot([x1,x2, x3])</pre></div><div class="mediaobject"><img src="images/4818OS_06_05.jpg" alt="How to do it…"/></div></li><li class="listitem">Seaborn also implements all-in-one statistical visualization functions. For example, we can use a single function (<code class="literal">regplot()</code>) to perform <span class="emphasis"><em>and</em></span> display a linear regression between two variables:<div class="informalexample"><pre class="programlisting">In [4]: sns.regplot(x2, y2)</pre></div><div class="mediaobject"><img src="images/4818OS_06_06.jpg" alt="How to do it…"/></div></li><li class="listitem">Seaborn has built-in <a id="id896" class="indexterm"/>support for pandas data<a id="id897" class="indexterm"/> structures. Here, we display the pair-wise correlations between all variables defined in a <code class="literal">DataFrame</code> object:<div class="informalexample"><pre class="programlisting">In [5]: df = pd.DataFrame(dict(x1=x1, x2=x2, x3=x3, 
                               y1=y1, y2=y2, y3=y3))
        sns.corrplot(df)</pre></div><div class="mediaobject"><img src="images/4818OS_06_07.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec214"/>There's more…</h2></div></div></div><p>Besides seaborn, there are other high-level plotting interfaces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The Grammar of Graphics</em></span> is a book<a id="id898" class="indexterm"/> by Dr. Leland Wilkinson that has influenced many high-level plotting interfaces such as R's <span class="emphasis"><em>ggplot2</em></span>, Python's <span class="emphasis"><em>ggplot</em></span> by yhat, <span class="emphasis"><em>
</em></span>and others.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vega</strong></span>, by Trifacta, is<a id="id899" class="indexterm"/> a declarative visualization grammar that can be translated to D3.js (a JavaScript visualization library). Also, <span class="strong"><strong>Vincent</strong></span><a id="id900" class="indexterm"/> is a Python library that lets us create visualizations with Vega.</li><li class="listitem" style="list-style-type: disc">Tableau's <span class="strong"><strong>VizQL</strong></span><a id="id901" class="indexterm"/> is a commercial database-oriented visualization language.</li></ul></div><p>Here are some more references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vega available<a id="id902" class="indexterm"/> at <a class="ulink" href="http://trifacta.github.io/vega/">http://trifacta.github.io/vega/</a></li><li class="listitem" style="list-style-type: disc">Vincent<a id="id903" class="indexterm"/> available at <a class="ulink" href="http://vincent.readthedocs.org/en/latest/">http://vincent.readthedocs.org/en/latest/</a></li><li class="listitem" style="list-style-type: disc">ggplot2 available<a id="id904" class="indexterm"/> at <a class="ulink" href="http://ggplot2.org/">http://ggplot2.org/</a></li><li class="listitem" style="list-style-type: disc">ggplot<a id="id905" class="indexterm"/> for Python available at <a class="ulink" href="http://blog.yhathq.com/posts/ggplot-for-python.html">http://blog.yhathq.com/posts/ggplot-for-python.html</a></li><li class="listitem" style="list-style-type: disc">VizQL available<a id="id906" class="indexterm"/> at <a class="ulink" href="http://www.tableausoftware.com/fr-fr/products/technology">http://www.tableausoftware.com/fr-fr/products/technology</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec215"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Making nicer matplotlib figures with prettyplotlib</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating interactive web visualizations with Bokeh"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Creating interactive web visualizations with Bokeh</h1></div></div></div><p>
<span class="strong"><strong>Bokeh</strong></span><a id="id907" class="indexterm"/> is a library for creating rich interactive visualizations in a browser. Plots are designed in Python, and they are entirely rendered in the browser. In this recipe, we will learn how to create and render interactive Bokeh figures in the IPython notebook.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec216"/>Getting ready</h2></div></div></div><p>Install Bokeh by following<a id="id908" class="indexterm"/> the instructions on the <a id="id909" class="indexterm"/>website<a id="id910" class="indexterm"/> at <a class="ulink" href="http://bokeh.pydata.org">http://bokeh.pydata.org</a>. In principle, you can just type <code class="literal">pip install bokeh</code> in a terminal. On Windows, you can also download the binary installer from Chris Gohlke's website at <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh">http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec217"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy and Bokeh. We need to call the <code class="literal">output_notebook()</code> function in order to tell Bokeh to render plots in the IPython notebook:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import bokeh.plotting as bkh
        bkh.output_notebook()</pre></div></li><li class="listitem">We create some random data:<div class="informalexample"><pre class="programlisting">In [2]: x = np.linspace(0., 1., 100)
        y = np.cumsum(np.random.randn(100))</pre></div></li><li class="listitem">Let's draw a curve:<div class="informalexample"><pre class="programlisting">In [3]: bkh.line(x, y, line_width=5)
        bkh.show()</pre></div><p>An interactive plot is rendered in the notebook. We can pan and zoom by clicking on the buttons above the plot:</p><div class="mediaobject"><img src="images/4818OS_06_08.jpg" alt="How to do it…"/><div class="caption"><p>An interactive plot with Bokeh</p></div></div></li><li class="listitem">Let's move on to<a id="id911" class="indexterm"/> another example. We<a id="id912" class="indexterm"/> first load a sample dataset (<span class="emphasis"><em>Iris flowers</em></span>). We also generate some colors based on the species of the flowers:<div class="informalexample"><pre class="programlisting">In [4]: from bokeh.sampledata.iris import flowers
        colormap = {'setosa': 'red',
                    'versicolor': 'green',
                    'virginica': 'blue'}
        flowers['color'] = flowers['species'].map(
                                   lambda x: colormap[x])</pre></div></li><li class="listitem">Now, we render an interactive scatter plot:<div class="informalexample"><pre class="programlisting">In [5]: bkh.scatter(flowers["petal_length"], 
                    flowers["petal_width"],
                    color=flowers["color"], 
                    fill_alpha=0.25, size=10,)
        bkh.show()</pre></div><div class="mediaobject"><img src="images/4818OS_06_09.jpg" alt="How to do it…"/><div class="caption"><p>An interactive scatter plot with Bokeh</p></div></div></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec218"/>There's more…</h2></div></div></div><p>Bokeh figures<a id="id913" class="indexterm"/> in the notebook are interactive even in the absence of a Python server. For example, our figures can be interactive in nbviewer. Bokeh can also generate standalone HTML/JavaScript documents from our plots. More examples can be found in the gallery at <a class="ulink" href="http://bokeh.pydata.org/docs/gallery.html">http://bokeh.pydata.org/docs/gallery.html</a>.</p><p>There is an IPython extension in Bokeh<a id="id914" class="indexterm"/> that simplifies the integration of interactive plots in the notebook. This is available at <a class="ulink" href="http://github.com/ContinuumIO/bokeh/tree/master/extensions">http://github.com/ContinuumIO/bokeh/tree/master/extensions</a>.</p><p>In the same vein, let's mention <span class="emphasis"><em>plot.ly</em></span>, an online commercial service for interactive Web-based visualization that offers Python interfaces, available at <a class="ulink" href="http://plot.ly">http://plot.ly</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec219"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Converting matplotlib figures to D3.js visualizations with mpld3</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Visualizing a NetworkX graph in the IPython notebook with D3.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Visualizing a NetworkX graph in the IPython notebook with D3.js</h1></div></div></div><p>D3.js (<a class="ulink" href="http://d3js.org">http://d3js.org</a>) is<a id="id915" class="indexterm"/> a <a id="id916" class="indexterm"/>popular interactive visualization framework for the Web. Written in JavaScript, it allows us to create data-driven visualizations based on Web technologies such as HTML, SVG, and CSS. There are many other JavaScript visualization and charting libraries, but we will focus on D3.js in this recipe.</p><p>Being a pure JavaScript library, D3.js has in principle nothing to do with Python. However, the HTML-based IPython notebook can integrate D3.js visualizations seamlessly.</p><p>In this recipe, we will create a <a id="id917" class="indexterm"/>graph in Python with NetworkX and <a id="id918" class="indexterm"/>visualize it in the IPython notebook with <a id="id919" class="indexterm"/>D3.js.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec220"/>Getting ready</h2></div></div></div><p>You need to know the basics of HTML, JavaScript, and D3.js for this recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec221"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import the packages:<div class="informalexample"><pre class="programlisting">In [1]: import json
        import numpy as np
        import networkx as nx
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We load a famous social graph published in 1977 called <span class="strong"><strong>Zachary's Karate Club graph</strong></span>. This graph <a id="id920" class="indexterm"/>represents the friendships between members of a Karate club. The club's president and the instructor were involved in a dispute, resulting in a split of this group. Here, we simply display the graph with matplotlib (using the <code class="literal">networkx.draw()</code> function):<div class="informalexample"><pre class="programlisting">In [2]: g = nx.karate_club_graph()
        nx.draw(g)</pre></div><div class="mediaobject"><img src="images/4818OS_06_10.jpg" alt="How to do it…"/></div></li><li class="listitem">Now, we're going<a id="id921" class="indexterm"/> to display this graph in the <a id="id922" class="indexterm"/>notebook with D3.js. The first<a id="id923" class="indexterm"/> step is to bring this graph to JavaScript. Here, we choose to export the graph to JSON. D3.js generally expects each edge to be an object with a source and target. Also, we specify which side each member has taken (<code class="literal">club</code> attribute). NetworkX comes with a built-in export function that we can use here:<div class="informalexample"><pre class="programlisting">In [3]: from networkx.readwrite import json_graph
        data = json_graph.node_link_data(g)
        with open('graph.json', 'w') as f:
            json.dump(data, f, indent=4)</pre></div></li><li class="listitem">The next step is to create an HTML object that will contain the visualization. Here, we create a <code class="literal">&lt;div&gt;</code> element in the notebook. We also specify a few CSS styles for nodes and links (also called edges):<div class="informalexample"><pre class="programlisting">In [4]: %%html
        &lt;div id="d3-example"&gt;&lt;/div&gt;
        &lt;style&gt;
        .node {stroke: #fff; stroke-width: 1.5px;}
        .link {stroke: #999; stroke-opacity: .6;}
        &lt;/style&gt;</pre></div></li><li class="listitem">The last step is trickier. We write the JavaScript code to load the graph from the JSON file and display it with D3.js. Knowing the basics of D3.js is required here (see the documentation of D3.js). The code is long, and you can find it on the book's website. Here, we highlight the most important steps:<div class="informalexample"><pre class="programlisting">In [5]: %%javascript
    // We load the d3.js library. 
    require(["d3"], function(d3) {
        // The code in this block is executed when the 
        // d3.js library has been loaded.
        [...]
        // We create a force-directed dynamic graph 
        // layout.
        var force = d3.layout.force().charge(-120).
               linkDistance(30).size([width, height]);
        [...]
        // In the &lt;div&gt; element, we create a &lt;svg&gt; graphic
        // that will contain our interactive 
        // visualization.
        var svg = d3.select("#d3-example").select("svg");
        [...]
        // We load the JSON file.
        d3.json("graph.json", function(error, graph) {
            // We create the graph here.
            force.nodes(graph.nodes).links(graph.links)
                 .start();

            // We create a &lt;line&gt; SVG element for each
            // link in the graph.
            var link = svg.selectAll(".link")
                    .data(graph.links)
                    .enter().append("line")
                    .attr("class", "link");

            // We create &lt;circle&gt; SVG elements for the 
            // nodes.
            var node = svg.selectAll(".node")
                .data(graph.nodes)
                .enter().append("circle")
                [...]
                .style("fill", function(d) {
                    return color(d.club); 
                 })
                .call(force.drag);
                [...]
            });
        });</pre></div><p>When we <a id="id924" class="indexterm"/>execute <a id="id925" class="indexterm"/>this cell, the HTML <a id="id926" class="indexterm"/>object created in the previous cell is updated. The graph is animated and interactive; we can click on nodes, see their labels, and move <a id="id927" class="indexterm"/>them <a id="id928" class="indexterm"/>within the canvas:</p><div class="mediaobject"><img src="images/4818OS_06_11.jpg" alt="How to do it…"/><div class="caption"><p>An interactive plot in the notebook with D3.js</p></div></div></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec222"/>There's more…</h2></div></div></div><p>D3.js' gallery contains many<a id="id929" class="indexterm"/> more examples of beautiful, interactive visualizations for the Web. They are available at <a class="ulink" href="http://github.com/mbostock/d3/wiki/Gallery">http://github.com/mbostock/d3/wiki/Gallery</a>.</p><p>In this recipe, we created an HTML/JavaScript interactive visualization from a static dataset. With IPython 2.0 and above, we can also create dynamic, real-time visualizations that involve bi-directional communication between the browser and the Python kernel. There is an experimental implementation by Brian Granger available at <a class="ulink" href="http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb">http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb</a>.</p><p>Let's also mention <a id="id930" class="indexterm"/><span class="strong"><strong>Vincent</strong></span>, a Python to Vega translator. Vega is a JSON-based visualization grammar that can be translated to D3.js. Vincent makes it possible to design an interactive visualization in Python and render it in the browser. More information can be <a id="id931" class="indexterm"/>found at <a class="ulink" href="http://vincent.readthedocs.org/en/latest/">http://vincent.readthedocs.org/en/latest/</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec223"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating interactive web visualizations with Bokeh</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Converting matplotlib figures to D3.js visualizations with mpld3</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting matplotlib figures to D3.js visualizations with mpld3"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Converting matplotlib figures to D3.js visualizations with mpld3</h1></div></div></div><p>The <span class="strong"><strong>mpld3</strong></span> library<a id="id932" class="indexterm"/> automatically converts matplotlib figures to interactive D3.js visualizations. In this recipe, we will see how to use this library in the notebook.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec224"/>Getting ready</h2></div></div></div><p>To install the<a id="id933" class="indexterm"/> mpld3 library, you can just type <code class="literal">pip install mpld3</code> in a terminal. See also the main website at <a class="ulink" href="http://mpld3.github.io">http://mpld3.github.io</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec225"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we load <a id="id934" class="indexterm"/>NumPy and <a id="id935" class="indexterm"/>matplotlib as <a id="id936" class="indexterm"/>usual:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">Then, we enable the mpld3 figures in the notebook with a single function call:<div class="informalexample"><pre class="programlisting">In [2]: from mpld3 import enable_notebook
        enable_notebook()</pre></div></li><li class="listitem">Now, let's create a scatter plot with matplotlib:<div class="informalexample"><pre class="programlisting">In [3]: X = np.random.normal(0, 1, (100, 3))
        color = np.random.random(100)
        size = 500 * np.random.random(100)
        plt.scatter(X[:,0], X[:,1], c=color,
                    s=size, alpha=0.5, linewidths=2)
        plt.grid(color='lightgray', alpha=0.7)</pre></div><p>The matplotlib figure is rendered with D3.js instead of the standard matplotlib backend. In particular, the figure is interactive (we can pan and zoom in the figure):</p><div class="mediaobject"><img src="images/4818OS_06_12.jpg" alt="How to do it…"/><div class="caption"><p>An interactive matplotlib figure with mpld3</p></div></div></li><li class="listitem">Now, we <a id="id937" class="indexterm"/>create<a id="id938" class="indexterm"/> a more<a id="id939" class="indexterm"/> complex example with multiple subplots that represent different 2D projections of a 3D dataset. We use the <code class="literal">sharex</code> and <code class="literal">sharey</code> keywords in matplotlib's <code class="literal">subplots()</code> function<a id="id940" class="indexterm"/> to automatically bind the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes of the different figures. Panning and zooming in any of the subplots automatically updates all the other subplots:<div class="informalexample"><pre class="programlisting">In [4]: fig, ax = plt.subplots(3, 3, figsize=(6, 6),
                               sharex=True, sharey=True)
        fig.subplots_adjust(hspace=0.3)
        X[::2,2] += 3
        for i in range(3):
            for j in range(3):
                ax[i,j].scatter(X[:,i], X[:,j], c=color,
                    s=.1*size, alpha=0.5, linewidths=2)
                ax[i,j].grid(color='lightgray', alpha=0.7)</pre></div><p>This use case is perfectly handled by mpld3; the D3.js subplots are dynamically linked together:</p><div class="mediaobject"><img src="images/4818OS_06_13.jpg" alt="How to do it…"/><div class="caption"><p>Interactive linked subplots in mpld3</p></div></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec226"/>How it works…</h2></div></div></div><p>mpld3 works by <a id="id941" class="indexterm"/>first crawling <a id="id942" class="indexterm"/>and exporting a matplotlib<a id="id943" class="indexterm"/> figure to JSON (in the context of the<a id="id944" class="indexterm"/> <span class="strong"><strong>mplexporter</strong></span> framework). Then, the library generates D3.js code from this JSON representation. This architecture can enable other matplotlib backends besides D3.js.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec227"/>There's more…</h2></div></div></div><p>Here are some references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">mplexporter<a id="id945" class="indexterm"/> available at <a class="ulink" href="http://github.com/mpld3/mplexporter">http://github.com/mpld3/mplexporter</a></li><li class="listitem" style="list-style-type: disc">mpld3 on GitHub<a id="id946" class="indexterm"/> available at <a class="ulink" href="https://github.com/jakevdp/mpld3">https://github.com/jakevdp/mpld3</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec228"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating interactive web visualizations with Bokeh</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Visualizing a NetworkX graph in the IPython notebook with D3.js</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Getting started with Vispy for high-performance interactive data visualizations"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Getting started with Vispy for high-performance interactive data visualizations</h1></div></div></div><p>Most existing plotting or visualization libraries in Python can display small or medium datasets (that contain no more than a few tens of thousands of points). In the <span class="emphasis"><em>Big Data</em></span> era, it is sometimes necessary to display larger datasets.</p><p>Vispy<a id="id947" class="indexterm"/> (<a class="ulink" href="http://vispy.org">http://vispy.org</a>) is a young 2D/3D high-performance visualization library that can display very large datasets. Vispy leverages the computational power of modern Graphics Processing Units (GPUs) through the OpenGL library.</p><p>The power of GPUs has been fostered by the video game industry in the last two decades. GPUs are specialized in high-performance, real-time rendering. As such, they are perfectly adapted to interactive scientific plotting.</p><p>Vispy offers a Pythonic object-oriented interface to OpenGL, useful to those who know OpenGL or who are willing to learn it. Higher-level graphical interfaces are also being developed at the time of this writing, and experimental versions are already available. These interfaces do not require any knowledge of OpenGL.</p><p>In this recipe, we will give a brief<a id="id948" class="indexterm"/> introduction to the fundamental concepts of OpenGL. There are two situations where you would need to know these concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you want to use Vispy today, before the availability of the high-level plotting interfaces</li><li class="listitem" style="list-style-type: disc">If you want to create custom, sophisticated, high-performance visualizations that are not yet implemented in Vispy</li></ul></div><p>Here, we display a digital signal using Vispy's object-oriented interface to OpenGL.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec229"/>Getting ready</h2></div></div></div><p>Vispy depends on NumPy. A backend library is necessary (for example, PyQt4 or PySide).</p><p>This recipe has been tested with the development version<a id="id949" class="indexterm"/> of Vispy available at <a class="ulink" href="http://github.com/vispy/vispy">http://github.com/vispy/vispy</a>. You should clone the GitHub repository and install Vispy with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python setup.py install</strong></span>
</pre></div><p>The API used in this recipe might change in future versions.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec230"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy, <code class="literal">vispy.app</code> (to display a canvas), and <code class="literal">vispy.gloo</code> (object-oriented interface to OpenGL):<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        from vispy import app
        from vispy import gloo</pre></div></li><li class="listitem">In order to display a window, we need to create a <a id="id950" class="indexterm"/><span class="strong"><strong>Canvas</strong></span>:<div class="informalexample"><pre class="programlisting">In [2]: c = app.Canvas(keys='interactive')</pre></div></li><li class="listitem">When using <code class="literal">vispy.gloo</code>, we <a id="id951" class="indexterm"/>need to write <a id="id952" class="indexterm"/><span class="strong"><strong>shaders</strong></span>. These programs, written in a C-like language, run on the GPU and give us full flexibility for our visualizations. Here, we create a trivial <span class="strong"><strong>vertex shader</strong></span><a id="id953" class="indexterm"/> that directly displays 2D data points (stored in the <code class="literal">a_position</code> variable) in the canvas. We will see more details in the next section:<div class="informalexample"><pre class="programlisting">In [3]: vertex = """
        attribute vec2 a_position;
        void main (void)
        {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
        """</pre></div></li><li class="listitem">The other shader we need to create is the <a id="id954" class="indexterm"/><span class="strong"><strong>fragment shader</strong></span>. It lets us control the pixels' color. Here, we display all data points in black:<div class="informalexample"><pre class="programlisting">In [4]: fragment = """
        void main()
        {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        }
        """</pre></div></li><li class="listitem">Next, we create<a id="id955" class="indexterm"/> an <span class="strong"><strong>OpenGL</strong></span> <code class="literal">Program</code>. This object contains shaders and links the shader variables to the NumPy data:<div class="informalexample"><pre class="programlisting">In [5]: program = gloo.Program(vertex, fragment)</pre></div></li><li class="listitem">We link the <code class="literal">a_position</code> variable to a <span class="emphasis"><em>(1000, 2)</em></span> NumPy array that contains the coordinates of 1000 data points. In the default coordinate system, the coordinates of the four canvas corners are <span class="emphasis"><em>(+/-1, +/-1)</em></span>:<div class="informalexample"><pre class="programlisting">In [6]: program['a_position'] = np.c_[
                np.linspace(-1.0, +1.0, 1000),
                np.random.uniform(-0.5, +0.5, 1000)]</pre></div></li><li class="listitem">We create a callback function when the window is being resized. Updating the <span class="strong"><strong>OpenGL viewport</strong></span><a id="id956" class="indexterm"/> lets us ensure that Vispy uses the entire canvas:<div class="informalexample"><pre class="programlisting">In [7]: @c.connect
        def on_resize(event):
            gloo.set_viewport(0, 0, *event.size)</pre></div></li><li class="listitem">We create a callback function when the canvas needs to be refreshed. This <code class="literal">on_draw()</code> function renders the entire scene. First, we clear the window in white (it is necessary to do this at every frame). Then, we draw a succession of line segments using our OpenGL program:<div class="informalexample"><pre class="programlisting">In [8]: @c.connect
        def on_draw(event):
            gloo.clear((1,1,1,1))
            program.draw('line_strip')</pre></div></li><li class="listitem">Finally, we show the <a id="id957" class="indexterm"/>canvas and run the application:<div class="informalexample"><pre class="programlisting">In [9]: c.show()
        app.run()</pre></div><p>The following figure shows a screenshot:</p><div class="mediaobject"><img src="images/4818OS_06_14.jpg" alt="How to do it…"/><div class="caption"><p>Basic visualization example with Vispy</p></div></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec231"/>How it works…</h2></div></div></div><p>OpenGL<a id="id958" class="indexterm"/> is<a id="id959" class="indexterm"/> an open standard for hardware-accelerated interactive visualization. It is widely used in video games, <a id="id960" class="indexterm"/>industry (<span class="strong"><strong>Computer-Aided Design</strong></span>, or <span class="strong"><strong>CAD</strong></span>), virtual reality, and scientific applications (medical imaging, computer graphics, and so on).</p><p>OpenGL is a mature technology created in the early 1990s. In the early 2000s, OpenGL 2.0 brought a major new feature: the possibility to customize fundamental steps of the <a id="id961" class="indexterm"/><span class="strong"><strong>rendering pipeline</strong></span>. This pipeline defines the way data is processed on the GPU for real-time rendering. Many OpenGL courses and tutorials cover the old, fixed pipeline. However, Vispy exclusively supports the modern, programmable pipeline.</p><p>Here, we will introduce the fundamental concepts of the programmable pipeline used in this recipe. OpenGL is considerably more complex than what we can cover here. However, Vispy provides a vastly simplified API for the most common features of OpenGL.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Vispy<a id="id962" class="indexterm"/> is based on <a id="id963" class="indexterm"/><span class="strong"><strong>OpenGL ES 2.0</strong></span>, a flavor of OpenGL that is supported on desktop computers, mobile devices, and modern web browsers (through<a id="id964" class="indexterm"/> <span class="strong"><strong>WebGL</strong></span>). Modern graphics cards can support additional features. These features will be available in future versions of Vispy.</p></div></div><p>There are four major elements in the rendering pipeline of a given OpenGL program:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data buffers</strong></span> store <a id="id965" class="indexterm"/>numerical data on the GPU. The main types of buffers are <a id="id966" class="indexterm"/><span class="strong"><strong>vertex buffers</strong></span>, <a id="id967" class="indexterm"/><span class="strong"><strong>index buffers</strong></span>, and <a id="id968" class="indexterm"/><span class="strong"><strong>textures</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Variables</strong></span> are available<a id="id969" class="indexterm"/> in the shaders. There are four major types of variables: <a id="id970" class="indexterm"/><span class="strong"><strong>attributes</strong></span>, <a id="id971" class="indexterm"/><span class="strong"><strong>uniforms</strong></span>, <a id="id972" class="indexterm"/><span class="strong"><strong>varyings</strong></span>, and <a id="id973" class="indexterm"/><span class="strong"><strong>texture samplers</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shaders</strong></span> are GPU <a id="id974" class="indexterm"/>programs written in a C-like language called <a id="id975" class="indexterm"/><span class="strong"><strong>OpenGL Shading Language</strong></span> (<span class="strong"><strong>GLSL</strong></span>). The two main types of shaders are <span class="strong"><strong>vertex shaders</strong></span><a id="id976" class="indexterm"/> and <a id="id977" class="indexterm"/><span class="strong"><strong>fragment shaders</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The primitive type</strong></span> defines the way <a id="id978" class="indexterm"/>data points <a id="id979" class="indexterm"/>are rendered. The main types are points, lines, and triangles.</li></ul></div><p>Here is how the rendering pipeline<a id="id980" class="indexterm"/> works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Data is sent to the GPU and stored in buffers.</li><li class="listitem">The vertex shader processes the data in parallel and generates a number of 4D points in a normalized coordinate system <span class="emphasis"><em>(+/-1, +/-1)</em></span>. The fourth dimension is a homogeneous coordinate (generally 1).</li><li class="listitem">Graphics primitives (points, lines, and triangles) are generated from the data points returned by the vertex shader (<span class="strong"><strong>primitive assembly</strong></span><a id="id981" class="indexterm"/> and <a id="id982" class="indexterm"/><span class="strong"><strong>rasterization</strong></span>).</li><li class="listitem">The fragment shader processes all primitive pixels in parallel and returns each pixel's color as RGBA components.</li></ol></div><p>In this recipe's example, there is only one GPU variable: the <code class="literal">a_position</code> attribute. An <span class="strong"><strong>attribute</strong></span><a id="id983" class="indexterm"/> is a variable that takes one value per data point. <span class="strong"><strong>Uniforms</strong></span><a id="id984" class="indexterm"/> are global variables (shared by all data points), whereas <span class="strong"><strong>varyings</strong></span><a id="id985" class="indexterm"/> are used to pass values from the vertex shader to the fragment shader (with automatic linear interpolation for a pixel between two or three vertices).</p><p>In <code class="literal">vispy.gloo</code>, a <code class="literal">Program</code> is created with the vertex and fragment shaders. Then, the variables declared in the <a id="id986" class="indexterm"/>shaders can be set with the <code class="literal">program['varname'] = value</code> syntax. When <code class="literal">varname</code> is an attribute variable, the value can just be a NumPy 2D array. In this array, every line contains the components of every data point.</p><p>Similarly, we can declare uniforms and textures in our program.</p><p>Finally, the <code class="literal">program.draw()</code> function renders the data using the specified primitive type. Here, the <code class="literal">line_strip</code> primitive type tells the GPU to run through all vertices (as returned by the vertex buffer) and to draw a line segment from one point to the next. If there are <span class="emphasis"><em>n</em></span> points, there will be <span class="emphasis"><em>n-1</em></span> line segments.</p><p>Other primitive types include points and triangles, with several ways of generating lines or triangles from a list of vertices.</p><p>In addition, an index buffer can be provided. An index buffer contains indices pointing to the vertex buffers. Using an index buffer would allow us to reuse any vertex multiple times during the primitive assembly stage. For example, when rendering a cube with a <code class="literal">triangles</code> primitive type (one triangle is generated for every triplet of points), we can use a vertex buffer with eight data points and an index buffer with thirty-six indices (three points per triangle, two triangles per face, and six faces).</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec232"/>There's more…</h2></div></div></div><p>The example shown <a id="id987" class="indexterm"/>here is extremely simple. The approach provided by OpenGL and Vispy is nevertheless particularly powerful. It gives us full control on the rendering pipeline, and it allows us to leverage the computational power of GPUs in a nearly optimal way.</p><p>High performance is achieved by minimizing the number of data transfers to the GPU. When displaying static data (for example, a scatter plot), it is possible to send the data to the GPU at initialization time only. Yet, rendering dynamic data is reasonably fast; the order of magnitude of data transfers is roughly 1 GBps.</p><p>Additionally, it is critical to use as few OpenGL draw calls as possible. Every draw incurs a significant overhead. High performance is achieved by rendering all similar primitive types at<a id="id988" class="indexterm"/> once (<span class="strong"><strong>batch rendering</strong></span>). GPUs are particularly efficient with batch rendering, even when the properties of the points are different (for example, points with various sizes and colors).</p><p>Finally, geometric or pixel transformations can be executed on the GPU with very high performance using the shaders. The massive architecture of GPUs, consisting of hundreds or thousands of computing units, is fully leveraged when transformations are implemented in the shaders.</p><p>General-purpose computations can be done in the shaders in the context of visualization. There is one major drawback compared to proper GPGPU frameworks like CUDA or OpenCL: in the vertex shader, a given thread has access to one data point only. Similarly, in the fragment shader, a thread has only access to one pixel. Yet, certain types of simulations or visualization effects require interactions between vertices or pixels. There are ways to mitigate this issue, but they lead to a drop in performance.</p><p>However, it is possible to interoperate OpenGL with CUDA/OpenCL. Buffers can be shared between OpenGL and the GPGPU framework. Complex CUDA/OpenCL computations can be implemented on vertex buffers or textures in real-time, leading to highly efficient rendering of numerical simulations.</p><div class="section" title="Vispy for scientific visualization"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec39"/>Vispy for scientific visualization</h3></div></div></div><p>As we have seen <a id="id989" class="indexterm"/>in this recipe, Vispy requires the user to know OpenGL and <a id="id990" class="indexterm"/>GLSL. However, higher-level graphical interfaces are currently being developed. These interfaces will bring to scientists the power of GPUs for high-performance interactive visualization.</p><p>
<span class="strong"><strong>Visuals</strong></span><a id="id991" class="indexterm"/> will provide reusable, reactive graphical components like shapes, polygons, 3D meshes, graphs, and others. These visuals will be fully customizable and can be used without knowledge of OpenGL. A <span class="strong"><strong>shader composition system</strong></span><a id="id992" class="indexterm"/> will allow advanced users to reuse snippets of GLSL code in a modular way.</p><p>Visuals will be organized within a <span class="strong"><strong>scene graph</strong></span><a id="id993" class="indexterm"/> implementing GPU-based<a id="id994" class="indexterm"/> <span class="strong"><strong>transformations</strong></span>.</p><p>Scientific plotting interfaces will be implemented. Vispy can also serve as a high-performance backend for existing plotting libraries such as matplotlib.</p><p>Vispy will also support<a id="id995" class="indexterm"/> full integration in the IPython notebook using <a id="id996" class="indexterm"/>WebGL.</p><p>Eventually, Vispy will be able to implement many kinds of scientific visualizations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scatter plots can be rendered efficiently with <a id="id997" class="indexterm"/><span class="strong"><strong>point sprites</strong></span>, using one vertex per data point. Panning and zooming can be implemented in the vertex shader, enabling fast interactive visualization of millions of points.</li><li class="listitem" style="list-style-type: disc">Static or dynamic (real-time) digital signals can be displayed with polylines. High-quality rendering of curves can be achieved using an OpenGL implementation of <a id="id998" class="indexterm"/><span class="strong"><strong>Anti-Grain Geometry</strong></span>, a high-quality 2D rendering library.</li><li class="listitem" style="list-style-type: disc">Graphs can be displayed by combining points and line segments.</li><li class="listitem" style="list-style-type: disc">3D meshes can be displayed with triangles and index buffers. Geometric transformations and realistic lighting can be implemented in the vertex and fragment shaders.</li><li class="listitem" style="list-style-type: disc">Real-time streams of images can be displayed efficiently with textures.</li><li class="listitem" style="list-style-type: disc">Axes, grids, ticks, text, and labels can be rendered efficiently in the fragment shader.</li></ul></div><p>Many examples can be found in Vispy's gallery.</p><p>Here are a few <a id="id999" class="indexterm"/>references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vispy's gallery available at <a class="ulink" href="http://vispy.org/gallery.html">http://vispy.org/gallery.html</a></li><li class="listitem" style="list-style-type: disc">A modern OpenGL tutorial, by Nicolas P. Rougier, available at <a class="ulink" href="http://www.loria.fr/~rougier/teaching/opengl/">http://www.loria.fr/~rougier/teaching/opengl/</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Hardware-accelerated interactive data visualization for neuroscience in Python</em></span>, an article available at <a class="ulink" href="http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full">http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full</a></li><li class="listitem" style="list-style-type: disc">The Vispy users mailing list available at <a class="ulink" href="http://groups.google.com/forum/#!forum/vispy">http://groups.google.com/forum/#!forum/vispy</a></li><li class="listitem" style="list-style-type: disc">The Vispy-dev mailing list available at <a class="ulink" href="http://groups.google.com/forum/#!forum/vispy-dev">http://groups.google.com/forum/#!forum/vispy-dev</a></li><li class="listitem" style="list-style-type: disc">The <a id="id1000" class="indexterm"/>Anti-Grain Geometry library<a id="id1001" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Anti-Grain_Geometry">http://en.wikipedia.org/wiki/Anti-Grain_Geometry</a></li></ul></div></div></div></div></div>
</body></html>