<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 12. Deterministic Dynamical Systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Deterministic Dynamical Systems</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Plotting the bifurcation diagram of a chaotic dynamical system</li><li class="listitem" style="list-style-type: disc">Simulating an elementary cellular automaton</li><li class="listitem" style="list-style-type: disc">Simulating an ordinary differential equation with SciPy</li><li class="listitem" style="list-style-type: disc">Simulating a partial differential equation – reaction-diffusion systems and Turing patterns</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec100"/>Introduction</h1></div></div></div><p>The previous chapters dealt with classical approaches in data science: statistics, machine learning, and signal processing. In this chapter and the next chapter, we will cover a different type of approach. Instead of analyzing data directly, we will simulate mathematical models that represent how our data was generated. A representative model gives us an explanation of the real-world processes underlying our data.</p><p>Specifically, we will cover a few examples of dynamical systems. These mathematical equations describe the evolution of quantities over time and space. They can represent a wide variety of real-world phenomena in physics, chemistry, biology, economics, social sciences, computer science, engineering, and other disciplines.</p><p>In this chapter, we will consider deterministic dynamical systems. This term is used in contrast to stochastic systems, which incorporate randomness in their rules. We will cover stochastic systems in the next chapter.</p><div class="section" title="Types of dynamical systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec381"/>Types of dynamical systems</h2></div></div></div><p>The types of deterministic dynamical systems<a id="id1761" class="indexterm"/> we will consider here are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Discrete-time dynamical systems</strong></span> (iterated functions)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cellular automata</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ordinary Differential Equations</strong></span> (<span class="strong"><strong>ODEs</strong></span>)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Partial Differential Equations</strong></span> (<span class="strong"><strong>PDEs</strong></span>)</li></ul></div><p>In these models, the<a id="id1762" class="indexterm"/> quantities of interest depend on one or several<a id="id1763" class="indexterm"/> <span class="strong"><strong>independent variables</strong></span>. Often, these variables include time and/or space. The independent variables can be discrete or continuous, resulting in different types of models and different analysis and simulation techniques.</p><p>A <span class="strong"><strong>discrete-time dynamical system</strong></span><a id="id1764" class="indexterm"/> is described by the iterative application of a function on an initial point: <span class="emphasis"><em>f(x)</em></span>, <span class="emphasis"><em>f(f(x))</em></span>, <span class="emphasis"><em>f(f(f(x)))</em></span>, and so on. This type of system can lead to complex and <span class="strong"><strong>chaotic</strong></span> behaviors.</p><p>A <span class="strong"><strong>cellular automaton</strong></span><a id="id1765" class="indexterm"/> is represented by a discrete grid of cells that<a id="id1766" class="indexterm"/> can be in a finite number of states. Rules describe how the state of a cell evolves according to the states of the neighboring cells. These simple models can lead to highly sophisticated behaviors.</p><p>An <span class="strong"><strong>ODE</strong></span><a id="id1767" class="indexterm"/> describes <a id="id1768" class="indexterm"/>the dependence of a continuous function on its derivative with respect to the independent variable. In differential equations, the unknown variable is a <span class="emphasis"><em>function</em></span> instead of a <span class="emphasis"><em>number</em></span>. ODEs notably arise when the rate of change of a quantity depends on the current value of this quantity. For example, in classical mechanics, the laws of motion (including movement of planets and satellites) can be described by ODEs.</p><p>
<span class="strong"><strong>PDEs</strong></span><a id="id1769" class="indexterm"/> are similar to <a id="id1770" class="indexterm"/>ODEs, but they involve several independent variables (for example, time and space). These equations contain <span class="strong"><strong>partial derivatives</strong></span><a id="id1771" class="indexterm"/> of the function with respect to the different independent variables. For example, PDEs describe the propagation of waves (acoustic, electromagnetic, or mechanical waves) and <a id="id1772" class="indexterm"/>fluids (<span class="strong"><strong>fluid dynamics</strong></span>). They are also important in quantum mechanics.</p></div><div class="section" title="Differential equations"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec382"/>Differential equations</h2></div></div></div><p>ODEs and PDEs can be one-dimensional or<a id="id1773" class="indexterm"/> multidimensional, depending on the dimensionality of the target space. Systems of multiple differential equations can be seen as multidimensional equations.</p><p>The <span class="strong"><strong>order</strong></span><a id="id1774" class="indexterm"/> of an ODE or a PDE refers to the maximal derivative order in the equation. For example, a first-order equation only involves simple derivatives, a second-order equation also involves second-order derivatives (the derivatives of the derivatives), and so on.</p><p>Ordinary or partial differential equations come with additional rules: <span class="strong"><strong>initial </strong></span><a id="id1775" class="indexterm"/><span class="strong"><strong>and</strong></span><a id="id1776" class="indexterm"/><span class="strong"><strong> boundary conditions</strong></span>. These formulas describe the behavior of the sought functions on the spatial and temporal domain boundaries. For example, in classical mechanics, boundary conditions include the initial position and initial speed of a physical body subject to forces.</p><p>Dynamical systems are often classified between <span class="strong"><strong>linear</strong></span><a id="id1777" class="indexterm"/> and <a id="id1778" class="indexterm"/><span class="strong"><strong>nonlinear</strong></span> systems, depending on whether the rules are linear or not (with respect to the unknown function). Nonlinear equations are typically much harder to study mathematically and numerically than linear equations. They can lead to extremely complex behaviors.</p><p>For example, the <a id="id1779" class="indexterm"/><span class="strong"><strong>Navier–Stokes equations</strong></span>, a set of nonlinear PDEs that describe the motion of fluid substances, can lead to <a id="id1780" class="indexterm"/><span class="strong"><strong>turbulence</strong></span>, a highly chaotic behavior seen in many fluid flows. Despite their high importance in meteorology, medicine, and engineering, fundamental properties of the Navier-Stokes equations remain unknown at this time. For example, the existence and smoothness problem in three dimensions is one of the seven Clay Mathematics Institute's Millennium Prize Problems. One million dollars is offered to anyone who comes up with a solution.</p></div><div class="section" title="References"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec383"/>References</h2></div></div></div><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overview of dynamical systems<a id="id1781" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Dynamical_system">http://en.wikipedia.org/wiki/Dynamical_system</a></li><li class="listitem" style="list-style-type: disc">Mathematical definition of dynamical systems available at <a class="ulink" href="http://en.wikipedia.org/wiki/Dynamical_system_%28definition%29">http://en.wikipedia.org/wiki/Dynamical_system_%28definition%29</a></li><li class="listitem" style="list-style-type: disc">List of dynamical systems topics available at <a class="ulink" href="http://en.wikipedia.org/wiki/List_of_dynamical_systems_and_differential_equations_topics">http://en.wikipedia.org/wiki/List_of_dynamical_systems_and_differential_equations_topics</a></li><li class="listitem" style="list-style-type: disc">Navier-Stokes equations<a id="id1782" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">http://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations</a></li><li class="listitem" style="list-style-type: disc">A course on Computational Fluid Dynamics<a id="id1783" class="indexterm"/> by Prof. Lorena Barba, written in the IPython notebook, available at <a class="ulink" href="https://github.com/barbagroup/CFDPython">https://github.com/barbagroup/CFDPython</a></li></ul></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Plotting the bifurcation diagram of a chaotic dynamical system"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec101"/>Plotting the bifurcation diagram of a chaotic dynamical system</h1></div></div></div><p>A <span class="strong"><strong>chaotic</strong></span> dynamical system<a id="id1784" class="indexterm"/> is highly sensitive to initial conditions; small perturbations at any given time yield completely different trajectories. The trajectories of a chaotic system tend to have complex and unpredictable behaviors.</p><p>Many real-world<a id="id1785" class="indexterm"/> phenomena are<a id="id1786" class="indexterm"/> chaotic, particularly those that involve nonlinear interactions among many agents (complex systems). Famous examples can be found in meteorology, economics, biology, and other disciplines.</p><p>In this recipe, we will simulate a famous chaotic system: the <a id="id1787" class="indexterm"/><span class="strong"><strong>logistic map</strong></span>. This is an archetypal example of how chaos can arise from a very simple nonlinear equation. The logistic map models the evolution of a population, taking into account both reproduction and density-dependent mortality (starvation).</p><p>We will draw the system's <a id="id1788" class="indexterm"/><span class="strong"><strong>bifurcation diagram</strong></span>, which shows the possible long-term behaviors (equilibria, fixed points, periodic orbits, and chaotic trajectories) as a function of the system's parameter. We will also compute an approximation of the system's<a id="id1789" class="indexterm"/> <span class="strong"><strong>Lyapunov exponent</strong></span>, characterizing the model's sensitivity to initial conditions.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec384"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy and matplotlib:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We define the logistic function by:<div class="mediaobject"><img src="images/4818OS_12_01.jpg" alt="How to do it..."/></div><p>Our discrete dynamical system is defined by the recursive application of the logistic function:</p><div class="mediaobject"><img src="images/4818OS_12_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Here is the implementation of this function in Python:<div class="informalexample"><pre class="programlisting">In [2]: def logistic(r, x):
            return r*x*(1-x)</pre></div></li><li class="listitem">We simulate this system for 10000 values of <span class="emphasis"><em>r</em></span> linearly spaced between <code class="literal">2.5</code> and <code class="literal">4</code>, and vectorize the simulation with NumPy by considering a vector of independent systems (one dynamical system per parameter value):<div class="informalexample"><pre class="programlisting">In [3]: n = 10000
        r = np.linspace(2.5, 4.0, n)</pre></div></li><li class="listitem">Let's simulate 1000 iterations of the logistic map and keep the last 100 iterations to display the bifurcation diagram:<div class="informalexample"><pre class="programlisting">In [4]: iterations = 1000
        last = 100</pre></div></li><li class="listitem">We initialize our system with the same initial condition <span class="emphasis"><em>x<sub>0</sub> = 0.00001</em></span>:<div class="informalexample"><pre class="programlisting">In [5]: x = 1e-5 * np.ones(n)</pre></div></li><li class="listitem">We also compute an approximation of the Lyapunov exponent for every value of <span class="emphasis"><em>r</em></span>. The Lyapunov exponent<a id="id1790" class="indexterm"/> is defined by:<div class="mediaobject"><img src="images/4818OS_12_03.jpg" alt="How to do it..."/></div></li><li class="listitem">We first<a id="id1791" class="indexterm"/> initialize the <code class="literal">lyapunov</code> vector:<div class="informalexample"><pre class="programlisting">In [6]: lyapunov = np.zeros(n)</pre></div></li><li class="listitem">Now, we<a id="id1792" class="indexterm"/> simulate the system and plot the bifurcation diagram. The simulation only involves the iterative evaluation of the <code class="literal">logistic()</code> function on our vector <code class="literal">x</code>. Then, to display the bifurcation diagram, we draw one pixel per point <span class="emphasis"><em>x<sub>n</sub><sup>(r)</sup></em></span> during the last 100 iterations:<div class="informalexample"><pre class="programlisting">In [7]: plt.subplot(211)
        for i in range(iterations):
            x = logistic(r, x)
            # We compute the partial sum of the
            # Lyapunov exponent.
            lyapunov += np.log(abs(r-2*r*x))
            # We display the bifurcation diagram.
            if i &gt;= (iterations - last):
                plt.plot(r, x, ',k', alpha=.02)
        plt.xlim(2.5, 4)
        plt.title("Bifurcation diagram")
        
        # We display the Lyapunov exponent.
        plt.subplot(212)
        plt.plot(r[lyapunov&lt;0],
                 lyapunov[lyapunov&lt;0] / iterations,
                 ',k', alpha=0.1)
        plt.plot(r[lyapunov&gt;=0],
                 lyapunov[lyapunov&gt;=0] / iterations,
                 ',r', alpha=0.25)
        plt.xlim(2.5, 4)
        plt.ylim(-2, 1)
        plt.title("Lyapunov exponent")</pre></div><div class="mediaobject"><img src="images/4818OS_12_04.jpg" alt="How to do it..."/><div class="caption"><p>The bifurcation diagram and Lyapunov exponent of the logistic map</p></div></div><p>The <a id="id1793" class="indexterm"/>bifurcation <a id="id1794" class="indexterm"/>diagram brings out the existence of a fixed point for <span class="emphasis"><em>r&lt;3</em></span>, then two and four equilibria, and a chaotic behavior when r belongs to certain areas of the parameter space.</p><p>We observe an important property of the Lyapunov exponent: it is positive when the system is chaotic (in red here).</p></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec385"/>There's more...</h2></div></div></div><p>Here are some references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Chaos theory<a id="id1795" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Chaos_theory">http://en.wikipedia.org/wiki/Chaos_theory</a></li><li class="listitem" style="list-style-type: disc">Complex systems<a id="id1796" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Complex_system">http://en.wikipedia.org/wiki/Complex_system</a></li><li class="listitem" style="list-style-type: disc">The logistic map<a id="id1797" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="https://en.wikipedia.org/wiki/Logistic_map">https://en.wikipedia.org/wiki/Logistic_map</a></li><li class="listitem" style="list-style-type: disc">Iterated functions (discrete dynamical systems) on<a id="id1798" class="indexterm"/> Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Iterated_function">http://en.wikipedia.org/wiki/Iterated_function</a></li><li class="listitem" style="list-style-type: disc">Bifurcation diagrams on <a id="id1799" class="indexterm"/>Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Bifurcation_diagram">http://en.wikipedia.org/wiki/Bifurcation_diagram</a></li><li class="listitem" style="list-style-type: disc">Lyapunov exponent<a id="id1800" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Lyapunov_exponent">http://en.wikipedia.org/wiki/Lyapunov_exponent</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec386"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Simulating an ordinary differential equation with SciPy</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Simulating an elementary cellular automaton"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec102"/>Simulating an elementary cellular automaton</h1></div></div></div><p>Cellular automata are discrete dynamical systems evolving on a grid of cells. These cells can be in a finite number of states (for example, on/off). The evolution of a cellular automaton is governed by a set of rules, describing how the state of a cell changes according to the state of its neighbors.</p><p>Although extremely simple, these models can initiate highly complex and chaotic behaviors. Cellular automata can model real-world phenomena such as car traffic, chemical reactions, propagation of fire in a forest, epidemic propagations, and much more. Cellular automata are also found in nature. For example, the patterns of some seashells are generated by natural cellular automata.</p><p>An <span class="strong"><strong>elementary cellular automaton</strong></span><a id="id1801" class="indexterm"/> is a binary, one-dimensional automaton, where the rules concern the immediate left and right neighbors of every cell.</p><p>In this recipe, we will simulate elementary cellular automata with NumPy using their Wolfram code.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec387"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We import <a id="id1802" class="indexterm"/>NumPy and matplotlib:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We will use the following vector to obtain numbers written in binary representation:<div class="informalexample"><pre class="programlisting">In [2]: u = np.array([[4], [2], [1]])</pre></div></li><li class="listitem">Let's write a function that performs an iteration on the grid, updating all cells at once according to the given rule in binary representation (we will give all explanations in the <span class="emphasis"><em>How it works...</em></span> section). The first step consists of stacking circularly-shifted versions of the grid to get the LCR (left, center, right) triplets of each cell (<code class="literal">y</code>). Then, we convert these triplets into 3-bit numbers (<code class="literal">z</code>). Finally, we compute the next state of every cell using the specified rule:<div class="informalexample"><pre class="programlisting">In [3]: def step(x, rule_binary):
            """Compute a single stet of an elementary
            cellular automaton."""
            # The columns contain the L, C, R values
            # of all cells.
            y = np.vstack((np.roll(x, 1), x,
                           np.roll(x, -1))).astype(np.int8)
            # We get the LCR pattern numbers 
            # between 0 and 7.
            z = np.sum(y * u, axis=0).astype(np.int8)
            # We get the patterns given by the rule.
            return rule_binary[7-z]</pre></div></li><li class="listitem">We now write a function that simulates any elementary cellular automaton. First, we compute the binary representation of the <a id="id1803" class="indexterm"/>rule (<span class="strong"><strong>Wolfram Code</strong></span>). Then, we initialize the first row of the grid with random values. Finally, we apply the function <code class="literal">step()</code> iteratively on the grid:<div class="informalexample"><pre class="programlisting">In [4]: def generate(rule, size=80, steps=80):
            """Simulate an elementary cellular automaton
            given its rule (number between 0 and 255)."""
            # Compute the binary representation of the
            # rule.
            rule_binary = np.array(
                [int(x) for x in np.binary_repr(rule, 8)],
                dtype=np.int8)
            x = np.zeros((steps, size), dtype=np.int8)
            # Random initial state.
            x[0,:] = np.random.rand(size) &lt; .5
            # Apply the step function iteratively.
            for i in range(steps-1):
                x[i+1,:] = step(x[i,:], rule_binary)
            return x</pre></div></li><li class="listitem">Now, we<a id="id1804" class="indexterm"/> simulate and display nine different automata:<div class="informalexample"><pre class="programlisting">In [5]: rules = [  3,  18,  30, 
                  90, 106, 110, 
                 158, 154, 184]
        for i, rule in enumerate(rules):
            x = generate(rule)
            plt.subplot(331+i)
            plt.imshow(x, interpolation='none',
                       cmap=plt.cm.binary)
            plt.xticks([]); plt.yticks([])
            plt.title(str(rule))</pre></div><div class="mediaobject"><img src="images/4818OS_12_05.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec388"/>How it works...</h2></div></div></div><p>Let's consider an elementary cellular automaton in one dimension. Every cell <span class="emphasis"><em>C</em></span> has two neighbors (<span class="emphasis"><em>L</em></span> and <span class="emphasis"><em>R</em></span>), and it can be either off (0) or on (1). Therefore, the future state of a cell depends on the current state of <span class="emphasis"><em>L</em></span>, <span class="emphasis"><em>C</em></span>, and <span class="emphasis"><em>R</em></span>. This triplet can be encoded as a number between 0 and 7 (three digits in binary representation).</p><p>A particular elementary cellular automaton is entirely determined by the outcome of each of these eight configurations. Therefore, there are 256 different elementary cellular automata (<span class="emphasis"><em>2<sup>8</sup></em></span>). Each of these automata is identified by a number between 0 and 255.</p><p>We consider all eight LCR states in order: 111, 110, 101, ..., 001, 000. Each of the eight digits in the binary representation of the automaton's number corresponds to a LCR state (using the same order). For<a id="id1805" class="indexterm"/> example, in the <span class="strong"><strong>Rule 110 automaton</strong></span><a id="id1806" class="indexterm"/> (<code class="literal">01101110</code> in binary representation), the state 111 yields a new state of 0 for the center cell, 110 yields 1, 101 yields 1, and so on. It has been shown that this particular automaton is <a id="id1807" class="indexterm"/><span class="strong"><strong>Turing complete</strong></span> (or <span class="strong"><strong>universal</strong></span>); it can theoretically simulate any computer program.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec389"/>There's more...</h2></div></div></div><p>Other types of cellular automata include <a id="id1808" class="indexterm"/><span class="strong"><strong>Conway's Game of Life</strong></span>, in two dimensions. This famous system yields various dynamic patterns. It is also Turing complete.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cellular automata<a id="id1809" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Cellular_automaton">http://en.wikipedia.org/wiki/Cellular_automaton</a></li><li class="listitem" style="list-style-type: disc">Elementary cellular automata<a id="id1810" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Elementary_cellular_automaton">http://en.wikipedia.org/wiki/Elementary_cellular_automaton</a></li><li class="listitem" style="list-style-type: disc">Rule 110, described <a id="id1811" class="indexterm"/>at <a class="ulink" href="http://en.wikipedia.org/wiki/Rule_110">http://en.wikipedia.org/wiki/Rule_110</a></li><li class="listitem" style="list-style-type: disc">The<a id="id1812" class="indexterm"/> Wolfram code, explained at <a class="ulink" href="http://en.wikipedia.org/wiki/Wolfram_code">http://en.wikipedia.org/wiki/Wolfram_code</a>, assigns a 1D elementary cellular automaton to any number between 0 and 255</li><li class="listitem" style="list-style-type: disc">Conway's Game of <a id="id1813" class="indexterm"/>Life on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Simulating an ordinary differential equation with SciPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec103"/>Simulating an ordinary differential equation with SciPy</h1></div></div></div><p>
<span class="strong"><strong>Ordinary Differential Equations</strong></span> (<span class="strong"><strong>ODEs</strong></span>)<a id="id1814" class="indexterm"/> describe the evolution of a system subject to internal and external dynamics. Specifically, an ODE links a quantity depending on a single independent variable (time, for example) to its derivatives. In addition, the system can be under the influence of external factors. A first-order ODE can typically be written as:</p><div class="mediaobject"><img src="images/4818OS_12_06.jpg" alt="Simulating an ordinary differential equation with SciPy"/></div><p>More generally, an <span class="emphasis"><em>n</em></span>-th <a id="id1815" class="indexterm"/>order ODE involves <a id="id1816" class="indexterm"/>successive derivatives of <span class="emphasis"><em>y</em></span> until the order <span class="emphasis"><em>n</em></span>. The ODE is said to be linear or nonlinear depending on whether <span class="emphasis"><em>f</em></span> is linear in <span class="emphasis"><em>y</em></span> or not.</p><p>ODEs naturally appear when the rate of change of a quantity depends on its value. Therefore, ODEs are found in many scientific disciplines such as mechanics (evolution of a body subject to dynamic forces), chemistry (concentration of reacting products), biology (spread of an epidemic), ecology (growth of a population), economics, and finance, among others.</p><p>Whereas simple ODEs can be solved analytically, many ODEs require a numerical treatment. In this recipe, we will simulate a simple linear second-order autonomous ODE, describing the evolution of a particle in the air subject to gravity and viscous resistance. Although this equation could be solved analytically, here we will use SciPy to simulate it numerically.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec390"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy, SciPy (the <code class="literal">integrate</code> package), and matplotlib:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import scipy.integrate as spi
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We define a few parameters appearing in our model:<div class="informalexample"><pre class="programlisting">In [2]: m = 1.  # particle's mass
        k = 1.  # drag coefficient
        g = 9.81  # gravity acceleration</pre></div></li><li class="listitem">We have two variables: <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> (two dimensions). We note <span class="emphasis"><em>u=(x,y)</em></span>. The ODE that we are going to simulate is:<div class="mediaobject"><img src="images/4818OS_12_07.jpg" alt="How to do it..."/></div><p>Here, <span class="emphasis"><em>g</em></span> is the gravity acceleration vector.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>Time derivatives are denoted with <span class="emphasis"><em>dots</em></span> above variables (one dot means <span class="emphasis"><em>first derivative</em></span> and two dots means <span class="emphasis"><em>second derivative</em></span>).</p></div></div><p>In order <a id="id1817" class="indexterm"/>to simulate <a id="id1818" class="indexterm"/>this second-order ODE with SciPy, we can convert it to a first-order ODE (another option would be to solve <span class="emphasis"><em>u</em></span>' first before integrating the solution). To do this, we consider two 2D variables: <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>u'</em></span>. We note <span class="emphasis"><em>v = (u, u')</em></span>. We can express <span class="emphasis"><em>v'</em></span> as a function of <span class="emphasis"><em>v</em></span>. Now, we create the initial vector <span class="emphasis"><em>v<sub>0</sub></em></span> at time <span class="emphasis"><em>t=0</em></span>: it has four components.</p><div class="informalexample"><pre class="programlisting">In [3]: # The initial position is (0, 0).
        v0 = np.zeros(4)
        # The initial speed vector is oriented
        # to the top right.
        v0[2] = 4.
        v0[3] = 10.</pre></div></li><li class="listitem">Let's create a Python function <span class="emphasis"><em>f</em></span> that takes the current vector <span class="emphasis"><em>v(t<sub>0</sub>)</em></span> and a time <span class="emphasis"><em>t<sub>0</sub></em></span> as arguments (with optional parameters) and that returns the derivative <span class="emphasis"><em>v'(t<sub>0</sub>)</em></span>:<div class="informalexample"><pre class="programlisting">In [4]: def f(v, t0, k):
            # v has four components: v=[u, u'].
            u, udot = v[:2], v[2:]
            # We compute the second derivative u'' of u.
            udotdot = -k/m * udot
            udotdot[1] -= g
            # We return v'=[u', u''].
            return np.r_[udot, udotdot]</pre></div></li><li class="listitem">Now, we simulate the system for different values of <span class="emphasis"><em>k</em></span>. We use the SciPy <code class="literal">odeint()</code> function, defined in the <code class="literal">scipy.integrate</code> package.<div class="informalexample"><pre class="programlisting">In [5]: # We want to evaluate the system on 30 linearly
        # spaced times between t=0 and t=3.
        t = np.linspace(0., 3., 30)
        # We simulate the system for different values of k.
        for k in np.linspace(0., 1., 5):
            # We simulate the system and evaluate $v$ on
            # the given times.
            v = spi.odeint(f, v0, t, args=(k,))
            # We plot the particle's trajectory.
            plt.plot(v[:,0], v[:,1], 'o-',
                     mew=1, ms=8, mec='w',
                     label='k={0:.1f}'.format(k))
        plt.legend()
        plt.xlim(0, 12)
        plt.ylim(0, 6)</pre></div><div class="mediaobject"><img src="images/4818OS_12_08.jpg" alt="How to do it..."/></div><p>In the preceding figure, the most outward trajectory (blue) corresponds to drag-free motion (without air resistance). It is a parabola. In the other trajectories, we can observe the increasing effect of air resistance, parameterized with <code class="literal">k</code>.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec391"/>How it works...</h2></div></div></div><p>Let's explain <a id="id1819" class="indexterm"/>how we obtained the<a id="id1820" class="indexterm"/> differential equation from our model. Let <span class="emphasis"><em>u = (x,y)</em></span> encode the 2D position of our particle with mass <span class="emphasis"><em>m</em></span>. This particle is subject to two forces: gravity <span class="emphasis"><em>g = (0, -9.81)</em></span> (in <span class="emphasis"><em>m/s</em></span>) and air drag <span class="emphasis"><em>F = -ku'</em></span>. This last term depends on the particle's speed and is only valid at low speed. With higher speeds, we need to use more complex nonlinear expressions.</p><p>Now, we use <span class="strong"><strong>Newton's second law of motion</strong></span> <a id="id1821" class="indexterm"/>in classical mechanics. This law states that in an inertial reference frame, the mass multiplied by the acceleration of the particle is equal to the sum of all forces applied to that particle. Here, we obtain:</p><div class="mediaobject"><img src="images/4818OS_12_09.jpg" alt="How it works..."/></div><p>We immediately obtain our second-order ODE:</p><div class="mediaobject"><img src="images/4818OS_12_10.jpg" alt="How it works..."/></div><p>We transform it into a single-order system of ODEs with <span class="emphasis"><em>v=(u, u')</em></span>:</p><div class="mediaobject"><img src="images/4818OS_12_11.jpg" alt="How it works..."/></div><p>The last term can be expressed as a function of <span class="emphasis"><em>v</em></span> only.</p><p>The SciPy <code class="literal">odeint()</code>function <a id="id1822" class="indexterm"/>is a black-box solver; we simply specify the function that describes the system, and SciPy solves it automatically.</p><p>This <a id="id1823" class="indexterm"/>function leverages the FORTRAN library <a id="id1824" class="indexterm"/><span class="strong"><strong>ODEPACK</strong></span>, which contains well-tested code that has been used for decades by many scientists and engineers.</p><p>An example of a <a id="id1825" class="indexterm"/>simple numerical solver is the <a id="id1826" class="indexterm"/><span class="strong"><strong>Euler method</strong></span>. To numerically solve the autonomous ODE <span class="emphasis"><em>y'=f(y)</em></span>, the method consists of discretizing time with a time step <span class="emphasis"><em>dt</em></span> and replacing <span class="emphasis"><em>y'</em></span> with a first-order approximation:</p><div class="mediaobject"><img src="images/4818OS_12_12.jpg" alt="How it works..."/></div><p>Then, starting from an initial condition <span class="emphasis"><em>y<sub>0</sub> = y(t<sub>0</sub>)</em></span>, the method evaluates <span class="emphasis"><em>y</em></span> successively with the following recurrence relation:</p><div class="mediaobject"><img src="images/4818OS_12_13.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec392"/>There's more...</h2></div></div></div><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The documentation of the <code class="literal">integrate</code> package in SciPy<a id="id1827" class="indexterm"/> available at <a class="ulink" href="http://docs.scipy.org/doc/scipy/reference/integrate.html">http://docs.scipy.org/doc/scipy/reference/integrate.html</a></li><li class="listitem" style="list-style-type: disc">ODEs<a id="id1828" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Ordinary_differential_equation">http://en.wikipedia.org/wiki/Ordinary_differential_equation</a></li><li class="listitem" style="list-style-type: disc">Newton's laws of motion<a id="id1829" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Newton's_laws_of_motion">http://en.wikipedia.org/wiki/Newton's_laws_of_motion</a></li><li class="listitem" style="list-style-type: disc">Air resistance<a id="id1830" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Drag_%28physics%29">http://en.wikipedia.org/wiki/Drag_%28physics%29</a></li><li class="listitem" style="list-style-type: disc">Some numerical methods<a id="id1831" class="indexterm"/> for ODEs described at <a class="ulink" href="http://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations">http://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations</a></li><li class="listitem" style="list-style-type: disc">The Euler method<a id="id1832" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Euler_method">http://en.wikipedia.org/wiki/Euler_method</a></li><li class="listitem" style="list-style-type: disc">Documentation of the ODEPACK package<a id="id1833" class="indexterm"/> in FORTRAN available at <a class="ulink" href="http://www.netlib.org/odepack/opks-sum">www.netlib.org/odepack/opks-sum</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec393"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Plotting the bifurcation diagram of a chaotic dynamical system</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Simulating a partial differential equation – reaction-diffusion systems and Turing patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec104"/>Simulating a partial differential equation – reaction-diffusion systems and Turing patterns</h1></div></div></div><p>
<span class="strong"><strong>Partial Differential Equations</strong></span> (<span class="strong"><strong>PDEs</strong></span>)<a id="id1834" class="indexterm"/> describe the evolution of dynamical systems involving both time and space. Examples in physics include sound, heat, electromagnetism, fluid flow, and elasticity, among others. Examples in biology include tumor growth, population dynamics, and epidemic propagations.</p><p>PDEs are hard to solve analytically. Therefore, PDEs are often studied via numerical simulations.</p><p>In this recipe, we will illustrate how to simulate a <span class="strong"><strong>reaction-diffusion system</strong></span><a id="id1835" class="indexterm"/> described by a PDE called the <a id="id1836" class="indexterm"/><span class="strong"><strong>FitzHugh–Nagumo equation</strong></span>. A reaction-diffusion system models the evolution of one or several variables subject to two processes: reaction (transformation of the variables into each other) and diffusion (spreading across a spatial region). Some chemical reactions can be described by this type of model, but there are other applications in physics, biology, ecology, and other disciplines.</p><p>Here, we simulate a system that has been proposed by Alan Turing as a model of animal coat pattern formation. Two chemical substances influencing skin pigmentation interact according to a reaction-diffusion model. This system is responsible for the formation of patterns that are reminiscent of the pelage of zebras, jaguars, and giraffes.</p><p>We will simulate this <a id="id1837" class="indexterm"/>system with the finite difference method. This method consists of discretizing time and space and replacing the derivatives with their discrete equivalents.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec394"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import the packages:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We will simulate the following system of partial differential equations on the domain <span class="emphasis"><em>E=[-1,1]<sup>2</sup></em></span>:<div class="mediaobject"><img src="images/4818OS_12_14.jpg" alt="How to do it..."/></div><p>The variable <span class="emphasis"><em>u</em></span> represents the concentration of a substance favoring skin pigmentation, whereas <span class="emphasis"><em>v</em></span> represents another substance that reacts with the first and impedes pigmentation.</p><p>At initialization time, we assume that <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>v</em></span> contain independent random numbers on every grid point. We also take <span class="strong"><strong>Neumann boundary conditions</strong></span>: we require <a id="id1838" class="indexterm"/>the spatial derivatives of the variables with respect to the normal vectors to be null on the domain's boundaries.</p></li><li class="listitem">Let's define the four parameters of the model:<div class="informalexample"><pre class="programlisting">In [2]: a = 2.8e-4
        b = 5e-3
        tau = .1
        k = -.005</pre></div></li><li class="listitem">We discretize time and space. The following condition ensures that the discretization scheme we use here is stable:<div class="mediaobject"><img src="images/4818OS_12_15.jpg" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting">In [3]: size = 80  # size of the 2D grid
        dx = 2./size  # space step
In [4]: T = 10.0  # total time
        dt = .9 * dx**2/2  # time step
        n = int(T/dt)</pre></div></li><li class="listitem">We initialize the <a id="id1839" class="indexterm"/>variables <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>v</em></span>. The matrices <code class="literal">U</code> and <code class="literal">V</code> contain the values of these variables on the vertices of the 2D grid. These variables are initialized with a uniform noise between 0 and 1:<div class="informalexample"><pre class="programlisting">In [5]: U = np.random.rand(size, size)
        V = np.random.rand(size, size)</pre></div></li><li class="listitem">Now, we define a function that computes the discrete Laplace operator of a 2D variable on the grid, using a five-point stencil finite difference method. This operator is defined by:<div class="mediaobject"><img src="images/4818OS_12_16.jpg" alt="How to do it..."/></div><p>We can compute the values of this operator on the grid using vectorized matrix operations. Because of side effects on the edges of the matrix, we need to remove the borders of the grid in the computation:</p><div class="informalexample"><pre class="programlisting">In [6]: def laplacian(Z):
            Ztop = Z[0:-2,1:-1]
            Zleft = Z[1:-1,0:-2]
            Zbottom = Z[2:,1:-1]
            Zright = Z[1:-1,2:]
            Zcenter = Z[1:-1,1:-1]
            return (Ztop + Zleft + Zbottom + Zright \
                    - 4 * Zcenter) / dx**2</pre></div></li><li class="listitem">Now, we simulate the system of equations using the finite difference method. At each time step, we compute the right-hand sides of the two equations on the grid using discrete spatial derivatives (Laplacians). Then, we update the variables using a<a id="id1840" class="indexterm"/> discrete time derivative:<div class="informalexample"><pre class="programlisting">In [7]: for i in range(n):
            # We compute the Laplacian of u and v.
            deltaU = laplacian(U)
            deltaV = laplacian(V)
            # We take the values of u and v
            # inside the grid.
            Uc = U[1:-1,1:-1]
            Vc = V[1:-1,1:-1]
            # We update the variables.
            U[1:-1,1:-1], V[1:-1,1:-1] = (
              Uc + dt * (a*deltaU + Uc - Uc**3 - Vc + k), 
              Vc + dt * (b*deltaV + Uc - Vc) / tau)
            # Neumann conditions: derivatives at the edges
            # are null.
            for Z in (U, V):
                Z[0,:] = Z[1,:]
                Z[-1,:] = Z[-2,:]
                Z[:,0] = Z[:,1]
                Z[:,-1] = Z[:,-2]</pre></div></li><li class="listitem">Finally, we display the variable <code class="literal">u</code> after a time <code class="literal">T</code> of simulation:<div class="informalexample"><pre class="programlisting">In [8]: plt.imshow(U, cmap=plt.cm.copper, extent=[-1,1,-1,1])</pre></div><div class="mediaobject"><img src="images/4818OS_12_17.jpg" alt="How to do it..."/></div><p>Whereas the variables were completely random at initialization time, we observe the formation of patterns after a sufficiently long simulation time.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec395"/>How it works...</h2></div></div></div><p>Let's explain how the <a id="id1841" class="indexterm"/>finite difference method allowed us to implement the update step. We start from the following system of equations:</p><div class="mediaobject"><img src="images/4818OS_12_18.jpg" alt="How it works..."/></div><p>We first use the following scheme for the discrete Laplace operator:</p><div class="mediaobject"><img src="images/4818OS_12_19.jpg" alt="How it works..."/></div><p>We also use this scheme for the time derivative of <span class="emphasis"><em>u</em></span> and <span class="emphasis"><em>v</em></span>:</p><div class="mediaobject"><img src="images/4818OS_12_20.jpg" alt="How it works..."/></div><p>We end up with the following iterative update step:</p><div class="mediaobject"><img src="images/4818OS_12_21.jpg" alt="How it works..."/></div><p>Here, our Neumann boundary conditions state that the spatial derivatives with respect to the normal vectors are null on the boundaries of the domain <span class="emphasis"><em>E</em></span>:</p><div class="mediaobject"><img src="images/4818OS_12_22.jpg" alt="How it works..."/></div><p>We implement these boundary conditions by duplicating values in matrices <code class="literal">U</code> and <code class="literal">V</code> on the edges (see the preceding code).</p><p>In order to ensure that <a id="id1842" class="indexterm"/>our numerical scheme converges to a numerical solution that is close to the actual (unknown) mathematical solution, the stability of the scheme needs to be ascertained. One can show that a sufficient condition for the stability is:</p><div class="mediaobject"><img src="images/4818OS_12_23.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec396"/>There's more...</h2></div></div></div><p>Here are further references on partial differential equations, reaction-diffusion systems, and numerical simulations of those systems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Partial differential equations on <a id="id1843" class="indexterm"/>Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Partial_differential_equation">http://en.wikipedia.org/wiki/Partial_differential_equation</a></li><li class="listitem" style="list-style-type: disc">Reaction-diffusion systems<a id="id1844" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system">http://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system</a></li><li class="listitem" style="list-style-type: disc">FitzHugh-Nagumo system<a id="id1845" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/FitzHugh%E2%80%93Nagumo_equation">http://en.wikipedia.org/wiki/FitzHugh%E2%80%93Nagumo_equation</a></li><li class="listitem" style="list-style-type: disc">Neumann boundary conditions<a id="id1846" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Neumann_boundary_condition">http://en.wikipedia.org/wiki/Neumann_boundary_condition</a></li><li class="listitem" style="list-style-type: disc">Von Neumann stability analysis<a id="id1847" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Von_Neumann_stability_analysis">http://en.wikipedia.org/wiki/Von_Neumann_stability_analysis</a></li><li class="listitem" style="list-style-type: disc">A course on Computational Fluid Dynamics<a id="id1848" class="indexterm"/> by Prof. Lorena Barba, written in the IPython notebook, available at <a class="ulink" href="https://github.com/barbagroup/CFDPython">https://github.com/barbagroup/CFDPython</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec397"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Simulating an elementary cellular automaton</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Simulating an ordinary differential equation with SciPy</em></span> recipe</li></ul></div></div></div></div>
</body></html>