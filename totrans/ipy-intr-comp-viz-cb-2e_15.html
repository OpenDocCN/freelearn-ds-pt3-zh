<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 15. Symbolic and Numerical Mathematics"><div class="titlepage"><div><div><h1 class="title"><a id="ch15"/>Chapter 15. Symbolic and Numerical Mathematics</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Diving into symbolic computing with SymPy</li><li class="listitem" style="list-style-type: disc">Solving equations and inequalities</li><li class="listitem" style="list-style-type: disc">Analyzing real-valued functions</li><li class="listitem" style="list-style-type: disc">Computing exact probabilities and manipulating random variables</li><li class="listitem" style="list-style-type: disc">A bit of number theory with SymPy</li><li class="listitem" style="list-style-type: disc">Finding a Boolean propositional formula from a truth table</li><li class="listitem" style="list-style-type: disc">Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations</li><li class="listitem" style="list-style-type: disc">Getting started with Sage</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec118"/>Introduction</h1></div></div></div><p>In this chapter, we will introduce <a id="id2092" class="indexterm"/><span class="strong"><strong>SymPy</strong></span>, a Python library for symbolic mathematics. Whereas most of the book deals with numerical methods, we will see examples here where symbolic computations are more suitable.</p><p>SymPy is to symbolic computing what NumPy<a id="id2093" class="indexterm"/> is to numerical computing. For example, SymPy can help us analyze a mathematical model before we run a simulation.</p><p>Although quite powerful, SymPy is a bit slow compared to other computer algebra systems. The main reason is that SymPy is written in pure Python. A faster and more powerful mathematics system is <a id="id2094" class="indexterm"/><span class="strong"><strong>Sage</strong></span> (see also the <span class="emphasis"><em>Getting started with Sage</em></span> recipe in this chapter). Sage is a heavy standalone program that has many big dependencies (including SymPy!), and it uses only Python 2 at the time of writing. It is essentially meant for interactive use. Sage includes an IPython-like notebook.</p><div class="section" title="LaTeX"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec445"/>LaTeX</h2></div></div></div><p>
<span class="strong"><strong>LaTeX</strong></span><a id="id2095" class="indexterm"/> is a document markup language widely used to write publication-quality mathematical equations. Equations written in LaTeX can be displayed in the browser with the <span class="strong"><strong>MathJax</strong></span><a id="id2096" class="indexterm"/> JavaScript library. SymPy uses this system to display equations in the IPython notebook.</p><p>LaTeX equations can also be used in matplotlib. In this case, it is recommended to have a LaTeX installation on your local computer.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">LaTeX on <a id="id2097" class="indexterm"/>Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/LaTeX">http://en.wikipedia.org/wiki/LaTeX</a></li><li class="listitem" style="list-style-type: disc">MathJax, available<a id="id2098" class="indexterm"/> at <a class="ulink" href="http://www.mathjax.org">www.mathjax.org</a></li><li class="listitem" style="list-style-type: disc">LaTeX in matplotlib, described at <a class="ulink" href="http://matplotlib.org/users/usetex.html">http://matplotlib.org/users/usetex.html</a></li><li class="listitem" style="list-style-type: disc">Documentation for displaying <a id="id2099" class="indexterm"/>equations with SymPy, available at <a class="ulink" href="http://docs.sympy.org/latest/tutorial/printing.html">http://docs.sympy.org/latest/tutorial/printing.html</a></li><li class="listitem" style="list-style-type: disc">To install LaTeX on your computer, refer to <a class="ulink" href="http://latex-project.org/ftp.html">http://latex-project.org/ftp.html</a></li></ul></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Diving into symbolic computing with SymPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec119"/>Diving into symbolic computing with SymPy</h1></div></div></div><p>In this recipe, we will give a brief introduction to symbolic computing with SymPy. We will see more advanced features of SymPy in the next recipes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec446"/>Getting ready</h2></div></div></div><p>SymPy<a id="id2100" class="indexterm"/> is a pure Python package with no other dependencies, and as such, it is very easy to install. With Anaconda, you can type <code class="literal">conda install sympy</code> in a terminal. On Windows, you can use Chris Gohlke's package (<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#sympy">www.lfd.uci.edu/~gohlke/pythonlibs/#sympy</a>). Finally, you can use the <code class="literal">pip install sympy</code> command.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec447"/>How to do it...</h2></div></div></div><p>SymPy can be used from a <a id="id2101" class="indexterm"/>Python module, or interactively in IPython. In the <a id="id2102" class="indexterm"/>notebook, all mathematical expressions are displayed with LaTeX, thanks to the MathJax JavaScript library.</p><p>Here is an introduction to SymPy:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we import SymPy and enable LaTeX printing in the IPython notebook:<div class="informalexample"><pre class="programlisting">In [1]: from sympy import *
        init_printing()</pre></div></li><li class="listitem">To deal with symbolic variables, we first need to declare them:<div class="informalexample"><pre class="programlisting">In [2]: var('x y')
Out[2]: (x, y)</pre></div></li><li class="listitem">The <code class="literal">var()</code> function creates symbols and injects them into the namespace. This function should only be used in the interactive mode. In a Python module, it is better to use the <code class="literal">symbols()</code> function that returns the symbols:<div class="informalexample"><pre class="programlisting">In [3]: x, y = symbols('x y')</pre></div></li><li class="listitem">We can create mathematical expressions with these symbols:<div class="informalexample"><pre class="programlisting">In [4]: expr1 = (x + 1)**2
        expr2 = x**2 + 2*x + 1</pre></div></li><li class="listitem">Are these expressions equal?<div class="informalexample"><pre class="programlisting">In [5]: expr1 == expr2
Out[5]: False</pre></div></li><li class="listitem">These expressions are mathematically equal, but not syntactically identical. To test whether they are mathematically equal, we can ask SymPy to simplify the difference algebraically:<div class="informalexample"><pre class="programlisting">In [6]: simplify(expr1-expr2)
Out[6]: 0</pre></div></li><li class="listitem">A very common operation with symbolic expressions is the substitution of a symbol by another symbol, expression, or a number, using the <code class="literal">subs()</code> method of a symbolic expression:<div class="mediaobject"><img src="images/4818OS_15_01.jpg" alt="How to do it..."/><div class="caption"><p>Substitution in a SymPy expression</p></div></div></li><li class="listitem">A rational number cannot be written simply as <code class="literal">1/2</code> as this Python expression evaluates to 0. A possibility is to convert the number <code class="literal">1</code> into a SymPy integer object, for example by using the <code class="literal">S()</code> function:<div class="informalexample"><pre class="programlisting">In [9]: expr1.subs(x, S(1)/2)
Out[9]: 9/4</pre></div></li><li class="listitem">Exactly represented numbers can be evaluated numerically with <code class="literal">evalf</code>:<div class="informalexample"><pre class="programlisting">In [10]: _.evalf()
Out[10]: 2.25000000000000</pre></div></li><li class="listitem">We can easily <a id="id2103" class="indexterm"/>create a Python function from a SymPy symbolic <a id="id2104" class="indexterm"/>expression using<a id="id2105" class="indexterm"/> the <code class="literal">lambdify()</code> function. The resulting function can notably be evaluated on NumPy arrays. This is quite convenient when we need to go from the symbolic world to the numerical world:<div class="informalexample"><pre class="programlisting">In [11]: f = lambdify(x, expr1)
In [12]: import numpy as np
         f(np.linspace(-2., 2., 5))
Out[12]: array([ 1.,  0.,  1.,  4.,  9.])</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec448"/>How it works...</h2></div></div></div><p>A core idea in SymPy is to use the standard Python syntax to manipulate exact expressions. Although this is very convenient and natural, there are a few caveats. Symbols such as <code class="literal">x</code>, which represent mathematical variables, cannot be used in Python before being instantiated (otherwise, a <code class="literal">NameError</code> exception is thrown by the interpreter). This is in contrast to most other computer algebra systems. For this reason, SymPy offers ways to declare symbolic variables beforehand.</p><p>Another example is integer division; as <code class="literal">1/2</code> evaluates to <code class="literal">0</code> (in Python 2), SymPy has no way to know that the user intended to write a fraction instead. We need to convert the numerical integer <code class="literal">1</code> to the symbolic integer <code class="literal">1</code> before dividing it by <code class="literal">2</code>.</p><p>Also, the Python equality<a id="id2106" class="indexterm"/> refers to the equality between syntax trees rather<a id="id2107" class="indexterm"/> than between mathematical expressions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec449"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Solving equations and inequalities</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Getting started with Sage</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Solving equations and inequalities"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec120"/>Solving equations and inequalities</h1></div></div></div><p>SymPy offers several ways to solve linear and nonlinear equations and systems of equations. Of course, these functions do not always succeed in finding closed-form exact solutions. In this case, we can fall back to numerical solvers and obtain approximate solutions.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec450"/>Getting ready</h2></div></div></div><p>We first need to import SymPy. We <a id="id2108" class="indexterm"/>also initialize pretty printing in the <a id="id2109" class="indexterm"/>notebook (see the first recipe of this chapter).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec451"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's define a few symbols:<div class="informalexample"><pre class="programlisting">In [2]: var('x y z a')
Out[2]: (x, y, z, a)</pre></div></li><li class="listitem">We use the <code class="literal">solve()</code> function to solve equations (the right-hand side is <code class="literal">0</code> by default):<div class="informalexample"><pre class="programlisting">In [3]: solve(x**2 - a, x)
Out[3]: [-sqrt(a), sqrt(a)]</pre></div></li><li class="listitem">We can also solve inequalities. Here, we need to use the <code class="literal">solve_univariate_inequality()</code> function to solve this univariate inequality in the real domain:<div class="informalexample"><pre class="programlisting">In [4]: x = Symbol('x')
        solve_univariate_inequality(x**2 &gt; 4, x)
Out[4]: Or(x &lt; -2, x &gt; 2)</pre></div></li><li class="listitem">The <code class="literal">solve()</code> function also accepts systems of equations (here, a linear system):<div class="informalexample"><pre class="programlisting">In [5]: solve([x + 2*y + 1, x - 3*y - 2], x, y)
Out[5]: {x: 1/5, y: -3/5}</pre></div></li><li class="listitem">Nonlinear systems are also handled:<div class="informalexample"><pre class="programlisting">In [6]: solve([x**2 + y**2 - 1, x**2 - y**2 - S(1)/2],
              x, y)
Out[6]: [(-sqrt(3)/2, -1/2), (-sqrt(3)/2, 1/2),
         (sqrt(3)/2, -1/2), (sqrt(3)/2, 1/2)]</pre></div></li><li class="listitem">Singular linear systems can also be solved (here, there is an infinite number of solutions because the two equations are collinear):<div class="informalexample"><pre class="programlisting">In [7]: solve([x + 2*y + 1, -x - 2*y - 1], x, y)
Out[7]: {x: -2*y - 1}</pre></div></li><li class="listitem">Now, let's solve a linear system using matrices containing symbolic variables:<div class="informalexample"><pre class="programlisting">In [8]: var('a b c d u v')
Out[8]: (a, b, c, d, u, v)</pre></div></li><li class="listitem">We create the<a id="id2110" class="indexterm"/> <span class="strong"><strong>augmented matrix</strong></span>, which is the horizontal concatenation of the system's <a id="id2111" class="indexterm"/>matrix with the linear coefficients and the right-hand side<a id="id2112" class="indexterm"/> vector. This matrix corresponds to the following system in <span class="emphasis"><em>x,y: ax+by=u, cx+dy=v</em></span>:<div class="informalexample"><pre class="programlisting">In [9]: M = Matrix([[a, b, u], [c, d, v]]); M
Out[9]: Matrix([[a, b, u],
                [c, d, v]])
In [10]: solve_linear_system(M, x, y)
Out[10]: {x: (-b*v + d*u)/(a*d - b*c),
          y: ( a*v - c*u)/(a*d - b*c)}</pre></div></li><li class="listitem">This system needs to be nonsingular in order to have a unique solution, which is equivalent to saying that the determinant of the system's matrix needs to be nonzero (otherwise the denominators in the preceding fractions are equal to zero):<div class="informalexample"><pre class="programlisting">In [11]: det(M[:2,:2])
Out[11]: a*d - b*c</pre></div></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec452"/>There's more...</h2></div></div></div><p>Matrix support in SymPy is <a id="id2113" class="indexterm"/>quite rich; we can perform a large number of operations and decompositions (see the reference guide at <a class="ulink" href="http://docs.sympy.org/latest/modules/matrices/matrices.html">http://docs.sympy.org/latest/modules/matrices/matrices.html</a>).</p><p>Here are more references about <a id="id2114" class="indexterm"/>linear algebra:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Linear algebra on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Linear_algebra#Further_reading">http://en.wikipedia.org/wiki/Linear_algebra#Further_reading</a></li><li class="listitem" style="list-style-type: disc">Linear algebra on Wikibooks, at <a class="ulink" href="http://en.wikibooks.org/wiki/Linear_Algebra">http://en.wikibooks.org/wiki/Linear_Algebra</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Analyzing real-valued functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec121"/>Analyzing real-valued functions</h1></div></div></div><p>SymPy contains a rich <span class="strong"><strong>calculus</strong></span> toolbox<a id="id2115" class="indexterm"/> to analyze real-valued functions: limits, power series, derivatives, integrals, Fourier transforms, and so on. In this recipe, we will show the very basics of these capabilities.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec453"/>Getting ready</h2></div></div></div><p>We first need to import SymPy. We also initialize pretty printing in the notebook (see the first recipe of this chapter).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec454"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's define a few <a id="id2116" class="indexterm"/>symbols and a function (which is just an expression depending on <code class="literal">x</code>):<div class="informalexample"><pre class="programlisting">In [1]: var('x z')
Out[1]: (x, z) 
In [2]: f = 1/(1+x**2)</pre></div></li><li class="listitem">Let's evaluate this function at <code class="literal">1</code>:<div class="informalexample"><pre class="programlisting">In [3]: f.subs(x, 1)
Out[3]: 1/2</pre></div></li><li class="listitem">We can compute the derivative of this function:<div class="informalexample"><pre class="programlisting">In [4]: diff(f, x)
Out[4]: -2*x/(x**2 + 1)**2</pre></div></li><li class="listitem">What is <code class="literal">f</code>'s limit to infinity? (Note the double o (<code class="literal">oo</code>) for the infinity symbol):<div class="informalexample"><pre class="programlisting">In [5]: limit(f, x, oo)
Out[5]: 0</pre></div></li><li class="listitem">Here's how to compute a Taylor series (here, around <code class="literal">0</code>, of order <code class="literal">9</code>). The <span class="strong"><strong>Big O</strong></span> can be removed with the <code class="literal">removeO()</code> method.<div class="informalexample"><pre class="programlisting">In [6]: series(f, x0=0, n=9)
Out[6]: 1 - x**2 + x**4 - x**6 + x**8 + O(x**9)</pre></div></li><li class="listitem">We can compute definite integrals (here, over the entire real line):<div class="informalexample"><pre class="programlisting">In [7]: integrate(f, (x, -oo, oo))
Out[7]: pi</pre></div></li><li class="listitem">SymPy can also compute indefinite integrals:<div class="informalexample"><pre class="programlisting">In [8]: integrate(f, x)
Out[8]: atan(x)</pre></div></li><li class="listitem">Finally, let's <a id="id2117" class="indexterm"/>compute <code class="literal">f</code>'s Fourier transforms:<div class="informalexample"><pre class="programlisting">In [9]: fourier_transform(f, x, z)
Out[9]: pi*exp(-2*pi*z)</pre></div></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec455"/>There's more...</h2></div></div></div><p>SymPy<a id="id2118" class="indexterm"/> includes a large number of other integral transforms besides the Fourier transform (<a class="ulink" href="http://docs.sympy.org/dev/modules/integrals/integrals.html">http://docs.sympy.org/dev/modules/integrals/integrals.html</a>). However, SymPy will not always be able to find closed-form solutions.</p><p>Here are a few general references about <a id="id2119" class="indexterm"/>real analysis and <a id="id2120" class="indexterm"/>calculus:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Real analysis on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Real_analysis#Bibliography">http://en.wikipedia.org/wiki/Real_analysis#Bibliography</a></li><li class="listitem" style="list-style-type: disc">Calculus on Wikibooks, at <a class="ulink" href="http://en.wikibooks.org/wiki/Calculus">http://en.wikibooks.org/wiki/Calculus</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Computing exact probabilities and manipulating random variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec122"/>Computing exact probabilities and manipulating random variables</h1></div></div></div><p>SymPy includes a module named <code class="literal">stats</code> that lets us<a id="id2121" class="indexterm"/> create and manipulate random variables. This is useful when we work with probabilistic or statistical models; we can compute symbolic expectancies, variances probabilities, and densities of random variables.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec456"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import <a id="id2122" class="indexterm"/>SymPy <a id="id2123" class="indexterm"/>and the stats module:<div class="informalexample"><pre class="programlisting">In [1]: from sympy import *
        from sympy.stats import *
        init_printing()</pre></div></li><li class="listitem">Let's roll two dice, <code class="literal">X</code> and <code class="literal">Y</code>, with six faces each:<div class="informalexample"><pre class="programlisting">In [2]: X, Y = Die('X', 6), Die('Y', 6)</pre></div></li><li class="listitem">We can compute probabilities defined by equalities (with the <code class="literal">Eq</code> operator) or inequalities:<div class="informalexample"><pre class="programlisting">In [3]: P(Eq(X, 3))
Out[3]: 1/6
In [4]: P(X&gt;3)
Out[4]: 1/2</pre></div></li><li class="listitem">Conditions can also involve multiple random variables:<div class="informalexample"><pre class="programlisting">In [5]: P(X&gt;Y)
Out[5]: 5/12</pre></div></li><li class="listitem">We can compute conditional probabilities:<div class="informalexample"><pre class="programlisting">In [6]: P(X+Y&gt;6, X&lt;5)
Out[6]: 5/12</pre></div></li><li class="listitem">We can also work with arbitrary discrete or continuous random variables:<div class="informalexample"><pre class="programlisting">In [7]: Z = Normal('Z', 0, 1)  # Gaussian variable
In [8]: P(Z&gt;pi)
Out[8]: -erf(sqrt(2)*pi/2)/2 + 1/2</pre></div></li><li class="listitem">We can compute expectancies and variances:<div class="informalexample"><pre class="programlisting">In [9]: E(Z**2), variance(Z**2)
Out[9]: (1, 2)</pre></div></li><li class="listitem">We can also compute densities:<div class="informalexample"><pre class="programlisting">In [10]: f = density(Z)
In [11]: var('x')
         f(x)
Out[11]: sqrt(2)*exp(-x**2/2)/(2*sqrt(pi))</pre></div></li><li class="listitem">We can plot these densities:<div class="informalexample"><pre class="programlisting">In [12]: %matplotlib inline
         plot(f(x), (x, -6, 6))</pre></div><div class="mediaobject"><img src="images/4818OS_15_02.jpg" alt="How to do it..."/><div class="caption"><p>The Gaussian density</p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec457"/>How it works...</h2></div></div></div><p>SymPy's <code class="literal">stats</code> module<a id="id2124" class="indexterm"/> contains many functions to define random variables with <a id="id2125" class="indexterm"/>classical laws (binomial, exponential, and so on), discrete<a id="id2126" class="indexterm"/> or continuous. It works by leveraging SymPy's powerful integration algorithms to compute exact probabilistic quantities as integrals of probability distributions. For example, <span class="inlinemediaobject"><img src="images/4818OS_15_10.jpg" alt="How it works..."/></span> is:</p><div class="mediaobject"><img src="images/4818OS_15_03.jpg" alt="How it works..."/></div><p>Note that the equality condition is written using the <code class="literal">Eq</code> operator rather than the more standard <code class="literal">==</code> Python syntax. This is a general feature in SymPy; <code class="literal">==</code> means equality between Python variables, whereas <code class="literal">Eq</code> is the mathematical operation between symbolic expressions.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A bit of number theory with SymPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec123"/>A bit of number theory with SymPy</h1></div></div></div><p>SymPy contains many <a id="id2127" class="indexterm"/>number-theory-related routines: obtaining prime numbers, integer decompositions, and much more. We will show a few examples here.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec458"/>Getting ready</h2></div></div></div><p>To display legends using LaTeX in matplotlib, you will need an installation of LaTeX on your computer (see this chapter's <span class="emphasis"><em>Introduction</em></span>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec459"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import SymPy and the number theory package:<div class="informalexample"><pre class="programlisting">In [1]: from sympy import *
        init_printing() 
In [2]: import sympy.ntheory as nt</pre></div></li><li class="listitem">We can test whether a number is prime:<div class="informalexample"><pre class="programlisting">In [3]: nt.isprime(2011)
Out[3]: True</pre></div></li><li class="listitem">We can find the next prime after a given number:<div class="informalexample"><pre class="programlisting">In [4]: nt.nextprime(2011)
Out[4]: 2017</pre></div></li><li class="listitem">What is the 1000th prime number?<div class="informalexample"><pre class="programlisting">In [5]: nt.prime(1000)
Out[5]: 7919</pre></div></li><li class="listitem">How many <a id="id2128" class="indexterm"/>primes <a id="id2129" class="indexterm"/>less than 2011 are there?<div class="informalexample"><pre class="programlisting">In [6]: nt.primepi(2011)
Out[6]: 305</pre></div></li><li class="listitem">
We can plot <span class="inlinemediaobject"><img src="images/4818OS_15_11.jpg" alt="How to do it..."/></span>, the <span class="strong"><strong>prime-counting function</strong></span><a id="id2130" class="indexterm"/> (the number of prime numbers less than or equal to some number <span class="emphasis"><em>x</em></span>). The famous <span class="strong"><strong>prime number theorem</strong></span><a id="id2131" class="indexterm"/> states that this function is asymptotically equivalent to <span class="emphasis"><em>x/</em></span>log<span class="emphasis"><em>(x)</em></span>. This expression approximately quantifies the distribution of prime numbers among all integers:
<div class="informalexample"><pre class="programlisting">In [7]: import numpy as np
        import matplotlib.pyplot as plt
        %matplotlib inline
        x = np.arange(2, 10000)
        plt.plot(x, map(nt.primepi, x), '-k', 
                 label='$\pi(x)$')
        plt.plot(x, x / np.log(x), '--k', 
                 label='$x/\log(x)$')
        plt.legend(loc=2)</pre></div><div class="mediaobject"><img src="images/4818OS_15_04.jpg" alt="How to do it..."/><div class="caption"><p>Distribution of prime numbers</p></div></div></li><li class="listitem">Let's compute the integer factorization of a number:<div class="informalexample"><pre class="programlisting">In [8]: nt.factorint(1998)
Out[8]: {2: 1, 3: 3, 37: 1}
In [9]: 2 * 3**3 * 37
Out[9]: 1998</pre></div></li><li class="listitem">Finally, a<a id="id2132" class="indexterm"/> small problem. A lazy mathematician is<a id="id2133" class="indexterm"/> counting his marbles. When they are arranged in three rows, the last column contains one marble. When they form four rows, there are two marbles in the last column, and there are three with five rows. How many marbles are there? (Hint: The lazy mathematician has fewer than 100 marbles.)<div class="mediaobject"><img src="images/4818OS_15_05.jpg" alt="How to do it..."/><div class="caption"><p>Counting marbles with the Chinese Remainder Theorem</p></div></div><p>The Chinese Remainder Theorem gives us the answer:</p><div class="informalexample"><pre class="programlisting">In [10]: from sympy.ntheory.modular import solve_congruence
In [11]: solve_congruence((1, 3), (2, 4), (3, 5))
Out[11]: (58, 60)</pre></div><p>There are infinitely many solutions:  58 plus any multiple of 60. Since there are less than 100 marbles, 58 is the right answer.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec460"/>How it works...</h2></div></div></div><p>SymPy contains<a id="id2134" class="indexterm"/> many <a id="id2135" class="indexterm"/>number-theory-related functions. Here, we used the <a id="id2136" class="indexterm"/><span class="strong"><strong>Chinese Remainder Theorem</strong></span> to find the solutions of the following system of arithmetic equations:</p><div class="mediaobject"><img src="images/4818OS_15_06.jpg" alt="How it works..."/><div class="caption"><p>The Chinese Remainder Theorem</p></div></div><p>The triple bar is the symbol for modular congruence. Here, it means that <span class="emphasis"><em>m<sub>i</sub></em></span> divides <span class="emphasis"><em>a<sub>i</sub>-n</em></span>. In other words, <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>a<sub>i</sub></em></span> are equal up to a multiple of <span class="emphasis"><em>m<sub>i</sub></em></span>. Reasoning with congruences is very convenient when periodic scales are involved. For example, operations involving 12-hour clocks are done modulo 12. The numbers 11 and 23 are equivalent modulo 12 (they represent the same hour on the clock) because their difference is a multiple of 12.</p><p>In this recipe's example, three congruences have to be satisfied: the remainder of the number of marbles in the division with 3 is 1 (there's one extra marble in that arrangement), it is 2 in the division with 4, and 3 in the division with 5. With SymPy, we simply specify these values in the <code class="literal">solve_congruence()</code> function<a id="id2137" class="indexterm"/> to get the solutions.</p><p>The theorem states that solutions exist as soon as the <span class="emphasis"><em>m<sub>i</sub></em></span> are pairwise co-prime (any two distinct numbers among them are co-prime). All solutions are congruent modulo the product of the <span class="emphasis"><em>m<sub>i</sub></em></span>. This fundamental theorem in number theory has several applications, notably in cryptography.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec461"/>There's more...</h2></div></div></div><p>Here are a few textbooks about <a id="id2138" class="indexterm"/>number theory:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Undergraduate level: <span class="emphasis"><em>Elementary Number Theory</em></span>, <span class="emphasis"><em>Gareth A. Jones</em></span>, <span class="emphasis"><em>Josephine M. Jones</em></span>, <span class="emphasis"><em>Springer</em></span>, <span class="emphasis"><em>(1998)</em></span></li><li class="listitem" style="list-style-type: disc">Graduate<a id="id2139" class="indexterm"/> level: <span class="emphasis"><em>A Classical Introduction to Modern Number Theory</em></span>, <span class="emphasis"><em>Kenneth Ireland</em></span>, <span class="emphasis"><em>Michael Rosen</em></span>, <span class="emphasis"><em>Springer</em></span>, <span class="emphasis"><em>(1982)</em></span></li></ul></div><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Documentation on <a id="id2140" class="indexterm"/>SymPy's number-theory module, available at <a class="ulink" href="http://docs.sympy.org/dev/modules/ntheory.html">http://docs.sympy.org/dev/modules/ntheory.html</a></li><li class="listitem" style="list-style-type: disc">The Chinese Remainder Theorem<a id="id2141" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">http://en.wikipedia.org/wiki/Chinese_remainder_theorem</a></li><li class="listitem" style="list-style-type: disc">Applications of the Chinese Remainder Theorem, given at <a class="ulink" href="http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem">http://mathoverflow.net/questions/10014/applications-of-the-chinese-remainder-theorem</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding a Boolean propositional formula from a truth table"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec124"/>Finding a Boolean propositional formula from a truth table</h1></div></div></div><p>The logic module in SymPy lets us manipulate complex Boolean expressions, also known as <a id="id2142" class="indexterm"/><span class="strong"><strong>propositional formulas</strong></span>.</p><p>This recipe will show an example <a id="id2143" class="indexterm"/>where this module can be<a id="id2144" class="indexterm"/> useful. Let's suppose that, in a program, we need to write a complex <code class="literal">if</code> statement depending on three Boolean variables. We can think about each of the eight possible cases (true, true and false, and so on) and evaluate what the outcome should be. SymPy offers a function to generate a compact logic expression that satisfies our truth table.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec462"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import SymPy:<div class="informalexample"><pre class="programlisting">In [1]: from sympy import *
        init_printing()</pre></div></li><li class="listitem">Let's define a few symbols:<div class="informalexample"><pre class="programlisting">In [2]: var('x y z')</pre></div></li><li class="listitem">We can define propositional formulas with symbols and a few operators:<div class="informalexample"><pre class="programlisting">In [3]: P = x &amp; (y | ~z); P
Out[3]: And(Or(Not(z), y), x) </pre></div></li><li class="listitem">We can use <code class="literal">subs()</code> to evaluate a formula on actual Boolean values:<div class="informalexample"><pre class="programlisting">In [4]: P.subs({x: True, y: False, z: True})
Out[4]: False</pre></div></li><li class="listitem">Now, we want to find a propositional formula depending on <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>, with the following truth table:<div class="mediaobject"><img src="images/4818OS_15_07.jpg" alt="How to do it..."/><div class="caption"><p>A truth table</p></div></div></li><li class="listitem">Let's write down <a id="id2145" class="indexterm"/>all combinations <a id="id2146" class="indexterm"/>that we want to evaluate to <code class="literal">True</code>, and those for which the outcome does not matter:<div class="informalexample"><pre class="programlisting">In [6]: minterms = [[1,0,1], [1,0,0], [0,0,0]]
        dontcare = [[1,1,1], [1,1,0]]</pre></div></li><li class="listitem">Now, we use the <code class="literal">SOPform()</code> function to derive an adequate formula:<div class="informalexample"><pre class="programlisting">In [7]: Q = SOPform(['x', 'y', 'z'], minterms, dontcare); Q
Out[7]: Or(And(Not(y), Not(z)), x)</pre></div></li><li class="listitem">Let's test that this proposition works:<div class="informalexample"><pre class="programlisting">In [8]: Q.subs({x: True, y: False, z: False}), 
        Q.subs({x: False, y: True, z: True})
Out[8]: (True, False)</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec463"/>How it works...</h2></div></div></div><p>The <code class="literal">SOPform()</code> function<a id="id2147" class="indexterm"/> generates a full expression corresponding to a truth table and simplifies it using the<a id="id2148" class="indexterm"/> <span class="strong"><strong>Quine-McCluskey algorithm</strong></span>. It returns the smallest <span class="emphasis"><em>Sum of Products</em></span> form (or disjunction of conjunctions). Similarly, the <code class="literal">POSform()</code> function returns a Product of Sums.</p><p>The given truth table can occur in this case: suppose that we want to write a file if it doesn't already exist (<code class="literal">z</code>), or if the user wants to force the writing (<code class="literal">x</code>). In addition, the user can prevent the writing (<code class="literal">y</code>). The expression evaluates to <code class="literal">True</code> if the file is to be written. The resulting SOP formula works if we explicitly forbid <code class="literal">x</code> and <code class="literal">y</code> in the first place (forcing and preventing the writing at the same time is forbidden).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec464"/>There's more...</h2></div></div></div><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The propositional formula<a id="id2149" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Propositional_formula">http://en.wikipedia.org/wiki/Propositional_formula</a></li><li class="listitem" style="list-style-type: disc">Sum of Products on<a id="id2150" class="indexterm"/> Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Canonical_normal_form">http://en.wikipedia.org/wiki/Canonical_normal_form</a></li><li class="listitem" style="list-style-type: disc">The Quine–McCluskey algorithm<a id="id2151" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm">http://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec125"/>Analyzing a nonlinear differential system – Lotka-Volterra (predator-prey) equations</h1></div></div></div><p>Here, we will conduct a brief analytical study of a famous nonlinear differential system: the <a id="id2152" class="indexterm"/><span class="strong"><strong>Lotka-Volterra equations</strong></span>, also known as predator-prey equations. These equations are first-order differential equations that describe the evolution of two interacting populations (for example, sharks and sardines), where the predators eat the prey. This example illustrates how to obtain exact expressions and results about fixed points and their stability with SymPy.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec465"/>Getting ready</h2></div></div></div><p>For this recipe, knowing the <a id="id2153" class="indexterm"/>basics of linear and nonlinear systems of differential equations is recommended.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec466"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's create some symbols:<div class="informalexample"><pre class="programlisting">In [1]: from sympy import *
        init_printing() 
In [2]: var('x y')
        var('a b c d', positive=True)
Out[2]: (a, b, c, d)</pre></div></li><li class="listitem">The variables <code class="literal">x</code> and <code class="literal">y</code> represent the populations of the prey and predators, respectively. The parameters <code class="literal">a</code>, <code class="literal">b</code>, <code class="literal">c</code>, and <code class="literal">d</code> are strictly positive parameters (described more precisely in the <span class="emphasis"><em>How it works...</em></span> section of this recipe). The equations are:<div class="mediaobject"><img src="images/4818OS_15_08.jpg" alt="How to do it..."/><div class="caption"><p>Lotka-Volterra equations</p></div></div><div class="informalexample"><pre class="programlisting">In [3]: f = x * (a - b*y)
        g = -y * (c - d*x)</pre></div></li><li class="listitem">Let's find the fixed<a id="id2154" class="indexterm"/> points of the system (solving <span class="emphasis"><em>f(x,y) = g(x,y) = 0</em></span>). We call them <span class="emphasis"><em>(x<sub>0</sub>, y<sub>0</sub>)</em></span> and <span class="emphasis"><em>(x<sub>1</sub>, y<sub>1</sub>)</em></span>:<div class="informalexample"><pre class="programlisting">In [4]: solve([f, g], (x, y))
Out[4]: [(0, 0), (c/d, a/b)] 
In [5]: (x0, y0), (x1, y1) = _</pre></div></li><li class="listitem">Let's write the 2D vector with the two equations:<div class="informalexample"><pre class="programlisting">In [6]: M = Matrix((f, g)); M
Out[6]: Matrix([[ x*(a - b*y)],
                [-y*(c - d*x)]])</pre></div></li><li class="listitem">Now, we can compute the <span class="strong"><strong>Jacobian</strong></span> of the system, as a function of <code class="literal">(x, y)</code>:<div class="informalexample"><pre class="programlisting">In [7]: J = M.jacobian((x, y)); J
Out[7]: Matrix([
        [a - b*y,     -b*x],
        [    d*y, -c + d*x]])</pre></div></li><li class="listitem">Let's study the stability of the first fixed point by looking at the eigenvalues of the Jacobian at this point. The first fixed point corresponds to extinct populations:<div class="informalexample"><pre class="programlisting">In [8]: M0 = J.subs(x, x0).subs(y, y0); M0
Out[8]: Matrix([a,  0],
               [0, -c]]) 
In [9]: M0.eigenvals()
Out[9]: {a: 1, -c: 1}</pre></div><p>The parameters <code class="literal">a</code> and <code class="literal">c</code> are strictly positive, so the eigenvalues are real and of opposite signs, and this fixed point is a <a id="id2155" class="indexterm"/><span class="strong"><strong>saddle point</strong></span>. As this point is unstable, the extinction of both populations is unlikely in this model.</p></li><li class="listitem">Let's consider the second fixed point now:<div class="informalexample"><pre class="programlisting">In [10]: M1 = J.subs(x, x1).subs(y, y1); M1
Out[10]: Matrix([[    0, -b*c/d],
                 [a*d/b,      0]])
In [11]: M1.eigenvals()
Out[11]: {-I*sqrt(a)*sqrt(c): 1, I*sqrt(a)*sqrt(c): 1}</pre></div><p>The eigenvalues are purely imaginary; thus, this fixed point is not hyperbolic. Therefore, we cannot draw conclusions from this linear analysis about the qualitative behavior of the system around this fixed point. However, we could show with other methods that oscillations occur around this point.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec467"/>How it works...</h2></div></div></div><p>The Lotka-Volterra equations <a id="id2156" class="indexterm"/>model the growth of the predator and<a id="id2157" class="indexterm"/> prey populations, taking into account their interactions. In the first equation, the <span class="emphasis"><em>ax</em></span> term represents the exponential growth of the prey, and <span class="emphasis"><em>-bxy</em></span> represents death by predators. Similarly, in the second equation, <span class="emphasis"><em>-yc</em></span> represents the natural death of the predators, and <span class="emphasis"><em>dxy</em></span> represents their growth as they eat more and more prey.</p><p>To find the <span class="strong"><strong>equilibrium points</strong></span><a id="id2158" class="indexterm"/> of the system, we need to find the values <span class="emphasis"><em>x, y</em></span> such that <span class="emphasis"><em>dx/dt = dy/dt = 0</em></span>, that is, <span class="emphasis"><em>f(x, y) = g(x, y) = 0</em></span>, so that the variables do not evolve anymore. Here, we were able to obtain analytical values for these equilibrium points with the <code class="literal">solve()</code> function.</p><p>To analyze their stability, we need to perform a linear analysis of the nonlinear equations, by taking the <span class="strong"><strong>Jacobian matrix</strong></span><a id="id2159" class="indexterm"/> at these equilibrium points. This matrix represents the linearized system, and its eigenvalues tell us about the stability of the system near the equilibrium point. The <span class="strong"><strong>Hartman–Grobman theorem</strong></span><a id="id2160" class="indexterm"/> states that the behavior of the original system qualitatively matches the behavior of the linearized system around an equilibrium point if this point is<a id="id2161" class="indexterm"/> <span class="strong"><strong>hyperbolic</strong></span> (meaning that no eigenvalues of the matrix have a real part equal to 0). Here, the first equilibrium point is hyperbolic as <span class="emphasis"><em>a, c &gt; 0</em></span>, but the second is not.</p><p>Here, we were able to compute symbolic expressions for the Jacobian matrix and its eigenvalues at the equilibrium points.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec468"/>There's more...</h2></div></div></div><p>Even when a differential system is not solvable analytically (as is the case here), a mathematical analysis can still give us qualitative information about the behavior of the system's solutions. A purely numerical analysis is not always relevant when we are interested in qualitative results, as numerical errors and approximations can lead to wrong conclusions about the system's behavior.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Matrix documentation in<a id="id2162" class="indexterm"/> SymPy, available at <a class="ulink" href="http://docs.sympy.org/dev/modules/matrices/matrices.html">http://docs.sympy.org/dev/modules/matrices/matrices.html</a></li><li class="listitem" style="list-style-type: disc">Dynamical systems on <a id="id2163" class="indexterm"/>Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Dynamical_system">http://en.wikipedia.org/wiki/Dynamical_system</a></li><li class="listitem" style="list-style-type: disc">Equilibrium points on <a id="id2164" class="indexterm"/>Scholarpedia, at <a class="ulink" href="http://www.scholarpedia.org/article/Equilibrium">www.scholarpedia.org/article/Equilibrium</a></li><li class="listitem" style="list-style-type: disc">Bifurcation theory<a id="id2165" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Bifurcation_theory">http://en.wikipedia.org/wiki/Bifurcation_theory</a></li><li class="listitem" style="list-style-type: disc">Chaos theory<a id="id2166" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Chaos_theory">http://en.wikipedia.org/wiki/Chaos_theory</a></li><li class="listitem" style="list-style-type: disc">Further reading on <a id="id2167" class="indexterm"/>dynamical systems, at <a class="ulink" href="http://en.wikipedia.org/wiki/Dynamical_system#Further_reading">http://en.wikipedia.org/wiki/Dynamical_system#Further_reading</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Getting started with Sage"><div class="titlepage"><div><div><h1 class="title"><a id="ch15lvl1sec126"/>Getting started with Sage</h1></div></div></div><p>Sage (<a class="ulink" href="http://www.sagemath.org">www.sagemath.org</a>) is <a id="id2168" class="indexterm"/>a<a id="id2169" class="indexterm"/> standalone mathematics software based on Python. It is an open source alternative to commercial products such as Mathematica, Maple, or MATLAB. Sage provides a unified interface to many open source mathematical libraries. These libraries include SciPy, SymPy, NetworkX, and other Python scientific packages, but also non-Python libraries such as ATLAS, BLAS, GSL, LAPACK, Singular, and many others.</p><p>In this recipe, we will give a brief introduction to Sage.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec469"/>Getting ready</h2></div></div></div><p>You can either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Install Sage on your<a id="id2170" class="indexterm"/> local computer (<a class="ulink" href="http://www.sagemath.org/doc/installation/">www.sagemath.org/doc/installation/</a>)</li><li class="listitem" style="list-style-type: disc">Create Sage notebooks<a id="id2171" class="indexterm"/> remotely in the cloud (<a class="ulink" href="https://cloud.sagemath.com/">https://cloud.sagemath.com/</a>)</li></ul></div><p>Being based on so many libraries, Sage is heavy and hard to compile from source. Binaries exist for most systems except Windows, where you generally have to use <a id="id2172" class="indexterm"/>VirtualBox (a virtualization solution: <a class="ulink" href="http://www.virtualbox.org">www.virtualbox.org</a>).</p><p>Alternatively, you can use Sage in a browser with an IPython notebook running on the cloud.</p><p>Note that Sage is not compatible with Python 3 at the time of this writing.</p><p>Typically, Sage is used interactively with the built-in notebook (which resembles the IPython notebook). If you want to use Sage in a Python program (that is, importing Sage from Python), you need to run Sage's built-in Python interpreter (<a class="ulink" href="http://www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script">www.sagemath.org/doc/faq/faq-usage.html#how-do-i-import-sage-into-a-python-script</a>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec470"/>How to do it...</h2></div></div></div><p>Here, we will create a new Sage notebook<a id="id2173" class="indexterm"/> and introduce the most basic features:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Sage accepts mathematical expressions as we would expect:<div class="informalexample"><pre class="programlisting">sage: 3*4
12</pre></div></li><li class="listitem">Being based on Python, Sage's syntax is almost Python, but there are a few differences. For example, the power exponent is the more classical <code class="literal">^</code> symbol:<div class="informalexample"><pre class="programlisting">sage: 2^3
8</pre></div></li><li class="listitem">Like in SymPy, symbolic variables need to be declared beforehand with the <code class="literal">var()</code> function. However, the <code class="literal">x</code> variable is always predefined. Here, we define a new mathematical function:<div class="informalexample"><pre class="programlisting">sage: f=1-sin(x)^2</pre></div></li><li class="listitem">Let's simplify the expression of <code class="literal">f</code>:<div class="informalexample"><pre class="programlisting">sage: f.simplify_trig()
cos(x)^2</pre></div></li><li class="listitem">Let's evaluate <code class="literal">f</code> on a given point:<div class="informalexample"><pre class="programlisting">sage: f(x=pi)
1</pre></div></li><li class="listitem">Functions can be differentiated and integrated:<div class="informalexample"><pre class="programlisting">sage: f.diff(x)
-2*cos(x)*sin(x)
sage: f.integrate(x)
1/2*x + 1/4*sin(2*x)</pre></div></li><li class="listitem">Sage also supports numerical computations in addition to symbolic computations:<div class="informalexample"><pre class="programlisting">sage: find_root(f-x, 0, 2)
0.6417143708729723</pre></div></li><li class="listitem">Sage also comes with rich<a id="id2174" class="indexterm"/> plotting capabilities (including interactive plotting widgets):<div class="informalexample"><pre class="programlisting">sage: f.plot((x, -2*pi, 2*pi))</pre></div><div class="mediaobject"><img src="images/4818OS_15_09.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec471"/>There's more...</h2></div></div></div><p>This (too) short recipe cannot do justice to the huge list of possibilities offered by Sage. Many aspects of mathematics are covered: algebra, combinatorics, numerical mathematics, number theory, calculus, geometry, graph theory, and many others. Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An in-depth<a id="id2175" class="indexterm"/> tutorial on Sage, available at <a class="ulink" href="http://www.sagemath.org/doc/tutorial/">www.sagemath.org/doc/tutorial/</a></li><li class="listitem" style="list-style-type: disc">The Sage reference manual, available at <a class="ulink" href="http://www.sagemath.org/doc/reference/">www.sagemath.org/doc/reference/</a></li><li class="listitem" style="list-style-type: disc">Videos on Sage, available at <a id="id2176" class="indexterm"/><a class="ulink" href="http://www.sagemath.org/help-video.html">www.sagemath.org/help-video.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch15lvl2sec472"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Diving into symbolic computing with SymPy</em></span> recipe</li></ul></div></div></div></div>
</body></html>