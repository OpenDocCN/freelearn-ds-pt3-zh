<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using NumPy and Data Structures with pandas</h1>
                </header>
            
            <article>
                
<p>This chapter is one of the most important ones in this book. We will now begin to dive into the nitty-gritty of pandas. We start by taking a tour of NumPy <kbd>ndarrays</kbd>, a data structure not in pandas but NumPy. Knowledge of NumPy <kbd>ndarrays</kbd> is useful as they are the building blocks on which pandas DataFrames have been built. One key benefit of NumPy arrays is that they execute what is known as <em>vectorized</em> operations, which are operations that require traversing/looping on a Python array and are much faster.</p>
<p>In this chapter, I will present the material via numerous examples using Jupyter.</p>
<p>The topics we will cover in this chapter include a tour of the <kbd>numpy.ndarray</kbd> data structure, the <kbd>pandas.Series</kbd> <strong>one-dimensional</strong> (<strong>1D</strong>) pandas data structure, the <kbd>pandas.DataFrame</kbd> <strong>two-dimensional</strong> (<strong>2D</strong>) pandas tabular data structure, and the <kbd>pandas.Panel</kbd> <strong>three-dimensional</strong> (<strong>3D</strong>) pandas data structure.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>NumPy <kbd>ndarrays</kbd></li>
<li>Implementing neural networks with NumPy</li>
<li>Practical applications of multidimensional arrays</li>
<li>Data structures in pandas</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NumPy ndarrays</h1>
                </header>
            
            <article>
                
<p>Arrays are vital objects in the data analysis scenario. Arrays allow for structured handling of elements that are stacked across rows and columns. The elements of an array are bound by the rule that they should all be of the same data type. For example, the medical records of five patients have been presented as an array as follows:</p>
<table style="border-collapse: collapse;width: 1001px;height: 392px" class="table" border="1">
<tbody>
<tr>
<td style="width: 209.258px" class="CDPAlignCenter CDPAlign"/>
<td style="width: 321.758px" class="CDPAlignCenter CDPAlign">
<p><strong>Blood glucose level</strong></p>
</td>
<td style="width: 173.008px" class="CDPAlignCenter CDPAlign">
<p><strong>Heart rate</strong></p>
</td>
<td style="width: 281.758px" class="CDPAlignCenter CDPAlign">
<p><strong>Cholesterol level</strong></p>
</td>
</tr>
<tr>
<td style="width: 209.258px" class="CDPAlignCenter CDPAlign">
<p><strong>Peter Parker</strong></p>
</td>
<td style="width: 321.758px" class="CDPAlignCenter CDPAlign">
<p>100</p>
</td>
<td style="width: 173.008px" class="CDPAlignCenter CDPAlign">
<p>65</p>
</td>
<td style="width: 281.758px" class="CDPAlignCenter CDPAlign">
<p>160</p>
</td>
</tr>
<tr>
<td style="width: 209.258px" class="CDPAlignCenter CDPAlign">
<p><strong>Bruce Wayne</strong></p>
</td>
<td style="width: 321.758px" class="CDPAlignCenter CDPAlign">
<p>150</p>
</td>
<td style="width: 173.008px" class="CDPAlignCenter CDPAlign">
<p>82</p>
</td>
<td style="width: 281.758px" class="CDPAlignCenter CDPAlign">
<p>200</p>
</td>
</tr>
<tr>
<td style="width: 209.258px" class="CDPAlignCenter CDPAlign">
<p><strong>Tony Stark</strong></p>
</td>
<td style="width: 321.758px" class="CDPAlignCenter CDPAlign">
<p>90</p>
</td>
<td style="width: 173.008px" class="CDPAlignCenter CDPAlign">
<p>55</p>
</td>
<td style="width: 281.758px" class="CDPAlignCenter CDPAlign">
<p>80</p>
</td>
</tr>
<tr>
<td style="width: 209.258px" class="CDPAlignCenter CDPAlign">
<p><strong>Barry Allen</strong></p>
</td>
<td style="width: 321.758px" class="CDPAlignCenter CDPAlign">
<p>130</p>
</td>
<td style="width: 173.008px" class="CDPAlignCenter CDPAlign">
<p>73</p>
</td>
<td style="width: 281.758px" class="CDPAlignCenter CDPAlign">
<p>220</p>
</td>
</tr>
<tr>
<td style="width: 209.258px" class="CDPAlignCenter CDPAlign">
<p><strong>Steve Rogers</strong></p>
</td>
<td style="width: 321.758px" class="CDPAlignCenter CDPAlign">
<p>190</p>
</td>
<td style="width: 173.008px" class="CDPAlignCenter CDPAlign">
<p>80</p>
</td>
<td style="width: 281.758px" class="CDPAlignCenter CDPAlign">
<p>150</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>It is seen that all 15 elements are of data type <kbd>int</kbd>. Arrays could also be composed of <kbd>strings</kbd>, <kbd>floats</kbd>, or complex numbers. Arrays could be constructed from lists—a widely used and versatile data structure in Python:</p>
<pre>array_list = [[100, 65, 160],<br/>[150, 82, 200],<br/>[90, 55, 80],<br/>[130, 73, 220],<br/>[190, 80, 150]]</pre>
<p>An element in the <em>i</em><sup>th</sup> row and <em>j</em><sup>th</sup> column (for example, first row and second column in the first example) of an array or matrix can be accessed as shown in the following code. Note that indexing in Python starts from 0:</p>
<pre>In [<strong>2</strong>]: array_list[1][2]<br/>Out[<strong>2</strong>]: 200<br/><br/>In [<strong>3</strong>]: array_list[3][0]<br/>Out[<strong>3</strong>]: 130</pre>
<p>Python has an built-in <kbd>array</kbd> module to create arrays. However, this array module is more like a glorified list where all elements are required to have the same data type. An array can be created using the <kbd>array</kbd> module by providing two arguments—the type code of the data type, and the elements in a list, string, or any iterable object. Let's create an array of floats. Here, <kbd>d</kbd> is the type code for a double-floating point value:</p>
<pre>import array as arr<br/>arr_x = arr.array("d", [98.6, 22.35, 72.1])</pre>
<p>It is not possible to create a two-dimensional entity with rows and columns using the <kbd>array</kbd> module. This can be achieved through a nested list of such arrays. Special functions implicit with matrices or arrays, such as matrix multiplication, determinants, and eigenvalues, are not defined in this module.</p>
<p>NumPy is the preferred package to create and work on array-type objects. NumPy allows multidimensional arrays to be created. Multidimensional arrays provide a systematic and efficient framework for storing data. Complex computations, which are built-in vectorized operations in the NumPy package, can be done quickly on these multidimensional arrays without the need for loops. Consider the earlier example where we created a two-dimensional array to store the medical records of five patients. The patients' names and the clinical indicators were the two dimensions in this case. Now, if the clinical parameters of the same patients were recorded for three years, from 2016 to 2018, then all this information could be conveniently represented in a three-dimensional array. The year in which the records were fetched will get in as the third dimension. The resultant array will be of dimension 3 x 5 x 3, and entirely composed of integers:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign" colspan="3"><strong>2016</strong></td>
<td class="CDPAlignCenter CDPAlign" colspan="3"><strong>2017</strong></td>
<td class="CDPAlignCenter CDPAlign" colspan="3"><strong>2018</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">100</td>
<td class="CDPAlignCenter CDPAlign">65</td>
<td class="CDPAlignCenter CDPAlign">160</td>
<td class="CDPAlignCenter CDPAlign">95</td>
<td class="CDPAlignCenter CDPAlign">68</td>
<td class="CDPAlignCenter CDPAlign">140</td>
<td class="CDPAlignCenter CDPAlign">110</td>
<td class="CDPAlignCenter CDPAlign">72</td>
<td class="CDPAlignCenter CDPAlign">160</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">150</td>
<td class="CDPAlignCenter CDPAlign">82</td>
<td class="CDPAlignCenter CDPAlign">200</td>
<td class="CDPAlignCenter CDPAlign">145</td>
<td class="CDPAlignCenter CDPAlign">80</td>
<td class="CDPAlignCenter CDPAlign">222</td>
<td class="CDPAlignCenter CDPAlign">160</td>
<td class="CDPAlignCenter CDPAlign">95</td>
<td class="CDPAlignCenter CDPAlign">185</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">90</td>
<td class="CDPAlignCenter CDPAlign">55</td>
<td class="CDPAlignCenter CDPAlign">80</td>
<td class="CDPAlignCenter CDPAlign">90</td>
<td class="CDPAlignCenter CDPAlign">62</td>
<td class="CDPAlignCenter CDPAlign">100</td>
<td class="CDPAlignCenter CDPAlign">100</td>
<td class="CDPAlignCenter CDPAlign">80</td>
<td class="CDPAlignCenter CDPAlign">110</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">130</td>
<td class="CDPAlignCenter CDPAlign">73</td>
<td class="CDPAlignCenter CDPAlign">220</td>
<td class="CDPAlignCenter CDPAlign">150</td>
<td class="CDPAlignCenter CDPAlign">92</td>
<td class="CDPAlignCenter CDPAlign">200</td>
<td class="CDPAlignCenter CDPAlign">140</td>
<td class="CDPAlignCenter CDPAlign">92</td>
<td class="CDPAlignCenter CDPAlign">120</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">190</td>
<td class="CDPAlignCenter CDPAlign">80</td>
<td class="CDPAlignCenter CDPAlign">150</td>
<td class="CDPAlignCenter CDPAlign">140</td>
<td class="CDPAlignCenter CDPAlign">60</td>
<td class="CDPAlignCenter CDPAlign">90</td>
<td class="CDPAlignCenter CDPAlign">100</td>
<td class="CDPAlignCenter CDPAlign">55</td>
<td class="CDPAlignCenter CDPAlign">100</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In NumPy, these multidimensional arrays are referred to as <kbd>ndarrays</kbd> (<em>n</em>-dimensional arrays). All NumPy array objects are of the type <kbd>numpy.ndarray</kbd>.</p>
<p>Let's view the preceding data as an <kbd>ndarray</kbd>:</p>
<pre>In [4]: ndarray_1<br/><br/>Out[4]:<br/>array([[[100, 65, 160],<br/>[150, 82, 200],<br/>[ 90, 55, 80],<br/>[130, 73, 220],<br/>[190, 80, 150]],<br/>[[ 95, 68, 140],<br/>[145, 80, 222],<br/>[ 90, 62, 100],<br/>[150, 92, 200],<br/>[140, 60, 90]],<br/>[[110, 72, 160],<br/>[160, 95, 185],<br/>[100, 80, 110],<br/>[140, 92, 120],<br/>[100, 55, 100]]])</pre>
<p>Attributes of an <kbd>ndarray</kbd> such as the data type, shape, number of dimensions, and size can be accessed by different attributes of the array. Some attributes for the <kbd>ndarray</kbd> <kbd>ndarray_1</kbd> have been explored in the following code:</p>
<pre># Data type of the array<br/>In [5]: ndarray_1.dtype<br/>Out[5]: dtype('int32')<br/><br/># Shape of the array<br/>In [6]: ndarray_1.shape<br/>Out[6]: (3, 5, 3)<br/><br/># Number of dimensions in the array<br/>In [7]: ndarray_1.ndim<br/>Out[7]: 3<br/><br/># Size of the array (number of elements in the array)<br/>In [8]: ndarray_1.size<br/>Out[8]: 45</pre>
<p>NumPy's <kbd>ndarray</kbd> makes use of a strided indexing scheme for its internal memory layout. A memory segment by itself can accommodate only one-dimensional structures. Hence, a specific memory allocation scheme such as the strided indexing scheme is needed to facilitate easy indexing and slicing of <kbd>ndarrays</kbd>. A stride indicates the number of bytes to jump to traverse to the subsequent element. The number of bytes for each stride is determined by the data type of the array. Let's understand strides through the array explored earlier. The number of bytes occupied by each element can be determined as shown in the following code:</p>
<pre>In [9]: ndarray_1.itemsize<br/>Out[9]: 4<br/>In [10]: ndarray_1.nbytes<br/>Out[10]: 180</pre>
<p>It is seen that each element occupies 4 bytes, and the entire array occupies 180 bytes. The strides for the array are represented as follows:</p>
<pre>In [11]: ndarray_1.strides<br/>Out[11]: (60, 12, 4)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The shape of the array is given by the tuple (3, 5, 3). The values in the tuple represent the number of years for which there is data, the number of patients, and the number of clinical parameters, respectively. For each year or first dimension, there are 15 records, and hence to move from one year to another in the array, 60 bytes should be jumped across. On a similar note, each distinct patient has 3 records for a given year, and 12 bytes of memory should be moved past to get to the next patient.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NumPy array creation</h1>
                </header>
            
            <article>
                
<p>NumPy arrays can be created in several ways via calls to various NumPy methods. The arrays can be created using the data in lists or any other data structures, by specifying numerical ranges to obtain uniformly spaced values or by generating random samples.</p>
<p>The simplest routine to create an array is through the <kbd>array</kbd> function. This function accepts any sequential object, such as a list or tuple, and converts it to an array. The following code snippet shows how a 1D array can be created through the <kbd>array</kbd> function:</p>
<pre>In [12]: array1d = np.array([1, 2, 3, 4])<br/>In [13]: array1d<br/>Out [13]: array([1, 2, 3, 4])</pre>
<p>Similarly, a multidimensional array can be created by passing a list of lists to the array function:</p>
<pre>In [14]: array2d = np.array([[0, 1, 2],[2, 3, 4]])<br/>In [15]: array2d<br/>Out [15]:<br/>array([[0, 1, 2],<br/>[2, 3, 4]])</pre>
<p>Instead of lists, the same result can be achieved with tuples, a list of tuples, or a tuple of tuples as well.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array of ones and zeros</h1>
                </header>
            
            <article>
                
<p>Several operations on arrays call for the creation of arrays or matrices with ones and zeros. Some special functions in NumPy provide for easy creation of such arrays. Usually, these functions take in the shape of the resultant array as an input argument in the form of a tuple:</p>
<pre># Creating an array of ones with shape (2, 3, 4)<br/>In [27]: np.ones((2, 3, 4))<br/>Out [27]:<br/>array([[[1., 1., 1., 1.],<br/>[1., 1., 1., 1.],<br/>[1., 1., 1., 1.]],<br/>[[1., 1., 1., 1.],<br/>[1., 1., 1., 1.],<br/>[1., 1., 1., 1.]]])<br/><br/># Creating an array of zeros with shape (2, 1, 3)<br/>In [28]: np.zeros((2, 1, 3))<br/>Out [28]:<br/>array([[[0., 0., 0.]],<br/>[[0., 0., 0.]]])</pre>
<p>The identity function returns a 2D <em>n x n</em> square matrix, where <em>n</em> is the order of the matrix passed as an input argument:</p>
<pre>In [29]: np.identity(3)<br/>Out [29]:<br/>array([[1., 0., 0.],<br/>[0., 1., 0.],<br/>[0., 0., 1.]])</pre>
<p class="mce-root">The <kbd>eye</kbd> function can also be used to create an identity matrix. It differs from the identity matrix in two main aspects:</p>
<ul>
<li>The eye function returns a 2D rectangular matrix and accepts both the number of rows and number of columns (optional argument) as the input. If the number of columns is not specified, a square matrix is returned using just the number of rows passed in.</li>
<li>The diagonal can be offset to any position in the upper triangle or lower triangle.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Take a look at the following code:</p>
<pre># Creating an identity matrix of order 3 with the eye function<br/>In [39]: np.eye(N = 3)<br/>Out [39]:<br/>array([[1., 0., 0.],<br/>[0., 1., 0.],[0., 0., 1.]])<br/><br/># Creating a rectangular equivalent of identity matrix with 2 rows and 3 columns<br/>In [40]: np.eye(N = 2, M = 3)<br/>Out [40]:<br/>array([[1., 0., 0.],<br/>[0., 1., 0.]])<br/><br/># Offsetting the diagonal of ones by one position in the upper triangle<br/>In [41]: np.eye(N = 4, M = 3, k = 1)<br/>Out [41]:<br/>array([[0., 1., 0.],<br/>[0., 0., 1.],<br/>[0., 0., 0.],<br/>[0., 0., 0.]])<br/><br/># Offsetting the diagonal of ones by two positions in the lower triangle<br/>In [42]: np.eye(N = 4, M = 3, k = -2)<br/>Out [42]:<br/>array([[0., 0., 0.],<br/>[0., 0., 0.],<br/>[1., 0., 0.],<br/>[0., 1., 0.]])</pre>
<p>By default, <kbd>k</kbd> holds the value 0 in the eye function.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array based on a numerical range</h1>
                </header>
            
            <article>
                
<p>The <kbd>arange</kbd> function of NumPy functionally resembles Python's range function. Based on a start value, stop value, and step value to increment or decrement subsequent values, the <kbd>arange</kbd> function generates a set of numbers. Just like the range function, the start and step arguments are optional here. But unlike range, which generates a list, <kbd>arange</kbd> generates an array:</p>
<pre># Creating an array with continuous values from 0 to 5<br/>In [44]: np.arange(6)<br/>Out [44]: array([0, 1, 2, 3, 4, 5])<br/><br/># Creating an array with numbers from 2 to 12 spaced out at intervals of 3<br/>In [45]: np.arange(2, 13, 3)<br/>Out [45]: array([ 2, 5, 8, 11])</pre>
<p>The <kbd>linspace</kbd> function generates an array of linearly spaced samples for a given start point and end point. Unlike the arrange function, which specifies the incremental/decremental interval, the <kbd>linspace</kbd> function accepts the number of samples to be generated as an optional argument. By default, 50 samples are generated for a given start point and end point:</p>
<pre># Creating a linearly spaced array of 20 samples between 5 and 10<br/>In [47]: np.linspace(start = 5, stop = 10, num = 20)<br/>Out [47]:<br/>array([ 5. , 5.26315789, 5.52631579, 5.78947368, 6.05263158,<br/>6.31578947, 6.57894737, 6.84210526, 7.10526316, 7.36842105,<br/>7.63157895, 7.89473684, 8.15789474, 8.42105263, 8.68421053,<br/>8.94736842, 9.21052632, 9.47368421, 9.73684211, 10. ])</pre>
<p>Similarly, the <kbd>logspace</kbd> and <kbd>geomspace</kbd> functions <span><span>create</span></span> an array of numbers following logarithmic and geometric sequences to be created.</p>
<p>The <kbd>arange</kbd> function and <kbd>linspace</kbd> function do not allow for any shape specification by themselves and produce 1D arrays with the given sequence of numbers. We can very well use some shape manipulation methods to mold these arrays to the desired shape. These methods will be discussed in the last part of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Random and empty arrays</h1>
                </header>
            
            <article>
                
<p>The <kbd>random</kbd> module of the NumPy package packs within it a whole range of functions for random sampling that perform operations right from creating a simple array of random numbers to drawing random samples from distribution functions.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>random.rand</kbd> function generates random values from 0 to 1 (uniform distribution) to create an array of given shape:</p>
<pre># Creating a random array with 2 rows and 4 columns, from a uniform distribution<br/>In [49]: np.random.rand(2, 4)<br/>Out [49]:<br/>array([[0.06573958, 0.32399347, 0.60926818, 0.99319404],<br/>[0.46371691, 0.49197909, 0.93103333, 0.06937098]])</pre>
<p>The <kbd>random.randn</kbd> function samples values from a standard normal distribution to build an array of given shape. If the shape parameter is not specified, a single value is returned as output:</p>
<pre># Creating a 2X4 array from a standard normal distribution<br/>In [50]: np.random.randn(2, 4)<br/>Out [50]:<br/>array([[ 1.29319502, 0.55161748, 0.4660141 , -0.72012401],<br/>[-0.64549002, 0.01922198, 0.04187487, 1.35950566]])<br/><br/># Creating a 2X4 array from a normal distribution with mean 10 and standard deviation 5<br/>In [51]: 5 * np.random.randn(2, 4) + 10<br/>Out [51]:<br/>array([[ 6.08538069, 12.10958845, 15.27372945, 15.9252008 ],<br/>[13.34173712, 18.49388151, 10.19195856, 11.63874627]])</pre>
<p>The <kbd>random.randint</kbd> function generates an array of integers between the specified lower and upper bounds, with the given shape. The limit excludes the upper bound. If the upper bound is not mentioned, it is considered to be 1 more than the lower bound defined:</p>
<pre># Creating an array of shape (2, 3) with random integers chosen from the interval [2, 5)<br/>In [<strong>52</strong>]: np.random.randint(2, 5, (2, 3))<br/>Out [<strong>52</strong>]:<br/>array([[2, 4, 3],<br/>[3, 4, 4]])</pre>
<p>The <kbd>empty</kbd> function returns an array with arbitrary values for the given shape. This array requires no initialization and would perform faster than functions such as zeros and ones where the values have to be initialized. Caution is needed when using this function, and it is to be used only when it is certain that all the values in the array would be filled:</p>
<pre># Creating an uninitialized empty array of 4X3 dimensions<br/>In [58]: np.empty([4,3])<br/>Out [58]:<br/>array([[0., 0., 0.],<br/>[0., 0., 0.],<br/>[1., 0., 0.],<br/>[0., 1., 0.]])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrays based on existing arrays</h1>
                </header>
            
            <article>
                
<p>Some of the NumPy array-creation routines are extremely useful to perform matrix operations such as constructing the <strong>diagonal matrix</strong> (<strong>diag</strong>), the <strong>upper triangular matrix</strong> (<strong>triu</strong>), and the <strong>lower triangular matrix</strong> (<strong>tril</strong>).</p>
<p>The <kbd>diag</kbd> function works only on 1D and 2D arrays. If the input array is 2D, the output is a 1D array with the diagonal elements of the input array. If the input is a 1D array, the output is a matrix with the input array along its diagonal. Here, a parameter k helps to offset the position from the main diagonal and can be positive or negative:</p>
<pre># The 2D input matrix for diag function<br/>In [68]: arr_a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])<br/>In [69]: arr_a<br/>Out [69]:<br/>array([[1, 2, 3],<br/>[4, 5, 6],<br/>[7, 8, 9]])<br/><br/># Getting the diagonal of the array<br/>In [70]: np.diag(arr_a)<br/>Out [70]: array([1, 5, 9])<br/><br/># Constructing the diagonal matrix from a 1D array<br/># diag returns a 1D array of diagonals for a 2D input matrix. This 1D array of diagonals can be used here.<br/>In [71]: np.diag(np.diag(arr_a))<br/>Out [71]:<br/>array([[1, 0, 0],<br/>[0, 5, 0],<br/>[0, 0, 9]])<br/><br/># Creating the diagonal matrix with diagonals other than main diagonal<br/>In [72]: np.diag(np.diag(arr_a, k = 1))<br/>Out [72]:<br/>array([[2, 0],<br/>[0, 6]])</pre>
<p>The <kbd>triu</kbd> and <kbd>tril</kbd> functions have a similar parameter k, which helps offset the diagonal. These functions work with any <kbd>ndarray</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Given an array of <em>n</em> dimensions, a new array can be created by repeating this array multiple times along each axis. This can be done with the <kbd>tile</kbd> function. This function accepts two input arguments—the input array and the number of repetitions:</p>
<pre># Repeating a 1D array 2 times<br/>In [76]: np.tile(np.array([1, 2, 3]), 2)<br/>Out [76]: array([1, 2, 3, 1, 2, 3])<br/><br/># Repeating a 2D array 4 times<br/>In [77]: np.tile(np.array([[1, 2, 3], [4, 5, 6]]), 4)<br/>Out [77]:<br/>array([[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3],<br/>[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]])<br/><br/># Repeating a 2D array 4 times along axis 0 and 1 time along axis 1<br/>In [78]: np.tile(np.array([[1, 2, 3], [4, 5, 6]]), (4,1))<br/>Out [78]:<br/>array([[1, 2, 3],<br/>[4, 5, 6],<br/>[1, 2, 3],<br/>[4, 5, 6],<br/>[1, 2, 3],<br/>[4, 5, 6],<br/>[1, 2, 3],<br/>[4, 5, 6]])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NumPy data types</h1>
                </header>
            
            <article>
                
<p>All the array-creation functions described earlier (except the functions for arrays based on existing arrays—<kbd>diag</kbd>, <kbd>triu</kbd>, <kbd>tril</kbd>, and <kbd>tile</kbd>) have an argument <kbd>dtype</kbd> to define the data type of the array.</p>
<p>Let's create an array without predefining the data type, and then check for its data type:</p>
<pre>In [80]: np.array([-2, -1, 0, 1, 2]).dtype<br/>Out [80]: dtype('int32')</pre>
<p>Now, let's define the same array by also setting its data type to <kbd>float</kbd>:</p>
<pre>In [81]: np.array([-2, -1, 0, 1, 2], dtype = "float")<br/>Out [81]: array([-2., -1., 0., 1., 2.])</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It is seen that the elements of the array are all casted as floating points. It is also possible to cast this array as a string:</p>
<pre>In [83]: np.array([-2, -1, 0, 1, 2], dtype = "str")<br/>Out[83]: array(['-2', '-1', '0', '1', '2'], dtype='&lt;U2'</pre>
<p>In this case, the elements are cast as strings. The output also specifies the data type as <kbd>&lt;U2</kbd>. It indicates that the elements of the array are Unicode strings and the maximum accepted length of string for this array is 2. This threshold on length is decided based on the length of the longest string in the array. Let's understand this with another example:</p>
<pre>In [87]: np.array(["a", "bb", "ccc", "dddd", "eeeee"])<br/>Out[87]: array(['a', 'bb', 'ccc', 'dddd', 'eeeee'], dtype='&lt;U5')</pre>
<p>Such typecasting is observed in arrays with strings, as optimal memory has to be allocated for the array. A single character occupies four bytes. Based on the maximum string length, each element will be allotted a memory block of size equal to four times the maximum string length.</p>
<p>NumPy arrays also support data types such as boolean and complex:</p>
<pre># Boolean array<br/>In [89]: np.array([True, False, True, True]).dtype<br/>Out[89]: dtype('bool')<br/>In [90]: np.array([0, 1, 1, 0, 0], dtype = "bool")<br/>Out[90]: array([False, True, True, False, False])<br/>In [91]: np.array([0, 1, 2, 3, -4], dtype = "bool")<br/>Out[91]: array([False, True, True, True, True])<br/><br/># Complex array<br/>In [92]: np.array([[1 + 1j, 2 + 2j], [3 + 3j, 4 + 4j]])<br/>Out[92]:<br/>array([[1.+1.j, 2.+2.j],<br/>[3.+3.j, 4.+4.j]])<br/>In [93]: np.array([[1 + 1j, 2 + 2j], [3 + 3j, 4 + 4j]]).dtype<br/>Out[93]: dtype('complex128')</pre>
<p>The data type of <kbd>ndarray</kbd> can be changed in much the same way as we cast in other languages such as Java or C/C++. The <kbd>ndarray.astype</kbd> method helps in type conversion:</p>
<pre># Int to float conversion<br/>In [94]: int_array = np.array([0, 1, 2, 3])<br/>In [95]: int_array.astype("float")<br/>Out[95]: array([0., 1., 2., 3.])<br/><br/># Float to int conversion<br/>In [97]: float_array = np.array([1.56, 2.95, 3.12, 4.65])<br/>In [98]: float_array.astype("int")<br/>Out[98]: array([1, 2, 3, 4])</pre>
<div class="packt_infobox">More information on casting can be found in the official documentation at <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html"><span class="URLPACKT">http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NumPy indexing and slicing</h1>
                </header>
            
            <article>
                
<p>Array indices in NumPy start at <kbd>0</kbd> as in languages such as Python, Java, and C++ and unlike in Fortran, Matlab, and Octave, which start at <kbd>1</kbd>. Arrays can be indexed in the standard way as we would index into any other Python sequences:</p>
<pre>    # print entire array, element 0, element 1, last element.
    In [36]: ar = np.arange(5); print ar; ar[0], ar[1], ar[-1]
    [0 1 2 3 4]
    Out[36]: (0, 1, 4)
    # 2nd, last and 1st elements
    In [65]: ar=np.arange(5); ar[1], ar[-1], ar[0]
    Out[65]: (1, 4, 0)</pre>
<p>Arrays can be reversed using the <kbd>::-1</kbd> idiom as follows:</p>
<pre>    In [24]: ar=np.arange(5); ar[::-1]
    Out[24]: array([4, 3, 2, 1, 0])</pre>
<p>Multidimensional arrays are indexed using tuples of integers:</p>
<pre>    In [71]: ar = np.array([[2,3,4],[9,8,7],[11,12,13]]); ar
    Out[71]: array([[ 2,  3,  4],
                    [ 9,  8,  7],
                    [11, 12, 13]])
    In [72]: ar[1,1]
    Out[72]: 8</pre>
<p>Here, we set the entry at <kbd>row1</kbd> and <kbd>column1</kbd> to <kbd>5</kbd>:</p>
<pre>    In [75]: ar[1,1]=5; ar
    Out[75]: array([[ 2,  3,  4],
                    [ 9,  5,  7],
                    [11, 12, 13]])</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Retrieve row 2:</p>
<pre>    In [76]:  ar[2]
    Out[76]: array([11, 12, 13])
    In [77]: ar[2,:]
    Out[77]: array([11, 12, 13])
  </pre>
<p>Retrieve column 1:</p>
<pre>    In [78]: ar[:,1]
    Out[78]: array([ 3,  5, 12])
  </pre>
<p>If an index is specified that is out of bounds of the range of an array, <kbd>IndexError</kbd> will be raised:</p>
<pre>    In [6]: ar = np.array([0,1,2])
    In [7]: ar[5]
       ---------------------------------------------------------------------------
       IndexError                  Traceback (most recent call last)
      &lt;ipython-input-7-8ef7e0800b7a&gt; in &lt;module&gt;()
       ----&gt; 1 ar[5]
          IndexError: index 5 is out of bounds for axis 0 with size 3
  </pre>
<p>Thus, for 2D arrays, the first dimension denotes rows and the second dimension, the columns. The colon (<kbd>:</kbd>) denotes selection across all elements of the dimension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array slicing</h1>
                </header>
            
            <article>
                
<p>Arrays can be sliced using the syntax <kbd>ar[startIndex: endIndex: stepValue]</kbd>:</p>
<pre>    In [82]: ar=2*np.arange(6); ar
    Out[82]: array([ 0,  2,  4,  6,  8, 10])
    In [85]: ar[1:5:2]
    Out[85]: array([2, 6])</pre>
<p>Note that if we wish to include the <kbd>endIndex</kbd> value, we need to go above it, as follows:</p>
<pre>    In [86]: ar[1:6:2]
    Out[86]: array([ 2,  6, 10])  </pre>
<p>Obtain the first <kbd>nelements</kbd> using <kbd>ar[:n]</kbd>:</p>
<pre>    In [91]: ar[:4]
    Out[91]: array([0, 2, 4, 6])  </pre>
<p>The implicit assumption here is that <kbd>startIndex=0, step=1</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Start at element 4 and select all the elements till the end:</p>
<pre>    In [92]: ar[4:]
    Out[92]: array([ 8, 10])  </pre>
<p>Slice array with <kbd>stepValue=3</kbd>:</p>
<pre>    In [94]: ar[::3]
    Out[94]: array([0, 6]) </pre>
<p>To illustrate the scope of indexing in NumPy, let's refer to the following diagram, which is taken from a NumPy lecture given at SciPy 2013 and can be found at <a href="http://scipy-lectures.github.io/_images/numpy_indexing.png"><span class="URLPACKT">http://scipy-lectures.github.io/_images/numpy_indexing.png</span></a>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9378279b-e9f5-4c20-beb3-2a9863c10d54.png" style="width:27.08em;height:15.75em;"/></div>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1">Pictorial illustration of NumPy indexing</span></div>
<p>Let's now examine the meanings of the expressions in the preceding diagram:</p>
<ul>
<li>The expression <kbd>a[0,3:5]</kbd> indicates the start at row 0, columns 3-5, column 5 not included.</li>
<li>In the expression <kbd>a[4:,4:]</kbd>, the first 4 indicates the start at row 4 and will give all columns, that is, the array [[40, 41,42,43,44,45] [50,51,52,53,54,55]]. The second 4 shows the cutoff at the start of column 4 to produce the array [[44, 45], [54, 55]].</li>
<li>The expression <kbd>a[:,2]</kbd> gives all rows from column 2.</li>
<li>Now, in the last expression, <kbd>a[2::2,::2]</kbd>, <kbd>2::2</kbd> indicates that the start is at row 2 and the step value here is also 2. This would give us the array [[20, 21, 22, 23, 24, 25], [40, 41, 42, 43, 44, 45]]. Further, <kbd>::2</kbd> specifies that we retrieve columns in steps of 2, producing the end result array ([[20, 22, 24], [40, 42, 44]]).</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Assignment and slicing can be combined as shown in the following code snippet:</p>
<pre>    In [96]: ar
    Out[96]: array([ 0,  2,  4,  6,  8, 10])
    In [100]: ar[:3]=1; ar
    Out[100]: array([ 1,  1,  1,  6,  8, 10])
    In [110]: ar[2:]=np.ones(4);ar
    Out[110]: array([1, 1, 1, 1, 1, 1])
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array masking</h1>
                </header>
            
            <article>
                
<p>NumPy arrays can be used as filters on the larger original array. This process of using arrays as filters is called <strong>array masking</strong>. For example, see the following snippet:</p>
<pre>    In [146]: np.random.seed(10)
              ar=np.random.random_integers(0,25,10); ar
    Out[146]: array([ 9,  4, 15,  0, 17, 25, 16, 17,  8,  9])
    In [147]: evenMask=(ar % 2==0); evenMask
    Out[147]: array([False,  True, False,  True, False, False,  True, False,  True, False], dtype=bool)
    In [148]: evenNums=ar[evenMask]; evenNums
    Out[148]: array([ 4,  0, 16,  8])</pre>
<p>In the following example, we randomly generate an array of 10 integers between 0 and 25. Then, we create a boolean mask array that is used to filter out only the even numbers. This masking feature can be very useful, say, for example, if we wished to eliminate missing values by replacing them with a default value. Here, the missing value <kbd>''</kbd> is replaced by <kbd>'USA'</kbd> as the default country. Note that <kbd>''</kbd> is also an empty string:</p>
<pre>    In [149]: ar=np.array(['Hungary','Nigeria', 
                           'Guatemala','','Poland',
                           '','Japan']); ar
    Out[149]: array(['Hungary', 'Nigeria', 'Guatemala', 
                     '', 'Poland', '', 'Japan'], 
                     dtype='|S9')
    In [150]: ar[ar=='']='USA'; ar
    Out[150]: array(['Hungary', 'Nigeria', 'Guatemala', 
      'USA', 'Poland', 'USA', 'Japan'], dtype='|S9')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Arrays of integers can also be used to index an array to produce another array. Note that this produces multiple values; hence, the output must be an array of type <kbd>ndarray</kbd>. This is illustrated in the following snippet:</p>
<pre>    In [173]: ar=11*np.arange(0,10); ar
    Out[173]: array([ 0, 11, 22, 33, 44, 55, 66, 77, 88, 99])
    In [174]: ar[[1,3,4,2,7]]
    Out[174]: array([11, 33, 44, 22, 77])</pre>
<p>In the preceding code, the selection object is a list, and elements at indices 1, 3, 4, 2, and 7 are selected. Now, assume that we change it to the following:</p>
<pre>    In [175]: ar[1,3,4,2,7]</pre>
<p>We get an <kbd>IndexError</kbd> error since the array is 1D and we're specifying too many indices to access it:</p>
<pre>    IndexError          Traceback (most recent call last)
    &lt;ipython-input-175-adbcbe3b3cdc&gt; in &lt;module&gt;()
    ----&gt; 1 ar[1,3,4,2,7]
    
    IndexError: too many indices</pre>
<p>This assignment is also possible with array indexing, as follows:</p>
<pre>    In [176]: ar[[1,3]]=50; ar
    Out[176]: array([ 0, 50, 22, 50, 44, 55, 66, 77, 88, 99]) </pre>
<p>When a new array is created from another array by using a list of array indices, the new array has the same shape.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Complex indexing</h1>
                </header>
            
            <article>
                
<p>Here, we illustrate the use of complex indexing to assign values from a smaller array into a larger one:</p>
<pre>    In [188]: ar=np.arange(15); ar
    Out[188]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
    
    In [193]: ar2=np.arange(0,-10,-1)[::-1]; ar2
    Out[193]: array([-9, -8, -7, -6, -5, -4, -3, -2, -1,  0]) </pre>
<p>Slice out the first 10 elements of <kbd>ar</kbd>, and replace them with elements from <kbd>ar2</kbd>, as follows:</p>
<pre>    In [194]: ar[:10]=ar2; ar
    Out[194]: array([-9, -8, -7, -6, -5, -4, -3, -2, -1,  0, 10, 11, 12, 13, 14])  </pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Copies and views</h1>
                </header>
            
            <article>
                
<p>A view on a NumPy array is just a particular way of portraying the data it contains. Creating a view does not result in a new copy of the array, rather the data it contains may be arranged in a specific order, or only certain data rows may be shown. Thus, if data is replaced on the underlying array's data, this will be reflected in the view whenever the data is accessed via indexing.</p>
<p>The initial array is not copied into the memory during slicing and is thus more efficient. The <kbd>np.may_share_memory</kbd> method can be used to see whether two arrays share the same memory block. However, it should be used with caution as it may produce false positives. Modifying a view modifies the original array:</p>
<pre>    In [118]:ar1=np.arange(12); ar1
    Out[118]:array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
    
    In [119]:ar2=ar1[::2]; ar2
    Out[119]: array([ 0,  2,  4,  6,  8, 10])
    
    In [120]: ar2[1]=-1; ar1
    Out[120]: array([ 0,  1, -1,  3,  4,  5,  6,  7,  8,  9, 10, 11])  </pre>
<p>To force NumPy to copy an array, we use the <kbd>np.copy</kbd> function. As we can see in the following array, the original array remains unaffected when the copied array is modified:</p>
<pre>    In [124]: ar=np.arange(8);ar
    Out[124]: array([0, 1, 2, 3, 4, 5, 6, 7])
    
    In [126]: arc=ar[:3].copy(); arc
    Out[126]: array([0, 1, 2])
    
    In [127]: arc[0]=-1; arc
    Out[127]: array([-1,  1,  2])
    
    In [128]: ar
    Out[128]: array([0, 1, 2, 3, 4, 5, 6, 7])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operations</h1>
                </header>
            
            <article>
                
<p>Many methods on NumPy arrays require running mathematical operators such as addition, subtraction, multiplication, division, and so on, on the arrays. The following section deals with explaining how these operators are applied on the arrays.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic operators</h1>
                </header>
            
            <article>
                
<p>NumPy is highly efficient in performance as it works based on vectorized operations, where the need for loops is avoided and the process becomes several times faster. All basic arithmetic operations involving +, -, *, and / take place elementwise and are vectorized:</p>
<pre># Arithmetic operation on arrays with scalars<br/>In [71]: array_1 = np.array([[1, 2, 3], [4, 5, 6]])<br/>In [72]: array_1<br/>Out[72]:<br/>array([[1, 2, 3],<br/>[4, 5, 6]])<br/>In [73]: array_1 + 5<br/>Out[73]:<br/>array([[ 6, 7, 8],<br/>[ 9, 10, 11]])<br/>In [74]: array_1 * 5<br/>Out[74]:<br/>array([[ 5, 10, 15],<br/>[20, 25, 30]])<br/>In [75]: array_1 ** 2<br/>Out[75]:<br/>array([[ 1, 4, 9],<br/>[16, 25, 36]], dtype=int32)</pre>
<p>Operations involving two arrays, such as adding or multiplying two arrays, also takes place in a vectorized manner:</p>
<pre># Element-wise addition of two arrays<br/>In [76]: array_1 + array_1<br/>Out[76]:<br/>array([[ 2, 4, 6],<br/>[ 8, 10, 12]])<br/><br/># Element-wise multiplication of two arrays<br/>In [77]: array_1 * array_1<br/>Out[77]:<br/>array([[ 1, 4, 9],<br/>[16, 25, 36]])<br/><br/># Matrix multiplication of an array and its transpose<br/>In [78]: array_1 @ array_1.T<br/>Out[78]:<br/>array([[14, 32],<br/>[32, 77]])</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Python's <kbd>timeit</kbd> function will give us a sense of how efficient vectorized operations are compared to looping over items:</p>
<pre># Computing the cube of each element in an array, for an array with 1000 elements<br/>In [79]: %timeit np.arange(1000) ** 3<br/>5.05 µs ± 195 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)<br/><br/># Computing the cube of each number from 0 to 1000, using a for loop<br/>In [80]: array_list = range(1000)<br/>...: %timeit [array_list[i]**3 for i in array_list]<br/>533 µs ± 8.06 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</pre>
<p>This shows that <kbd>numpy</kbd> operations are about 100 times faster than for loops.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mathematical operators</h1>
                </header>
            
            <article>
                
<p>The mathematical operators of NumPy can mainly support trigonometric operations, arithmetic operations, and exponential and logarithmic operations.</p>
<p>A class of these operators, such as <kbd>prod</kbd>, <kbd>sum</kbd>, and so on, perform computations within the array and serve to reduce the matrix. For example, the <kbd>sum</kbd> function calculates the sum along a given axis. The output will be the sum of elements along the axis. These functions can be called as a <kbd>numpy.function</kbd> or as an <kbd>ndarray.method</kbd>:</p>
<pre># Sum of all elements in an array<br/>In [62]: np.array([[1, 2, 3], [4, 5, 6]]).sum()<br/>Out[62]: 21<br/><br/># Column sum of elements<br/>In [63]: np.array([[1, 2, 3], [4, 5, 6]]).sum(axis = 0)<br/>Out[63]: array([5, 7, 9])<br/><br/># Cumulative sum of elements along axis 0<br/>In [64]: np.array([[1, 2, 3], [4, 5, 6]]).cumsum(axis = 0)<br/>Out[64]:<br/>array([[1, 2, 3],<br/>[5, 7, 9]], dtype=int32)<br/><br/># Cumulative sum of all elements in the array<br/>In [65]: np.array([[1, 2, 3], [4, 5, 6]]).cumsum()<br/>Out[65]: array([ 1, 3, 6, 10, 15, 21], dtype=int32)</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistical operators</h1>
                </header>
            
            <article>
                
<p>A wide range of statistical operations, such as computing mean, median, variance, and standard deviation, can be calculated for NumPy arrays using the available statistical operators. The aggregates, such as mean, median, variance, and standard deviation, for an entire array can be calculated as shown in the following code:</p>
<pre>In [16]: array_x = np.array([[0, 1, 2], [3, 4, 5]])<br/>In [17]: np.mean(array_x)<br/>Out[17]: 2.5<br/>In [18]: np.median(array_x)<br/>Out[18]: 2.5<br/>In [19]: np.var(array_x)<br/>Out[19]: 2.9166666666666665<br/>In [20]: np.std(array_x)<br/>Out[20]: 1.707825127659933</pre>
<p>By default, these statistical parameters are computed by flattening out the array. To compute the statistical parameters along any of the axes, the <kbd>axis</kbd> argument can be defined when calling these functions. Let's look at this behavior with the <kbd>mean</kbd> function as an example:</p>
<pre>In [27]: np.mean(array_x, axis = 0)<br/>Out[27]: array([1.5, 2.5, 3.5])<br/>In [28]: np.mean(array_x, axis = 1)<br/>Out[28]: array([1., 4.])</pre>
<p>There are special implementations of these functions to handle arrays with missing values or <kbd>NA</kbd>s. These functions are <kbd>nanmean</kbd>, <kbd>nanmedian</kbd>, <kbd>nanstd</kbd>, <kbd>nanvar</kbd>:</p>
<pre>In [30]: nan_array = np.array([[5, 6, np.nan], [19, 3, 2]])<br/><br/># The regular function returns only nan with a warning<br/>In [31]: np.median(nan_array)<br/>C:\Users \Anaconda3\lib\site-packages\numpy\lib\function_base.py:3250: RuntimeWarning: Invalid value encountered in median<br/>r = func(a, **kwargs)<br/>Out[31]: nan<br/>In [32]: np.nanmedian(nan_array)<br/>Out[32]: 5.0</pre>
<p>The <kbd>corrcoeff</kbd> and <kbd>cov</kbd> <span>functions </span>help compute the Pearson's correlation coefficients and the covariance matrix for a given array or two given arrays:</p>
<pre>In [35]: array_corr = np.random.randn(3,4)<br/>In [36]: array_corr<br/>Out[36]:<br/>array([[-2.36657958, -0.43193796, 0.4761051 , -0.11778897],<br/>[ 0.52101041, 1.11562216, 0.61953044, 0.07586606],<br/>[-0.17068701, -0.84382552, 0.86449631, 0.77080463]])<br/>In [37]: np.corrcoef(array_corr)<br/>Out[37]:<br/>array([[ 1. , -0.00394547, 0.48887013],<br/>[-0.00394547, 1. , -0.76641267],<br/>[ 0.48887013, -0.76641267, 1. ]])<br/>In [38]: np.cov(array_corr)<br/>Out[38]:<br/>array([[ 1.51305796, -0.00207053, 0.48931189],<br/>[-0.00207053, 0.18201613, -0.26606154],<br/>[ 0.48931189, -0.26606154, 0.66210821]])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logical operators</h1>
                </header>
            
            <article>
                
<p>The logical operators help compare arrays, check the type and contents of an array, and perform logical comparison between arrays.</p>
<p>The <kbd>all</kbd> and <kbd>any</kbd> <span>functions </span>help to evaluate whether all or any values along the specified axis evaluate to <kbd>True</kbd>. Based on the evaluation result, it returns <kbd>True</kbd> or <kbd>False</kbd>:</p>
<pre>In [39]: array_logical = np.random.randn(3, 4)<br/>In [40]: array_logical<br/>Out[40]:<br/>array([[ 0.79560751, 1.11526762, 1.21139114, -0.36566102],<br/>[ 0.561285 , -1.27640005, 0.28338879, 0.13984101],<br/>[-0.304546 , 1.58540957, 0.1415475 , 1.53267898]])<br/><br/># Check if any value is negative along each dimension in axis 0<br/>In [42]: np.any(array_logical &lt; 0, axis = 0)<br/>Out[42]: array([ True, True, False, True])<br/><br/># Check if all the values are negative in the array<br/>In [43]: np.all(array_logical &lt; 0)<br/>Out[43]: False</pre>
<p>For both the <kbd>all</kbd> and <kbd>any</kbd> methods described previously, <kbd>axis</kbd> is an optional parameter. When it is not provided, the array is flattened and considered for computation.</p>
<p>Some functions test for the presence of <kbd>NAs</kbd> or infinite values in the array. Such functionalities are an essential part of data processing and data cleaning. These functions take in an array or array-like object as input and return the truth value as output:</p>
<pre>In [44]: np.isfinite(np.array([12, np.inf, 3, np.nan]))<br/>Out[44]: array([ True, False, True, False])<br/>In [45]: np.isnan((np.array([12, np.inf, 3, np.nan])))<br/>Out[45]: array([False, False, False, True])<br/>In [46]: np.isinf((np.array([12, np.inf, 3, np.nan])))<br/>Out[46]: array([False, True, False, False])</pre>
<p>Operators such as greater, less, and equal help to perform element-to-element comparison between two arrays of identical shape:</p>
<pre># Creating two random arrays for comparison<br/>In [50]: array1 = np.random.randn(3,4)<br/>In [51]: array2 = np.random.randn(3, 4)<br/>In [52]: array1<br/>Out[52]:<br/>array([[ 0.80394696, 0.67956857, 0.32560135, 0.64933303],<br/>[-1.78808905, 0.73432929, 0.26363089, -1.47596536],<br/>[ 0.00214663, 1.30853759, -0.11930249, 1.41442395]])<br/>In [54]: array2<br/>Out[54]:<br/>array([[ 0.59876194, -0.33230015, -1.68219462, -1.27662143],<br/>[-0.49655572, 0.43650693, -0.34648415, 0.67175793],<br/>[ 0.1837518 , -0.15162542, 0.04520202, 0.58648728]])<br/><br/># Checking for the truth of array1 greater than array2<br/>In [55]: np.greater(array1, array2)<br/>Out[55]:<br/>array([[ True, True, True, True],<br/>[False, True, True, False],<br/>[False, True, False, True]])<br/><br/># Checking for the truth of array1 less than array2<br/>In [56]: np.less(array1, array2)<br/>Out[56]:<br/>array([[False, False, False, False],<br/>[ True, False, False, True],<br/>[ True, False, True, False]])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Broadcasting</h1>
                </header>
            
            <article>
                
<p>Using broadcasting, we can work with arrays that don't have exactly the same shape. Here is an example:</p>
<pre>    In [357]: ar=np.ones([3,2]); ar
    Out[357]: array([[ 1.,  1.],
                     [ 1.,  1.],
                     [ 1.,  1.]])
    
    In [358]: ar2=np.array([2,3]); ar2
    Out[358]: array([2, 3])
    
    In [359]: ar+ar2
    Out[359]: array([[ 3.,  4.],
                     [ 3.,  4.],
                     [ 3.,  4.]])</pre>
<p>Thus, we can see that <kbd>ar2</kbd> is broadcast across the rows of <kbd>ar</kbd> by adding it to each row of <kbd>ar</kbd>, producing the preceding result. Here is another example, showing that broadcasting works across dimensions:</p>
<pre>    In [369]: ar=np.array([[23,24,25]]); ar
    Out[369]: array([[23, 24, 25]])
    In [368]: ar.T
    Out[368]: array([[23],
                     [24],
                     [25]])
    In [370]: ar.T+ar
    Out[370]: array([[46, 47, 48],
                     [47, 48, 49],
                     [48, 49, 50]])</pre>
<p>Here, both row and column arrays were broadcast and we ended up with a 3 × 3 array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array shape manipulation</h1>
                </header>
            
            <article>
                
<p>More often than not, data needs to be transformed before it becomes usable in analysis. The same is true for arrays. NumPy has some special sets of functions that help in reshaping and transforming arrays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reshaping</h1>
                </header>
            
            <article>
                
<p>The <kbd>reshape</kbd> function helps to modify the shape of the array. It accepts two main input arguments—the array to be processed and the expected shape as an integer or tuple of integers.</p>
<p>Previously in this chapter, we saw that <kbd>np.arange</kbd> should rely upon an external function to transform the data from being 1D:</p>
<pre>In [78]: reshape_array = np.arange(0,15)<br/>In [79]: np.reshape(reshape_array, (5, 3))<br/>Out[79]:<br/>array([[ 0, 1, 2],<br/>[ 3, 4, 5],<br/>[ 6, 7, 8],<br/>[ 9, 10, 11],<br/>[12, 13, 14]]</pre>
<p>The <kbd>np.reshape</kbd> function returns a view of the data, meaning the underlying array remains unchanged. In special cases, however, the shape cannot be changed without the data being copied. For more details on this, see the documentation at <a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html">http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transposing</h1>
                </header>
            
            <article>
                
<p>The <kbd>transpose</kbd> function reverses the dimensions of an array:</p>
<pre>In [80]: trans_array = np.arange(0,24).reshape(4, 6)<br/>In [82]: trans_array<br/>Out[82]:<br/>array([[ 0, 1, 2, 3, 4, 5],<br/>[ 6, 7, 8, 9, 10, 11],<br/>[12, 13, 14, 15, 16, 17],<br/>[18, 19, 20, 21, 22, 23]])<br/>In [83]: trans_array.T<br/>Out[83]:<br/>array([[ 0, 6, 12, 18],<br/>[ 1, 7, 13, 19],<br/>[ 2, 8, 14, 20],<br/>[ 3, 9, 15, 21],<br/>[ 4, 10, 16, 22],<br/>[ 5, 11, 17, 23]])</pre>
<p>The following result is obtained on applying <kbd>transpose</kbd> on a multidimensional array:</p>
<pre>In [84]: trans_array = np.arange(0,24).reshape(2, 3, 4)<br/>In [85]: trans_array.T.shape<br/>Out[85]: (4, 3, 2)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ravel</h1>
                </header>
            
            <article>
                
<p>Ravel helps to flatten the data from multidimensional to 1D:</p>
<pre>In [86]: ravel_array = np.arange(0,12).reshape(4, 3)<br/>In [87]: ravel_array.ravel()<br/>Out[87]: array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The order in which the array is raveled can be set. The order can be <kbd>"C"</kbd>, <kbd>"F"</kbd>, <kbd>"A"</kbd>, or <kbd>"K"</kbd>. <kbd>"C"</kbd> is the default order, where the array gets flattened along the row major, while with "F", flattening occurs along the column major. "A" reads the array elements in a Fortran-like index-based order and "K" reads the elements in the order in which they are stored in memory:</p>
<pre>In [88]: ravel_array.ravel(order = "F")<br/>Out[88]: array([ 0, 3, 6, 9, 1, 4, 7, 10, 2, 5, 8, 11])</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a new axis</h1>
                </header>
            
            <article>
                
<p>NumPy has the <kbd>newaxis</kbd> method to add additional axes to the existing array:</p>
<pre># Creating a 1D array with 7 elements<br/>In [98]: array_x = np.array([0, 1, 2, 3, 4, 5, 6])<br/>In [99]: array_x.shape<br/>Out[99]: (7,)<br/><br/># Adding a new axis changes the 1D array to 2D<br/>In [100]: array_x[:, np.newaxis]<br/>Out[100]:<br/>array([[0],<br/>[1],<br/>[2],<br/>[3],<br/>[4],<br/>[5],<br/>[6]])<br/>In [101]: array_x[:, np.newaxis].shape<br/>Out[101]: (7, 1)<br/><br/># Adding 2 new axis to the 1D array to make it 3D<br/>In [102]: array_x[:, np.newaxis, np.newaxis]<br/>Out[102]:<br/>array([[[0]],<br/>[[1]],<br/>[[2]],<br/>[[3]],<br/>[[4]],<br/>[[5]],<br/>[[6]]])<br/>In [103]: array_x[:, np.newaxis, np.newaxis].shape<br/>Out[103]: (7, 1, 1)</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic linear algebra operations</h1>
                </header>
            
            <article>
                
<p>Linear algebra constitutes a set of vital operations for matrices and arrays. The NumPy package is built with a special module called <kbd>linalg</kbd> to deal with all linear algebra requirements. The following segment discusses some frequently used functions of the <kbd>linalg</kbd> module in detail.</p>
<p>The dot function of the <kbd>linalg</kbd> module helps in matrix multiplication. For 2D arrays, it behaves exactly like matrix multiplication. It requires the last dimension of the first array to be equal to the last dimension of the second array. The arrays need not have equal numbers of dimensions. For an  N-dimensional array, the output will have 2N-2 dimensions:</p>
<pre># For 2D arrays<br/>In [23]: array_1 = np.random.randn(2, 4)<br/>In [24]: array_2 = np.random.randn(4, 2)<br/>In [25]: np.dot(array_1, array_2)<br/>Out[25]:<br/>array([[-2.89783151, 5.34861977],<br/>[-0.98078998, -3.47603638]])<br/><br/># For N dimensional arrays<br/>In [37]: array_1 = np.random.randn(2, 4, 2)<br/>In [38]: array_2 = np.random.randn(1, 1, 2, 1)<br/>In [39]: np.dot(array_1, array_2).shape<br/>Out[39]: (2, 4, 1, 1, 1)</pre>
<p>The <kbd>linalg.multidot</kbd> function can help in computing the product of several arrays at once, instead of using a nested sequence of dot functions. This function automatically finds the most efficient order for evaluating the sequence of products.</p>
<p>The <kbd>linalg.svd</kbd> function helps in singular value decomposition and returns three arrays as the result of decomposition. It accepts an array with two or more dimensions as the input:</p>
<pre>In [42]: array_svd = np.random.randn(4, 3)<br/>In [43]: np.linalg.svd(array_svd)<br/>Out[43]:<br/>(array([[-0.31366226, 0.27266983, 0.17962633, -0.89162858],<br/>[ 0.72860587, 0.51810374, 0.44793275, -0.00763141],<br/>[-0.59309456, 0.61499855, 0.26103908, 0.44930416],<br/>[-0.13779807, -0.52820115, 0.83603183, 0.05537156]]),<br/>array([1.68668514, 0.91044852, 0.65293131]),<br/>array([[ 0.43322222, 0.10710679, 0.89490035],<br/>[-0.73052453, 0.62326903, 0.27905131],<br/>[-0.52787538, -0.77463789, 0.34825813]]))</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Eigenvalues and eigenvectors of an array can be calculated with the <kbd>linalg.eig</kbd> function. The <kbd>eig</kbd> function requires the last two dimensions of the input array to be a square. The same function returns both the eigenvalues and the eigenvectors:</p>
<pre>In [50]: np.linalg.eig(np.random.randn(5, 5))<br/>Out[50]:<br/>(array([ 2.52146488+0.j , -2.80191144+0.j ,<br/>0.57756977+0.j , -0.65032217+1.22149327j,<br/>-0.65032217-1.22149327j]),<br/>array([[-0.85628289+0.j , -0.04688595+0.j ,<br/>-0.71887813+0.j , -0.51046122-0.03158232j,<br/>-0.51046122+0.03158232j],<br/>[ 0.15793025+0.j , 0.7517844 +0.j ,<br/>0.45393309+0.j , 0.52887467+0.j ,<br/>0.52887467-0.j ],<br/>[-0.35226803+0.j , 0.33640372+0.j ,<br/>0.51482125+0.j , 0.40554944-0.02802925j,<br/>0.40554944+0.02802925j],<br/>[ 0.08722806+0.j , -0.07904384+0.j ,<br/>-0.03872718+0.j , -0.41252898+0.16212983j,<br/>-0.41252898-0.16212983j],<br/>[ 0.33186767+0.j , 0.55964858+0.j ,<br/>0.10304501+0.j , 0.14346541-0.27643973j,<br/>0.14346541+0.27643973j]]))</pre>
<p>The <kbd>linalg</kbd> module also has functions to solve linear equations. The <kbd>linalg.solve</kbd> function takes in a coefficient matrix and the dependent variable, and solves for the exact solution. It requires that all rows of the coefficient matrix must be linearly independent:</p>
<pre>In [51]: a = np.array([[1, 2, 3], [5, 4, 2], [8, 9, 7]])<br/>In [52]: b = np.array([6, 19, 47])<br/>In [53]: np.linalg.solve(a, b)<br/>Out[53]: array([-6.27272727, 15.81818182, -6.45454545])</pre>
<p>If the best possible solution is needed instead of the exact solution, the least-squares solution could be obtained from the <kbd>linalg.lstsq</kbd> function.</p>
<p>The <kbd>linalg.det</kbd> function computes the determinant of a square array. If there are more than two dimensions in the input array, it is treated as a stack of matrices and the determinant is computed for each stack. The last two dimensions must, however, correspond to a square matrix:</p>
<pre>In [55]: np.linalg.det(np.random.randn(3,3))<br/>Out[55]: -0.08292700167707867<br/>In [56]: np.linalg.det(np.random.randn(2,3,3))<br/>Out[56]: array([-0.22575897, 1.47647984])</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Array sorting</h1>
                </header>
            
            <article>
                
<p>Arrays can be sorted in various ways:</p>
<ol>
<li>Sorting the array along an axis; first, let's discuss this along the <em>y</em> axis:</li>
</ol>
<pre>    In [43]: ar=np.array([[3,2],[10,-1]])
                 ar
    Out[43]: array([[ 3,  2],
                    [10, -1]])
    In [44]: ar.sort(axis=1)
                 ar
    Out[44]: array([[ 2,  3],
                    [-1, 10]])</pre>
<ol start="2">
<li>Here, we will explain the sorting along the <em>x</em> axis:</li>
</ol>
<pre>    In [45]: ar=np.array([[3,2],[10,-1]])
                 ar
    Out[45]: array([[ 3,  2],
                    [10, -1]])
    In [46]: ar.sort(axis=0)
                 ar
    Out[46]: array([[ 3, -1],
                    [10,  2]])  </pre>
<ol start="3">
<li>Sorting by in-place (<kbd>np.array.sort</kbd>) and out-of-place (<kbd>np.sort</kbd>) functions.</li>
<li>Other operations that are available for array sorting include the following:</li>
</ol>
<ul>
<li><kbd>np.min()</kbd>: This returns the minimum element in the array</li>
<li><kbd>np.max()</kbd>: <span>This</span> returns the maximum element in the array</li>
<li><kbd>np.std()</kbd>: <span>This </span>returns the standard deviation of the elements in the array</li>
<li><kbd>np.var()</kbd>: <span>This </span>returns the variance of elements in the array</li>
<li><kbd>np.argmin()</kbd>: <span>This </span>returns indices of minimum value in the array</li>
<li><kbd>np.argmax()</kbd>: <span>This </span>returns indices of maximum value in the array</li>
<li><kbd>np.all()</kbd>: <span>This </span>returns elementwise logical 'and' of all the elements</li>
<li><kbd>np.any()</kbd>: <span>This </span>returns elementwise logical 'or' of all the elements</li>
</ul>
<p>Up to now, we have been getting acquainted with the functionalities of NumPy. In the coming sections, we will look at two practical examples where NumPy arrays are widely used for performing complex computations. After that, we will move on to delving deeper into the core data structures of pandas, such as DataFrames, Series, and Panels—how they are created, modified, and used.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing neural networks with NumPy</h1>
                </header>
            
            <article>
                
<p>While NumPy is definitely not the go-to package for training a neural network in real-time scenarios, learning to implement it in NumPy brings out the flexibility and might of NumPy for doing complex matrix computations and also provides a better understanding of neural networks.</p>
<p>First, let's synthetically generate a dataset for a binary classification problem that will be used for training the neural network. The data will be from two different Gaussian distributions, and the model will be trained to classify this data into either of the two categories. Let's generate the data with 1,000 samples in each category:</p>
<pre>N = 1000<br/>X1 = np.random.randn(N, 2) + np.array([0.9, 0.9])<br/>X2 = np.random.randn(N, 2) + np.array([-0.9, -0.9])</pre>
<p>Now we have two 1000 x 2 arrays. For the predictor variable, we can use the <kbd>zeros</kbd> and <kbd>ones</kbd> functions to create two different 1D arrays:</p>
<pre>Y1 = np.zeros((N, 1))<br/>Y2 = np.ones((N, 1))</pre>
<p>The four arrays—X1, X2, Y1, and Y2—must be stacked together to create the complete training set with dimensions 2000 x 3:</p>
<pre>X = np.vstack((X1, X2))<br/>Y = np.vstack((Y1, Y2))<br/>train = np.hstack((X, Y))</pre>
<p>Our aim is to build a simple neural network with one hidden layer and three neurons. For a moment, let's move away from NumPy to understand the architecture of the neural network we will be building from scratch.</p>
<p>The following is a schematic diagram of a simple neural network architecture:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a0cca604-4775-4916-ab4c-485a67f061ae.png" style="width:32.67em;height:29.50em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1"> Schematic diagram of a simple neural network architecture</span></div>
<p>There are two neurons in the input layer, three neurons in the hidden layer, and a single output neuron. The squares represent the bias. To implement the neural network, the independent variables and predictor have been stored in <kbd>x</kbd> and <kbd>t</kbd>:</p>
<pre>x = train[:, 0:2]<br/>t = train[:, 2].reshape(2000, 1)</pre>
<p>As this is a binary classification problem, a sigmoid function would be an ideal choice for the activation function:</p>
<pre>def sigmoid(x, derive = False):<br/>if (derive == True):<br/>    return x * (1 - x)<br/>    return 1 / (1 + np.exp(-x))</pre>
<p>The preceding function does the sigmoid transformation and also derivative computation (for backpropagation). The process of training consists of two modes of propagation—feedforward and backpropagation.</p>
<p>The first stage of feedforward is from the input layer to the hidden layer. This stage can be summarized with the following set of equations:</p>
<p class="CDPAlignCenter CDPAlign"><em>ah1 = sigmoid(x1*w_ih11 + x2*w_ih21 + 1* b_ih1)</em></p>
<p class="CDPAlignCenter CDPAlign"><em>ah2 = sigmoid(x1*w_ih12 + x2*w_ih22 + 1*b_ih2)</em></p>
<p class="CDPAlignCenter CDPAlign"><em>ah3 = sigmoid(x1*w_ih13 + x2*w_ih23 + 1*b_ih3)</em></p>
<p>Here, <kbd>ah1</kbd>, <kbd>ah2</kbd>, and <kbd>ah3</kbd> are inputs to the next stage of the feedforward network, from the hidden layer to the output. This involves multiplying the input matrix of dimensions 2000 x 2 and weight matrix <kbd>w_ih</kbd> of dimensions 2 x 3 (three hidden neurons, hence 3), and then adding the bias. Instead of handling the bias components separately, they could be handled as part of the weight matrix. This can be done by adding a unit column vector to the input matrix and inserting the bias values as the last row of the weight matrix. Hence, the new dimensions of the input matrix and weight matrix would be 2000 x 3 and 3 x 3:</p>
<pre>x_in = np.concatenate([x, np.repeat([[1]], 2000, axis = 0)], axis = 1)<br/>w_ih = np.random.normal(size = (3, 3))</pre>
<p>The weight matrix is initialized with random values:</p>
<pre>y_h = np.dot(x_in, w_ih)<br/>a_h = sigmoid(y_h)</pre>
<p>Here, <kbd><em>a_h</em></kbd> is the input matrix for the second stage of feedforward. Just as in the case of input matrix <em>x, <kbd>a_h</kbd></em> should be appended with unit column vectors for the bias and the second weight matrix should be initialized:</p>
<pre>a_hin = np.concatenate([a_h, np.repeat([[1]], 2000, axis = 0)], axis = 1)<br/>w_ho = np.random.normal(size = (4, 1)</pre>
<p>Now the matrix multiplication and sigmoid transformation can be done for this stage:</p>
<pre>y_o = np.dot(a_hin, w_ho)<br/>a_o = sigmoid(y_o)</pre>
<p>For simplicity's sake, let's use mean squared error as the loss function, though it would be more appropriate to use a log loss function for a classification problem:</p>
<p class="CDPAlignCenter CDPAlign">E = ((1 / 2) * (np.power((a_o - t), 2)))</p>
<p>This marks the end of feedforward and the beginning of backpropagation. Backpropagation aims to find the delta or difference to be made to the weights and biases for the error <em>E</em> to reduce. The entire process of backpropagation can be summarized in the following two equations.</p>
<p>The first one calculates the change in loss function <em>E</em> w.r.t <em>w_ho</em> and the second one calculates the change in loss function <em>E</em> w.r.t <em>w_ih:</em></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/770f0a28-dc2c-4cdf-a2ee-d97502b222af.png" style="width:15.83em;height:4.08em;"/></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43af660e-3839-4454-b051-0f6acec1f14e.png" style="width:15.83em;height:4.33em;"/></p>
<p>Now, the implementation of these equations in NumPy is as simple as computing all the derivatives necessary and finding the corresponding products:</p>
<pre># Output layer<br/>delta_a_o_error = a_o - t<br/>delta_y_o = sigmoid(a_o, derive=True)<br/>delta_w_ho = a_hin<br/>delta_output_layer = np.dot(delta_w_ho.T,(delta_a_o_error * delta_y_o))<br/><br/># Hidden layer<br/>delta_a_h = np.dot(delta_a_o_error * delta_y_o, w_ho[0:3,:].T)<br/>delta_y_h = sigmoid(a_h, derive=True)<br/>delta_w_ih = x_in<br/>delta_hidden_layer = np.dot(delta_w_ih.T, delta_a_h * delta_y_h)</pre>
<p>The change to be made to the weight has been computed. Let's use these delta values to update the weights:</p>
<pre>eta = 0.1<br/>w_ih = w_ih - eta * delta_hidden_layer<br/>w_ho = w_ho - eta * delta_output_layer</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here, <kbd><em>eta</em></kbd> is the learning rate of the model. Feedforward will take place again using the updated weights. Backpropagation will again follow to reduce the error. Hence, feedforward and backpropagation should take place iteratively for a set number of epochs. The complete code is as follows:</p>
<pre>### Neural Network with one hidden layer with feedforward and backpropagation<br/>x = train[:,0:2]<br/>t = train[:,2].reshape(2000,1)<br/>x_in = np.concatenate([x, np.repeat([[1]], 2000, axis = 0)], axis = 1)<br/>w_ih = np.random.normal(size = (3, 3))<br/>w_ho = np.random.normal(size = (4, 1))<br/>def sigmoid(x, derive = False):<br/>if (derive == True):<br/>return x * (1 - x)<br/>return 1 / (1 + np.exp(-x))<br/>epochs = 5000<br/>eta = 0.1<br/><br/>for epoch in range(epochs)<span>:</span><br/># Feed forward<br/>    y_h = np.dot(x_in, w_ih)<br/>    a_h = sigmoid(y_h)<br/>    a_hin = np.concatenate([a_h, np.repeat([[1]], 2000, axis = 0)],     axis = 1)<br/>    y_o = np.dot(a_hin, w_ho)<br/>    a_o = sigmoid(y_o)<br/><br/>    # Calculate the error<br/>    a_o_error = ((1 / 2) * (np.power((a_o - t), 2)))<br/><br/>    # Backpropagation<br/>    ## Output layer<br/>    delta_a_o_error = a_o - t<br/>    delta_y_o = sigmoid(a_o, derive=True)<br/>    delta_w_ho = a_hin<br/>    delta_output_layer = np.dot(delta_w_ho.T,(delta_a_o_error * delta_y_o))<br/><br/>    ## Hidden layer<br/>    delta_a_h = np.dot(delta_a_o_error * delta_y_o, w_ho[0:3,:].T)<br/>    delta_y_h = sigmoid(a_h, derive=True)<br/>    delta_w_ih = x_in<br/>    delta_hidden_layer = np.dot(delta_w_ih.T, delta_a_h * delta_y_h)<br/>    w_ih = w_ih - eta * delta_hidden_layer<br/>    w_ho = w_ho - eta * delta_output_layer<br/>    print(a_o_error.mean())</pre>
<p class="mce-root"/>
<p>The neural network has been implemented for 5,000 epochs. This is a simple yet efficient model quite suitable for a range of problems. Good accuracy can be obtained by choosing the right epoch, learning rate, loss function, and activation function. To test and validate, make use of just the feedforward module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practical applications of multidimensional arrays</h1>
                </header>
            
            <article>
                
<p>Panel data (spreadsheet-like data with several distinguishable rows and columns; the kind of data we generally encounter) is best handled by the DataFrame data structure available in pandas and R. Arrays can be used too but it would be tedious.</p>
<p>So what is a good example of data in real life that can be best represented by an array? Images, which are generally represented as multidimensional arrays of pixels, are a good example. In this section, we will see examples of multidimensional representation of an image and why it makes sense.</p>
<p>Any object detection or image-processing algorithm performed on an image requires it to be represented in a numerical array format. For text data, term-document matrix and <strong>term frequency-inverse document frequency</strong> (<strong>TF-IDF</strong>) are used to vectorize (create numerical arrays) the data. In the case of an image, pixel values are used to represent an image.</p>
<p>For a 100 x 50 pixel RGB image, there would be the following:</p>
<ul>
<li>5,000 pixel values in one channel</li>
<li>Three channels each for red, blue, and green</li>
</ul>
<p>Hence, if you flatten the image pixels as one single vector, its length would be 15,000 (5,000 for each of the three channels). A grayscale image would contain a single channel. Each pixel value represents the degree of brightness for each channel.</p>
<p>A dataset of multiple images then becomes four-dimensional data representing the following:</p>
<ul>
<li>Width of the image in pixels</li>
<li>Height of the image in pixels</li>
<li>Number of channels</li>
<li>Serial number of the image</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's verify the shape of the resultant image pixel arrays by reading an image. To work with images, a Python package called <strong>opencv</strong> (<kbd>cv2</kbd>) is quite helpful:</p>
<pre># reading images using opencv package<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import os<br/>os.chdir('')<br/>img=cv2.imread('view.jpg')<br/>img2=cv2.imread('rose.jpg')</pre>
<p>The <kbd>imread</kbd> method returns an array of pixels. Let's check the object type of the returned object <kbd>img</kbd>:</p>
<pre>print(type(img))</pre>
<p class="mce-root">This returns <kbd>&lt;class 'numpy.ndarray'&gt;</kbd>, which confirms that it returns a <kbd>numpy</kbd> array.</p>
<p class="mce-root">Next, let's have a look at the shape of the array. It should return us the pixel width, pixel height, and number of channels:</p>
<pre>img.shape</pre>
<p class="mce-root">This returns (183, 275, 3).</p>
<p class="mce-root">It is a tuple of three numbers representing image height in pixels, image width in pixels, and number of channels. Hence, this image has a height of 183 pixels, a width of 275 pixels, and three channels of the dimension 183 x 275 representing red, blue, and green.</p>
<p class="mce-root">The <kbd>img</kbd> object looks as follows on printing:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/45a81f61-f7c1-4478-ac6c-1ea05abccf92.png" style="width:16.25em;height:38.83em;"/></p>
<div class="p1 CDPAlignCenter CDPAlign packt_figref"><span class="s1">Image pixels as a multidimensional array</span></div>
<p class="mce-root">Now the question arises, why would someone want to subset an array of image pixels? There can be multiple reasons for that:</p>
<ul>
<li>Selecting and/or manipulating a region of interest in the image. This can be a small block of the image representing an object.</li>
<li>Selecting only one color channel from the image.</li>
</ul>
<p class="mce-root">The array of pixels can be seen as a plot/image with pixel height and pixel width as the axes labels as shown in the following code:</p>
<pre>plt.imshow(img) </pre>
<p>Take a look at the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cc06a144-45ed-47fa-8a48-76a246519643.png" style="width:18.67em;height:13.17em;"/></p>
<div class="p1 packt_figref CDPAlignCenter CDPAlign"><span class="s1"><span class="Apple-converted-space">                </span> Image pixel arrays plotted as an image</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting only one channel</h1>
                </header>
            
            <article>
                
<p class="mce-root">As we saw earlier, the third dimension denotes the RGB channel. Hence, to filter all the pixels in one channel, we should select all the pixels in the first two dimensions and only the channel of interest. Also, the indexing in Python starts from 0, thus 0 represents red, 1 represents green, and 2 represents blue. Keeping these in mind, let's have a look at the snippets to select the red, green, and blue channels of an image.</p>
<p>The snippet to select the red is as follows:</p>
<pre>img_r=img[:,:,0]<br/>plt.imshow(img_r)    </pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6f214d64-224b-44ed-bff5-98cae2c4add8.png" style="width:20.08em;height:14.25em;"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Image pixel array made of selecting only pixels in the red channel visualized as an image</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>The snippet to select the green is as follows:</span></p>
<pre>img_g=img[:,:,1]<br/>plt.imshow(img_g)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/a5a6e4c2-393f-4a3d-9a0b-ff4dfc11077f.png" style="width:23.83em;height:16.00em;"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Image pixel array made of selecting only pixels in the green channel visualized as an image</div>
<p><span>The snippet to select the blue is as follows:</span></p>
<pre>img_b=img[:,:,2]<br/>plt.imshow(img_b)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"> <img src="assets/013cbf29-7d82-4c16-91c8-bdfccc7e6c14.png" style="width:23.50em;height:16.58em;"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Image pixel array made of selecting only pixels in the blue channel visualized as an image</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting the region of interest of an image</h1>
                </header>
            
            <article>
                
<p>Let's try to select the tree in the preceding screenshot. Looking at the image with axis labels, it is evident that vertical bounds of the tree are within 50 to 155 pixels while horizontal bounds are within 95 to 190 pixels. Let's try to subset this region with all the channels:</p>
<pre>img_tree=img[50:155,95:190,:]<br/>plt.imshow(img_tree)</pre>
<p>The following image shows us the <strong>region of interest</strong> (<strong>ROI</strong>) that is selected therein:</p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref"><strong><img src="assets/f8bd95c3-e4a9-4ed7-b0b2-bea749b34226.png"/></strong></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Selecting an ROI in an image</div>
<p class="mce-root">This operation is akin to cropping an image.</p>
<p class="mce-root">The pixel values of a certain ROI or a channel can be assigned some different values. This can be used to do the following:</p>
<ul>
<li>Remove certain channels (if we replace the values in that channel with 0)</li>
<li>Copy and paste a certain ROI to another part of the image</li>
</ul>
<p class="mce-root">The following code shows an example of the latter case:</p>
<pre>img3=img<br/>img3[50:155,1:96,:]=img_tree<br/>plt.imshow(img3)    </pre>
<p>The following image shows the selected ROI that is being pasted to another image area:</p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><strong><img src="assets/025d5551-131f-4e3d-9de8-04017e15976b.png"/></strong></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Pasting a selected ROI to another image area</div>
<p class="mce-root">In this example, we have copied the tree ROI and pasted it to an area to the left of the selected ROI. This has been obtained by assigning the pixels of the pasting destination values equal to the pixel value of the copy source.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple channel selection and suppressing other channels</h1>
                </header>
            
            <article>
                
<p class="mce-root">To show pixels of only a certain color, the pixels of other colors need to be suppressed or assigned a value of 0. The channel selection can happen via indexing or by passing a list:</p>
<ul>
<li class="mce-root"><strong>Indexing</strong>: Keep in mind that, while indexing, the value to the right of the colon represents the higher limit of the channel. It also counts up to <em>n</em>-1. For example, <kbd>img[:,:,1:3]</kbd> will select channels up to channel 2, namely blue, starting from channel 1, namely green, but not channel 0, namely red. The snippet  <kbd>img[:,:,0:2]</kbd> will select channel 0 (red channel) and channel 1 (green) but not channel 2 (blue).</li>
<li class="mce-root"><strong>List</strong>: A list such as [0,2] would mean selecting channels 0 and 2, namely red and blue.</li>
</ul>
<p class="mce-root">In the following example, we suppress the non-red, non-green, and non-blue pixels so that the resultant pixels appear red, green, and blue respectively:</p>
<pre>fig, axes = plt.subplots(1, 3)<br/><br/># Red Channel<br/>imgR = img.copy()<br/>imgR[:, :, 1:3] = 0 # Assigning Green and Blue channel pixels to 0<br/>axes[0].imshow(imgR)<br/><br/># Green Channel<br/>imgG = img.copy()<br/>imgG[:, :, [0,2]] = 0 # Assigning Red and Blue channel pixels to 0<br/>axes[1].imshow(imgG)<br/><br/># Blue Channel<br/>imgB = img.copy()<br/>imgB[:, :, 0:2] = 0 0 # Assigning Red and Green channel pixels to 0<br/>axes[2].imshow(imgB)</pre>
<p>The following is the output:</p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign"><strong><img src="assets/94ffe739-2eab-45c1-b5eb-5b45fe244548.png" style="width:30.00em;height:8.08em;"/></strong></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Panel showing image obtained by suppressing the two channels so that it shows only the third color (green and blue, red and blue, and red and green respectively are suppressed in the three images from left to right)</div>
<p class="mce-root">Audio data can also be represented as arrays of pressure readings across a horizontal distance. Similar array manipulation techniques can be used there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data structures in pandas</h1>
                </header>
            
            <article>
                
<p>The pandas package was created by Wes McKinney in 2008 as a result of frustrations he encountered while working on time series data in R. It is built on top of NumPy and provides features not available in it. It provides fast, easy-to-understand data structures and helps fill the gap between Python and a language like R. NumPy deals with homogeneous blocks of data. Using pandas helps to deal with data in a tabular structure composed of different data types.</p>
<p><span>The official documentation for pandas can be found at</span><span> </span><a href="http://pandas.pydata.org/pandas-docs/stable/dsintro.html">http://pandas.pydata.org/pandas-docs/stable/dsintro.html</a><span>.</span></p>
<p>There are three main data structures in pandas:</p>
<ul>
<li>Series—1D</li>
<li>DataFrame—2D</li>
<li>Panel—3D</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Series</h1>
                </header>
            
            <article>
                
<p>A Series is really a 1D NumPy array under the hood. It consists of a NumPy array coupled with an array of labels. Just like a NumPy array, a series can be wholly composed of any data type. The labels are together called the index of the series. A series consists of two components—1D data and the index.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Series creation</h1>
                </header>
            
            <article>
                
<p>The general construct for creating a series data structure is as follows:</p>
<pre>import pandas as pd<br/>ser = pd.Series(data, index = idx)</pre>
<p>Here, data can be one of the following:</p>
<ul>
<li>An <kbd>ndarray</kbd></li>
<li>A Python dictionary</li>
<li>A scalar value</li>
</ul>
<p class="mce-root">If an index is not specified, the following default index [0,... n-1] will be created, where n is the length of the data.</p>
<p class="mce-root">A series can be created from a variety of sources as shown in the following subsections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using an ndarray</h1>
                </header>
            
            <article>
                
<p>In this case, the index must be the same length as the data. The following example creates a Series structure of seven random numbers between 0 and 1; the index is not specified:</p>
<pre>In [4]: ser = pd.Series(np.random.randn(7))<br/>In [5]: ser<br/>Out[5]:<br/>0 3.063921<br/>1 0.097450<br/>2 -1.660367<br/>3 -1.221308<br/>4 -0.948873<br/>5 0.454462<br/>6 0.586824<br/>dtype: float64</pre>
<p>An index can also be string objects. The following example creates a Series structure of the first five months of the year with a specified index of month names:</p>
<pre>In [6]: import calendar as cal<br/>In [7]: monthNames=[cal.month_name[i] for i in np.arange(1,6)]<br/>In [8]: months = pd.Series(np.arange(1,6), index = monthNames)<br/>In [10]: months<br/>Out[10]:<br/>January 1<br/>February 2<br/>March 3<br/>April 4<br/>May 5<br/>dtype: int32<br/>In [11]: months.index<br/>Out[11]: Index(['January', 'February', 'March', 'April', 'May'], dtype='object')</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a Python dictionary</h1>
                </header>
            
            <article>
                
<p>A dictionary consists of key-value pairs. When a dictionary is used to create a Series, the keys form the index, and the values form the 1D data of the Series:</p>
<pre>In [12]: currDict={'US' : 'dollar', 'UK' : 'pound', 'Germany': 'euro', 'Mexico':'peso', 'Nigeria':'naira', 'China':'yuan', 'Japan':'yen'}<br/>In [13]: currSeries = pd.Series(currDict)<br/>In [14]: currSeries<br/>Out[14]:<br/>US dollar<br/>UK pound<br/>Germany euro<br/>Mexico peso<br/>Nigeria naira<br/>China yuan<br/>Japan yen<br/>dtype: object</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The index of a pandas Series structure is of type <kbd>pandas.core.index.Index</kbd> and can be viewed as an ordered multiset.</p>
<p>If an index is also specified when creating the Series, then this specified index setting overrides the dictionary keys. If the specified index contains values that are not keys in the original dictionary, <kbd>NaN</kbd> is appended against that index in the Series:</p>
<pre>In [18]: stockPrices = {'GOOG':1180.97, 'FB':62.57, 'TWTR': 64.50, 'AMZN':358.69, 'AAPL':500.6}<br/># "YHOO" is not a key in the above dictionary<br/>In [19]: stockPriceSeries = pd.Series(stockPrices, index=['GOOG','FB','YHOO','TWTR','AMZN','AAPL'], name='stockPrices')<br/>In [20]: stockPriceSeries<br/>Out[20]:<br/>GOOG 1180.97<br/>FB 62.57<br/>YHOO NaN<br/>TWTR 64.50<br/>AMZN 358.69<br/>AAPL 500.60<br/>Name: stockPrices, dtype: float64</pre>
<p>Note that a Series also has a name attribute that can be set as shown in the preceding snippet. The name attribute is useful in tasks such as combining Series objects into a DataFrame structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a scalar value</h1>
                </header>
            
            <article>
                
<p>A Series can also be initialized with just a scalar value. For scalar data, an index must be provided. The value will be repeated for as many index values as possible. One possible use of this method is to provide a quick and dirty method of initialization, with the Series structure to be filled in later. Let's see how to create a Series using scalar values:</p>
<pre>In [21]: dogSeries=pd.Series('chihuahua', index=['breed', 'countryOfOrigin', 'name', 'gender'])<br/>In [22]: dogSeries = pd.Series('chihuahua', index=['breed', 'countryOfOrigin', 'name', 'gender'])<br/>In [23]: dogSeries<br/>Out[23]:<br/>breed chihuahua<br/>countryOfOrigin chihuahua<br/>name chihuahua<br/>gender chihuahua<br/>dtype: object</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operations on Series</h1>
                </header>
            
            <article>
                
<p>The behavior of a Series is very similar to that of NumPy arrays, discussed previously in this chapter, with one caveat being that an operation such as slicing also slices the index of the series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assignment</h1>
                </header>
            
            <article>
                
<p>Values can be set and accessed using the index label in a dictionary-like manner:</p>
<pre># Accessing value from series using index label<br/>In [26]: currDict['China']<br/>Out[26]: 'yuan'<br/><br/># Assigning value to series through a new index label<br/>In [27]: stockPriceSeries['GOOG'] = 1200.0<br/>In [28]: stockPriceSeries<br/>Out[28]:<br/>GOOG 1200.00<br/>FB 62.57<br/>YHOO NaN<br/>TWTR 64.50<br/>AMZN 358.69<br/>AAPL 500.60<br/>Name: stockPrices, dtype: float64</pre>
<p>Just as in the case of <kbd>dict</kbd>, <kbd>KeyError</kbd> is raised if you try to retrieve a missing label:</p>
<pre>In [29]: stockPriceSeries['MSFT']<br/>KeyError: 'MSFT'</pre>
<p>This error can be avoided by explicitly using <kbd>get</kbd> as follows:</p>
<pre>In [30]: stockPriceSeries.get('MSFT, np.NaN)<br/>Out[30]: nan</pre>
<p>In this case, the default value of <kbd>np.NaN</kbd> is specified as the value to return when the key does not exist in the Series structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Slicing</h1>
                </header>
            
            <article>
                
<p>The slice operation behaves the same way as a NumPy array. Slicing can be done using the index numbers as shown in the following code:</p>
<pre># Slice till the 4th index (0 to 3)<br/>In [31]: stockPriceSeries[:4]<br/>Out[31]:<br/>GOOG 1200.00<br/>FB 62.57<br/>YHOO NaN<br/>TWTR 64.50<br/>Name: stockPrices, dtype: float64<br/>Logical slicing also works as follows:<br/>In [32]: stockPriceSeries[stockPriceSeries &gt; 100]<br/>Out[32]:<br/>GOOG 1200.00<br/>AMZN 358.69<br/>AAPL 500.60<br/>Name: stockPrices, dtype: float64</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other operations</h1>
                </header>
            
            <article>
                
<p>Arithmetic and statistical operations can be applied, just like for a NumPy array. Such operations take place in a vectorized mode in a Series, just as in NumPy arrays, and do not require to be looped through:</p>
<pre># Mean of entire series<br/>In [34]: np.mean(stockPriceSeries)<br/>Out[34]: 437.27200000000005<br/><br/># Standard deviation of entire series<br/>In [35]: np.std(stockPriceSeries)<br/>Out[35]: 417.4446361087899</pre>
<p>Elementwise operations can also be performed on a Series:</p>
<pre>In [36]: ser<br/>Out[36]:<br/>0 3.063921<br/>1 0.097450<br/>2 -1.660367<br/>3 -1.221308<br/>4 -0.948873<br/>5 0.454462<br/>6 0.586824<br/>dtype: float64<br/><br/>In [37]: ser * ser<br/>Out[37]:<br/>0 9.387611<br/>1 0.009496<br/>2 2.756819<br/>3 1.491593<br/>4 0.900359<br/>5 0.206535<br/>6 0.344362<br/>dtype: float64</pre>
<p>An important feature of a Series is that data is automatically aligned based on the label:</p>
<pre>In [40]: ser[1:]<br/>Out[40]:<br/>1 0.097450<br/>2 -1.660367<br/>3 -1.221308<br/>4 -0.948873<br/>5 0.454462<br/>6 0.586824<br/>dtype: float64<br/>In [41]: ser[1:] + ser[:-2]<br/>Out[41]:<br/>0 NaN<br/>1 0.194899<br/>2 -3.320734<br/>3 -2.442616<br/>4 -1.897745<br/>5 NaN<br/>6 NaN<br/>dtype: float64</pre>
<p>Thus, we can see that for non-matching labels, NaN is inserted. The default behavior is that the union of the indexes is produced for unaligned Series structures. This is preferable as information is preserved rather than lost. We will handle missing values in pandas in a later chapter of the book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DataFrames</h1>
                </header>
            
            <article>
                
<p>A DataFrame is a two-dimensional data structure composed of rows and columns—exactly like a simple spreadsheet or a SQL table. Each column of a DataFrame is a pandas Series. These columns should be of the same length, but they can be of different data types—float, int, bool, and so on. DataFrames are both value-mutable and size-mutable. This lets us perform operations that would alter values held within the DataFrame or add/delete columns to/from the DataFrame.</p>
<p class="mce-root"/>
<p>Similar to a Series, which has a name and index as attributes, a DataFrame has column names and a row index. The row index can be made of either numerical values or strings such as month names. Indexes are needed for fast lookups as well as proper aligning and joining of data in pandas multilevel indexing is also possible in DataFrames. The following is a simple view of a DataFrame with five rows and three columns. In general, the index is not counted as a column:</p>
<table style="border-collapse: collapse;width: 838px;height: 392px" class="table" border="1">
<tbody>
<tr>
<td style="width: 134.688px" class="CDPAlignCenter CDPAlign">
<p><strong>Index</strong></p>
</td>
<td style="width: 133.576px" class="CDPAlignCenter CDPAlign">
<p><strong>Event type</strong></p>
</td>
<td style="width: 186.91px" class="CDPAlignCenter CDPAlign">
<p><strong>Total attendees</strong></p>
</td>
<td style="width: 369.132px" class="CDPAlignCenter CDPAlign">
<p><strong>Percentage of student participants</strong></p>
</td>
</tr>
<tr>
<td style="width: 134.688px" class="CDPAlignCenter CDPAlign">
<p>Monday</p>
</td>
<td style="width: 133.576px" class="CDPAlignCenter CDPAlign">
<p>C</p>
</td>
<td style="width: 186.91px" class="CDPAlignCenter CDPAlign">
<p>42</p>
</td>
<td style="width: 369.132px" class="CDPAlignCenter CDPAlign">
<p>23.56%</p>
</td>
</tr>
<tr>
<td style="width: 134.688px" class="CDPAlignCenter CDPAlign">
<p>Tuesday</p>
</td>
<td style="width: 133.576px" class="CDPAlignCenter CDPAlign">
<p>B</p>
</td>
<td style="width: 186.91px" class="CDPAlignCenter CDPAlign">
<p>58</p>
</td>
<td style="width: 369.132px" class="CDPAlignCenter CDPAlign">
<p>12.89%</p>
</td>
</tr>
<tr>
<td style="width: 134.688px" class="CDPAlignCenter CDPAlign">
<p>Wednesday</p>
</td>
<td style="width: 133.576px" class="CDPAlignCenter CDPAlign">
<p>A</p>
</td>
<td style="width: 186.91px" class="CDPAlignCenter CDPAlign">
<p>27</p>
</td>
<td style="width: 369.132px" class="CDPAlignCenter CDPAlign">
<p>45.90%</p>
</td>
</tr>
<tr>
<td style="width: 134.688px" class="CDPAlignCenter CDPAlign">
<p>Thursday</p>
</td>
<td style="width: 133.576px" class="CDPAlignCenter CDPAlign">
<p>A</p>
</td>
<td style="width: 186.91px" class="CDPAlignCenter CDPAlign">
<p>78</p>
</td>
<td style="width: 369.132px" class="CDPAlignCenter CDPAlign">
<p>47.89%</p>
</td>
</tr>
<tr>
<td style="width: 134.688px" class="CDPAlignCenter CDPAlign">
<p>Friday</p>
</td>
<td style="width: 133.576px" class="CDPAlignCenter CDPAlign">
<p>B</p>
</td>
<td style="width: 186.91px" class="CDPAlignCenter CDPAlign">
<p>92</p>
</td>
<td style="width: 369.132px" class="CDPAlignCenter CDPAlign">
<p>63.25%</p>
</td>
</tr>
</tbody>
</table>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DataFrame creation</h1>
                </header>
            
            <article>
                
<p>A DataFrame is the most commonly used data structure in pandas. The constructor accepts many different types of arguments:</p>
<ul>
<li>Dictionary of 1D ndarrays, lists, dictionaries, or Series structures</li>
<li>2D NumPy array</li>
<li>Structured or record ndarray</li>
<li>Series</li>
<li>Another DataFrame</li>
</ul>
<p>Row label indexes and column labels can be specified along with the data. If they're not specified, they will be generated from the input data in an intuitive fashion, for example, from the keys of <kbd>dict </kbd>(in the case of column labels) or by using <kbd>np.range(n)</kbd> in the case of row labels, where n corresponds to the number of rows.</p>
<p>A DataFrame can be created from a variety of sources as discussed in the following subsections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a dictionary of Series</h1>
                </header>
            
            <article>
                
<p>Each individual entity of a dictionary is a key-value pair. A DataFrame is, in essence, a dictionary of several Series put together. The name of the Series corresponds to the key, and the contents of the Series correspond to the value.</p>
<p>As the first step, the dictionary with all the Series should be defined:</p>
<pre>stockSummaries = {<br/>'AMZN': pd.Series([346.15,0.59,459,0.52,589.8,158.88],<br/>index=['Closing price','EPS',<br/>'Shares Outstanding(M)',<br/>'Beta', 'P/E','Market Cap(B)']),<br/>'GOOG': pd.Series([1133.43,36.05,335.83,0.87,31.44,380.64],<br/>index=['Closing price','EPS','Shares Outstanding(M)',<br/>'Beta','P/E','Market Cap(B)']),<br/>'FB': pd.Series([61.48,0.59,2450,104.93,150.92],<br/>index=['Closing price','EPS','Shares Outstanding(M)',<br/>'P/E', 'Market Cap(B)']),<br/>'YHOO': pd.Series([34.90,1.27,1010,27.48,0.66,35.36],<br/>index=['Closing price','EPS','Shares Outstanding(M)',<br/>'P/E','Beta', 'Market Cap(B)']),<br/>'TWTR':pd.Series([65.25,-0.3,555.2,36.23],<br/>index=['Closing price','EPS','Shares Outstanding(M)',<br/>'Market Cap(B)']),<br/>'AAPL':pd.Series([501.53,40.32,892.45,12.44,447.59,0.84],<br/>index=['Closing price','EPS','Shares Outstanding(M)','P/E',<br/>'Market Cap(B)','Beta'])}</pre>
<p>The preceding dictionary summarizes the performance of six different stocks and indicates that the DataFrame will have six columns. Observe that each series has a different set of indices and is of different length. The final DataFrame will contain a unique set of the values in each of the indices. If a certain column has no value at a row index, NA is appended to that cell automatically. Now, the following step wraps up this dictionary into a DataFrame:</p>
<pre>stockDF = pd.DataFrame(stockSummaries)</pre>
<p>Let's print the DataFrame created in the preceding step:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/75b068ce-dd4c-4fbc-8730-dbd82b9d04ef.png" style="width:33.08em;height:15.67em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The DataFrame need not necessarily have all the row and column labels from the original dictionary. At times, only a subset of these rows and columns may be needed. In such cases, the row and column indices can be restricted as shown in the following code:</p>
<pre>stockDF = pd.DataFrame(stockSummaries,<br/>index=['Closing price','EPS',<br/>'Shares Outstanding(M)',<br/>'P/E', 'Market Cap(B)','Beta'],<br/>columns=['FB','TWTR','SCNW'])</pre>
<p>Here, a new column name, <kbd>SCNW</kbd>, which is not found in the original dictionary, has been added. This will result in a column named <kbd>SCNW</kbd> with NAs throughout. Similarly, manually passing an index name that is absent in the original data structure will result in a row with NAs throughout.</p>
<p>Let's print the preceding DataFrame:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/be7e57c0-7726-44fc-a1f3-7bc1ada20582.png" style="width:21.83em;height:14.17em;"/></p>
<p>The row index and column names can be accessed as attributes of the DataFrame:</p>
<pre>In [47]: stockDF.index<br/>Out[47]:<br/>Index(['Closing price', 'EPS', 'Shares Outstanding(M)', 'P/E', 'Market Cap(B)',<br/>'Beta'],<br/>dtype='object')<br/>In [48]: stockDF.columns<br/>Out[48]: Index(['FB', 'TWTR', 'SCNW'], dtype='object')</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a dictionary of ndarrays/lists</h1>
                </header>
            
            <article>
                
<p>In the preceding example, the dictionary consisted of Series as the values in the key-value pair. It is possible to construct a DataFrame with a dictionary of lists instead of a dictionary of Series. Unlike the previous case, the row index will not be defined anywhere in the dictionary. Hence, the row label indices are generated using <kbd>np.range(n)</kbd>. Therefore, it is crucial in this case for all lists or arrays in the dictionary to be of equal length. If this condition is not met, an error occurs.</p>
<p class="mce-root">The dictionary of lists is defined in the following code:</p>
<pre>algos = {'search': ['DFS','BFS','Binary Search',<br/>'Linear','ShortestPath (Djikstra)'],<br/>'sorting': ['Quicksort','Mergesort', 'Heapsort',<br/>'Bubble Sort', 'Insertion Sort'],<br/>'machine learning': ['RandomForest', 'K Nearest Neighbor',<br/>'Logistic Regression', ''K-Means Clustering', 'Linear Regression']}</pre>
<p class="mce-root">Now, let's convert this dictionary to a DataFrame and print it:</p>
<pre class="mce-root">algoDF = pd.DataFrame(algos)</pre>
<p>Take a look at the following output:</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/f67edac0-e7b9-4f08-ab12-ea05caed53c2.png"/></p>
<p class="mce-root">Here, the row indices are assigned continuous values from 0 to 4. The row indices can also be given custom values as shown in the following code:</p>
<pre class="mce-root">pd.DataFrame(algos,index=['algo_1','algo_2','algo_3','algo_4','algo_5'])</pre>
<p><span>Ta</span><span>ke a look at the following output:</span></p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e909303f-7d27-436b-940b-f289abe522b1.png" style="width:27.17em;height:12.50em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a structured array</h1>
                </header>
            
            <article>
                
<p class="mce-root">Structured arrays are slightly different from <kbd>ndarrays</kbd>. Each field in a structured array can be of a different data type. For more information on structured arrays, refer to the following: <a href="http://docs.scipy.org/doc/numpy/user/basics.rec.html">http://docs.scipy.org/doc/numpy/user/basics.rec.html</a>.</p>
<p class="mce-root">The following is an example of a structured array:</p>
<pre class="mce-root">memberData = np.array([('Sanjeev',37,162.4),<br/>('Yingluck',45,137.8),<br/>('Emeka',28,153.2),<br/>('Amy',67,101.3)],<br/>dtype = [('Name','a15'),<br/>('Age','i4'),<br/>('Weight','f4')])</pre>
<p>This structured array has three fields for which the data types have been defined in a list of tuples along with the field names. The same <kbd>DataFrame</kbd> function can be used to construct a <kbd>DataFrame</kbd> function from a structured array:</p>
<pre>memberDF = pd.DataFrame(memberData)</pre>
<p><span>Ta</span><span>ke a look at the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/04cfbbba-25af-42b0-aa79-dd12c9cfc324.png" style="width:15.92em;height:11.00em;"/></p>
<p>By default, continuous range of integral values have been assigned to the index. It is possible to replace the indices:</p>
<pre>pd.DataFrame(memberData, index=['a','b','c','d'])</pre>
<p>Take a look at the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/62929fa6-eafd-47b1-97bb-50beb6077f22.png"/></p>
<p>The columns can be reordered through the <kbd>columns</kbd> argument of the <kbd>DataFrame</kbd> function:</p>
<pre>pd.DataFrame(memberData, columns = ["Weight", "Name", "Age"])</pre>
<p><span>Ta</span><span>ke a look at the following output:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/897d3b35-4b88-4f87-bc43-e9017f76aa77.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a list of dictionaries</h1>
                </header>
            
            <article>
                
<p>When a list of dictionaries is converted to a DataFrame, each dictionary in the list corresponds to a row in the DataFrame and each key in each dictionary represents a column label.</p>
<p>Let's define a list of dictionaries:</p>
<pre>demographicData = [{"Age": 32, "Gender": "Male"}, {"Race": "Hispanic", "Gender": "Female", "Age": 26}]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now the list of dictionaries can be converted to a DataFrame as shown in the following code:</p>
<pre>demographicDF = pd.DataFrame(demographicData)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d5e285f8-1c32-4def-973e-5917bf985ade.png" style="width:12.92em;height:6.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a dictionary of tuples for multilevel indexing</h1>
                </header>
            
            <article>
                
<p>A dictionary of tuples can create a structured DataFrame with hierarchically indexed rows and columns. The following is a dictionary of tuples:</p>
<pre>salesData = {("2012", "Q1"): {("North", "Brand A"): 100, ("North", "Brand B"): 80, ("South", "Brand A"): 25, ("South", "Brand B"): 40},<br/>("2012", "Q2"): {("North", "Brand A"): 30, ("South", "Brand B"): 50},<br/>("2013", "Q1"): {("North", "Brand A"): 80, ("North", "Brand B"): 10, ("South", "Brand B"): 25},<br/>("2013", "Q2"): {("North", "Brand A"): 70, ("North", "Brand B"): 50, ("South", "Brand A"): 35, ("South", "Brand B"): 40}}</pre>
<p>Instead of a regular key-value pair, the key is a tuple with two values denoting two levels in the row index, and the value is a dictionary in which each key-value pair represents a column. Here, again, the key is a tuple and denotes two column indices.</p>
<p>Now this dictionary of tuples can be converted to a DataFrame and printed:</p>
<pre>salesDF = pd.DataFrame(salesData)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0fcaf4d8-6a68-4568-af64-20f6518a0490.png" style="width:16.50em;height:11.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a Series</h1>
                </header>
            
            <article>
                
<p>Consider the following series:</p>
<pre>In [12]: currDict={'US' : 'dollar', 'UK' : 'pound', 'Germany': 'euro', 'Mexico':'peso', 'Nigeria':'naira', 'China':'yuan', 'Japan':'yen'}<br/>In [13]: currSeries = pd.Series(currDict)<br/>Out[13]:<br/>US dollar<br/>UK pound<br/>Germany euro<br/>Mexico peso<br/>Nigeria naira<br/>China yuan<br/>Japan yen<br/>Name: Currency, dtype: object</pre>
<p>Here, the series has a defined index and name. When being converted to a DataFrame, this index is retained and the name of the Series gets assigned as a column name:</p>
<pre>currDF = pd.DataFrame(currSeries)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/88556948-0368-4e92-bc4c-afd428c9e8cb.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are also alternative constructors for DataFrames; they can be summarized as follows:</p>
<ul>
<li><kbd>DataFrame.from_dict</kbd>: It takes a dictionary of dictionaries or sequences and returns a DataFrame. It slightly differs from the method discussed earlier due to an argument to specify order. While the other method always converts keys of dictionaries to columns, this constructor provides an option to convert the keys to row labels:</li>
</ul>
<pre style="padding-left: 60px"># Default setting<br/>pd.DataFrame.from_dict(algos, orient = "columns")</pre>
<p style="padding-left: 60px">The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/44774fca-917d-4b5d-91cc-55dcad8f314f.png" style="width:28.00em;height:13.50em;"/></p>
<p style="padding-left: 60px">Another method to do this is as follows:</p>
<pre style="padding-left: 60px">pd.DataFrame.from_dict(algos, orient = "index", columns = ["A", "B", "C", "D", "E"])</pre>
<p style="padding-left: 60px">The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6d87ba0c-a32e-4482-b1b1-c3c4a801b5db.jpg" style="width:49.25em;height:8.75em;"/></p>
<ul>
<li><kbd>DataFrame.from_records</kbd>: It takes a list of tuples or structured <kbd>ndarray</kbd> to construct a DataFrame. Unlike the method mentioned earlier for structured arrays, this function allows you to set one of the fields of the array as an index:</li>
</ul>
<pre style="padding-left: 60px">pd.DataFrame.from_records(memberData, index="Name")</pre>
<p style="padding-left: 60px">The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/862ba2b3-6ad0-40c3-9d68-64533ecc0ebf.png" style="width:15.50em;height:13.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operations on pandas DataFrames</h1>
                </header>
            
            <article>
                
<p>Many operations, such as column/row indexing, assignment, concatenation, deletion, and so on, can be performed on DataFrames. Let's have a look at them in the following subsections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Column selection</h1>
                </header>
            
            <article>
                
<p>A specific column can be selected out from the DataFrame, as a Series, using the column name:</p>
<pre>In [60]: memberDF["Name"]<br/>Out[60]:<br/>0 b'Sanjeev'<br/>1 b'Yingluck'<br/>2 b'Emeka'<br/>3 b'Amy'<br/>Name: Name, dtype: object</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a new column</h1>
                </header>
            
            <article>
                
<p>A new column can be added to a DataFrame by inserting a scalar value into it. Inserting a scalar value into any column of a DataFrame will cause the entire column to be filled with that scalar value:</p>
<pre>In [61]: memberDF['Height'] = 60<br/>In [62]: memberDF</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a9775ac3-2544-48f0-98e4-d7459e807914.png" style="width:18.83em;height:10.25em;"/></p>
<p>Instead of a scalar value, a list of values can also be assigned:</p>
<pre>In [63]: memberDF['Height2'] = [57, 62, 65, 59]<br/>In [64]: memberDF</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d8a27ac-4a7f-4241-ad93-4d4c3dd15f91.png" style="width:21.17em;height:9.58em;"/></p>
<p>A column can also be inserted at the desired position using the <kbd>insert</kbd> method. This needs three arguments: the position in which the column is to be inserted, the new column name, and the values to be passed:</p>
<pre>In [65]: memberDF.insert(1, "ID", ["S01", "S02", "S03", "S04"])<br/>In [66]: memberDF</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c12d5e49-5608-4fe6-abc6-a42ed2d8d50d.png" style="width:24.25em;height:10.25em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting columns</h1>
                </header>
            
            <article>
                
<p>The <kbd>del</kbd> command can be used to delete a single column as shown in the following code:</p>
<pre>In [67]: del memberDF["Height"]<br/>In [68]: memberDF</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/93bc40ad-3ded-4965-aea4-b12b2a964b20.png"/></p>
<p>Instead of <kbd>del</kbd>, the <kbd>pop</kbd> method can be used, just like in dictionaries:</p>
<pre>In [65]: height2 = memberDF.pop("Height2")<br/>In [66]: memberDF</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5764f486-de04-440e-b92a-fe73153e01cc.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Alignment of DataFrames</h1>
                </header>
            
            <article>
                
<p>The union of two DataFrames occurs based on row and column indices. Let's understand this through an example. Consider two DataFrames:</p>
<pre>ore1DF=pd.DataFrame(np.array([[20,35,25,20],<br/>[11,28,32,29]]),<br/>columns=['iron','magnesium',<br/>'copper','silver'])<br/>ore2DF=pd.DataFrame(np.array([[14,34,26,26],<br/>[33,19,25,23]]),<br/>columns=['iron','magnesium',<br/>'gold','silver'])</pre>
<p>The <kbd>+</kbd> operator will add values in columns with the same labels in both DataFrames:</p>
<pre>ore1DF + ore2DF</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5ed89cb6-bbf1-4131-bce3-5c0990bbc714.png"/></p>
<p>The columns—copper and gold—were not found in both the DataFrames. Hence, NA has been appended in these columns.</p>
<p>If you combine a DataFrame object and a Series object, the default behavior is to broadcast the Series object across the rows:</p>
<pre>ore1DF + pd.Series([25,25,25,25], index=['iron', 'magnesium', 'copper', 'silver'])</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9100505a-c637-416d-8434-922c244e322a.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other mathematical operations</h1>
                </header>
            
            <article>
                
<p>The basic mathematical operators work on DataFrames. For example, a new column can be obtained as a result of adding, multiplying, subtracting, or dividing two columns:</p>
<pre>In [<strong>67</strong>]: ore1DF["add_iron_copper"] = ore1DF["iron"] + ore1DF["copper"]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c9b9d76-9d01-43da-92c9-f9c047be69c2.png"/></p>
<p>Logical operators such as  | (or), &amp; (and), and ^ (not) work on DataFrames. Consider the following two DataFrames:</p>
<pre>logical_df1 = pd.DataFrame({'Col1' : [1, 0, 1], 'Col2' : [0, 1, 1] }, dtype=bool)<br/>logical_df2 = pd.DataFrame({'Col1' : [1, 0, 0], 'Col2' : [0, 0, 1] }, dtype=bool)</pre>
<p>Now, performing the logical or between these two columns yields the following result:</p>
<pre>logical_df1 | logical_df2</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/098e3a86-cc56-41db-bb50-9e90d0da18be.png"/></p>
<p>Operations can also be performed on DataFrames using the NumPy functions:</p>
<pre>np.sqrt(ore1DF)</pre>
<p>The following is the output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e57fe462-6e84-436c-8639-dc231cb61d40.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Panels</h1>
                </header>
            
            <article>
                
<p>A Panel is a 3D array. It is not as widely used as Series or DataFrames. It is not as easily displayed on screen or visualized as the other two because of its 3D nature. The Panel data structure is the final piece of the data structure puzzle in pandas. It is less widely used. It is generally used for 3D time-series data. The three axis names are as follows:</p>
<ul>
<li><kbd>items</kbd>: This is axis 0. Each item corresponds to a DataFrame structure. </li>
<li><kbd>major_axis</kbd>: This is axis 1. Each item corresponds to the rows of the DataFrame structure.</li>
<li><kbd>minor_axis</kbd>: This is axis 2. Each item corresponds to the columns of each DataFrame structure.</li>
</ul>
<p>Panels are deprecated and will not be available in future versions. Hence, it's advisable to use multi-indexing in DataFrames instead of Panels.</p>
<p>As with Series and DataFrames, there are different ways to create Panel objects. They are explained in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a 3D NumPy array with axis labels</h1>
                </header>
            
            <article>
                
<p>Here, we show how to construct a Panel object from a 3D NumPy array. After defining the 3D array, a panel could be created by defining each of the three axes:</p>
<pre>In [68]: stockData = np.array([[[63.03,61.48,75],<br/>[62.05,62.75,46],<br/>[62.74,62.19,53]],<br/>[[411.90, 404.38, 2.9],<br/>[405.45, 405.91, 2.6],<br/>[403.15, 404.42, 2.4]]])<br/>In [69]: stockHistoricalPrices = pd.Panel(stockData,<br/>items=['FB', 'NFLX'], major_axis=pd.date_range('2/3/2014', periods=3),<br/>minor_axis=['open price', 'closing price', 'volume'])<br/>In [70]: stockHistoricalPrices<br/>Out[70]:<br/>&lt;class 'pandas.core.panel.Panel'&gt;<br/>Dimensions: 2 (items) x 3 (major_axis) x 3 (minor_axis)<br/>Items axis: FB to NFLX<br/>Major_axis axis: 2014-02-03 00:00:00 to 2014-02-05 00:00:00<br/>Minor_axis axis: open price to volume</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a Python dictionary of DataFrame objects</h1>
                </header>
            
            <article>
                
<p>A panel consists of several DataFrames. To create a panel, let's define two DataFrames:</p>
<pre>USData = pd.DataFrame(np.array([[249.62 , 8900],<br/>[ 282.16,12680],<br/>[309.35,14940]]),<br/>columns=['Population(M)','GDP($B)'],<br/>index=[1990,2000,2010])<br/>ChinaData = pd.DataFrame(np.array([[1133.68, 390.28],<br/>[ 1266.83,1198.48],<br/>[1339.72, 6988.47]]),<br/>columns=['Population(M)','GDP($B)'],<br/>index=[1990,2000,2010])</pre>
<p>Now, a dictionary of these DataFrames can be created:</p>
<pre>In [<strong>73</strong>]: US_ChinaData={'US' : USData, 'China': ChinaData}<br/>In [<strong>74</strong>]: pd.Panel(US_ChinaData)<br/>Out[<strong>74</strong>]:<br/>&lt;class 'pandas.core.panel.Panel'&gt;<br/>Dimensions: 2 (items) x 3 (major_axis) x 2 (minor_axis)<br/>Items axis: US to China<br/>Major_axis axis: 1990 to 2010<br/>Minor_axis axis: Population(M) to GDP($B)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the DataFrame.to_panel method</h1>
                </header>
            
            <article>
                
<p>A multi-indexed DataFrame is comparable to a Panel. Hence, a multi-indexed DataFrame can be directly converted to a Panel:</p>
<pre>In [75]: mIdx = pd.MultiIndex(levels = [['US', 'China'], [1990,2000, 2010]], labels=[[1,1,1,0,0,0],[0,1,2,0,1,2]])<br/>In [76]: ChinaUSDF = pd.DataFrame({'Population(M)' : [1133.68, 1266.83, 1339.72, 249.62, 282.16, 309.35], GDB($B)': [390.28, 1198.48, 6988.47, 8900, 12680,14940]}, index=mIdx)<br/>In [77]: ChinaUSDF.to_panel()<br/>Out[77]:<br/>&lt;class 'pandas.core.panel.Panel'&gt;<br/>Dimensions: 2 (items) x 2 (major_axis) x 3 (minor_axis)<br/>Items axis: Population(M) to GDB($B)<br/>Major_axis axis: China to US<br/>Minor_axis axis: 1990 to 2010</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The sources of the US/China economic data are the following sites:</p>
<ul>
<li><a href="http://www.multpl.com/us-gdp-inflation-adjusted/table">http://www.multpl.com/us-gdp-inflation-adjusted/table</a></li>
<li><a href="http://www.multpl.com/united-states-population/table">http://www.multpl.com/united-states-population/table</a></li>
<li><a href="http://en.wikipedia.org/wiki/Demographics_of_China">http://en.wikipedia.org/wiki/Demographics_of_China</a></li>
<li><a href="http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980">http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other operations</h1>
                </header>
            
            <article>
                
<p>Insertion, deletion, and itemwise operations behave the same as in the case of DataFrames. Panel structures can be rearranged by transposing them. The feature set of the operations of Panels is relatively underdeveloped and not as rich as for Series and DataFrames.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>This chapter was a quick tour of the power of NumPy and showed a glimpse of how it makes life easier while working with pandas. Some of the highlights from the chapter were as follows:</span></p>
<ul>
<li>
<p>A  NumPy array is a versatile data structure used for containing multidimensional homogeneous data.</p>
</li>
</ul>
<ul>
<li>
<p>There are a variety of methods available for slicing/dicing, creating, and manipulating an array in the NumPy package.</p>
</li>
<li>
<p>NumPy arrays have practical applications such as being the building blocks of linear algebra operations and a tool to manipulate multidimensional array data such as images and audio.</p>
</li>
<li>
<p>Arrays (or matrices) are the computational blocks used in advanced mathematical models such as neural networks.</p>
</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li>
<p>NumPy arrays are the precursors of some of the essential data structures in pandas, namely Series.</p>
</li>
<li>
<p>Series are very similar to arrays. Series are one-dimensional. A custom-index can be passed to Series. Arrays or lists can be converted to Series. An indexed Series can be converted to a DataFrame.</p>
</li>
<li>
<p>Series, DataFrames, and Panels are other commonly used data structures in pandas, of which DataFrames are the most popular.</p>
</li>
<li>
<p>Multi-indexed DataFrames can be created using a dictionary of tuples. Simple dictionaries or dictionaries of lists/arrays can also be used for creating DataFrames.</p>
</li>
</ul>
<p>In the next chapter, we will focus on a variety of data sources for I/O operations in pandas. pandas supports a variety of data structures and sources to be read from and to be written to. We will learn about all that and more in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<ul>
<li class="mce-root"><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/index.html">https://opencv-python-tutroals.readthedocs.io/en/latest/index.html</a></li>
<li class="mce-root"><a href="http://corochann.com/basic-image-processing-tutorial-1220.html">http://corochann.com/basic-image-processing-tutorial-1220.html</a></li>
</ul>


            </article>

            
        </section>
    </body></html>