<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Indexing and Selecting in pandas</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, you learned how pandas makes it possible to read from any source and store structured data as a pandas object—Series, DataFrame, or panel. This chapter elaborates on how to slice and dice these objects. The row labels and column labels serve as identifiers that help us with selecting a subset of the data. Instead of a label, positional identifiers such as the row index and column index can also be used. Indexing and selecting are the most fundamental yet vital operations performed on data. The topics that will be addressed in this chapter include the following:</p>
<ul>
<li>Basic indexing</li>
<li>Labels, integer, and mixed indexing</li>
<li>Multi-indexing</li>
<li>Boolean indexing</li>
<li>Operations on indexes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic indexing</h1>
                </header>
            
            <article>
                
<p>If you have come across lists in Python, you will know that a pair of square brackets (<kbd>[]</kbd>) is used to index and subset a list. This square bracket operator is also useful in slicing NumPy arrays. The square bracket <kbd>[]</kbd> is the basic indexing operator in pandas as well.</p>
<p class="mce-root"/>
<p>Let's create a Series, DataFrame, and panel to understand how the square bracket operator is used in pandas:</p>
<pre># Creating a series with 6 rows and user-defined index<br/>ser = pd.Series(["Numpy", "Pandas", "Sklearn", "Tensorflow", "Scrapy", "Keras"], <br/>index = ["A", "B", "C", "D", "E", "F"])<br/><br/># Creating a 6X3 dataframe with defined row and column labels<br/>df = pd.DataFrame(np.random.randn(6, 3), columns = ["colA", "colB", "colC"], <br/>index = ["R1", "R2", "R3", "R4", "R5", "R6"])<br/><br/># Creating a panel with 3 items<br/>pan = pd.Panel({"Item1": df+1, "Item2": df, "Item3": df*2})</pre>
<p>For a Series, the square bracket operator can be used to slice by specifying the label or the positional index. Both use cases are shown in the following code block: </p>
<pre># Subset using the row-label<br/>In: ser["D"]<br/>Out: 'Tensorflow'<br/><br/># Subset using positional index<br/>In: ser[1]<br/>Out: 'Pandas'</pre>
<p>The use of the square bracket operator in a DataFrame does have some restrictions. It allows only the column label to be passed and not the positional index or even the row label. Passing any other string that does not represent a column name raises <kbd>KeyError</kbd>:</p>
<pre># Subset a single column by column name<br/>df["colB"]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/63e255b7-39ae-4b4d-83af-2a48f5e129f8.png" style="width:12.83em;height:7.42em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Subset of a single column by column name</div>
<p>A sequence of square bracket operators can be used to specify the row index or row label following the column attribute:</p>
<pre># Accessing a single element in a DataFrame<br/>df["colB"]["R3"], df["colB"][1]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a1f2e659-668c-468d-bd4c-b3001ae6e32b.png" style="width:21.00em;height:1.67em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Slicing a single element using the square bracket operator</div>
<p>The rules that apply to a <span>DataFrame </span>apply to a panel as well—each item can be sliced from the panel by specifying the item name. The square bracket operator accepts only a valid item name: </p>
<pre># Subset a panel<br/>pan["Item1"]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a01f5d7f-9f80-4977-a4cf-2f354c42c307.png" style="width:14.83em;height:11.92em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Subset of a panel</div>
<p>To subset multiple values, a list of the labels of the entities to be subset should be passed into the square bracket operator. Let's examine this using the <span>DataFrame</span>. This holds good for Series and Panels as well: </p>
<pre>df[["colA", "colB"]]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ec0a9c3e-8d71-4b21-b10b-fd40e5109ade.png" style="width:11.25em;height:13.25em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Slicing multiple columns from a <span>DataFrame</span></div>
<p>When a string that is not a column name is passed in, it raises an exception. This can be overcome by using the <kbd>get()</kbd> method: </p>
<pre>In: df.get("columnA", "NA")<br/>Out: 'NA'</pre>
<p>The square bracket operator is also useful for inserting a new column in a <span>DataFrame</span>, as shown in the following code block:</p>
<pre># Add new column "colD"<br/>df["colD"] = list(range(len(df)))<br/>df</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5f45a054-209b-4437-a669-f486965dbc95.png" style="width:16.67em;height:11.75em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Adding a new column to a <span>DataFrame</span></div>
<p>New values can be added to Series and Panels as well, via the method shown here.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing attributes using the dot operator</h1>
                </header>
            
            <article>
                
<p>To access a single entity (a column, value, or item), the square bracket operator can be replaced by the dot operator. Let's subset <kbd>colA</kbd> in the <span>DataFrame </span>using the dot (<kbd>.</kbd>) operator:</p>
<pre>df.colA</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5930687-5da6-4f77-9428-975df89e904f.png" style="width:14.33em;height:8.92em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Slicing a column with the dot operator</div>
<p>By using two dot operators in a chain, an individual element can be accessed: </p>
<pre>In: df.colA.R3<br/>Out: -2.089066</pre>
<p>This is also applicable to Panels and Series. However, unlike the square bracket operator in Series, the positional index cannot be used here. For the dot operator to be used, the row labels or column labels must have valid names. A valid Python identifier must follow the following lexical convention:</p>
<pre>identifier::= (letter|"_") (letter | digit | "_")*
Thus, a valid Python identifier cannot contain a space. See the Python Lexical Analysis documents for more details at <span class="URLPACKT">http://docs.python.org/2.7/reference/lexical_analysis.html#identifiers</span>.</pre>
<p>Using the dot operator, the values of existing columns can be changed. However, new columns cannot be created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Range slicing</h1>
                </header>
            
            <article>
                
<p>Slicing by supplying the start and end position to subset a range of values can be done in pandas objects, just as in NumPy arrays. The <kbd>[ : ]</kbd> operator helps in range slicing.</p>
<p class="mce-root"/>
<p>Let's slice the Series that we created earlier to subset the second, third, and fourth rows: </p>
<pre>ser[1:4]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/424795dc-55ee-4ef6-872d-a8551d236324.png" style="width:9.50em;height:5.75em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Slicing a Series with a range of indexes</div>
<p>As always with a range in Python, the value after the colon is excluded when slicing.</p>
<p>Range slicing can be done by providing either the start or end index. If the end index is not provided, values are sliced from the given starting index to the end of the data structure. Likewise, when only the end index is given, the first row is considered as the starting position for slicing: </p>
<pre># End provided for range slicing<br/>df[:2]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5aab6d02-1a19-48cc-be1b-750c176be125.png" style="width:17.83em;height:6.33em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Range slicing with the posterior end of the range defined</div>
<p>When the starting index is given, the row corresponding to that index value is chosen as the starting position for slicing:</p>
<pre># Start provided for range slicing<br/>df[2:]</pre>
<p class="mce-root"/>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/43e084aa-1fd6-4607-9cb6-baeabd69b615.png" style="width:14.17em;height:8.42em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Range slicing with the anterior end of the range defined</div>
<p>Range slicing can be made even more interesting through a property to select rows at evenly spaced intervals. For instance, you can select only the odd-numbered rows or even-numbered rows this way:</p>
<pre># Select odd rows<br/>df[::2]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/174bb860-123e-4a07-a88e-9b7a64b9510a.png" style="width:15.17em;height:7.75em;"/></p>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Range slicing to select odd-numbered rows</div>
<p>To select even rows, you can use the following code:</p>
<pre># Select even rows<br/>df[1::2]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a981f78-0ceb-4124-a46a-e118457da6ca.png" style="width:14.08em;height:7.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Range slicing to select even-numbered rows</div>
<p>If you want to reverse the <span><span>order</span></span> of the rows, you can use the following command:</p>
<pre># Reverse the rows<br/>df[::-1]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/66dce428-832c-411c-8070-6783d9d9dee9.png" style="width:14.58em;height:11.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Range slicing to reverse the order of rows</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Labels, integer, and mixed indexing</h1>
                </header>
            
            <article>
                
<p>In addition to the standard indexing operator, <kbd>[]</kbd>, and attribute operator, there are operators provided in pandas to make the job of indexing easier and more convenient. By label indexing, we generally mean indexing by a header name, which tends to be a string value in most cases. These operators are as follows:</p>
<ul>
<li><strong>The</strong> <kbd>.loc</kbd> <strong>operator</strong>: This allows label-oriented indexing.</li>
<li><strong>The <kbd>.iloc</kbd> operator</strong>: This allows integer-based indexing.</li>
<li><strong>The <kbd>.ix</kbd> operator</strong>: This allows mixed label and integer-based indexing.</li>
</ul>
<p>We'll now turn our attention to these operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Label-oriented indexing</h1>
                </header>
            
            <article>
                
<p>The <kbd>.loc</kbd> operator supports pure label-based indexing. It accepts the following as valid inputs:</p>
<ul>
<li>A single label such as <kbd>["colC"]</kbd>, <kbd>[2]</kbd>, or <kbd>["R1"]</kbd>—note that in cases where the label is an integer, it doesn't refer to the integer position of the index, but the integer is itself a label.</li>
<li>A list or array of labels, for example, <kbd>["colA", "colB" ]</kbd>.</li>
<li>A slice object with labels, for example, <kbd>"colB":"colD"</kbd>.</li>
<li>A Boolean array.</li>
</ul>
<p>Let's examine each of these four cases with respect to the following two Series—one with an integer-based label and another with a string-based label: </p>
<pre>ser_loc1 = pd.Series(np.linspace(11, 15, 5))<br/>ser_loc2 = pd.Series(np.linspace(11, 15, 5), index = list("abcde"))<br/><br/># Indexing with single label<br/>In: ser_loc1.loc[2]<br/>Out: 13.0<br/>In: ser_loc2.loc["b"]<br/>Out: 12.0<br/><br/># Indexing with a list of labels<br/>ser_loc1.loc[[1, 3, 4]]</pre>
<p>This results in the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c79d572a-546a-4917-a5c4-d0e6abd79a7f.png" style="width:9.67em;height:7.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc1.loc with a list of integer labels</div>
<pre>ser_loc2.loc[["b", "c", "d"]]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fdab5360-f534-4f9e-9cd3-91774a7b7dd5.png" style="width:9.25em;height:5.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc2.loc with a list of labels</div>
<pre># Indexing with range slicing<br/>ser_loc1.loc[1:4]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c722f22a-c2a7-4161-aaab-8ad8a2078ab9.png" style="width:9.58em;height:6.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc with range slicing (integer labels)</div>
<pre>ser_loc2.loc["b":"d"]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dd3f4e13-5719-4369-8db6-030f8e1708cc.png" style="width:8.92em;height:5.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc with range slicing</div>
<p>Notice that, unlike the ranges in Python where the posterior end is excluded, here, both the exteriors are included in the selected data. pandas objects can also be filtered based on logical conditions applied to values within the objects: </p>
<pre># Indexing with Boolean arrays<br/>ser_loc1.loc[ser_loc1 &gt; 13]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f141cc8d-442a-44c9-992e-611072fa7c06.png" style="width:11.17em;height:5.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc with a Boolean array for indexing</div>
<p>Now, these techniques for slicing can be applied to a <span>DataFrame</span>. It works the same, except for the fact that there is a provision to supply two sets of labels—one for each axis: </p>
<pre># Create a dataframe with default row-labels<br/>df_loc1 = pd.DataFrame(np.linspace(1, 25, 25).reshape(5, 5), columns = ["Asia", "Europe", "Africa", "Americas", "Australia"])<br/><br/># Create a dataframe with custom row labels<br/>df_loc2 = pd.DataFrame(np.linspace(1, 25, 25).reshape(5, 5), columns = ["Asia", "Europe", "Africa", "Americas", "Australia"], index = ["2011", "2012", "2013", "2014", "2015"])<br/><br/># Indexing with single label<br/>df_loc1.loc[:,"Asia"]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cd799db4-795c-4d65-932e-190cb3cf9f66.png" style="width:15.25em;height:7.42em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc for slicing a single column</div>
<pre>df_loc1.loc[2, :]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a669a756-30ff-48d2-91e3-e974b6d6f0cc.png" style="width:11.17em;height:7.08em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc for slicing a single row (integer label)</div>
<p>In the preceding case, "2" did not represent the position, but the index label:</p>
<pre>df_loc2.loc["2012", :]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/63723539-7ee5-47d1-a5be-c0710018880f.png" style="width:14.67em;height:8.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc for slicing a single row</div>
<pre># Indexing with a list of labels<br/>df_loc1.loc[:,["Africa", "Asia"]]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c4d8eb7a-0702-4293-8d7c-d98d5062e6a0.png" style="width:9.33em;height:11.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc for selecting through a list of labels</div>
<pre># Indexing with range slicing<br/>df_loc1.loc[:,"Europe":"Americas"]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d9d1349d-4334-4f00-8d1e-3791633bf3f0.png" style="width:14.08em;height:12.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Output of loc for range slicing</div>
<pre># Indexing with Boolean array<br/>df_loc2.loc[df_loc2["Asia"] &gt; 11, :]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5bc1bee1-2294-49f6-bc43-f0ad4d174c85.png" style="width:24.83em;height:7.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of loc for slicing based on a Boolean array</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integer-oriented indexing</h1>
                </header>
            
            <article>
                
<p>Integer-oriented indexing can be implemented for the same four cases as label-oriented indexing: single labels, a list of labels, range slicing, and Boolean arrays.</p>
<p class="mce-root"/>
<p>Let's use the same DataFrames as in the previous session to understand integer-oriented indexing. Here, let's use two values—one for each axis—to examine integer-based indexing. Passing an index for one axis is also permissible. This can also be done with the <kbd>loc</kbd> operator by passing in both the row and column labels:</p>
<pre># Indexing with single values.<br/>In: df_loc1.iloc[3, 2]<br/>Out: 18.0</pre>
<pre># Indexing with list of indices<br/>df_loc1.iloc[[1, 4], [0, 2, 3]]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12d678e0-1364-4f53-acd7-85716669bae2.png" style="width:13.17em;height:6.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of iloc for slicing with a list of indices</div>
<pre># Indexing with ranged slicing<br/>df_loc2.iloc[3:,:3]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/271db284-08af-455d-acc5-48d826c62034.png" style="width:14.50em;height:7.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of iloc for ranged slicing</div>
<pre># Indexing with Boolean array<br/>df_loc2.iloc[(df_loc2["Asia"] &gt; 11).values, :]</pre>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f56d6eb3-1b21-49ee-ad00-725ba8cb38f0.png" style="width:24.67em;height:7.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of iloc for slicing with a Boolean array</div>
<p>For Boolean array-based indexing with the <kbd>iloc</kbd> operator, the array must be extracted using logical conditions around array values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The .iat and .at operators</h1>
                </header>
            
            <article>
                
<p>The <kbd>.iat</kbd> and <kbd>.at</kbd> operators are equivalent to <kbd>.iloc</kbd> and <kbd>.loc</kbd> operators—the former is for position-based indexing and the latter for label-based indexing. While <kbd>.loc</kbd> and <kbd>.iloc</kbd> support the selection of multiple values, <kbd>.at</kbd> and <kbd>.iat</kbd> can only extract a single scalar value. Hence they require row and column indices for slicing:</p>
<pre>In: df_loc2.at["2012", "Americas"]<br/>Out: 9.0<br/><br/>In: df_loc1.iat[2, 3]<br/>Out: 14.0</pre>
<p>The <kbd>.iat</kbd> and <kbd>.at</kbd> <span>operators </span>are considerably faster in performance than <kbd>.iloc</kbd> and <kbd>.loc</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9255123f-bdae-46fa-b7c1-e95ffadf7ed7.png" style="width:45.67em;height:11.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Benchmarking .iat with respect to .iloc</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mixed indexing with the .ix operator</h1>
                </header>
            
            <article>
                
<p>The <kbd>.ix</kbd> operator accepts both label-based and position-based indexing and is considered to be a more generic version of the <kbd>.loc</kbd> and <kbd>.iloc</kbd> operators. Due to ambiguity, this operator is deprecated and will not be available in a future version. Hence, it is advised not to use the <kbd>.ix</kbd> operator. Let's get an understanding of the <kbd>.ix</kbd> operator.</p>
<p>Here, the row index is label-based and the column index is position-based: </p>
<pre>df_loc2.ix["2012":"2014", 0:2]</pre>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a33ee537-af4c-47be-acd7-d45df89c359f.png" style="width:8.83em;height:7.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Mixed indexing with .ix in a DataFrame</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multi-indexing</h1>
                </header>
            
            <article>
                
<p>We'll now turn to the topic of multi-indexing. Multi-level or hierarchical indexing is useful because it enables pandas users to select and massage data in multiple dimensions by using data structures such as Series and DataFrames. In order to start, let's save the following data to a file, <kbd>stock_index_prices.csv</kbd>, and read it in:</p>
<pre>    In[950]:sharesIndexDataDF=pd.read_csv('./stock_index_prices.csv')
    In [951]: sharesIndexDataDF<br/>    Out[951]:
      TradingDate  PriceType  Nasdaq     S&amp;P 500  Russell 2000
    0   2014/02/21   open     4282.17  1841.07  1166.25
    1   2014/02/21   close     4263.41  1836.25  1164.63
    2   2014/02/21   high     4284.85  1846.13  1168.43
    3   2014/02/24   open     4273.32  1836.78  1166.74
    4   2014/02/24   close     4292.97  1847.61  1174.55
    5   2014/02/24   high      4311.13  1858.71  1180.29
    6   2014/02/25   open     4298.48  1847.66  1176.00
    7   2014/02/25   close     4287.59  1845.12  1173.95
    8   2014/02/25   high     4307.51  1852.91  1179.43
    9   2014/02/26   open     4300.45  1845.79  1176.11
    10   2014/02/26   close     4292.06  1845.16  1181.72
    11   2014/02/26   high     4316.82  1852.65  1188.06
    12   2014/02/27   open     4291.47  1844.90  1179.28
    13   2014/02/27   close     4318.93  1854.29  1187.94
    14   2014/02/27   high     4322.46  1854.53  1187.94
    15   2014/02/28   open     4323.52  1855.12 1189.19
    16   2014/02/28   close     4308.12  1859.45 1183.03
    17   2014/02/28   high     4342.59  1867.92 1193.50</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Here, we create a multi-index from the <kbd>TradingDate</kbd> and <kbd>PriceType</kbd> columns:</p>
<pre>In[958]:sharesIndexDF=sharesIndexDataDF.set_index(['TradingDate','PriceType']) <br/><br/>In [959]: mIndex=sharesIndexDF.index; mIndex <br/><br/>Out[959]: MultiIndex
        [(u'2014/02/21', u'open'), (u'2014/02/21', u'close'), (u'2014/02/21', u'high'), (u'2014/02/24', u'open'), (u'2014/02/24', u'close'), (u'2014/02/24', u'high'), (u'2014/02/25', u'open'), (u'2014/02/25', u'close'), (u'2014/02/25', u'high'), (u'2014/02/26', u'open'), (u'2014/02/26', u'close'), (u'2014/02/26', u'high'), (u'2014/02/27', u'open'), (u'2014/02/27', u'close'), (u'2014/02/27', u'high'), (u'2014/02/28', u'open'), (u'2014/02/28', u'close'), (u'2014/02/28', u'high')]
    
In [960]: sharesIndexDF<br/>Out[960]: Nasdaq  S&amp;P 500   Russell 2000 TradingDate PriceType
2014/02/21 open   4282.17  1841.07  1166.25
          close  4263.41  1836.25  1164.63
          high   4284.85  1846.13  1168.43
2014/02/24 open         4273.32  1836.78  1166.74
         close         4292.97  1847.61  1174.55
         high         4311.13  1858.71  1180.29
2014/02/25 open         4298.48  1847.66  1176.00
         close         4287.59  1845.12  1173.95
         high         4307.51  1852.91  1179.43
2014/02/26 open         4300.45  1845.79  1176.11
         close         4292.06  1845.16  1181.72
         high         4316.82  1852.65  1188.06
2014/02/27 open        4291.47  1844.90  1179.28
         close        4318.93  1854.29  1187.94
         high        4322.46  1854.53  1187.94
2014/02/28 open        4323.52  1855.12  1189.19
         close        4308.12  1859.45  1183.03
         high        4342.59  1867.92  1193.50
  </pre>
<p>Upon inspection, we see that the multi-index consists of a list of tuples. Applying the <kbd>get_level_values</kbd> function with the appropriate argument produces a list of the labels for each level of the index:</p>
<pre>    In [962]: mIndex.get_level_values(0)
    Out[962]: Index([u'2014/02/21', u'2014/02/21', u'2014/02/21', u'2014/02/24', u'2014/02/24', u'2014/02/24', u'2014/02/25', u'2014/02/25', u'2014/02/25', u'2014/02/26', u'2014/02/26', u'2014/02/26', u'2014/02/27', u'2014/02/27', u'2014/02/27', u'2014/02/28', u'2014/02/28', u'2014/02/28'], dtype=object)
    
    In [963]: mIndex.get_level_values(1)
    Out[963]: Index([u'open', u'close', u'high', u'open', u'close', u'high', u'open', u'close', u'high', u'open', u'close', u'high', u'open', u'close', u'high', u'open', u'close', u'high'], dtype=object)
  </pre>
<p><kbd>IndexError</kbd> will be thrown if the value passed to <kbd>get_level_values()</kbd> is invalid or out of range:</p>
<pre>    In [88]: mIndex.get_level_values(2)
             ---------------------------------------------------------
    IndexError                      Traceback (most recent call last)
    ...
  </pre>
<p>You can achieve hierarchical indexing with a multi-indexed DataFrame:</p>
<pre>    In [971]: sharesIndexDF.ix['2014/02/21']
    Out[971]:       Nasdaq   S&amp;P 500    Russell 2000
      PriceType
      open       4282.17  1841.07  1166.25
      close       4263.41  1836.25  1164.63
      high       4284.85  1846.13  1168.43
    
    In [976]: sharesIndexDF.ix['2014/02/21','open']
    Out[976]: Nasdaq          4282.17
        S&amp;P 500         1841.07
        Russell 2000    1166.25
        Name: (2014/02/21, open), dtype: float64 
  </pre>
<p>We can slice using a multi-index:</p>
<pre>    In [980]: sharesIndexDF.ix['2014/02/21':'2014/02/24']
    Out[980]:      Nasdaq   S&amp;P 500   Russell 2000
      TradingDate  PriceType
      2014/02/21   open  4282.17   1841.07   1166.25
             close  4263.41   1836.25   1164.63
             high  4284.85   1846.13   1168.43
      2014/02/24   open  4273.32   1836.78   1166.74
             close  4292.97   1847.61   1174.55
             high  4311.13   1858.71   1180.29
  </pre>
<p>We can try slicing at a lower level:</p>
<pre>    In [272]:
    sharesIndexDF.ix[('2014/02/21','open'):('2014/02/24','open')]
    ------------------------------------------------------------------
    KeyError                                  Traceback (most recent call last)
    &lt;ipython-input-272-65bb3364d980&gt; in &lt;module&gt;()
    ----&gt; 1 sharesIndexDF.ix[('2014/02/21','open'):('2014/02/24','open')]
    ...
    KeyError: 'Key length (2) was greater than MultiIndex lexsort depth (1)'
  </pre>
<p>However, this results in <kbd>KeyError</kbd> with a rather strange error message. The key lesson to be learned here is that the current incarnation of multi-index requires the labels to be sorted for the lower-level slicing routines to work correctly.</p>
<p>In order to do this, you can utilize the <kbd>sortlevel()</kbd> method, which sorts the labels of an axis within a multi-index. To be on the safe side, sort first before slicing with a multi-index. Thus, we can do the following:</p>
<pre>In [984]: sharesIndexDF.sortlevel(0).ix[('2014/02/21','open'):('2014/02/24','open')]
    <br/>Out[984]:          Nasdaq    S&amp;P 500  Russell 2000
      TradingDate  PriceType
      2014/02/21  open      4282.17   1841.07  1166.25
      2014/02/24  close      4292.97   1847.61  1174.55
          high      4311.13   1858.71  1180.29
          open      4273.32   1836.78  1166.74
  </pre>
<p>We can also pass a list of tuples:</p>
<pre>In [985]: sharesIndexDF.ix[[('2014/02/21','close'),('2014/02/24','open')]] <br/>Out[985]: Nasdaq S&amp;P 500 Russell 2000 TradingDate PriceType 2014/02/21 close 4263.41 1836.25 1164.63 2014/02/24 open 4273.32 1836.78 1166.74 2 rows × 3 columns</pre>
<p>Note that by specifying a list of tuples instead of a range, as in the previous example, we display only the values of open <kbd>PriceType</kbd> rather than all three for <kbd>TradingDate = <span>2014/02/24</span></kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swapping and re-ordering levels</h1>
                </header>
            
            <article>
                
<p>The <kbd>swaplevel</kbd> function enables levels within the multi-index to be swapped:</p>
<pre>    In [281]: swappedDF=sharesIndexDF[:7].swaplevel(0, 1, axis=0)
              swappedDF<br/>    Out[281]:        Nasdaq    S&amp;P 500  Russell 2000
      PriceType  TradingDate
      open        2014/02/21   4282.17  1841.07  1166.25
      close    2014/02/21   4263.41  1836.25  1164.63
      high    2014/02/21   4284.85  1846.13  1168.43
      open    2014/02/24   4273.32  1836.78  1166.74
      close    2014/02/24   4292.97  1847.61  1174.55
      high    2014/02/24   4311.13  1858.71  1180.29
      open        2014/02/25   4298.48  1847.66  1176.00
      7 rows × 3 columns
  </pre>
<p>The <kbd>reorder_levels</kbd> function is more general, allowing you to specify the order of the levels:</p>
<pre> In [285]: reorderedDF=sharesIndexDF[:7].reorder_levels(['PriceType',                                                 'TradingDate'],axis=0)<br/> reorderedDF<br/>    Out[285]:        Nasdaq    S&amp;P 500  Russell 2000
      PriceType  TradingDate
      open    2014/02/21   4282.17  1841.07  1166.25
      close    2014/02/21   4263.41  1836.25  1164.63
      high    2014/02/21   4284.85  1846.13  1168.43
      open    2014/02/24   4273.32  1836.78  1166.74
      close    2014/02/24   4292.97  1847.61  1174.55
      high    2014/02/24   4311.13  1858.71  1180.29
      open    2014/02/25   4298.48  1847.66  1176.00
      7 rows × 3 columns
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cross-sections</h1>
                </header>
            
            <article>
                
<p>The <kbd>xs</kbd> method provides a shortcut means of selecting data based on a particular index-level value:</p>
<pre>    In [287]: sharesIndexDF.xs('open',level='PriceType')<br/>    Out[287]:
          Nasdaq    S&amp;P 500  Russell 2000
      TradingDate
      2014/02/21  4282.17  1841.07  1166.2x5
      2014/02/24   4273.32  1836.78  1166.74
      2014/02/25   4298.48  1847.66  1176.00
      2014/02/26   4300.45  1845.79  1176.11
      2014/02/27   4291.47  1844.90  1179.28
      2014/02/28   4323.52  1855.12  1189.19
      6 rows × 3 columns
  </pre>
<p>The more long-winded alternative to the preceding command would be to use <kbd>swaplevel</kbd> to switch between the <kbd>TradingDate</kbd> and <kbd>PriceType</kbd> levels and then perform the selection as follows:</p>
<pre>    In [305]: sharesIndexDF.swaplevel(0, 1, axis=0).ix['open']<br/>    Out[305]:     Nasdaq   S&amp;P 500  Russell 2000
      TradingDate
      2014/02/21  4282.17  1841.07  1166.25
      2014/02/24  4273.32  1836.78  1166.74
      2014/02/25  4298.48  1847.66  1176.00
      2014/02/26  4300.45  1845.79  1176.11
      2014/02/27  4291.47  1844.90  1179.28
      2014/02/28  4323.52  1855.12  1189.19
      6 rows × 3 columns
  </pre>
<p>Using <kbd>.xs</kbd> achieves the same effect as obtaining a cross-section in the previous section on integer-oriented indexing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Boolean indexing</h1>
                </header>
            
            <article>
                
<p>We use Boolean indexing to filter or select parts of the data. The operators are as follows:</p>
<table style="border-collapse: collapse;width: 857px;height: 257px" class="table" border="1">
<tbody>
<tr>
<td style="width: 479.132px" class="CDPAlignCenter CDPAlign">
<p><strong>Operators</strong></p>
</td>
<td style="width: 370.243px" class="CDPAlignCenter CDPAlign">
<p><strong>Symbol</strong></p>
</td>
</tr>
<tr>
<td style="width: 479.132px" class="CDPAlignCenter CDPAlign">
<p>OR</p>
</td>
<td style="width: 370.243px" class="CDPAlignCenter CDPAlign">
<p>|</p>
</td>
</tr>
<tr>
<td style="width: 479.132px" class="CDPAlignCenter CDPAlign">
<p>AND</p>
</td>
<td style="width: 370.243px" class="CDPAlignCenter CDPAlign">
<p>&amp;</p>
</td>
</tr>
<tr>
<td style="width: 479.132px" class="CDPAlignCenter CDPAlign">
<p>NOT</p>
</td>
<td style="width: 370.243px" class="CDPAlignCenter CDPAlign">
<p>~</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>These operators must be grouped using parentheses when used together. Using the earlier DataFrame from the previous section, here we display the trading dates for which NASDAQ closed above 4,300:</p>
<pre>  In [311]: sharesIndexDataDF.ix[(sharesIndexDataDF['PriceType']=='close') &amp; \
                         (sharesIndexDataDF['Nasdaq']&gt;4300) ]<br/>  Out[311]:        PriceType  Nasdaq   S&amp;P 500   Russell 2000
      TradingDate
      2014/02/27   close  4318.93   1854.29   1187.94
      2014/02/28   close  4308.12   1859.45   1183.03
      2 rows × 4 columns
  </pre>
<p>You can also create Boolean conditions in which you use arrays to filter out parts of the data, as shown in the following code:</p>
<pre>highSelection=sharesIndexDataDF['PriceType']=='high'  NasdaqHigh=sharesIndexDataDF['Nasdaq']&lt;4300  sharesIndexDataDF.ix[highSelection &amp; NasdaqHigh]<br/>    Out[316]: TradingDate  PriceType Nasdaq  S&amp;P 500  Russell 2000
        2014/02/21        high 4284.85  1846.13  1168.43</pre>
<p class="mce-root"/>
<p>Thus, the preceding code snippet displays the only date in the dataset for which the NASDAQ Composite index stayed below the 4,300 level for the entire trading session.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The isin and any all methods</h1>
                </header>
            
            <article>
                
<p>These methods enable the user to achieve more with Boolean indexing than the standard operators used in the preceding sections. The <kbd>isin</kbd> method takes a list of values and returns a Boolean array with <kbd>True</kbd> at the positions within the Series or DataFrame that match the values in the list. This enables the user to check for the presence of one or more elements within a Series. Here is an illustration using <kbd>Series</kbd>:</p>
<pre>    In[317]:stockSeries=pd.Series(['NFLX','AMZN','GOOG','FB','TWTR'])
               stockSeries.isin(['AMZN','FB'])<br/>    Out[317]:0    False
            1     True
            2    False
            3     True
            4    False
            dtype: bool
  </pre>
<p>Here, we use the Boolean array to select a sub-series containing the values that we're interested in:</p>
<pre>    In [318]: stockSeries[stockSeries.isin(['AMZN','FB'])]<br/>    Out[318]: 1    AMZN
             3      FB
            dtype: object
  </pre>
<p>For our DataFrame example, we switch to a more interesting dataset for those of us who are of a biological anthropology bent—that of classifying Australian mammals (a pet interest of mine):</p>
<pre>    In [324]: australianMammals=
                  {'kangaroo': {'Subclass':'marsupial', 
                                  'Species Origin':'native'},
                   'flying fox' : {'Subclass':'placental', 
                                   'Species Origin':'native'},
                   'black rat': {'Subclass':'placental', 
                                 'Species Origin':'invasive'},
                   'platypus' : {'Subclass':'monotreme', 
                                 'Species Origin':'native'},
                   'wallaby' :  {'Subclass':'marsupial', 
                                 'Species Origin':'native'},
            'palm squirrel' : {'Subclass':'placental', 
                               'Origin':'invasive'},
            'anteater':     {'Subclass':'monotreme', 'Origin':'native'},
            'koala':        {'Subclass':'marsupial', 'Origin':'native'}
    }
  </pre>
<div class="packt_infobox">Some more information on mammals: Marsupials are pouched mammals, monotremes are egg-laying, and placentals give birth to live young. The source of this information is the following: <a href="http://en.wikipedia.org/wiki/List_of_mammals_of_Australia">http://en.w<span class="URLPACKT">ikipedia.org/wiki/List_of_mammals_of_Australia</span></a>.</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/764b993d-5a63-451a-8e9c-a62c465387e1.jpg" style="width:26.00em;height:17.33em;"/></div>
<p>The source of the preceding image is Bennett's wallaby at <a href="http://bit.ly/NG4R7N."><span class="URLPACKT">http://bit.ly/NG4R7N</span>.</a></p>
<p>Let's read the Australian Mammals dataset, convert that to a DataFrame, and transpose it before using it:</p>
<pre>    In [328]: ozzieMammalsDF=pd.DataFrame(australianMammals)
    In [346]: aussieMammalsDF=ozzieMammalsDF.T; aussieMammalsDF
    Out[346]:       Subclass  Origin
      anteater      monotreme      native
      black rat     placental   invasive
      flying fox    placental   native
      kangaroo      marsupial   native
      koala          marsupial   native
      palm squirrel placental   invasive
      platypus      monotreme      native
      wallaby   marsupial   native
      8 rows × 2 columns</pre>
<p class="mce-root"/>
<p>Let's try to select mammals that are native to Australia:</p>
<pre>    In [348]: aussieMammalsDF.isin({'Subclass':['marsupial'],'Origin':['native']})<br/>    Out[348]:    Subclass Origin
      anteater   False   True
      black rat   False   False
      flying fox   False   True
      kangaroo   True   True
      koala      True   True
      palm squirrel False False
      platypus   False   True
      wallaby   True   True
      8 rows × 2 columns
  </pre>
<p>The set of values passed to <kbd>isin</kbd> can be an array or a dictionary. That works to some extent, but we can achieve better results by creating a mask as a combination of the <kbd>isin</kbd> and <kbd>all()</kbd> methods:</p>
<pre>    In [349]: nativeMarsupials={'Mammal Subclass':['marsupial'],
                                'Species Origin':['native']}
           nativeMarsupialMask=aussieMammalsDF.isin(nativeMarsupials).all(True)
        aussieMammalsDF[nativeMarsupialMask]
    Out[349]:      Subclass   Origin
      kangaroo  marsupial  native
      koala      marsupial  native
      wallaby   marsupial  native
      3 rows × 2 columns
  </pre>
<p>Thus, we see that kangaroo, koala, and wallaby are the native marsupials in our dataset. The <kbd>any()</kbd> method returns whether any element is <kbd>True</kbd> in a Boolean DataFrame. The <kbd>all()</kbd> method filters return whether all elements are <kbd>True</kbd> in a Boolean DataFrame.</p>
<p><span><span>More can be read about the pandas methods from their official documentation page:</span></span> <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.any.html."><span class="URLPACKT">http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.any.html</span>.</a></p>
<p><a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.any.html."/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the where() method</h1>
                </header>
            
            <article>
                
<p>The <kbd>where()</kbd> method is used to ensure that the result of Boolean filtering is the same shape as the original data. First, we set the random number generator seed to 100 so that the user can generate the same values, as shown next:</p>
<pre>    In [379]: np.random.seed(100)
           normvals=pd.Series([np.random.normal() for i in np.arange(10)])
        normvals
    Out[379]: 0   -1.749765
        1    0.342680
        2    1.153036
        3   -0.252436
        4    0.981321
        5    0.514219
        6    0.221180
        7   -1.070043
        8   -0.189496
        9    0.255001
        dtype: float64
    
    In [381]: normvals[normvals&gt;0]
    Out[381]: 1    0.342680
        2    1.153036
        4    0.981321
        5    0.514219
        6    0.221180
        9    0.255001
        dtype: float64
    
    In [382]: normvals.where(normvals&gt;0)
    Out[382]: 0         NaN
        1    0.342680
        2    1.153036
        3         NaN
        4    0.981321
        5    0.514219
        6    0.221180
        7         NaN
        8         NaN
        9    0.255001
        dtype: float64
  </pre>
<p>This method seems to be useful only in the case of a Series, as we get this behavior for free in the case of a DataFrame:</p>
<pre>    In [393]: np.random.seed(100) 
           normDF=pd.DataFrame([[round(np.random.normal(),3) for i in np.arange(5)] for j in range(3)], 
                 columns=['0','30','60','90','120'])
        normDF
    Out[393]:  0  30  60  90  120
      0  -1.750   0.343   1.153  -0.252   0.981
      1   0.514   0.221  -1.070  -0.189   0.255
      2  -0.458   0.435  -0.584   0.817   0.673
      3 rows × 5 columns
    In [394]: normDF[normDF&gt;0]
    Out[394]:  0  30  60  90  120
      0   NaN   0.343   1.153   NaN   0.981
      1   0.514   0.221   NaN       NaN   0.255
      2   NaN   0.435   NaN   0.817   0.673
      3 rows × 5 columns
    In [395]: normDF.where(normDF&gt;0)
    Out[395]:  0  30  60  90  120
      0   NaN   0.343   1.153   NaN   0.981
      1   0.514   0.221   NaN   NaN   0.255
      2   NaN   0.435   NaN   0.817   0.673
      3 rows × 5 columns
  </pre>
<p>The inverse operation of the <kbd>where</kbd> method is <kbd>mask</kbd>:</p>
<pre>    In [396]: normDF.mask(normDF&gt;0)
    Out[396]:  0  30  60  90  120
      0  -1.750  NaN   NaN  -0.252  NaN
      1   NaN  NaN  -1.070  -0.189  NaN
      2  -0.458  NaN  -0.584   NaN  NaN
      3 rows × 5 columns
  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operations on indexes</h1>
                </header>
            
            <article>
                
<p>To complete this chapter, we'll discuss operations on indexes. We sometimes need to operate on indexes when we wish to realign our data or select it in different ways. There are various operations:</p>
<p>Note that <kbd>set_index</kbd> allows the creation of an index on an existing DataFrame and returns an indexed DataFrame, as we have seen before:</p>
<pre>    In [939]: stockIndexDataDF=pd.read_csv('./stock_index_data.csv')
    In [940]: stockIndexDataDF
    Out[940]:   TradingDate  Nasdaq   S&amp;P 500  Russell 2000
      0   2014/01/30   4123.13  1794.19  1139.36
      1   2014/01/31   4103.88  1782.59  1130.88
      2   2014/02/03   3996.96  1741.89  1094.58
      3   2014/02/04   4031.52  1755.20  1102.84
      4   2014/02/05   4011.55  1751.64  1093.59
      5   2014/02/06   4057.12  1773.43  1103.93
  </pre>
<p>Now, we can set the index as follows:</p>
<pre>    In [941]: stockIndexDF=stockIndexDataDF.set_index('TradingDate')
    In [942]: stockIndexDF
    Out[942]:    Nasdaq   S&amp;P 500  Russell 2000
      TradingDate
      2014/01/30  4123.13   1794.19  1139.36
      2014/01/31      4103.88   1782.59  1130.88
      2014/02/03  3996.96   1741.89  1094.58
      2014/02/04  4031.52   1755.20  1102.84
      2014/02/05  4011.55   1751.64  1093.59
      2014/02/06  4057.12   1773.43  1103.93
  </pre>
<p>Furthermore, <kbd>reset_index</kbd> reverses <kbd>set_index</kbd>:</p>
<pre>    In [409]: stockIndexDF.reset_index()<br/>    Out[409]:    
       TradingDate   Nasdaq   S&amp;P 500  Russell 2000
    0   2014/01/30   4123.13   1794.19   1139.36
    1   2014/01/31   4103.88   1782.59   1130.88
    2   2014/02/03   3996.96   1741.89   1094.58
    3   2014/02/04   4031.52   1755.20   1102.84
    4   2014/02/05   4011.55   1751.64   1093.59
    5   2014/02/06   4057.12   1773.43   1103.93
    6 rows × 4 columns
  </pre>
<p>After reading this chapter, you have come a long way in wrangling data using pandas. We will continue to learn about useful tools for data wrangling in the next chapter. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to access and select data from panda data structures. We also looked in detail at basic indexing and label-oriented, integer-oriented, and mixed indexing. We also learned how to use a Boolean/logical index as well. At the end of the chapter, we discussed the index operations. </p>
<p>For further references about indexing in pandas, please take a look at the official documentation at <a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html"><span class="URLPACKT">http://pandas.pydata.org/pandas-docs/stable/indexing.html</span></a>.</p>
<p>In the next chapter, we will examine the topics of grouping, reshaping, and merging data using pandas.</p>


            </article>

            
        </section>
    </body></html>