- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing and Displaying Content with Columns, Expanders, and NLP Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop all the business logic required for the skeleton
    app we implemented in [*Chapter 4*](B21147_04.xhtml#_idTextAnchor045). We are
    going to learn about some extremely important features of Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Columns and expanders are two layout features in the Streamlit framework that
    allow for more flexible and organized display of content in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Columns allow for dividing the screen horizontally into multiple sections, each
    with its own content. This is useful for displaying multiple visualizations or
    data tables side by side, or for separating different parts of the app’s interface.
    Expanders, on the other hand, allow for collapsing and expanding sections of content
    within a column. This is useful for hiding less important or less frequently used
    parts of the app’s interface, and allowing users to expand them only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: In NLP, tokens are individual text units segmented by white space or punctuation.
    Lemmas, on the other hand, are the base or dictionary form of a word, which may
    differ from the inflected or derived form found in the text.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, our first web application should appear much more
    complete and you should have a wider understanding of how to build a Python web
    application using Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing and arranging content in a web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding and showing parts depending on importance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing NLP concepts – tokens and lemmas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spacy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neattext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code in the chapter can be accessed through the following GitHub link: [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/bd70c6ee45d046134e71c3c8a93c3d97172bf3f9/Chapter05](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/bd70c6ee45d046134e71c3c8a93c3d97172bf3f9/Chapter05)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing and arranging content in a web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B21147_04.xhtml#_idTextAnchor045), we built the foundations
    of our first web application and wrote some Python code that, once executed, gives
    us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Chapter 5 starting point](img/B21147_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: [*Chapter 5*](B21147_05.xhtml#_idTextAnchor053) starting point'
  prefs: []
  type: TYPE_NORMAL
- en: We completed the **About** section, made some decorations in terms of colors,
    and added an icon (the so-called *favicon*) and a title to the web browser page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to complete the three remaining voices of the menu: **Text Analysis**,
    **Translation**, and **Sentiment Analysis**.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding decorations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before completing the three voices of the menu, however, let’s add a nice decoration
    to the sidebar of our web app. So, once again, open the Sublime Text editor and
    restart coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add an image to the sidebar immediately after the second HTML of
    the title on *lines 35-36* of our code. This is an easy coding task, and it is
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: st.sidebar.image](img/B21147_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: st.sidebar.image'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is extremely easy: we are adding to the sidebar `(st.sidebar)`
    an image. We just wrote `NLP` in Google and downloaded an image, saving it as
    `nlp.jpg` in the same folder as our Python script. Since we are setting the `unsafe_allow_width`
    argument to `True`, the width of our image will be exactly the same as that of
    all other elements in the sidebar. If you want, instead of `unsafe_allow_width`,
    you can use the `width` one in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can try with different widths (100, 300, etc.) and observe the different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5**.3*, we can see the result of the last decoration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: A picture in the sidebar](img/B21147_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: A picture in the sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: Our web application is starting to look appealing! Now we can move on to the
    text analysis part.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Text Analysis part
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part, we will use `textblob`, a Python library for processing textual
    data. It provides a simple API for diving into common NLP tasks such as part-of-speech
    tagging, sentiment analysis, classification, and more. For more details, visit
    [pypi.org](http://pypi.org) (the famous Python Package Index).
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we need to install the package in our virtual environment by just
    typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we import it into our Python script, adding the following line at
    the very beginning in the `importing` `libraries` part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Anyway, if you followed [*Chapter 4*](B21147_04.xhtml#_idTextAnchor045) carefully,
    you have already done this, but it’s better to repeat it just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump to the *Text Analysis* part of our script and finally add its specific
    business logic. *Text Analysis*, as we will see during the coding, is a function
    focused on text stats (length, number of words, etc.), wordstopping, lemmas and
    tokens, and so on. We will quickly explain these concepts one by one in the next
    pages. Besides NLP concepts, what is very important here is to understand how
    to use the various Streamlit widgets, functions, and technicalities in order to
    create and build up solid and well-performing web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a text area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, in this part, we just have a header and a subheader. In order to
    perform text analysis, for sure we need some text, so as the very first operation,
    let’s add a text area where we can input all the text we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: st.text_area](img/B21147_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: st.text_area'
  prefs: []
  type: TYPE_NORMAL
- en: We are using `text_area` to get some text and put it in a variable named `raw_text`.
    Try to play with `st.text_area` arguments a little, and especially try to discover
    what happens if you don’t use *height*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Analyze button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want to do something with the text typed in this `text_area` so, just to
    understand better how it works, let’s add a button named **Analyze** that, when
    pushed, writes our text on the screen. The code is quite simple, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: A button to show our text](img/B21147_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: A button to show our text'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep it very neat and clean, we write something in the text area – for example,
    `Hello everybody!` – click on the button, and see what we wrote on the screen.
    This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Hello everybody!](img/B21147_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Hello everybody!'
  prefs: []
  type: TYPE_NORMAL
- en: To perform any NLP task, TextBlob needs to convert any text into a `Blob` object,
    something specific to this nice package. Let us see how.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Blob object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform all our NLP tasks with TextBlob, we have to be sure that this Blob
    can be created, and it can be created only if the text area contains some text
    – in other words, if the text area is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the preceding code a bit, just to be sure that the text area is
    not empty and that the `Blob` object will be created without issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: TextBlob in action](img/B21147_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: TextBlob in action'
  prefs: []
  type: TYPE_NORMAL
- en: So, *if* there is no text in the `text_area`, its length (`len`) is equal to
    zero and we display a warning message; otherwise (`else`) we create a `TextBlob`
    object, save it as a variable named `blob`, and display a confirmation message
    (`OK`).
  prefs: []
  type: TYPE_NORMAL
- en: And now, we have our `TextBlob` object working.
  prefs: []
  type: TYPE_NORMAL
- en: Adding basic functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to now, we have edited all code properly and we are ready to implement some
    real text analysis functions. In fact, we will be using `TextBlob` later on for
    the sentiment analysis function. Now, we just use it to check that the application
    runs correctly, so if you want, you can comment on the following line of code,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s get started with `st.write("OK")` line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we are at the stage shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Basic functions](img/B21147_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Basic functions'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to understand how to show and hide information on the screen using
    columns, expanders, and more advanced coding.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding and showing parts depending on importance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a very broad point of view, an application is just a way to visualize,
    transform, and save information. Not always showing all the available information
    at the same time is a winning idea. For example, having all the information on
    a unique screen could make our app very crowded. In other cases, we are not interested
    in visualizing all the information simultaneously because we want to see only
    a specific piece of information that is of our interest. So, hiding and properly
    showing information in our web application is a very valuable skill to acquire.
  prefs: []
  type: TYPE_NORMAL
- en: Adding columns, expanders, and a textbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Columns are very useful because they allow us to create some *layers* or *different
    parts*. This means that by using columns, we can divide the screen into as many
    vertical sections as we want and use these sections (or columns) for any kind
    of specific purpose we think should be in a specific – or let’s say dedicated
    – container. All we need to do is create or declare these widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start using them by adopting the `with` instruction. Let’s see it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Columns and expanders](img/B21147_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Columns and expanders'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `col1, col2 = st.columns(2)` line just creates two columns named `col1`
    and `col2`. In the two `with` lines, we use these columns. In each of the columns,
    we create an *expander*; any expander has its own label (`Basic Info` and `Processed
    Text`). Expanders are clickable since they have an *up arrow* and *down arrow*
    symbol. Clicking on these symbols, we *expand* or *collapse* these widgets to
    reveal their content – in our example, just `st.write` and `st.success` instructions.
    The effect in the browser is very beautiful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Columns and expanders in our web application](img/B21147_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Columns and expanders in our web application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to also include a couple of *Advanced Features* in our web app,
    let’s copy the latest part of the code in order to create another couple of columns
    and expanders, plus an `info` text box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: New columns and expanders](img/B21147_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: New columns and expanders'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we added is the same as we already commented previously. Its impact
    on the web application is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Our application layout is going to be completed](img/B21147_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Our application layout is going to be completed'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, up to now we have two layers, two expanders, and two columns
    for every layer; the effect is very clean and well-balanced. Now we can take care
    of the four functions: two basic and two advanced.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the two basic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the first basic function: `neattext` package, which is very
    useful for our statistics as it has a function named `word_stats`. If you haven’t
    already imported it, it’s time to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: '`word_stats` returns a dictionary, so a `key:value` data structure; all we
    need to do is to get the information from it (putting in the `word_desc` variable),
    then write everything on the screen in the proper column. The following screenshot
    shows the code that obviously is part of `col1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Text Stats](img/B21147_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Text Stats'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the stats using a simple key:value combination. However, the
    logic of the required code is outside the scope of this book, which focuses on
    Streamlit. The important thing to understand is that any specific function must
    be coded in the correct column section. This is what we see in our web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Text Stats function effect on the screen](img/B21147_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Text Stats function effect on the screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the second basic function: `nexttext` library is also very useful
    for **Processed Text** and this task is quite easy. We can jump to the **Processed
    Text** part of the code and add a very simple instruction, as illustrated in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: The Processed Text expander](img/B21147_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: The Processed Text expander'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `neattext`’s `remove_stopwords()` to get the text we input without
    the stopwords, then cast it to a string (`str`), and save it in a variable named
    `processed_text`; finally, we write the processed text on the screen. This is
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: The Processed Text function effect on the screen](img/B21147_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: The Processed Text function effect on the screen'
  prefs: []
  type: TYPE_NORMAL
- en: The result is nice, but we can do even better – for example, writing on the
    screen the list of the stopwords we removed from the text. Please note that stopwords
    are, let’s say, *common words* that don’t add any information to our original
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add this list into the first column, adding to it a second expander
    exactly below the first one; this is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: The code to extract the stopwords](img/B21147_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The code to extract the stopwords'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we add a second expander `(st.expander()"Stopwords")` and, once again using
    `neattext`, we extract `stopwords (extract_stopwords)` and put them into a variable
    `(stop_w)`, then print this variable on the screen, this time using `st.error`.
    Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.18: \uFEFFStopwords visualization](img/B21147_05_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Stopwords visualization'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything is working fine: **Text Stats** tells us how many stopwords we have,
    **Stop Words List** shows us those stopwords in a list, and **Processed Text**
    shows the text without these items.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a wordcloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the `Wordcloud` library, as suggested in [*Chapter 4*](B21147_04.xhtml#_idTextAnchor045).
    This time, we can add another expander into the second column and write a few
    lines of code, as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Wordcloud plotting code](img/B21147_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Wordcloud plotting code'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few lines of code and a wordcloud will appear! So, we add another expander,
    then create a wordcloud from the original text using the `generate` method, and
    then define a figure with its size. Finally, use `plt` (we already imported `pyplot`)
    to plot the wordcloud without `axis`. We used a longer original text for a richer
    wordcloud. The bigger the words appear, the more often they occur in the text.
    This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Wordcloud on the screen](img/B21147_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Wordcloud on the screen'
  prefs: []
  type: TYPE_NORMAL
- en: Now our **Basic Functions** part really is finished. We have a beautiful text
    that shows the beginning of the section and two columns, and in each of them,
    two expanders, with everything working well and fluidly. It’s time to address
    the advanced features, such as handling tokens, lemmas, and summarization. We
    will discuss these in detail further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing NLP concepts – tokens and lemmas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin exploring **Advanced Features** by creating a simple summarization
    function in Python and Streamlit. Although many packages and libraries offer powerful
    summarization capabilities, this book focuses on web application development rather
    than NLP or summarization.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the summarization function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though the name is self-explanatory, a `summarization` function is a piece
    of code that summarizes a sentence or a text, extracting only the most important
    part of it. This task can be achieved in many ways – some very easy, like the
    one we are proposing just to show how to develop complex web applications with
    Streamlit, and some very sophisticated, leveraging artificial intelligence and
    neural networks. *Figure 5**.21* shows the code where we add the `summarize_text`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: The summarize_text function](img/B21147_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: The summarize_text function'
  prefs: []
  type: TYPE_NORMAL
- en: 'An attention point is that after the NLP packages, we imported two new libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Both of them are Python standard packages; the first one is a set of collections
    that includes a counter and the second is the regular expressions package.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this import activity, we defined the `summarize_text` function by writing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is very simple: it takes text as input, cleans the text by lowercasing
    it, splits everything into words, calculates the frequency of each word (that’s
    why we need the counter), sorts the words according to their frequency, extracts
    the most frequent, and then creates a summary just by joining the top words.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be used inside the expander of the summarization as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: The Summarize expander](img/B21147_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: The Summarize expander'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the expander of `col4`, we are just using the `summarize_text` function
    with the input text (`raw_text`) and showing the result on the screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: Summarize in action](img/B21147_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Summarize in action'
  prefs: []
  type: TYPE_NORMAL
- en: OK, this feature is not the best, but why don’t you try to improve it by yourself?
    For example, you could add some advanced summarization features offered online
    by many companies via API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us learn what tokens and lemmas are.
  prefs: []
  type: TYPE_NORMAL
- en: Tokens and lemmas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Tokens** and **lemmas** are quite classical concepts of NLP. Tokens are the
    smallest *units* of a text and are usually identified with words. So, if we say
    *I write code*, we have three tokens: *I*, *write*, and *code*. Depending on the
    granularity level, things can get more complex because sometimes tokens can be
    identified with single letters. We don’t consider the letters, just the words.
    Please note that even with words, tokenization can be challenging; for example,
    in the sentence *I’m writing code*, we have many tokens – three or four. In the
    first case, *I’m* is a unique token, while in the second case, we can consider
    *I’m* as two words, with two different tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: There is no right or wrong approach but everything depends on the language and
    the use case to be considered. Lemmas are made of so-called *plain text*, so if
    we say *code*, *coding*, or *coder*, we can assume that for all these three words,
    the lemma is just *code*.
  prefs: []
  type: TYPE_NORMAL
- en: For *Tokens&Lemmas*, we can use `spacy`, a very powerful NLP package we imported
    in [*Chapter 4*](B21147_04.xhtml#_idTextAnchor045). Maybe you remember that, in
    [*Chapter 4*](B21147_04.xhtml#_idTextAnchor045), we also downloaded the English
    model used by spaCy (`en_core_web_sm`). Now we are using both the library and
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did for summarization, let’s write a function that takes care of tokens
    and lemmas. We can write, immediately after the summarization function, something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Lemmas and tokens function](img/B21147_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Lemmas and tokens function'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we load in spaCy the English model, then create an `nlp` object
    (an object specific to the `spacy` library) from a text (`doc=nlp(text)`), and
    thanks to this object, we can extract tokens and lemmas (`token.text and token.lemma_`),
    saving them into a dictionary (a key:value data structure) named `allData`. At
    the very end, we return this `allData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Please note the strange `@st.cache_data` at the beginning of our function. It’s
    a *decorator* that tells Streamlit to save in a cache the data managed by this
    function, so unless the function’s input doesn’t change, any time we select the
    function, the response will be very fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check Streamlit’s official documentation about caching ([https://docs.streamlit.io/library/advanced-features/caching](https://docs.streamlit.io/library/advanced-features/caching))
    because it’s really something that can help a lot with response time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Streamlit’s official documentation on caching](img/B21147_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Streamlit’s official documentation on caching'
  prefs: []
  type: TYPE_NORMAL
- en: Our *Tokens&Lemmas* function is ready so we can use it inside our final expander.
  prefs: []
  type: TYPE_NORMAL
- en: Using the text_analysis function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before using the *Tokens&Lemmas* function, we will clean the text a little
    bit; let’s see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: Tokens&Lemmas expander](img/B21147_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Tokens&Lemmas expander'
  prefs: []
  type: TYPE_NORMAL
- en: Before using the `text_analysis` function we just discussed, we will clean the
    text with `neattext`. First of all, we will remove stopwords from it, then we
    will remove the punctuation, and finally, we will remove special characters such
    as `"@"`, `"#"`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will pass this cleaned text to `text_analyzer` and then print the result
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that, since the `text_analyzer` function returns a dictionary –
    or better, a list of dictionaries – we are printing it in the JSON format (`st.json(tandl)`);
    this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27: Tokens&Lemmas on the screen](img/B21147_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: Tokens&Lemmas on the screen'
  prefs: []
  type: TYPE_NORMAL
- en: To make it very clear, tokens are the words of our text after we clean it, while
    lemmas are something called *the normal shape* of the words; for example, we can
    see that the word *spending* has *spend* as a lemma, the token *traveling* has
    *travel* as a lemma, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to test that everything works properly, we can copy some text from
    the web – for example, an extract from some article from the CNN website – and
    put it in our web application. This is the result in the case of an article about
    traveling and journeys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: Text Analysis test](img/B21147_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: Text Analysis test'
  prefs: []
  type: TYPE_NORMAL
- en: The result is quite impressive; please consider that by using only Python, Streamlit,
    and some libraries, we’ve already got a very good-looking, working web application
    that can be used directly online. All we need is a browser!
  prefs: []
  type: TYPE_NORMAL
- en: 'If possible, try to use the application from a device – for example, a tablet
    or smartphone – that is on the same (Wi-Fi) network as the computer from which
    you are coding. This is the great point of these web applications: immediately
    accessible from everywhere! We write code once and can use it from everywhere,
    with no need to install locally, manage patches, manage new versions, and so on.
    Everything stays in one place and it’s accessed by a web browser. In case of changes
    or new versions, we only need to update the code *server*-side, meaning no pain
    for users. Smooth, clean, and easy!'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, here are the screenshots of the code produced up to now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29: Code – part 1](img/B21147_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: Code – part 1'
  prefs: []
  type: TYPE_NORMAL
- en: In part 1, we imported the packages, set the page configuration, and defined
    the `"summarize_text"` and `"``text_analyzer"` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30: Code – part 2](img/B21147_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: Code – part 2'
  prefs: []
  type: TYPE_NORMAL
- en: In part 2, we wrote the `"main"` function that visualizes the main title of
    the application, the menu in the sidebar that uses an `IF` clause to make the
    menu’s voices selection possible, and used some interesting widgets such as columns
    and expanders.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31: Code – part 3](img/B21147_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.31: Code – part 3'
  prefs: []
  type: TYPE_NORMAL
- en: In part 3, we completed the `"main"` function, then created placeholders for
    the **Translation** and **Sentiment Analysis** features, and finally, created
    a beautiful **About** section, leveraging simple markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s underline once again how powerful Streamlit can be, since with a few lines
    of code, we are able to create a complete web application made of both back and
    frontend parts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started completing the decorations by adding a beautiful
    picture in the sidebar. The application should always work correctly but giving
    it a quite beautiful *shape* is always a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'After decoration, we focused on the first voice of the menu: **Text Analysis**.
    **Text Analysis** is a quite complex section and in order to make it clear, good-looking,
    and well-performing, we decided to arrange our web application into different
    sections that cover different topics. The best solution to make this possible
    is to learn how to use columns and expanders. The **Text Analysis** section we
    created has two layers, one for **Basic Functions** and another for **Advanced
    Features**, and by using columns and expanders, we can manage both layers in a
    very effective and elegant way.'
  prefs: []
  type: TYPE_NORMAL
- en: Columns allow us to place everything we want into pillars, while expanders allow
    us to *expand* or *collapse* anything we want to show or hide.
  prefs: []
  type: TYPE_NORMAL
- en: Having good-looking sections and well-arranged topics in our application is
    very important, but an extremely important point is having very well-performing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Code should run in a fast and smooth way, without taking a long time to load
    and show information on the screen. This is the reason why we also had a first
    look at caching in Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to complete the two remaining voices of our
    menu: **Translation** and **Sentiment Analysis**.'
  prefs: []
  type: TYPE_NORMAL
