<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer010">
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Chapter 1: Distributed Computing Primer</h1>
			<p>This chapter introduces you to the <strong class="bold">Distributed Computing</strong> paradigm and shows you how Distributed Computing can help you to easily process very large amounts of data. You will learn about the concept of <strong class="bold">Data Parallel Processing</strong> using the <strong class="bold">MapReduce</strong> paradigm and, finally, learn how Data Parallel Processing can be made more efficient by using an in-memory, unified data processing engine such as Apache Spark.</p>
			<p>Then, you will dive deeper into the architecture and components of Apache Spark along with code examples. Finally, you will get an overview of what's new with the latest 3.0 release of Apache Spark.</p>
			<p>In this chapter, the key skills that you will acquire include an understanding of the basics of the Distributed Computing paradigm and a few different implementations of the Distributed Computing paradigm such as MapReduce and Apache Spark. You will learn about the fundamentals of Apache Spark along with its architecture and core components, such as the Driver, Executor, and Cluster Manager, and how they come together as a single unit to perform a Distributed Computing task. You will learn about Spark's <strong class="bold">Resilient Distributed Dataset</strong> (<strong class="bold">RDD</strong>) API along with higher-order functions and lambdas. You will also gain an understanding of the Spark SQL Engine and its DataFrame and SQL APIs. Additionally, you will implement working code examples. You will also learn about the various components of an Apache Spark data processing program, including transformations and actions, and you will learn about the concept of <strong class="bold">Lazy Evaluation</strong>. </p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introduction Distributed Computing</li>
				<li>Distributed Computing with Apache Spark</li>
				<li>Big data processing with Spark SQL and DataFrames</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>In this chapter, we will be using the Databricks Community Edition to run our code. This can be found at <a href="https://community.cloud.databricks.com">https://community.cloud.databricks.com</a>. </p>
			<p>Sign-up instructions can be found at <a href="https://databricks.com/try-databricks">https://databricks.com/try-databricks</a>. </p>
			<p>The code used in this chapter can be downloaded from <a href="https://github.com/PacktPublishing/Essential-PySpark-for-Data-Analytics/tree/main/Chapter01">https://github.com/PacktPublishing/Essential-PySpark-for-Data-Analytics/tree/main/Chapter01</a>. </p>
			<p>The datasets used in this chapter can be found at <a href="https://github.com/PacktPublishing/Essential-PySpark-for-Data-Analytics/tree/main/data">https://github.com/PacktPublishing/Essential-PySpark-for-Data-Analytics/tree/main/data</a>.</p>
			<p>The original datasets can be taken from their sources, as follows:</p>
			<ul>
				<li>Online Retail: <a href="https://archive.ics.uci.edu/ml/datasets/Online+Retail+II">https://archive.ics.uci.edu/ml/datasets/Online+Retail+II</a><a href="https://archive.ics.uci.edu/ml/datasets/Online+Retail+II%20"/></li>
				<li>Image Data: <a href="https://archive.ics.uci.edu/ml/datasets/Rice+Leaf+Diseases">https://archive.ics.uci.edu/ml/datasets/Rice+Leaf+Diseases</a><a href="https://archive.ics.uci.edu/ml/datasets/Rice+Leaf+Diseases%20"/></li>
				<li>Census Data: <a href="https://archive.ics.uci.edu/ml/datasets/Census+Income">https://archive.ics.uci.edu/ml/datasets/Census+Income</a><a href="https://archive.ics.uci.edu/ml/datasets/Census+Income%20"/></li>
				<li>Country Data: <a href="https://public.opendatasoft.com/explore/dataset/countries-codes/information/">https://public.opendatasoft.com/explore/dataset/countries-codes/information/</a><a href="https://public.opendatasoft.com/explore/dataset/countries-codes/information/%20"/></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Distributed Computing</h1>
			<p>In this section, you<a id="_idIndexMarker000"/> will learn about Distributed Computing, the need for it, and how you can use it to process very large amounts of data in a quick and efficient manner.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Introduction to Distributed Computing</h2>
			<p><strong class="bold">Distributed Computing</strong> is a class <a id="_idIndexMarker001"/>of computing techniques where we use a group of computers as a single unit to solve a computational problem instead of just using a single machine. </p>
			<p>In data analytics, when the amount of data becomes too large to fit in a single machine, we can either split the data into smaller chunks and process it on a single machine iteratively, or we can process the chunks of data on several machines in parallel. While the former gets the job done, it might take longer to process the entire dataset iteratively; the latter technique gets the job completed in a shorter period of time by using multiple machines at once.</p>
			<p>There are different kinds of Distributed Computing techniques; however, for data analytics, one<a id="_idIndexMarker002"/> popular technique is <strong class="bold">Data Parallel Processing</strong>. </p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Data Parallel Processing</h2>
			<p><strong class="bold">Data Parallel Processing</strong> involves <a id="_idIndexMarker003"/>two<a id="_idIndexMarker004"/> main parts:</p>
			<ul>
				<li>The actual data that needs to be processed </li>
				<li>The piece of code or business logic that needs to be applied to the data in order to process it</li>
			</ul>
			<p>We can process large amounts of data by splitting it into smaller chunks and processing them in parallel on several machines. This can be done in two ways:</p>
			<ul>
				<li>First, bring the data to the machine where our code is running.</li>
				<li>Second, take our code to where our data is actually stored.</li>
			</ul>
			<p>One drawback of the first technique is that as our data sizes become larger, the amount of time it takes to move data also increases proportionally. Therefore, we end up spending more time moving data from one system to another and, in turn, negating any efficiency gained by our parallel processing system. We also find ourselves creating multiple copies of data during data replication.</p>
			<p>The second technique is far more efficient because instead of moving large amounts of data, we can easily move a few lines of code to where our data actually resides. This technique of moving code to where the data resides is referred to as Data Parallel Processing. This Data Parallel Processing technique is very fast and efficient, as we save the amount of time that was needed earlier to move and copy data across different systems. One such Data Parallel Processing technique is called the <strong class="bold">MapReduce paradigm</strong>.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Data Parallel Processing using the MapReduce paradigm</h2>
			<p>The <a id="_idIndexMarker005"/>MapReduce <a id="_idIndexMarker006"/>paradigm breaks <a id="_idIndexMarker007"/>down a Data Parallel Processing problem into three main stages:</p>
			<ul>
				<li>The Map stage</li>
				<li>The Shuffle stage</li>
				<li>The Reduce stage</li>
			</ul>
			<p>The <strong class="bold">Map</strong> stage <a id="_idIndexMarker008"/>takes the input dataset, splits it into <strong class="source-inline">(key, value)</strong> pairs, applies some processing on the pairs, and transforms them into another set of <strong class="source-inline">(key, value)</strong> pairs.</p>
			<p>The <strong class="bold">Shuffle</strong> stage <a id="_idIndexMarker009"/>takes the <strong class="source-inline">(key, value)</strong> pairs from the Map stage and shuffles/sorts them so that pairs with the same <em class="italic">key</em> end up together.</p>
			<p>The <strong class="bold">Reduce</strong> stage<a id="_idIndexMarker010"/> takes the resultant <strong class="source-inline">(key, value)</strong> pairs from the Shuffle stage and reduces or aggregates the pairs to produce the final result.</p>
			<p>There can be multiple <strong class="bold">Map</strong> stages followed by multiple <strong class="bold">Reduce</strong> stages. However, a <strong class="bold">Reduce</strong> stage only starts after all of the <strong class="bold">Map</strong> stages have been completed.</p>
			<p>Let's take a look at an example where we want to calculate the counts of all the different words in a text document and apply the <strong class="bold">MapReduce</strong> paradigm to it.</p>
			<p>The following diagram shows how the MapReduce paradigm works in general:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="Images/B16736_01_01.jpg" alt="Figure 1.1 – Calculating the word count using MapReduce&#13;&#10;" width="795" height="423"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Calculating the word count using MapReduce</p>
			<p>The previous <a id="_idIndexMarker011"/>example<a id="_idIndexMarker012"/> works in the <a id="_idIndexMarker013"/>following manner:</p>
			<ol>
				<li>In <em class="italic">Figure 1.1</em>, we have a cluster of three nodes, labeled <strong class="bold">M1</strong>, <strong class="bold">M2</strong>, and <strong class="bold">M3</strong>. Each machine includes a few text files containing several sentences in plain text. Here, our goal is to use MapReduce to count all of the words in the text files.</li>
				<li>We load all the text documents onto the cluster; each machine loads the documents that are local to it.</li>
				<li>The <strong class="bold">Map Stage</strong> splits the text files into individual lines and further splits each line into individual words. Then, it assigns each word a count of <strong class="bold">1</strong> to create a <strong class="source-inline">(word, count)</strong> pair.</li>
				<li>The <strong class="bold">Shuffle Stage</strong> takes the <strong class="source-inline">(word, count)</strong> pairs from the <strong class="bold">Map stage</strong> and shuffles/sorts them so that word pairs with the same keyword end up together.</li>
				<li>The <strong class="bold">Reduce Stage</strong> groups all keywords together and sums their counts to produce the final count of each individual word.</li>
			</ol>
			<p>The MapReduce paradigm was popularized by the <strong class="bold">Hadoop</strong> framework and was pretty popular for processing big data workloads. However, the MapReduce paradigm offers a very low-level API for transforming data and requires users to have proficient knowledge of programming languages such as Java. Expressing a data analytics problem using Map and Reduce is not very intuitive or flexible. </p>
			<p>MapReduce was designed to run on commodity hardware, and since commodity hardware was prone to failures, resiliency to hardware failures was a necessity.  MapReduce achieves resiliency to hardware failures by saving the results of every stage to disk. This round-trip to disk after every stage makes MapReduce relatively slow at processing data because of the slow I/O performance of physical disks in general. To overcome this limitation, the next generation of the MapReduce paradigm was created, which made use of much faster system memory, as opposed to disks, to process data and offered much more flexible APIs to express data transformations. This new framework is called Apache Spark, and you will learn about it in the next section and throughout the<a id="_idIndexMarker014"/> remainder <a id="_idIndexMarker015"/>of this <a id="_idIndexMarker016"/>book. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In Distributed Computing, you will often encounter the term <strong class="bold">cluster</strong>. A cluster is a group of computers all working together as a single unit to solve a computing problem. The primary machine of a cluster is, typically, termed the <strong class="bold">Master Node</strong>, which takes care of the orchestration and management of the cluster, and secondary machines that actually carry out task execution <a id="_idIndexMarker017"/>are called <strong class="bold">Worker Nodes</strong>. A cluster is a key component of any Distributed Computing system, and you will encounter these terms throughout this book.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Distributed Computing with Apache Spark</h1>
			<p>Over the<a id="_idIndexMarker018"/> last<a id="_idIndexMarker019"/> decade, Apache Spark has grown to be the de facto standard for big data processing. Indeed, it is an indispensable tool in the hands of anyone involved with data analytics. </p>
			<p>Here, we will begin with the basics of Apache Spark, including its architecture and components. Then, we will get started with the PySpark programming API to actually implement the previously illustrated word count problem. Finally, we will take a look at what's new <a id="_idIndexMarker020"/>with the latest 3.0 release of Apache <a id="_idIndexMarker021"/>Spark.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Introduction to Apache Spark</h2>
			<p>Apache Spark<a id="_idIndexMarker022"/> is an in-memory, unified data analytics engine that is relatively fast compared to other distributed data processing frameworks.</p>
			<p>It is a unified data analytics framework because it can process different types of big data workloads with a single engine. The different workloads include the following</p>
			<ul>
				<li>Batch data processing</li>
				<li>Real-time data processing</li>
				<li>Machine learning and data science</li>
			</ul>
			<p>Typically, data analytics involves all or a combination of the previously mentioned workloads to solve a single business problem. Before Apache Spark, there was no single framework that could accommodate all three workloads simultaneously. With Apache Spark, various teams involved in data analytics can all use a single framework to solve a single business problem, thus improving communication and collaboration among teams and drastically reducing their learning curve. </p>
			<p>We will explore each of the preceding workloads, in depth, in <a href="B16736_02_Final_JM_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Data Ingestion</em> through to <a href="B16736_08_Final_JM_ePub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a><em class="italic">, Unsupervised Machine Learning,</em> of this book.</p>
			<p>Further, Apache Spark is fast in two aspects:</p>
			<ul>
				<li>It is fast in terms of data processing speed.</li>
				<li>It is fast in terms of development speed.</li>
			</ul>
			<p>Apache Spark has fast job/query execution speeds because it does all of its data processing in memory, and it has other optimizations techniques built-in such as <strong class="bold">Lazy Evaluation</strong>, <strong class="bold">Predicate Pushdown</strong>, and Partition Pruning to name a few. We will go over Spark's optimization techniques in the coming chapters.</p>
			<p>Secondly, Apache Spark provides developers with very high-level APIs to perform basic data processing operations such as <em class="italic">filtering</em>, <em class="italic">grouping</em>, <em class="italic">sorting</em>, <em class="italic">joining</em>, and <em class="italic">aggregating</em>. By using these high-level programming constructs, developers can very easily express their data processing logic, making their development many times faster. </p>
			<p>The core abstraction of Apache Spark, which makes it fast and very expressive for data analytics, is <a id="_idIndexMarker023"/>called an RDD. We will cover this in the next section.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Data Parallel Processing with RDDs</h2>
			<p>An RDD is <a id="_idIndexMarker024"/>the core abstraction of the Apache Spark <a id="_idIndexMarker025"/>framework. Think of an RDD as any kind of immutable data structure that is typically found in a programming language but one that resides in the memory of several machines instead of just one. An RDD consists of partitions, which are logical divisions of an RDD, with a few of them residing on each machine. </p>
			<p>The following diagram helps explain the concepts of an RDD and its partitions:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="Images/B16736_01_02.jpg" alt="Figure 1.2 – An RDD&#13;&#10;" width="656" height="305"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – An RDD</p>
			<p>In the previous diagram, we have a cluster of three machines or nodes. There are three RDDs on the cluster, and each RDD is divided into partitions. Each node of the cluster contains a few partitions of an individual RDD, and each RDD is distributed among several nodes of the cluster by means of partitions.</p>
			<p>The RDD abstractions are accompanied by a set of high-level functions that can operate on the RRDs <a id="_idIndexMarker026"/>in order to manipulate the data stored within <a id="_idIndexMarker027"/>the partitions. These functions are called <strong class="bold">higher-order functions</strong>, and you will learn about them in the following section.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Higher-order functions</h2>
			<p>Higher-order <a id="_idIndexMarker028"/>functions manipulate RDDs and help us write business logic to transform data stored within the partitions. Higher-order functions accept other functions as parameters, and these inner functions help us define the actual business logic that transforms data and is applied to each partition of the RDD in parallel. These inner functions passed as parameters to the higher-order functions<a id="_idIndexMarker029"/> are called <strong class="bold">lambda functions</strong> or <strong class="bold">lambdas</strong>.</p>
			<p>Apache Spark comes with several higher-order functions such as <strong class="source-inline">map</strong>, <strong class="source-inline">flatMap</strong>, <strong class="source-inline">reduce</strong>, <strong class="source-inline">fold</strong>, <strong class="source-inline">filter</strong>, <strong class="source-inline">reduceByKey</strong>, <strong class="source-inline">join</strong>, and <strong class="source-inline">union</strong> to name a few. These functions are high-level functions and help us express our data manipulation logic very easily.</p>
			<p>For example, consider our previously illustrated word count example. Let's say you wanted to read a text file as an RDD and split each word based on a delimiter such as a whitespace. This is what code expressed in terms of an RDD and higher-order function would look like:</p>
			<p class="source-code">lines = sc.textFile("/databricks-datasets/README.md")</p>
			<p class="source-code">words = lines.flatMap(lambda s: s.split(" "))</p>
			<p class="source-code">word_tuples = words.map(lambda s: (s, 1))</p>
			<p>In the previous code snippet, the following occurs:</p>
			<ol>
				<li value="1">We are loading a text file using the built-in <strong class="source-inline">sc.textFile()</strong> method, which loads all text files at the specified location into the cluster memory, splits them into individual lines, and returns an RDD of lines or strings.</li>
				<li>We then apply the <strong class="source-inline">flatMap()</strong> higher-order function to the new RDD of lines and supply it with a function that instructs it to take each line and split it based on a white space. The lambda function that we pass to <strong class="source-inline">flatMap()</strong> is simply an anonymous function that takes one parameter, an individual line of <strong class="source-inline">StringType</strong>, and returns a list of words. Through the <strong class="source-inline">flatMap()</strong> and <strong class="source-inline">lambda()</strong> functions, we are able to transform an RDD of lines into an RDD of words.</li>
				<li>Finally, we use the <strong class="source-inline">map()</strong> function to assign a count of <strong class="source-inline">1</strong> to every individual word. This is pretty easy and definitely more intuitive compared to developing a MapReduce application using the Java programming language.</li>
			</ol>
			<p>To summarize<a id="_idIndexMarker030"/> what you have learned, the primary construct of the Apache Spark framework is an RDD. An RDD consists of <em class="italic">partitions</em> distributed across individual nodes of a cluster. We use special functions called higher-order functions to operate on the RDDs and transform the RDDs according to our business logic. This business logic is passed along to the Worker Nodes via higher-order functions in the form of lambdas or anonymous functions.</p>
			<p>Before we dig deeper into the inner workings of higher-order functions and lambda functions, we need to understand the architecture of the Apache Spark framework and the components of a typical Spark Cluster. We will do this in the following section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <em class="italic">Resilient</em> part of an RDD comes from the fact that every RDD knows its lineage. At any given point in time, an RDD has information of all the individual operations performed on it, going back all the way to the data source itself. Thus, if any Executors are lost due to any failures and one or more of its partitions are lost, it can easily recreate those partitions from the source data making use of the lineage information, thus making it <em class="italic">Resilient</em> to failures.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Apache Spark cluster architecture</h2>
			<p>A typical Apache<a id="_idIndexMarker031"/> Spark cluster consists of three major components, namely, the Driver, a few Executors, and the Cluster Manager:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/B16736_01_03.jpg" alt="Figure 1.3 – Apache Spark Cluster components&#13;&#10;" width="1008" height="496"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Apache Spark Cluster components</p>
			<p>Let's examine<a id="_idIndexMarker032"/> each of these components a little closer.</p>
			<h3>Driver – the heart of a Spark application</h3>
			<p>The Spark Driver is a<a id="_idIndexMarker033"/> Java Virtual Machine process and is the core part of a Spark application. It is responsible for user application code declarations, along with the creation of RDDs, DataFrames, and datasets. It is also responsible for coordinating with and running code on the Executors and creating and scheduling tasks on the Executors. It is even responsible for relaunching Executors after a failure and finally returning any data requested back to the client or the user. Think of a Spark Driver as the <strong class="source-inline">main()</strong> program of any Spark application. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The Driver is the single point of failure for a Spark cluster, and the entire Spark application fails if the driver fails; therefore, different Cluster Managers implement different strategies to make the Driver highly available.</p>
			<h3>Executors – the actual workers</h3>
			<p>Spark Executors are <a id="_idIndexMarker034"/>also Java Virtual Machine processes, and they are responsible for running operations on RDDs that actually transform data. They can cache data partitions locally and return the processed data back to the Driver or write to persistent storage. Each Executor runs operations on a set of partitions of an RDD in parallel.</p>
			<h3>Cluster Manager – coordinates and manages cluster resources</h3>
			<p>The <strong class="bold">Cluster Manager</strong> is <a id="_idIndexMarker035"/>a process that runs centrally on the cluster and is responsible for providing resources requested by the Driver. It also monitors the Executors regarding task progress and their status. Apache Spark comes with its own Cluster Manager, which is referred to as the Standalone Cluster Manager, but it also supports other popular Cluster Managers such as YARN or Mesos. Throughout this book, we will be using Spark's built-in Standalone Cluster Manager. </p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Getting started with Spark</h2>
			<p>So far, we have <a id="_idIndexMarker036"/>learnt about Apache Spark's core data structure, called RDD, the functions used to manipulate RDDs, called higher-order functions, and the components of an Apache Spark cluster. You have also seen a few code snippets on how to use higher-order functions.</p>
			<p>In this section, you will put your knowledge to practical use and write your very first Apache Spark program, where you will use Spark's Python<a id="_idIndexMarker037"/> API called <strong class="bold">PySpark</strong> to create a word count application. However, first, we need a few things to get started:</p>
			<ul>
				<li>An Apache Spark cluster</li>
				<li>Datasets</li>
				<li>Actual code for the word count application</li>
			</ul>
			<p>We will use<a id="_idIndexMarker038"/> the free <strong class="bold">Community Edition of Databricks</strong> to create our Spark cluster. The code used can be found via the GitHub link that was mentioned at the beginning of this chapter. The links for the required resources can be found in the <em class="italic">Technical requirements</em> section toward the beginning of the chapter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although we are using Databricks Spark Clusters in this book, the provided code can be executed on any Spark cluster running Spark 3.0, or higher, as long as data is provided at a location accessible by your Spark cluster.</p>
			<p>Now that you have gained an understanding of Spark's core concepts such as RDDs, higher-order functions, lambdas, and Spark's architecture, let's implement your very first Spark application using the following code: </p>
			<p class="source-code">lines = sc.textFile("/databricks-datasets/README.md")</p>
			<p class="source-code">words = lines.flatMap(lambda s: s.split(" "))</p>
			<p class="source-code">word_tuples = words.map(lambda s: (s, 1))</p>
			<p class="source-code">word_count = word_tuples.reduceByKey(lambda x, y:  x + y)</p>
			<p class="source-code">word_count.take(10)</p>
			<p class="source-code">word_count.saveAsTextFile("/tmp/wordcount.txt")</p>
			<p>In the previous <a id="_idIndexMarker039"/>code snippet, the following takes place:</p>
			<ol>
				<li value="1">We load a text file using the built-in <strong class="source-inline">sc.textFile()</strong> method, which reads all of the text files at the specified location, splits them into individual lines, and returns an RDD of lines or strings.</li>
				<li>Then, we apply the <strong class="source-inline">flatMap()</strong> higher-order function to the RDD of lines and supply it with a function that instructs it to take each line and split it based on a white space. The lambda function that we pass to <strong class="source-inline">flatMap()</strong> is simply an anonymous function that takes one parameter, a line, and returns individual words as a list. By means of the <strong class="source-inline">flatMap()</strong> and <strong class="source-inline">lambda()</strong> functions, we are able to transform an RDD of lines into an RDD of words.</li>
				<li>Then, we use the <strong class="source-inline">map()</strong> function to assign a count of <strong class="source-inline">1</strong> to every individual word.</li>
				<li>Finally, we use the <strong class="source-inline">reduceByKey()</strong> higher-order function to sum up the count of similar words occurring multiple times.</li>
				<li>Once the counts have been calculated, we make use of the <strong class="source-inline">take()</strong> function to display a sample of the final word counts.</li>
				<li>Although displaying a sample result set is usually helpful in determining the correctness of our code, in a big data setting, it is not practical to display all the results on to the console. So, we make use of the <strong class="source-inline">saveAsTextFile()</strong> function to persist our finals results in persistent storage.<p class="callout-heading">Important note</p><p class="callout">It is not recommended that you display the entire result set onto the console using commands such as <strong class="source-inline">take()</strong> or <strong class="source-inline">collect()</strong>. It could even be outright dangerous to try and display all the data in a big data setting, as it could try to bring way too much data back to the driver and<a id="_idTextAnchor026"/> cause the driver to fail with an <strong class="source-inline">OutOfMemoryError</strong>, which, in turn, causes<a id="_idIndexMarker040"/> the entire application to fail.</p><p class="callout">Therefore, it is recommended that you use <strong class="source-inline">take()</strong> with a very small result set, and use <strong class="source-inline">collect()</strong> only when you are confident that the amount of data returned is, indeed, very small.</p></li>
			</ol>
			<p>Let's dive deeper into the following line of code in order to understand the inner workings of lambdas and how they implement Data Parallel Processing along with higher-order functions:</p>
			<p class="source-code">words = lines.flatMap(lambda s: s.split(" "))</p>
			<p>In the previous code snippet, the <strong class="source-inline">flatMmap()</strong> higher-order function bundles the code present in the lambda and sends it over a network to the Worker Nodes, using a process called <em class="italic">serialization</em>. This <em class="italic">serialized lambda</em> is then sent out to every executor, and each executor, in turn, applies this lambda to individual RDD partitions in parallel.  </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Since higher-order functions need to be able to serialize the lambdas in order to send your code to the Executors. The lambda functions need to be <strong class="source-inline">serializable</strong>, and failing this, you might encounter a <em class="italic">Task not serializable</em> error.</p>
			<p>In summary, higher-order functions are, essentially, transferring your data transformation code in the form of serialized lambdas to your data in RDD partitions. Therefore, instead of moving data to where the code is, we are actually moving our code to where data is situated, which is the exact definition of Data Parallel Processing, as we learned earlier in this chapter.</p>
			<p>Thus, Apache Spark along with its RDDs and higher-order functions implements an in-memory version of the Data Parallel Processing paradigm. This makes Apache Spark fast and efficient at big data processing in a Distributed Computing setting.</p>
			<p>The RDD abstraction of Apache Spark definitely offers a higher level of programming API compared to MapReduce, but it still requires some level of comprehension of the functional programming style to be able to express even the most common types of data transformations. To overcome this challenge, Spark's already existing SQL engine was expanded, and another abstraction, called the DataFrame, was added on top of RDDs. This <a id="_idIndexMarker041"/>makes data processing much easier and more familiar for data scientists and data analysts. The following section will explore the DataFrame and SQL API of the Spark SQL engine.  </p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor027"/>Big data processing with Spark SQL and DataFrames</h1>
			<p>The Spark<a id="_idIndexMarker042"/> SQL <a id="_idIndexMarker043"/>engine supports two types of APIs, namely, DataFrame and Spark SQL. Being higher-level abstractions than RDDs, these are far more intuitive and even more expressive. They come with many more data transformation functions and utilities that you might already be familiar with as a data engineer, data analyst, or a data scientist. </p>
			<p>Spark SQL and DataFrame APIs offer a low barrier to entry into big data processing. They allow you to use your existing knowledge and skills of data analytics and allow you to easily get started with Distributed Computing. They help you get started with processing data at scale, without having to deal with any of the complexities that typically come along with Distributed Computing frameworks.</p>
			<p>In this section, you will learn how to use both DataFrame and Spark SQL APIs to get started with your scalable data processing journey. Notably, the concepts learned here will be <a id="_idIndexMarker044"/>useful and <a id="_idIndexMarker045"/>are required throughout this book.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Transforming data with Spark DataFrames</h2>
			<p>Starting <a id="_idIndexMarker046"/>with Apache Spark 1.3, the Spark SQL engine was added as a layer on top of the RDD API and expanded to every component of Spark, to offer an even easier to use and familiar API for developers. Over the years, the Spark SQL engine and its DataFrame and SQL APIs have grown to be even more robust and have become the de facto and recommended standard for using Spark in general. Throughout this book, you will be exclusively using either DataFrame operations or Spark SQL statements for all your data processing needs, and you will rarely ever use the RDD API.</p>
			<p>Think of a Spark DataFrame as a Pandas DataFrame or a relational database table with rows and named columns. The only difference is that a Spark DataFrame resides in the memory of several machines instead of a single machine. The following diagram shows a Spark DataFrame with three columns distributed across three worker machines:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/B16736_01_04.jpg" alt="Figure 1.4 – A distributed DataFrame&#13;&#10;" width="1154" height="506"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – A distributed DataFrame</p>
			<p>A Spark DataFrame is also an immutable data structure such as an RDD, consisting of rows and named columns, where each individual column can be of any type. Additionally, DataFrames come with operations that allow you to manipulate data, and we generally refer to these set of<a id="_idIndexMarker047"/> operations as <strong class="bold">Domain Specific Language</strong> (<strong class="bold">DSL</strong>). Spark DataFrame operations can be grouped into two main categories, namely, transformations and actions, which we will explore in the following sections.</p>
			<p>One advantage of using DataFrames or Spark SQL over the RDD API is that the Spark SQL engine comes with a built-in query <a id="_idIndexMarker048"/>optimizer called <strong class="bold">Catalyst</strong>. This Catalyst optimizer analyzes user code, along with any available statistics on the data, to generate the best possible execution plan for the query. This query plan is further converted into Java bytecode, which runs natively inside the Executor's Java JVM. This happens irrespective of the programming language used, thus making any code processed via the Spark SQL engine equally<a id="_idIndexMarker049"/> performant in most cases, whether it be written using Scala, Java, Python, R, or SQL.</p>
			<h3>Transformations</h3>
			<p><strong class="bold">Transformations</strong> are <a id="_idIndexMarker050"/>operations performed on DataFrames that manipulate the data in the DataFrame and result in another DataFrame. Some examples of transformations are <strong class="source-inline">read</strong>, <strong class="source-inline">select</strong>, <strong class="source-inline">where</strong>, <strong class="source-inline">filter</strong>, <strong class="source-inline">join</strong>, and <strong class="source-inline">groupBy</strong>.</p>
			<h3>Actions</h3>
			<p><strong class="bold">Actions</strong> are <a id="_idIndexMarker051"/>operations that actually cause a result to be calculated and either printed onto the console or, more practically, written back to a storage location. Some examples of actions include <strong class="source-inline">write</strong>, <strong class="source-inline">count</strong>, and <strong class="source-inline">show</strong>.</p>
			<h3>Lazy evaluation</h3>
			<p>Spark<a id="_idIndexMarker052"/> transformations are lazily evaluated, which means that transformations are not evaluated immediately as they are declared, and data is not manifested in memory until an action is called. This has a few advantages, as it gives the Spark optimizer an opportunity to evaluate all of your transformations until an action is called and generate the most optimal plan of execution to get the best performance and efficiency out of your code. </p>
			<p>The advantage of Lazy Evaluation coupled with Spark's Catalyst optimizer is that you can solely focus on expressing your data transformation logic and not worry too much about arranging your transformations in a specific order to get the best performance and efficiency out of your code. This helps you be more productive at your tasks and not become perplexed by the complexities of a new framework. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Compared to Pandas DataFrames, Spark DataFrames are not manifested in memory as soon as they are declared. They are only manifested in memory when an action is called. Similarly, DataFrame operations don't necessarily run in the order you specified them to, as Spark's Catalyst optimizer generates the best possible execution plan for you, sometimes even combining a few operations into a single unit.</p>
			<p>Let's take the<a id="_idIndexMarker053"/> word count example that we previously implemented using the RDD API and try to implement it using the DataFrame DSL:</p>
			<p class="source-code">from pyspark.sql.functions import split, explode</p>
			<p class="source-code">linesDf = spark.read.text("/databricks-datasets/README.md")</p>
			<p class="source-code">wordListDf = linesDf.select(split("value", " ").alias("words"))</p>
			<p class="source-code">wordsDf = wordListDf.select(explode("words").alias("word"))</p>
			<p class="source-code">wordCountDf = wordsDf.groupBy("word").count()</p>
			<p class="source-code">wordCountDf.show()</p>
			<p class="source-code">wordCountDf.write.csv("/tmp/wordcounts.csv")</p>
			<p>In the previous code snippet, the following occurs:</p>
			<ol>
				<li value="1">First, we import a few functions from the PySpark SQL function library, namely, split and explode.</li>
				<li>Then, we read text using the <strong class="source-inline">SparkSession</strong> <strong class="source-inline">read.text()</strong> method, which creates a DataFrame of lines of <strong class="source-inline">StringType</strong>.</li>
				<li>We then use the <strong class="source-inline">split()</strong> function to separate out every line into its individual words; the result is a DataFrame with a single column, named <strong class="source-inline">value</strong>, which is actually a list of words.</li>
				<li>Then, we use the <strong class="source-inline">explode()</strong> function to separate the list of words in each row out to every word on a separate row; the result is a DataFrame with a column labeled <strong class="source-inline">word</strong>.</li>
				<li>Now we are finally ready to count our words, so we group our words by the <strong class="source-inline">word</strong> column and count individual occurrences of each word. The final result is a DataFrame of two columns, that is, the actual <strong class="source-inline">word</strong> and its <strong class="source-inline">count</strong>.</li>
				<li>We can view a sample of the result using the <strong class="source-inline">show()</strong> function, and, finally, save our results in persistent storage using the <strong class="source-inline">write()</strong> function.</li>
			</ol>
			<p>Can you guess<a id="_idIndexMarker054"/> which operations are actions? If you guessed <strong class="source-inline">show()</strong> or <strong class="source-inline">write()</strong>, then you are correct. Every other function, including <strong class="source-inline">select()</strong> and <strong class="source-inline">groupBy()</strong>, are transformations and will not induce the Spark job into action.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although the <strong class="source-inline">read()</strong> function is a transformation, sometimes, you will notice that it will actually execute a Spark job. The reason for this is that with certain structured and semi-structured data formats, Spark will try and infer the schema information from the underlying files and will process a small subset of the actual files to do this.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Using SQL on Spark </h2>
			<p>SQL is an<a id="_idIndexMarker055"/> expressive<a id="_idIndexMarker056"/> language for ad hoc data exploration and business intelligence types of queries. Because it is a very high-level declarative programming language, the user can simply focus on the input and output and what needs to be done to the data and not worry too much about the programming complexities of how to actually implement the logic. Apache Spark's SQL engine also has a SQL language API along with the DataFrame and Dataset APIs. </p>
			<p>With Spark 3.0, Spark SQL is now compliant with ANSI standards, so if you are a data analyst who is familiar with another SQL-based platform, you should be able to get started with Spark SQL with minimal effort. </p>
			<p>Since DataFrames and Spark SQL utilize the same underlying Spark SQL engine, they are completely interchangeable, and it is often the case that users intermix DataFrame DSL with Spark SQL statements for parts of the code that are expressed easily with SQL.</p>
			<p>Now, let's rewrite our word count program using Spark SQL. First, we create a table specifying our text file to be a CSV file with a white space as the delimiter, a neat trick to read each <a id="_idIndexMarker057"/>line of the text file, and also split each file into individual words <a id="_idIndexMarker058"/>all at once:</p>
			<p class="source-code">CREATE TABLE word_counts (word STRING)</p>
			<p class="source-code">USING csv</p>
			<p class="source-code">OPTIONS("delimiter"=" ")</p>
			<p class="source-code">LOCATION "/databricks-datasets/README.md"</p>
			<p>Now that we have a table of a single column of words, we just need to <strong class="source-inline">GROUP BY</strong> the <strong class="source-inline">word</strong> column and do a <strong class="source-inline">COUNT()</strong> operation to get our word counts:</p>
			<p class="source-code">SELECT word, COUNT(word) AS count</p>
			<p class="source-code">FROM word_counts</p>
			<p class="source-code">GROUP BY word</p>
			<p>Here, you can observe that solving the same business problem became progressively easier from using MapReduce to RRDs, to DataFrames and Spark SQL. With each new release, Apache Spark has been adding many higher-level programming abstractions, data transformation and utility functions, and other optimizations. The goal has been to enable data engineers, data scientists, and data analysts to focus their time and energy on solving the actual business problem at hand and not worry about complex programming abstractions or system architectures. </p>
			<p>Apache Spark's latest major release of version 3 has many such enhancements that make the life of a data analytics professional much easier. We will discuss the most prominent of these enhancements in the following section.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>What's new in Apache Spark 3.0?</h2>
			<p>There are many <a id="_idIndexMarker059"/>new and notable features in Apache Spark 3.0; however, only a few are mentioned here, which you will find very useful during the beginning phases of your data analytics journey:</p>
			<ul>
				<li><strong class="bold">Speed</strong>: Apache Spark 3.0 is orders of magnitude faster than its predecessors. Third-party benchmarks have put Spark 3.0 to be anywhere from 2 to 17 times faster for certain types of workloads.</li>
				<li><strong class="bold">Adaptive Query Execution</strong>: The Spark SQL engine generates a few logical and physical query execution plans based on user code and any previously collected statistics on the source data. Then, it tries to choose the most optimal execution plan. However, sometimes, Spark is not able to generate the best possible execution plan either because the statistics are either stale or non-existent, leading to suboptimal performance. With adaptive query execution, Spark is able to dynamically adjust the execution plan during runtime and give the best possible query performance.</li>
				<li><strong class="bold">Dynamic Partition Pruning</strong>: Business intelligence systems and data warehouses follow a data modeling<a id="_idIndexMarker060"/> technique called <strong class="bold">Dimensional Modeling</strong>, where data is stored in a central fact table surrounded by a few dimensional tables. Business intelligence types of queries utilizing these dimensional models involve queries with multiple joins between the dimension and fact tables, along with various filter conditions on the dimension tables. With dynamic partition pruning, Spark is able to filter out any fact table partitions based on the filters applied on these dimensions, resulting in less data being read into the memory, which, in turn, results in better query performance.</li>
				<li><strong class="bold">Kubernetes Support</strong>: Earlier, we learned that Spark comes with its own Standalone Cluster Manager and can also work with other popular resource managers such as YARN and Mesos. Now Spark 3.0 natively supports <strong class="bold">Kubernetes</strong>, which is a popular open source framework for running and managing parallel container services.</li>
			</ul>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor031"/>Summary</h1>
			<p>In this chapter, you learned the concept of Distributed Computing. We discovered why Distributed Computing has become very important, as the amount of data being generated is growing rapidly, and it is not practical or feasible to process all your data using a single specialist system.</p>
			<p>You then learned about the concept of Data Parallel Processing and reviewed a practical example of its implementation by means of the MapReduce paradigm.</p>
			<p>Then, you were introduced to an in-memory, unified analytics engine called Apache Spark, and learned how fast and efficient it is for data processing. Additionally, you learned it is very intuitive and easy to get started for developing data processing applications. You also got to understand the architecture and components of Apache Spark and how they come together as a framework.</p>
			<p>Next, you came to understand RDDs, which are the core abstraction of Apache Spark, how they store data on a cluster of machines in a distributed manner, and how you can leverage higher-order functions along with lambda functions to implement Data Parallel Processing via RDDs.</p>
			<p>You also learned about the Spark SQL engine component of Apache Spark, how it provides a higher level of abstraction than RRDs, and that it has several built-in functions that you might already be familiar with. You learned to leverage the DataFrame DSL to implement your data processing business logic in an easier and more familiar way. You also learned about Spark's SQL API, how it is ANSI SQL standards-compliant, and how it allows you to seamlessly perform SQL analytics on large amounts of data efficiently.</p>
			<p>You also came to know some of the prominent improvements in Apache Spark 3.0, such as adaptive query execution and dynamic partition pruning, which help make Spark 3.0 much faster in performance than its predecessors.</p>
			<p>Now that you have learned the basics of big data processing with Apache Spark, you are ready to embark on a data analytics journey using Spark. A typical data analytics journey starts with acquiring raw data from various source systems, ingesting it into a historical storage component such as a data warehouse or a data lake, then transforming the raw data by cleansing, integrating, and transforming it to get a single source of truth. Finally, you can gain actionable business insights through clean and integrated data, leveraging descriptive and predictive analytics. We will cover each of these aspects in the subsequent chapters of this book, starting with the process of data cleansing and ingestion in the following chapter.</p>
		</div>
	</div></body></html>