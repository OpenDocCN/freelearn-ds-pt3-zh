- en: Adding Interactivity and Animating Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a book focusing on the use of Matplotlib through elaborate examples, we opted
    to defer or simplify our discussion of the internals. For those of you who want
    to understand the nuts and bolts that make Matplotlib tick, you are advised to
    read *Mastering matplotlib* by Duncan M. McGreggor. At some point during our Matplotlib
    journey, it becomes inevitable for us to discuss more about backends, which turn
    plotting commands to graphics. These backends can be broadly classified as non-interactive
    or interactive. We will give examples that are pertinent to each backend class.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib was not designed as an animation package from the get-go, thus it
    will appear sluggish in some advanced usages. For animation-centric applications,
    PyGame is a very good alternative ([https://www.pygame.org](https://www.pygame.org));
    it supports OpenGL- and Direct3D-accelerated graphics for the ultimate speed in
    animating objects. Nevertheless, Matplotlib has acceptable performance most of
    the time, and we will guide you through the steps to create animations that are
    more engaging than static plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in this chapter will be based on unemployment rates and earnings
    by educational attainment (2016), available from `data.gov` and curated by the
    Bureau of Labor Statistics, U.S. Department of Labor. Here is the outline of this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Scraping information from websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-interactive backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interactive backends: Tkinter, Jupyter, and Plot.ly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an animated plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting an animation as a video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scraping information from websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Governments or jurisdictions around the world are increasingly embracing the
    importance of open data, which aims to increase citizen involvement and informs
    about decision making, making policies more open to public scrutiny. Some examples
    of open data initiatives around the world include `data.gov` (United States of
    America), `data.gov.uk` (United Kingdom), and `data.gov.hk` (Hong Kong).
  prefs: []
  type: TYPE_NORMAL
- en: These data portals often provide Application Programming Interfaces (APIs; see
    [Chapter 7](7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml), *Visualizing Online Data*, for
    more details) for programmatic access to data. However, APIs are not available
    for some datasets; hence, we resort to good old web scraping techniques to extract
    information from websites.
  prefs: []
  type: TYPE_NORMAL
- en: BeautifulSoup ([https://www.crummy.com/software/BeautifulSoup/](https://www.crummy.com/software/BeautifulSoup/))
    is an incredibly useful package used to scrape information from websites. Basically,
    everything marked with an HTML tag can be scraped with this wonderful package,
    from text, links, tables, and styles, to images. Scrapy is also a good package
    for web scraping, but it is more like a framework for writing powerful web crawlers.
    So, if you just need to fetch a table from a page, BeautifulSoup offers simpler
    procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use BeautifulSoup version 4.6 throughout this chapter. To install
    BeautifulSoup 4, we can once again rely on PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The data on USA unemployment rates and earnings by educational attainment (2016)
    is available at [https://www.bls.gov/emp/ep_table_001.htm](https://www.bls.gov/emp/ep_table_001.htm).
    Currently, BeautifulSoup does not handle HTML requests. So we need to use the `urllib.request`
    or `requests` package to fetch a web page for us. Of the two options, the `requests`
    package is probably easier to use, due to its higher-level HTTP client interface.
    If `requests` is not available on your system, you can install it through PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the web page before we write the web scraping code. If
    we use the Google Chrome browser to visit the Bureau of Labor Statistics website,
    we can inspect the HTML code corresponding to the table we need by right-clicking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9361cdab-a87a-426c-9a2e-8528e99a4a8e.png)'
  prefs: []
  type: TYPE_IMG
- en: A pop-up window for code inspection will be shown, which allows us to read the
    code for each of the elements on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb44dc05-1da5-461e-8b1f-40c989b5beec.png)'
  prefs: []
  type: TYPE_IMG
- en: More specifically, we can see that the column names are defined in the `<thead>...</thead>`
    section, while the table content is defined in the `<tbody>...</tbody>` section.
  prefs: []
  type: TYPE_NORMAL
- en: In order to instruct BeautifulSoup to scrape the information we need, we need
    to give clear directions to it. We can right-click on the relevant section in
    the code inspection window and copy the unique identifier in the format of the
    CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68310554-690c-47c0-8ff6-dfe7d929a683.png)**Cascading Style Sheets**
    (**CSS**) selectors were originally designed for applying element-specific styles
    to a website. For more information, visit the following page: [https://www.w3schools.com/cssref/css_selectors.asp](https://www.w3schools.com/cssref/css_selectors.asp).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to get the CSS selectors for `thead` and `tbody`, and use the `BeautifulSoup.select()`
    method to scrape the respective HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the following output from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to find all instances of `<th>...</th>` in `<thead>...</thead>`,
    which contains the name of each column. We will build a dictionary of lists with
    headers as keys to hold the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we parse the remaining rows (`<tr>...</tr>`) from the body (`<tbody>...</tbody>`)
    of the table and convert the data into a pandas DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|  | **Educational attainment** | **Median usual weekly earnings ($)** | **Unemployment
    rate (%)** |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Doctoral degree | 1664.0 | 1.6 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Professional degree | 1745.0 | 1.6 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Master''s degree | 1380.0 | 2.4 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Bachelor''s degree | 1156.0 | 2.7 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Associate''s degree | 819.0 | 3.6 |'
  prefs: []
  type: TYPE_TB
- en: We have now fetched the HTML table and formatted it as a structured pandas DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Non-interactive backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for plotting graphs is considered the frontend in Matplotlib terminology.
    We first mentioned backends in [Chapter 6](bf358e3c-35c4-47c5-9683-7378dfa01c4e.xhtml),
    *Hello Plotting World!*, when we were talking about output formats. In reality,
    Matplotlib backends differ much more than just in the support of graphical formats.
    Backends handle so many things behind the scenes! And that determines the support
    for plotting capabilities. For example, LaTeX text layout is only supported by
    AGG, PDF, PGF, and PS backends.
  prefs: []
  type: TYPE_NORMAL
- en: We have been using non-interactive backends so far, which include AGG, Cairo,
    GDK, PDF, PGF, PS, and SVG. Most of these backends work without extra dependencies,
    yet Cairo and GDK would require the Cairo graphics library or GIMP Drawing Kit,
    respectively, to work.
  prefs: []
  type: TYPE_NORMAL
- en: Non-interactive backends can be further classified into two groups--vector and
    raster. Vector graphics describe images in terms of points, paths, and shapes
    that are calculated using mathematical formulas. A vector graphic will always
    appear smooth, irrespective of scale and its size is usually much smaller than
    its raster counterpart. PDF, PGF, PS, and SVG backends belong to the "vector"
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raster graphics describe images in terms of a finite number of tiny color blocks
    (pixels). So, if we zoom in enough, we start to see a blurry image, or in other
    words, pixelation. By increasing the resolution or **Dots Per Inch** (**DPI**)
    of the image, we are less likely to observe pixelation. AGG, Cairo, and GDK belong
    to this group of backends. This table summarizes the key functionalities and differences
    among the non-interactive backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Backend** | **Vector/Raster** | **Output formats** |'
  prefs: []
  type: TYPE_TB
- en: '| Agg | Raster | PNG |'
  prefs: []
  type: TYPE_TB
- en: '| Cairo | Vector/Raster | PDF, PNG, PS, or SVG |'
  prefs: []
  type: TYPE_TB
- en: '| PDF | Vector | PDF |'
  prefs: []
  type: TYPE_TB
- en: '| PGF | Vector | PDF or PGF |'
  prefs: []
  type: TYPE_TB
- en: '| PS | Vector | PS |'
  prefs: []
  type: TYPE_TB
- en: '| SVG | Vector | SVG |'
  prefs: []
  type: TYPE_TB
- en: '| GDK (Deprecated in Matplotlib 2.0) | Raster | PNG, JPEG, or TIFF |'
  prefs: []
  type: TYPE_TB
- en: 'Normally, we don''t need to manually select a backend, as the default choice
    would work great for most tasks. On the other hand, we can specify a backend through
    the `matplotlib.use()` method before importing `matplotlib.pyplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3e69075d-cffe-4138-80be-7f00b8b55f89.png)'
  prefs: []
  type: TYPE_IMG
- en: Interactive backends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib can build interactive figures that are far more engaging for readers.
    Sometimes, a plot might be overwhelmed with graphical elements, making it hard
    to discern individual data points. On other occasions, some data points may appear
    so similar that it becomes hard to spot the differences with the naked eye. An
    interactive plot can address these two scenarios by allowing us to zoom in, zoom
    out, pan, and explore the plot in the way we want.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of interactive backends, plots in Matplotlib can be embedded
    in Graphical User Interface (GUI) applications. By default, Matplotlib supports
    the pairing of the Agg raster graphics renderer with a wide variety of GUI toolkits,
    including wxWidgets (Wx), GIMP Toolkit (GTK+), Qt, and Tkinter (Tk). As Tkinter
    is the de facto standard GUI for Python, which is built on top of Tcl/Tk, we can
    create an interactive plot just by calling `plt.show()` in a standalone Python
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter-based backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to copy the following code to a separate text file and name it `chapter6_gui.py`.
    After that, type `python chapter6_gui.py` in your terminal (Mac/Linux) or Command
    Prompt (Windows). If you are unsure about how to open a terminal or Command Prompt,
    refer to [Chapter 6](bf358e3c-35c4-47c5-9683-7378dfa01c4e.xhtml), *Hello Plotting
    World!*, for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We see a pop-up window similar to the following. We can pan, zoom to selection,
    configure subplot margins, save, and go back and forth between different views
    by clicking on the buttons on the bottom toolbar. If we put our mouse over the
    plot, we can also observe the exact coordinates in the bottom-right corner. This
    feature is extremely useful for dissecting data points that are close to each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/520c0399-4fbd-4784-a3ed-3190e96dd92d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we are going to extend the application by adding a radio button widget
    on top of the figure, such that we can switch between the display of weekly earnings
    or unemployment rates. The radio button can be found in `matplotlib.widgets`,
    and we are going to attach a data updating function to the `.on_clicked()` event
    of the button. You can paste the following code right before the `plt.show()`
    line in the previous code example (`chapter6_gui.py`). Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3f5d8413-3324-4c26-ac5a-3e9cad6c263a.png)'
  prefs: []
  type: TYPE_IMG
- en: You will be welcomed by a new radio selector box at the top of the figure. Try
    switching between the two states and see if the figure is updated accordingly.
    The complete code is also available as `chapter6_tkinter.py` in our code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive backend for Jupyter Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we conclude this section, we are going to introduce two more interactive
    backends that are rarely covered by books. Starting with Matplotlib 1.4, there
    is an interactive backend specifically designed for Jupyter Notebook. To invoke
    that, we simply need to paste `%matplotlib notebook` at the start of our notebook.
    We are going to adapt one of the earlier examples in this chapter to use this
    backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an interactive interface coming up, with buttons similar to a
    Tkinter-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b955965-8ea6-4b84-a397-f2532b6446f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Plot.ly-based backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, we will talk about Plot.ly, which is a D3.js-based interactive graphing
    library with many programming language bindings, including Python. Plot.ly has
    quickly gained traction in the area of online data analytics due to its powerful
    data dashboard, high performance, and detailed documentation. For more information,
    please visit Plot.ly's website ([https://plot.ly](https://plot.ly)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Plot.ly offers easy transformation of Matplotlib figures into online interactive
    charts through its Python bindings. To install Plotly.py, we can use PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us show you a quick example of integrating Matplotlib with Plot.ly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9c10384f-e542-4c5b-895d-c0e9ff2d5288.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may be greeted by the following error message when you run the preceding
    Plot.ly example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To circumvent this error, you can relaunch Jupyter Notebook by setting a higher
    `iopub_data_rate_limit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You may also notice that the tick labels cannot be displayed properly, despite
    clear specifications in the code. This issue is also reported on the official
    GitHub page ([https://github.com/plotly/plotly.py/issues/735](https://github.com/plotly/plotly.py/issues/735)).
    Unfortunately, there is no fix for this issue to date.
  prefs: []
  type: TYPE_NORMAL
- en: We admit that there are numerous materials online that describe the integration
    of Matplotlib plots in different GUI applications. Due to page limits, we are
    not going to go through each of these backends here. For readers who want to read
    more about these interactive backends, Alexandre Devert has written an excellent
    chapter (*Chapter 8, User Interface*) in *matplotlib Plotting Cookbook*. In *Chapter
    8, User Interface* of that book, Alexandre has provided recipes for creating GUI
    applications using wxWidgets, GTK, and Pyglet as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animated plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained at the start of this chapter, Matplotlib was not originally designed
    for making animations, and there are GPU-accelerated Python animation packages
    that may be more suitable for such a task (such as PyGame). However, since we
    are already familiar with Matplotlib, it is quite easy to adapt existing plots
    to animations.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of FFmpeg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start making animations, we need to install either FFmpeg, avconv,
    MEncoder, or ImageMagick on our system. These additional dependencies are not
    bundled with Matplotlib, and so we need to install them separately. We are going
    to walk you through the steps of installing FFmpeg.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian-based Linux users, FFmpeg can be installed by issuing the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'FFmpeg may not be available on Ubuntu 14.04 or earlier. To install FFmpeg on
    Ubuntu 14.04, please follow the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**sudo add-apt-repository ppa:mc3man/trusty-media**`'
  prefs: []
  type: TYPE_NORMAL
- en: Press *Enter* to confirm the addition of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '`**Also note that with apt-get a sudo apt-get dist-upgrade is needed for initial
    setup & with some package upgrades**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**More info: https://launchpad.net/~mc3man/+archive/ubuntu/trusty-media**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Press [ENTER] to continue or ctrl-c to cancel adding it**`'
  prefs: []
  type: TYPE_NORMAL
- en: Update and upgrade a few packages before installing FFmpeg.
  prefs: []
  type: TYPE_NORMAL
- en: '`**sudo apt-get update**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**sudo apt-get dist-upgrade**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, proceed with the normal procedure of installing FFmpeg via `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**sudo apt-get install ffmpeg**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Mac users, Homebrew ([https://brew.sh/](https://brew.sh/)) is the simplest
    way to search and install the FFmpeg package. For those who don''t have Homebrew,
    you can paste the following code in your terminal to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can install FFmpeg by issuing the following command in the terminal
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you may install FFmpeg by copying the binaries ([https://evermeet.cx/ffmpeg/](https://evermeet.cx/ffmpeg/))
    to the system path (for example, `/usr/local/bin`). Readers may visit the following
    page for more details: [http://www.renevolution.com/ffmpeg/2013/03/16/how-to-install-ffmpeg-on-mac-os-x.html](http://www.renevolution.com/ffmpeg/2013/03/16/how-to-install-ffmpeg-on-mac-os-x.html)
  prefs: []
  type: TYPE_NORMAL
- en: The installation steps for Windows users are quite a bit more involved, as we
    need to download the executable ourselves, followed by adding the executable to
    the system path. Therefore, we have prepared a series of screen captures to guide
    you through the process.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to obtain a prebuilt binary from [http://ffmpeg.zeranoe.com/builds/](http://ffmpeg.zeranoe.com/builds/).
    Choose the CPU architecture that matches with your system, and select the latest
    release and static linked libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ba57f3f-8638-460c-a285-5b0840821f3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to extract the downloaded ZIP file to the `C` drive as `c:\ffmpeg`,
    and add the folder `c:\ffmpeg\bin` to the `Path` variable. To do this, go to Control
    Panel and click on the System and Security link, followed by clicking on System.
    In the System window, click on the Advanced system settings link to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/983a0265-de22-4ced-8403-fd3b0437b8d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the pop-up System Properties window, click on the Environmental Variables…
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c47667f5-d7d4-497e-97d2-a08497cafc96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the Path entry, and click on the Edit… button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bff4d62b-e28a-42a9-bab1-4ace578e1fcd.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Edit environmental variable window, create a new entry that shows `c:\ffmpeg\bin`.
    Click on OK in all pop-up windows to save your changes. Restart Command Prompt
    and Jupyter Notebook and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8742e3c3-9731-41fa-a5c1-9dc777763a84.png)'
  prefs: []
  type: TYPE_IMG
- en: Visit Wikihow ([http://www.wikihow.com/Install-FFmpeg-on-Windows](http://www.wikihow.com/Install-FFmpeg-on-Windows))
    for instructions on installing FFmpeg on Windows 7.
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matplotlib provides two main interfaces for creating animations: `TimedAnimation`
    and `FuncAnimation`. `TimedAnimation` is useful for creating time-based animations,
    while `FuncAnimation` can be used to create animations according to a custom-defined
    function. Given the much higher level of flexibility offered by `FuncAnimation`,
    we will only explore the use of `FuncAnimation` in this section. Readers can refer
    to the official documentation ([https://matplotlib.org/api/animation_api.html](https://matplotlib.org/api/animation_api.html))
    for more information about `TimedAnimation`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FuncAnimation` works by repeatedly calling a function that changes the properties
    of Matplotlib objects in each frame. In the following example, we''ve simulated
    the change in median weekly earnings by assuming a 5% annual increase. We are
    going to create a custom function--animate--which returns Matplotlib Artist objects
    that are changed in each frame. This function will be supplied to `animation.FuncAnimation()`
    together with a few more extra parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screen capture of one of the video frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15792b24-dce1-43c8-9640-3d4cc8dc3580.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we output the animation in the form of MPEG-4-encoded videos.
    The video can also be embedded in Jupyter Notebook in the form of an H.264-encoded
    video. All you need to do is call the `Animation.to_html5_video()` method and
    supply the returned object to `IPython.display.HTML`. Video encoding and HTML5
    code generation will happen automatically behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you further enriched your techniques for obtaining online data
    through the use of the BeautifulSoup web scraping library. You successfully learned
    the different ways of creating interactive figures and animations. These techniques
    will pave the way for you to create intuitive and engaging visualizations in more
    advanced applications.
  prefs: []
  type: TYPE_NORMAL
