- en: '*Chapter 5*: Interactively Comparing Values with Bar Charts and Dropdown Menus'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have all the basics you need to easily construct interactive features
    linking page elements and to produce interactive dashboards. The main concepts
    have been covered with the help of several examples, and we will now be focusing
    on specific types of charts and the different options that they provide. More
    importantly, we will go into additional details for customizing our charts and
    making them suitable for several purposes, firstly, in order to be good enough
    to publish and share with a wider audience, as opposed to just for your interactive
    use, and secondly, to ensure that they properly fit on a page that potentially
    contains other components, and making sure we utilize the available space in an
    optimal way. Another important aspect to cover is the dynamic nature of the charts
    that our users can generate. Based on the user's choice of option in an interactive
    component, the resulting dataset might contain 7 or maybe 70 elements to plot.
    In some cases, it might not contain any data. This dramatically affects the resulting
    charts and their usability, and can even make them difficult to read in certain
    cases. We will explore a few solutions to cater for these situations.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we are trying to move from working with a prototype that simply
    does what it's supposed to do to working with a product that can be shared or
    published to a wide audience.
  prefs: []
  type: TYPE_NORMAL
- en: The chapters in *Part 2* of this book will each focus on a chart type and an
    interactive component to explore their options. In this chapter, we will explore
    **bar charts** and how they can be used with **drop-down** components, from **Dash
    Core Component**. There is nothing in the nature of these components that links
    a certain component to a certain chart type. They are just used together for organization
    purposes. A dropdown can be used with any type of chart, and any type of interactive
    component can be used to manipulate a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be focusing on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting bar charts vertically and horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking bar charts and dropdowns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring different ways of displaying multiple bar charts (stacked, grouped,
    overlaid, and relative)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using facets to split charts into multiple sub-charts – horizontally, vertically,
    or wrapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring additional features of dropdowns (allowing multiple selections, adding
    placeholder text, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue to use the packages that we are now familiar with – `JupyterDash`
    and `Dash`, for prototyping and then integrating into our app, respectively. For
    data manipulation, we will be using `pandas`, and `JupyterLab` will be our starting
    point for building and testing various options. Then, we will use Dash Core Component,
    Dash HTML Components, and Dash Bootstrap Components to update our app.
  prefs: []
  type: TYPE_NORMAL
- en: The dataset that we will be using is the same dataset, specifically the `poverty`
    DataFrame, that we created in the previous chapter. The code files of this chapter
    can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_05](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_05).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3ebv8sk](https://bit.ly/3ebv8sk).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring the two main ways in which we can display bar charts
    – vertically and horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting bar charts vertically and horizontally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default display of bar charts is vertical. This is intuitive and easy to
    understand. Each category or item takes a separate position on the *x* axis, and
    the heights of the bars represent a certain quantity on the *y* axis. The same
    applies when the bars are displayed horizontally, only in this case, the width
    of the bars is what represents the quantity. Usually, with relatively fewer values,
    the vertical orientation is good. However, horizontal orientation can be more
    effective in two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When we have many categories**: In this case, the bars might not fit on the
    screen, and we might need to either make them much thinner than the default width,
    or we might need to force horizontal scrolling, which is not as natural as vertical
    scrolling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When the names of the categories are relatively long**: This is not really
    a big problem, and the solution is easy. Plotly already handles this for us, by
    automatically changing the angle at which the names (tick labels) are displayed.
    If needed, the names can be displayed vertically for maximum space utilization.
    Reading text displayed horizontally is the most natural though, and it is the
    most suitable way for these situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see this in action using our `poverty` DataFrame, so we can see the
    effects of these options, and also to get to know our dataset a little better.
    We will take a look at one of the most widely used measures of income/wealth inequality,
    the Gini index. It is also referred to as the Gini ratio, or coefficient. To learn
    a bit about it, we can use the `series` DataFrame, which contains information
    about the indicators that we will be working with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `pandas` and create the `series` variable. The name of the variable
    was chosen based on the filename, as we did in the previous chapter. Please don''t
    confuse this with the `pandas.Series` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable, `gini`, as a string, as an easier alternative to using the
    long name of the indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the long definition of the indicator by using the column of the same
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Knowing that the values vary between 0 and 100, let''s check what the most
    extreme values are for all years and countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also learn a little more about this column by using the `describe` method
    from `pandas`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will learn much more about this indicator and interactively explore and
    compare different countries across different years, but this statement from the
    `Limitations and exceptions` column stood out to me: *"Because the underlying
    household surveys differ in methods and types of welfare measures collected, data
    is not strictly comparable across countries or even across years within a country."*'
  prefs: []
  type: TYPE_NORMAL
- en: So, we will have to be careful not to take those values precisely, as mentioned,
    and keep this limitation in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are a bit more familiar with the indicator, we are ready to explore
    various options for visualizing it with a bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a subset of the `poverty` DataFrame, named `df`. This
    will be a subset where the `year` values are equal to an arbitrarily selected
    year. We then remove the missing values, and sort the available ones using the
    `gini` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now easily create our Gini index bar chart with Plotly Express. The
    code also dynamically generates the title by joining the name of the indicator
    to the selected year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the chart in *Figure 5.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A bar chart of the Gini index for the year 1980](img/B16780_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – A bar chart of the Gini index for the year 1980
  prefs: []
  type: TYPE_NORMAL
- en: 'For the year 1980, it seems we only have data for three countries, and having
    them displayed vertically seems fine, easily readable, and clear. Let''s now repeat
    the same process for the year 1990, and see the result in *Figure 5.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – A bar chart of the Gini index for the year 1990](img/B16780_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – A bar chart of the Gini index for the year 1990
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the country names, but not as naturally as we would if they were
    displayed horizontally as in *Figure 5.1*. Now, if users were reading the same
    chart on a narrower screen, the country names would be displayed vertically, and
    it becomes even more difficult to read them, as you can see in *Figure 5.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A bar chart of the Gini index for the year 1990 with country
    names displayed vertically](img/B16780_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – A bar chart of the Gini index for the year 1990 with country names
    displayed vertically
  prefs: []
  type: TYPE_NORMAL
- en: 'In more recent years, we have data for many more countries, and in those cases,
    there is not enough horizontal space to fit them. Some names are not even displayed,
    unless you hover over the respective bar, or zoom in to that part of the chart.
    As an example, you can see the same chart for the year 2010 in *Figure 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A bar chart of the Gini index for the year 2010 with some country
    names not displayed](img/B16780_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – A bar chart of the Gini index for the year 2010 with some country
    names not displayed
  prefs: []
  type: TYPE_NORMAL
- en: Based on the charts we just saw, we now have a better understanding of the challenge
    of making an interactive bar chart dynamically generated for the Gini index. If
    we want to let users select the year they are interested in, then we have a few
    points to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the number of available values for this metric varies from 3 to more
    than 150, which is a very large range. Second, it would be better, and safer,
    to use horizontal orientation, because in all cases country names would be displayed
    horizontally, and no matter how long the names are, they would be easy to read.
    These issues can be easily solved by setting `orientation=''h''` in our call to
    `px.bar`, but one challenge remains. We need to determine the optimal height of
    the chart, based on the number of available countries in the chosen year, knowing
    how big the range is, as we just saw. Let''s first see what the bar chart looks
    like when displayed horizontally, and then design the solution for an interactive
    one. We will run the same code, but with two principal differences. The `x` and
    `y` arguments need to be swapped, as they will each take the opposite axis, and
    we also need to set the appropriate value for the `orientation` parameter, `h`
    for "horizontal" in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the chart in *Figure 5.5* for the year 2000:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A horizontal bar chart of the Gini index for the year 2000 for
    all available countries](img/B16780_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – A horizontal bar chart of the Gini index for the year 2000 for
    all available countries
  prefs: []
  type: TYPE_NORMAL
- en: Now the countries are very easily readable (the ones that are displayed at least),
    but the bars are too narrow and crowded. The chart looks unnecessarily wide (especially
    knowing that the minimum and maximum values are in the interval [20.2, 65.8]).
    We can manually set the width of the chart in our function call if we require,
    but we need to figure out a way to dynamically set the height of the chart, which
    can be set using the `height` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to set a fixed height in pixels. Then, based on the number
    of countries in `df`, we can add 20 pixels per country. For example, if we have
    10 countries in `df`, then our height would be 200 + (10x20) = 400 pixels. Once
    `df` has been created, we can easily count the number of countries it contains,
    and assign it to a variable, `n_countries`. The modified code to produce this
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code over three years that have a different number of
    countries produces the charts in *Figure 5.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Various horizontal bar charts with a dynamic height based on
    the number of countries](img/B16780_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Various horizontal bar charts with a dynamic height based on the
    number of countries
  prefs: []
  type: TYPE_NORMAL
- en: The long chart on the right was resized to fit on the page, but it is pretty
    much the same as the others in terms of the height of the bars and the readability
    of country names. All countries are visible, easy to read, and nothing is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: With this solution, we took care of the dynamic number of countries that can
    be selected by dynamically setting the total height of the figure, based on the
    number of countries.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be thought of as a discovery approach. Users don't know exactly
    what they are looking for; they select a year and see whatever data is available
    for that year. After they select a few options, they might be interested in digging
    deeper to learn more about specific countries. For example, they might be interested
    in how a certain country's Gini index has progressed over time. We will do this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating vertical bar charts with many values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to let users visualize how a country's Gini index (or any other
    indicator) has progressed over the years, we can do so with vertical bars. Because
    years represent a sequence of events, displaying them side by side is natural,
    because it shows a trend over time. And since years are numbers in a sequence,
    we don't have the readability issue that we had with country names. Even if the
    bars end up much thinner, and even if some of them weren't displayed, users can
    easily mentally "fill in the blanks" where required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to produce such a chart is very similar to the last one, and actually
    simpler, because we don''t need to worry about dynamically setting the height.
    Instead of `year` as our dynamic variable, we will have `Country Name`. The definition
    of `df` will depend on the rows in our dataset that contain the chosen country:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can generate the chart in a straightforward way with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code produces the chart in *Figure 5.7* for Sweden:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – A vertical bar chart with years on the x axis](img/B16780_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – A vertical bar chart with years on the x axis
  prefs: []
  type: TYPE_NORMAL
- en: Note that the years with missing values are still available on the *x* axis,
    even though there are no bars representing their value for those years. This is
    important because it shows where the gaps are in our data. It would be misleading
    otherwise if we only displayed years that contained data, giving the false impression
    of continuous data for all years.
  prefs: []
  type: TYPE_NORMAL
- en: We have familiarized ourselves a bit with the Gini index data, and tested how
    to make two types of dynamic charts. We are now ready to create a "Gini Index"
    section and add it to our app, which we will be doing next.
  prefs: []
  type: TYPE_NORMAL
- en: Linking bar charts and dropdowns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now want to put together everything that we''ve done so far. The plan is
    to have two dropdowns, side by side, with a chart underneath each. The first will
    provide years as options that will generate a horizontal bar chart. The second
    will generate a vertical bar chart, based on the selected country. The end goal
    is to produce a new section in our app that looks like *Figure 5.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – The Gini Index section in the app with two drop-down components
    and two bar charts](img/B16780_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The Gini Index section in the app with two drop-down components
    and two bar charts
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by building this as a complete and independent app in JupyterLab,
    and make sure it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first run the necessary imports and instantiate the app. We already covered
    all these imports, except for the `PreventUpdate` exception. This is a useful
    tool when there is no value selected in a component that is handled by a callback
    function; for example, when a user first loads the app, or when there are no default
    values. In this case, the input value coming from `Dropdown` would be `None` and
    would most likely raise exceptions. In those situations, we can use this exception
    to freeze things, so to speak, until a proper input is passed to the callback
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `gini_df`, which is a subset of `poverty` that doesn''t have missing
    values in the Gini index column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the app''s layout using one top-level div, within which we will place
    all other components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the div we just created, we want to add a section title, as well as
    a `dbc.Row` component. This row will then contain two `dbc.Col` elements, which
    would, in turn, contain a dropdown and a chart each. Here is a list of elements
    that will be inserted in the div:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should take care of the layout once we insert it in the
    top-level div. Now we can create the first callback, which takes a year as input
    and returns the appropriate chart. Note how the `PreventUpdate` exception is used
    at the beginning of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also do the same thing and create the other callback function that handles
    the second part of the Gini Index section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we run the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should create a running app as shown in *Figure 5.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to incorporate this new functionality into our existing app. All
    we have to do is insert the visual components wherever we want them to appear.
    The callbacks can be added below the app''s `layout` attribute. You can go ahead
    and make a copy of the latest version of the app that we created in [*Chapter
    3*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044), *Working with Plotly''s Figure
    Objects*. You can insert the new components as a list between `dcc.Graph(id=''population_chart'')`
    and `dbc.Tabs`, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using one indicator, we created two dynamic charts, the first allowing users
    to explore the data for a given year, showing all available countries, and the
    other allowing them to explore data for all years, for a certain country. We also
    explored the two ways of displaying bars, horizontally and vertically, and discussed
    when it can be better to use each of the orientations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now move on to exploring how to plot multiple bar charts on the same figure,
    and see different ways of doing so. We will also explore a new set of indicators
    using those new techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring different ways of displaying multiple bar charts (stacked, grouped,
    overlaid, and relative)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we want to display values for different countries but for the same years,
    we have several options for how to display multiple bars on each position of the
    *x* axis. *Figure 5.9* shows the different ways in which we can do that when visualizing
    two variables, **a** and **b**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Multiple bar charts displayed using different "barmode" options](img/B16780_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Multiple bar charts displayed using different "barmode" options
  prefs: []
  type: TYPE_NORMAL
- en: The four bar charts in the preceding diagram show the same information, but
    in different ways. This can be set using the `barmode` parameter. With **relative**,
    bars are displayed on top of one another, with negative values below, and positive
    values above, the zero line. If you set it to **group**, then bars will be displayed
    next to one another. With **overlay**, bars are displayed in front of one another,
    and by default, we get some transparency in order to see both bars. Finally, if
    you set it to **stack**, you get them on top of one another, like relative, but
    in this case, the negative values cancel out the positives, as you can see for
    values 2 and 4 in the last chart. This is great if you want to compare proportions
    of each value to the total, especially if they all add up to the same total. This
    is what we will do with the income share indicators that are available in our
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the income share DataFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the five columns that show the share of income for each
    of the five quintiles of countries'' populations. We first create a subset of
    the `poverty` DataFrame, and call it `income_share_df`. This is done by filtering
    the columns using the regular expression shown here. We also drop missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code shows us a sample of rows from the newly created
    `income_share_df`, as you can see in *Figure 5.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Sample rows showing income share quintiles per country](img/B16780_05_0010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Sample rows showing income share quintiles per country
  prefs: []
  type: TYPE_NORMAL
- en: 'For every country and year combination, we have five values. Each value shows
    the percentage of income of the respective group''s share of the total for that
    country and year. We want to let users select a country and, as a result, display
    a chart showing how the split of those five values changes across all available
    years. To get an idea of the end result, take a look at *Figure 5.11* showing
    those values for the United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Income shares per quintile, shown for the selected country
    for all available years](img/B16780_05_0011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Income shares per quintile, shown for the selected country for
    all available years
  prefs: []
  type: TYPE_NORMAL
- en: Since these values all add up to 100 (with minor rounding errors), we can have
    clearly comparable bars across the years, because they all have the same total
    length. Since these are proportions, we are interested in seeing the split for
    a particular year, and also how that split changed across years.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is very easy to see how things change for the rightmost and
    leftmost parts of the bars because they have the same baseline, whether at the
    beginning or the end. However, for the values in the middle, it's not easy to
    do so. The reason is that their size changes, as well as their baselines. So,
    the more divisions you add, the more difficult it gets to compare them across
    years. But since Plotly's charts are interactive, users can easily hover over
    the bars, get their exact values, and compare them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Producing this chart should be straightforward. We already created our DataFrame,
    and have our values. We can just set the `x` and `y` values, and set `orientation=''h''`,
    but the problem is that the categories are ordered alphabetically in the DataFrame,
    and we want them to be ordered according to their numeric meaning, from the lowest
    to the highest, so that their relative position can be easily understood by users.
    As usual, this is mainly a data manipulation challenge. So, let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to rename the columns and order them by their value, from "lowest"
    to "highest." One way to do that is to prepend the column names with numbers and
    sort accordingly. This can easily be done using the `rename` method. After that,
    we sort the columns by using the `sort_index` method, and setting `axis=1`, which
    means the columns (as opposed to the index of the DataFrame):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check to see that our work is correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now want to remove the redundant part of the columns and keep the position
    indicator together with "20%." We can use the standard library''s `re` module
    for that. We replace any digit followed by `Income share held by` with an empty
    string. After that, we change the casing of the resulting string to title case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now create a variable, `income_share_cols`, to refer to the columns that
    we are interested in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, our DataFrame is ready for plotting with suitable and short names. We
    first create a `country` variable to use in filtering the DataFrame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the bar chart using `px.bar`. Note that when setting the value of the
    `x` parameter, we are using a list. Plotly Express can also work with wide format
    data, which is very convenient in such cases. We could have melted the DataFrame
    and used the approach we used in the previous chapter as well. We also set `orientation=''h''`
    and `barmode=''stack''`. The title will dynamically insert the country name, as
    you can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You probably noticed that I assigned the result to a variable figure, and that
    is because we have a few minor details to improve. Running the preceding code
    produces the chart in *Figure 5.12*:![Figure 5.12 – Income shares per quintile,
    shown using the default options](img/B16780_05_0012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.12 – Income shares per quintile, shown using the default options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The titles of the *x* axis, `fig.layout`, and setting them is straightforward.
    Note that the legend has the `x` and `y` attributes to set its position in the
    figure. We set the legend''s `x` attribute to 0.25 to indicate that we want the
    legend to start at quarter the distance from the origin of the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code for Indonesia produces the final chart in *Figure
    5.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Income shares per quintile, shown using customized options](img/B16780_05_0013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Income shares per quintile, shown using customized options
  prefs: []
  type: TYPE_NORMAL
- en: Let's now put everything together and add the new features to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the functionality into our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now ready to again add the new functionality to our app using the function
    and chart we just created. At this stage, not much explanation is required since
    we have done this enough times, but I will go through the main steps, and you
    can always refer to the code repository to check your work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the module, we first make the DataFrame definitions, as well
    as column changes, as we did. Make sure that the following code is placed after
    creating the `poverty` DataFrame because it depends on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the layout part, we require an `h2` element as a title for the new section,
    a `Dropdown` component for countries, and a `Graph` component, right under the
    last charts we created for the Gini Index section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `callback` function can be easily constructed using the code we just worked
    with, and it ends up as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding this code in the right places should add the new functionality to our
    app. We now have multiple indicators that our users can interact with, and several
    of them provide different ways of looking at the data.
  prefs: []
  type: TYPE_NORMAL
- en: The four ways of displaying bar charts can be interesting, but in our case,
    if we want to allow users to compare more than one country, it would quickly become
    almost impossible to read. Going back to our Gini index country chart, for example,
    each selected country typically displays 20 to 30 bars, depending on how much
    data is available. For four countries, we are talking about around 100 bars, on
    half a page, which is really difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: How about allowing users to select as many countries as they want, and for each
    selected country, a separate chart is produced, so they can see the countries
    on multiple charts?
  prefs: []
  type: TYPE_NORMAL
- en: This is what faceting is all about, which we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Using facets to split charts into multiple sub-charts – horizontally, vertically,
    or wrapped
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very powerful technique that allows us to add a new dimension to our
    analysis. We can select any feature (column) from our dataset to split the chart
    by. If you are expecting a long explanation of how it works, and what you need
    to learn to master it, don't. Just like most other things in Plotly Express, if
    you have a long-form (tidy) dataset, all you have to do is select a column and
    use its name for the `facet_col` or `facet_row` parameter. That's it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the available options for facets by looking at
    the relevant facet parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`facet_col`: This means you want to split the chart into columns, and the selected
    column name will be used to split them. This results in the charts being displayed
    side by side (as columns).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`facet_row`: Similarly, if you want to split the chart into rows, you can use
    this parameter, which will split the chart into sub-charts displayed on top of
    one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`facet_col_wrap`: This is really useful when you have a dynamic number of facets
    to produce. If you know your users will be generating multiple charts, after how
    many charts should the following chart be displayed on the next row in the resulting
    grid of charts? The answer should be an integer, and Plotly Express makes sure
    that after that number, the charts are displayed in the next row of charts. This
    ensures that for every row, we have a maximum number of columns of charts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`facet_row_spacing` and `facet_col_spacing`: As their names suggest, you can
    control the spacing between rows and columns by setting these values in the range
    [0, 1] as a fraction of the total figure size, horizontally or vertically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run a quick example to make sure this is clear:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list of countries to filter by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the definition of `df` to filter the rows where `''Country Name''` is
    in `countries`. The `pandas` method `isin` can be used for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `px.bar` with the simple addition of `facet_row=''Country Name''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this code produces the chart in *Figure 5.14*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Two bar charts generated using the facet_row parameter](img/B16780_05_0014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.14 – Two bar charts generated using the facet_row parameter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It''s very easy to extend our charts, as you can see, and we also get the sub-charts
    labeled for us with the correct country names. It still doesn''t look as good
    as we would like it to be. The *y* axis titles are overlapping, and you have to
    look hard at the vertical titles to see which sub-chart belongs to which country.
    So let''s improve things. Let''s first start by modifying the *y* axis titles,
    which can be done using the `labels` parameter, by providing a dictionary and
    mapping the default name to the new name that we want:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also help the user to quickly identify the charts by coloring the bars
    by country. This will make them distinctive and will also produce a legend with
    colored guides, making it even easier to distinguish the charts. Again this is
    done by simply providing an argument to the `color` parameter, which is basically
    a selection of the column name that we want to use for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another helpful thing would be to add a dynamic title to the figure as a whole.
    We can display the full indicator name, and underneath that, we can show a comma-separated
    list of the selected countries. Plotly annotations support some HTML tags, and
    we will use the `<br>` tag to separate the indicator name and the country list
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having two countries on the chart is easy to read, but what if the users decide
    to select seven? As we did with the dynamic height of the Gini index horizontal
    bar chart, we also need to set a dynamic height for the faceted bar charts based
    on the number of selected countries. We will use the same technique, but with
    different values, because we are managing sub-plots, and not horizontal bars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full updated code can be seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final chart can be seen in *Figure 5.15*, shown for three countries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Three bar charts generated using the facet_row parameter with
    customized options](img/B16780_05_0015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Three bar charts generated using the facet_row parameter with
    customized options
  prefs: []
  type: TYPE_NORMAL
- en: The figure and function have now been updated to produce faceted charts, based
    on the selected countries. The only remaining change that we have to make is to
    set the dropdown providing the options for this, to allow multiple selections.
    We will do this next, as well as taking a general view of our current dashboard,
    and see how to improve its layout and usability.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring additional features of dropdowns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Dropdown` component has an optional parameter, `multi`, that takes a Boolean
    argument, which we can set to `True` to allow this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can now make the changes and use the Gini country bar chart for as many
    countries as you like. The height of that figure on the page dynamically expands/collapses
    based on the dynamic height that we set, so we also don't need to worry about
    this aspect of the layout. The users will manage it themselves while interacting
    with the components. Let's now see whether it's easy for a newcomer to use those
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Adding placeholder text to dropdowns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look at the Gini Index section of the app for the first time, you will
    see two dropdowns that allow you to make a selection, as shown in *Figure 5.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Dropdowns without any placeholder text](img/B16780_05_0016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Dropdowns without any placeholder text
  prefs: []
  type: TYPE_NORMAL
- en: But select what exactly?
  prefs: []
  type: TYPE_NORMAL
- en: The `Dropdown` component has an optional `placeholder` parameter, which can
    be very useful for users to know what exactly they are selecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily update our placeholder text for both `Dropdown` components to
    make it clearer to users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make it even more explicit by using the `Label` component from Dash
    Bootstrap Components, which, as the name suggests, provides a label. These labels
    can be placed above the dropdowns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the new options results in the updated messages as shown in *Figure
    5.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Dropdowns with placeholder text and labels](img/B16780_05_0017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Dropdowns with placeholder text and labels
  prefs: []
  type: TYPE_NORMAL
- en: I think it looks easier to use this way. We are also making it clear which one
    accepts a single option, and which accepts multiple ones. We can also do the same
    for the Income Share Distribution section by adding a similar label, Country,
    and a placeholder, Select a country.
  prefs: []
  type: TYPE_NORMAL
- en: Our app is now getting bigger, and provides many more options. It's good to
    take a general look and see how to improve the overall look and feel of the app,
    make it easier to use, and use a consistent theme across all figures.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the app's theme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already saw how easy it is to change the theme of our app, which can be
    done by providing a list as an argument to the `external_style_sheets` parameter
    while instantiating the app. You can play around with the available ones, and
    we can set it to `COSMO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This should modify several visual elements of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we can consider doing is making our theme consistent with the
    theme of the charts that we are using. We can set the background color of the
    app to the same default color used in Plotly''s figures. Using the `style` parameter
    in the top-level `html.Div`, we can set the background color to match that of
    the default Plotly color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: One more change is needed to make this complete.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly's `Figure` object contains two main areas, the "plot" and the "paper"
    areas. The plot area is the inner rectangle within the *x* and *y* axes. In all
    the charts that we produced, this is the area colored light blue (or gray, if
    you are reading the printed book).
  prefs: []
  type: TYPE_NORMAL
- en: 'The bigger rectangle enclosing the smaller one is the "paper" area. In the
    charts we have produced so far, it has been colored white. We can also set its
    color to the same color, making all background colors the same for our app. We
    simply have to add the following line to the callback functions that generate
    charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the app now, we will get some empty figures with a white background
    for the ones where we did not set default values. For those, we also need to create
    empty figures, but set the background colors to be consistent with the whole app
    theme. Doing this is very simple, as we did in [*Chapter 3*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044),
    *Working with Plotly''s Figure Objects*. The `dcc.Graph` component has a `figure`
    attribute, to which we can add the empty figures with the desired background colors.
    These will be modified when users make a selection. Because we have a few instances
    of those, it''s better to create a function that can be used to create such figures
    whenever we want them. The following code achieves that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the call to `make_empty_fig` where required, as you can see
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have chosen a new overall theme and made sure that we have consistent
    background colors across all the elements of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another thing we need to handle is how the resizing of the browser window affects
    the size and placement of our different components. The figures are responsive
    by default, but we need to make some decisions for the figures that are placed
    side by side. In the Gini Index section, we have two such charts, placed in two
    `dbc.Col` components next to each other. All we have to do is set the desired
    size for those charts for large-, `lg`, as well as medium-, `md`, sized screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When on a large screen, `lg`, the most likely scenario, each figure will have
    a size of 5 (out of 12), which is how the screen is split by Bootstrap. You can
    refer to the discussion on Bootstrap layouts, columns, and rows, as well as its
    grid system, in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*, if you want a refresher. On medium-sized screens,
    `md`, the figures will expand to occupy 12 out of 12 columns, which means that
    they will take the full width of the screen at that size.
  prefs: []
  type: TYPE_NORMAL
- en: When we started learning about interactivity, we created a simple report at
    the top of our app. It displays the population of the selected country/region
    for the year 2010\. We can remove this component, as it is very limited in functionality
    and was mainly used for illustration purposes. This can simply be done by deleting
    the component, together with the output area underneath it, as well as the callback
    that handles it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of the work we have done in this chapter, you can see in *Figure
    5.18* what our app now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The final layout of the app](img/B16780_05_0018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – The final layout of the app
  prefs: []
  type: TYPE_NORMAL
- en: I strongly encourage you to make these changes manually yourself, without looking
    at the code provided in the repository. I also encourage you to test out other
    layouts, play with different options, and generate lots of errors!
  prefs: []
  type: TYPE_NORMAL
- en: Making changes all the time and being in control of your code requires a consistent
    naming convention of the components, callbacks, and variables. It also helps if
    you follow a certain logical flow in the organization of your components. We will
    be doing these things many times, and hopefully you will master these techniques
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Our app is now looking better, easier to use, and can even be shared with others
    if you want to. We covered many things in this chapter, taking our app to a new
    level, so let's recap the things that we covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We focused mainly on bar charts in this chapter. We also used `Dropdown` components
    in several ways. We saw the pros and cons of using horizontal and vertical orientation,
    and we actually implemented both in our app. We then analyzed the different ways
    in which multiple bar charts can be displayed together, and we implemented one
    showing the proportions of a total value. We then explored facets and saw how
    they enrich our figures and make them flexible and scalable. We also linked that
    to dropdowns, which allow multiple selections. After making sure that everything
    is working fine, we gave our app a facelift by choosing a new theme and making
    sure that all background colors are consistent. We also managed the layout for
    different screen sizes by setting different sizes for our figures for different
    screen sizes. A few helpful messages were added to make the app easier to use.
    Finally, we took a screenshot of the resulting app!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore one of the most ubiquitous chart types
    – the scatter plot. We will also explore how to use it together with sliders that
    allow users to select and modify values or ranges of values.
  prefs: []
  type: TYPE_NORMAL
