<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 14. Graphs, Geometry, and Geographic Information Systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Graphs, Geometry, and Geographic Information Systems</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manipulating and visualizing graphs with NetworkX</li><li class="listitem" style="list-style-type: disc">Analyzing a social network with NetworkX</li><li class="listitem" style="list-style-type: disc">Resolving dependencies in a Directed Acyclic Graph with a topological sort</li><li class="listitem" style="list-style-type: disc">Computing connected components in an image</li><li class="listitem" style="list-style-type: disc">Computing the Voronoi diagram of a set of points</li><li class="listitem" style="list-style-type: disc">Manipulating geospatial data with Shapely and basemap</li><li class="listitem" style="list-style-type: disc">Creating a route planner for a road network</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec110"/>Introduction</h1></div></div></div><p>In this chapter, we will cover Python's capabilities in graph theory, geometry, and geography.</p><p>
<span class="strong"><strong>Graphs</strong></span><a id="id1910" class="indexterm"/> are mathematical objects describing relations between items. They are ubiquitous in science and engineering, as they can represent many kinds of real-world relations: friends in a social network, atoms in a molecule, website links, cells in a neural network, neighboring pixels in an image, and so on. Graphs are also classical data structures in computer science. Finally, many domain-specific problems may be re-expressed as graph problems, and then solved with well-known algorithms.</p><p>We will also see a few recipes related to <span class="strong"><strong>geometry</strong></span> and <a id="id1911" class="indexterm"/><span class="strong"><strong>Geographic Information Systems</strong></span> (<span class="strong"><strong>GIS</strong></span>), which refers to the processing and analysis of any kind of spatial, geographical, or topographical data.</p><p>In this introduction, we will give a brief overview of these topics.</p><div class="section" title="Graphs"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec415"/>Graphs</h2></div></div></div><p>Mathematically, a <a id="id1912" class="indexterm"/><span class="strong"><strong>graph</strong></span> <span class="emphasis"><em>G = (V, E)</em></span> is defined by a<a id="id1913" class="indexterm"/> set <span class="emphasis"><em>V</em></span> of <span class="strong"><strong>vertices</strong></span><a id="id1914" class="indexterm"/> or <a id="id1915" class="indexterm"/><span class="strong"><strong>nodes</strong></span>, and <a id="id1916" class="indexterm"/>a set <span class="emphasis"><em>E</em></span> of<a id="id1917" class="indexterm"/> <span class="strong"><strong>edges</strong></span> (two-element subsets of V). Two <a id="id1918" class="indexterm"/>nodes <span class="emphasis"><em>v</em></span> and <span class="emphasis"><em>v</em></span>' are said to be <span class="strong"><strong>connected</strong></span><a id="id1919" class="indexterm"/> if <span class="emphasis"><em>(v, v')</em></span> is an edge (element of <span class="emphasis"><em>E</em></span>).</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the edges are <span class="emphasis"><em>unordered</em></span> (meaning that <span class="emphasis"><em>(v,v') = (v',v)</em></span>), the graph is said to be <a id="id1920" class="indexterm"/><span class="strong"><strong>undirected</strong></span></li><li class="listitem" style="list-style-type: disc">If the edges are <span class="emphasis"><em>ordered</em></span> (meaning that <span class="emphasis"><em>(v,v') </em></span>≠<span class="emphasis"><em> (v',v)</em></span>), the graph is said to be <a id="id1921" class="indexterm"/><span class="strong"><strong>directed</strong></span></li></ul></div><p>An edge in an undirected graph is represented by a line segment between the two nodes. In a directed graph, it is represented by an arrow.</p><div class="mediaobject"><img src="images/4818OS_14_01.jpg" alt="Graphs"/><div class="caption"><p>Undirected and directed graphs</p></div></div><p>A graph can be represented by different data structures, notably an <span class="strong"><strong>adjacency list</strong></span><a id="id1922" class="indexterm"/> (for each vertex, a list of adjacent vertices) or an <span class="strong"><strong>adjacency matrix</strong></span><a id="id1923" class="indexterm"/> (matrix of connections between vertices).</p><div class="section" title="Problems in graph theory"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec71"/>Problems in graph theory</h3></div></div></div><p>Here are a few examples of <a id="id1924" class="indexterm"/>classical graph problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Graph traversal</strong></span>: How to walk<a id="id1925" class="indexterm"/> through a graph, discussed at <a class="ulink" href="http://en.wikipedia.org/wiki/Graph_traversal">http://en.wikipedia.org/wiki/Graph_traversal</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Graph coloring</strong></span>: How to <a id="id1926" class="indexterm"/>color nodes in a graph such that no two adjacent vertices share the same color, discussed at <a class="ulink" href="http://en.wikipedia.org/wiki/Graph_coloring">http://en.wikipedia.org/wiki/Graph_coloring</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connected components</strong></span>: How to find <a id="id1927" class="indexterm"/>connected components in a graph, explained at <a class="ulink" href="http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29">http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shortest paths</strong></span>: What is the <a id="id1928" class="indexterm"/>shortest path from one node to another in a given graph?, discussed at <a class="ulink" href="http://en.wikipedia.org/wiki/Shortest_path_problem">http://en.wikipedia.org/wiki/Shortest_path_problem</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hamiltonian paths</strong></span>: Does a graph <a id="id1929" class="indexterm"/>include a Hamiltonian path, visiting every vertex exactly once?, explained at <a class="ulink" href="http://en.wikipedia.org/wiki/Hamiltonian_path">http://en.wikipedia.org/wiki/Hamiltonian_path</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Eulerian paths</strong></span>: Does a<a id="id1930" class="indexterm"/> graph include an Eulerian path, visiting<a id="id1931" class="indexterm"/> every <span class="emphasis"><em>edge</em></span> exactly once?, discussed at <a class="ulink" href="http://en.wikipedia.org/wiki/Eulerian_path">http://en.wikipedia.org/wiki/Eulerian_path</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Traveling Salesman Problem</strong></span>: What is <a id="id1932" class="indexterm"/>the shortest route visiting every node exactly once (Hamiltonian path)?, explained at <a class="ulink" href="http://en.wikipedia.org/wiki/Traveling_salesman_problem">http://en.wikipedia.org/wiki/Traveling_salesman_problem</a></li></ul></div></div><div class="section" title="Random graphs"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec72"/>Random graphs</h3></div></div></div><p>
<span class="strong"><strong>Random graphs</strong></span><a id="id1933" class="indexterm"/> are particular kinds of graphs defined with probabilistic rules. They are useful for understanding the structure of large real-world graphs such as social graphs.</p><p>In particular, <span class="strong"><strong>small-world networks</strong></span><a id="id1934" class="indexterm"/> have sparse connections, but most nodes can be reached from every other node in a small number of steps. This property is due to the existence of a small number of <span class="strong"><strong>hubs</strong></span><a id="id1935" class="indexterm"/> that have a high number of connections.</p></div><div class="section" title="Graphs in Python"><div class="titlepage"><div><div><h3 class="title"><a id="ch14lvl3sec73"/>Graphs in Python</h3></div></div></div><p>Although graphs can be manipulated with native Python structures, it is more convenient to use a dedicated library implementing specific data structures and manipulation routines. In this chapter, we will use <a id="id1936" class="indexterm"/><span class="strong"><strong>NetworkX</strong></span>, a pure Python library. Alternative Python libraries include <span class="strong"><strong>python-graph</strong></span><a id="id1937" class="indexterm"/> and <a id="id1938" class="indexterm"/><span class="strong"><strong>graph-tool</strong></span> (largely written in C++).</p><p>NetworkX implements a flexible data structure for graphs, and it contains many algorithms. NetworkX also lets us draw graphs easily with matplotlib.</p></div></div><div class="section" title="Geometry in Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec416"/>Geometry in Python</h2></div></div></div><p>
<span class="strong"><strong>Shapely</strong></span><a id="id1939" class="indexterm"/> is a Python library used to manipulate 2D geometrical shapes such as points, lines, and polygons. It is most notably useful in Geographic Information Systems.</p><p>It is not straightforward to combine Shapely with matplotlib. Fortunately, the <span class="strong"><strong>descartes</strong></span> package<a id="id1940" class="indexterm"/> makes this task much easier.</p></div><div class="section" title="Geographical Information Systems in Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec417"/>Geographical Information Systems in Python</h2></div></div></div><p>There are several Python modules <a id="id1941" class="indexterm"/>used to manipulate geographical data and plotting maps.</p><p>In this chapter, we will use matplotlib's basemap, Shapely, descartes, and Fiona to handle GIS files.</p><p>The ESRI <span class="strong"><strong>shapefile</strong></span><a id="id1942" class="indexterm"/> is a popular geospatial vector data format. It can be read by basemap, NetworkX, and Fiona.</p><p>We will also use the <a id="id1943" class="indexterm"/><span class="strong"><strong>OpenStreetMap</strong></span> service, a free, open source, collaborative service providing maps of the world.</p><p>Other GIS/mapping systems in Python that we couldn't cover in this chapter include <a id="id1944" class="indexterm"/><span class="strong"><strong>GeoPandas</strong></span>, <a id="id1945" class="indexterm"/><span class="strong"><strong>Kartograph</strong></span>, <a id="id1946" class="indexterm"/><span class="strong"><strong>Vincent</strong></span>, and <a id="id1947" class="indexterm"/><span class="strong"><strong>cartopy</strong></span>.</p></div><div class="section" title="References"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec418"/>References</h2></div></div></div><p>Here are a few references<a id="id1948" class="indexterm"/> about graphs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Graph theory<a id="id1949" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Graph_theory">http://en.wikipedia.org/wiki/Graph_theory</a></li><li class="listitem" style="list-style-type: disc">Data structures for <a id="id1950" class="indexterm"/>graphs, described at <a class="ulink" href="http://en.wikipedia.org/wiki/Graph_(abstract_data_type)">http://en.wikipedia.org/wiki/Graph_(abstract_data_type)</a></li><li class="listitem" style="list-style-type: disc">Random graphs<a id="id1951" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Random_graph">http://en.wikipedia.org/wiki/Random_graph</a></li><li class="listitem" style="list-style-type: disc">Small-world graphs<a id="id1952" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Small-world_network">http://en.wikipedia.org/wiki/Small-world_network</a></li><li class="listitem" style="list-style-type: disc">NetworkX package, available <a id="id1953" class="indexterm"/>at <a class="ulink" href="http://networkx.github.io">http://networkx.github.io</a></li><li class="listitem" style="list-style-type: disc">The python-graph package,<a id="id1954" class="indexterm"/> available at <a class="ulink" href="https://code.google.com/p/python-graph/">https://code.google.com/p/python-graph/</a></li><li class="listitem" style="list-style-type: disc">The<a id="id1955" class="indexterm"/> graph-tool package,<a id="id1956" class="indexterm"/> available at <a class="ulink" href="http://graph-tool.skewed.de">http://graph-tool.skewed.de</a></li></ul></div><p>Here are a few references about geometry<a id="id1957" class="indexterm"/> and maps<a id="id1958" class="indexterm"/> in Python:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basemap<a id="id1959" class="indexterm"/> at <a class="ulink" href="http://matplotlib.org/basemap/">http://matplotlib.org/basemap/</a></li><li class="listitem" style="list-style-type: disc">Shapely<a id="id1960" class="indexterm"/> at <a class="ulink" href="http://toblerity.org/shapely/project.html">http://toblerity.org/shapely/project.html</a></li><li class="listitem" style="list-style-type: disc">Fiona<a id="id1961" class="indexterm"/> at <a class="ulink" href="http://toblerity.org/fiona/">http://toblerity.org/fiona/</a></li><li class="listitem" style="list-style-type: disc">descartes<a id="id1962" class="indexterm"/> at <a class="ulink" href="https://pypi.python.org/pypi/descartes">https://pypi.python.org/pypi/descartes</a></li><li class="listitem" style="list-style-type: disc">Shapefile<a id="id1963" class="indexterm"/> at <a class="ulink" href="http://en.wikipedia.org/wiki/Shapefile">http://en.wikipedia.org/wiki/Shapefile</a></li><li class="listitem" style="list-style-type: disc">OpenStreetMap<a id="id1964" class="indexterm"/> at <a class="ulink" href="http://www.openstreetmap.org">www.openstreetmap.org</a></li><li class="listitem" style="list-style-type: disc">Folium<a id="id1965" class="indexterm"/> at <a class="ulink" href="https://github.com/wrobstory/folium">https://github.com/wrobstory/folium</a></li><li class="listitem" style="list-style-type: disc">GeoPandas<a id="id1966" class="indexterm"/> at <a class="ulink" href="http://geopandas.org">http://geopandas.org</a></li><li class="listitem" style="list-style-type: disc">Kartograph<a id="id1967" class="indexterm"/> at <a class="ulink" href="http://kartograph.org">http://kartograph.org</a></li><li class="listitem" style="list-style-type: disc">Cartopy<a id="id1968" class="indexterm"/> at <a class="ulink" href="http://scitools.org.uk/cartopy/">http://scitools.org.uk/cartopy/</a></li><li class="listitem" style="list-style-type: disc">Vincent<a id="id1969" class="indexterm"/> at <a class="ulink" href="https://github.com/wrobstory/vincent">https://github.com/wrobstory/vincent</a></li></ul></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Manipulating and visualizing graphs with NetworkX"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec111"/>Manipulating and visualizing graphs with NetworkX</h1></div></div></div><p>In this recipe, we will show how to create, manipulate, and visualize graphs with NetworkX.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec419"/>Getting ready</h2></div></div></div><p>You can find the installation instructions for NetworkX<a id="id1970" class="indexterm"/> in the official documentation at <a class="ulink" href="http://networkx.github.io/documentation/latest/install.html">http://networkx.github.io/documentation/latest/install.html</a>.</p><p>With Anaconda, you can type <code class="literal">conda install networkx</code> in a terminal. Alternatively, you can type <code class="literal">pip install networkx</code>. On Windows, you can also use Chris Gohlke's installer, available at <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#networkx">www.lfd.uci.edu/~gohlke/pythonlibs/#networkx</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec420"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy, NetworkX, and matplotlib:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import networkx as nx
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">There are<a id="id1971" class="indexterm"/> many different ways of creating a graph. Here, we <a id="id1972" class="indexterm"/>create <a id="id1973" class="indexterm"/>a list of <a id="id1974" class="indexterm"/>edges (pairs of node indices):<div class="informalexample"><pre class="programlisting">In [2]: n = 10  # Number of nodes in the graph.
        # Each node is connected to the two next nodes,
        # in a circular fashion.
        adj = [(i, (i+1)%n) for i in range(n)]
        adj += [(i, (i+2)%n) for i in range(n)]</pre></div></li><li class="listitem">We instantiate a <code class="literal">Graph</code> object with our list of edges:<div class="informalexample"><pre class="programlisting">In [3]: g = nx.Graph(adj)</pre></div></li><li class="listitem">Let's check the list of nodes and edges of the graph, and its adjacency matrix:<div class="informalexample"><pre class="programlisting">In [4]: print(g.nodes())
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [5]: print(g.edges())
[(0, 8), (0, 1), (0, 2), ..., (7, 9), (8, 9)]
In [6]: print(nx.adjacency_matrix(g))
[[ 0.  1.  1.  0.  0.  0.  0.  0.  1.  1.]
 [ 1.  0.  1.  1.  0.  0.  0.  0.  0.  1.]
 ...
 [ 1.  0.  0.  0.  0.  0.  1.  1.  0.  1.]
 [ 1.  1.  0.  0.  0.  0.  0.  1.  1.  0.]]</pre></div></li><li class="listitem">Let's display this graph. NetworkX comes with a variety of drawing functions. We can either specify the nodes' positions explicitly, or we can use an algorithm to automatically compute an interesting layout. Here, we use the <code class="literal">draw_circular()</code> function that simply positions nodes linearly on a circle:<div class="informalexample"><pre class="programlisting">In [7]: nx.draw_circular(g)</pre></div><div class="mediaobject"><img src="images/4818OS_14_02.jpg" alt="How to do it…"/></div></li><li class="listitem">Graphs can be modified easily. Here, we add a new node connected to all existing nodes. We also specify a <code class="literal">color</code> attribute to this node. In NetworkX, every node and edge comes with a convenient Python dictionary containing arbitrary attributes.<div class="informalexample"><pre class="programlisting">In [8]: g.add_node(n, color='#fcff00')
        # We add an edge from every existing 
        # node to the new node.
        for i in range(n):
            g.add_edge(i, n)</pre></div></li><li class="listitem">Now, let's draw the <a id="id1975" class="indexterm"/>modified graph again. This <a id="id1976" class="indexterm"/>time, we specify the nodes' <a id="id1977" class="indexterm"/>positions and colors <a id="id1978" class="indexterm"/>explicitly:<div class="informalexample"><pre class="programlisting">In [9]: # We define custom node positions on a circle
        # except the last node which is at the center.
        t = np.linspace(0., 2*np.pi, n)
        pos = np.zeros((n+1, 2))
        pos[:n,0] = np.cos(t)
        pos[:n,1] = np.sin(t)
        # A node's color is specified by its 'color'
        # attribute, or a default color if this attribute
        # doesn't exist.
        color = [g.node[i].get('color', '#88b0f3')
                 for i in range(n+1)]
        # We now draw the graph with matplotlib.
        nx.draw_networkx(g, pos=pos, node_color=color)
        plt.axis('off')</pre></div><div class="mediaobject"><img src="images/4818OS_14_03.jpg" alt="How to do it…"/></div></li><li class="listitem">Let's also use an automatic layout algorithm:<div class="informalexample"><pre class="programlisting">In [10]: nx.draw_spectral(g, node_color=color)
         plt.axis('off')</pre></div><div class="mediaobject"><img src="images/4818OS_14_04.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec421"/>There's more…</h2></div></div></div><p>In NetworkX, nodes are not necessarily integers. They can be numbers, strings, tuples, and instances of any hashable Python class.</p><p>In addition, every node and edge comes with optional attributes (which form a dictionary).</p><p>A few layout algorithms are implemented in NetworkX. The <code class="literal">draw_spectral()</code> function<a id="id1979" class="indexterm"/> uses the eigenvectors of the graph's <a id="id1980" class="indexterm"/><span class="strong"><strong>Laplacian matrix</strong></span>.</p><p>The <code class="literal">draw_spring()</code> function<a id="id1981" class="indexterm"/> implements the <a id="id1982" class="indexterm"/><span class="strong"><strong>Fruchterman-Reingold force-directed</strong></span> algorithm. Nodes are considered as masses subject to edge-dependent forces. A force-directed graph drawing algorithm minimizes the system's energy so as to find an equilibrium configuration. This results in an aesthetically appealing layout with as few crossing edges as possible.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Graph drawing, described at <a class="ulink" href="http://en.wikipedia.org/wiki/Graph_drawing">http://en.wikipedia.org/wiki/Graph_drawing</a></li><li class="listitem" style="list-style-type: disc">Laplacian matrix on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Laplacian_matrix">http://en.wikipedia.org/wiki/Laplacian_matrix</a></li><li class="listitem" style="list-style-type: disc">Force-directed graph drawing<a id="id1983" class="indexterm"/>, described at <a class="ulink" href="http://en.wikipedia.org/wiki/Force-directed_graph_drawing">http://en.wikipedia.org/wiki/Force-directed_graph_drawing</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec422"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Analyzing a social network with NetworkX</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Analyzing a social network with NetworkX"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec112"/>Analyzing a social network with NetworkX</h1></div></div></div><p>In this recipe, we will show how to analyze social data in Python. Social data is generated by people's activity on social networks such as Facebook, Twitter, Google+, GitHub, and others.</p><p>In this recipe, we will <a id="id1984" class="indexterm"/>analyze and visualize a Twitter user's social <a id="id1985" class="indexterm"/>network with NetworkX.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec423"/>Getting ready</h2></div></div></div><p>First, you need to install the <a id="id1986" class="indexterm"/><span class="strong"><strong>Twitter</strong></span> Python package. You can install it with <code class="literal">pip install twitter</code>. You'll find more information at <a class="ulink" href="https://pypi.python.org/pypi/twitter">https://pypi.python.org/pypi/twitter</a>.</p><p>Then, you need to obtain authentication codes in order to access your Twitter data. The procedure is free. In addition to a Twitter account, you also need to create an <span class="emphasis"><em>Application</em></span> on the Twitter Developers website<a id="id1987" class="indexterm"/> at <a class="ulink" href="https://dev.twitter.com/apps">https://dev.twitter.com/apps</a>. Then, you will be able to retrieve the <span class="strong"><strong>OAuth authentication codes</strong></span><a id="id1988" class="indexterm"/> that are required for this recipe.</p><p>You need to create a <code class="literal">twitter.txt</code> text file in the current folder with the four private authentication keys. There must be one key per line, in the following order:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">API key</li><li class="listitem" style="list-style-type: disc">API secret</li><li class="listitem" style="list-style-type: disc">Access token</li><li class="listitem" style="list-style-type: disc">Access token secret</li></ul></div><p>Note that access to the Twitter API is limited. Most methods can only be called a few times within a given time window. Unless you study small networks or look at small portions of large networks, you will need to <span class="emphasis"><em>throttle</em></span> your requests. In this recipe, we only consider a small portion of the network, so that the API limit should not be reached. Otherwise, you will have to wait a few minutes before the next time window starts. The API limits are<a id="id1989" class="indexterm"/> available at <a class="ulink" href="https://dev.twitter.com/docs/rate-limiting/1.1/limits">https://dev.twitter.com/docs/rate-limiting/1.1/limits</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec424"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import a few packages:<div class="informalexample"><pre class="programlisting">In [1]: import math
        import json
        import twitter
        import numpy as np
        import pandas as pd
        import networkx as nx
        import matplotlib.pyplot as plt
        %matplotlib inline
        from IPython.display import Image</pre></div></li><li class="listitem">We get the secret <a id="id1990" class="indexterm"/>consumer and <a id="id1991" class="indexterm"/>OAuth keys from our <code class="literal">twitter.txt</code> file:<div class="informalexample"><pre class="programlisting">In [2]: (CONSUMER_KEY,
         CONSUMER_SECRET, 
         OAUTH_TOKEN,
         OAUTH_TOKEN_SECRET) = open(
                  'twitter.txt', 'r').read().splitlines()</pre></div></li><li class="listitem">We now create an instance of the <code class="literal">Twitter</code> class that will give us access to the Twitter API:<div class="informalexample"><pre class="programlisting">In [3]: auth = twitter.oauth.OAuth(OAUTH_TOKEN,
                                   OAUTH_TOKEN_SECRET,
                                   CONSUMER_KEY,
                                   CONSUMER_SECRET)
        tw = twitter.Twitter(auth=auth)</pre></div></li><li class="listitem">We use the 1.1 version of the Twitter API in this recipe. The <code class="literal">twitter</code> library defines a direct mapping between the REST API and the attributes of the <code class="literal">Twitter</code> instance. Here, we execute the <code class="literal">account/verify_credentials</code> REST request to obtain the identifier of the authenticated user (me here, or you if you execute this notebook yourself!):<div class="informalexample"><pre class="programlisting">In [4]: me = tw.account.verify_credentials()
In [5]: myid = me['id']</pre></div></li><li class="listitem">Let's define a simple function that returns the identifiers of all followers of a given user (the authenticated user by default):<div class="informalexample"><pre class="programlisting">In [6]: def get_followers_ids(uid=None):
            # Retrieve the list of followers' ids of the
            # specified user.
            return tw.followers.ids(user_id=uid)['ids']
In [7]: # We get the list of my followers.
        my_followers_ids = get_followers_ids()</pre></div></li><li class="listitem">Now, we define a function that retrieves the full profile of Twitter users. As the <code class="literal">users/lookup</code> batch request is limited to 100 users per call, and only a small number of calls are allowed within a time window, we only look at a subset of all the followers:<div class="informalexample"><pre class="programlisting">In [8]: def get_users_info(users_ids, max=500):
            n = min(max, len(users_ids))
            # Get information about those users,
            # using batch requests.
            users = [tw.users.lookup(
               user_id=users_ids[100*i:100*(i+1)])
                   for i in range(int(math.ceil(n/100.)))]
            # We flatten this list of lists.
            users = [item for sublist in users 
                     for item in sublist]
            return {user['id']: user for user in users}
In [9]: users_info = get_users_info(my_followers_ids)
In [10]: # Let's save this dictionary on the disk.
         with open('my_followers.json', 'w') as f:
             json.dump(users_info, f, indent=1)</pre></div></li><li class="listitem">We also start to <a id="id1992" class="indexterm"/>define the graph with the <a id="id1993" class="indexterm"/>followers, using an adjacency list (technically, a dictionary of lists). This is called the <a id="id1994" class="indexterm"/><span class="strong"><strong>ego graph</strong></span>. This graph represents all <span class="emphasis"><em>following</em></span> connections between our followers:<div class="informalexample"><pre class="programlisting">In [11]: adjacency = {myid: my_followers_ids}</pre></div></li><li class="listitem">Now, we are going to take a look at the part of the ego graph related to Python. Specifically, we will consider the followers of the 10 most followed users whose descriptions contain "Python":<div class="informalexample"><pre class="programlisting">In [12]: my_followers_python = \[user 
            for user in users_info.values()
              if 'python' in user['description'].lower()]
In [13]: my_followers_python_best = \
          sorted(my_followers_python, 
            key=lambda u: u['followers_count'])[::-1][:10]</pre></div><p>The request for retrieving the followers of a given user is rate-limited. Let's check how many remaining calls we have:</p><div class="informalexample"><pre class="programlisting">In [14]: tw.application.rate_limit_status(
             resources='followers') \
             ['resources']['followers']['/followers/ids']
Out[14]: {u'limit': 15, 
          u'remaining': 0, 
          u'reset': 1388865551}
In [15]: for user in my_followers_python_best:
             # The call to get_followers_ids is 
             # rate-limited.
             adjacency[user['id']] = list(set(
                 get_followers_ids(user['id'])). \
                 intersection(my_followers_ids))</pre></div></li><li class="listitem">Now that our graph is defined as an adjacency list in a dictionary, we will load it in NetworkX:<div class="informalexample"><pre class="programlisting">In [16]: g = nx.Graph(adjacency)
In [17]: # We only restrict the graph to the users
         # for which we were able to retrieve the profile.
         g = g.subgraph(users_info.keys())
In [18]: # We also save this graph on disk.
         with open('my_graph.json', 'w') as f:
             json.dump(nx.to_dict_of_lists(g), f, indent=1)
In [19]: # We remove isolated nodes for simplicity.
         g.remove_nodes_from([k 
                for k, d in g.degree().items()
                              if d &lt;= 1])
In [20]: # Since I am connected to all nodes, 
         # by definition, we can remove me for simplicity.
         g.remove_nodes_from([myid])</pre></div></li><li class="listitem">Let's take a look <a id="id1995" class="indexterm"/>at the graph's <a id="id1996" class="indexterm"/>statistics:<div class="informalexample"><pre class="programlisting">In [21]: len(g.nodes()), len(g.edges())
Out[21]: (197, 1037)</pre></div></li><li class="listitem">We are now going to plot this graph. We will use different sizes and colors for the nodes, according to the number of followers and the number of tweets for each user. Most followed users will be bigger. Most active users will be redder.<div class="informalexample"><pre class="programlisting">In [22]: # Update the dictionary.
         deg = g.degree()
         for user in users_info.values():
             fc = user['followers_count']
             sc = user['statuses_count']
             # Is this user a Pythonista?
             user['python'] = 'python' in \ 
                              user['description'].lower()
             # We compute the node size as a function of 
             # the number of followers.
             user['node_size'] = math.sqrt(1 + 10 * fc)
             # The color is function of its activity
             user['node_color'] = 10 * math.sqrt(1 + sc)
             # We only display the name of the most 
             # followed users.
             user['label'] = user['screen_name'] \
                                 if fc &gt; 2000 else ''</pre></div></li><li class="listitem">Finally, we use<a id="id1997" class="indexterm"/> the <code class="literal">draw()</code> function to display<a id="id1998" class="indexterm"/> the graph. We need to specify the nodes' sizes and colors as lists, and the labels as a dictionary:<div class="informalexample"><pre class="programlisting">In [23]: node_size = [users_info[uid]['node_size']
                      for uid in g.nodes()]
In [24]: node_color = [users_info[uid]['node_color']
                       for uid in g.nodes()]
In [25]: labels = {uid: users_info[uid]['label']
                   for uid in g.nodes()}
In [26]: nx.draw(g, cmap=plt.cm.OrRd, alpha=.8,
                 node_size=node_size,
                 node_color=node_color,
                 labels=labels, font_size=4, width=.1)</pre></div><div class="mediaobject"><img src="images/4818OS_14_05.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec425"/>There's more…</h2></div></div></div><p>A great reference on social data analysis<a id="id1999" class="indexterm"/> with Python is Matthew A. Russel's book <span class="emphasis"><em>Mining the Social Web</em></span>, <span class="emphasis"><em>O'Reilly Media</em></span>. The code is available on GitHub as IPython notebooks at <a class="ulink" href="https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition">https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition</a>. The following networks are covered: Twitter, Facebook, LinkedIn, Google+, GitHub, mailboxes, websites, and others.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec426"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Manipulating and visualizing graphs with NetworkX</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Resolving dependencies in a directed acyclic graph with a topological sort"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec113"/>Resolving dependencies in a directed acyclic graph with a topological sort</h1></div></div></div><p>In this recipe, we will show an application of a well-known graph algorithm: <span class="strong"><strong>topological sorting</strong></span>. Let's<a id="id2000" class="indexterm"/> consider a directed graph describing dependencies between items. For example, in a package manager, before we can install a given package <span class="emphasis"><em>P</em></span>, we may need to install <span class="emphasis"><em>dependent</em></span> packages.</p><p>The set of dependencies <a id="id2001" class="indexterm"/>forms a <a id="id2002" class="indexterm"/>directed graph. With topological sorting, the package manager can resolve the dependencies and find the right installation order of the packages.</p><p>Topological sorting has many other applications. Here, we will illustrate this notion on real data from the Debian package manager. We will find the installation order of the required packages for IPython.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec427"/>Getting ready</h2></div></div></div><p>You need the <code class="literal">python-apt</code> package<a id="id2003" class="indexterm"/> in order to build the package dependency graph. The package is available at <a class="ulink" href="https://pypi.python.org/pypi/python-apt/">https://pypi.python.org/pypi/python-apt/</a>.</p><p>We also assume that this notebook is executed on a Debian system (such as Ubuntu). If you don't have such a system, you can download the <span class="emphasis"><em>Debian</em></span> dataset directly from the book's GitHub repository at <a class="ulink" href="https://github.com/ipython-books/cookbook-data">https://github.com/ipython-books/cookbook-data</a>. Extract it in the current directory, and start directly from step 7 in this notebook.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec428"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We import the <code class="literal">apt</code> module and we build the list of packages:<div class="informalexample"><pre class="programlisting">In [1]: import json
        import apt
        cache = apt.Cache()</pre></div></li><li class="listitem">The <code class="literal">graph</code> dictionary will contain the adjacency list of a small portion of the dependency graph:<div class="informalexample"><pre class="programlisting">In [2]: graph = {}</pre></div></li><li class="listitem">We define a function that returns the list of dependencies of a package:<div class="informalexample"><pre class="programlisting">In [3]: def get_dependencies(package):
            if package not in cache:
                return []
            pack = cache[package]
            ver = pack.candidate or pack.versions[0]
            # We flatten the list of dependencies,
            # and we remove the duplicates.
            return sorted(set([item.name 
                    for sublist in ver.dependencies 
                    for item in sublist]))</pre></div></li><li class="listitem">We now <a id="id2004" class="indexterm"/>define <a id="id2005" class="indexterm"/>a <span class="emphasis"><em>recursive</em></span> function that builds the dependency graph for a particular package. This function updates the <code class="literal">graph</code> variable:<div class="informalexample"><pre class="programlisting">In [4]: def get_dep_recursive(package):
            if package not in cache:
                return []
            if package not in graph:
                dep = get_dependencies(package)
                graph[package] = dep
            for dep in graph[package]:
                if dep not in graph:
                    graph[dep] = get_dep_recursive(dep)
            return graph[package]</pre></div></li><li class="listitem">Let's build the dependency graph for IPython:<div class="informalexample"><pre class="programlisting">In [5]: get_dep_recursive('ipython')</pre></div></li><li class="listitem">Finally, we save the adjacency list in JSON:<div class="informalexample"><pre class="programlisting">In [6]: with open('data/apt.json', 'w') as f:
            json.dump(graph, f, indent=1)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>Start here if you don't have a Debian operating system (you first need to download the <span class="emphasis"><em>Debian</em></span> dataset from the book's repository).</p></div></div></li><li class="listitem">We import a few packages:<div class="informalexample"><pre class="programlisting">In [7]: import json
        import numpy as np
        import networkx as nx
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">Let's load the adjacency list from the JSON file:<div class="informalexample"><pre class="programlisting">In [8]: with open('data/apt.json', 'r') as f:
            graph = json.load(f)</pre></div></li><li class="listitem">Now, we create a directed graph (<code class="literal">DiGraph</code> in NetworkX) from our adjacency list. We reverse the graph to get a more natural ordering:<div class="informalexample"><pre class="programlisting">In [9]: g = nx.DiGraph(graph).reverse()</pre></div></li><li class="listitem">A topological sort only exists when the graph is a <span class="strong"><strong>directed acyclic graph</strong></span> (<span class="strong"><strong>DAG</strong></span>). This means that there is no cycle in the graph, that is, no circular dependency. Is our graph a DAG? Let's see:<div class="informalexample"><pre class="programlisting">In [10]: nx.is_directed_acyclic_graph(g)
Out[10]: False</pre></div></li><li class="listitem">What are<a id="id2006" class="indexterm"/> the packages<a id="id2007" class="indexterm"/> responsible for the cycles? We can find them with the <code class="literal">simple_cycles()</code> function:<div class="informalexample"><pre class="programlisting">In [11]: set([cycle[0] for cycle in nx.simple_cycles(g)])
Out[11]: {u'coreutils', u'libc6', u'multiarch-support',
          u'python-minimal', u'tzdata'}</pre></div></li><li class="listitem">Here, we can try to remove these packages. In an actual package manager, these cycles need to be carefully taken into account.<div class="informalexample"><pre class="programlisting">In [12]: g.remove_nodes_from(_)
In [13]: nx.is_directed_acyclic_graph(g)
Out[13]: True</pre></div></li><li class="listitem">The graph is now a DAG. Let's display it first:<div class="informalexample"><pre class="programlisting">In [14]: ug = g.to_undirected()
         deg = ug.degree()
In [15]: # The size of the nodes depends on the number 
         # of dependencies.
         nx.draw(ug, font_size=6, 
              node_size=[20*deg[k] for k in ug.nodes()])</pre></div><div class="mediaobject"><img src="images/4818OS_14_06.jpg" alt="How to do it…"/></div></li><li class="listitem">Finally, we <a id="id2008" class="indexterm"/>can perform<a id="id2009" class="indexterm"/> the topological sort, thereby obtaining a linear installation order satisfying all dependencies:<div class="informalexample"><pre class="programlisting">In [16]: nx.topological_sort(g)
Out[16]: [u'libexpat1',
          u'libdb5.1',
          u'debconf-2.0',
          ...
          u'python-pexpect',
          u'python-configobj',
          u'ipython']</pre></div></li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec429"/>There's more…</h2></div></div></div><p>Directed acyclic graphs<a id="id2010" class="indexterm"/> are found in many applications. They can represent causal relations, influence diagrams, dependencies, and other concepts. For example, the version history of a distributed revision control system such as Git is described with a DAG.</p><p>Topological sorting<a id="id2011" class="indexterm"/> is useful in any scheduling task in general (project management and instruction scheduling).</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Topological sorting <a id="id2012" class="indexterm"/>on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Topological_sorting">http://en.wikipedia.org/wiki/Topological_sorting</a></li><li class="listitem" style="list-style-type: disc">Directed acyclic graphs, described <a id="id2013" class="indexterm"/>at <a class="ulink" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">http://en.wikipedia.org/wiki/Directed_acyclic_graph</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Computing connected components in an image"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec114"/>Computing connected components in an image</h1></div></div></div><p>In this recipe, we will show an application of graph theory in image processing. We will compute <span class="strong"><strong>connected components</strong></span><a id="id2014" class="indexterm"/> in an image. This method will allow us to label contiguous regions of an image, similar to the <span class="emphasis"><em>bucket</em></span> fill tool of paint programs.</p><p>Finding connected<a id="id2015" class="indexterm"/> components is also useful in many puzzle <a id="id2016" class="indexterm"/>video games such as Minesweeper, bubble shooters, and others. In these games, contiguous sets of items with the same color need to be automatically detected.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec430"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import the packages:<div class="informalexample"><pre class="programlisting">In [1]: import itertools
        import numpy as np
        import networkx as nx
        import matplotlib.colors as col
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We create a <span class="emphasis"><em>10 x 10</em></span> image where each pixel can take one of three possible labels (or colors):<div class="informalexample"><pre class="programlisting">In [2]: n = 10
In [3]: img = np.random.randint(size=(n, n), 
                                low=0, high=3)</pre></div></li><li class="listitem">Now, we create the underlying 2D grid graph encoding the structure of the image. Each node is a pixel, and a node is connected to its nearest neighbors. NetworkX defines a <code class="literal">grid_2d_graph</code> function to generate this graph:<div class="informalexample"><pre class="programlisting">In [4]: g = nx.grid_2d_graph(n, n)</pre></div></li><li class="listitem">Let's create two functions to display the image and the corresponding graph:<div class="informalexample"><pre class="programlisting">In [5]: def show_image(img, **kwargs):
            plt.imshow(img,
                       origin='lower',
                       interpolation='none',
                       **kwargs)
            plt.axis('off')
In [6]: def show_graph(g, **kwargs):
            nx.draw(g,
              pos={(i, j): (j, i) 
                   for (i, j) in g.nodes()},
              node_color=[img[i, j] 
                          for (i, j) in g.nodes()],
              linewidths=1, edge_color='w',
              with_labels=False, node_size=30, **kwargs)
In [7]: cmap = plt.cm.Blues</pre></div></li><li class="listitem">Here is the<a id="id2017" class="indexterm"/> original image superimposed with the underlying graph:<div class="informalexample"><pre class="programlisting">In [8]: show_image(img, cmap=cmap, vmin=-1)
        show_graph(g, cmap=cmap, vmin=-1)</pre></div><div class="mediaobject"><img src="images/4818OS_14_07.jpg" alt="How to do it…"/></div></li><li class="listitem">Now, we <a id="id2018" class="indexterm"/>are going to find all contiguous dark blue regions containing more than three pixels. First, we consider the <span class="emphasis"><em>subgraph</em></span> corresponding to all dark blue pixels:<div class="informalexample"><pre class="programlisting">In [9]: g2 = g.subgraph(zip(*np.nonzero(img==2)))
In [10]: show_image(img, cmap=cmap, vmin=-1)
         show_graph(g2, cmap=cmap, vmin=-1)</pre></div><div class="mediaobject"><img src="images/4818OS_14_08.jpg" alt="How to do it…"/></div></li><li class="listitem">We see that the requested contiguous regions correspond to the <span class="emphasis"><em>connected components</em></span> containing more than three nodes in the subgraph. We can use the <code class="literal">connected_components</code> function of NetworkX to find those components:<div class="informalexample"><pre class="programlisting">In [11]: components = [np.array(comp)
             for comp in nx.connected_components(g2)
             if len(comp)&gt;=3]
         len(components)
Out[11]: 3</pre></div></li><li class="listitem">Finally, we assign a new color to each of these components, and we display the new image:<div class="informalexample"><pre class="programlisting">In [12]: # We copy the image, and assign a new label
         # to each found component.
         img_bis = img.copy()
         for i, comp in enumerate(components):
             img_bis[comp[:,0], comp[:,1]] = i + 3
In [13]: # We create a new discrete color map extending
         # the previous map with new colors.
         colors = [cmap(.5), cmap(.75), cmap(1.), 
                   '#f4f235', '#f4a535', '#f44b35']
         cmap2 = col.ListedColormap(colors, 'indexed')
In [14]: show_image(img_bis, cmap=cmap2)</pre></div><div class="mediaobject"><img src="images/4818OS_14_09.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec431"/>How it works…</h2></div></div></div><p>The problem<a id="id2019" class="indexterm"/> we solved is called <a id="id2020" class="indexterm"/><span class="strong"><strong>connected-component labeling</strong></span>. It is also closely related to the<a id="id2021" class="indexterm"/> <span class="strong"><strong>flood-fill algorithm</strong></span>.</p><p>The idea to associate<a id="id2022" class="indexterm"/> a grid graph to an image is quite common in image processing. Here, contiguous color regions correspond to <span class="strong"><strong>connected components</strong></span><a id="id2023" class="indexterm"/> of subgraphs. A connected component can be defined as an equivalence class of the<a id="id2024" class="indexterm"/> <span class="strong"><strong>reachability</strong></span> relation. Two nodes are connected in the graph if there is a path from one node to the other. An equivalence class contains nodes that can be reached from one another.</p><p>Finally, the simple approach described here is only adapted to basic tasks on small images. More advanced algorithms are covered in <a class="link" href="ch11.html" title="Chapter 11. Image and Audio Processing">Chapter 11</a>, <span class="emphasis"><em>Image and Audio Processing</em></span>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec432"/>There's more…</h2></div></div></div><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connected components<a id="id2025" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29">http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29</a></li><li class="listitem" style="list-style-type: disc">Connected-component labeling<a id="id2026" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Connected-component_labeling">http://en.wikipedia.org/wiki/Connected-component_labeling</a></li><li class="listitem" style="list-style-type: disc">Flood-fill algorithm<a id="id2027" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Flood_fill">http://en.wikipedia.org/wiki/Flood_fill</a></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Computing the Voronoi diagram of a set of points"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec115"/>Computing the Voronoi diagram of a set of points</h1></div></div></div><p>The <span class="strong"><strong>Voronoi diagram</strong></span><a id="id2028" class="indexterm"/> of a set of <span class="emphasis"><em>seed</em></span> points divides space into several regions. Each region contains all points closer to one seed point than to any other seed point.</p><p>The Voronoi diagram is a fundamental structure in computational geometry. It is widely used in computer science, robotics, geography, and other disciplines. For example, the Voronoi diagram of a set of metro stations gives us the closest station from any point in the city.</p><p>In this recipe, we compute the <a id="id2029" class="indexterm"/>Voronoi diagram of the set of metro stations in Paris using SciPy.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec433"/>Getting ready</h2></div></div></div><p>You need the Smopy module to display the OpenStreetMap map of Paris. You can install this package with <code class="literal">pip install smopy</code>.</p><p>You also need to download the <span class="emphasis"><em>RATP</em></span> dataset from the book's GitHub repository at <a class="ulink" href="https://github.com/ipython-books/cookbook-data">https://github.com/ipython-books/cookbook-data</a> and extract it in the current directory. The data was obtained on <a id="id2030" class="indexterm"/>RATP's open data website (Paris' public transport operator, <a class="ulink" href="http://data.ratp.fr">http://data.ratp.fr</a>).</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec434"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import NumPy, pandas, matplotlib, and SciPy:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import pandas as pd
        import scipy.spatial as spatial
        import matplotlib.pyplot as plt
        import matplotlib.path as path
        import matplotlib as mpl
        import smopy
        %matplotlib inline</pre></div></li><li class="listitem">Let's load the dataset with pandas:<div class="informalexample"><pre class="programlisting">In [2]: df = pd.read_csv('data/ratp.csv',
                         sep='#', header=None)
In [3]: df[df.columns[1:]].tail(2)
Out[3]:   1      2              3              4     5
11609  2.30  48.93        TIMBAUD  GENNEVILLIERS  tram
11610  2.23  48.91   VICTOR BASCH       COLOMBES  tram</pre></div></li><li class="listitem">The <code class="literal">DataFrame</code> object<a id="id2031" class="indexterm"/> contains the coordinates, name, city, district, and type of station. Let's select all metro stations:<div class="informalexample"><pre class="programlisting">In [4]: metro = df[(df[5] == 'metro')]
In [5]: metro[metro.columns[1:]].tail(3)
Out[5]:
305  2.308  48.841  Volontaires  PARIS-15EME  metro
306  2.379  48.857     Voltaire  PARIS-11EME  metro
307  2.304  48.883       Wagram  PARIS-17EME  metro</pre></div></li><li class="listitem">We are going to extract the district number of Paris' stations. With pandas, we can use vectorized string operations using the <code class="literal">str</code> attribute of the corresponding column.<div class="informalexample"><pre class="programlisting">In [6]: # We only extract the district from stations
        # in Paris.
        paris = metro[4].str.startswith('PARIS').values
In [7]: # We create a vector of integers with the district
        # number of the corresponding station, or 0 
        # if the station is not in Paris.
        districts = np.zeros(len(paris), dtype=np.int32)
        districts[paris] = metro[4][paris].\
                     str.slice(6, 8).astype(np.int32)
        districts[~paris] = 0
        ndistricts = districts.max() + 1</pre></div></li><li class="listitem">We also extract the coordinates of all metro stations:<div class="informalexample"><pre class="programlisting">In [8]: lon = metro[1]
        lat = metro[2]</pre></div></li><li class="listitem">Now, let's retrieve Paris' map with OpenStreetMap. We specify the map's boundaries with the extreme latitude and longitude coordinates of all our metro stations. We use the lightweight Smopy module to generate the map:<div class="informalexample"><pre class="programlisting">In [9]: box = (lat[paris].min(), lon[paris].min(), 
               lat[paris].max(), lon[paris].max())
        m = smopy.Map(box, z=12)</pre></div></li><li class="listitem">We now compute the Voronoi diagram of the stations using SciPy. A <code class="literal">Voronoi</code> object is created with the points coordinates. It contains several attributes we will use for display:<div class="informalexample"><pre class="programlisting">In [10]: vor = spatial.Voronoi(np.c_[lat, lon])</pre></div></li><li class="listitem">We create a generic<a id="id2032" class="indexterm"/> function to display a Voronoi diagram. SciPy already implements such a function, but this function does not take infinite points into account. The implementation we will use has been obtained in Stack Overflow<a id="id2033" class="indexterm"/> and is present at <a class="ulink" href="http://stackoverflow.com/a/20678647/1595060">http://stackoverflow.com/a/20678647/1595060</a>. This function is relatively long, and we won't copy it entirely here. The full version can be found in the book's GitHub repository.<div class="informalexample"><pre class="programlisting">In [11]: def voronoi_finite_polygons_2d(vor, radius=None):
             """Reconstruct infinite Voronoi regions in a 
             2D diagram to finite regions."""
             ...</pre></div></li><li class="listitem">The <code class="literal">voronoi_finite_polygons_2d()</code> function returns a list of regions and a list of vertices. Every region is a list of vertex indices. The coordinates of all vertices are stored in <code class="literal">vertices</code>. From these structures, we can create a list of <span class="emphasis"><em>cells</em></span>. Every cell represents a polygon as an array of vertex coordinates. We also use the <code class="literal">to_pixels()</code> method of the <code class="literal">smopy.Map</code> instance. This function converts latitude and longitude geographical coordinates to pixels in the image.<div class="informalexample"><pre class="programlisting">In [12]: regions, vertices = \
                     voronoi_finite_polygons_2d(vor)
         cells = [m.to_pixels(vertices[region])
                  for region in regions]</pre></div></li><li class="listitem">Now, we compute the color of every polygon:<div class="informalexample"><pre class="programlisting">In [13]: cmap = plt.cm.Set3
         # We generate colors for districts using
         # a color map.
         colors_districts = cmap(
                   np.linspace(0., 1., ndistricts))[:,:3]
         # The color of every polygon, grey by default.
         colors = .25 * np.ones((len(districts), 3))
         # We give each polygon in Paris the color of 
         # its district.
         colors[paris] = colors_districts[districts[paris]]</pre></div></li><li class="listitem">Finally, we display the<a id="id2034" class="indexterm"/> map with the Voronoi diagram, using the <code class="literal">show_mpl()</code> method of the <code class="literal">Map</code> instance:<div class="informalexample"><pre class="programlisting">In [14]: ax = m.show_mpl()
         ax.add_collection(
             mpl.collections.PolyCollection(cells,
                facecolors=colors, edgecolors='k',
                alpha=0.35,))</pre></div><div class="mediaobject"><img src="images/4818OS_14_10.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec435"/>How it works…</h2></div></div></div><p>Let's give the mathematical definition of the Voronoi diagram in a Euclidean space. If <span class="emphasis"><em>(x<sub>i</sub>)</em></span> is a set of points, the Voronoi diagram of this set of points is the collection of subsets <span class="emphasis"><em>V<sub>i</sub></em></span> (called <span class="strong"><strong>cells</strong></span><a id="id2035" class="indexterm"/> or <a id="id2036" class="indexterm"/><span class="strong"><strong>regions</strong></span>) defined by:</p><div class="mediaobject"><img src="images/4818OS_14_11.jpg" alt="How it works…"/></div><p>The dual graph of the Voronoi diagram is the <a id="id2037" class="indexterm"/><span class="strong"><strong>Delaunay triangulation</strong></span>. This geometrical object covers the convex hull of the set of points with triangles.</p><p>SciPy computes Voronoi diagrams with <a id="id2038" class="indexterm"/><span class="strong"><strong>Qhull</strong></span>, a computational geometry library in C++.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec436"/>There's more…</h2></div></div></div><p>Here are further references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Voronoi diagram<a id="id2039" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Voronoi_diagram">http://en.wikipedia.org/wiki/Voronoi_diagram</a></li><li class="listitem" style="list-style-type: disc">Delaunay triangulation<a id="id2040" class="indexterm"/> on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Delaunay_triangulation">http://en.wikipedia.org/wiki/Delaunay_triangulation</a></li><li class="listitem" style="list-style-type: disc">The documentation of <code class="literal">scipy.spatial.voronoi</code> <a id="id2041" class="indexterm"/>available at <a class="ulink" href="http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html">http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html</a></li><li class="listitem" style="list-style-type: disc">The Qhull<a id="id2042" class="indexterm"/> library available at <a class="ulink" href="http://www.qhull.org">www.qhull.org</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec437"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Manipulating geospatial data with Shapely and basemap</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Manipulating geospatial data with Shapely and basemap"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec116"/>Manipulating geospatial data with Shapely and basemap</h1></div></div></div><p>In this recipe, we will show how to load and display geographical data in the Shapefile format. Specifically, we will use data from <span class="strong"><strong>Natural Earth</strong></span><a id="id2043" class="indexterm"/> (<a class="ulink" href="http://www.naturalearthdata.com">www.naturalearthdata.com</a>) to display the countries of Africa, color coded with their population and <a id="id2044" class="indexterm"/><span class="strong"><strong>Gross Domestic Product</strong></span> (<span class="strong"><strong>GDP</strong></span>).</p><p>
<span class="strong"><strong>Shapefile</strong></span> (<a class="ulink" href="http://en.wikipedia.org/wiki/Shapefile">http://en.wikipedia.org/wiki/Shapefile</a>) is<a id="id2045" class="indexterm"/> a popular geospatial <a id="id2046" class="indexterm"/>vector data format for GIS software. It can be read by <span class="strong"><strong>Fiona</strong></span>, a Python wrapper to <span class="strong"><strong>GDAL/OGR</strong></span><a id="id2047" class="indexterm"/> (a C++ library supporting GIS file formats). We will also use<a id="id2048" class="indexterm"/> <span class="strong"><strong>Shapely</strong></span>, a Python package used to handle two-dimensional geometrical shapes, and<a id="id2049" class="indexterm"/> <span class="strong"><strong>descartes</strong></span>, used to render Shapely shapes in matplotlib. Finally, we will use <span class="strong"><strong>basemap</strong></span><a id="id2050" class="indexterm"/> to plot maps.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec438"/>Getting ready</h2></div></div></div><p>You need the following packages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GDAL/OGR<a id="id2051" class="indexterm"/> available at <a class="ulink" href="http://www.gdal.org/ogr/">www.gdal.org/ogr/</a></li><li class="listitem" style="list-style-type: disc">Fiona<a id="id2052" class="indexterm"/> available at <a class="ulink" href="http://toblerity.org/fiona/README.html">http://toblerity.org/fiona/README.html</a></li><li class="listitem" style="list-style-type: disc">Shapely<a id="id2053" class="indexterm"/> available at <a class="ulink" href="http://toblerity.org/shapely/project.html">http://toblerity.org/shapely/project.html</a></li><li class="listitem" style="list-style-type: disc">descartes<a id="id2054" class="indexterm"/> available at <a class="ulink" href="https://pypi.python.org/pypi/descartes">https://pypi.python.org/pypi/descartes</a></li><li class="listitem" style="list-style-type: disc">Basemap<a id="id2055" class="indexterm"/> available at <a class="ulink" href="http://matplotlib.org/basemap/">http://matplotlib.org/basemap/</a></li></ul></div><p>With Anaconda, you can do:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>conda install gdal</strong></span>
<span class="strong"><strong>conda install fiona</strong></span>
<span class="strong"><strong>conda install basemap</strong></span>
</pre></div><p>Shapely and descartes can be installed with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install shapely</strong></span>
<span class="strong"><strong>pip install descartes</strong></span>
</pre></div><p>On Windows, you can find binary installers for all of those packages except descartes on Chris Gohlke's webpage, <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">www.lfd.uci.edu/~gohlke/pythonlibs/</a>.</p><p>On other systems, you can find installation instructions on the projects' websites. GDAL/OGR is a C++ library that is required by Fiona. The other packages are regular Python packages.</p><p>Finally, you need to download the <span class="emphasis"><em>Africa</em></span> dataset on the book's GitHub repository at <a class="ulink" href="https://github.com/ipython-books/cookbook-data">https://github.com/ipython-books/cookbook-data</a>. The data was obtained on Natural Earth's website, <a class="ulink" href="http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/">www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec439"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's <a id="id2056" class="indexterm"/>import <a id="id2057" class="indexterm"/>the packages:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import matplotlib.pyplot as plt
        import matplotlib.collections as col
        from mpl_toolkits.basemap import Basemap
        import fiona
        import shapely.geometry as geom
        from descartes import PolygonPatch
        %matplotlib inline</pre></div></li><li class="listitem">We load <a id="id2058" class="indexterm"/>the <span class="emphasis"><em>Shapefile</em></span> dataset with Fiona. This<a id="id2059" class="indexterm"/> dataset notably contains the borders of all countries in the world.<div class="informalexample"><pre class="programlisting">In [2]: # Natural Earth data
        countries = fiona.open(
                       "data/ne_10m_admin_0_countries.shp")</pre></div></li><li class="listitem">We select the countries in Africa:<div class="informalexample"><pre class="programlisting">In [3]: africa = [c for c in countries 
            if c['properties']['CONTINENT'] == 'Africa']</pre></div></li><li class="listitem">Now, we create a basemap map showing the African continent:<div class="informalexample"><pre class="programlisting">In [4]: m = Basemap(llcrnrlon=-23.03,
                    llcrnrlat=-37.72,
                    urcrnrlon=55.20,
                    urcrnrlat=40.58)</pre></div></li><li class="listitem">Let's write <a id="id2060" class="indexterm"/>a function converting the <a id="id2061" class="indexterm"/>geographical <a id="id2062" class="indexterm"/>coordinates of the<a id="id2063" class="indexterm"/> countries' borders to map coordinates. This will allow us to display the borders in basemap:<div class="informalexample"><pre class="programlisting">In [5]: def _convert(poly, m):
            if isinstance(poly, list):
                return [_convert(_, m) for _ in poly]
            elif isinstance(poly, tuple):
                return m(*poly)
In [6]: for _ in africa:
            _['geometry']['coordinates'] = _convert(
                _['geometry']['coordinates'], m)</pre></div></li><li class="listitem">The next step is to create matplotlib <code class="literal">PatchCollection</code> objects from the <span class="emphasis"><em>Shapefile</em></span> dataset loaded with Fiona. We use Shapely and descartes for this:<div class="informalexample"><pre class="programlisting">In [7]: def get_patch(shape, **kwargs):
            """Return a matplotlib PatchCollection from a 
            geometry object loaded with fiona."""
            # Simple polygon.
            if isinstance(shape, geom.Polygon):
                return col.PatchCollection(
                      [PolygonPatch(shape, **kwargs)],
                      match_original=True)
            # Collection of polygons.
            elif isinstance(shape, geom.MultiPolygon):
                return col.PatchCollection(
                       [PolygonPatch(c, **kwargs)
                        for c in shape],
                       match_original=True)
In [8]: def get_patches(shapes, fc=None, 
                        ec=None, **kwargs):
            """Return a list of matplotlib PatchCollection 
            objects from a Shapefile dataset."""
            # fc and ec are the face and edge colors of the 
            # countries. We ensure these are lists of 
            # colors, with one element per country.
            if not isinstance(fc, list):
                fc = [fc] * len(shapes)
            if not isinstance(ec, list):
                ec = [ec] * len(shapes)
            # We convert each polygon to a matplotlib 
            # PatchCollection object.
            return [get_patch(geom.shape(s['geometry']), 
                              fc=fc_, ec=ec_, **kwargs) 
                    for s, fc_, ec_ in zip(shapes, fc, ec)]</pre></div></li><li class="listitem">We also<a id="id2064" class="indexterm"/> define a function to <a id="id2065" class="indexterm"/>get countries' <a id="id2066" class="indexterm"/>colors depending on a <a id="id2067" class="indexterm"/>specific field in the <span class="emphasis"><em>Shapefile</em></span> dataset. Indeed, our dataset not only contains countries borders, but also a few administrative, economical, and geographical properties for each country. Here, we will choose the color according to the countries' population and GDP:<div class="informalexample"><pre class="programlisting">In [9]: def get_colors(field, cmap):
            """Return one color per country, depending on a 
            specific field in the dataset."""
            values = [country['properties'][field]
                      for country in africa]
            values_max = max(values)
            return [cmap(v / values_max) for v in values]</pre></div></li><li class="listitem">Finally, we display the maps. We display the coastlines with basemap, and the countries with our <span class="emphasis"><em>Shapefile</em></span> dataset:<div class="informalexample"><pre class="programlisting">In [10]: # Display the countries color-coded with
         # their population.
         ax = plt.subplot(121)
         m.drawcoastlines()
         patches = get_patches(africa, 
                               fc=get_colors('POP_EST',
                                             plt.cm.Reds), 
                               ec='k')
         for p in patches:
             ax.add_collection(p)
         plt.title("Population")
         # Display the countries color-coded with
         # their population.
         ax = plt.subplot(122)
         m.drawcoastlines()
         patches = get_patches(africa, 
                               fc=get_colors('GDP_MD_EST',
                                             plt.cm.Blues), 
                               ec='k')
         for p in patches:
             ax.add_collection(p)
         plt.title("GDP")</pre></div><div class="mediaobject"><img src="images/4818OS_14_12.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec440"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a route planner for a road network</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating a route planner for a road network"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec117"/>Creating a route planner for a road network</h1></div></div></div><p>In this recipe, we build upon <a id="id2068" class="indexterm"/>several techniques described in the <a id="id2069" class="indexterm"/>previous recipes in order to create a simple GPS-like route planner in Python. We will retrieve California's road network data from the United States Census Bureau in order to find shortest paths in the road network graph. This allows us to display road itineraries between any two locations in California.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec441"/>Getting ready</h2></div></div></div><p>You need NetworkX and Smopy for this recipe. In order for NetworkX to read Shapefile datasets, you also need GDAL/OGR. You can find more information in the previous recipe.</p><p>You also need to download the <span class="emphasis"><em>Road</em></span> dataset from the book's GitHub repository at <a class="ulink" href="https://github.com/ipython-books/cookbook-data">https://github.com/ipython-books/cookbook-data</a>, and extract it in the current directory.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>At the time of this writing, NetworkX's support of Shapefile doesn't seem to be compatible with Python 3.x. For this reason, this recipe has only been successfully tested with Python 2.x.</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec442"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import the packages:<div class="informalexample"><pre class="programlisting">In [1]: import networkx as nx
        import numpy as np
        import pandas as pd
        import json
        import smopy
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">We load the<a id="id2070" class="indexterm"/> data (a Shapefile dataset) with<a id="id2071" class="indexterm"/> NetworkX. This dataset contains detailed information about the primary roads in California. NetworkX's <code class="literal">read_shp()</code> function returns a graph, where each node is a geographical position, and each edge contains information about the road linking the two nodes. The data comes from the United States <a id="id2072" class="indexterm"/>Census Bureau website at <a class="ulink" href="http://www.census.gov/geo/maps-data/data/tiger.html">www.census.gov/geo/maps-data/data/tiger.html</a>.<div class="informalexample"><pre class="programlisting">In [2]: g = nx.read_shp("data/tl_2013_06_prisecroads.shp")</pre></div></li><li class="listitem">This graph is not necessarily connected, but we need a connected graph in order to compute shortest paths. Here, we take the largest connected subgraph using the <code class="literal">connected_component_subgraphs()</code> function:<div class="informalexample"><pre class="programlisting">In [3]: sgs = list(nx.connected_component_subgraphs(
                   g.to_undirected()))
        largest = np.argmax([len(sg) 
                             for sg in sgs])
        sg = sgs[largest]
        len(sg)
Out[3]: 464</pre></div></li><li class="listitem">We define two positions (with the latitude and longitude) and find the shortest path between these two positions:<div class="informalexample"><pre class="programlisting">In [4]: pos0 = (36.6026, -121.9026)
        pos1 = (34.0569, -118.2427)</pre></div></li><li class="listitem">Each edge in the graph contains information about the road, including a list of points along this road. We first create a function that returns this array of coordinates, for any edge in the graph:<div class="informalexample"><pre class="programlisting">In [5]: def get_path(n0, n1):
            """If n0 and n1 are connected nodes in the 
            graph, this function returns an array of point
            coordinates along the road linking these
            two nodes."""
            return np.array(json.loads(
                      sg[n0][n1]['Json'])['coordinates'])</pre></div></li><li class="listitem">We can notably use the road path to compute its length. We first need to define a function that computes the distance between any two points in geographical coordinates. This function has been <a id="id2073" class="indexterm"/>found in Stack Overflow (<a class="ulink" href="http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance">http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance</a>):<div class="informalexample"><pre class="programlisting">In [6]: EARTH_R = 6372.8
        def geocalc(lat0, lon0, lat1, lon1):
            """Return the distance (in km) between two
            points in geographical coordinates."""
            lat0 = np.radians(lat0)
            lon0 = np.radians(lon0)
            lat1 = np.radians(lat1)
            lon1 = np.radians(lon1)
            dlon = lon0 - lon1
            y = np.sqrt(
                  (np.cos(lat1)*np.sin(dlon))**2
                  +(np.cos(lat0)*np.sin(lat1) 
                    -np.sin(lat0)*np.cos(lat1)* \
                     np.cos(dlon))**2)
            x = np.sin(lat0)*np.sin(lat1) + \
                np.cos(lat0)*np.cos(lat1)*np.cos(dlon)
            c = np.arctan2(y, x)
            return EARTH_R * c</pre></div></li><li class="listitem">Now, we define a function computing a path's length:<div class="informalexample"><pre class="programlisting">In [7]: def get_path_length(path):
            return np.sum(geocalc(
                            path[1:,0], path[1:,1],
                            path[:-1,0], path[:-1,1]))</pre></div></li><li class="listitem">Now, we<a id="id2074" class="indexterm"/> update our graph by computing the <a id="id2075" class="indexterm"/>distance between any two connected nodes. We add this information in the <code class="literal">distance</code> attribute of the edges:<div class="informalexample"><pre class="programlisting">In [8]: # Compute the length of the road segments.
        for n0, n1 in sg.edges_iter():
            path = get_path(n0, n1)
            distance = get_path_length(path)
            sg.edge[n0][n1]['distance'] = distance</pre></div></li><li class="listitem">The last step before we can find the shortest path in the graph is to find the two nodes in the graph that are closest to the two requested positions:<div class="informalexample"><pre class="programlisting">In [9]: nodes = np.array(sg.nodes())
        # Get the closest nodes in the graph.
        pos0_i = np.argmin(np.sum(
                               (nodes[:,::-1] - pos0)**2,
                               axis=1))
        pos1_i = np.argmin(np.sum(
                               (nodes[:,::-1] - pos1)**2,
                              axis=1))</pre></div></li><li class="listitem">Now, we use NetworkX's <code class="literal">shortest_path()</code> function<a id="id2076" class="indexterm"/> to compute the shortest path between our two positions. We specify that the weight of every edge is the length of the road between them:<div class="informalexample"><pre class="programlisting">In [10]: # Compute the shortest path.
         path = nx.shortest_path(sg, 
                        source=tuple(nodes[pos0_i]), 
                        target=tuple(nodes[pos1_i]),
                        weight='distance')
         len(path)
Out[10]: 19</pre></div></li><li class="listitem">The<a id="id2077" class="indexterm"/> itinerary has been computed. The <code class="literal">path</code> variable contains the list of edges that form the shortest path between <a id="id2078" class="indexterm"/>our two positions. Now, we can get information about the itinerary with pandas. The dataset has a few fields of interest, including the name and type (State, Interstate, and so on) of the roads:<div class="informalexample"><pre class="programlisting">In [11]: roads = pd.DataFrame([
                     sg.edge[path[i]][path[i + 1]] 
                             for i in range(len(path)-1)], 
                     columns=['FULLNAME', 'MTFCC', 
                             'RTTYP', 'distance'])
         roads
Out[11]:  FULLNAME  MTFCC RTTYP    distance
0      State Rte 1  S1200     S  100.657768
1      State Rte 1  S1200     S   33.419581
...
16   Hollywood Fwy  S1200     M   14.087627
17   Hollywood Fwy  S1200     M    0.010107</pre></div><p>Here is the total length of this itinerary:</p><div class="informalexample"><pre class="programlisting">In [12]: roads['distance'].sum()
Out[12]: 508.66421585288725</pre></div></li><li class="listitem">Finally, let's display the itinerary on the map. We first retrieve the map with Smopy:<div class="informalexample"><pre class="programlisting">In [13]: map = smopy.Map(pos0, pos1, z=7, margin=.1)</pre></div></li><li class="listitem">Our path contains connected nodes in the graph. Every edge between two nodes is characterized by a list of points (constituting a part of the road). Therefore, we need to define a function that concatenates the positions along every edge in the path. We have to concatenate the positions in the right order along our path. We choose the order based on the fact that the last point in an edge needs to be close to the first point in the next edge:<div class="informalexample"><pre class="programlisting">In [14]: def get_full_path(path):
             """Return the positions along a path."""
             p_list = []
             curp = None
             for i in range(len(path)-1):
                 p = get_path(path[i], path[i+1])
                 if curp is None:
                     curp = p
                 if np.sum((p[0]-curp)**2) &gt; \
                                  np.sum((p[-1]-curp)**2):
                     p = p[::-1,:]
                 p_list.append(p)
                 curp = p[-1]
             return np.vstack(p_list)</pre></div></li><li class="listitem">We convert <a id="id2079" class="indexterm"/>the path in pixels in order <a id="id2080" class="indexterm"/>to display it on the Smopy map:<div class="informalexample"><pre class="programlisting">In [15]: linepath = get_full_path(path)
         x, y = map.to_pixels(linepath[:,1], linepath[:,0])</pre></div></li><li class="listitem">Finally, let's display the map, with our two positions and the computed itinerary between them:<div class="informalexample"><pre class="programlisting">In [16]: map.show_mpl()
         # Plot the itinerary.
         plt.plot(x, y, '-k', lw=1.5)
         # Mark our two positions.
         plt.plot(x[0], y[0], 'ob', ms=10)
         plt.plot(x[-1], y[-1], 'or', ms=10)</pre></div><div class="mediaobject"><img src="images/4818OS_14_13.jpg" alt="How to do it…"/></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec443"/>How it works…</h2></div></div></div><p>We computed<a id="id2081" class="indexterm"/> the shortest path with NetworkX's<a id="id2082" class="indexterm"/> <code class="literal">shortest_path()</code> function. Here, this function used <span class="strong"><strong>Dijkstra's algorithm</strong></span>. This <a id="id2083" class="indexterm"/>algorithm <a id="id2084" class="indexterm"/>has a wide variety of applications, for example in network routing protocols.</p><p>There are different ways to compute the geographical distance between two points. Here, we used a relatively precise formula: the <span class="strong"><strong>orthodromic distance</strong></span><a id="id2085" class="indexterm"/> (also called <a id="id2086" class="indexterm"/><span class="strong"><strong>great-circle distance</strong></span>), which assumes that the Earth is a perfect sphere. We could also have used a simpler formula since the distance between two successive points on a road is small.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec444"/>There's more…</h2></div></div></div><p>You can find more information about shortest path problems and Dijkstra's algorithm in the following references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shortest paths on <a id="id2087" class="indexterm"/>Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Shortest_path_problem">http://en.wikipedia.org/wiki/Shortest_path_problem</a></li><li class="listitem" style="list-style-type: disc">Dijkstra's algorithm<a id="id2088" class="indexterm"/>, described at <a class="ulink" href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a></li></ul></div><p>Here are a few references about geographical distances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Geographical distance on <a id="id2089" class="indexterm"/>Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Geographical_distance">http://en.wikipedia.org/wiki/Geographical_distance</a></li><li class="listitem" style="list-style-type: disc">Great circles<a id="id2090" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Great_circle">http://en.wikipedia.org/wiki/Great_circle</a></li><li class="listitem" style="list-style-type: disc">Great-circle distance<a id="id2091" class="indexterm"/> on Wikipedia, at <a class="ulink" href="http://en.wikipedia.org/wiki/Great-circle_distance">http://en.wikipedia.org/wiki/Great-circle_distance</a></li></ul></div></div></div></div>
</body></html>