<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-123"><a id="_idTextAnchor122"/>5</h1>
<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Working with Genomes</h1>
<p>Many tasks in computational biology are dependent on the existence of reference genomes. If you are performing sequence alignment, finding genes, or studying the genetics of populations, you will be directly or indirectly using a reference genome. In this chapter, we will develop some recipes for working with reference genomes and dealing with references of varying quality, which can range from high quality (by high quality, we only refer to the state of the genome’s assembly, which is the focus of this chapter), as with the human genome, to problematic with non-model species. We will also learn how to deal with genome annotations (working with databases that will point us to interesting features in the genome) and extract sequence data using the annotation information. We will also try to find some gene orthologs across species. Finally, we will access a <strong class="bold">Gene Ontology</strong> (<strong class="bold">GO</strong>) database.</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Working with high-quality reference genomes</li>
<li>Dealing with low-quality reference genomes</li>
<li>Traversing genome annotations</li>
<li>Extracting genes from a reference using annotations</li>
<li>Finding orthologues with the Ensembl REST API</li>
<li>Retrieving gene ontology information from Ensembl</li>
</ul>
<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Technical requirements</h1>
<p>If you are running this chapter’s content via Docker, you can use the <strong class="source-inline">tiagoantao/bioinformatics_genomes</strong> image. If you are using Anaconda, the required software for this chapter will be introduced in each relevant section.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Working with high-quality reference genomes</h1>
<p>In this recipe, you will learn<a id="_idIndexMarker331"/> about a few general techniques to manipulate reference genomes. As an illustrative example, we will study the GC content – the fraction of the genome that is based on guanine-cytosine in <em class="italic">Plasmodium falciparum</em>, the most important parasite species that causes malaria. Reference genomes are normally made available as FASTA files.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Getting ready</h2>
<p>Organism genomes come in widely different sizes, ranging from viruses such as HIV, which is 9.7 kbp, to bacteria such as <em class="italic">E. coli</em>, to protozoans such as <em class="italic">Plasmodium falciparum</em>, which has a 22 Mbp spread across 14 chromosomes, mitochondrion, and apicoplast, to the fruit fly with three autosomes, a mitochondrion, and X/Y sex chromosomes, to humans with their three Gbp pairs spread across 22 autosomes, X/Y chromosomes, and mitochondria, all the way up to <em class="italic">Paris japonica</em>, a plant with 150 Gbp of the genome. Along the way, you have different ploidy and sex chromosome organizations.</p>
<p class="callout-heading">Tip</p>
<p class="callout">As you can see, different organisms have very different genome sizes. This difference can be of several orders of magnitude. This can have significant implications for your programming style. Working with a large genome will require you to be more conservative with memory. Unfortunately, larger genomes would benefit from more speed-efficient programming techniques (as you have much more data to analyze); these are conflicting requirements. The general rule is that you have to be much more careful with efficiency (both speed and memory) with larger genomes.</p>
<p>To make this recipe less of a burden, we will use a small eukaryotic genome from <em class="italic">Plasmodium falciparum</em>. This genome still has many typical features of larger genomes (for example, multiple chromosomes). Therefore, it’s a good compromise between complexity and size. Note that with a genome that’s the size of <em class="italic">Plasmodium falciparum</em>, it will be possible to perform many operations by loading the whole genome in memory. However, we opted for a programming style that can be used with bigger genomes (for example, mammals) so that you can use this recipe in a more general way, but feel free to use more memory-intensive approaches with small genomes like this.</p>
<p>We will use Biopython, which you installed in <a href="B17942_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Python and the Surrounding Software Ecology</em>. As usual, this recipe is available in this book’s Jupyter notebook as <strong class="source-inline">Chapter05/Reference_Genome.py</strong>, in the code bundle for this book. We will need to download the reference <a id="_idIndexMarker332"/>genome – you can find the up-to-date location in the aforementioned notebook. To generate the chart at the end of this recipe, we will need <strong class="source-inline">reportlab</strong>:</p>
<p class="source-code">conda install -c bioconda reportlab</p>
<p>Now, we’re ready to begin.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>How to do it...</h2>
<p>Follow these steps:</p>
<ol>
<li>We will start by inspecting the description of all of the sequences in the reference genome’s FASTA file:<p class="source-code">from Bio import SeqIO</p><p class="source-code">genome_name = 'PlasmoDB-9.3_Pfalciparum3D7_Genome.fasta'</p><p class="source-code">recs = SeqIO.parse(genome_name, 'fasta')</p><p class="source-code">for rec in recs:</p><p class="source-code">    print(rec.description)</p></li>
</ol>
<p>This code should look familiar from the previous chapter, <a href="B17942_03.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Next-Generation Sequencing</em>. Let’s take a look at part of the output:</p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt="" height="412" src="image/B17942_05_001.jpg" width="1328"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The output showing the FASTA descriptions for the reference genome of Plasmodium falciparum</p>
<p>Different genome<a id="_idIndexMarker333"/> references will have different description lines, but they will generally contain important information. In this example, you can see that we have chromosomes, mitochondria, and apicoplast. We can also view the chromosome sizes, but we will take the value from the sequence length instead.</p>
<ol>
<li value="2">Let’s parse the description line to extract the chromosome number. We will retrieve the chromosome size from the sequence and compute the <strong class="source-inline">GC</strong> content across chromosomes on a window basis:<p class="source-code">from Bio import SeqUtils</p><p class="source-code">recs = SeqIO.parse(genome_name, 'fasta')</p><p class="source-code">chrom_sizes = {}</p><p class="source-code">chrom_GC = {}</p><p class="source-code">block_size = 50000</p><p class="source-code">min_GC = 100.0</p><p class="source-code">max_GC = 0.0</p><p class="source-code">for rec in recs:</p><p class="source-code">    if rec.description.find('SO=chromosome') == -1:</p><p class="source-code">        continue</p><p class="source-code">    chrom = int(rec.description.split('_')[1])</p><p class="source-code">    chrom_GC[chrom] = []</p><p class="source-code">    size = len(rec.seq)</p><p class="source-code">    chrom_sizes[chrom] = size</p><p class="source-code">    num_blocks = size // block_size + 1</p><p class="source-code">    for block in range(num_blocks):</p><p class="source-code">        start = block_size * block</p><p class="source-code">        if block == num_blocks - 1:</p><p class="source-code">            end = size</p><p class="source-code">        else:</p><p class="source-code">            end = block_size + start + 1</p><p class="source-code">        block_seq = rec.seq[start:end]</p><p class="source-code">        block_GC = SeqUtils.GC(block_seq)</p><p class="source-code">        if block_GC &lt; min_GC:</p><p class="source-code">            min_GC = block_GC</p><p class="source-code">        if block_GC &gt; max_GC:</p><p class="source-code">            max_GC = block_GC</p><p class="source-code">        chrom_GC[chrom].append(block_GC)</p><p class="source-code">print(min_GC, max_GC)</p></li>
</ol>
<p>Here, we have performed a windowed analysis of all chromosomes, similar to what we did in <a href="B17942_03.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Next-Generation Sequencing</em>. We started by defining a window <a id="_idIndexMarker334"/>size of 50 kbp. This is appropriate for <em class="italic">Plasmodium falciparum</em> (feel free to vary its size), but you will want to consider other values for genomes with chromosomes that are orders of magnitude different from this.</p>
<p>Note that we are re-reading the file. With such a small genome, it would have been feasible (in <em class="italic">Step 1</em>) to do an in-memory load of the whole genome. By all means, feel free to try this programming style for small genomes – it’s faster! However, our code is designed to be reused with larger genomes.</p>
<ol>
<li value="3">Note that in the <strong class="source-inline">for</strong> loop, we ignore the mitochondrion and apicoplast by parsing the <strong class="source-inline">SO</strong> entry to the description. The <strong class="source-inline">chrom_sizes</strong> dictionary will maintain the size of chromosomes.</li>
</ol>
<p>The <strong class="source-inline">chrom_GC</strong> dictionary is our most interesting data structure and will contain a list of a <a id="_idIndexMarker335"/>fraction of the <strong class="source-inline">GC</strong> content for each 50 kbp window. So, for chromosome 1, which has a size of 640,851 bp, there will be 14 entries because this chromosome’s size is 14 blocks of 50 kbp.</p>
<p>Be aware of two unusual features of the <em class="italic">Plasmodium falciparum</em> genome: the genome is very AT-rich – that is, GC-poor. Therefore, the numbers that you will get will be very low. Also, chromosomes are ordered based on size (as is common) but starting with the smallest size. The usual convention is to start with the largest size (such as with genomes in humans).</p>
<ol>
<li value="4">Now, let’s create a genome plot of the <strong class="source-inline">GC</strong> distribution. We will use shades of blue for the <strong class="source-inline">GC</strong> content. However, for high outliers, we will use shades of red. For low outliers, we will use shades of yellow:<p class="source-code">from reportlab.lib import colors</p><p class="source-code">from reportlab.lib.units import cm</p><p class="source-code">from Bio.Graphics import BasicChromosome</p><p class="source-code">chroms = list(chrom_sizes.keys())</p><p class="source-code">chroms.sort()</p><p class="source-code">biggest_chrom = max(chrom_sizes.values())</p><p class="source-code">my_genome = BasicChromosome.Organism(output_format="png")</p><p class="source-code">my_genome.page_size = (29.7*cm, 21*cm)</p><p class="source-code">telomere_length = 10</p><p class="source-code">bottom_GC = 17.5</p><p class="source-code">top_GC = 22.0</p><p class="source-code">for chrom in chroms:</p><p class="source-code">    chrom_size = chrom_sizes[chrom]</p><p class="source-code">    chrom_representation = BasicChromosome.Chromosome ('Cr %d' % chrom)</p><p class="source-code">    chrom_representation.scale_num = biggest_chrom</p><p class="source-code">    tel = BasicChromosome.TelomereSegment()</p><p class="source-code">    tel.scale = telomere_length</p><p class="source-code">    chrom_representation.add(tel)</p><p class="source-code">    num_blocks = len(chrom_GC[chrom])</p><p class="source-code">    for block, gc in enumerate(chrom_GC[chrom]):</p><p class="source-code">        my_GC = chrom_GC[chrom][block]</p><p class="source-code">        body = BasicChromosome.ChromosomeSegment()</p><p class="source-code">        if my_GC &gt; top_GC:</p><p class="source-code">            body.fill_color = colors.Color(1, 0, 0)</p><p class="source-code">        elif my_GC &lt; bottom_GC:</p><p class="source-code">            body.fill_color = colors.Color(1, 1, 0)</p><p class="source-code">        else:</p><p class="source-code">            my_color = (my_GC - bottom_GC) / (top_GC -bottom_GC)</p><p class="source-code">            body.fill_color = colors.Color(my_color,my_color, 1)</p><p class="source-code">        if block &lt; num_blocks - 1:</p><p class="source-code">            body.scale = block_size</p><p class="source-code">        else:</p><p class="source-code">            body.scale = chrom_size % block_size</p><p class="source-code">        chrom_representation.add(body)</p><p class="source-code">    tel = BasicChromosome.TelomereSegment(inverted=True)</p><p class="source-code">    tel.scale = telomere_length</p><p class="source-code">    chrom_representation.add(tel)</p><p class="source-code">    my_genome.add(chrom_representation)</p><p class="source-code">my_genome.draw('falciparum.png', 'Plasmodium falciparum')</p></li>
</ol>
<p>The first line converts the return of the <strong class="source-inline">keys</strong> method into a list. This was redundant in Python 2, but not in Python 3, where the <strong class="source-inline">keys</strong> method has a specific <strong class="source-inline">dict_keys</strong> return type.</p>
<p>We draw the<a id="_idIndexMarker336"/> chromosomes in order (hence the sort). We need the size of the biggest chromosome (14, in <em class="italic">Plasmodium falciparum</em>) to make sure that the size of chromosomes is printed with the correct scale (the <strong class="source-inline">biggest_chrom</strong> variable).</p>
<p>Then, we create an A4-sized representation of an organism with a PNG output. Note that we draw very small telomeres of 10 bp. This will produce a rectangular-like chromosome. You can make the telomeres bigger, giving them a roundish representation, or you may have the arguably better idea of using the correct telomere size for your species.</p>
<p>We declare that anything with a <strong class="source-inline">GC</strong> content below 17.5% or above 22.0% will be considered an outlier. Remember that for most other species, this will be much higher.</p>
<p>Then, we print these chromosomes: they are bounded by telomeres and composed of 50 kbp chromosome segments (the last segment is sized with the remainder). Each <a id="_idIndexMarker337"/>segment will be colored in blue, with a red-green component based on the linear normalization between two outlier values. Each chromosome segment will either be 50 kbp or potentially smaller if it’s the last one of the chromosome. The output is shown in the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="" height="358" src="image/B17942_05_002.jpg" width="571"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The 14 chromosomes of Plasmodium falciparum, color-coded with the GC content (red is more than 22%, yellow less than 17%, and the blue shades represent a linear gradient between both numbers)</p>
<p class="callout-heading">Tip</p>
<p class="callout">Biopython code evolved before Python was such a fashionable language. In the past, the availability of libraries was quite limited. The usage of <strong class="source-inline">reportlab</strong> can be seen mostly as a legacy issue. I suggest that you learn just enough from it to use it with Biopython. If you are planning on learning a modern plotting library in Python, then the standard bearer is Matplotlib, as we learned in <a href="B17942_02.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a><em class="italic">, Getting to Know NumPy, pandas, Arrow, and Matplotlib</em>. Alternatives include Bokeh, HoloViews, or Python’s version of ggplot (or even more sophisticated visualization alternatives, such as Mayavi, <strong class="bold">Visualization Toolkit</strong> (<strong class="bold">VTK</strong>), and even the Blender API).</p>
<ol>
<li value="5">Finally, you can print the image inline in the notebook:<p class="source-code">from IPython.core.display import Image</p><p class="source-code">Image("falciparum.png")</p></li>
</ol>
<p>And that completes this recipe!</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>There’s more...</h2>
<p><em class="italic">Plasmodium falciparum</em> is a reasonable <a id="_idIndexMarker338"/>example of a eukaryote with a <a id="_idIndexMarker339"/>small genome that allows you to perform a small data exercise with enough features, while still being useful for most eukaryotes. Of course, there are no sex chromosomes (such as X/Y in humans), but these should be easy to process because reference genomes do not deal with ploidy issues.</p>
<p><em class="italic">Plasmodium falciparum</em> does have a mitochondrion, but we will not deal with it here due to space constraints. Biopython does have the functionality to print circular genomes, which you can also use with bacteria. With regards to bacteria and viruses, these genomes are much easier to process because their size is very small.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>See also</h2>
<p>Here are some sources you can learn more from:</p>
<ul>
<li>You can find <a id="_idIndexMarker340"/>many reference genomes of model organisms in Ensembl at <a href="http://www.ensembl.org/info/data/ftp/index.xhtml">http://www.ensembl.org/info/data/ftp/index.xhtml</a>.</li>
<li>As usual, <strong class="bold">National Center for Biotechnology Information</strong> (<strong class="bold">NCBI</strong>) also provides a large list of<a id="_idIndexMarker341"/> genomes at <a href="http://www.ncbi.nlm.nih.gov/genome/browse/">http://www.ncbi.nlm.nih.gov/genome/browse/</a>.</li>
<li>There are<a id="_idIndexMarker342"/> plenty of websites dedicated to a single organism (or a set of related organisms). Apart from PlasmoDB (<a href="http://plasmodb.org/plasmo/">http://plasmodb.org/plasmo/</a>), which you <a id="_idIndexMarker343"/>downloaded the <em class="italic">Plasmodium falciparum</em> genome from, you will find <a id="_idIndexMarker344"/>VectorBase (<a href="https://www.vectorbase.org/">https://www.vectorbase.org/</a>) in the next recipe for <a id="_idIndexMarker345"/>disease vectors. FlyBase (<a href="http://flybase.org/">http://flybase.org/</a>) for <em class="italic">Drosophila melanogaster</em> is also worth mentioning, but do not forget to search for your organism of interest.</li>
</ul>
<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Dealing with low-quality genome references</h1>
<p>Unfortunately, not all<a id="_idIndexMarker346"/> reference genomes will have the quality of <em class="italic">Plasmodium falciparum</em>. Apart from some model species (for example, humans, or the common fruit fly <em class="italic">Drosophila melanogaster</em>) and a few others, most reference genomes could use some improvement. In this recipe, we will learn how to deal with reference genomes of lower quality.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Getting ready</h2>
<p>In keeping with the malaria theme, we will use the reference genomes of two mosquitoes that are vectors of malaria: <em class="italic">Anopheles gambiae</em> (which is the most important vector of malaria and can be found in Sub-Saharan Africa) and <em class="italic">Anopheles atroparvus</em>, a malaria vector in Europe (while the disease has been eradicated in Europe, this vector is still around). The <em class="italic">Anopheles gambiae</em> genome is of reasonable quality. Most chromosomes have been mapped, although the Y chromosome still needs some work. There is a fairly large unknown chromosome, probably composed of bits of X and Y chromosomes, as well as midgut microbiota. This genome has a reasonable amount of positions that are not called (that is, you will find <em class="italic">N</em>s instead of ACTGs). The <em class="italic">Anopheles atroparvus</em> genome is still in the scaffold format. Unfortunately, this is what you will find for many non-model species.</p>
<p>Note that we will up the ante a bit. The <em class="italic">Anopheles</em> genome is one order of magnitude bigger than the <em class="italic">Plasmodium falciparum</em> genome (but still one order of magnitude smaller than most mammals).</p>
<p>We will use Biopython, which you installed in <a href="B17942_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Python and the Surrounding Software Ecology</em>. As usual, this recipe is available in this book’s Jupyter notebook at <strong class="source-inline">Chapter05/Low_Quality.py</strong>, in the <a id="_idIndexMarker347"/>code bundle for this book. At the start of the notebook, you can find the most up-to-date location of both genomes, along with the code to download them.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>How to do it...</h2>
<p>Follow these steps:</p>
<ol>
<li value="1">Let’s start by listing the chromosomes of the <em class="italic">Anopheles gambiae</em> genome:<p class="source-code">import gzip</p><p class="source-code">from Bio import SeqIO</p><p class="source-code">gambiae_name = 'gambiae.fa.gz'</p><p class="source-code">atroparvus_name = 'atroparvus.fa.gz'</p><p class="source-code">recs = SeqIO.parse(gzip.open(gambiae_name, 'rt', encoding='utf-8'), 'fasta')</p><p class="source-code">for rec in recs:</p><p class="source-code">    print(rec.description)</p></li>
</ol>
<p>This will produce an output that will include the organism chromosomes (along with a few unmapped supercontigs not depicted):</p>
<p class="source-code"><strong class="bold">AgamP4_2L | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=49364325 | SO=chromosome</strong></p>
<p class="source-code"><strong class="bold">AgamP4_2R | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=61545105 | SO=chromosome</strong></p>
<p class="source-code"><strong class="bold">AgamP4_3L | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=41963435 | SO=chromosome</strong></p>
<p class="source-code"><strong class="bold">AgamP4_3R | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=53200684 | SO=chromosome</strong></p>
<p class="source-code"><strong class="bold">AgamP4_X | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=24393108 | SO=chromosome</strong></p>
<p class="source-code"><strong class="bold">AgamP4_Y_unplaced | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=237045 | SO=chromosome</strong></p>
<p class="source-code"><strong class="bold">AgamP4_Mt | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=15363 | SO=mitochondrial_chromosome</strong></p>
<p>The code is quite straightforward. We use the <strong class="source-inline">gzip</strong> module because the files of larger genomes are normally compressed. We can see four chromosome arms (<strong class="source-inline">2L</strong>, <strong class="source-inline">2R</strong>, <strong class="source-inline">3L</strong>, and <strong class="source-inline">3R</strong>), the mitochondria (<strong class="source-inline">Mt</strong>), the <strong class="source-inline">X</strong> chromosome, and the <strong class="source-inline">Y</strong> chromosome, which<a id="_idIndexMarker348"/> is quite small and has a name that all but indicates that it may not be in the best state. Also, the unknown (<strong class="source-inline">UNKN</strong>) chromosome is a large proportion of the reference genome, to the tune of a chromosome arm.</p>
<p>Do not perform this with <em class="italic">Anopheles atroparvus</em>; otherwise, you will get more than a thousand entries, courtesy of the scaffold status.</p>
<ol>
<li value="2">Now, let’s check the uncalled positions (<strong class="source-inline">Ns</strong>) and their distribution for the <em class="italic">Anopheles gambiae</em> genome:<p class="source-code">recs = SeqIO.parse(gzip.open(gambiae_name, 'rt', encoding='utf-8'), 'fasta')</p><p class="source-code">chrom_Ns = {}</p><p class="source-code">chrom_sizes = {}</p><p class="source-code">for rec in recs:</p><p class="source-code">    if rec.description.find('supercontig') &gt; -1:</p><p class="source-code">        continue</p><p class="source-code">    print(rec.description, rec.id, rec)</p><p class="source-code">    chrom = rec.id.split('_')[1]</p><p class="source-code">    if chrom in ['UNKN']:</p><p class="source-code">        continue</p><p class="source-code">    chrom_Ns[chrom] = []</p><p class="source-code">    on_N = False</p><p class="source-code">    curr_size = 0</p><p class="source-code">    for pos, nuc in enumerate(rec.seq):</p><p class="source-code">        if nuc in ['N', 'n']:</p><p class="source-code">            curr_size += 1</p><p class="source-code">            on_N = True</p><p class="source-code">        else:</p><p class="source-code">            if on_N:</p><p class="source-code">                chrom_Ns[chrom].append(curr_size)</p><p class="source-code">                curr_size = 0</p><p class="source-code">            on_N = False</p><p class="source-code">    if on_N:</p><p class="source-code">        chrom_Ns[chrom].append(curr_size)</p><p class="source-code">    chrom_sizes[chrom] = len(rec.seq)</p><p class="source-code">for chrom, Ns in chrom_Ns.items():</p><p class="source-code">    size = chrom_sizes[chrom]</p><p class="source-code">    if len(Ns) &gt; 0:</p><p class="source-code">        max_Ns = max(Ns)</p><p class="source-code">    else:</p><p class="source-code">        max_Ns = 'NA'</p><p class="source-code">    print(f'{chrom} ({size}): %Ns ({round(100 * sum(Ns) / size, 1)}), num Ns: {len(Ns)}, max N: {max_Ns}')</p></li>
</ol>
<p>The preceding code will take some time to run, so please be patient; we will inspect every base pair of autosomes. As usual, we will reopen and re-read the file to save memory.</p>
<p>We have two <a id="_idIndexMarker349"/>dictionaries: one dictionary that contains chromosome sizes and another that contains the distribution of the sizes of runs of <strong class="source-inline">Ns</strong>. To calculate the runs of <strong class="source-inline">Ns</strong>, we must traverse all autosomes (noting when an <strong class="source-inline">N</strong> position starts and ends). Then, we must print the basic statistics of the distribution of <strong class="source-inline">Ns</strong>:</p>
<p class="source-code"><strong class="bold">2L (49364325): %Ns (1.7), num Ns: 957, max N: 28884</strong></p>
<p class="source-code"><strong class="bold">2R (61545105): %Ns (2.3), num Ns: 1658, max N: 36427</strong></p>
<p class="source-code"><strong class="bold">3L (41963435): %Ns (2.9), num Ns: 1272, max N: 31063</strong></p>
<p class="source-code"><strong class="bold">3R (53200684): %Ns (1.8), num Ns: 1128, max N: 24292</strong></p>
<p class="source-code"><strong class="bold">X (24393108): %Ns (4.1), num Ns: 1287, max N: 21132</strong></p>
<p class="source-code"><strong class="bold">Y (237045): %Ns (43.0), num Ns: 63, max N: 7957</strong></p>
<p class="source-code"><strong class="bold">Mt (15363): %Ns (0.0), num Ns: 0, max N: NA</strong></p>
<p>So, for the <strong class="source-inline">2L</strong> chromosome arm (with a size of 49 Mbp), 1.7% are <strong class="source-inline">N</strong> calls divided by <strong class="source-inline">957</strong> runs. The biggest run is <strong class="source-inline">28884</strong> bps. Note that the <strong class="source-inline">X</strong> chromosome has the highest fraction of positions with <strong class="source-inline">Ns</strong>.</p>
<ol>
<li value="3">Now, let’s turn our attention to the <em class="italic">Anopheles Atroparvus</em> genome. Let’s count the number of scaffolds, along with the distribution of scaffold sizes:<p class="source-code">import numpy as np</p><p class="source-code">recs = SeqIO.parse(gzip.open(atroparvus_name, 'rt', encoding='utf-8'), 'fasta')</p><p class="source-code">sizes = []</p><p class="source-code">size_N = []</p><p class="source-code">for rec in recs:</p><p class="source-code">    size = len(rec.seq)</p><p class="source-code">    sizes.append(size)</p><p class="source-code">    count_N = 0</p><p class="source-code">    for nuc in rec.seq:</p><p class="source-code">        if nuc in ['n', 'N']:</p><p class="source-code">            count_N += 1</p><p class="source-code">    size_N.append((size, count_N / size))</p><p class="source-code">print(len(sizes), np.median(sizes), np.mean(sizes),</p><p class="source-code">      max(sizes), min(sizes),</p><p class="source-code">      np.percentile(sizes, 10), np.percentile(sizes, 90))</p></li>
</ol>
<p>This code is similar to what we looked at previously, but we print slightly more detailed statistics using NumPy, so we get the following:</p>
<p class="source-code"><strong class="bold">1320 7811.5 170678.2 58369459 1004 1537.1 39644.7</strong></p>
<p>Thus, we have <strong class="source-inline">1371</strong> scaffolds (against seven entries on the <em class="italic">Anopheles gambiae</em> genome) with <a id="_idIndexMarker350"/>a median size of <strong class="source-inline">7811.5</strong> (a mean of <strong class="source-inline">17,0678.2</strong>). The biggest scaffold is 5.8 Mbp, while the smallest scaffold is 1,004 bp. The tenth percentile for size is <strong class="source-inline">1537.1</strong>, while the ninetieth is <strong class="source-inline">39644.7</strong>.</p>
<ol>
<li value="4">Finally, let’s plot the fraction of the scaffold – that is, <strong class="source-inline">N</strong> – as a function of its size:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">small_split = 4800</p><p class="source-code">large_split = 540000</p><p class="source-code">fig, axs = plt.subplots(1, 3, figsize=(16, 9), squeeze=False, sharey=True)</p><p class="source-code">xs, ys = zip(*[(x, 100 * y) for x, y in size_N if x &lt;= small_split])</p><p class="source-code">axs[0, 0].plot(xs, ys, '.')</p><p class="source-code">xs, ys = zip(*[(x, 100 * y) for x, y in size_N if x &gt; small_split and x &lt;= large_split])</p><p class="source-code">axs[0, 1].plot(xs, ys, '.')</p><p class="source-code">axs[0, 1].set_xlim(small_split, large_split)</p><p class="source-code">xs, ys = zip(*[(x, 100 * y) for x, y in size_N if x &gt; large_split])</p><p class="source-code">axs[0, 2].plot(xs, ys, '.')</p><p class="source-code">axs[0, 0].set_ylabel('Fraction of Ns', fontsize=12)</p><p class="source-code">axs[0, 1].set_xlabel('Contig size', fontsize=12)</p><p class="source-code">fig.suptitle('Fraction of Ns per contig size', fontsize=26)</p></li>
</ol>
<p>The preceding code will generate the output shown in the following diagram, in which we split the<a id="_idIndexMarker351"/> chart into three parts based on the scaffold size: one for scaffolds with less than 4,800 bp, one for scaffolds between 4,800 and 540,000 bp, and one for larger ones. The fraction of <strong class="source-inline">Ns</strong> is very low for small scaffolds (always below 3.5%); for medium scaffolds, it has a large variance (sizes between 0% and above 90%), and a tighter variance (between 0% and 25%) for the largest scaffolds:</p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="" height="748" src="image/B17942_05_003.jpg" width="1168"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The fraction of scaffolds that are N as a function of their size</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>There’s more...</h2>
<p>Sometimes, reference genomes carry extra information. For example, the <em class="italic">Anopheles gambiae</em> genome is soft masked. This means that some procedures were run on the genome to identify areas of low complexity (which are normally more problematic to analyze). This can be annotated by capitalization: ACTG will be high complexity, whereas actg will be low.</p>
<p>Reference genomes with lots of scaffolds are more than an inconvenient hassle. For example, very small scaffolds (say, below 2,000 bp) may have mapping problems when using an aligner (such as <strong class="bold">Burrows-Wheeler Aligner</strong> (<strong class="bold">BWA</strong>)), especially at the extremes (most scaffolds will have mapping problems at their extremes, but these will be of a much larger proportion of the scaffold if it’s small). If you are using a reference genome like this to align, you will want to consider ignoring the pair information (assuming that you have paired-end reads) when mapping to small scaffolds, or at least measure the impact of the scaffold size on the performance of your aligner. In any case, the general idea is that you should be careful because the scaffold size and number will rear their ugly head from time to time.</p>
<p>With these genomes, only complete ambiguity (<strong class="source-inline">N</strong>) was identified. Note that other genome assemblies will give you an intermediate code between the total <strong class="bold">ambiguity and certainty</strong> (<strong class="bold">ACTG</strong>).</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>See also</h2>
<p>Here are some resources you can learn more from:</p>
<ul>
<li>Tools such <a id="_idIndexMarker352"/>as RepeatMasker can be used to find areas of the genome with low complexity. Check out <a href="http://www.repeatmasker.org/">http://www.repeatmasker.org/</a> for more information.</li>
<li>IUPAC ambiguity <a id="_idIndexMarker353"/>codes may be useful to have in hand when processing other genomes. Check out <a href="http://www.bioinformatics.org/sms/iupac.xhtml">http://www.bioinformatics.org/sms/iupac.xhtml</a> for more information.</li>
</ul>
<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Traversing genome annotations</h1>
<p>Having a genome <a id="_idIndexMarker354"/>sequence is interesting, but we will want to extract features from it, such as genes, exons, and coding sequences. This type of annotation information is made available<a id="_idIndexMarker355"/> in <strong class="bold">Generic Feature Format</strong> (<strong class="bold">GFF</strong>) and <strong class="bold">General Transfer Format</strong> (<strong class="bold">GTF</strong>) files. In this recipe, we will learn how to parse and analyze GFF files <a id="_idIndexMarker356"/>while using the annotation of the <em class="italic">Anopheles gambiae</em> genome as an example.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Getting ready</h2>
<p>Use the <strong class="source-inline">Chapter05/Annotations.py</strong> notebook file, which is provided in the code bundle for this book. The up-to-date location of the GFF file that we will be using can be found at the top of the notebook.</p>
<p>You will need to install <strong class="source-inline">gffutils</strong>:</p>
<p class="source-code">conda install -c bioconda gffutils</p>
<p>Now, we’re ready to start.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>How to do it...</h2>
<p>Follow these steps:</p>
<ol>
<li value="1">Let’s start by creating an annotation database with <strong class="source-inline">gffutils</strong>, based on our GFF file:<p class="source-code">import gffutils</p><p class="source-code">import sqlite3</p><p class="source-code">try:</p><p class="source-code">    db = gffutils.create_db('gambiae.gff.gz', 'ag.db')</p><p class="source-code">except sqlite3.OperationalError:</p><p class="source-code">    db = gffutils.FeatureDB('ag.db')</p></li>
</ol>
<p>The <strong class="source-inline">gffutils</strong> library creates a SQLite database to store annotations efficiently. Here, we will try <a id="_idIndexMarker357"/>to create the database, but if it already exists, we will use the existing one. This step can be time-consuming.</p>
<ol>
<li value="2">Now, let’s list all the available feature types and count them:<p class="source-code">print(list(db.featuretypes()))</p><p class="source-code">for feat_type in db.featuretypes():</p><p class="source-code">    print(feat_type, db.count_features_of_type(feat_type))</p></li>
</ol>
<p>These features will include contigs, genes, exons, transcripts, and so on. Note that we will use the <strong class="source-inline">gffutils</strong> package’s <strong class="source-inline">featuretypes</strong> function. It will return a generator, but we will convert it into a list (it’s safe to do so here).</p>
<ol>
<li value="3">Let’s list all seqids:<p class="source-code">seqids = set()</p><p class="source-code">for e in db.all_features():</p><p class="source-code">    seqids.add(e.seqid)</p><p class="source-code">for seqid in seqids:</p><p class="source-code">    print(seqid)</p></li>
</ol>
<p>This will show us that there is annotation information for all chromosome arms and sex chromosomes, mitochondrion, and the unknown chromosome.</p>
<ol>
<li value="4">Now, let’s extract a lot of useful information per chromosome, such as the number of genes, number <a id="_idIndexMarker358"/>of transcripts per gene, number of exons, and so on:<p class="source-code">from collections import defaultdict</p><p class="source-code">num_mRNAs = defaultdict(int)</p><p class="source-code">num_exons = defaultdict(int)</p><p class="source-code">max_exons = 0</p><p class="source-code">max_span = 0</p><p class="source-code">for seqid in seqids:</p><p class="source-code">    cnt = 0</p><p class="source-code">    for gene in db.region(seqid=seqid, featuretype='protein_coding_gene'):</p><p class="source-code">        cnt += 1</p><p class="source-code">        span = abs(gene.start - gene.end) # strand</p><p class="source-code">        if span &gt; max_span:</p><p class="source-code">            max_span = span</p><p class="source-code">            max_span_gene = gene</p><p class="source-code">        my_mRNAs = list(db.children(gene, featuretype='mRNA'))</p><p class="source-code">        num_mRNAs[len(my_mRNAs)] += 1</p><p class="source-code">        if len(my_mRNAs) == 0:</p><p class="source-code">            exon_check = [gene]</p><p class="source-code">        else:</p><p class="source-code">            exon_check = my_mRNAs</p><p class="source-code">        for check in exon_check:</p><p class="source-code">            my_exons = list(db.children(check, featuretype='exon'))</p><p class="source-code">            num_exons[len(my_exons)] += 1</p><p class="source-code">            if len(my_exons) &gt; max_exons:</p><p class="source-code">                max_exons = len(my_exons)</p><p class="source-code">                max_exons_gene = gene</p><p class="source-code">    print(f'seqid {seqid}, number of genes {cnt}')</p><p class="source-code">print('Max number of exons: %s (%d)' % (max_exons_gene.id, max_exons))</p><p class="source-code">print('Max span: %s (%d)' % (max_span_gene.id, max_span))</p><p class="source-code">print(num_mRNAs)</p><p class="source-code">print(num_exons)</p></li>
</ol>
<p>We will traverse all seqids while extracting all protein-coding genes (using <strong class="source-inline">region</strong>). In each <a id="_idIndexMarker359"/>gene, we count the number of alternative transcripts. If there are none (note that this is probably an annotation issue and not a biological one), we count the exons (<strong class="source-inline">children</strong>). If there are several transcripts, we count the exons per transcript. We also account for the span size to check for the gene that spans the largest region. </p>
<p>We follow a similar procedure to find the gene and the largest number of exons. Finally, we print a dictionary that contains the distribution of the number of alternative transcripts per gene (<strong class="source-inline">num_mRNAs</strong>) and the distribution of the number of exons per transcript (<strong class="source-inline">num_exons</strong>).</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>There’s more...</h2>
<p>There are many variations of the GFF/GTF format. There are different GFF versions and many unofficial variations. If possible, choose GFF version 3. However, the ugly truth is that you will find it very <a id="_idIndexMarker360"/>difficult to process files. The <strong class="source-inline">gffutils</strong> library tries as best as it can to accommodate this. Indeed, much of the documentation for this library is concerned with helping you process all kinds of awkward variations (refer to <a href="https://pythonhosted.org/gffutils/examples.xhtml">https://pythonhosted.org/gffutils/examples.xhtml</a>).</p>
<p>There is an alternative to using <strong class="source-inline">gffutils</strong> (either because your GFF file is strange or because you do not like the library interface or its dependency on a SQL backend). Parse the file yourself manually. If you look at the format, you will notice that it’s not very complex. If you are only performing a one-off operation, then maybe manual parsing is good enough. Of course, one-off operations tend to not be that good in the long run.</p>
<p>Also, note that the quality of annotations tends to vary a lot. As the quality increases, so does the complexity. Just check the human annotation for an example of this. You can expect that, over time, as our knowledge of organisms evolves, the quality and complexity of annotations will increase.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>See also</h2>
<p>Here are some resources you can learn more from:</p>
<ul>
<li>The GFF spec can be <a id="_idIndexMarker361"/>found at <a href="https://www.sanger.ac.uk/resources/software/gff/spec.xhtml">https://www.sanger.ac.uk/resources/software/gff/spec.xhtml</a>.</li>
<li>Probably the best <a id="_idIndexMarker362"/>explanation of the GFF format, along with the most common versions and GTF, can be found at <a href="http://gmod.org/wiki/GFF3">http://gmod.org/wiki/GFF3</a>.</li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Extracting genes from a reference using annotations</h1>
<p>In this recipe, we will learn <a id="_idIndexMarker363"/>how to extract a gene sequence with<a id="_idIndexMarker364"/> the help of <a id="_idIndexMarker365"/>an annotation file to get its coordinates against a reference FASTA. We will use the <em class="italic">Anopheles gambiae</em> genome, along with its annotation file (as per the previous two recipes). First, we<a id="_idIndexMarker366"/> will extract the <strong class="bold">voltage-gated sodium channel</strong> (<strong class="bold">VGSC</strong>) gene, which is involved in resistance to insecticides.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Getting ready</h2>
<p>If you have followed the previous two<a id="_idIndexMarker367"/> recipes, you will be <a id="_idIndexMarker368"/>ready. If not, download the <em class="italic">Anopheles gambiae</em> FASTA file, along with the GTF file. You also need to prepare the <strong class="source-inline">gffutils</strong> database:</p>
<pre class="source-code">
import gffutils
import sqlite3
try:
    db = gffutils.create_db('gambiae.gff.gz', 'ag.db')
except sqlite3.OperationalError:
    db = gffutils.FeatureDB('ag.db')</pre>
<p>As usual, you will<a id="_idIndexMarker369"/> find all of this in the <strong class="source-inline">Chapter05/Getting_Gene.py</strong> notebook file.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>How to do it...</h2>
<p>Follow these steps:</p>
<ol>
<li value="1">Let’s start by retrieving the annotation information for our gene:<p class="source-code">import gzip</p><p class="source-code">from Bio import Seq, SeqIO</p><p class="source-code">gene_id = 'AGAP004707'</p><p class="source-code">gene = db[gene_id]</p><p class="source-code">print(gene)</p><p class="source-code">print(gene.seqid, gene.strand)</p></li>
</ol>
<p><strong class="source-inline">gene_id</strong> was retrieved from VectorBase, an online database for the genomics of disease vectors. For other specific cases, you will need to know the ID of your gene (which will be dependent on the species and database). The output will be as follows:</p>
<p class="source-code">AgamP4_2L       VEuPathDB       protein_coding_gene     2358158 2431617 .       +       .       ID=AGAP004707;Name=para;description=voltage-gated sodium channel</p>
<p class="source-code">AgamP4_2L + </p>
<p>Note that the gene is on the <strong class="source-inline">2L</strong> chromosome arm and coded in the positive direction (the <strong class="source-inline">+</strong> strand).</p>
<ol>
<li value="2">Let’s hold the <a id="_idIndexMarker370"/>sequence for the <strong class="source-inline">2L</strong> chromosome<a id="_idIndexMarker371"/> arm in memory (it’s just a single chromosome, so we will indulge):<p class="source-code">recs = SeqIO.parse(gzip.open('gambiae.fa.gz', 'rt', encoding='utf-8'), 'fasta')</p><p class="source-code">for rec in recs:</p><p class="source-code">    print(rec.description)</p><p class="source-code">    if rec.id == gene.seqid:</p><p class="source-code">        my_seq = rec.seq</p><p class="source-code">        break</p></li>
</ol>
<p>The output will be as <a id="_idIndexMarker372"/>follows:</p>
<p class="source-code">AgamP4_2L | organism=Anopheles_gambiae_PEST | version=AgamP4 | length=49364325 | SO=chromosome</p>
<ol>
<li value="3">Let’s create a function to construct a gene sequence for a list of <strong class="source-inline">CDSs</strong>:<p class="source-code">def get_sequence(chrom_seq, CDSs, strand):</p><p class="source-code">    seq = Seq.Seq('')</p><p class="source-code">    for CDS in CDSs:</p><p class="source-code">        my_cds = Seq.Seq(str(my_seq[CDS.start - 1:CDS.end]))</p><p class="source-code">        seq += my_cds</p><p class="source-code">    return seq if strand == '+' else seq.reverse_complement()</p></li>
</ol>
<p>This function will receive a chromosome sequence (in our case, the <strong class="source-inline">2L</strong> arm), a list of coding sequences (retrieved from the annotation file), and the strand.</p>
<p>We have to be very careful <a id="_idIndexMarker373"/>with the start and end of the sequence (note that the GFF file is 1-based, whereas the Python array is 0-based). Finally, we return the reverse<a id="_idIndexMarker374"/> complement if the strand is negative.</p>
<ol>
<li value="4">Although we <a id="_idIndexMarker375"/>have the <strong class="source-inline">gene_id</strong> at hand, we only want one of the transcripts of the three available for this gene, so we need to choose one:<p class="source-code">mRNAs = db.children(gene, featuretype='mRNA')</p><p class="source-code">for mRNA in mRNAs:</p><p class="source-code">    print(mRNA.id)</p><p class="source-code">    if mRNA.id.endswith('RA'):</p><p class="source-code">        break</p></li>
<li>Now, let’s get the coding sequence for our transcript, then get the gene sequence, and translate it:<p class="source-code">CDSs = db.children(mRNA, featuretype='CDS', order_by='start')</p><p class="source-code">gene_seq = get_sequence(my_seq, CDSs, gene.strand)</p><p class="source-code">print(len(gene_seq), gene_seq)</p><p class="source-code">prot = gene_seq.translate()</p><p class="source-code">print(len(prot), prot)</p></li>
<li>Let’s get the gene that is coded in the negative strand direction. We will just take the gene next to <a id="_idIndexMarker376"/>VGSC (which happens to be the negative strand):<p class="source-code">reverse_transcript_id = 'AGAP004708-RA'</p><p class="source-code">reverse_CDSs = db.children(reverse_transcript_id, featuretype='CDS', order_by='start')</p><p class="source-code">reverse_seq = get_sequence(my_seq, reverse_CDSs, '-')</p><p class="source-code">print(len(reverse_seq), reverse_seq)</p><p class="source-code">reverse_prot = reverse_seq.translate()</p><p class="source-code">print(len(reverse_prot), reverse_prot)</p></li>
</ol>
<p>Here, I avoided getting <a id="_idIndexMarker377"/>all of the information about the gene<a id="_idIndexMarker378"/> and just hardcoded the transcript ID. The point is that you should make sure your code works, irrespective of the strand.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>There’s more...</h2>
<p>This is a simple recipe that exercises several concepts that have been presented in this chapter and <a href="B17942_03.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Next Generation Sequencing</em>. While it’s conceptually trivial, it’s unfortunately full of booby traps.</p>
<p class="callout-heading">Tip</p>
<p class="callout">When using different databases, be sure that the genome assembly versions are synchronized. It would be a serious and potentially silent bug to use different versions. Remember that different versions (at least on the major version number) have different coordinates. For example, position 1,234 on chromosome 3 on build 36 of the human genome will probably refer to a different SNP than 1,234 on build 38. With human data, you will probably find a lot of chips on build 36, and plenty of whole genome sequences on build 37, whereas the most recent human assembly is build 38. With our <em class="italic">Anopheles</em> example, you will have versions 3 and 4 around. This will happen with most species. So, be aware!</p>
<p>There is also the issue of 0-indexed arrays in Python versus 1-indexed genomic databases. Nonetheless, be aware that some genomic databases may also be 0-indexed.</p>
<p>There are also two sources of confusion: the transcript versus the gene choice, as in more rich annotation databases. Here, you will have several alternative transcripts (if you want to look at a rich-to-the-point-of-confusing database, refer to the human annotation database). Also, fields tagged with <strong class="source-inline">exon</strong> will contain more information compared to the coding sequence. For this purpose, you will want the CDS field.</p>
<p>Finally, there is the strand issue, where you will want to translate based on the reverse complement.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>See also</h2>
<p>Here are some resources you can learn more from:</p>
<ul>
<li>You can<a id="_idIndexMarker379"/> download MySQL tables for Ensembl at <a href="http://www.ensembl.org/info/data/mysql.xhtml">http://www.ensembl.org/info/data/mysql.xhtml</a>.</li>
<li>The UCSC genome browser can be <a id="_idIndexMarker380"/>found at <a href="http://genome.ucsc.edu/">http://genome.ucsc.edu/</a>. Be sure to check the download area at <a href="http://hgdownload.soe.ucsc.edu/downloads.xhtml">http://hgdownload.soe.ucsc.edu/downloads.xhtml</a>.</li>
<li>With a reference to genomes, you can find GTFs of model organisms in Ensembl at <a href="http://www.ensembl.org/info/data/ftp/index.xhtml">http://www.ensembl.org/info/data/ftp/index.xhtml</a>.</li>
<li>A simple explanation of CDSs and exons can be found at <a href="https://www.biostars.org/p/65162/">https://www.biostars.org/p/65162/</a>.</li>
</ul>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Finding orthologues with the Ensembl REST API</h1>
<p>In this recipe, we will learn<a id="_idIndexMarker381"/> how to look for orthologues for a <a id="_idIndexMarker382"/>certain gene. This simple recipe will not only introduce orthology retrieval but also how to use REST APIs on the web to access biological data. Last, but surely not least, it will serve as an introduction to how to access the Ensembl database using the programmatic API.</p>
<p>In our example, we will try to find any orthologue for the human <strong class="bold">lactase</strong> (<strong class="bold">LCT</strong>) gene on the <strong class="source-inline">horse</strong> genome.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Getting ready</h2>
<p>This recipe will not require <a id="_idIndexMarker383"/>any pre-downloaded data, but since<a id="_idIndexMarker384"/> we are using web APIs, internet access will be needed. The amount of data that can be transferred will be limited.</p>
<p>We will also make use of the <strong class="source-inline">requests</strong> library to access Ensembl. The request API is an easy-to-use wrapper for web requests. Of course, you can use the standard Python libraries, but these are much more cumbersome.</p>
<p>As usual, you can find this content in the <strong class="source-inline">Chapter05/Orthology.py</strong> notebook file.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>How to do it...</h2>
<p>Follow these steps:</p>
<ol>
<li value="1">We will start by creating a support function to perform a web request:<p class="source-code">import requests</p><p class="source-code">ensembl_server = 'http://rest.ensembl.org'</p><p class="source-code">def do_request(server, service, *args, **kwargs):</p><p class="source-code">    url_params = ''</p><p class="source-code">    for a in args:</p><p class="source-code">        if a is not None:</p><p class="source-code">            url_params += '/' + a</p><p class="source-code">    req = requests.get('%s/%s%s' % (server, service, url_params), params=kwargs, headers={'Content-Type': 'application/json'})</p><p class="source-code">    if not req.ok:</p><p class="source-code">        req.raise_for_status()</p><p class="source-code">    return req.json()</p></li>
</ol>
<p>We start by importing the <strong class="source-inline">requests</strong> library and specifying the root URL. Then, we create a simple function <a id="_idIndexMarker385"/>that will take the functionality to be<a id="_idIndexMarker386"/> called (see the following examples) and generate a complete URL. It will also add optional parameters and specify the payload to be of the JSON type (just to get a default JSON answer). It will return the response in JSON format. This is typically a nested Python data structure of lists and dictionaries.</p>
<ol>
<li value="2">Then, we will check all the available species on the server, which is around 110 at the time of writing this book:<p class="source-code">answer = do_request(ensembl_server, 'info/species')</p><p class="source-code">for i, sp in enumerate(answer['species']):</p><p class="source-code">    print(i, sp['name'])</p></li>
</ol>
<p>Note that this will construct a URL starting with the <strong class="source-inline">http://rest.ensembl.org/info/species</strong> prefix for the REST request. The preceding link will not work on your browser, by the way; it should only be used via a REST API.</p>
<ol>
<li value="3">Now, let’s try to find any <strong class="source-inline">HGNC</strong> databases on the server related to human data:<p class="source-code">ext_dbs = do_request(ensembl_server, 'info/external_dbs', 'homo_sapiens', filter='HGNC%')</p><p class="source-code">print(ext_dbs)</p></li>
</ol>
<p>We restrict the search to human-related databases (<strong class="source-inline">homo_sapiens</strong>). We also filter databases starting with <strong class="source-inline">HGNC</strong> (this filtering uses the SQL notation). <strong class="source-inline">HGNC</strong> is the HUGO database. We want to make sure that it’s available because the HUGO database is responsible for curating human gene names and maintaining our LCT identifier.</p>
<ol>
<li value="4">Now that we know that the LCT identifier is probably available, we want to retrieve the Ensembl ID for the gene, as shown in the following code:<p class="source-code">answer = do_request(ensembl_server, 'lookup/symbol', 'homo_sapiens', 'LCT')</p><p class="source-code">print(answer)</p><p class="source-code">lct_id = answer['id']</p></li>
</ol>
<p class="callout-heading">Tip</p>
<p class="callout">Different databases, as you probably know by now, will have different IDs for the same object. We will need to resolve our LCT identifier to the Ensembl ID. When you deal with external databases that relate to the same objects, ID translation between databases will probably be your first task.</p>
<ol>
<li value="5">Just for your information, we<a id="_idIndexMarker387"/> can now get the sequence of the<a id="_idIndexMarker388"/> area containing the gene. Note that this is probably the whole interval, so if you want to recover the gene, you will have to use a procedure similar to what we used in the previous recipe:<p class="source-code">lct_seq = do_request(ensembl_server, 'sequence/id', lct_id)</p><p class="source-code">print(lct_seq)</p></li>
<li>We can also inspect other databases known to Ensembl; refer to the following gene:<p class="source-code">lct_xrefs = do_request(ensembl_server, 'xrefs/id', lct_id)</p><p class="source-code">for xref in lct_xrefs:</p><p class="source-code">    print(xref['db_display_name'])</p><p class="source-code">    print(xref)</p></li>
</ol>
<p>You will find different kinds of <a id="_idIndexMarker389"/>databases, such as the <strong class="bold">Vertebrate Genome Annotation</strong> (<strong class="bold">Vega</strong>) project, UniProt (see <a href="B17942_08.xhtml#_idTextAnchor209"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Protein Data Bank</em>), and WikiGene.</p>
<ol>
<li value="7">Let’s get the orthologues<a id="_idIndexMarker390"/> for this gene on the <strong class="source-inline">horse</strong> genome:<p class="source-code">hom_response = do_request(ensembl_server, 'homology/id', lct_id, type='orthologues', sequence='none')</p><p class="source-code">homologies = hom_response['data'][0]['homologies']</p><p class="source-code">for homology in homologies:</p><p class="source-code">    print(homology['target']['species'])</p><p class="source-code">    if homology['target']['species'] != 'equus_caballus':</p><p class="source-code">        continue</p><p class="source-code">    print(homology)</p><p class="source-code">    print(homology['taxonomy_level'])</p><p class="source-code">    horse_id = homology['target']['id']</p></li>
</ol>
<p>We could have acquired <a id="_idIndexMarker391"/>the orthologues directly for the <strong class="source-inline">horse</strong> genome by specifying a <strong class="source-inline">target_species</strong> parameter on <strong class="source-inline">do_request</strong>. However, this code allows you to inspect all the available orthologues.</p>
<p>You will get quite a lot of information about an orthologue, such as the taxonomic level of orthology (Boreoeutheria – placental mammals is the closest phylogenetic level between humans and horses), the Ensembl ID of the orthologue, the dN/dS ratio (non-synonymous to synonymous mutations), and the CIGAR string (refer to the previous chapter, <a href="B17942_03.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Next-Generation Sequencing</em>) of differences among sequences. By default, you will also get the alignment of the orthologous sequence, but I have removed it to unclog the output.</p>
<ol>
<li value="8">Finally, let’s look for the <strong class="source-inline">horse_id</strong> Ensembl record:<p class="source-code">horse_req = do_request(ensembl_server, 'lookup/id', horse_id)</p><p class="source-code">print(horse_req)</p></li>
</ol>
<p>From this point onward, you <a id="_idIndexMarker392"/>can use the previous recipe<a id="_idIndexMarker393"/> methods to explore the LCT <strong class="source-inline">horse</strong> orthologue.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>There’s more...</h2>
<p>You can find a detailed explanation of<a id="_idIndexMarker394"/> all the functionalities available at <a href="http://rest.ensembl.org/">http://rest.ensembl.org/</a>. This includes all the interfaces and Python code snippets, among other languages.</p>
<p>If you are interested in paralogues, this information can be retrieved quite trivially from the preceding recipe. On the call to <strong class="source-inline">homology/id</strong>, just replace the type with <strong class="source-inline">paralogues</strong>.</p>
<p>If you have heard of Ensembl, you have probably heard of an alternative service from UCSC: the Genome Browser (<a href="http://genome.ucsc.edu/">http://genome.ucsc.edu/</a>). From the<a id="_idIndexMarker395"/> perspective of the user interface, they are on the same level. From a programmatic perspective, Ensembl is probably more mature. Accessing NCBI Entrez databases was covered in  <a href="B17942_03.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Next Generation Sequencing</em>.</p>
<p>Another completely different strategy to interface programmatically with Ensembl will be to download raw tables and inject them into a local MySQL database. Be aware that this will be quite an undertaking in itself (you will probably just want to load a very small subset of tables). However, if you intend to be very intensive in terms of usage, you may have to consider creating a local version of part of the database. If this is the case, you may want to reconsider the UCSC alternative, as it’s as good as Ensembl from the local database perspective.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Retrieving gene ontology information from Ensembl</h1>
<p>In this recipe, you<a id="_idIndexMarker396"/> will learn how to use gene ontology information again by querying the Ensembl REST API. Gene ontologies are controlled<a id="_idIndexMarker397"/> vocabularies for annotating genes and gene products. These are made available as trees of concepts (with more general concepts near the top of the hierarchy). There are three domains for gene ontologies: the cellular component, the molecular function, and the biological process.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Getting ready</h2>
<p>As with the previous recipe, we do not require any pre-downloaded data, but since we are using web APIs, internet access will be needed. The amount of data that will be transferred will be limited.</p>
<p>As usual, you can find this content in the <strong class="source-inline">Chapter05/Gene_Ontology.py</strong> notebook file. We will make use of the <strong class="source-inline">do_request</strong> function, which was defined in <em class="italic">Step 1</em> of the previous recipe (<em class="italic">Finding orthologues with the Ensembl REST API</em>). To draw GO trees, we will use <strong class="source-inline">pygraphviz</strong>, a graph-drawing library:</p>
<p class="source-code">conda install pygraphviz</p>
<p>OK – we’re all set.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>How to do it...</h2>
<p>Follow these steps:</p>
<ol>
<li value="1">Let’s start by retrieving all GO terms associated with the LCT gene (you learned how to retrieve the Ensembl ID in the previous recipe). Remember that you will need the <strong class="source-inline">do_request</strong> function from the previous recipe:<p class="source-code">lct_id = 'ENSG00000115850'</p><p class="source-code">refs = do_request(ensembl_server, 'xrefs/id', lct_id,external_db='GO', all_levels='1')</p><p class="source-code">print(len(refs))</p><p class="source-code">print(refs[0].keys())</p><p class="source-code">for ref in refs:</p><p class="source-code">    go_id = ref['primary_id']</p><p class="source-code">    details = do_request(ensembl_server, 'ontology/id', go_id)</p><p class="source-code">    print('%s %s %s' % (go_id, details['namespace'], ref['description']))</p><p class="source-code">    print('%s\n' % details['definition'])</p></li>
</ol>
<p>Note the free-form definition and the varying namespace for each term. The first two of the<a id="_idIndexMarker398"/> reported items in the loop <a id="_idIndexMarker399"/>are as follows (this may change when you run it, because the database may have been updated):</p>
<p class="source-code">GO:0000016 molecular_function lactase activity</p>
<p class="source-code"> "Catalysis of the reaction: lactose + H2O = D-glucose + D-galactose." [EC:3.2.1.108]</p>
<p class="source-code"> </p>
<p class="source-code"> GO:0004553 molecular_function hydrolase activity, hydrolyzing O-glycosyl compounds</p>
<p class="source-code"> "Catalysis of the hydrolysis of any O-glycosyl bond." [GOC:mah]</p>
<ol>
<li value="2">Let’s concentrate on the <strong class="source-inline">lactase activity</strong> molecular function and retrieve more detailed information about it (the following <strong class="source-inline">go_id</strong> comes from the previous step):<p class="source-code">go_id = 'GO:0000016'</p><p class="source-code">my_data = do_request(ensembl_server, 'ontology/id', go_id)</p><p class="source-code">for k, v in my_data.items():</p><p class="source-code">    if k == 'parents':</p><p class="source-code">        for parent in v:</p><p class="source-code">            print(parent)</p><p class="source-code">            parent_id = parent['accession']</p><p class="source-code">    else:</p><p class="source-code">        print('%s: %s' % (k, str(v)))</p><p class="source-code">parent_data = do_request(ensembl_server, 'ontology/id', parent_id)</p><p class="source-code">print(parent_id, len(parent_data['children']))</p></li>
</ol>
<p>We print the <strong class="source-inline">lactase activity</strong> record (which is currently a node of the GO tree molecular function) and retrieve <a id="_idIndexMarker400"/>a list of potential parents. There is a single parent for this record. We retrieve it<a id="_idIndexMarker401"/> and print the number of children.</p>
<ol>
<li value="3">Let’s retrieve all the general terms for the <strong class="source-inline">lactase activity</strong> molecular function (again, the parent and all other ancestors):<p class="source-code">refs = do_request(ensembl_server, 'ontology/ancestors/chart', go_id)</p><p class="source-code">for go, entry in refs.items():</p><p class="source-code">    print(go)</p><p class="source-code">    term = entry['term']</p><p class="source-code">    print('%s %s' % (term['name'], term['definition']))</p><p class="source-code">    is_a = entry.get('is_a', [])</p><p class="source-code">    print('\t is a: %s\n' % ', '.join([x['accession'] for x in is_a]))</p></li>
</ol>
<p>We retrieve the <strong class="source-inline">ancestor</strong> list by following the <strong class="source-inline">is_a</strong> relationship (refer to the GO sites in the <em class="italic">See also</em> section for more details on the types of possible relationships).</p>
<ol>
<li value="4">Let’s define a <a id="_idIndexMarker402"/>function that will create<a id="_idIndexMarker403"/> a dictionary with the ancestor relationship for a term, along with some summary information for each term returned in a pair:<p class="source-code">def get_upper(go_id):</p><p class="source-code">    parents = {}</p><p class="source-code">    node_data = {}</p><p class="source-code">    refs = do_request(ensembl_server, 'ontology/ancestors/chart', go_id)</p><p class="source-code">    for ref, entry in refs.items():</p><p class="source-code">        my_data = do_request(ensembl_server, 'ontology/id', ref)</p><p class="source-code">        node_data[ref] = {'name': entry['term']['name'], 'children': my_data['children']}</p><p class="source-code">        try:</p><p class="source-code">            parents[ref] = [x['accession'] for x in entry['is_a']]</p><p class="source-code">        except KeyError:</p><p class="source-code">            pass  # Top of hierarchy</p><p class="source-code">    return parents, node_data</p></li>
<li>Finally, we will print a tree of relationships for the <strong class="source-inline">lactase activity</strong> term. For this, we will use the <strong class="source-inline">pygraphivz</strong> library:<p class="source-code">parents, node_data = get_upper(go_id)</p><p class="source-code">import pygraphviz as pgv</p><p class="source-code">g = pgv.AGraph(directed=True)</p><p class="source-code">for ofs, ofs_parents in parents.items():</p><p class="source-code">    ofs_text = '%s\n(%s)' % (node_data[ofs]['name'].replace(', ', '\n'), ofs)</p><p class="source-code">    for parent in ofs_parents:</p><p class="source-code">        parent_text = '%s\n(%s)' % (node_data[parent]['name'].replace(', ', '\n'), parent)</p><p class="source-code">        children = node_data[parent]['children']</p><p class="source-code">        if len(children) &lt; 3:</p><p class="source-code">            for child in children:</p><p class="source-code">                if child['accession'] in node_data:</p><p class="source-code">                    continue</p><p class="source-code">                g.add_edge(parent_text, child['accession'])</p><p class="source-code">        else:</p><p class="source-code">            g.add_edge(parent_text, '...%d...' % (len(children) - 1))</p><p class="source-code">        g.add_edge(parent_text, ofs_text)</p><p class="source-code">print(g)</p><p class="source-code">g.graph_attr['label']='Ontology tree for Lactase activity'</p><p class="source-code">g.node_attr['shape']='rectangle'</p><p class="source-code">g.layout(prog='dot')</p><p class="source-code">g.draw('graph.png')</p></li>
</ol>
<p>The following output <a id="_idIndexMarker404"/>shows the<a id="_idIndexMarker405"/> ontology tree for the <strong class="source-inline">lactase activity</strong> term:</p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 5.4 – An ontology tree for the “lactase activity” term (the terms at the top are more general); the top of the tree is molecular_function; for all ancestral nodes, the number of extra offspring is also noted (or enumerated, if less than three) " height="729" src="image/B17942_05_004.jpg" width="469"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – An ontology tree for the “lactase activity” term (the terms at the top are more general); the top of the tree is molecular_function; for all ancestral nodes, the number of extra offspring is also noted (or enumerated, if less than three)</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/>There’s more...</h2>
<p>If you are interested in gene ontologies, your main port of call will be <a href="http://geneontology.org">http://geneontology.org</a>, where you will<a id="_idIndexMarker406"/> find much more information on this topic. Apart from <strong class="source-inline">molecular_function</strong>, gene ontology also has a <em class="italic">biological process</em> and a <em class="italic">cellular component</em>. In our recipes, we have followed the hierarchical relationship <em class="italic">is a</em>, but others do exist partially. For example, “mitochondrial ribosome” (GO:0005761) is a cellular component and is part of “mitochondrial matrix” (refer to <a href="http://amigo.geneontology.org/amigo/term/GO:0005761#display-lineage-tab">http://amigo.geneontology.org/amigo/term/GO:0005761#display-lineage-tab</a> and click on <strong class="bold">Graph Views</strong>).</p>
<p>As with the previous recipe, you can download the MySQL dump of a gene ontology database (you may prefer to interact with the data in that way). For this, see <a href="http://geneontology.org/page/download-go-annotations">http://geneontology.org/page/download-go-annotations</a>. Again, expect to allocate some time to understanding the relational database schema. Also, note that there are many alternatives to Graphviz for plotting trees and graphs. We will return to this topic later in this book.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>See also</h2>
<p>Here are some resources you can learn more from:</p>
<ul>
<li>As mentioned previously, more so than Ensembl, the main resource for gene ontologies is <a href="http://geneontology.org">http://geneontology.org</a>.</li>
<li>For visualization, we<a id="_idIndexMarker407"/> are using the <strong class="source-inline">pygraphviz</strong> library, which is a wrapper on top of Graphviz ( <a href="http://www.graphviz.org">http://www.graphviz.org</a>).</li>
<li>There are<a id="_idIndexMarker408"/> very good user interfaces for GO data, such as AmiGO (<a href="http://amigo.geneontology.org">http://amigo.geneontology.org</a>) and <a id="_idIndexMarker409"/>QuickGO (<a href="http://www.ebi.ac.uk/QuickGO/">http://www.ebi.ac.uk/QuickGO/</a>).</li>
<li>One of the most common analyses performed with GO is gene enrichment analysis to check whether some GO terms are overexpressed or underexpressed in a certain gene set. The <a href="http://geneontology.org">geneontology.org</a> server uses<a id="_idIndexMarker410"/> Panther (<a href="http://go.pantherdb.org/">http://go.pantherdb.org/</a>), but other alternatives are available (such as DAVID, at <a href="http://david.abcc.ncifcrf.gov/">http://david.abcc.ncifcrf.gov/</a>).</li>
</ul>
</div>
<div>
<div id="_idContainer042">
</div>
</div>
</div></body></html>