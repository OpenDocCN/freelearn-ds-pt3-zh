- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization is a fundamental tool for the modern data scientist. It is often
    the central lens used to understand items such as statistical models (for example,
    via an AUC chart), the distribution of a crucial variable (via a histogram), or
    even important business metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two chapters, we used two popular Python graphing libraries (**Matplotlib**
    and **Altair**) in our examples. This chapter will focus on extending that ability
    to a broad range of Python graphing libraries, including some graphing functions
    native to Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should feel comfortable using Streamlit’s native
    graphing functions and visualization functions to place graphs made from major
    Python visualization libraries in your own Streamlit app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**San Francisco** (**SF**) Trees – a new dataset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit’s built-in graphing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit’s built-in visualization options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Python visualization libraries in Streamlit. In this section, we will
    cover the following libraries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plotly** (for interactive visualizations)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seaborn** and **Matplotlib** (for classic statistical visualizations)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bokeh** (for interactive visualization in web browsers)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Altair** (for declarative, interactive visualizations)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyDeck** (for interactive map-based visualizations)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be working with a new dataset that can be found at
    [https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv).
    A further explanation of the dataset can be found in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: San Francisco Trees – a new dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re going to be working with all sorts of graphs in this chapter, so we’re
    going to need a new dataset that has much more info, especially dates and locations.
    Enter **SF Trees**. The department of public works in SF has a dataset (cleaned
    by the wonderful folks in the R community who run Tidy Tuesday, a weekly event
    where people publish interesting visualizations of new data each week) of every
    tree planted and maintained in the city of SF. They cleverly call this dataset
    **EveryTreeSF – Urban Forest Map** and update it every day. I have selected a
    random set of 10,000 trees with complete info and placed this data in the main
    GitHub repository under the **trees** folder (I’m not as clever as the data engineer
    in SF’s DPW, I know). The GitHub repo can be found at [https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps).
    If you would like to download the full dataset, the link is here: [https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq](https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq).'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the main `streamlit_apps` folder that we’ve been using throughout this
    book, start by creating a new folder, creating a new Python file, and then downloading
    our data into that folder, the same thing we did in *Chapter 2*, *Uploading, Downloading,
    and Manipulating Data*, but with some new data! You can run the following code
    in your terminal to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I’ll note here that if this does not work, or if you are on an operating system
    without these commands (such as Windows, for example), you can always go and download
    the CSV file directly by going to the GitHub repo mentioned in the preceding paragraph
    ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our setup, our next step is to open our `trees.py` file in
    our favorite editor and start making our Streamlit app.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow these exact same steps at the beginning of the rest of the chapters,
    so in the future, we will not cover these explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by titling our app and printing out some example rows using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the following command in our terminal and see the resulting
    Streamlit app in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is neither the easiest nor the best way to see the first few
    rows of a dataset, but we can do this purely because we already know that we’re
    going to build a Streamlit app using this data. The general workflow usually begins
    with some data exploration outside of Streamlit (in Jupyter notebooks, through
    SQL queries, or whatever the preferred workflow is for you as a data scientist
    or analyst). With that said, let’s continue our exploration of the dataset by
    looking at the output of the preceding code in the new Streamlit app in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The first few rows of trees'
  prefs: []
  type: TYPE_NORMAL
- en: This dataset contains a huge amount of info about the trees in SF, from their
    width (**dbh**) to the longitude and latitude points, the species, their address,
    and even the date they were planted. Before we get started with graphing, let’s
    talk a bit about the visualization options in front of us.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit visualization use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Streamlit users are relatively experienced Python developers with well-tested
    workflows in visualization libraries of their choice. For these users, the best
    path forward is the one we’ve taken so far, which is to create graphs in our library
    of choice (Seaborn, Matplotlib, Bokeh, and so on) and then use the appropriate
    Streamlit function to write this to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Other Streamlit users will have less experience in Pythonic graphing, and especially
    for these users, Streamlit offers a few built-in functions. We’ll start with built-in
    libraries and move on to learning how to import the most popular and powerful
    libraries for our Streamlit apps.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit’s built-in graphing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four built-in functions for graphing – `st.line_chart()`, `st.bar_chart()`,
    `st.area_chart()`, and `st.map()`. They all work similarly by trying to figure
    out what variables you’re already trying to graph and then putting them into a
    line, bar, map, or area chart, respectively. In our dataset, we have a variable
    called `dbh`, which is the width of the tree at chest height. First, we can group
    our DataFrame by `dbh`, and then push that directly to the line chart, bar chart,
    and area chart. The following code should group our dataset by width, count the
    unique trees of each width, and then make a line, bar, and area chart of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should show our three graphs one right after another, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Lines, bars, area, and tree height'
  prefs: []
  type: TYPE_NORMAL
- en: We gave the function nothing except for the DataFrame, and it was able to guess
    correctly which items should be on the *x* and *y* axes and plot those to our
    Streamlit chart. Each of these charts is also interactive by default! We can zoom
    in or out, roll the mouse over points/bars/lines to see each data point, and even
    view the full screen out of the box. These Streamlit functions call a popular
    graphing library called **Altair** (the same one we used before in *Chapter 2*!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we see the basics of the built-in (it’s clear that the term *built-in*
    is fairly loose here, as Streamlit is built to be a great and convenient web application
    library, not a great visualization library) functions, let’s push these functions
    to see how they handle more data. First, we’re going to make a new column of random
    numbers between -500 and 500 in our `df_dbh_grouped` DataFrame, using the `numpy`
    library, and use the same plotting code that we used before. The following code
    plots two line charts, one before we added the new column, and one after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code should produce an app that looks like the following screenshot, with
    the two separate line charts vertically adjacent to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Two sequential line charts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, these functions put whatever is on the index on the *x* axis and use
    all the columns they can as variables on the *y* axis. These built-in functions
    are very useful if we have an incredibly straightforward graphing problem in front
    of us (as in the example). If we want, we can also explicitly tell Streamlit the
    variables that we want to plot on the *x*and *y* axes; the following bit of code
    turns the index into its own column and then graphs a line chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When you run this code, you’ll see the same line chart we created before! These
    built-in functions are great but less flexible when compared to libraries with
    the sole purpose of visualization, and it may be difficult to debug the behavior
    behind these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation here is that if you want a fairly basic visualization, these
    functions will probably work just fine for you. But if you want something more
    complicated, you should use other graphing libraries (my personal favorite is
    Altair).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more built-in Streamlit graphing function that we should discuss
    here, `st.map()`. Just like the preceding functions, this wraps around another
    Python graphing library, this time PyDeck instead of Altair, and finds columns
    that it thinks are longitude and latitude points by searching the DataFrame for
    columns with titles such as **longitude**, **long**, **latitude**, or **lat**.
    Then, it plots each row as its own point on a map, auto-zooms and focuses the
    map, and writes it to our Streamlit app. We should note that visualizing detailed
    maps is much more computationally intensive in comparison to the other forms of
    visualization that we have used so far, so we are going to sample 1,000 random
    rows from our DataFrame, remove `null` values, and try out `st.map()` using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This works perfectly well, right out of the box! We get a beautiful interactive
    map of trees in SF, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Default SF map of trees ](img/B18444_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Default SF map of trees'
  prefs: []
  type: TYPE_NORMAL
- en: As with other functions, we don’t have many options for customization here other
    than an optional zoom parameter, but this works very well for quick visualization.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen, these built-in functions can be useful to make Streamlit apps
    quickly, but we trade off speed for customizability. In practice, I rarely use
    these functions when I produce Streamlit apps, but I often use these when doing
    quick visualizations of data already in Streamlit. In production, more powerful
    libraries, such as Matplotlib, Seaborn, and PyDeck, would be able to give us the
    flexibility and customizability we want. The rest of this chapter will provide
    a walk-through of six different popular Python visualization libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit’s built-in visualization options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the rest of this chapter, we’re going to run through the rest of the Streamlit
    visualization options, which are Plotly, Matplotlib, Seaborn, Bokeh, Altair, and
    PyDeck.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plotly is an interactive visualization library that many data scientists use
    to visualize data in a Jupyter notebook, either locally in the browser or even
    hosted on a web platform such as **Dash** (the creator of Plotly). This library
    is very similar to Streamlit in its intent and is primarily used for internal
    or external dashboards (hence, the name Dash).
  prefs: []
  type: TYPE_NORMAL
- en: 'Streamlit allows us to call plotly graphs from within Streamlit apps using
    the `st.plotly_chart()` function, which makes it a breeze to port any Plotly or
    Dash dashboards. We’ll test this out by making a histogram of the height of trees
    in SF, essentially the same graph that we’ve made before. The following code makes
    our Plotly histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’ll notice, all the interactivity native to Plotly works by default in
    Streamlit. Particularly, the user can scroll over histogram bars and get the exact
    info about each bar. There are a few other useful built-in features in Plotly
    that readily port over to Streamlit, such as the ability to zoom in and out, download
    the plot as a .**png**, and select a group of data points/bars/lines. The full
    features can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Our first Plotly chart'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re comfortable with Plotly, we can move on to other popular visualization
    libraries, Matplotlib and Seaborn.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib and Seaborn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this book, we learned how to use the Matplotlib and Seaborn visualization
    libraries inside Streamlit, so we will just go over them briefly here. There is
    a column called **date** in the trees dataset that corresponds to the date that
    the tree was planted. We can use the `datetime` library to figure out the age
    of each tree in days, and plot that histogram using Seaborn and Matplotlib, respectively.
    The following code creates a new column called `age`, which is the difference
    in days between the tree planting date and today’s date, and then graphs the histogram
    of the age using both Seaborn and Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined unique subplots for each graph, created a
    Seaborn or Matplotlib graph for each, and then used the `st.pyplot()` function
    to insert each graph in successive order right inside our Streamlit app. The preceding
    code should show an app similar to the following screenshot (I say similar because,
    depending on when you run this, the age of the trees will be different, as `pd.to_datetime`
    (`''today''`) will return your current date):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Seaborn and Matplotlib histograms ](img/B18444_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Seaborn and Matplotlib histograms'
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use Seaborn or Matplotlib, you’ll use the `st.pyplot()` function
    in the same way. Now that we’re more comfortable with these libraries, we can
    learn about another interactive visualization library – **Bokeh**.
  prefs: []
  type: TYPE_NORMAL
- en: Bokeh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bokeh is another web-based interactive visualization library that also has dashboarding
    products built on top of it. It is a direct competitor to Plotly and is, frankly,
    incredibly similar in use, but it has some stylistic differences. Either way,
    Bokeh is an extremely popular Python visualization package that Python users may
    be very comfortable using.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call Bokeh graphs using the same format as Plotly. First, we create
    the Bokeh graph, and then we use the `st.bokeh_chart()` function to write the
    app to Streamlit. In Bokeh, we have to first instantiate a Bokeh figure object,
    and then change aspects of that figure before we can plot it out. The important
    lesson here is that if we change an aspect of the Bokeh figure object after we
    call the `st.bokeh_chart()` function, we will not change the graph shown on the
    Streamlit app. For example, when we run the following code, we will not see a
    new **x** axis title at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we’ll have to switch the order of the last two lines, which will now
    show up on our app. We’ll add a **y** axis for good measure as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a Bokeh chart of `dbh` versus `site_order`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Bokeh scatterplot ](img/B18444_03_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Bokeh scatterplot'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our basic Bokeh plot of `dbh` by site order, on to our next
    visualization library – Altair!
  prefs: []
  type: TYPE_NORMAL
- en: Altair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already used Altair in this chapter through Streamlit functions such as
    `st.line_chart()` and `st.map()`, and directly through `st.altair_chart()`, so
    again we’ll cover this one briefly for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Because we’ve made quite a few graphs with this dataset already, why don’t we
    explore a new column, the `caretaker` column? This bit of data defines who is
    in charge of the tree (public or private) and, if public, what government organization
    is responsible for upkeep. Thrilling!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code groups our DataFrame by caretaker, and then uses that grouped
    DataFrame from within Altair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Altair also allows us to summarize our data directly within the **y** value
    of `mark_bar()`, so we can simplify this by instead using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a Streamlit app showing the count of trees by
    caretaker in SF, which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_03_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: Altair bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: This should be it for traditional visualization libraries, but Streamlit also
    allows us to use more complex visualization libraries such as PyDeck for geographical
    mapping. In fact, we have already used PyDeck through the native `st.map()` function
    and will explore this in more depth in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: PyDeck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyDeck is a visualization library that plots visualizations as layers on top
    of **Mapbox** (a mapping company with a truly exceptional free tier) maps. Both
    Streamlit and PyDeck have a base set of limited features available without signing
    up for a Mapbox account, but they greatly expand their free features when we get
    a **Mapbox** token, which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to set up your own **Mapbox** token, which is optional, first go to
    [www.Mapbox.com](http://www.Mapbox.com) and sign up for an account. Once you have
    verified your account, you can find your token at [https://www.Mapbox.com/install/](https://www.Mapbox.com/install/).
    We will not pass our token directly to Streamlit because, otherwise, we might
    accidentally push it to a public GitHub repository. Instead, Streamlit has a global
    configuration file called `config.toml`. To view our current settings, we can
    run the following command anywhere in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are four methods that Streamlit offers to change our default configuration
    settings; I’ll show you my recommended option and one of the other options, which
    should provide you with the majority of the use cases. If you find these options
    insufficient, the Streamlit documentation ([https://docs.streamlit.io/library/advanced-features/configuration](https://docs.streamlit.io/library/advanced-features/configuration))
    goes over all four options in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is to set global configuration options by directly editing
    the `config.toml` file. We can edit the file directly by opening it in our text
    editor. The following command will open the file in VSCode. For other text editors
    (such as Vim and Atom), replace `code` with the appropriate command or open the
    file directly from the text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If this fails, it likely means that we do not have the file generated already.
    To create our own file, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this file, you can either copy and paste the contents of `''streamlit
    config show''`, or choose to start from scratch. Either one should be fine! Now,
    open the file in VS Code so that we can view and edit any of the config options
    directly. Make sure that there is a section in your config file that has your
    Mapbox token, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, your token will look different than the one I clearly made up! This
    option is great for a config option such as a Mapbox token, as I will never have
    multiple Mapbox accounts with multiple tokens.
  prefs: []
  type: TYPE_NORMAL
- en: However, some Streamlit apps may want to use, for example, different ports than
    the default **8501 serverPort**. It would not make sense to change a global option
    for a project-specific change, which leads us to the second option for configuration
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to create and edit a project-specific `config.toml` file.
    Our previous config sets our default config options, while this option is specific
    to each Streamlit app. Here is where our individual project folders within the
    `streamlit_apps` folder come in handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check our current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a config file for our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the config file within PyDeck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our first step is to make sure our current working directory is the `trees_app`
    folder by running the `pwd` command in our terminal, which will show our current
    working directory and should end with `trees_app` (for example, mine looks like
    `Users/tyler/Documents/streamlit_apps/trees_app`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make a config file just for our project. First, we will make
    a folder called `.streamlit`, and then we will repeat the Mac/Linux shortcut we
    used above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can then edit our config options just as we did before, but this will only
    be applicable to our Streamlit apps when we run Streamlit from our directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, finally, we can go back to PyDeck graphing. Our first effort is going
    to be getting a base map of SF, which has a city center of `37.77, -122.4`. We
    can do this using the following code, which first defines the initial state (where
    we want to start viewing the map), and then calls `st.pydeck_chart()` using that
    initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce a map of SF, which we can use to layer on data points.
    Notice a couple of things here. First, the black default map may be difficult
    to see, and second, we need to spend time zooming into SF to get the view that
    we need. We can fix both these items by using the defaults suggested in the Streamlit
    documentation ([https://docs.streamlit.io/](https://docs.streamlit.io/)), as seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should create a map that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – PyDeck mapping: SF base map ](img/B18444_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: PyDeck mapping: SF base map'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly what we want! We can see the entire **SF Bay Area**, and now
    we need to add our layer of trees. The PyDeck library has tooltips for interactivity,
    which do not deal well with `null` values in our dataset, so we will remove `null`
    values before we map these points in the following code. We’ll also increase the
    `zoom` value to `11` so that we can see each point better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The best values for both the `zoom` and `radius` parameters are dependent on
    your visualization preferences. Try a few options out to see what looks the best.
    The preceding code will make the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Mapping SF trees  ](img/B18444_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Mapping SF trees'
  prefs: []
  type: TYPE_NORMAL
- en: As with previous maps, this is interactive by default, so we can zoom into different
    parts of SF to see where the places with the highest tree density are. For our
    next change to this map, we are going to add another layer, this time hexagons,
    which will be colored based on the density of the trees in SF. We can use the
    same code as above but change the scatterplot layer to a hexagon layer. We also
    will include the option to have the hexagon extrude vertically, making this graph
    more three-dimensional, which isn’t necessary but is certainly a fun visualization
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last change is to change the pitch or the angle at which we are viewing
    the map. The default pitch, as we can see, is nearly directly down on the city,
    which will not work if we try to view vertical hexagons on our map. The following
    code implements each one of these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the previous map, the optimal radius and pitch parameters will change
    based on your visualizations. Try changing each one of these around a few times
    to see whether you can get the hang of it! The preceding code will produce the
    following app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Final San Francisco Trees map ](img/B18444_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Final SF Trees map'
  prefs: []
  type: TYPE_NORMAL
- en: From this screenshot, we can see that PyDeck creates darker circles where there
    exists a higher density of trees in SF. We can observe from this many interesting
    details, such as the fact that the dataset seems to be missing trees from the
    famous Golden Gate Park on the west side of the city, and that the area around
    the Golden Gate Bridge also seems to have very few trees in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this chapter, you hopefully have a solid understanding of how to leverage
    several incredible open-source Python visualization libraries from within Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s recap. First, we learned how to use the default visualization options,
    such as `st.line_chart()` and `st.map()`, and then we dove into interactive libraries
    such as Plotly, mapping libraries such as PyDeck, and everything in between.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will move on to cover how to use machine learning and
    AI with Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/sl](https://packt.link/sl)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code13440134443835796.png)'
  prefs: []
  type: TYPE_IMG
