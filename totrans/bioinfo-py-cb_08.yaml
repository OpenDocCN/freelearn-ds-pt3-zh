- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phylogenetics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phylogenetics is the application of molecular sequencing that is used to study
    the evolutionary relationship among organisms. The typical way to illustrate this
    process is through the use of phylogenetic trees. The computation of these trees
    from genomic data is an active field of research with many real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will take the practical approach that is mentioned to a new
    level: most of the recipes here are inspired by a recent study on the Ebola virus,
    researching the recent Ebola outbreak in Africa. This study is called *Genomic
    surveillance elucidates Ebola virus origin and transmission during the 2014 outbreak*,
    by *Gire et al.*, published in *Science*. It is available at [https://pubmed.ncbi.nlm.nih.gov/25214632/](https://pubmed.ncbi.nlm.nih.gov/25214632/).
    Here, we will try to follow a similar methodology to arrive at similar results
    to the paper.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use DendroPy (a phylogenetics library) and Biopython.
    The `bioinformatics_phylo` Docker image includes all the necessary software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a dataset for phylogenetic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning genetic and genomic data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconstructing phylogenetic trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing recursively with trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing phylogenetic data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a dataset for phylogenetic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will download and prepare the dataset to be used for our
    analysis. The dataset contains complete genomes of the Ebola virus. We will use
    DendroPy to download and prepare the data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will download complete genomes from GenBank; these genomes were collected
    from various Ebola outbreaks, including several from the 2014 outbreak. Note that
    there are several virus species that cause the Ebola virus disease; the species
    involved in the 2014 outbreak (the EBOV virus, which was formally known as the
    Zaire Ebola virus) is the most common, but this disease is caused by more species
    of the genus Ebolavirus; four others are also available in a sequenced form. You
    can read more at [https://en.wikipedia.org/wiki/Ebolavirus](https://en.wikipedia.org/wiki/Ebolavirus).
  prefs: []
  type: TYPE_NORMAL
- en: If you have already gone through the previous chapters, you might panic looking
    at the potential data sizes involved here; this is not a problem at all because
    these are genomes of viruses that are each around 19 kbp in size. So, our approximately
    100 genomes are actually quite light.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this analysis, we will need to install `dendropy`. If you are using Anaconda,
    please perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As usual, this information is available in the corresponding Jupyter Notebook
    file, which is available at `Chapter07/Exploration.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s start by specifying our data sources using DendroPy, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have three functions: one to retrieve data from the most recent EBOV
    outbreak, another to retrieve data from the previous EBOV outbreaks, and one to
    retrieve data from the outbreaks of other species.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the DendroPy GenBank interface provides several different ways to
    specify lists or ranges of records to retrieve. Some lines are commented out.
    These include the code to download more genomes. For our purpose, the subset that
    we will download is enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a set of FASTA files; we will use these files here and
    in future recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will generate several different FASTA files, which include either all genomes,
    just EBOV, or just EBOV samples from the 2014 outbreak. In this chapter, we will
    mostly use the `sample.fasta` file with all genomes.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `dendropy` functions to create FASTA files that are retrieved
    from GenBank records through conversion. The ID of each sequence in the FASTA
    file is produced by a lambda function that uses the species and the year, alongside
    the GenBank accession number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract four (of the total seven) genes in the virus, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start by searching the first GenBank record for all gene features (please
    refer to [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068), *Next Generation Sequencing*,
    or the **National Center for Biotechnology Information** (**NCBI**) documentation
    for further details; although we will use DendroPy and not Biopython here, the
    concepts are similar) and write to the FASTA files in order to extract the genes.
    We put each gene into a different file and only take two virus species. We also
    get translated proteins, which are available in the records for each gene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a function to get the basic statistical information from the alignment,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our function takes a `DnaCharacterMatrix` DendroPy class and counts the number
    of taxons. Then, we extract all the amino acids per sequence (we exclude gaps
    identified by `-`) to compute the length and report the minimum, mean, and maximum
    sizes. Take a look at the DendroPy documentation for additional details regarding
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inspect the sequence of the EBOV genome and compute the basic statistics,
    as shown earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then call a function and get 25 sequences with a minimum size of 18,700,
    a mean size of 18,925.2, and a maximum size of 18,959\. This is a small genome
    when compared to eukaryotes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at the very end, the memory structure has been deleted. This is because
    the memory footprint is still quite big (DendroPy is a pure Python library and
    has some costs in terms of speed and memory). Be careful with your memory usage
    when you load full genomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s inspect the other Ebola virus genome file and count the number of
    different species:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name prefix of each taxon is indicative of the species, and we leverage
    that to fill a dictionary of counts.
  prefs: []
  type: TYPE_NORMAL
- en: The output for the species and the EBOV breakdown is detailed next (with the
    legend as Bundibugyo virus=BDBV, Tai Forest virus=TAFV, Sudan virus=SUDV, and
    Reston virus=RESTV; we have 1 TAFV, 6 SUDV, 6 RESTV, and 5 BDBV).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extract the basic statistics of a gene in the virus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This allows you to have an overview of the basic gene information (that is,
    the name and the mean size), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the work here can probably be performed with Biopython, but DendroPy
    has additional functionalities that will be explored in later recipes. Furthermore,
    as you will discover, it’s more robust with certain tasks (such as file parsing).
    More importantly, there is another Python library to perform phylogenetics that
    you should consider. It’s called ETE and is available at [http://etetoolkit.org/](http://etetoolkit.org/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The US **Center for Disease Control** (**CDC**) has a good introductory page
    on the Ebola virus disease at [https://www.cdc.gov/vhf/ebola/history/summaries.xhtml](https://www.cdc.gov/vhf/ebola/history/summaries.xhtml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference application in phylogenetics is Joe Felsenstein’s *Phylip*, which
    can be found at [http://evolution.genetics.washington.edu/phylip.xhtml](http://evolution.genetics.washington.edu/phylip.xhtml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the Nexus and Newick formats in future recipes ([http://evolution.genetics.washington.edu/phylip/newicktree.xhtml](http://evolution.genetics.washington.edu/phylip/newicktree.xhtml)),
    but do also check out the PhyloXML format ([http://en.wikipedia.org/wiki/PhyloXML](http://en.wikipedia.org/wiki/PhyloXML)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning genetic and genomic data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can perform any phylogenetic analysis, we need to align our genetic
    and genomic data. Here, we will use MAFFT ([http://mafft.cbrc.jp/alignment/software/](http://mafft.cbrc.jp/alignment/software/))
    to perform the genome analysis. The gene analysis will be performed using MUSCLE
    ([http://www.drive5.com/muscle/](http://www.drive5.com/muscle/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform the genomic alignment, you will need to install MAFFT. Additionally,
    to perform the genic alignment, MUSCLE will be used. Also, we will use trimAl
    ([http://trimal.cgenomics.org/](http://trimal.cgenomics.org/)) to remove spurious
    sequences and poorly aligned regions in an automated manner. All packages are
    available from Bioconda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As usual, this information is available in the corresponding Jupyter Notebook
    file at `Chapter07/Alignment.py`. You will need to run the previous notebook beforehand,
    as it will generate the files that are required here. In this chapter, we will
    use Biopython.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run MAFFT to align the genomes, as shown in the following code.
    This task is CPU-intensive and memory-intensive, and it will take quite some time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding parameters are the same as the ones specified in the supplementary
    material of the paper. We will use the Biopython interface to call MAFFT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use trimAl to trim sequences, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just call the application using `os.system`. The `-automated1` parameter
    is from the supplementary material.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can run `MUSCLE` to align the proteins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use Biopython to call an external application. Here, we will align a set
    of proteins.
  prefs: []
  type: TYPE_NORMAL
- en: Note that to make some analysis of molecular evolution, we have to compare aligned
    genes, not proteins (for example, comparing synonymous and nonsynonymous mutations).
    However, we just have aligned the proteins. Therefore, we have to convert the
    alignment into the gene sequence form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s align the genes by finding three nucleotides that correspond to each
    amino acid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code gets the protein and the gene coding. If a gap is found in a protein,
    three gaps are written; if an amino acid is found, the corresponding nucleotides
    of the gene are written.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will compare the sequences we aligned in the previous recipe. We will
    perform gene-wide and genome-wide comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use DendroPy and will require the results from the previous two recipes.
    As usual, this information is available in the corresponding notebook at `Chapter07/Comparison.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start analyzing the gene data. For simplicity, we will only use data
    from two other species of the genus Ebola virus that are available in the extended
    dataset, that is, the Reston virus (`RESTV`) and the Sudan virus (`SUDV`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We get four genes that we stored in the first recipe and aligned in the second.
  prefs: []
  type: TYPE_NORMAL
- en: We load all the files (which are FASTA formatted) and create a dictionary with
    all of the genes. Each entry will be a dictionary itself with the RESTV or SUDV
    species, including all reads. This is not a lot of data, just a handful of genes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s print some basic information for all four genes, such as the number of
    segregating sites (`seg_sites`), nucleotide diversity (`nuc_div`), Tajima’s D
    (`taj_d`), and Waterson’s theta (`wat_theta`) (check out the *There’s more...*
    section of this recipe for links on these statistics):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, let’s look at the output, and then we’ll explain how to build it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A DataFrame for the virus dataset ](img/B17942_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A DataFrame for the virus dataset
  prefs: []
  type: TYPE_NORMAL
- en: I used a `pandas` DataFrame to print the results because it’s really tailored
    to deal with an operation like this. We will initialize our DataFrame with a NumPy
    multidimensional array with four rows (genes) and four statistics times the two
    species.
  prefs: []
  type: TYPE_NORMAL
- en: The statistics, such as the number of segregating sites, nucleotide diversity,
    Tajima’s D, and Watterson’s theta, are computed by DendroPy. Note the placement
    of individual data points in the array (the coordinate computation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the very last line: if you are in Jupyter, just putting `df` at the
    end will render the DataFrame and the cell output, too. If you are not in a notebook,
    use `print(df)` (you can also perform this in a notebook, but it will not look
    as pretty).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s extract similar information, but genome-wide instead of only gene-wide.
    In this case, we will use a subsample of two EBOV outbreaks (from 2007 and 2014).
    We will perform a function to display basic statistics, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By now, this function should be easy to understand, given the preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s extract a subsample of the data properly, and output the statistical
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we will construct two versions of two datasets: the 2014 outbreak and
    the 2007 outbreak. We will generate one version as `DnaCharacterMatrix` and another
    as a list. We will use this list version at the end of this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: As the dataset for the EBOV outbreak of 2014 is large, we subsample it with
    just eight individuals, which is a comparable sample size to the dataset of the
    2007 outbreak.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we delete the `ebov_seqs` data structure to conserve memory (these are
    genomes, not only genes).
  prefs: []
  type: TYPE_NORMAL
- en: If you perform this analysis on the complete dataset for the 2014 outbreak available
    on GenBank (99 samples), be prepared to wait for quite some time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we perform some statistical analysis on the two subsets of 2007 and
    2014, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that we will perform something slightly different here; we will ask DendroPy
    (`popgenstat.PopulationPairSummaryStatistics`) to directly compare two populations
    so that we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now the number of segregating sites is much bigger because we are dealing with
    data from two different populations that are reasonably diverged. The average
    number of pairwise differences among populations is quite large. As expected,
    this is much larger than the average number for the population, irrespective of
    the population information.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to get many phylogenetic and population genetics formulas, including
    the ones used here, I strongly recommend that you get the manual for the Arlequin
    software suite ([http://cmpg.unibe.ch/software/arlequin35/](http://cmpg.unibe.ch/software/arlequin35/)).
    If you do not use Arlequin to perform data analysis, its manual is probably the
    best reference to implement formulas. This free document probably has more relevant
    details on formula implementation than any book that I can remember.
  prefs: []
  type: TYPE_NORMAL
- en: Reconstructing phylogenetic trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will construct phylogenetic trees for the aligned dataset for all Ebola
    species. We will follow a procedure that’s quite similar to the one used in the
    paper.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires RAxML, a program for maximum likelihood-based inference
    of large phylogenetic trees, which you can check out at [http://sco.h-its.org/exelixis/software.xhtml](http://sco.h-its.org/exelixis/software.xhtml).
    Bioconda also includes it, but it is named `raxml`. Note that the binary is called
    `raxmlHPC`. You can perform the following command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is simple, but it will take time to execute because it will
    call RAxML (which is computationally intensive). If you opt to use the DendroPy
    interface, it might also become memory-intensive. We will interact with RAxML,
    DendroPy, and Biopython, leaving you with a choice of which interface to use;
    DendroPy gives you an easy way to access results, whereas Biopython is less memory-intensive.
    Although there is a recipe for visualization later in this chapter, we will, nonetheless,
    plot one of our generated trees here.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, this information is available in the corresponding notebook at `Chapter07/Reconstruction.py`.
    You will need the output of the previous recipe to complete this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For DendroPy, we will load the data first and then reconstruct the genus dataset,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that the size of the data structure for this is quite big; therefore,
    ensure that you have enough memory to load this (at least 10 GB).
  prefs: []
  type: TYPE_NORMAL
- en: Be prepared to wait for some time. Depending on your computer, this could take
    more than one hour. If it takes longer, consider restarting the process, as sometimes
    a RAxML bug might occur.
  prefs: []
  type: TYPE_NORMAL
- en: We will run RAxML with the GTRΓ nucleotide substitution model, as specified
    in the paper. We will only perform 10 replicates to speed up the results, but
    you should probably do a lot more, say 100\. At the end of the process, we will
    delete the genome data from memory as it takes up a lot of memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `ebola_data` variable will have the best RAxML tree, with distances included.
    The `RaxmlRunner` object will have access to other information generated by RAxML.
    Let’s print the directory where DendroPy will execute RAxML. If you inspect this
    directory, you will find a lot of files. As RAxML returns the best tree, you might
    want to ignore all of these files, but we will discuss this a little in the alternative
    Biopython step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will save trees for future analysis; in our case, it will be a visualization,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will write sequences to a NEXUS file because we need to store the topology
    information. FASTA is not enough here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s visualize our genus tree, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will defer the explanation of this code until we come to the proper recipe
    later, but if you look at the following diagram and compare it with the results
    from the paper, you will clearly see that it looks like a step in the right direction.
    For example, all individuals from the same species are clustered together.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that trimAl changed the names of its sequences, for example,
    by adding their sizes. This is easy to solve; we will deal with this in the *Visualizing
    phylogenetic data* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The phylogenetic tree that we generated with RAxML for all Ebola
    viruses ](img/B17942_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The phylogenetic tree that we generated with RAxML for all Ebola
    viruses
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s reconstruct the phylogenetic tree with RAxML via Biopython. The Biopython
    interface is less declarative, but much more memory-efficient than DendroPy. So,
    after running it, it will be your responsibility to process the output, whereas
    DendroPy automatically returns the best tree, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: DendroPy has a more declarative interface than Biopython, so you can take care
    of a few extra things. You should specify the seed (Biopython will put a fixed
    default of 10,000 if you do not do so) and the working directory. With RAxML,
    the working directory specification requires the absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inspect the outcome of the Biopython run. While the RAxML output is the
    same (save for stochasticity) for DendroPy and Biopython, DendroPy abstracts away
    a few things. With Biopython, you need to take care of the results yourself. You
    can also perform this with DendroPy; however, in this case, it is optional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will read the best tree from the RAxML run. The name of the
    file was appended with the project name that you specified in the previous step
    (in this case, `biopython`).
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the content of the `bp_rx` directory; here, you will find all
    the outputs from RAxML, including all 10 alternative trees.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the purpose of this book is not to teach phylogenetic analysis, it’s
    important to know why we do not inspect consensus and support information in the
    tree topology. You should research this in your dataset. For more information,
    refer to [http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf](http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Playing recursively with trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not a book about programming in Python, as the topic is vast. Having
    said that, it’s not common for introductory Python books to discuss recursive
    programming at length. Usually, recursive programming techniques are well tailored
    to deal with trees. It is also a required programming strategy with functional
    programming dialects, which can be quite useful when you perform concurrent processing.
    This is common when processing very large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: The phylogenetic notion of a tree is slightly different from that in computer
    science. Phylogenetic trees can be rooted (if so, then they are normal tree data
    structures) or unrooted, making them undirected acyclic graphs. Additionally,
    phylogenetic trees can have weights on their edges. Therefore, be mindful of this
    when you read the documentation; if the text is written by a phylogeneticist,
    you can expect the tree (rooted and unrooted), while most other documents will
    use undirected acyclic graphs for unrooted trees. In this recipe, we will assume
    that all of the trees are rooted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that while this recipe is mostly devised to help you understand
    recursive algorithms and tree-like structures, the final part is actually quite
    practical and fundamental for the next recipe to work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to have the files from the previous recipe. As usual, you can
    find this content in the `Chapter07/Trees.py` notebook file. Here, we will use
    DendroPy’s tree representations. Note that most of this code is easily generalizable
    compared to other tree representations and libraries (phylogenetic or not).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s load the RAxML-generated tree for all Ebola viruses, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to compute the level of each node (the distance to the root node):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: DendroPy’s node representation has a level method (which is used for comparison),
    but the point here is to introduce a recursive algorithm, so we will implement
    it anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the function works; it’s called with `seed_node` (which is the root
    node, since the code works under the assumption that we are dealing with rooted
    trees). The default level for the root node is `0`. The function will then call
    itself for all its children nodes, increasing the level by one. Then, for each
    node that is not a leaf (that is, it is internal to the tree), the calling will
    be repeated, and this will recurse until we get to the leaf nodes.
  prefs: []
  type: TYPE_NORMAL
- en: For the leaf nodes, we then print the level (we could have done the same for
    the internal nodes) and show the same information computed by DendroPy’s internal
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s compute the height of each node. The height of the node is the number
    of edges of the maximum downward path (going to the leaves), starting on that
    node, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we will use the same recursive strategy, but each node will return its
    height to its parent. If the node is a leaf, then the height is `0`; if not, then
    it’s `1` plus the maximum height of its entire offspring.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use a map over a lambda function to get the heights of all the
    children of the current node. Then, we choose the maximum (the `max` function
    performs a `reduce` operation here because it summarizes all of the values that
    are reported). If you are relating this to MapReduce frameworks, you are correct;
    they are inspired by functional programming dialects like these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s compute the number of offspring for each node. By now, this should
    be quite easy to understand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will print all of the leaves (this is, apparently, trivial):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that all the functions that we have developed so far impose a very clear
    traversal pattern on the tree. It calls its first offspring, then that offspring
    will call their offspring, and so on; only after this will the function be able
    to call its next offspring in a depth-first pattern. However, we can do things
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s print the leaf nodes in a breadth-first manner, that is, we will
    print the leaves with the lowest level (closer to the root) first, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we explain this algorithm, let’s look at how different the result from
    this run will be compared to the previous one. For starters, take a look at the
    following diagram. If you print the nodes by depth-first order, you will get Y,
    A, X, B, and C. But if you perform a breath-first traversal, you will get X, B,
    C, Y, and A. Tree traversal will have an impact on how the nodes are visited;
    more often than not, this is important.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the preceding code, here, we will use a completely different approach,
    as we will perform an iterative algorithm. We will use a **first-in, first-out**
    (**FIFO**) queue to help order our nodes. Note that Python’s deque can be used
    as efficiently as FIFO, as well as in **last-in, first-out** (**LIFO**). That’s
    because it implements an efficient data structure when you operate at both extremes.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm starts by putting the root node onto the queue. While the queue
    is not empty, we will take the node out front. If it’s an internal node, we will
    put all of its children into the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will iterate the preceding step until the queue is empty. I encourage you
    to take a pen and paper and see how this works by performing the example shown
    in the following diagram. The code is small, but not trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Visiting a tree; the first number indicates the order in which
    that node is visited traversing depth-first, while the second assumes breadth-first
    ](img/B17942_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Visiting a tree; the first number indicates the order in which
    that node is visited traversing depth-first, while the second assumes breadth-first
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get back to the real dataset. As we have a bit too much data to visualize,
    we will generate a trimmed-down version, where we remove the subtrees that have
    single species (in the case of EBOV, they have the same outbreak). We will also
    ladderize the tree, that is, sort the child nodes in order of the number of children:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will perform a deep copy of the tree structure. As our function and the ladderization
    are destructive (they will change the tree), we will want to maintain the original
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: DendroPy is able to enumerate all the leaf nodes (at this stage, a good exercise
    would be to write a function to perform this). With this functionality, we will
    get all the leaves for a certain node. If they share the same species and outbreak
    year as in the case of EBOV, we remove all of the child nodes, leaves, and internal
    subtree nodes.
  prefs: []
  type: TYPE_NORMAL
- en: If they do not share the same species, we recurse down until that happens. The
    worst case is that when you are already at a leaf node, the algorithm trivially
    resolves to the species of the current node.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a massive amount of computer science literature on the topic of trees
    and data structures; if you want to read more, Wikipedia provides a great introduction
    at [http://en.wikipedia.org/wiki/Tree_%28data_structure%29](http://en.wikipedia.org/wiki/Tree_%28data_structure%29).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the use of `lambda` functions and `map` is not encouraged as a Python
    dialect; you can read some (older) opinions on the subject from Guido van Rossum
    at [http://www.artima.com/weblogs/viewpost.jsp?thread=98196](http://www.artima.com/weblogs/viewpost.jsp?thread=98196).
    I presented it here because it’s a very common dialect within functional and recursive
    programming. The more common dialect will be based on a list of comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the functional dialect based on using the `map` and `reduce` operations
    is the conceptual base for MapReduce frameworks, and you can use frameworks such
    as Hadoop, Disco, or Spark to perform high-performance bioinformatics computing.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing phylogenetic data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to visualize phylogenetic trees. DendroPy
    only has simple visualization mechanisms based on drawing textual ASCII trees,
    but Biopython has quite a rich infrastructure, which we will leverage here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This will require you to have completed all of the previous recipes. Remember
    that we have the files for the whole genus of the Ebola virus, including the RAxML
    tree. Furthermore, a simplified genus version will have been produced in the previous
    recipe. As usual, you can find this content in the `Chapter07/Visualization.py`
    notebook file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load all of the phylogenetic data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For all of the trees that we read, we will change the name of the tree, as the
    name will be printed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can draw ASCII representations of the trees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The ASCII representation of the simplified genus tree is shown in the following
    diagram. Here, we will not print the complete version because it will take several
    pages. But if you run the preceding code, you will be able to see that it’s actually
    quite readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The ASCII representation of a simplified Ebola virus dataset
    ](img/B17942_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The ASCII representation of a simplified Ebola virus dataset
  prefs: []
  type: TYPE_NORMAL
- en: '`Bio.Phylo` allows for the graphical representation of trees by using `matplotlib`
    as a backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, we will print the branch lengths at the edges, but we will remove
    all of the lengths that are less than 0.02 to avoid clutter. The result of doing
    this is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – A matplotlib-based version of the simplified dataset with branch
    lengths added ](img/B17942_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – A matplotlib-based version of the simplified dataset with branch
    lengths added
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will plot the complete dataset, but we will color each bit of the tree
    differently. If a subtree only has a single virus species, it will get its own
    color. EBOV will have two colors, that is, one for the 2014 outbreak and one for
    the others, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a tree traversing algorithm, not unlike the ones presented in the previous
    recipe. As a recursive algorithm, it works in the following way. If the node is
    a leaf, it will get a color based on its species (or the EBOV outbreak year).
    If it’s an internal node and all the descendant nodes below it are of the same
    species, it will get the color of that species; if there are several species after
    that, it will be colored in gray. Actually, the color function can be changed
    and will be changed later. Only the edge colors will be used (the labels will
    be printed in black).
  prefs: []
  type: TYPE_NORMAL
- en: Note that ladderization (performed in the previous recipe with DendroPy) helps
    quite a lot in terms of a clear visual appearance.
  prefs: []
  type: TYPE_NORMAL
- en: We also deep copy the genus tree to color a copy; remember from the previous
    recipe that some tree traversal functions can change the state, and in this case,
    we want to preserve a version without any coloring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the usage of the lambda function to clean up the name that was changed
    by trimAl, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – A ladderized and colored phylogenetic tree with the complete
    Ebola virus dataset ](img/B17942_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – A ladderized and colored phylogenetic tree with the complete Ebola
    virus dataset
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tree and graph visualization is a complex topic; arguably, here, the tree’s
    visualization is rigorous but far from pretty. One alternative to DendroPy, which
    has more visualization features, is ETE ([http://etetoolkit.org/](http://etetoolkit.org/)).
    General alternatives for drawing trees and graphs include Cytoscape ([https://cytoscape.org/](https://cytoscape.org/))
    and Gephi ([http://gephi.github.io/](http://gephi.github.io/)). If you want to
    know more about the algorithms for rendering trees and graphs, check out the Wikipedia
    page at [http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)
    for an introduction to this fascinating topic.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to trade style for substance, though. For example, the previous
    edition of this book had a pretty rendering of a phylogenetic tree using a graph-rendering
    library. While it was clearly the most beautiful image in that chapter, it was
    misleading in terms of branch lengths.
  prefs: []
  type: TYPE_NORMAL
