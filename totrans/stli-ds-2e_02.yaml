- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading, Downloading, and Manipulating Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have exclusively used simulated data in our Streamlit
    apps. This was useful for getting a good background on some of the basics of Streamlit,
    but most data science is not done on simulated data but on real-world datasets
    that data scientists already have, or on datasets provided by users.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on the world of data in Streamlit apps, covering everything
    you will need to know to bring datasets to life using Streamlit. We will cover
    data manipulation, using user-imported data, flow control, debugging Streamlit
    apps, and speeding up our data applications using caching through an example dataset
    called Palmer’s Penguins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The setup – Palmer’s Penguins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Streamlit apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data manipulation in Streamlit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence with Session State
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will need to download the Palmer’s Penguins dataset, which
    can be found at [https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv).
    The setup for this chapter, along with an explanation of the dataset, can be found
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The setup – Palmer’s Penguins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we’ll be using a delightful dataset about Arctic penguins
    that comes from the work of Dr. Kristen Gorman ([https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php))
    and the Palmer Station, Antarctica LTER ([https://pallter.marine.rutgers.edu/](https://pallter.marine.rutgers.edu/)).
  prefs: []
  type: TYPE_NORMAL
- en: Dataset Acknowledgment
  prefs: []
  type: TYPE_NORMAL
- en: Data from the Palmer LTER data repository was supported by the Office of Polar
    Programs, NSF Grants OPP-9011927, OPP-9632763, and OPP-0217282.
  prefs: []
  type: TYPE_NORMAL
- en: This data is a common alternative to the famous Iris datasets and includes data
    on 344 individual penguins with 3 species represented. The data can be found in
    the GitHub repository for this book ([https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)),
    in the `penguin_app` folder entitled `penguins.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve discussed before, Streamlit apps run from inside our Python script.
    This sets the base directory to the location of the Python file with our Streamlit
    app, which means we can access any other files that we put in our app directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a folder for our new app in our existing `streamlit_apps`
    folder using the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, download the data and put the resulting CSV file (named `penguins.csv`
    in the example) in the `penguin_app` folder. Now, our folder should have the `penguins.py`
    file and our `penguins.csv` file. For our first go around, we’re just going to
    print out the first five rows of our DataFrame using the `st.write()` function
    we learned about earlier by putting the following code in our `penguins.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following Streamlit app when we run `streamlit
    run penguins.py` in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The first five penguins ](img/B18444_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The first five penguins'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good idea of what the data looks like, we will explore the
    dataset a bit more and then begin adding to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Palmer’s Penguins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin working with this dataset, we should make some visualizations
    to better understand the data. As we saw before, we have many columns in this
    data, whether the bill length, the flipper length, the island the penguin lives
    on, or even the species of penguin. I’ve done the first visualization for us already
    in Altair, a popular visualization library that we will use extensively throughout
    this book because it is interactive by default and generally pretty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Bill length and bill depth'
  prefs: []
  type: TYPE_NORMAL
- en: From this, we can see that the Adelie penguins have a shorter bill length but
    generally have fairly deep bills. Now, what does it look like if we plot weight
    by flipper length?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Bill length and weight'
  prefs: []
  type: TYPE_NORMAL
- en: Now we see that Gentoo penguins seem to be heavier than the other two species,
    and that bill length and body mass are positively correlated. These findings are
    not a huge surprise, but getting to these simple findings was a little tedious.
    There are many more combinations of variables that we could plot, but could we
    instead make a data explorer Streamlit app do this for us?
  prefs: []
  type: TYPE_NORMAL
- en: The final goal of this mini-app is to reduce the friction in exploratory data
    analysis by letting the user define the species of penguin they want to look at,
    along with the *x* and *y* variables to plot on a scatterplot. We’ll start by
    learning how to take those inputs, how to load the data into Streamlit, and then
    how to create a dynamic visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we learned about a Streamlit input called `st.number_input()`.
    This won’t help us here, but Streamlit has a very similar one called `st.selectbox()`,
    which allows us to ask the user to select one option from multiple options, and
    the function returns whatever the user selects. We will use this to get the three
    inputs for our scatterplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates three new variables from three new select boxes in which
    the user can provide input in our Streamlit app. The following screenshot shows
    the Streamlit app from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: User input on penguins'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the `selected_species` variable, we can filter our DataFrame
    and make a quick scatterplot using the selected *x* and *y* variables, as in this
    next block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding bit of code adds to the previous example by loading our DataFrame,
    filtering by species, and then plotting in the same method from the previous chapter,
    which will result in the same app as before but with a scatterplot attached as
    well, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: First penguin scatterplot'
  prefs: []
  type: TYPE_NORMAL
- en: Try to play around with this app and make sure that all the inputs and outputs
    are working correctly. Notice that if we hover over any individual point, we can
    see the underlying data, and if we change the Streamlit inputs, the entire graph
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our graph doesn’t explicitly show what species is being graphed, so let’s practice
    making dynamic text. The following adds dynamic text to our Streamlit app’s graph
    title with the f-strings, which are native to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds the species to our scatterplot and results in the following
    Streamlit app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Dynamic graph titles'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks great, but there are a few more edits that we can make as an improvement.
    Right now we can’t zoom into our chart, so most of the graph is blank. We can
    change this by either using Altair to edit the axes, or we can make the Altair
    chart interactive so that the user can zoom in wherever they’d like on the graph.
    The following code makes the Altair chart zoomable and extends the graph to fit
    the entire screen with the `use_container_width` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows our new and improved Palmer’s Penguins app,
    which has the appropriately sized chart and interactivity (I zoomed into some
    places on the graph that I thought were interesting just to show off the new interactive
    feature). I also placed my mouse over an individual point, which showed the underlying
    data for that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Screenshot with interaction'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, it seemed like a good idea to allow the user
    to select a species to filter the DataFrame by. But now, after making this app,
    it seems like it might be better to just allow the user to make changes to the
    *x* and *y* inputs, and always plot the species in different colors. The next
    bit of code does exactly that, removing the filtering mechanisms we added and
    adding a color parameter to the `altair` section of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our app has a color for each species (in this screenshot, you can probably
    see it in black-and-white, but you should see the different colors in your own
    app!), has interactivity, and allows for user input, all in 26 lines of code and
    3 Streamlit commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Penguins in color'
  prefs: []
  type: TYPE_NORMAL
- en: The last step for this app is to allow the user to upload their own data. What
    if we wanted the research team, at any point, to be able to upload their own data
    to this app and see the results? Or what if there were three research groups,
    all with their own unique data with different column names, that wanted to use
    a method that we created? We’ll approach this problem one aspect at a time. First,
    how do we accept data from users of our app?
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit has a function called `file_uploader()`, which allows users of the
    app to upload data up to 200 MB in size (as a default). It works just like the
    other interactive widgets we’ve used before, with one exception. Our default in
    an interactive widget-like select box is just the first value in our list, but
    it does not make sense to have a default uploaded file before the user actually
    interacts with the app! The default user-uploaded file has a value of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: This begins to cover a very important concept in Streamlit development, which
    is flow control. Flow control can be understood as thinking carefully through
    all the steps of your application because Streamlit will try to run the entire
    app at once if we’re not explicit about things, such as wanting to wait until
    the user has uploaded a file to attempt to create a graphic or manipulate a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control in Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we talked about just before, there are two solutions to this data upload
    default situation. We can provide a default file to use until the user interacts
    with the application, or we can stop the app until a file is uploaded. Let’s start
    with the first option. The following code uses the `st.file_uploader()` function
    from within an `if` statement. If the user uploads a file, then the app uses that;
    if they do not, then we default to the file we have used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code in our terminal, we see our three user inputs
    (the *x* axis, the *y* axis, and the dataset), and also the graph, even if we
    have yet to upload a file. The following screenshot shows this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: File input'
  prefs: []
  type: TYPE_NORMAL
- en: The clear advantage of this approach is that there are always results shown
    in this application, but the results may not be useful to the user! For larger
    applications, this is a subpar solution as well because any data stored inside
    the app, regardless of use, is going to slow the application down. Later, in *Chapter
    7*, *Exploring Streamlit Components*, we’ll discuss all of our options for deployment,
    including a built-in deployment option called Streamlit Community Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second option is to stop the application entirely unless the user has uploaded
    a file. For that option, we’re going to use a new Streamlit function called `stop()`,
    which (predictably) stops the flow whenever it is called. It is best practice
    to use this to find errors in the app and to encourage the user to make some changes
    or describe the error that is happening. This is not necessary for us but is a
    good thing to know for future applications. The following code uses an `if-else`
    statement with `st.stop()` in the `else` statement to prevent the entire app from
    running when `st.file_uploader()` is unused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see with the following screenshot, until we upload our own data,
    we will not see a scatterplot, and the application stops. The Streamlit app simply
    waits to run fully until the user has uploaded their file instead of throwing
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Streamlit stop()'
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to data manipulation and create more complicated Streamlit
    apps, we should touch on some best practices for debugging Streamlit apps.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Streamlit apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We broadly have two options for Streamlit development:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop in Streamlit and `st.write()` as a debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore in Jupyter and then copy to Streamlit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing in Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first option, we write our code directly in Streamlit as we’re experimenting
    and exploring exactly what our application will do. We’ve basically been taking
    this option already, which works very well if we have less exploration work and
    more implementation work to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: What you see is what you get – there is no need to maintain both IPython and
    Python versions of the same app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better experience for learning how to write production code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: A slower feedback loop (the entire app must run before feedback).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A potentially unfamiliar development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring in Jupyter and then copying to Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another option is to utilize the extremely popular Jupyter data science product
    to write and test out the Streamlit app’s code before placing it in the necessary
    script and formatting it correctly. This can be useful for exploring new functions
    that will live in the Streamlit app, but it has serious downsides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: The lightning-fast feedback loop makes it easier to experiment with very large
    apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users may be more familiar with Jupyter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full app does not have to be run to get results, as Jupyter can be run in
    individual cells.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter may provide deceptive results if run out of order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Copying” code over from Jupyter is time-consuming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python versioning may be different between Jupyter and Streamlit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My recommendation here is to develop Streamlit apps inside the environment where
    they are going to be run (that is, a Python file). For debugging, heavily utilize
    the `st.write()` function, which can print out nearly any Python object (dictionary,
    DataFrame, list, string, number, graph, and so on) that you may need. Try to only
    use another development environment such as Jupyter as a last resort! Now on to
    data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation in Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Streamlit runs our Python file from the top down as a script, so we can perform
    data manipulation with powerful libraries such as `pandas` in the same way that
    we might in a Jupyter notebook or a regular Python script. As we’ve discussed
    before, we can do all our regular data manipulation as normal. For our Palmer’s
    Penguins app, what if we wanted the user to be able to filter out penguins based
    on their gender? The following code filters our DataFrame using `pandas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A couple of things to note here. First, we’ve added another `selectbox` widget,
    with male, female, and all options. We could have done this by asking for a text
    input, but for data manipulation we want to restrict user action as much as possible.
    We also made sure to dynamically change the title, which is recommended for clarity
    as we want to show the user that the data has been filtered by their input directly
    in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we create more computationally intensive Streamlit apps and begin to use
    and upload larger datasets, we should start thinking about the runtime of these
    apps and work to increase our efficiency whenever possible. The easiest way to
    make a Streamlit app more efficient is through caching, which is storing some
    results in memory so that the app does not repeat the same work whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: A good analogy for an app’s cache is a human’s short-term memory, where we keep
    bits of information close at hand that we think might be useful. When something
    is in our short-term memory, we don’t have to think very hard to get access to
    that piece of information. In the same way, when we cache a piece of information
    in Streamlit, we are making a bet that we’ll use that information often.
  prefs: []
  type: TYPE_NORMAL
- en: The way Streamlit caching works more specifically is by storing the results
    of a function in our app, and if that function is called with the same parameters
    by another user (or by us if we rerun the app), Streamlit does not run the same
    function but instead loads the result of the function from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s prove to ourselves that this works! First, we’ll create a function for
    our data upload part of the Penguins app, and then use the `time` library to artificially
    make the function take much longer than it would normally and see whether we can
    make our app faster using `st.cache_data`. There are two Streamlit caching functions,
    one for data (`st.cache_data`) and one for resources like database connections
    or machine learning models (`st.cache_resource`).
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry, we’ll learn all about `st.cache_resource` in *Chapter 4*, *Machine
    Learning and AI with Streamlit*, but we don’t need it now so we’ll focus on caching
    data first.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code, we first made a new function called `load_file()`,
    which waits 3 seconds, and then loads the file that we need. Normally, we would
    not intentionally slow down our app, but we want to know whether caching works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s run this app and then select the hamburger icon in the top right
    and press the rerun button (we can also just press the *R* key to rerun).
  prefs: []
  type: TYPE_NORMAL
- en: 'We notice that each time we rerun the app, it takes at least 3 seconds. Now,
    let’s add our cache decorator on top of the `load_file()` function and run our
    app again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As we run the app a few times, we can notice that it is much faster! When we
    rerun the app, two things happen. First, Streamlit checks the cache to ascertain
    whether that same function with the same inputs has been run before and returns
    the Palmer’s Penguins data from memory, and second, it does not run the `load_file()`
    function at all, meaning we never run the `time.sleep(3)` command and also never
    spend the time required to load the data into Streamlit. We’ll explore this caching
    function in more detail, but this method offers us the majority of the efficiency
    gains. The last flow-related topic we will cover here is Streamlit’s `st.session_state`,
    which is used to hold information across sessions!
  prefs: []
  type: TYPE_NORMAL
- en: Persistence with Session State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most frustrating parts of the Streamlit operating model for developers
    starting out is the combination of two facts:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, information is not stored across reruns of the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On user input, Streamlits are rerun top-to-bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These two facts make it difficult to make certain types of apps! This is best
    shown in an example. Let’s say that we want to make a to-do app that makes it
    easy for you to add items to your to-do list. Adding user input in Streamlit is
    really simple, so we can create one quickly in a new file called `session_state_example.py`
    that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This app seems to work well on first use. You can add to the list from the
    text box as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18444_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: To-do list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what do you think will happen if we try to add a second item? Let’s try
    it now by adding another item to our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B18444_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Second addition'
  prefs: []
  type: TYPE_NORMAL
- en: Once you try to add more than one item to the list, you will notice that it
    resets the original list and forgets what the first item you entered was! Now
    our to-do list does not contain our eat fruit addition from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `st.session_state`. Session State is a Streamlit feature that is a global
    dictionary that persists through a user’s session. This allows us to get around
    the two annoyances we mentioned earlier in this section, by placing the user’s
    inputs into this global dictionary! We can add the Session State functionality
    by first checking if we have placed our to-do list in the `session_state` dictionary,
    and if not, setting our default values. And with each new button click, we can
    update our list that we placed in the `session_state` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, our app will work just fine and will keep our to-do list until we leave
    the app or refresh the page. And we can add multiple to-do items!
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B18444_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Multiple additions'
  prefs: []
  type: TYPE_NORMAL
- en: There are many applications of this, from keeping the state of Streamlit inputs
    to applying filters across multi-page apps (don’t worry, we will cover these later
    in this book). But whenever you want to keep information from the user across
    runs, `st.session_state` can help you out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was full of fundamental building blocks that we will use often
    throughout the remainder of this book, and that you will use to develop your own
    Streamlit applications.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of data, we covered how to bring our own DataFrames into Streamlit
    and how to accept user input in the form of a data file, which brings us past
    only being able to simulate data. In terms of other skill sets, we learned how
    to use our cache to make our data apps faster, how to control the flow of our
    Streamlit apps, and how to debug our Streamlit apps using `st.write()`. That’s
    it for this chapter. Next, we’ll move on to data visualization!
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/sl](https://packt.link/sl)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code13440134443835796.png)'
  prefs: []
  type: TYPE_IMG
