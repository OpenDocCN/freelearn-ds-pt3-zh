<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Classes
                </header>
            
            <article>
                
<p>In mathematics, when we write <img class="fm-editor-equation" src="assets/b1869c68-1acd-4903-8bde-c96d445836db.png" style="width:1.92em;height:1.33em;"/>, we refer to a mathematical object for which we know many methods from elementary calculus. For example:</p>
<ul>
<li>We might want to evaluate <sub><img class="fm-editor-equation" src="assets/a629d68f-bc0d-4504-922b-d25a0ffd394a.png" style="width:3.08em;height:1.33em;"/></sub> at <sub><img class="fm-editor-equation" src="assets/b8a07b49-896f-4d82-b58b-93e1134b360f.png" style="width:4.08em;height:1.08em;"/></sub>, that is, compute <img class="fm-editor-equation" src="assets/5566ed05-3ece-4bd8-9e92-47a924e36044.png" style="width:3.42em;height:1.17em;"/>, which returns a real number.</li>
<li>We might want to compute its derivative, which gives us another mathematical object, <strong>cos</strong>.</li>
<li>We might want to compute the first three coefficients of its Taylor polynomial.</li>
</ul>
<p>These methods may be applied not only to <strong>sin</strong> but also to other sufficiently smooth functions. There are, however, other mathematical objects, for example, the number <em>5,</em> for which these methods would make no sense.</p>
<p>Objects that have the same methods are grouped together in abstract classes, for example, functions. Every statement and every method that can be applied to functions in general applies in particular to <strong>sin</strong> or <strong>cos</strong>.</p>
<p>Other examples for such classes might be a rational number, for which a denominator and numerator method exist; an interval, which has a left and right boundary method; an infinite sequence, for which we can ask whether it has a limit, and so on.</p>
<p>In this case, <img class="fm-editor-equation" src="assets/796b437a-5221-4fa9-af25-8c1efb98be48.png" style="width:1.67em;height:1.17em;"/> is called an <em>instance</em> of the class. The mathematical phrase <em>Let g be a function...</em> is, in this context, called <strong>instantiation</strong>. Here, <img class="fm-editor-equation" src="assets/b441010f-f760-498d-83b1-19bbbacf79ca.png" style="width:0.50em;height:0.83em;"/> is the name of the function, one of many <em>attributes</em> that can be assigned to it. Another attribute might be its domain.</p>
<p>The mathematical object <sub><img class="fm-editor-equation" src="assets/792a1325-520d-43b7-a0e4-3bab90b0f537.png" style="width:6.67em;height:1.33em;"/></sub> is just like the sine function. Every function method applies to <img class="fm-editor-equation" src="assets/a10ad167-28bd-4fc6-9c5f-8a658b818ccb.png" style="width:0.67em;height:1.00em;"/>, but we can also define special methods for <img class="fm-editor-equation" src="assets/5b332529-ae82-48ca-86f5-8858c45f7ae7.png" style="width:0.67em;height:1.00em;"/>. We might, for instance, ask for <img class="fm-editor-equation" src="assets/4d4879f1-5b0b-4547-8323-dc47f88332e5.png" style="width:0.83em;height:1.00em;"/><em>'</em>s coefficients. These methods can be used to define the class of polynomials. As polynomials are functions, they additionally <em>inherit</em> all methods of the function class.</p>
<p>In mathematics, we often use the same operator symbol for completely different operations. For instance, in <img class="fm-editor-equation" src="assets/b3530656-c09b-4bda-87e2-34e9dac3fec7.png" style="width:2.42em;height:1.00em;"/> and <img class="fm-editor-equation" src="assets/23af4c8e-d3ba-4c2a-b5be-9d1e88f67112.png" style="width:4.33em;height:1.08em;"/>, the operator symbol <kbd>+</kbd> has different meanings. By using the same symbol, similarities to corresponding mathematical operations are emphasized. We have introduced these terms from object-oriented programming by applying them to mathematical examples, such as classes, instance and instantiation, inheritance, methods, attributes, and operator overloading.</p>
<p>Specifically, in this chapter, we are going to cover the following topics:</p>
<ul>
<li>Introduction to classes</li>
<li>Bound and unbound methods</li>
<li>Class attributes and class methods</li>
<li>Subclasses and inheritance</li>
<li>Encapsulation</li>
<li>Classes as decorators</li>
</ul>
<p class="mce-root">In this chapter, we will show how these concepts are used in Python and start with some fundamentals.</p>
<h1 id="uuid-14d60917-857f-4b18-849b-0f19593658cf">8.1 Introduction to classes</h1>
<p>This section introduces the most common terms of classes and their realization in Python.</p>
<p>First, we set up a guiding example.</p>
<h2 id="uuid-a84e4987-81da-46a9-9c3b-7f678c6d6d84">8.1.1 A guiding example: Rational numbers</h2>
<p>We will illustrate the concept of classes with the example of rational numbers, that is, numbers of the form <img class="fm-editor-equation" src="assets/66f8f5f2-953a-4695-ba5d-a6ed3021626e.png" style="width:6.00em;height:1.50em;"/>, where <span><img class="fm-editor-equation" src="assets/830cf1ec-1cf4-43f7-9771-6b50c9b2ed63.png" style="width:1.42em;height:0.92em;"/></span> and <span><img class="fm-editor-equation" src="assets/99434b20-95a8-41b5-b0fa-79fbd50f80f7.png" style="width:1.25em;height:0.83em;"/></span> are integers.</p>
<p>The following figure gives an example of a class declaration:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cecb5307-8e17-4e70-92d6-ac4927583d45.png" style="width:37.58em;height:21.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 8.1: Example of a class declaration</div>
<p>We use rational numbers here only as an example of the class concept. For future work in Python with rational numbers, use the <span>Python</span> <span>module</span> <kbd>fractions</kbd><span>.</span></p>
<h2 id="uuid-0d03d6a2-fb32-4ba2-9363-33e483821c75">8.1.2 Defining a class and making an instance</h2>
<p>The definition of a class is made by a block command with the <span>keyword</span> <kbd>class</kbd><span>, the name of the class, and some statements in the block (see</span> <em>Figure 8.1</em><span>):</span></p>
<pre>class RationalNumber: 
    pass</pre>
<p>An instance of this class (or in other words, an object of the type <kbd>RationalNumber</kbd>) is created by <kbd>r = RationalNumber()</kbd> and the query <kbd>type(r)</kbd> <span>returns the answer,</span> <kbd>&lt;class'__main__.RationalNumber'&gt;</kbd><span>. If</span> we want to investigate whether an object is an instance of this class, we can use the following lines:</p>
<pre>if isinstance(r, RationalNumber):
    print('Indeed, it belongs to the class RationalNumber')  </pre>
<p>So far, we have generated an object of the type <kbd>RationalNumber</kbd> <span>that</span> has no data yet. Furthermore, there are no methods defined to perform operations with these objects. This is the subject of the next sections.</p>
<h2 id="uuid-1d2282df-ca04-49ec-a46c-8c16475136f5">8.1.3 The __init__ method</h2>
<p>Now we provide our example class with some attributes, that is, we give it defining data. In our case, this data will be the values of the denominator and the numerator. To this end, we have to define a method, <kbd>__init__</kbd>, used to initialize the class with these values:</p>
<pre>class RationalNumber:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator</pre>
<p>Before we explain the special function <kbd>__init__</kbd>, which we added to the class, we demonstrate the instantiation of a <kbd>RationalNumber</kbd> <span>object</span>:</p>
<pre>q = RationalNumber(10, 20)    # Defines a new object
q.numerator                   # returns 10
q.denominator                 # returns 20</pre>
<p>A new object of type <kbd>RationalNumber</kbd> is created by using the class name as if it were a function. This statement does two things:</p>
<ol>
<li>It first creates an empty object, <kbd>q</kbd>.</li>
<li>Then it applies the <kbd>__init__</kbd> function to it; that is, <kbd>q.__init__(10, 20)</kbd> is executed.</li>
</ol>
<p>The first parameter of <kbd>__init__</kbd> refers to the new object itself. On a function call, this first parameter is replaced by the object's instance. This applies to all methods of the class and not just to the special <span>method</span> <kbd>__init__</kbd><span>. The special role of this first parameter is reflected by the convention to name it</span> <kbd>self</kbd><span>.</span></p>
<p>In the previous example, the <span>function</span> <kbd>__init__</kbd> <span>defines two attributes of the new object,</span> <kbd>numerator</kbd> <span>and</span> <kbd>denominator</kbd><span>.</span></p>
<h2 id="uuid-d991b6ff-45d2-46b8-9509-21a4aa45fe82">8.1.4 Attributes and methods</h2>
<p>One of the main reasons for working with classes is that objects can be grouped together and bound to a common object. We saw this already when looking at rational numbers; <kbd>denominator</kbd> and <kbd>numerator</kbd> are two objects that we bound to an instance of the <span>class</span> <kbd>RationalNumber</kbd><span>. They are called</span> <strong>attributes of the instance</strong><span>. The fact that an object is an attribute of a class instance becomes apparent from the way they are referenced, which we have used tacitly before:</span></p>
<pre>​_&lt;object&gt;.attribute</pre>
<p>Here are some examples of instantiation and attribute reference:</p>
<pre>q = RationalNumber(3, 5) # instantiation
q.numerator              # attribute access
q.denominator

a = array([1, 2])        # instantiation
a.shape

z = 5 + 4j               # instantiation<em>step</em>z.imag</pre>
<p>Once an instance is defined, we can set, change, or delete attributes of that particular instance. The syntax is the same as for regular variables:</p>
<pre>q = RationalNumber(3, 5) 
r = RationalNumber(7, 3)
q.numerator = 17
del r.denominator</pre>
<p>Changing or deleting an attribute may have undesired side effects, which might even render the object useless. We will be learning more about this in <span><a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.2</a>:</span> <em>Attributes that depend on each other</em>. As functions are objects too, we can also use functions as attributes; they are called methods of the instance:</p>
<pre>&lt;object&gt;.method(&lt;arguments...&gt;)</pre>
<p>For example, let's add a method to the <span>class</span> <kbd>RationalNumber</kbd> <span>that converts the number to a float:</span></p>
<pre>class RationalNumber:
...
    def convert2float(self):
        return float(self.numerator) / float(self.denominator)</pre>
<p>Again, this method takes as its first (and only) argument <kbd>self</kbd>, the reference to the object itself. We use this method with a regular function call:</p>
<pre>q = RationalNumber(10, 20)    # Defines a new object
q.convert2float() # returns 0.5   </pre>
<p>This is equivalent to the following call:</p>
<pre>RationalNumber.convert2float(q)</pre>
<p>Note again that the object instance is inserted as the first argument of the function. This use of the first argument explains the error message that would occur if this particular method were used with additional arguments. The <span>call</span> <kbd>q.convert2float(15)</kbd> <span>provokes this error message:</span></p>
<pre>TypeError: convert2float() takes exactly 1 argument (2 given)</pre>
<p>The reason this does not work is that <kbd>q.convert2float(15)</kbd> is precisely equivalent to <kbd>RationalNumber.comvert2float(q,15)</kbd>, which fails because <kbd>RationalNumber.convert2float</kbd> takes only one argument.</p>
<h2 id="uuid-afb74a7b-e1d6-4d2a-af35-2a93fab33be6">8.1.5 Special methods</h2>
<p>The special method <kbd>__repr__</kbd> gives us the ability to define the way the object is represented in a Python interpreter. For rational numbers, a possible definition of this method could be as follows:</p>
<pre>class RationalNumber:
    ...
    def __repr__(self): <br/>        return f'{self.numerator} / {self.denominator}'</pre>
<p>With this method defined, just typing <kbd>q</kbd> returns <kbd>10 / 20</kbd>.</p>
<p>We would like to have a method that performs the addition of two rational numbers. A first attempt could result in a method like this:</p>
<pre>class RationalNumber:
    ...
    def add(self, other): <br/>        p1, q1 = self.numerator, self.denominator <br/>        if isinstance(other, int):        <br/>            p2, q2 = other, 1 <br/>        else: <br/>            p2, q2 = other.numerator, other.denominator <br/>        return RationalNumber(p1 * q2 + p2 * q1, q1 * q2)</pre>
<p>A call to this method takes the following form:</p>
<pre>q = RationalNumber(1, 2)
p = RationalNumber(1, 3)
q.add(p)   # returns the RationalNumber for 5/6</pre>
<p>It would be much nicer if we could write <kbd>q + p</kbd> instead. But so far, the plus sign is not defined for the <span>type</span> <kbd>RationalNumber</kbd><span>. This is done by using the special method</span> <kbd>__add__</kbd><span>. So, just renaming</span> <kbd>add</kbd> <span>to</span> <kbd>__add__</kbd> <span>allows using the plus sign for rational numbers:</span></p>
<pre>q = RationalNumber(1, 2)
p = RationalNumber(1, 3)
q + p # RationalNumber(5, 6)</pre>
<p>The expression <kbd>q + p</kbd> is, in fact, an alias for the expression <kbd>q.__add__(p)</kbd>. In <em>Table 8.1</em>, you find special methods for binary operators such as <kbd>+</kbd>, <kbd>-</kbd>, or <kbd>*</kbd>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Method</strong></p>
</td>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Method</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>+</kbd></p>
</td>
<td>
<p><kbd>__add__</kbd></p>
</td>
<td>
<p><kbd>+=</kbd></p>
</td>
<td>
<p><kbd>__iadd__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>*</kbd></p>
</td>
<td>
<p><kbd>__mul__</kbd></p>
</td>
<td>
<p><kbd>*=</kbd></p>
</td>
<td>
<p><kbd>__imul__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>-</kbd></p>
</td>
<td>
<p><kbd>__sub__</kbd></p>
</td>
<td>
<p><kbd>-=</kbd></p>
</td>
<td>
<p><kbd>__isub__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>/</kbd></p>
</td>
<td>
<p><kbd>__truediv__</kbd></p>
</td>
<td>
<p><kbd>/=</kbd></p>
</td>
<td>
<p><kbd>__itruediv__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>//</kbd></p>
</td>
<td>
<p><kbd>__floordiv__</kbd></p>
</td>
<td>
<p><kbd>//=</kbd></p>
</td>
<td>
<p><kbd>__ifloordiv__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>**</kbd></p>
</td>
<td>
<p><kbd>__pow__</kbd></p>
</td>
<td/>
<td/>
</tr>
<tr>
<td>
<p><kbd>==</kbd></p>
</td>
<td>
<p><kbd>__eq__</kbd></p>
</td>
<td>
<p><kbd>!=</kbd></p>
</td>
<td>
<p><kbd>qD__ne__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;=</kbd></p>
</td>
<td>
<p><kbd>__le__</kbd></p>
</td>
<td>
<p><kbd>&lt;</kbd></p>
</td>
<td>
<p><kbd>__lt__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>&gt;=</kbd></p>
</td>
<td>
<p><kbd>__ge__</kbd></p>
</td>
<td>
<p><kbd>&gt;</kbd></p>
</td>
<td>
<p><kbd>__gt__</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>()</kbd></p>
</td>
<td>
<p><kbd>__call__</kbd></p>
</td>
<td>
<p><kbd>[]</kbd></p>
</td>
<td>
<p><kbd>__getitem__</kbd></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 8.1: Some Python operators and corresponding class methods</div>
<p>The implementation of those operators for a new class is called <strong>operator overloading</strong>. Another example of operator overloading is a method for examining whether two rational numbers are the same:</p>
<pre>class RationalNumber:
...
    def __eq__(self, other):
        return self.denominator * other.numerator == \
            self.numerator * other.denominator</pre>
<p>It is used like this:</p>
<pre>p = RationalNumber(1, 2) # instantiation
q = RationalNumber(2, 4) # instantiation
p == q # True</pre>
<p>Operations between objects belonging to different classes need special care:</p>
<pre>p = RationalNumber(1, 2) # instantiation
p + 5  # corresponds to p.__add__(5)  
5 + p  # returns an error</pre>
<p>By default, the <span>operator</span> <kbd>+</kbd> <span>invokes the left operand's method,</span> <kbd>__add__</kbd><span>. We programmed it so that it allows both objects of type</span> <kbd>int</kbd> <span>and objects of type</span> <kbd>RationalNumber</kbd><span>. In the statement</span> <kbd>5+p</kbd><span>, the operands are commuted and the</span> <span>method</span> <kbd>__add__</kbd> <span>of the built-in type</span> <kbd>int</kbd> <span>is invoked. This method returns an error as it cannot know how to handle rational numbers. This case can be handled by the method</span> <kbd>__radd__</kbd><span>, with which we now will equip the</span> <span>class</span> <kbd>RationalNumber</kbd><span>. The method</span> <kbd>__radd__</kbd> <span>is called</span> <strong>reverse addition</strong><span>.</span></p>
<h3 id="uuid-d219d1b5-1175-4f4d-9510-49d20b695611">Reverse operations</h3>
<p>If operations such as <kbd>+</kbd> are applied to two operands of different types, the corresponding method (in this case, <kbd>__add__</kbd>) of the left operand is invoked first. If this raises an exception, the reverse method (here, <kbd>__radd__</kbd>) of the right operand is called. If this method does not exist, a <kbd>TypeError</kbd> exception is raised.</p>
<p>In order to enable the operation <sub><img class="fm-editor-equation" src="assets/c395f657-6c03-422c-ba41-23a1b55c9001.png" style="width:2.92em;height:1.33em;"/></sub><span>,</span> where <span><sub><img class="fm-editor-equation" src="assets/a1f1efad-32cf-4fb3-a1c6-e031ee758cc3.png" style="width:0.83em;height:1.17em;"/></sub></span> is an instance of <kbd>RationalNumber</kbd>, we define <kbd>__radd__</kbd> as:</p>
<pre>class RationalNumber:
   ....
    def __radd__(self, other):
        return self + other</pre>
<p>Note that <kbd>__radd__</kbd> interchanges the order of the arguments; <kbd>self</kbd> is the object of type <kbd>RationalNumber</kbd> while <kbd>other</kbd> is the object that has to be converted.</p>
<h3 id="uuid-507e605d-0509-4669-8d60-59dffcd230c6">Methods mimicking function calls and iterables</h3>
<p>Using a class instance together with parentheses or brackets<em>,</em> <kbd>()</kbd> or <kbd>[]</kbd>, invokes a call to one of the special methods <kbd>__call__</kbd> or <kbd>__getitem__</kbd>, giving the instance the behavior of a function or of an iterable; see also <em>Table 8.1</em>.</p>
<pre>class Polynomial:
    ...
    def __call__(self, x):
        return self.eval(x)</pre>
<p>Which now may be used as follows:</p>
<pre>p = Polynomial(...)    # Creating a polynomial object
p(3.) # value of p at 3.</pre>
<p>The <span>special method</span> <kbd>__getitem__</kbd> makes sense if the class provides an iterator (it is recommended that you review <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.2.1</a>: <em>Generators</em> before you consider the following example).</p>
<p>The recursion <sub><span><img class="fm-editor-equation" src="assets/deae62f4-7489-4c8f-9bd3-cf784904f150.png" style="width:12.67em;height:1.33em;"/></span></sub> is called a <strong>three<em>-</em>term recursion</strong>. It plays an important role in applied mathematics, in particular in the construction of orthogonal polynomials. We can set up a three-term recursion as a class in the following way:</p>
<pre>import itertools

class  Recursion3Term:
    def __init__(self, a0, a1, u0, u1):
        self.coeff = [a1, a0]
        self.initial = [u1, u0]
    def __iter__(self):
        u1, u0 = self.initial
        yield u0  # (see also Iterators section in Chapter 9) 
        yield u1
        a1, a0 = self.coeff
        while True :
            u1, u0 = a1 * u1 + a0 * u0, u1
            yield u1
    def __getitem__(self, k):
        return list(itertools.islice(self, k, k + 1))[0]</pre>
<p>Here, the method <kbd>__iter__</kbd> defines a generator object, which allows us to use an instance of the class as an iterator:</p>
<pre>r3 = Recursion3Term(-0.35, 1.2, 1, 1)
for i, r in enumerate(r3):
    if i == 7:
        print(r)  # returns 0.194167
        break</pre>
<p>The method <kbd>__getitem__</kbd> enables us to directly access the iterations as if <kbd>r3</kbd> were a list:</p>
<pre>r3[7] # returns 0.194167</pre>
<p>Note that we used <kbd>itertools.islice</kbd> when coding <kbd>__getitem__</kbd> (see <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.3.2</a>: <em>Iterator tools</em> for more information).</p>
<h2 id="uuid-d08ec66c-d7e1-4210-acc7-68361ec172ed">8.2 Attributes that depend on each other</h2>
<p>Attributes of an instance can be changed (or created) by simply assigning them a value. However, if other attributes depend on the one just changed, it is desirable to change them simultaneously.</p>
<p>To demonstrate this, we consider an example: let's define a class that defines an object for planar triangles from three given points. A first attempt to set up such a class could be as follows:</p>
<pre>class Triangle:
    def __init__(self,  A, B, C):
        self.A = array(A)
        self.B = array(B)
        self.C = array(C)
        self.a = self.C - self.B
        self.b = self.C - self.A
        self.c = self.B - self.A
    def area(self):
        return abs(cross(self.b, self.c)) / 2</pre>
<p>An instance of this triangle is created by this:</p>
<pre>tr = Triangle([0., 0.], [1., 0.], [0., 1.])</pre>
<p>Then its area is computed by calling the corresponding method:</p>
<pre>tr.area() # returns 0.5</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>If we change an attribute, say point <em>B</em>, the corresponding edges <span><em>a</em></span> and <span><em>c</em></span> are not automatically updated and the computed area is wrong:</p>
<pre>tr.B = [12., 0.]
tr.area() # still returns 0.5, should be 6 instead.</pre>
<p>A remedy is to define a method that is executed when an attribute is changed; such a method is called a <strong>setter method</strong>. Correspondingly, you might ask for a method that is executed when a value of an attribute is requested; such a method is called a <strong>getter method</strong>. We explain now how these two methods are defined.</p>
<h2 id="uuid-309585fc-d0b5-4d96-9233-0bb7c7d761ee">8.2.1 The function property</h2>
<p>The special <span>function</span> <kbd>property</kbd> links an attribute to such a getter, setter, and deleter method. It might also be used to assign a documentation string to an attribute:</p>
<pre>attribute = property(fget = get_attr, fset = set_attr, 
                     fdel = del_attr, doc = string)</pre>
<p>We continue with the previous example with a setter method and consider the class <kbd>Triangle</kbd> again. If the following statement is included in the definition of this class, the command <span><kbd>tr.B = &lt;something&gt;</kbd></span> <span>invokes the setter method</span> <kbd>set_B</kbd>:</p>
<pre>B = property(fget = get_B, fset = set_B, fdel = del_B, <br/>             doc = ’The point B of a triangle’)</pre>
<p>Let's modify the <kbd>Triangle</kbd> class accordingly:</p>
<pre>class Triangle:
    def __init__(self, A, B, C):
        self._A = array(A)
        self._B = array(B)
        self._C = array(C)
        self._a = self._C - self._B
        self._b = self._C - self._A
        self._c = self._B - self._A
    def area(self):
        return abs(cross(self._c, self._b)) / 2.
    def set_B(self, B):
        self._B = B
        self._a = self._C - self._B
        self._c = self._B - self._A
    def get_B(self):
        return self._B
    def del_Pt(self):
        raise Exception('A triangle point cannot be deleted')
    B = property(fget = get_B, fset = set_B, fdel = del_Pt)</pre>
<p>If the attribute <kbd>B</kbd> is changed, then the <kbd>set_B</kbd> <span>method</span> stores the new value in the internal attribute <kbd>_B</kbd> and changes all depending attributes:</p>
<pre>tr.B = [12., 0.]
tr.area() # returns 6.0</pre>
<p>The way the deleter method is used here is to prevent the deletion of attributes:</p>
<pre>del tr.B # raises an exception</pre>
<p>The use of an underscore as a prefix of attribute names is a convention used to indicate attributes that are not designed to be accessed directly. They are intended to hold data for attributes handled by setters and getters. These attributes are not private in the sense of other programming languages; they are just not intended to be accessed directly.</p>
<h1 id="uuid-1ad291f3-4d1c-4dc9-8100-543cbd8c955c">8.3 Bound and unbound methods</h1>
<p>We will now take a closer look at attributes that are methods. Let's consider an example:</p>
<pre>class A:
    def func(self,arg):
        pass</pre>
<p>A little inspection shows us how the nature of <kbd>func</kbd> changes after creating an instance:</p>
<pre>A.func  # &lt;unbound method A.func&gt;
instA = A()  # we create an instance
instA.func  #  &lt;bound method A.func of ... &gt;</pre>
<p>Calling, for example, <kbd>A.func(3)</kbd> would result in an error message such as this:</p>
<pre>TypeError: func() missing 1 required positional argument: 'arg'</pre>
<p><kbd>instA.func(3)</kbd> is executed as expected. Upon creation of an instance, the method <kbd>func</kbd> is bound to the instance. The argument <kbd>self</kbd> gets the instance assigned as its value. Binding a method to an instance makes the method applicable as a function. Before that, it is of no use. Class methods, which we will consider in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.4.2</a>: <em>Class methods</em>, are different in this aspect.</p>
<h1 id="uuid-4179ac60-7633-44ac-a8fd-9ba53698390e">8.4 Class attributes and class methods</h1>
<p>So far, we have seen attributes and methods that are bound to an instance of a class. In this section, we introduce class attributes and class methods. They allow access to methods and data before an instance is created.</p>
<h2 id="uuid-723202fa-9384-4cf1-8523-6f9950fd6c35">8.4.1 Class attributes</h2>
<p>Attributes specified in the class declaration are called <strong>class attributes</strong>. Consider the following example:</p>
<pre>class Newton:
    tol = 1e-8 # this is a class attribute
    def __init__(self,f):
        self.f = f # this is not a class attribute
    ...</pre>
<p>Class attributes are useful for simulating default values and can be used if values have to be reset:</p>
<pre>N1 = Newton(f)
N2 = Newton(g)</pre>
<p>Both instances have an attribute, <kbd>tol</kbd>, with the value initialized in the class definition:</p>
<pre>N1.tol # 1e-8
N2.tol # 1e-8</pre>
<p>Altering the class attribute automatically affects all the corresponding attributes of all instances:</p>
<pre>Newton.tol = 1e-10
N1.tol # 1e-10
N2.tol # 1e-10</pre>
<p>Altering <kbd>tol</kbd> for one instance does not affect the other instance:</p>
<pre>N2.tol = 1.e-4
N1.tol  # still 1.e-10</pre>
<p>But now, <kbd>N2.tol</kbd> is detached from the class attribute. Changing <kbd>Newton.tol</kbd> no longer has any effect on <kbd>N2.tol</kbd>:</p>
<pre>Newton.tol = 1e-5 <br/># now all instances of the Newton classes have tol=1e-5
N1.tol # 1.e-5
N2.tol # 1.e-4 <br/># N2.tol is now detached and therefore not altered</pre>
<h2 id="uuid-859c661b-4857-4db8-b7bf-c08d98d6460f">8.4.2 Class methods</h2>
<p>We saw in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.3</a>: <em>Bound and unbound methods</em> how methods are either bound to an instance of a class or remain in a state as unbound methods. Class methods are different. They are always bound methods. They are bound to the class itself.</p>
<p>We will first describe the syntactic details and then give some examples to show what these methods can be used for.</p>
<p>To indicate that a method is a class method, the decorator line precedes the method definition:</p>
<pre>@classmethod</pre>
<p>While standard methods make a reference to an instance by the use of their first argument, the first argument of a class method refers to the class itself. By convention, the first argument is called <kbd>self</kbd> for standard methods and <kbd>cls</kbd> for class methods.</p>
<p>The following is an example of the standard case:</p>
<pre>class A:
    def func(self,*args):
         &lt;...&gt;</pre>
<p>This is contrasted by an example of the <kbd>classmethod</kbd> case:</p>
<pre>class B:
    @classmethod
    def func(cls,*args):
         &lt;...&gt;</pre>
<p>In practice, class methods may be useful for executing commands before an instance is created, for instance, in a preprocessing step. See the following example.</p>
<p>In this example, we show how class methods can be used to prepare data before creating an instance:</p>
<pre>class Polynomial:
    def __init__(self, coeff):
        self.coeff = array(coeff)
    @classmethod
    def by_points(cls, x, y):
        degree = x.shape[0] - 1
        coeff = polyfit(x, y, degree)
        return cls(coeff) 
    def __eq__(self, other):
        return allclose(self.coeff, other.coeff)</pre>
<p>The class is designed so that a polynomial object is created by specifying its coefficients. Alternatively, the <span>class method</span> <kbd>by_points</kbd> <span>allows us to define a polynomial by interpolation points.</span></p>
<p>We can transform the interpolation data to the polynomial coefficients even when no instance of <kbd>Polynomial</kbd> is available:</p>
<pre>p1 = Polynomial.by_points(array([0., 1.]), array([0., 1.]))
p2 = Polynomial([1., 0.])

print(p1 == p2)  # prints True</pre>
<p>Another example of a class method is presented in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.7</a>: <em>Classes as decorators</em>. There, a class method is used to access information related to several (or all) instances from this class.</p>
<h1 id="uuid-c9df9bc9-b12a-4cce-953b-f7441398e42c">8.5 Subclasses and inheritance</h1>
<p>In this section, we introduce some central concepts from object-oriented programming: <strong>abstract classes</strong>, <strong>subclasses</strong>, and <strong>inheritance</strong>. To guide you through these concepts, we consider another mathematical example: one-step methods for solving a differential equation.</p>
<p>The generic form of an ordinary initial value problem is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/984b6f95-b6c1-45b0-b4b9-a33b4a888ee6.png" style="width:24.33em;height:1.50em;"/><em><br/></em></div>
<p>The data is the right-hand side function <span><img class="fm-editor-equation" src="assets/ae32d475-3b7f-42fc-ba19-35f6c70f1e90.png" style="width:0.67em;height:1.50em;"/></span>, the initial value <img class="fm-editor-equation" src="assets/110bf954-0df2-465d-a569-e653d9b7bfec.png" style="width:1.58em;height:1.17em;"/>, and the interval of interest <img class="fm-editor-equation" src="assets/84ce4328-754a-4cae-a02c-6149358e7cf5.png" style="width:3.00em;height:1.42em;"/>.</p>
<p>The solution to this problem is a function <sub><img class="fm-editor-equation" src="assets/aee7a0ad-6c39-4d75-88a7-dff14759956f.png" style="width:7.00em;height:1.33em;"/></sub>. A numerical algorithm gives this solution as a vector <span><img class="fm-editor-equation" src="assets/6564bfaf-0da4-44ae-ae55-6e5e89f4e9ca.png" style="width:0.92em;height:0.92em;"/></span> of discrete values <img class="fm-editor-equation" src="assets/c623b321-35c6-4b22-9667-2847e637a603.png" style="width:1.42em;height:1.17em;"/> being approximations to <sub><img class="fm-editor-equation" src="assets/4cb2ef0c-bb63-4b63-a245-f971704ba437.png" style="width:2.25em;height:1.42em;"/></sub>. Here, <sub><img class="fm-editor-equation" src="assets/d1198a41-c4a7-4bd9-af0c-827318e13aad.png" style="width:5.33em;height:1.42em;"/></sub> and <sub><img class="fm-editor-equation" src="assets/72ef7f04-3a16-4a59-99c6-340ae218054f.png" style="width:6.25em;height:1.25em;"/></sub> are discretized values of the independent variable <span><img class="fm-editor-equation" src="assets/b47fccf1-7514-4e00-bfb2-adfc999d7379.png" style="width:0.50em;height:1.08em;"/></span>, which in physical models often represents time.</p>
<p>A one-step method constructs the solution values <img class="fm-editor-equation" src="assets/39df427c-bf50-4e98-9e2d-be6e53c2b29f.png" style="width:1.17em;height:0.92em;"/> by the recursion steps:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b8b77557-6e14-4250-951f-c876172b3cad.png" style="width:15.17em;height:1.58em;"/></p>
<p>Here, <img class="fm-editor-equation" src="assets/c29823d2-ff3c-45aa-a1c1-b0ca44432554.png" style="width:1.00em;height:1.08em;"/> is a step function that characterizes the individual methods, see also <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[28]</a>:</p>
<ul>
<li>
<div class="CDPAlignLeft CDPAlign">Explicit Euler: <img class="fm-editor-equation" src="assets/991c703e-d8c4-4210-9328-b2f82309f864.png" style="width:13.67em;height:1.58em;"/>_</div>
</li>
<li>
<div class="CDPAlignLeft CDPAlign">Midpoint rule: <img class="fm-editor-equation" src="assets/c1d72a3a-495e-49e2-b4cd-5bc4162546a3.png" style="width:21.67em;height:2.75em;"/></div>
</li>
<li>
<div class="CDPAlignLeft CDPAlign">Runge–Kutta 4: <img class="fm-editor-equation" src="assets/ccd180d0-7786-4692-9697-1790a3f151a8.png" style="width:21.75em;height:2.83em;"/>with <span><img class="fm-editor-equation" src="assets/ae77b771-8d9e-4352-bbbf-38aa1f1c44a9.png" style="width:65.75em;height:3.67em;"/></span></div>
</li>
</ul>
<p>What we did here is the typical way of describing a mathematical algorithm. We first described a method by its idea, giving its steps in an abstract way. To actually use it, we have to fill in the parameters of a concrete method, in this example, the function <sub><img class="fm-editor-equation" src="assets/8e3a3508-cd7c-412c-ad83-961369b45912.png" style="width:0.92em;height:1.17em;"/></sub>. This is also the way things are explained in object-oriented programming. First, we set up a class with the abstract description of the method:</p>
<pre>class OneStepMethod:
    def __init__(self, f, x0, interval, N):
        self.f = f
        self.x0 = x0
        self.interval = [t0, te] = interval
        self.grid = linspace(t0, te, N)
        self.h = (te - t0) / N

    def generate(self):
        ti, ui = self.grid[0], self.x0
        yield ti, ui
        for t in self.grid[1:]:
            ui = ui + self.h * self.step(self.f, ui, ti)
            ti = t
            yield ti, ui

    def solve(self):
        self.solution = array(list(self.generate()))

    def plot(self):
        plot(self.solution[:, 0], self.solution[:, 1])

    def step(self, f, u, t):
        raise NotImplementedError()</pre>
<p>This abstract class, with its methods, is used as a template for the individual methods:</p>
<pre>class ExplicitEuler(OneStepMethod):
    def step(self, f, u, t):
        return f(u, t)

class MidPointRule(OneStepMethod):
    def step(self, f, u, t):
        return f(u + self.h / 2 * f(u, t), t + self.h / 2)</pre>
<p>Note that in the class definitions, the name of the abstract class that we used as a template, <kbd>OneStepMethod</kbd>, is given as an extra argument:</p>
<pre>class ExplicitEuler(OneStepMethod)</pre>
<p>That class is called the <strong>parent class</strong>. All methods and attributes of the parent class are inherited by the subclasses as long as they are not overridden. They are overridden if they are redefined in the subclass. The <span>method</span> <kbd>step</kbd> <span>is redefined in the subclasses, while the</span> <span>method</span> <kbd>generate</kbd> <span>is generic for the entire family and therefore inherited from the parent.</span></p>
<p>Before considering further details, we will demonstrate how these three classes can be used:</p>
<pre>def f(x, t):
    return -0.5 * x

euler = ExplicitEuler(f, 15., [0., 10.], 20)
euler.solve()
euler.plot()
hold(True)
midpoint = MidPointRule(f, 15., [0., 10.], 20)

midpoint.solve()
midpoint.plot()</pre>
<p>You can avoid the repetition of common parameter lists by using the star operator (see <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.2.5</a>: <em>Variable number of arguments</em> for more details):</p>
<pre>...
argument_list = [f, 15., [0., 10.], 20]
euler = ExplicitEuler(*argument_list)
...
midpoint = MidPointRule(*argument_list)
...</pre>
<p>Note that the abstract class has never been used to create an instance. As the <span>method</span> <kbd>step</kbd> <span>was not completely defined, calling it raises an exception of type</span> <kbd>NotImplementedError</kbd><span>.</span></p>
<p>Sometimes you have to access the methods or attributes of a parent class. This is done using the command <kbd>super</kbd>. This is useful when the child class uses its own <kbd>__init__</kbd> method in order to extend the parent’s <kbd>__init__</kbd> method.</p>
<p>For example, let's assume that we want to give every solver class a string variable with the solver’s name. To this end, we provide the solver with an <kbd>__init__</kbd> method as it overrides the parent's <kbd>__init__</kbd> method. In the case that both methods should be used, we have to refer to the parent’s method by the command <kbd>super</kbd>:</p>
<pre>class ExplicitEuler(OneStepMethod):
    def __init__(self,*args, **kwargs):
        self.name='Explicit Euler Method'
        super(ExplicitEuler, self).__init__(*args,**kwargs)
    def step(self, f, u, t):
        return f(u, t)</pre>
<p>Note, you could have used the name of the parent class explicitly. The use of <kbd>super</kbd> instead allows us to change the name of the parent class without having to change all the references to the parent class.</p>
<h1 id="uuid-f6d742bf-9356-4cd5-8a21-5b00a2c03001">8.6 Encapsulation</h1>
<p>Sometimes the use of inheritance is impractical or even impossible. This motivates the use of encapsulation.</p>
<p>We will explain the concept of encapsulation by considering Python functions, that is, objects of the Python type <kbd>function</kbd>, which we encapsulate in a new class, <kbd>Function</kbd>, and provide with some relevant methods:</p>
<pre>class Function:
    def __init__(self, f):
        self.f = f
    def __call__(self, x):
        return self.f(x)
    def __add__(self, g):
        def sum(x):
            return self(x) + g(x)
        return type(self)(sum) 
    def __mul__(self, g): 
        def prod(x):
            return self.f(x) * g(x)
        return type(self)(prod)
    def __radd__(self, g):
        return self + g
    def __rmul__(self, g):
        return self * g</pre>
<p>Note that the <span>operations</span> <kbd>__add__</kbd> <span>and</span> <kbd>__mul__</kbd> <span>should return an instance of the same class. This is achieved by the statement</span> <kbd>return type(self)(sum)</kbd><span>, which in this case is a more general form of writing</span> <kbd>return Function(sum)</kbd><span>. We can now derive subclasses by inheritance.</span></p>
<p>Consider as an example Chebyshev polynomials. They can be computed in the interval <sub><img class="fm-editor-equation" src="assets/542ff6cb-5696-4556-a905-85fbabbafda1.png" style="width:3.00em;height:1.33em;"/></sub> by:</p>
<p class="CDPAlignCenter CDPAlign"><sub><img class="fm-editor-equation" src="assets/5213e4fc-3a20-4de8-a6af-a7bad2fa8e97.png" style="width:11.33em;height:1.33em;"/></sub></p>
<p>We construct a Chebyshev polynomial as an instance of the class <kbd>Function</kbd>:</p>
<pre>T5 = Function(lambda x: cos(5 * arccos(x)))
T6 = Function(lambda x: cos(6 * arccos(x)))</pre>
<p>Chebyshev polynomials are orthogonal in the sense:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5828d012-2424-4a0c-9c78-6055184edd76.png" style="width:19.67em;height:3.08em;"/></div>
<p>This can easily be checked using this construction:</p>
<pre>import scipy.integrate as sci

weight = Function(lambda x: 1 / sqrt((1 - x ** 2)))
[integral, errorestimate] = \
        sci.quad(weight * T5 * T6, -1, 1) <br/># (6.510878470473995e-17, 1.3237018925525037e-14)</pre>
<p>Without encapsulation, multiplying functions as simply as writing <kbd>weight * T5 * T6</kbd> would not have been possible.</p>
<h1 id="uuid-c29def1e-0f88-4670-9fcb-487d51022255">8.7 Classes as decorators</h1>
<p>In <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.8</a>: <em>Function as decorators</em><span>,</span> we saw how functions can be modified by applying another function as a decorator. In <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.1.5</a>: <em>Special methods</em>, we saw how classes can be made to behave as functions as long as they are provided with the method <kbd>__call__</kbd>. We will use this here to show how classes can be used as decorators.</p>
<p>Let's assume that we want to change the behavior of some functions in such a way that before the function is invoked, all input parameters are printed. This could be useful for debugging purposes. We take this situation as an example to explain the use of a decorator class:</p>
<pre>class echo:
    text = 'Input parameters of {name}\n'+\
        'Positional parameters {args}\n'+\
        'Keyword parameters {kwargs}\n'
    def __init__(self, f):
        self.f = f
    def __call__(self, *args, **kwargs):
        print(self.text.format(name = self.f.__name__,
              args = args, kwargs = kwargs))
        return self.f(*args, **kwargs)</pre>
<p>We use this class to decorate function definitions:</p>
<pre>@echo
def line(m, b, x):
    return m * x + b</pre>
<p>Then, call the function as usual:</p>
<pre>line(2., 5., 3.)
line(2., 5., x=3.)</pre>
<p>On the second call, we obtain the following output:</p>
<pre>Input parameters of line
Positional parameters (2.0, 5.0)
Keyword parameters {'x': 3.0}

11.0</pre>
<p>This example shows that both classes and functions can be used as decorators. Classes allow more possibilities, as they can be used to collect data as well.</p>
<p>Indeed, we observe that:</p>
<ul>
<li>Every decorated function creates a new instance of the decorator class.</li>
<li>Data collected by one instance can be saved and made accessible to another instance by class attributes; see <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.4</a>: <em>Class</em> <em>attributes and class methods</em>.</li>
</ul>
<p>The last point emphasizes the difference between function decorators. We show this now with a decorator that counts function calls and stores the result in a dictionary with the function as the key.</p>
<p>In order to analyze the performance of algorithms, it might be useful to count the calls of particular functions. We can get counter information without changing the function definition:</p>
<pre>class CountCalls:
    """
    Decorator that keeps track of the number of times 
    a function is called.
    """
    instances = {} 
    def __init__(self, f):
        self.f = f
        self.numcalls = 0
        self.instances[f] = self
    def __call__(self, *args, **kwargs):
        self.numcalls += 1
        return self.f(*args, **kwargs)
    @classmethod
    def counts(cls):
        """
        Return a dict of {function: # of calls} for all 
        registered functions.
        """
        return dict([(f.__name__, cls.instances[f].numcalls) 
                                    for f in cls.instances])</pre>
<p>Here, we use the class attribute <kbd>CountCalls.instances</kbd> to store the counters for each individual instance.</p>
<p>Let's see how this decorator works:</p>
<pre>@CountCalls
def line(m, b, x):
    return m * x + b
@CountCalls 
def parabola(a, b, c, x):_
    return a * x ** 2 + b * x + c
line(3., -1., 1.)
parabola(4., 5., -1., 2.)
 
CountCalls.counts() # returns {'line': 1, 'parabola': 1}
parabola.numcalls # returns 1</pre>
<h1 id="uuid-a8088c3c-69b0-4d14-9b4b-cb1dfa49414c">8.8 Summary</h1>
<p>One of the most important programming concepts in modern computer science is object-oriented programming. We learned in this chapter how to define objects as instances of classes, which we provide with methods and attributes. The first parameter of methods, usually denoted by <kbd>self</kbd>, plays an important and special role. You saw methods that can be used to define basic operations <span>for your own classes</span> such as <kbd>+</kbd> and <kbd>*</kbd>.</p>
<p>While in other programming languages attributes and methods can be protected against unintended use, Python allows a technique to hide attributes and access these hidden attributes through special getter and setter methods. To this end, you met an important function, <kbd>property</kbd>.</p>
<h1 id="uuid-9901c03d-19b4-40bd-93b9-e0f7158e12fd">8.9 Exercises</h1>
<ol>
<li>Write a method simplify to the class <kbd>RationalNumber</kbd>. This method should return the simplified version of the fraction as a tuple.</li>
<li>To provide results with confidence intervals, a special calculus, so-called interval arithmetic, is introduced in numerical mathematics. Define a class called <kbd>Interval</kbd> and provide it with methods for addition, subtraction, division, multiplication, and power (with positive integers only). These operations obey the following rules:</li>
</ol>
<div style="padding-left: 60px" class="CDPAlignLeft CDPAlign">  <img src="assets/f6b0c186-7c26-4084-8b79-d623f4f52a86.png" style="width:39.00em;height:8.50em;"/></div>
<p style="padding-left: 60px">Provide this class with methods that allow operations of the type <kbd>a + I, a I, I + a, I a</kbd>, where <kbd>I</kbd> is an interval and <kbd>a</kbd> <span>is</span> an integer or float. Convert an integer or float into an interval <kbd>[a,a]</kbd> first. (Hint: you may want to use function decorators for this; see <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section</a> <span>7.8:</span> <em>Function as decorators</em>.) Furthermore, implement the <span>method</span> <kbd>__contains__</kbd><span>, which enables you to check whether a given number belongs to the interval using the syntax</span> <kbd>x in I</kbd> <span>for an object</span> <kbd>I</kbd> <span>of type <kbd>Interval</kbd>. Test your class by applying a polynomial</span> <kbd>f=lambda x: 25*x**2-4*x+1</kbd> <span>to an interval.</span></p>
<ol start="3">
<li>Consider the example in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.7</a>: <em>Classes as decorators</em>. Extend this example to obtain a <em>function decorator</em> that counts how often a certain function is called; <span>see also</span> <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section</a> <span>7.8:</span> <em>Functions as decorators.</em></li>
<li>Compare the two ways to implement a method for reverse addition <kbd>__radd__</kbd> in the class <kbd>RationalNumber</kbd>: the one given in the example in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.1.5</a>: <em>Special methods</em> and the one given here:</li>
</ol>
<pre style="padding-left: 60px">class RationalNumber:
    ....
    def __radd__(self, other):
        return other + self</pre>
<p style="padding-left: 60px">Do you expect an error in this version? What is the error and how do you explain it? Test your answer by executing:</p>
<pre style="padding-left: 60px">q = RationalNumber(10, 15)
5 + q</pre>
<ol start="5">
<li>Consider the <span>decorator class</span> <kbd>CountCalls</kbd> as in the example in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml"/><a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml"/><a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.7</a>: <em>Classes as decorators</em>. Provide this class with a method, <kbd>reset</kbd>, that sets the counters of all functions in the dictionary <kbd>CountCalls.instances</kbd> to <kbd>0</kbd>. What would happen if the dictionary were replaced by an empty dictionary instead?</li>
</ol>


            </article>

            
        </section>
    </body></html>