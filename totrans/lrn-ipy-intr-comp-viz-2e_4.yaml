- en: Chapter 4. Interactive Plotting and Graphical Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will show the graphical capabilities of Python and how they
    can be used interactively with IPython.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy provides a very efficient way of dealing with large amounts of data structured
    as multidimensional arrays. But looking at grids of numbers is often much less
    intuitive than looking at plots, such as curves, scatter plots, images, and likewise.
    Matplotlib is a particularly rich Python package for generating high-quality figures
    from NumPy data. It provides a simple, high-level interface much similar to Matlab,
    a commercial product that is popular in the engineering and scientific worlds.
    Matplotlib integrates very well with IPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also introduce **Graphical User Interface** (**GUI)** programming.
    Covering this rich subject extensively is far beyond the scope of this book. So
    we will only see basic examples in this chapter. We will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting figures with Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image processing techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geographical maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Graphical User Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing and debugging GUIs with IPython's event loop integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figures with Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of Python packages for curve plotting, but the most widely used
    one, by far, is Matplotlib. It is one of the most complete and powerful graphical
    libraries. It can be used both for interactive visualization and for generating
    high-quality figures that can be readily used in scientific publications. In addition,
    its high-level interface makes it particularly easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show some of the possibilities offered by Matplotlib
    as well as how it can be advantageously used with IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up IPython for interactive visualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython implements a loop integration system that allows to display graphical
    windows from the command-line interface without blocking the console. This is
    very useful when using Matplotlib or when creating graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using Matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Figures can be displayed interactively in IPython using event loop integration.
    Then, they can be updated dynamically from the command-line interface. The `%pylab`
    magic command (or the `--pylab` option to the `ipython` shell command) activates
    this integration automatically. It is possible to choose the backend renderer
    used for Matplotlib and IPython, for example, `--pylab qt`, which requires PyQt
    or PySide.
  prefs: []
  type: TYPE_NORMAL
- en: We will assume that the `%pylab` mode is active in IPython throughout this chapter.
    When using Matplotlib from a script instead from IPython, we can put the `from
    pylab import *` command at the top of the script. In a Python module, it might
    be a better idea to use `import matplotlib.pyplot as plt` so that the Matplotlib
    objects stay within their namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the way of generating plots is slightly different in a script compared
    to IPython. In a script, the figure is displayed only when the function `show()`
    is called, typically, at the very end of the script, whereas, in the IPython command-line
    interface, the figure is shown and updated at each plot function.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When showing a figure with Matplotlib, the window contains a few buttons for
    navigating interactively within the figure (panning and zooming) and for changing
    the figure's options. There is also the possibility to save the figure in a bitmap
    or vector format.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib in the IPython notebook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matplotlib can also be used in the notebook. When launching the notebook with
    `ipython notebook --pylab inline`, the plots appear in the output cells as images
    and are saved as base64 strings within the IPYNB files. Without this inline option,
    figures are displayed in separate windows as usual. It is also possible to activate
    this option within the notebook by using the command `%pylab inline`.
  prefs: []
  type: TYPE_NORMAL
- en: Standard plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will see some examples of standard plots, such as lines,
    curves, scatter plots, and bar plots. In the next sections, we will also see images
    and maps. But Matplotlib offers far more plot types than what we will cover here,
    including 3D plots, geometrical shapes, vector fields, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Curves
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawing a curve with Matplotlib actually means drawing small, successive line
    segments that give the illusion of a smooth curve when the number of lines is
    large enough. To plot a mathematical function, one plots samples of this function
    within a given interval just as NumPy represents functions as arrays with sampled
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a time-dependent signal can be represented as a one-dimensional
    vector of sampled values at regular time intervals (for example, every 1 millisecond
    at a 1 kHz sampling frequency), such that one second of signal is represented
    as a 1000-unit long vector. The function `plot` can be used to draw this signal
    on the screen, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Curves](img/9932_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting a white noise signal in a notebook
  prefs: []
  type: TYPE_NORMAL
- en: Here, we generate a vector with random values following independent normal random
    variables. The resulting signal is a so-called white noise signal, a random signal
    with a flat power spectral density. When plotting the figure in the notebook with
    the `--pylab inline` option, Matplotlib generates an image representing this curve,
    and the image is then automatically inserted in the output cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `plot` function receives a single vector as an argument, it assumes
    that this vector contains values on the y axis, whereas values on the x axis are
    automatically generated as integers from `0` to `len(y) - 1`. To explicitly specify
    the values on the x axis, we can use the following command: `plot(x,y)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Scatter plots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scatter plots represent sets of points in two dimensions, using pixels or any
    other marker. Let''s continue with our cities example. Assuming we are in the
    right directory (the `citiesdata` alias), we can load the data and try to plot
    the geographical coordinates of all the cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Scatter plots](img/9932_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying the cities' coordinates in the notebook
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we plot the latitude (y axis) versus the longitude (x axis)
    of all the cities. The third argument (`','`) of the `plot` function specifies
    the marker type. Here, it corresponds to a scatter plot where each city is represented
    by a single pixel. We can easily recognize the shape of the continents even if
    they seem a bit distorted. This is because we plot the geographical coordinates
    in a Cartesian system, whereas it would be more appropriate to use a map projection
    method. We will get back to this issue later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Bar graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A bar graph is typically used for histograms, representing the distribution
    of values at different intervals. The `hist` function in Matplotlib accepts a
    vector of values and plots a histogram. The `bins` keyword allows to specify either
    the number of bins or the list of bins.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s plot the histogram of the nodes'' degrees in the Facebook
    graph example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Bar graphs](img/9932_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Distribution of the nodes' degrees in a graph
  prefs: []
  type: TYPE_NORMAL
- en: Here, `g.degree()` is a dictionary with the degree of each node (that is, the
    number of other nodes connected to it). The `values` method returns the list of
    all the degrees.
  prefs: []
  type: TYPE_NORMAL
- en: There are far more graph types in Matplotlib than what we showed here, and the
    plotting possibilities are nearly endless. A wide variety of figure examples can
    be found in the Matplotlib Gallery on the official website ([http://matplotlib.org/gallery.html](http://matplotlib.org/gallery.html))
    and in Nicolas Rougier's tutorial ([http://www.loria.fr/~rougier/teaching/matplotlib/](http://www.loria.fr/~rougier/teaching/matplotlib/)).
  prefs: []
  type: TYPE_NORMAL
- en: Plot customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib offers a lot of customization options. Here, we will see how to change
    styles and colors in figures, how to configure axes and legends, and how to display
    several plots on the same figure.
  prefs: []
  type: TYPE_NORMAL
- en: Styles and colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, curves are continuous and have a uniform color. The style and color
    of the curves can easily be specified in the `plot` function.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument of the `plot` function specifies the style and color of the
    curve in a short syntax. For example, '`-r`' means "continuous and red" while
    '`--g`' means "dashed and green". There are dozens of possible styles such as,
    `':'` for dotted lines, `'-.'` for dash-dot, `'.'` for points, `','` for pixels,
    `'o'` for circle markers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are eight colors with a single-character shortcut, namely `b`, `g`,
    and `r` (primary additive colors—blue, greed, and red); `c`, `m`, and `y` (secondary
    additive colors—cyan, magenta, and yellow); and `k` and `w` (black and white).
    Any other color can be specified by its hexadecimal code, RGB or RGBA tuple (values
    between `0` and `1`), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using a string for specifying the style and color is only a shortcut to the
    more general way of specifying styles and colors of plots, which is to use particular
    keyword arguments. These arguments include `linestyle` (or `ls`), `linewidth`
    (or `lw`), `marker`, `markerfacecolor` (or `mfc`), `markersize` (or `ms`), and
    so on. The full list of options can be found in the reference documentation of
    Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, when displaying several plots on the same figure, the color of each plot
    cycles through a predefined set of colors, such as blue, green, red, and so on.
    This cycle can be customized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Customizing Matplotlib**'
  prefs: []
  type: TYPE_NORMAL
- en: '`rcParams` is a global, dictionary-like variable in Matplotlib with custom
    parameters. Nearly every aspect of Matplotlib can be configured here. Also, it
    is possible to specify permanent custom options by saving them in an ASCII text
    file called `matplotlibrc`, which can be stored either in the current directory
    (for local options) or in `~/.matplotlib` (for global options). In this file,
    each line contains a custom parameter, for example, `axes.color_cycle: [''r'',
    ''k'', ''c'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: Grid, axes, and legends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A graph would not convey anything useful about the data without legends and
    axes. By default, Matplotlib displays axes and ticks automatically. The exact
    positions of the ticks can be set with `xticks` and `yticks`, and a grid can be
    added with the `grid` function. The extent of the x and y coordinates can be specified
    with `xlim` and `ylim`. The axes labels can be set with `xlabel` and `ylabel`.
    Also, it is possible to specify the legend with the `legend` keyword; the label
    of each line corresponds to the `label` keyword argument of the `plot` function.
    Finally, the `title` command displays the name of the figure. The following example
    illustrates how to use these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grid, axes, and legends](img/9932_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sine and cosine functions with axes and legends
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Superposition of plots**'
  prefs: []
  type: TYPE_NORMAL
- en: Calling different plot functions updates the same figure in Matplotlib. This
    is how several plots can be shown on the same figure. To create a new figure in
    a new window, we need to call the function figure(). Finally, it is possible to
    display several independent figures within the same window using subplots, as
    we will see later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction from IPython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating Matplotlib figures with the IPython console using event loop integration
    allows to interact with them programmatically. It is possible to add new plots
    in a figure or to update it in real time, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We first create a figure with two white noise signals (the `plot` function
    displays every column as an independent curve). Once the window with the figure
    has opened, we can return to the IPython console without closing that window.
    The output `Out[1]` contains a list of `Line2D` objects. Indeed, Matplotlib uses
    an object-oriented description of the figure. Let''s retrieve the first object
    (corresponding to the first curve) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Tab completion on the `line` variable then shows the list of methods that we
    can use to update the figure. For instance, to change the line color from blue
    to red, we can type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The figure is then updated accordingly. It may be necessary to force refresh
    the figure, for example, by panning or zooming.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's mention the **Edit** button in the figure window that offers
    a GUI for updating some figures' properties.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing multiple plots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiple independent plots can be displayed on the same figure. We can define
    a grid with an arbitrary number of rows and columns and plot figures inside each
    box. Boxes can even span several rows or columns (using `subplot2grid`). For instance,
    the following example shows how to plot two figures with different coordinate
    systems side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Drawing multiple plots](img/9932_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cartesian and polar plots in the same figure
  prefs: []
  type: TYPE_NORMAL
- en: The `subplot` function simultaneously specifies how many columns (first argument)
    and rows (second argument) there are, but also the index of the box where the
    plot will be rendered (third argument, 1-based indexing, from left to right and
    top to bottom). The `polar=True` keyword argument specifies that the second subplot
    contains a polar graph. The `polar` function is similar to the `plot` function,
    but a polar coordinate system containing the attributes theta, and r is used where
    theta is the angle and r is the radius.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced figures and graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show more advanced graphical features offered by Matplotlib
    that are related to images and maps. We will also take a look at a few other graphical
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Image processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A colored N x M image can be represented as an N x M x 3 NumPy array corresponding
    to three N x M matrices for the red, green, and blue channels. Image processing
    algorithms can then be implemented efficiently with NumPy and SciPy and visualized
    with Matplotlib. In addition, the PIL package (Python Imaging Library) implements
    basic image processing routines for pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matplotlib's `imread` function opens a PNG image from the hard drive and returns
    an N x M x 3 (or N x M x 4 if there is an alpha transparency channel) NumPy array.
    It can also read other formats if PIL is installed. PIL also offers the `open`
    function for reading images in any format (BMP, GIF, JPEG, TIFF, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we download a PNG image from a remote URL and load
    it with `imread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `imread` function accepts either an image filename or a Python file-like
    object (like here, where we use the buffer returned by `urlopen`). The object
    returned by the `imread` function is a three-dimensional NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use PIL for reading images. We can either use `Image.open` to open
    an image file directly, or we can convert a NumPy array into a PIL image with
    the `Image.fromarray` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `fromarray` function accepts an array with unsigned 8-bit integers, with
    values between `0` and `255`. This is the reason why we need to convert the NumPy
    array with floating point values to the required data type. Conversely, to convert
    a PIL image into a NumPy array, we can use the `array` function `im = array(img)`.
  prefs: []
  type: TYPE_NORMAL
- en: Showing images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `imshow` function of Matplotlib displays an image from a NumPy array, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Showing images](img/9932_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying an image in the notebook with Matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'The `imshow` function also accepts two-dimensional NumPy arrays (grayscale
    images). The mapping from scalar values between `0` and `1` to actual pixel colors
    can be specified with the color map. A color map is a linear gradient of colors
    defining the color of any value between `0` and `1`. A lot of predefined color
    maps are available in Matplotlib, and the full list can be found here: [http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps](http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps)'
  prefs: []
  type: TYPE_NORMAL
- en: To specify the color map in `imshow`, we can use the `cmap=get_cmap(name)` keyword
    argument, where name is the color map's name.
  prefs: []
  type: TYPE_NORMAL
- en: Using PIL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Basic image processing routines, such as rotate, crop, filtering, copy and
    paste, geometrical transforms, and likewise, are provided by PIL. For example,
    to rotate an image, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Using PIL](img/9932_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rotating an image with PIL
  prefs: []
  type: TYPE_NORMAL
- en: Here, we rotate the image 45 degrees counterclockwise, and we convert back the
    image from PIL to NumPy to display it.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced image processing – color quantization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PIL provides basic image processing functions, whereas SciPy can be used for
    more advanced algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we will show a small example of an advanced image processing algorithm
    called color quantization. The principle of this algorithm is to reduce the number
    of colors of an image while keeping most of the visual structure of the image.
    In this example, we will implement this algorithm with the `scipy.cluster` package.
    We will use the k-means algorithm to group the color values into a small number
    of clusters, and we will assign each pixel to its group''s color. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We only take the red channel and flatten the image with the `ravel` function
    so as to treat all pixels equally (that is, we get a one-dimensional vector instead
    of a two-dimensional matrix). Then, the `kmeans` function finds the clusters in
    the color space and returns the centroid colors. Finally, the `vq` function assigns
    each pixel to its centroid index, and we retrieve the resulting image clustered
    through fancy indexing of the centroid indices (in `qnt`) by the centroid colors
    (`centroids`). Since the output of this algorithm is a grayscale image, we need
    to specify a color map. We will use a set of colors that had its heyday some time
    ago, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Advanced image processing – color quantization](img/9932_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Color quantization with SciPy
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `ListedColormap` function creates a custom color map with a discrete
    set of colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can save the resulting image as a PNG file with Matplotlib''s `imsave`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are a complex but important type of figure. The basemap toolkit (which
    needs to be installed separately) brings geographical capabilities to Matplotlib.
    It is highly powerful, and we will only scratch the surface in this section. Specifically,
    we will continue with our cities example to plot a human density map on a planisphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we retrieve the locations and populations of the cities as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize a world map by specifying the projection type and map boundaries
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of different ways of projecting the surface of the earth on
    a plane, and the choice of one projection or another depends on the specific application.
    Here, we use the Miller cylindrical projection. The other keyword arguments give
    the latitude and longitude of the lower-left and upper-right corners.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to generate a two-dimensional image with the world population
    density. To do this, we will need to project the geographical coordinates of the
    cities on our map, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the function `m(long,lat)` allows to get the `(x,y)` coordinates of
    the geographical positions with longitudes and latitudes. To generate the density
    map, we will also need the coordinates of the map boundaries, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s generate the density map. We will use the `histogram2d` function,
    which returns a two-dimensional histogram from a set of points. Here, each point
    corresponds to a city. We will also use a weight for each city, which corresponds
    to its population. Care must be taken for cities that do not have a population;
    we will set the weight to `1000` for these cities, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `h` variable contains the population count in every small rectangle
    of a 500 x 500 grid spanning the whole planisphere. To generate a density map,
    we can apply a Gaussian filter to `log(h)` (corresponding to a kind of kernel
    density estimation) using SciPy. Using the logarithm can be useful when the values
    span several orders of magnitude. We also need to take care of zeros (corresponding
    to empty zones) because the logarithm of zero is undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The filter is applied to the function `log(h.T)` because the coordinate system
    of the `h` variable is transposed compared to the coordinate system of the map.
    Also, we use a filtering value of `1` here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we display the density map as well as the coast lines, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Maps](img/9932_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: World map with population density using Matplotlib.basemap
  prefs: []
  type: TYPE_NORMAL
- en: 3D plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matplotlib includes a 3D toolkit called `mplot3d` that can be used for basic
    3D plots, such as 3D curves, surface plots, and likewise. As an example, let''s
    create a surface plot. We first need to import the `mplot3d` toolkit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the x, y, and z coordinates of a surface plot with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The NumPy function `meshgrid` returns the coordinates of all the points in
    a grid that spans a rectangle area defined by the `X` and `Y` vectors. Finally,
    we create a 3D canvas and draw the surface plot as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The Matplotlib function `gca` returns the current axis instance, and we specify
    here that this instance should use 3D projection. In the `plot_surface` function,
    the `rstride` and `cstride` keyword arguments give the row and column strides
    of the surface, whereas `cmap` is the color map and `linewidth` is the width of
    the wireframe. The following screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![3D plots](img/9932_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A surface plot with mplot3D
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib is capable of creating animations and exporting them as MP4 videos
    using FFmpeg or MEncoder. The idea is to create a plot and write a function to
    update it at regular time intervals. The documentation of the animation module
    can be found at [http://matplotlib.org/api/animation_api.html](http://matplotlib.org/api/animation_api.html).
    Besides this, a tutorial made by Jake Vanderplas is available at [http://jakevdp.github.com/blog/2012/08/18/matplotlib-animation-tutorial/](http://jakevdp.github.com/blog/2012/08/18/matplotlib-animation-tutorial/).
  prefs: []
  type: TYPE_NORMAL
- en: Other visualization packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matplotlib is not the only visualization package in Python. Here are other
    similar libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chaco**: This is an alternative library to Matplotlib ([http://code.enthought.com/chaco/](http://code.enthought.com/chaco/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyQwt**: This is a plotting library based on PyQt ([http://pyqwt.sourceforge.net/](http://pyqwt.sourceforge.net/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyQtGraph**: This package is also based on PyQt and offers 2D and 3D plotting
    features ([http://www.pyqtgraph.org/](http://www.pyqtgraph.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visvis**: This package is based on OpenGL; it offers an object-oriented plotting
    interface ([http://code.google.com/p/visvis/](http://code.google.com/p/visvis/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mayavi**: This package offers 3D interactive visualization features, such
    as curves, surfaces, meshes, volume rendering, and likewise ([http://code.enthought.com/projects/mayavi/](http://code.enthought.com/projects/mayavi/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyOpenGL**: This Python library gives raw access to the popular OpenGL library;
    it offers low-level, hardware-accelerated 2D/3D graphics capabilities ([http://pyopengl.sourceforge.net/](http://pyopengl.sourceforge.net/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Galry**: This is a high-performance interactive visualization package based
    on PyOpenGL that targets very large datasets with tens or even hundreds of millions
    of points ([http://rossant.github.com/galry/](http://rossant.github.com/galry/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical User Interfaces (GUI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when human-computer interaction was only done through a command-line
    interface. Today, most regular computer users are much more confident with a mouse
    and graphical windows than with a keyboard and black screen with a blinking cursor.
    For this reason, any developer may be asked at some point to write a graphical
    interface, even the simplest possible, so as to let non-developer users interact
    comfortably with the program.
  prefs: []
  type: TYPE_NORMAL
- en: A GUI can easily be integrated in any Python package. There are numerous graphical
    toolkits for Python, most of them being wrappers to native or C++ graphical libraries.
    Famous toolkits include Qt, wxWidgets, Tkinter, GTK, and so on. We will use Qt
    in this book's examples.
  prefs: []
  type: TYPE_NORMAL
- en: GUI programming can be a hard subject, requiring in-depth knowledge of low-level
    details about the operating system, multithreading programming, as well as some
    basic notions about human-computer interactions. In this book, we will show a
    "Hello World" example that gives the very basics of PyQt. We will also see how
    GUIs can be manipulated interactively with IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up IPython for interactive GUIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython implements a loop integration system that allows the display of graphical
    windows from the command-line interface without blocking the console. This is
    very useful when creating GUIs because it becomes possible to interact with the
    windows dynamically from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The `%gui` magic command activates the event loop integration. We need to provide
    the name of the graphical library to use. The possible names are `wx`, `qt`, `gtk`,
    and `tk`. Here we will work with Qt. So we can type `%gui qt`. The main Qt application
    is then automatically started in IPython. Another possibility is to launch IPython
    with `ipython --gui qt`.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section require either PyQt4 or PySide. We will assume
    that PyQt4 is installed, but, if only PySide is installed, it will only be a matter
    of replacing `PyQt4` with `PySide` in the imports. The Qt binding API provided
    by both libraries is nearly identical.
  prefs: []
  type: TYPE_NORMAL
- en: A "Hello World" example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this "Hello World" example, we will show a window with a button triggering
    a message box. We will also show how to interact with the window from the IPython
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a window, we need to create a class that is derived from the `QWidget`
    base class. `QWidget` is the base class of all Qt windows and controls, also called
    widgets. Here is the code of the "Hello World" example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the work happens in the `HelloWorld` widget''s constructor. We first
    need to call the parent constructor. Then, we perform several steps to display
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: We first create a button, as in the instance of the `QPushButton` class. The
    first argument is the text of the button, and the second one is the parent widget's
    instance (`self`). Every specific control and widget is defined by a class that
    is derived from the `QWidget` base class and can be found in the `QtGui` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the callback method that is called when the user clicks on the button.
    The `clicked` attribute is a Qt signal emitted as soon as the user clicks on the
    button. We connect this signal to the `clicked` method (called a slot) of our
    `HelloWorld` widget. Signals and slots are Qt's way of making different widgets
    communicate with each other. Signals are raised when some events occur, and slots
    connected to these signals are called whenever the signals are raised. Any widget
    contains a lot of predefined signals. Custom signals can also be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need to put the newly created button somewhere on the window. We first
    need to create a `QVBoxLayout` widget, which is a container widget containing
    a vertical stack of widgets. Here we only put the button in it, using the `addWidget`
    method. We also specify that this box is the window's layout. In this way, the
    main window contains this box that itself contains our button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to show the window with the command `self.show()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `clicked` method, we create a `QMessageBox` widget representing, by default,
    a dialog with a text and single **OK** button. The `setText` method specifies
    the text, and the `show` method displays the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now assuming that the event loop integration with Qt has been activated in
    IPython either with `%gui qt` or `ipython --gui qt`, we can display the window
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The window then appears, and the IPython console is still usable while the window
    is open.
  prefs: []
  type: TYPE_NORMAL
- en: '![A "Hello World" example](img/9932_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A basic Qt dialog
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the button shows a dialog containing **Hello World**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can interact with the window dynamically from the IPython console.
    For example, the following command displays the Hello World dialog exactly as
    if we had clicked on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This feature is particularly convenient when designing a complex window and
    for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the graphical possibilities offered by IPython,
    Matplotlib, and a few other packages. We can create plots, charts, histograms,
    maps, display and process images, graphical user interfaces, and so on. Figures
    can also be integrated very easily in a notebook. All aspects of the figures can
    be customized. These reasons explain why these tools are quite popular in the
    scientific and engineering communities, where data visualization plays a central
    role in most applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see some techniques to make Python code faster.
  prefs: []
  type: TYPE_NORMAL
