<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Journey from Statistics to Machine Learning</h1>
                </header>
            
            <article>
                
<p>In recent times, <strong>machine learning</strong> (<strong>ML</strong>) and data science have gained popularity like never before. This field is expected to grow exponentially in the coming years. First of all, what is machine learning? And why does someone need to take pains to understand the principles? Well, we have the answers for you. One simple example could be book recommendations in e-commerce websites when someone went to search for a particular book or any other product recommendations which were bought together to provide an idea to users which they might like. Sounds magic, right? In fact, utilizing machine learning can achieve much more than this.</p>
<p>Machine learning is a branch of study in which a model can learn automatically from the experiences based on data without exclusively being modeled like in statistical models. Over a period and with more data, model predictions will become better.</p>
<p class="mce-root"/>
<p>In this first chapter, we will introduce the basic concepts which are necessary to understand statistical learning and create a foundation for full-time statisticians or software engineers who would like to understand the statistical workings behind the ML methods. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistical terminology for model building and validation</h1>
                </header>
            
            <article>
                
<p>Statistics is the branch of mathematics dealing with the collection, analysis, interpretation, presentation, and organization of numerical data.</p>
<p class="mce-root"/>
<p>Statistics are mainly classified into two subbranches:</p>
<ul>
<li><strong>Descriptive statistics</strong>: These are used to summarize data, such as the mean, standard deviation for continuous data types (such as age), whereas frequency and percentage are useful for categorical data (such as gender).</li>
<li><strong>Inferential statistics</strong>: Many times, a collection of the entire data (also known as population in statistical methodology) is impossible, hence a subset of the data points is collected, also called a sample, and conclusions about the entire population will be drawn, which is known as inferential statistics. Inferences are drawn using hypothesis testing, the estimation of numerical characteristics, the correlation of relationships within data, and so on.</li>
</ul>
<p>Statistical modeling is applying statistics on data to find underlying hidden relationships by analyzing the significance of the variables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Machine learning</h1>
                </header>
            
            <article>
                
<p>Machine learning is the branch of computer science that utilizes past experience to learn from and use its knowledge to make future decisions. Machine learning is at the intersection of computer science, engineering, and statistics. The goal of machine learning is to generalize a detectable pattern or to create an unknown rule from given examples. An overview of machine learning landscape is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/cd3cfb9c-7c4e-41f8-90df-92e537e1d0b4.png" style="width:24.92em;height:21.17em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Machine learning is broadly classified into three categories but nonetheless, based on the situation, these categories can be combined to achieve the desired results for particular applications:</p>
<ul>
<li><strong>Supervised learning</strong>: This is teaching machines to learn the relationship between other variables and a target variable, similar to the way in which a teacher provides feedback to students on their performance. The major segments within supervised learning are as follows:
<ul>
<li>Classification problem</li>
<li>Regression problem</li>
</ul>
</li>
<li><strong>Unsupervised learning</strong>: In unsupervised learning, algorithms learn by themselves without any supervision or without any target variable provided. It is a question of finding hidden patterns and relations in the given data. The categories in unsupervised learning are as follows:
<ul>
<li>Dimensionality reduction</li>
<li>Clustering</li>
</ul>
</li>
<li><strong>Reinforcement learning</strong>: This allows the machine or agent to learn its behavior based on feedback from the environment. In reinforcement learning, the agent takes a series of decisive actions without supervision and, in the end, a reward will be given, either +1 or -1. Based on the final payoff/reward, the agent reevaluates its paths. Reinforcement learning problems are closer to the artificial intelligence methodology rather than frequently used machine learning algorithms.</li>
</ul>
<p>In some cases, we initially perform unsupervised learning to reduce the dimensions followed by supervised learning when the number of variables is very high. Similarly, in some artificial intelligence applications, supervised learning combined with reinforcement learning could be utilized for solving a problem; an example is self-driving cars in which, initially, images are converted to some numeric format using supervised learning and combined with driving actions (left, forward, right, and backward).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statistical fundamentals and terminology for model building and validation</h1>
                </header>
            
            <article>
                
<p>Statistics itself is a vast subject on which a complete book could be written; however, here the attempt is to focus on key concepts that are very much necessary with respect to the machine learning perspective. In this section, a few fundamentals are covered and the remaining concepts will be covered in later chapters wherever it is necessary to understand the statistical equivalents of machine learning.</p>
<p>Predictive analytics depends on one major assumption: that history repeats itself!</p>
<p>By fitting a predictive model on historical data after validating key measures, the same model will be utilized for predicting future events based on the same explanatory variables that were significant on past data.</p>
<p>The first movers of statistical model implementers were the banking and pharmaceutical industries; over a period, analytics expanded to other industries as well.</p>
<p>Statistical models are a class of mathematical models that are usually specified by mathematical equations that relate one or more variables to approximate reality. Assumptions embodied by statistical models describe a set of probability distributions, which distinguishes it from non-statistical, mathematical, or machine learning models</p>
<p>Statistical models always start with some underlying assumptions for which all the variables should hold, then the performance provided by the model is statistically significant. Hence, knowing the various bits and pieces involved in all building blocks provides a strong foundation for being a successful statistician.</p>
<p>In the following section, we have described various fundamentals with relevant codes:</p>
<ul>
<li><strong>Population</strong>: This is the totality, the complete list of observations, or all the data points about the subject under study.</li>
<li><strong>Sample</strong>: A sample is a subset of a population, usually a small portion of the population that is being analyzed.</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/4f5a4037-baaf-46dc-abbc-7ca06fa0275e.png" style="width:28.25em;height:12.08em;"/></div>
<div class="packt_infobox">Usually, it is expensive to perform an analysis of an entire population; hence, most statistical methods are about drawing conclusions about a population by analyzing a sample.</div>
<ul>
<li><strong>Parameter versus statistic</strong>: Any measure that is calculated on the population is a parameter, whereas on a sample it is called a <strong>statistic</strong>.</li>
<li><strong>Mean</strong>: This is a simple arithmetic average, which is computed by taking the aggregated sum of values divided by a count of those values. The mean is sensitive to outliers in the data. An outlier is the value of a set or column that is highly deviant from the many other values in the same data; it usually has very high or low values.</li>
<li><strong>Median</strong>: This is the midpoint of the data, and is calculated by either arranging it in ascending or descending order. If there are <em>N</em> observations.</li>
<li><strong>Mode</strong>: This is the most repetitive data point in the data:</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/2315b4ff-1753-4cb4-86da-5ad2f981ed0c.png" style="width:36.83em;height:15.50em;"/></div>
<p style="padding-left: 90px">The Python code for the calculation of mean, median, and mode using a <kbd>numpy</kbd> array and the <kbd>stats</kbd> package is as follows:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; import numpy as np 
&gt;&gt;&gt; from scipy import stats 
 
&gt;&gt;&gt; data = np.array([4,5,1,2,7,2,6,9,3]) 
 
# Calculate Mean 
&gt;&gt;&gt; dt_mean = np.mean(data) ; print ("Mean :",round(dt_mean,2)) 
 
# Calculate Median 
&gt;&gt;&gt; dt_median = np.median(data) ; print ("Median :",dt_median)          
 
# Calculate Mode 
&gt;&gt;&gt; dt_mode =  stats.mode(data); print ("Mode :",dt_mode[0][0])   </strong>                 </pre>
<p style="padding-left: 90px">The output of the preceding code is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/ff428ca6-bb72-432a-9a86-8bc6aa661437.png" style="width:14.83em;height:6.83em;"/></div>
<div class="packt_infobox">We have used a NumPy array instead of a basic list as the data structure; the reason behind using this is the <kbd>scikit-learn</kbd> package built on top of NumPy array in which all statistical models and machine learning algorithms have been built on NumPy array itself. The <kbd>mode</kbd> function is not implemented in the <kbd>numpy</kbd> package, hence we have used SciPy's <kbd>stats</kbd> package. SciPy is also built on top of NumPy arrays.</div>
<p style="padding-left: 90px">The R code for descriptive statistics (mean, median, and mode) is given as follows:</p>
<pre style="padding-left: 90px"><strong>data &lt;- c(4,5,1,2,7,2,6,9,3) 
dt_mean = mean(data) ; print(round(dt_mean,2)) 
dt_median = median (data); print (dt_median) 
 
func_mode &lt;- function (input_dt) { 
  unq &lt;- unique(input_dt)  unq[which.max(tabulate(match(input_dt,unq)))] 
} 
 
dt_mode = func_mode (data); print (dt_mode)</strong> </pre>
<div class="packt_tip">We have used the default <kbd>stats</kbd> package for R; however, the <kbd>mode</kbd> function was not built-in, hence we have written custom code for calculating the mode.</div>
<ul>
<li><strong>Measure of variation</strong>: Dispersion is the variation in the data, and measures the inconsistencies in the value of variables in the data. Dispersion actually provides an idea about the spread rather than central values.</li>
<li><strong>Range</strong>: This is the difference between the maximum and minimum of the value.</li>
<li><strong>Variance</strong>: This is the mean of squared deviations from the mean (<em>xi</em> = data points, <em>µ</em> = mean of the data, <em>N</em> = number of data points). The dimension of variance is the square of the actual values. The reason to use denominator <em>N-1</em> for a sample instead of <em>N</em> in the population is due the degree of freedom. <em>1</em> degree of freedom lost in a sample by the time of calculating variance is due to extraction of substitution of sample:</li>
</ul>
<div style="padding-left: 90px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/665ab16b-6862-42cf-808b-a87f2ca40793.jpg" style="width:35.33em;height:4.17em;"/></div>
<ul>
<li><strong>Standard deviation</strong>: This is the square root of variance. By applying the square root on variance, we measure the dispersion with respect to the original variable rather than square of the dimension:</li>
</ul>
<div style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/7dde7512-4ce1-4567-b2d9-482b6808f36d.jpg" style="width:46.67em;height:5.17em;"/></div>
<ul>
<li><strong>Quantiles</strong>: These are simply identical fragments of the data. Quantiles cover percentiles, deciles, quartiles, and so on. These measures are calculated after arranging the data in ascending order:
<ul>
<li><strong>Percentile</strong>: This is nothing but the percentage of data points below the value of the original whole data. The median is the 50<sup>th</sup> percentile, as the number of data points below the median is about 50 percent of the data.</li>
<li><strong>Decile</strong>: This is 10th percentile, which means the number of data points below the decile is 10 percent of the whole data.</li>
<li><strong>Quartile</strong>: This is one-fourth of the data, and also is the 25<sup>th</sup> percentile. The first quartile is 25 percent of the data, the second quartile is 50 percent of the data, the third quartile is 75 percent of the data. The second quartile is also known as the median or 50<sup>th</sup> percentile or 5<sup>th</sup> decile.</li>
<li><strong>Interquartile range</strong>: This is the difference between the third quartile and first quartile. It is effective in identifying outliers in data. The interquartile range describes the middle 50 percent of the data points.</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img style="text-align: center;font-size: 1em;width:28.33em;height:28.67em;" class="image-border" src="assets/fb60b3ef-c652-4d4d-ae6a-d0af8bd62c50.png"/></div>
<p style="padding-left: 90px">The Python code is as follows:</p>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; from statistics import variance, stdev 
&gt;&gt;&gt; game_points = np.array([35,56,43,59,63,79,35,41,64,43,93,60,77,24,82]) 
 
# Calculate Variance 
&gt;&gt;&gt; dt_var = variance(game_points) ; print ("Sample variance:", round(dt_var,2)) 
 
# Calculate Standard Deviation 
&gt;&gt;&gt; dt_std = stdev(game_points) ; print ("Sample std.dev:", round(dt_std,2)) 
                
# Calculate Range 
&gt;&gt;&gt; dt_rng = np.max(game_points,axis=0) - np.min(game_points,axis=0) ; print ("Range:",dt_rng) 
 
#Calculate percentiles 
&gt;&gt;&gt; print ("Quantiles:") 
&gt;&gt;&gt; for val in [20,80,100]: 
&gt;&gt;&gt;      dt_qntls = np.percentile(game_points,val)  
&gt;&gt;&gt;      print (str(val)+"%" ,dt_qntls) 
                                 
# Calculate IQR                             
&gt;&gt;&gt; q75, q25 = np.percentile(game_points, [75 ,25]); print ("Inter quartile range:",q75-q25)</strong> </pre>
<p style="padding-left: 60px">The output of the preceding code is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/2848dd9a-30f9-4873-80ea-e5fa6e2cd316.png" style="width:16.92em;height:13.33em;"/></div>
<p style="padding-left: 60px">The R code for dispersion (variance, standard deviation, range, quantiles, and IQR) is as follows:</p>
<pre style="padding-left: 60px"><strong>game_points &lt;- c(35,56,43,59,63,79,35,41,64,43,93,60,77,24,82) 
dt_var = var(game_points); print(round(dt_var,2)) 
dt_std = sd(game_points); print(round(dt_std,2)) 
range_val&lt;-function(x) return(diff(range(x)))  
dt_range = range_val(game_points); print(dt_range) 
dt_quantile = quantile(game_points,probs = c(0.2,0.8,1.0)); print(dt_quantile) 
dt_iqr = IQR(game_points); print(dt_iqr)</strong> </pre>
<ul>
<li><strong>Hypothesis testing</strong>: This is the process of making inferences about the overall population by conducting some statistical tests on a sample. Null and alternate hypotheses are ways to validate whether an assumption is statistically significant or not.</li>
<li><strong>P-value</strong>: The probability of obtaining a test statistic result is at least as extreme as the one that was actually observed, assuming that the null hypothesis is true (usually in modeling, against each independent variable, a p-value less than 0.05 is considered significant and greater than 0.05 is considered insignificant; nonetheless, these values and definitions may change with respect to context).</li>
</ul>
<p style="padding-left: 90px">The steps involved in hypothesis testing are as follows:</p>
<ol>
<li style="list-style-type: none">
<ol>
<li>Assume a null hypothesis (usually no difference, no significance, and so on; a null hypothesis always tries to assume that there is no anomaly pattern and is always homogeneous, and so on).</li>
<li>Collect the sample.</li>
<li>Calculate test statistics from the sample in order to verify whether the hypothesis is statistically significant or not.</li>
<li>Decide either to accept or reject the null hypothesis based on the test statistic.</li>
</ol>
</li>
</ol>
<ul>
<li><strong>Example of hypothesis testing</strong>: A chocolate manufacturer who is also your friend claims that all chocolates produced from his factory weigh at least 1,000 g and you have got a funny feeling that it might not be true; you both collected a sample of 30 chocolates and found that the average chocolate weight as 990 g with sample standard deviation as 12.5 g. Given the 0.05 significance level, can we reject the claim made by your friend?</li>
</ul>
<p style="padding-left: 90px">The null hypothesis is that <em>µ0 ≥ 1000</em> (all chocolates weigh more than 1,000 g).</p>
<p style="padding-left: 90px">Collected sample:</p>
<div style="padding-left: 180px" class="CDPAlignLeft CDPAlign"><img src="assets/40b90cd1-fdcf-48bb-80e3-ccda20c33970.jpg" style="width:12.17em;height:1.33em;"/></div>
<p style="padding-left: 90px">Calculate test statistic:</p>
<div style="padding-left: 240px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/e89db8ab-0abd-46df-aa50-039728e8e5b5.jpg" style="width:5.92em;height:4.25em;"/></div>
<p class="CDPAlignCenter CDPAlign"><em>t = (990 - 1000) / (12.5/sqrt(30)) = - 4.3818</em></p>
<p class="CDPAlignCenter CDPAlign"><em>Critical t value from t tables = t0.05, 30 = 1.699 =&gt; - t0.05, 30 = -1.699</em></p>
<p class="CDPAlignCenter CDPAlign"><em>P-value = 7.03 e-05</em></p>
<p style="padding-left: 90px">Test statistic is <em>-4.3818</em>, which is less than the critical value of <em>-1.699</em>. Hence, we can reject the null hypothesis (your friend's claim) that the mean weight of a chocolate is above 1,000 g.</p>
<p style="padding-left: 90px">Also, another way of deciding the claim is by using the p-value. A p-value less than <em>0.05</em> means both claimed values and distribution mean values are significantly different, hence we can reject the null hypothesis:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/ebd0304a-1571-449d-b6fc-8545dedea197.png"/></div>
<p style="padding-left: 90px">The Python code is as follows:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; from scipy import stats  
&gt;&gt;&gt; xbar = 990; mu0 = 1000; s = 12.5; n = 30 
 
# Test Statistic 
&gt;&gt;&gt; t_smple  = (xbar-mu0)/(s/np.sqrt(float(n))); print ("Test Statistic:",round(t_smple,2)) 
 
# Critical value from t-table 
&gt;&gt;&gt; alpha = 0.05 
&gt;&gt;&gt; t_alpha = stats.t.ppf(alpha,n-1); print ("Critical value from t-table:",round(t_alpha,3))           
 
#Lower tail p-value from t-table                          
&gt;&gt;&gt; p_val = stats.t.sf(np.abs(t_smple), n-1); print ("Lower tail p-value from t-table", p_val) </strong> </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/aebd860b-f4d1-4fa4-bafe-b75f259358be.png"/></div>
<p style="padding-left: 60px">The R code for T-distribution is as follows:</p>
<pre style="padding-left: 60px"><strong>xbar = 990; mu0 = 1000; s = 12.5 ; n = 30 
t_smple = (xbar - mu0)/(s/sqrt(n));print (round(t_smple,2)) 
 
alpha = 0.05 
t_alpha = qt(alpha,df= n-1);print (round(t_alpha,3)) 
 
p_val = pt(t_smple,df = n-1);print (p_val)</strong> </pre>
<ul>
<li><strong>Type I and II error</strong>: Hypothesis testing is usually done on the samples rather than the entire population, due to the practical constraints of available resources to collect all the available data. However, performing inferences about the population from samples comes with its own costs, such as rejecting good results or accepting false results, not to mention separately, when increases in sample size lead to minimizing type I and II errors:
<ul>
<li><strong>Type I error</strong>: Rejecting a null hypothesis when it is true</li>
<li><strong>Type II error</strong>: Accepting a null hypothesis when it is false</li>
</ul>
</li>
<li><strong>Normal distribution</strong>: This is very important in statistics because of the central limit theorem, which states that the population of all possible samples of size <em>n</em> from a population with mean <em>μ</em> and variance <em>σ2</em> approaches a normal distribution:</li>
</ul>
<div style="padding-left: 180px" class="CDPAlignLeft CDPAlign"><img src="assets/55e41132-9bf5-4b7f-8ffe-e063b04aca3a.jpg" style="width:24.17em;height:4.17em;"/></div>
<p style="padding-left: 90px">Example: Assume that the test scores of an entrance exam fit a normal distribution. Furthermore, the mean test score is <em>52</em> and the standard deviation is <em>16.3</em>. What is the percentage of students scoring <em>67</em> or more in the exam?</p>
<div style="padding-left: 180px" class="CDPAlignLeft CDPAlign"><img src="assets/a880eec5-7560-4eba-8ecb-5db9e49fad60.jpg" style="width:24.42em;height:3.33em;"/></div>
<div style="padding-left: 180px" class="CDPAlignLeft CDPAlign"><img src="assets/181df08e-7eb1-452f-8863-a376b6d609f0.jpg" style="width:21.67em;height:3.67em;"/></div>
<div style="padding-left: 150px" class="CDPAlignLeft CDPAlign"><img src="assets/35c16a2d-06da-4cec-976f-32821be8de32.jpg" style="width:31.25em;height:2.00em;"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/63b78d64-5416-47bc-aa66-dd469c152037.png"/></div>
<p style="padding-left: 90px">The Python code is as follows:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; from scipy import stats 
&gt;&gt;&gt; xbar = 67; mu0 = 52; s = 16.3 
 
# Calculating z-score 
&gt;&gt;&gt; z = (67-52)/16.3  
 
# Calculating probability under the curve     
&gt;&gt;&gt; p_val = 1- stats.norm.cdf(z) 
&gt;&gt;&gt; print ("Prob. to score more than 67 is ",round(p_val*100,2),"%")</strong> </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/134ae03f-464d-4b0c-8fe1-ffad35402bbc.png" style="width:26.42em;height:4.50em;"/></div>
<p style="padding-left: 90px">The R code for normal distribution is as follows:</p>
<pre style="padding-left: 90px"><strong>xbar = 67; mu0 = 52; s = 16.3 
pr = 1- pnorm(67, mean=52, sd=16.3) 
print(paste("Prob. to score more than 67 is ",round(pr*100,2),"%"))</strong> </pre>
<ul>
<li><strong>Chi-square</strong>: This test of independence is one of the most basic and common hypothesis tests in the statistical analysis of categorical data. Given two categorical random variables <em>X</em> and <em>Y</em>, the chi-square test of independence determines whether or not there exists a statistical dependence between them.</li>
</ul>
<p style="padding-left: 90px">The test is usually performed by calculating <em>χ2</em> from the data and <em>χ2</em> with (<em>m-1</em>, <em>n-1</em>) degrees from the table. A decision is made as to whether both variables are independent based on the actual value and table value, whichever is higher:</p>
<div style="padding-left: 120px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/61bdd5ec-a242-4aaa-826b-b92bb925bb75.jpg" style="width:27.67em;height:4.50em;"/></div>
<p style="padding-left: 90px">Example: In the following table, calculate whether the smoking habit has an impact on exercise behavior:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/758dda66-0370-42d3-8dc7-77d5b4cf377b.png" style="width:34.08em;height:18.08em;"/></div>
<p style="padding-left: 90px" class="mce-root">The Python code is as follows:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; import pandas as pd 
&gt;&gt;&gt; from scipy import stats 
 
&gt;&gt;&gt; survey = pd.read_csv("survey.csv")   
 
# Tabulating 2 variables with row &amp; column variables respectively 
&gt;&gt;&gt; survey_tab = pd.crosstab(survey.Smoke, survey.Exer, margins = True)</strong> </pre>
<p style="padding-left: 90px">While creating a table using the <kbd>crosstab</kbd> function, we will obtain both row and column totals field extra. However, in order to create the observed table, we need to extract the variables part and ignore the totals:</p>
<pre style="padding-left: 90px"><strong># Creating observed table for analysis 
&gt;&gt;&gt; observed = survey_tab.ix[0:4,0:3] </strong> </pre>
<p style="padding-left: 90px">The <kbd>chi2_contingency</kbd> function in the stats package uses the observed table and subsequently calculates its expected table, followed by calculating the p-value in order to check whether two variables are dependent or not. If <em>p-value &lt; 0.05</em>, there is a strong dependency between two variables, whereas if <em>p-value &gt; 0.05</em>, there is no dependency between the variables:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; contg = stats.chi2_contingency(observed= observed) 
&gt;&gt;&gt; p_value = round(contg[1],3) 
&gt;&gt;&gt; print ("P-value is: ",p_value)</strong> </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" src="assets/81c1bb9d-6ac4-4958-a2ce-a0c1c14db08d.png" style="width:12.17em;height:3.83em;"/></div>
<p style="padding-left: 90px">The p-value is <kbd>0.483</kbd>, which means there is no dependency between the smoking habit and exercise behavior.</p>
<p style="padding-left: 90px">The R code for chi-square is as follows:</p>
<pre style="padding-left: 90px"><strong>survey = read.csv("survey.csv",header=TRUE) 
tbl = table(survey$Smoke,survey$Exer) 
p_val = chisq.test(tbl)</strong> </pre>
<ul>
<li><strong>ANOVA</strong>: Analyzing variance tests the hypothesis that the means of two or more populations are equal. ANOVAs assess the importance of one or more factors by comparing the response variable means at the different factor levels. The null hypothesis states that all population means are equal while the alternative hypothesis states that at least one is different.</li>
</ul>
<p style="padding-left: 90px">Example: A fertilizer company developed three new types of universal fertilizers after research that can be utilized to grow any type of crop. In order to find out whether all three have a similar crop yield, they randomly chose six crop types in the study. In accordance with the randomized block design, each crop type will be tested with all three types of fertilizer separately. The following table represents the yield in g/m<sup>2</sup>. At the 0.05 level of significance, test whether the mean yields for the three new types of fertilizers are all equal:</p>
<table style="border-collapse: collapse;width: 50%" class="ListTable3-Accent51" border="1">
<tbody>
<tr>
<td>
<p><strong>Fertilizer 1</strong></p>
</td>
<td>
<p><strong>Fertilizer 2</strong></p>
</td>
<td>
<p><strong>Fertilizer 3</strong></p>
</td>
</tr>
<tr>
<td>
<p>62</p>
</td>
<td>
<p>54</p>
</td>
<td>
<p>48</p>
</td>
</tr>
<tr>
<td>
<p>62</p>
</td>
<td>
<p>56</p>
</td>
<td>
<p>62</p>
</td>
</tr>
<tr>
<td>
<p>90</p>
</td>
<td>
<p>58</p>
</td>
<td>
<p>92</p>
</td>
</tr>
<tr>
<td>
<p>42</p>
</td>
<td>
<p>36</p>
</td>
<td>
<p>96</p>
</td>
</tr>
<tr>
<td>
<p>84</p>
</td>
<td>
<p>72</p>
</td>
<td>
<p>92</p>
</td>
</tr>
<tr>
<td>
<p>64</p>
</td>
<td>
<p>34</p>
</td>
<td>
<p>80</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p style="padding-left: 90px" class="mce-root">The Python code is as follows:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; import pandas as pd 
&gt;&gt;&gt; from scipy import stats 
&gt;&gt;&gt; fetilizers = pd.read_csv("fetilizers.csv")</strong> </pre>
<p style="padding-left: 90px">Calculating one-way ANOVA using the <kbd>stats</kbd> package:</p>
<pre style="padding-left: 90px"><strong>&gt;&gt;&gt; one_way_anova = stats.f_oneway(fetilizers["fertilizer1"], fetilizers["fertilizer2"], fetilizers["fertilizer3"]) 
 
&gt;&gt;&gt; print ("Statistic :", round(one_way_anova[0],2),", p-value :",round(one_way_anova[1],3))</strong> </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/e1fd826b-4729-42e4-8f49-9586be23466a.png"/></div>
<p style="padding-left: 90px">Result: The p-value did come as less than 0.05, hence we can reject the null hypothesis that the mean crop yields of the fertilizers are equal. Fertilizers make a significant difference to crops.</p>
<p style="padding-left: 90px">The R code for ANOVA is as follows:</p>
<pre style="padding-left: 90px"><strong>fetilizers = read.csv("fetilizers.csv",header=TRUE) 
r = c(t(as.matrix(fetilizers))) 
f = c("fertilizer1","fertilizer2","fertilizer3") 
k = 3; n = 6 
tm = gl(k,1,n*k,factor(f)) 
blk = gl(n,k,k*n) 
av = aov(r ~ tm + blk) 
smry = summary(av)</strong> </pre>
<ul>
<li><strong>Confusion matrix</strong>: This is the matrix of the actual versus the predicted. This concept is better explained with the example of cancer prediction using the model:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/be777195-6394-4f75-9cc7-02fb8e685c51.png" style="width:38.17em;height:12.25em;"/></div>
<p style="padding-left: 60px">Some terms used in a confusion matrix are:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>True positives (TPs)</strong>: True positives are cases when we predict the disease as yes when the patient actually does have the disease.</li>
<li><strong>True negatives (TNs)</strong>: Cases when we predict the disease as no when the patient actually does not have the disease.</li>
<li><strong>False positives (FPs)</strong>: When we predict the disease as yes when the patient actually does not have the disease. FPs are also considered to be type I errors.</li>
<li><strong>False negatives (FNs)</strong>: When we predict the disease as no when the patient actually does have the disease. FNs are also considered to be type II errors.</li>
<li><strong>Precision (P)</strong>: When yes is predicted, how often is it correct?</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><em>(TP/TP+FP)</em></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Recall (R)/sensitivity/true positive rate</strong>: Among the actual yeses, what fraction was predicted as yes?</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><em>(TP/TP+FN)</em></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>F1 score (F1)</strong>: This is the harmonic mean of the precision and recall. Multiplying the constant of <em>2</em> scales the score to <em>1</em> when both precision and recall are <em>1</em>:</li>
</ul>
</li>
</ul>
<div style="padding-left: 180px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/052349b8-7696-4423-8d90-ba8360b45a48.jpg" style="width:18.42em;height:4.75em;"/></div>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Specificity</strong>: Among the actual nos, what fraction was predicted as no? Also equivalent to <em>1- false positive rate</em>:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><em>(TN/TN+FP)</em></p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Area under curve (ROC)</strong>: Receiver operating characteristic curve is used to plot between <strong>true positive rate</strong> (<strong>TPR</strong>) and <strong>false positive rate</strong> (<strong>FPR</strong>), also known as a sensitivity and <em>1- specificity</em> graph:</li>
</ul>
</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img style="text-align: center;font-size: 1em;width:23.08em;height:23.92em;" class=" image-border" src="assets/a535dde5-2180-46dc-a48e-f8071ba4fa37.png"/></div>
<p style="padding-left: 150px">Area under curve is utilized for setting the threshold of cut-off probability to classify the predicted probability into various classes.</p>
<ul>
<li><strong>Observation and performance window</strong>: In statistical modeling, the model tries to predict the event in advance rather than at the moment, so that some buffer time will exist to work on corrective actions. For example, a question from a credit card company would be, for example, what is the probability that a particular customer will default in the coming 12-month period? So that I can call him and offer any discounts or develop my collection strategies accordingly.</li>
</ul>
<p style="padding-left: 90px">In order to answer this question, a probability of default model (or behavioral scorecard in technical terms) needs to be developed by using independent variables from the past 24 months and a dependent variable from the next 12 months. After preparing data with <em>X</em> and <em>Y</em> variables, it will be split into 70 percent - 30 percent as train and test data randomly; this method is called <strong>in-time validation</strong> as both train and test samples are from the same time period:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/07d2d04a-8f13-4c95-b486-36baed358cfa.png" style="width:33.50em;height:13.25em;"/></div>
<ul>
<li><strong>In-time and out-of-time validation</strong>: In-time validation implies obtaining both a training and testing dataset from the same period of time, whereas out-of-time validation implies training and testing datasets drawn from different time periods. Usually, the model performs worse in out-of-time validation rather than in-time due to the obvious reason that the characteristics of the train and test datasets might differ.</li>
<li><strong>R-squared (coefficient of determination)</strong>: This is the measure of the percentage of the response variable variation that is explained by a model. It also a measure of how well the model minimizes error compared with just utilizing the mean as an estimate. In some extreme cases, R-squared can have a value less than zero also, which means the predicted values from the model perform worse than just taking the simple mean as a prediction for all the observations. </li>
</ul>
<div style="padding-left: 60px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/b2793a7e-a64a-402b-8e71-7c3e214c21fe.jpg" style="width:43.00em;height:4.33em;"/></div>
<div style="padding-left: 240px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/0a9b0de7-29d5-4f21-9372-829ddfac3f3b.jpg" style="width:7.83em;height:3.50em;"/></div>
<ul>
<li><strong>Adjusted R-squared</strong>: The explanation of the adjusted R-squared statistic is almost the same as R-squared but it penalizes the R-squared value if extra variables without a strong correlation are included in the model:</li>
</ul>
<div style="padding-left: 180px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/12581e1d-5f7c-4914-9bc0-590e0828ba2d.jpg" style="width:15.33em;height:3.67em;"/></div>
<p style="padding-left: 90px">Here, <em>R2</em> = sample R-squared value, <em>n</em> = sample size, <em>k</em> = number of predictors (or) variables.</p>
<p style="padding-left: 90px">Adjusted R-squared value is the key metric in evaluating the quality of linear regressions. Any linear regression model having the value of <em>R2 adjusted &gt;= 0.7</em> is considered as a good enough model to implement.</p>
<p style="padding-left: 90px">Example: The R-squared value of a sample is <em>0.5,</em> with a sample size of <em>50</em> and the independent variables are <em>10</em> in number. Calculated adjusted R-squared:</p>
<div style="padding-left: 180px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/375aa180-1432-49e9-99b9-50601db2292c.jpg" style="width:20.17em;height:3.83em;"/></div>
<ul>
<li><strong>Maximum likelihood estimate (MLE)</strong>: This is estimating the parameter values of a statistical model (logistic regression, to be precise) by finding the parameter values that maximize the likelihood of making the observations. </li>
<li><strong>Akaike information criteria (AIC)</strong>: This is used in logistic regression, which is similar to the principle of adjusted R-square for linear regression. It measures the relative quality of a model for a given set of data:</li>
</ul>
<div style="padding-left: 210px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/69ac9b5d-5caa-45f1-9dcf-f7897ad171b1.jpg" style="width:13.00em;height:2.00em;"/></div>
<p style="padding-left: 90px">Here, <em>k</em> = number of predictors or variables</p>
<p style="padding-left: 90px">The idea of AIC is to penalize the objective function if extra variables without strong predictive abilities are included in the model. This is a kind of regularization in logistic regression.</p>
<ul>
<li><strong>Entropy</strong>: This comes from information theory and is the measure of impurity in the data. If the sample is completely homogeneous, the entropy is zero and if the sample is equally divided, it has an entropy of <em>1</em>. In decision trees, the predictor with the most heterogeneousness will be considered nearest to the root node to classify given data into classes in a greedy mode. We will cover this topic in more depth in <a href="2fe96fbc-0c1d-437c-bad5-03dc13df3281.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Tree-Based Machine Learning Models</em>:</li>
</ul>
<div style="padding-left: 150px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/909ab57f-71a9-4e0a-9f88-2d936cc536e3.jpg" style="width:22.25em;height:2.33em;"/></div>
<p style="padding-left: 90px">Here, <em>n</em> = number of classes. Entropy is maximal at the middle, with the value of <em>1</em> and minimal at the extremes as <em>0</em>. A low value of entropy is desirable as it will segregate classes better:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2461a422-4f06-48e4-8075-7223267a0864.png" style="width:32.25em;height:18.83em;"/></div>
<p style="padding-left: 90px">Example: Given two types of coin in which the first one is a fair one (<em>1/2</em> head and <em>1/2</em> tail probabilities) and the other is a biased one (<em>1/3</em> head and <em>2/3</em> tail probabilities), calculate the entropy for both and justify which one is better with respect to modeling:</p>
<div style="padding-left: 120px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/54d91887-6f9b-4b17-9a61-55e9f37fe3ed.jpg" style="width:31.92em;height:3.42em;"/></div>
<div style="padding-left: 120px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/7b191a9d-a8da-47e8-98f8-1a5131f375ff.jpg" style="width:34.33em;height:3.17em;"/></div>
<p style="padding-left: 90px">From both values, the decision tree algorithm chooses the biased coin rather than the fair coin as an observation splitter due to the fact the value of entropy is less.</p>
<ul>
<li><strong>Information gain</strong>: This is the expected reduction in entropy caused by partitioning the examples according to a given attribute. The idea is to start with mixed classes and to keep partitioning until each node reaches its observations of the purest class. At every stage, the variable with maximum information gain is chosen in greedy fashion:</li>
</ul>
<p class="mce-root CDPAlignCenter CDPAlign"><em>Information gain = Entropy of parent - sum (weighted % * Entropy of child)</em></p>
<p class="CDPAlignCenter CDPAlign"><em>Weighted % = Number of observations in particular child / sum (observations in all child nodes)</em></p>
<ul>
<li><strong>Gini</strong>: Gini impurity is a measure of misclassification, which applies in a multiclass classifier context. Gini works almost the same as entropy, except Gini is faster to calculate:</li>
</ul>
<div style="padding-left: 240px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/f7e865a6-52ab-4fe2-84ac-7bc69f4affad.jpg" style="width:9.67em;height:3.67em;"/></div>
<p style="padding-left: 90px">Here, <em>i</em> = number of classes. The similarity between Gini and entropy is shown as follows:</p>
<div style="padding-left: 120px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/be9e2a95-e9e1-4ea4-bcd2-d8bbf2e4c50e.png" style="width:29.42em;height:22.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bias versus variance trade-off</h1>
                </header>
            
            <article>
                
<p>Every model has both bias and variance error components in addition to white noise. Bias and variance are inversely related to each other; while trying to reduce one component, the other component of the model will increase. The true art lies in creating a good fit by balancing both. The ideal model will have both low bias and low variance.</p>
<p>Errors from the bias component come from erroneous assumptions in the underlying learning algorithm. High bias can cause an algorithm to miss the relevant relations between features and target outputs; this phenomenon causes an underfitting problem.</p>
<p>On the other hand, errors from the variance component come from sensitivity to change in the fit of the model, even a small change in training data; high variance can cause an overfitting problem:</p>
<div style="padding-left: 90px" class="mce-root CDPAlignLeft CDPAlign"><img src="assets/7c7502ec-b60d-4891-abb8-d9f530bc61f2.jpg" style="width:31.58em;height:3.50em;"/></div>
<p>An example of a high bias model is logistic or linear regression, in which the fit of the model is merely a straight line and may have a high error component due to the fact that a linear model could not approximate underlying data well.</p>
<p>An example of a high variance model is a decision tree, in which the model may create a wiggly curve as a fit, in which even a small change in training data will cause a drastic change in the fit of the curve.</p>
<p>At the moment, state-of-the-art models are utilizing high variance models such as decision trees and performing ensemble on top of them to reduce the errors caused by high variance and at the same time not compromising on increases in errors due to the bias component. The best example of this category is random forest, in which many decision trees will be grown independently and ensemble in order to come up with the best fit; we will cover this in upcoming chapters:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/1656ae24-5704-4e83-94dd-f0c7d83d6443.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Train and test data</h1>
                </header>
            
            <article>
                
<p>In practice, data usually will be split randomly 70-30 or 80-20 into train and test datasets respectively in statistical modeling, in which training data utilized for building the model and its effectiveness will be checked on test data:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/376bde10-df3d-45dc-afa8-3f27cd56fd5c.png" style="width:27.67em;height:13.17em;"/></div>
<p>In the following code, we split the original data into train and test data by 70 percent - 30 percent. An important point to consider here is that we set the seed values for random numbers in order to repeat the random sampling every time we create the same observations in training and testing data. Repeatability is very much needed in order to reproduce the results:</p>
<pre><strong># Train &amp; Test split 
&gt;&gt;&gt; import pandas as pd       
&gt;&gt;&gt; from sklearn.model_selection import train_test_split 
 
&gt;&gt;&gt; original_data = pd.read_csv("mtcars.csv")     </strong> </pre>
<p>In the following code, <kbd>train size</kbd> is <kbd>0.7</kbd>, which means 70 percent of the data should be split into the training dataset and the remaining 30% should be in the testing dataset. Random state is seed in this process of generating pseudo-random numbers, which makes the results reproducible by splitting the exact same observations while running every time:</p>
<pre><strong>&gt;&gt;&gt; train_data,test_data = train_test_split(original_data,train_size = 0.7,random_state=42)</strong> </pre>
<p>The R code for the train and test split for statistical modeling is as follows:</p>
<pre><strong>full_data = read.csv("mtcars.csv",header=TRUE) 
set.seed(123) 
numrow = nrow(full_data) 
trnind = sample(1:numrow,size = as.integer(0.7*numrow)) 
train_data = full_data[trnind,] 
test_data = full_data[-trnind,]</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have gained a high-level view of various basic building blocks and subcomponents involved in statistical modeling and machine learning, such as mean, variance, interquartile range, p-value, bias versus variance trade-off, AIC, Gini, the area under the curve, and so on with respect to the statistics context. </p>
<p><span>In the next chapter, we will be covering complete tree-based models such as decision trees, random forest, boosted trees, ensemble of models, and so on to improve accuracy!</span></p>


            </article>

            
        </section>
    </body></html>