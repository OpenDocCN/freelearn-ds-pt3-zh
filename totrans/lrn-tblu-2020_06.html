<html><head></head><body>
  <div id="_idContainer264">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-122" class="chapterTitle">Diving Deep with Table Calculations</h1>
    <p class="normal"><strong class="bold">Table calculations</strong> are one of the most powerful features in Tableau. They enable solutions that really couldn't be achieved any other way (short of writing a custom application or complex custom SQL scripts!). The features include the following:</p>
    <ul>
      <li class="list">They make it possible to use data that isn't structured well and still get quick results without waiting for someone to fix the data at the source.</li>
      <li class="list">They make it possible to compare and perform calculations on aggregate values across rows of the resulting table.</li>
      <li class="list">They open incredible possibilities for analysis and creative approaches to solving problems, highlighting insights, or improving the user experience.</li>
    </ul>
    <p class="normal">Table calculations range in complexity, from incredibly easy to create (a couple of clicks) to extremely complex (requiring an understanding of <strong class="bold">addressing</strong>, <strong class="bold">partitioning</strong>, and <strong class="bold">data densification</strong>, for example). We'll start off simple and move toward complexity in this chapter. The goal is to gain a solid foundation in creating and using table calculations, understanding how they work, and looking at some examples of how they can be used. We'll consider these topics:</p>
    <ul>
      <li class="list">An overview of table calculations</li>
      <li class="list">Quick table calculations</li>
      <li class="list">Scope and direction</li>
      <li class="list">Addressing and partitioning</li>
      <li class="list">Custom table calculations</li>
      <li class="list">Practical examples</li>
    </ul>
    <p class="normal">The examples in this chapter will return to the sample <code class="Code-In-Text--PACKT-">Superstore</code> data that we used in the first chapter. To follow along with the examples, use the <code class="Code-In-Text--PACKT-">Chapter 06 Starter.twbx</code> workbook.</p>
    <h1 id="_idParaDest-123" class="title">An overview of table calculations</h1>
    <p class="normal"><strong class="bold">Table calculations</strong> are different from<a id="_idIndexMarker539"/> all other calculations in Tableau. Row-level, aggregate calculations, and LOD expressions, which we explored in the previous chapters, are performed as part of the query to the data source. If you were to examine the queries sent to the data source by Tableau, you'd find the code for your calculations translated into whatever implementation of SQL the data source used.</p>
    <p class="normal">Table calculations, on the other hand, are performed after the initial query. Here's a diagram that demonstrates how aggregated results are stored in Tableau's cache:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.1: Table calculations are computed in Tableau's cache of aggregated data</p>
    <p class="normal">Table calculations are <a id="_idIndexMarker540"/>performed on the aggregate table of data in Tableau's cache right before the data visualization is rendered. As we'll see, this is important to understand for multiple reasons, including the following:</p>
    <ul>
      <li class="list"><strong class="bold">Aggregation</strong>: Table <a id="_idIndexMarker541"/>calculations operate on aggregate data. You cannot reference a field in a table calculation without referencing the field as an aggregate.</li>
      <li class="list"><strong class="bold">Filtering</strong>: Regular filters will <a id="_idIndexMarker542"/>be applied before table calculations. This means that table calculations will only be applied to data returned from the source to the cache. You'll need to avoid filtering any data necessary for the table calculation.</li>
      <li class="list"><strong class="bold">Table calculation filtering</strong> (sometimes called <strong class="bold">late filtering</strong>): Table calculations used as filters will be applied after<a id="_idIndexMarker543"/> the aggregate results are returned from the data source. The order is important: row-level and aggregate filters are applied first, the aggregate data is returned to the cache, and then the table calculation is applied as a filter that effectively hides data from the view. This allows some creative approaches to solving certain kinds of problems that we'll consider in some of the examples later in the chapter.</li>
      <li class="list"><strong class="bold">Performance</strong>: If you are<a id="_idIndexMarker544"/> using a live connection to an enterprise database server, then row-level and aggregate-level calculations will be taking advantage of enterprise-level hardware. Table calculations are performed in the cache, which means they will be performed on whatever machine is running Tableau. You will not likely need to be concerned if your table calculations are operating on a dozen or even hundreds of rows of aggregate data, or if you anticipate publishing to a powerful Tableau server. However, if you are getting back hundreds of thousands of rows of aggregate data on your local machine, then you'll need to consider the performance of your table calculations. At the same time, there are cases where table calculations might be used to avoid an expensive filter or calculation at the source.</li>
    </ul>
    <p class="normal">With this overview of table calculations in mind, let's jump into understanding some options for creating table calculations.</p>
    <h2 id="_idParaDest-124" class="title">Creating and editing table calculations</h2>
    <p class="normal">There are several ways to create<a id="_idIndexMarker545"/> table calculations in Tableau, including:</p>
    <ul>
      <li class="list">Using the drop-down <a id="_idIndexMarker546"/>menu for any active field used as a numeric aggregate in the view, select <strong class="screen-text">Quick Table Calculation</strong> and then the desired calculation type.</li>
      <li class="list">Using the drop-down menu for any active field that is used as a numeric aggregate in the view, select <strong class="screen-text">Add Table Calculation</strong>, then select the calculation type, and adjust any desired settings.</li>
      <li class="list">Creating a calculated field and using one or more table calculation functions to write your own custom table calculations.</li>
    </ul>
    <p class="normal">The first two options create a<a id="_idIndexMarker547"/> quick table calculation, which can be edited or removed using the drop-down menu on the field and selecting <strong class="screen-text">Edit Table Calculation...</strong> or <strong class="screen-text">Clear Table Calculation</strong>. The third option creates a calculated field, which can be edited or deleted like any other calculated field.</p>
    <p class="normal">A field on a shelf in the<a id="_idIndexMarker548"/> view that is using a table calculation, or which is a calculated field using table calculation functions, will have a delta symbol icon (<span class="mediaobject"><img src="../Images/B16021_06_001.png" style="height: 0.8em !important;" alt=""/></span>) visible, as follows.</p>
    <p class="normal">Following is a snippet of an active field<strong class="bold"> </strong>without a table calculation:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.2: An active field without a table calculation applied</p>
    <p class="normal">Following is the active field with a table calculation:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.3: An active field with a table calculation applied includes the delta symbol</p>
    <p class="normal">Most of the examples in this chapter will utilize text tables/cross tab reports as these most closely match the actual aggregate table in the cache. This makes it easier to see how the table calculations are working.</p>
    <div class="packt_tip">
      <p>Table calculations can be used in any type of visualization. However, when building a view that uses table calculations, especially more complex ones, try using a table with all dimensions on the <strong class="bold">Rows</strong> shelf and then adding table calculations as discrete values on <strong class="bold">Rows</strong> to the right of the dimensions. Once you have all the table calculations working as desired, you can rearrange the fields in the view to give you the appropriate visualization.</p>
    </div>
    <p class="normal">We'll now move from the concept of creating table calculations to some examples.</p>
    <h1 id="_idParaDest-125" class="title">Quick table calculations</h1>
    <p class="normal"><strong class="bold">Quick table calculations</strong> are predefined <a id="_idIndexMarker549"/>table calculations that can be applied to fields used as measures in the view. These calculations include common and useful calculations such as <strong class="screen-text">Running Total</strong>, <strong class="screen-text">Difference</strong>, <strong class="screen-text">Percent Difference</strong>, <strong class="screen-text">Percent of Total</strong>, <strong class="screen-text">Rank</strong>, <strong class="screen-text">Percentile</strong>, <strong class="screen-text">Moving Average</strong>, <strong class="screen-text">YTD Total</strong> (year-to-date total), <strong class="screen-text">Compound Growth Rate</strong>, <strong class="screen-text">Year over Year Growth</strong>, and <strong class="screen-text">YTD Growth</strong>. You'll find applicable options on the drop-down list on a field used as a measure in the view, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.4: Using the dropdown, you can create a quick table calculation from an aggregate field in the view</p>
    <p class="normal">Consider the following example using the sample <code class="Code-In-Text--PACKT-">Superstore Sales</code> data:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.5: The first SUM(Sales) field is a normal aggregate. The second has a quick table calculation of Running Total applied </p>
    <p class="normal">Here, <strong class="screen-text">Sales</strong> over time is shown. <strong class="screen-text">Sales</strong> has been placed on the <strong class="screen-text">Rows</strong> shelf twice and the second <strong class="screen-text">SUM(Sales)</strong> field has had the <strong class="bold">running total</strong> quick table calculation applied. Using the quick table calculation meant it was unnecessary to write any code.</p>
    <p class="normal">You can actually see the code that the quick table calculations uses by double-clicking the table calculation field in the view. This turns it into an ad hoc calculation. You can also drag an active field with a quick table calculation applied to the data pane, which will turn it into a calculated field that can be reused in other views.</p>
    <p class="normal">The following table demonstrates some of the quick table calculations:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.6: Sales in the first column is simply the SUM(Sales). The three additional columns show various table calculations applied (Running Sum, Difference, Rank)</p>
    <p class="normal">Although it is quite easy<a id="_idIndexMarker550"/> to create quick table calculations, it is essential to understand some fundamental concepts. We'll take a look at these next, starting with the difference between relative and fixed table calculations.</p>
    <h1 id="_idParaDest-126" class="title">Relative versus fixed</h1>
    <p class="normal">We'll look at the details<a id="_idIndexMarker551"/> shortly, but first it is important to understand that table calculations may be computed in one of the two following ways:</p>
    <ul>
      <li class="list"><strong class="bold">Relative</strong>: The table <a id="_idIndexMarker552"/>calculation will be computed relative to the layout of the table. They might move across or down the table. Rearranging <a id="_idIndexMarker553"/>dimensions in a way that changes the table will change the table calculation results. As we'll see, the key for relative table calculations is <strong class="bold">scope </strong>and<strong class="bold"> direction</strong>. When you set a table calculation to use a relative computation, it will continue to use the same relative scope and direction, even if you rearrange the view. (The term here is different from <strong class="screen-text">Relative To</strong> that appears in the UI for some quick table calculations.)</li>
      <li class="list"><strong class="bold">Fixed</strong>: The table<a id="_idIndexMarker554"/> calculation will be computed using one or more dimensions. Rearranging those dimensions in the view will not change the computation of the table calculation. Here, the scope and direction remain fixed to one or more dimensions, no matter where they are moved within the view. When we talk about fixed table calculations, we'll focus on the concepts of <strong class="bold">partitioning </strong>and<strong class="bold"> addressing</strong>.</li>
    </ul>
    <p class="normal">You can see these concepts in the user interface. The following is the <strong class="screen-text">Table Calculation</strong> editor that appears when you select <strong class="screen-text">Edit Table Calculation</strong> from the menu of a table calculation field:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.7: The Edit Table Calculation UI demonstrates the difference between Relative and Fixed table calculations</p>
    <p class="normal">We'll explore the options and terms in <a id="_idIndexMarker555"/>more detail, but for now, notice the options that relate to specifying a table calculation that is computed relative to rows and columns, and options that specify a table calculation that is computed fixed to certain dimensions in the view.</p>
    <p class="normal">Next, we'll look at <strong class="bold">scope</strong> and <strong class="bold">direction</strong>, which describe how relative table calculations operate.</p>
    <h2 id="_idParaDest-127" class="title">Scope and direction</h2>
    <p class="normal"><strong class="bold">Scope</strong> and <strong class="bold">direction</strong> are terms that describe how a table calculation is computed relative to the table. Specifically, scope and direction refer to the following:</p>
    <ul>
      <li class="list"><strong class="bold">Scope</strong>: The scope defines<a id="_idIndexMarker556"/> the boundaries within which a given table calculation can reference other values.</li>
      <li class="list"><strong class="bold">Direction</strong>: The direction <a id="_idIndexMarker557"/>defines how the table calculation moves within the scope.</li>
    </ul>
    <p class="normal">You've already seen table calculations being calculated <strong class="screen-text">Table (across)</strong> (the running sum of sales over time in <em class="italics">Figure 6.5</em>) and <strong class="screen-text">Table (down)</strong> (in <em class="italics">Figure 6.6</em>). In these cases, the scope was the entire table and the direction was either across or down. For example, the running total calculation ran across the entire table, adding subsequent values as it moved from left to right.</p>
    <p class="normal">To define scope and direction for a table calculation, use the drop-down menu for the field in the view and select <strong class="screen-text">Compute Using</strong>. You will get a list of options that vary slightly depending on the location of dimensions in the view. The first of the options listed allows you to define the scope and direction relative to the table. After the option for cell, you will see a list of dimensions present in the view. We'll look at those in the next section.</p>
    <p class="normal">The options for scope and direction<a id="_idIndexMarker558"/> relative to the table are as follows:</p>
    <ul>
      <li class="list"><strong class="bold">Scope options</strong>: Table, pane, and cells</li>
      <li class="list"><strong class="bold">Direction options</strong>: Down, across, down then<a id="_idIndexMarker559"/> across, across then down</li>
    </ul>
    <p class="normal">In order to understand these options, consider the following example:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.8: The difference between table, pane, and cell in the view</p>
    <p class="normal">When it comes to the<a id="_idIndexMarker560"/> scope of table calculations, Tableau makes the following distinctions:</p>
    <ul>
      <li class="list">The <strong class="bold">table</strong> is the entire set of aggregate data.</li>
      <li class="list">The <strong class="bold">pane</strong> is a smaller<a id="_idIndexMarker561"/> section of the entire table. Technically, it is defined by the penultimate<a id="_idIndexMarker562"/> level of the table; that is, the next-to-last dimension on the <strong class="screen-text">Rows</strong> and/or <strong class="screen-text">Columns</strong> shelf defines the pane. In the preceding image, you can see that the intersection of <strong class="screen-text">Year</strong> on rows and <strong class="screen-text">Region</strong> on columns defines the panes (one of eight is highlighted in the view).</li>
      <li class="list">The <strong class="bold">cell</strong> is defined by the lowest level of the table. In this view, the intersection of one <strong class="screen-text">Department</strong> within a <strong class="screen-text">Region</strong> and one <strong class="screen-text">Quarter</strong> within a <strong class="screen-text">Year</strong> is a single cell (one of 96 is highlighted in the view).</li>
    </ul>
    <p class="normal">The bounded areas in the preceding<a id="_idIndexMarker563"/> screenshot are defined by the scope. Scope (and as we'll see, also <a id="_idIndexMarker564"/>partition) defines windows within the data that contain various table calculations. Window functions, such as <code class="Code-In-Text--PACKT-">WINDOW_SUM()</code> in particular, work within the scope of these windows.</p>
    <h3 id="_idParaDest-128" class="title">Working with scope and direction</h3>
    <p class="normal">In order to see how scope<a id="_idIndexMarker565"/> and direction work together, let's work through a few examples. We'll start by creating our own custom table calculations. Create a new<a id="_idIndexMarker566"/> calculated field named <code class="Code-In-Text--PACKT-">Index</code> with the code <code class="Code-In-Text--PACKT-">Index()</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Index()</code> is a table calculation function that starts with a value of <code class="Code-In-Text--PACKT-">1</code> and increments by one as it moves in a given direction and within a given scope. There are many practical uses for <code class="Code-In-Text--PACKT-">Index()</code>, but we'll use it here because it is easy to see how it is moving for a given scope and direction.</p>
    <p class="normal">Create the table as shown in <em class="italics">Figure 6.8</em>, with <strong class="screen-text">YEAR(Order Date)</strong> and <strong class="screen-text">QUARTER(Order Date)</strong> on <strong class="screen-text">Rows</strong> and <strong class="screen-text">Region</strong> and <strong class="screen-text">Department</strong> on <strong class="screen-text">Columns</strong>. Instead of placing <strong class="screen-text">Sales</strong> in the view, add the newly created <strong class="screen-text">Index</strong> field to the <strong class="screen-text">Text</strong> shelf. Then experiment, using the drop-down menu on the <strong class="screen-text">Index</strong> field and select <strong class="screen-text">Compute Using</strong> to cycle through various scope and direction combinations. In the following examples, we've only kept the <strong class="screen-text">East</strong> and <strong class="screen-text">West</strong> regions and two years, <strong class="screen-text">2015</strong> and <strong class="screen-text">2016</strong>:</p>
    <ul>
      <li class="list"><strong class="bold">Table (across)</strong>: This is Tableau's default when there are columns in the table. Notice in the following how <strong class="screen-text">Index</strong> increments across the entire table:
    <figure class="mediaobject"><img src="../Images/B16021_06_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.9: Table (across)</p></li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Table (down)</strong>: When using <code class="Code-In-Text--PACKT-">table (down)</code>, <strong class="screen-text">Index</strong> increments<a id="_idIndexMarker567"/> down the entire table:
    <figure class="mediaobject"><img src="../Images/B16021_06_10.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.10: Table (down)</p></li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Table (across then down)</strong>: This increments <strong class="screen-text">Index</strong> across the table, then steps down, continues to increment across, and repeats for the entire table:
    <figure class="mediaobject"><img src="../Images/B16021_06_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.11: Table (across then down)</p></li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Pane (across)</strong>: This defines a boundary for <strong class="screen-text">Index</strong> and causes it to increment across until it reaches the pane boundary, at which point the indexing restarts:
    <figure class="mediaobject"><img src="../Images/B16021_06_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.12: Pane (across)</p></li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Pane (down)</strong>: This defines a boundary for <strong class="screen-text">Index</strong> and causes it to increment down until it reaches the<a id="_idIndexMarker568"/> pane boundary, at which point the indexing restarts:
    <figure class="mediaobject"><img src="../Images/B16021_06_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.13: Pane (down)</p></li>
    </ul>
    <ul>
      <li class="list"><strong class="bold">Pane (across then down)</strong>: This allows <strong class="screen-text">Index</strong> to increment across the pane and continue by stepping down. The pane defines the boundary here:
    <figure class="mediaobject"><img src="../Images/B16021_06_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.14: Pane (across then down)</p></li>
    </ul>
    <p class="normal">You may use scope and direction with any table calculation. Consider how a running total or percentage difference would be calculated using the same movement and boundaries shown here. Keep experimenting with different options until you feel comfortable with how scope and direction work.</p>
    <p class="normal">Scope and direction <a id="_idIndexMarker569"/>operate relative to the table, so you can rearrange fields, and the calculation will continue to work in the same scope and direction. For example, you could swap <strong class="screen-text">Year of Order Date</strong> with <strong class="screen-text">Department</strong> and still see <strong class="screen-text">Index</strong> calculated according to the scope and direction you defined.</p>
    <p class="normal">Next, we'll take a look at the corresponding concept for table calculations that are fixed to certain dimensions.</p>
    <h2 id="_idParaDest-129" class="title">Addressing and partitioning</h2>
    <p class="normal"><strong class="bold">Addressing</strong> and <strong class="bold">partitioning</strong> are very<a id="_idIndexMarker570"/> similar to scope and direction but are most often used to describe how table calculations are computed with absolute reference to <a id="_idIndexMarker571"/>certain fields in the view. With addressing and partitioning, you define which dimensions in the view define the addressing (direction) and all others define the partitioning (scope).</p>
    <p class="normal">Using addressing and partitioning gives you much finer control because your table calculations are no longer<a id="_idIndexMarker572"/> relative to the table layout, and you have many more options for fine-tuning the scope, direction, and order of the calculations.</p>
    <p class="normal">To begin to understand how this <a id="_idIndexMarker573"/>works, let's consider a simple example. Using the preceding view, select <strong class="screen-text">Edit table calculation</strong> from the drop-down menu of the <strong class="screen-text">Index</strong> field on <strong class="screen-text">Text</strong>. In the resulting dialog box, check <strong class="screen-text">Department</strong> under <strong class="screen-text">Specific Dimensions</strong>.</p>
    <p class="normal">The result of selecting <strong class="screen-text">Department </strong>is as follows:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.15: Setting the table calculation to Compute Using Specific Dimensions uses addressing and partitioning</p>
    <p class="normal">You'll notice that Tableau is computing <strong class="screen-text">Index</strong> along (in the direction of) the checked dimension, <strong class="screen-text">Department</strong>. In other words, you have used <strong class="screen-text">Department</strong> for addressing, so each new department increments the index. All other unchecked dimensions in the view are implicitly used for partitioning; that is, they define the scope or boundaries at which the index function must restart. As we saw with scope, these boundaries are sometimes referred to as a window.</p>
    <p class="normal">The preceding view looks identical to what you would see if you set <strong class="screen-text">Index</strong> to compute using <strong class="screen-text">Pane (across)</strong>. However, there is a major difference. When you use <strong class="screen-text">Pane (across)</strong>, <strong class="screen-text">Index</strong> is always computed across<a id="_idIndexMarker574"/> the pane, even if you rearrange the dimensions in the view, remove some, or add others. </p>
    <p class="normal">But when you compute using a dimension for addressing, the table calculation will always compute using that dimension. Removing that dimension will break the table calculation (the field will turn red with an exclamation mark) and you'll need to edit the table calculation via the drop-down menu to <a id="_idIndexMarker575"/>adjust the settings. If you rearrange dimensions in the view, <strong class="screen-text">Index</strong> will continue to be computed along the <strong class="screen-text">Department</strong> dimension.</p>
    <p class="normal">Here, for example, is the result of clicking the <strong class="screen-text">Swap Rows and Columns</strong> button in the toolbar:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.16: Swapping Rows and Columns does not change how this table calculation was computed as it is fixed to the dimensions rather than the table layout</p>
    <p class="normal">Notice that <strong class="screen-text">Index</strong> continues to be computed along <strong class="screen-text">Department</strong> even though the entire orientation of the table has<a id="_idIndexMarker576"/> changed. To complete the following<a id="_idIndexMarker577"/> examples, we'll undo the swap of rows and columns to return our table to its original orientation.</p>
    <h3 id="_idParaDest-130" class="title">Working with addressing and partitioning</h3>
    <p class="normal">Let's consider a few<a id="_idIndexMarker578"/> other examples of what happens when you add additional dimensions. For example, if you check <strong class="screen-text">Quarter of Order Date</strong>, you'll see Tableau highlight a<a id="_idIndexMarker579"/> partition defined by <strong class="screen-text">Region</strong> and <strong class="screen-text">Year of Order Date</strong>, with <strong class="screen-text">Index</strong> incrementing by the addressing fields of <strong class="screen-text">Quarter of Order Date</strong> and then <strong class="screen-text">Department</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.17: Adding dimensions alters the table calculation's behavior. One of the resulting partitions is highlighted</p>
    <p class="normal">If you <a id="_idIndexMarker580"/>were to select <strong class="screen-text">Department</strong> and <strong class="screen-text">Year of Order Date</strong> as the addressing of <strong class="screen-text">Index</strong>, you'd see a single<a id="_idIndexMarker581"/> partition defined by <strong class="screen-text">Region</strong> and <strong class="screen-text">Quarter</strong>, like this:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.18: Changing the checked dimensions alters the table calculation's behavior. One of the resulting partitions is highlighted</p>
    <p class="normal">You'll notice, in this view, that <strong class="screen-text">Index</strong> increments for every combination of <strong class="screen-text">Year</strong> and <strong class="screen-text">Department</strong> within the partition of <strong class="screen-text">Quarter</strong> and <strong class="screen-text">Region</strong>.</p>
    <p class="normal">These are a few of the other<a id="_idIndexMarker582"/> things to consider when working with addressing and partitioning:</p>
    <ul>
      <li class="list">You can specify the sort <a id="_idIndexMarker583"/>order. For example, if you wanted <strong class="screen-text">Index</strong> to increment according to the value of the sum of sales, you could use the drop-down list at the bottom of the table calculation editor to define a custom sort.</li>
      <li class="list">The <strong class="screen-text">At the Level</strong> option in the edit table calculation dialog box allows you to specify a level at which the table calculations are performed. Most of the time, you'll leave this set at <strong class="screen-text">Deepest</strong> (which is the same as setting it to the bottom-most dimension), but occasionally, you might want to set it at a different level if you need to keep certain dimensions from defining the partition but need the table calculation to be applied at a higher level. You can also reorder the dimensions by dragging and dropping within the checkbox list of <strong class="screen-text">Specific Dimensions</strong>.</li>
      <li class="list">The <strong class="screen-text">Restarting Every...</strong> option effectively makes the selected field, and all dimensions in the addressing above that selected field, part of the partition, but allows you to maintain the fine-tuning of the ordering.</li>
      <li class="list">Dimensions are the only kinds of fields that can be used in addressing; however, a discrete (blue) measure can be used to partition table calculations. To enable this, use the drop-down menu on the field and uncheck <strong class="screen-text">Ignore in Table Calculations</strong>.</li>
    </ul>
    <p class="normal">Take some time to experiment with various options and become comfortable with how addressing and partitioning works. Next, we'll look at how to write our own custom table calculations.</p>
    <h1 id="_idParaDest-131" class="title">Custom table calculations</h1>
    <p class="normal">Before we move <a id="_idIndexMarker584"/>on to some practical examples, let's briefly discuss how to write your own table calculations, instead of using quick table calculations. You can see a list of available table calculation functions by creating a new calculation and selecting <strong class="screen-text">Table Calculation</strong> from the drop-down list under <strong class="screen-text">Functions</strong>.</p>
    <p class="normal">For each of the examples, we'll set <strong class="screen-text">Compute Using</strong> | <strong class="screen-text">Category</strong>. This means <strong class="screen-text">Department</strong> will be the partition.</p>
    <p class="normal">You can think of table <a id="_idIndexMarker585"/>calculations broken down into several categories. The following table calculations can be combined and even nested just like other functions.</p>
    <h2 id="_idParaDest-132" class="title">Meta table functions</h2>
    <p class="normal">These are the functions<a id="_idIndexMarker586"/> that give you information about the partitioning <a id="_idIndexMarker587"/>and addressing. These functions also include <strong class="bold">Index</strong>, <strong class="bold">First</strong>, <strong class="bold">Last</strong>, and <strong class="bold">Size</strong>:</p>
    <ul>
      <li class="list"><strong class="bold">Index</strong> gives an increment as it<a id="_idIndexMarker588"/> moves along the addressing within the partition.</li>
      <li class="list"><strong class="bold">First</strong> gives the offset from the first row in the<a id="_idIndexMarker589"/> partition, so the first row in each partition is <strong class="screen-text">0</strong>, the next row is <strong class="screen-text">-1</strong>, then <strong class="screen-text">-2</strong>, and so on.</li>
      <li class="list"><strong class="bold">Last</strong> gives the offset to the last<a id="_idIndexMarker590"/> row in the partition, so the last row in each partition is <strong class="screen-text">0</strong>, the next-to-last row is <strong class="screen-text">1</strong>, then <strong class="screen-text">2</strong> and so on.</li>
      <li class="list"><strong class="bold">Size</strong> gives the size of the <a id="_idIndexMarker591"/>partition.</li>
    </ul>
    <p class="normal">The following image illustrates the various functions:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.19: Meta table calculations</p>
    <p class="normal"><strong class="bold">Index</strong>, <strong class="bold">First</strong>, and <strong class="bold">Last</strong> are all affected by <a id="_idIndexMarker592"/>scope/partition<a id="_idIndexMarker593"/> and direction/addressing, while <strong class="bold">Size</strong> will give the same result at each address of the partition, no matter what direction is specified.</p>
    <h2 id="_idParaDest-133" class="title">Lookup and previous value</h2>
    <p class="normal">The first of these two<a id="_idIndexMarker594"/> functions gives you the ability to reference values in other rows, while the second gives you the ability to <a id="_idIndexMarker595"/>carry forward values. Notice from the following screenshot that direction is very important for these two functions:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.20: Lookup and Previous_Value functions (though Previous_Value includes some additional logic described below) </p>
    <p class="normal">Both calculations are <a id="_idIndexMarker596"/>computed using an<a id="_idIndexMarker597"/> addressing of <strong class="screen-text">Category</strong> (so <strong class="screen-text">Department</strong> is the partition).</p>
    <p class="normal">Here, we've used the code <code class="Code-In-Text--PACKT-">Lookup(ATTR([Category]), -1)</code>, which looks up the value of the category in the row offset by <code class="Code-In-Text--PACKT-">-1</code> from the current one. The first row in each partition gets a <code class="Code-In-Text--PACKT-">NULL</code> result<a id="_idIndexMarker598"/> from the lookup (because there isn't a row before it).</p>
    <p class="normal">For <code class="Code-In-Text--PACKT-">Previous_Value</code>, we used this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">Previous_Value</span><span class="hljs-params">(</span><span class="hljs-string">""</span><span class="hljs-params">)</span> + <span class="hljs-string">","</span> + ATTR([Category]) 
</code></pre>
    <p class="normal">Notice that in the first row of each partition, there is no previous value, so <code class="Code-In-Text--PACKT-">Previous_Value()</code> simply<a id="_idIndexMarker599"/> returned what we specified as the default: an empty string. This was then concatenated together with a comma and the category in that row, giving us the value<strong class="screen-text"> Bookcases</strong>.</p>
    <p class="normal">In the second row, <strong class="screen-text">Bookcases</strong> is the previous value, which gets concatenated with a comma and the category in that row, giving us the value<strong class="screen-text"> Bookcases, Chairs &amp; Chairmats</strong>, which becomes the previous value in the next row. The pattern continues throughout the partition and then restarts in the partition defined by the department <strong class="screen-text">Office Supplies</strong>.</p>
    <h2 id="_idParaDest-134" class="title">Running functions</h2>
    <p class="normal">These functions run along <a id="_idIndexMarker600"/>direction/addressing <a id="_idIndexMarker601"/>and include <code class="Code-In-Text--PACKT-">Running_Avg()</code>, <code class="Code-In-Text--PACKT-">Running_Count()</code>, <code class="Code-In-Text--PACKT-">Running_Sum()</code>, <code class="Code-In-Text--PACKT-">Running_Min()</code>, and <code class="Code-In-Text--PACKT-">Running_Max()</code>, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.21: Running Functions</p>
    <p class="normal">Notice that <code class="Code-In-Text--PACKT-">Running_Sum(SUM[Sales]))</code> continues to add the sum of sales to a running total for every row in the partition. <code class="Code-In-Text--PACKT-">Running_Min(SUM[Sales]))</code> keeps the value of the sum of sales if it is the <a id="_idIndexMarker602"/>smallest value it has encountered so far <a id="_idIndexMarker603"/>as it moves along the rows of the partition.</p>
    <h2 id="_idParaDest-135" class="title">Window functions</h2>
    <p class="normal">These functions operate <a id="_idIndexMarker604"/>across all rows in the partition at once <a id="_idIndexMarker605"/>and essentially aggregate the aggregates. They include <code class="Code-In-Text--PACKT-">Window_Sum</code>, <code class="Code-In-Text--PACKT-">Window_Avg</code>, <code class="Code-In-Text--PACKT-">Window_Max</code>, and <code class="Code-In-Text--PACKT-">Window_Min</code>, among others, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.22: Examples of Window functions</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Window_Sum(SUM([Sales])</code> adds up the sums of sales within the entire window (in this case, for all categories <a id="_idIndexMarker606"/>within the department). <code class="Code-In-Text--PACKT-">Window_Max(SUM([Sales])</code> returns the <a id="_idIndexMarker607"/>maximum sum of sales within the window.</p>
    <div class="packt_tip">
      <p>You may pass optional parameters to window functions to further limit the scope of the window. The window will always be limited to, at most, the partition.</p>
    </div>
    <h2 id="_idParaDest-136" class="title">Rank functions</h2>
    <p class="normal">These functions<a id="_idIndexMarker608"/> provide various ways to rank based on aggregate values. There <a id="_idIndexMarker609"/>are multiple variations of rank, which allow you to decide how to deal with ties and how dense the ranking should be, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.23: Examples of rank functions</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Rank(SUM([Sales])</code> calculation returns <a id="_idIndexMarker610"/>the rank of the sum<a id="_idIndexMarker611"/> of sales for categories within the department.</p>
    <h2 id="_idParaDest-137" class="title">Script functions</h2>
    <p class="normal">These functions allow<a id="_idIndexMarker612"/> integration with the R analytics platform or<a id="_idIndexMarker613"/> Python, either of which can incorporate simple or complex scripts for everything from advanced statistics to predictive modeling. It's beyond the scope of this book to dive into all that is possible, but documentation and examples are readily available on Tableau's website and from various members of the Tableau community.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Bora Beran, for example, has<a id="_idIndexMarker614"/> an excellent post here: <a href="https://www.tableau.com/about/blog/2016/11/leverage-power-python-tableau-tabpy-62077"><span class="url">https://www.tableau.com/about/blog/2016/11/leverage-power-python-tableau-tabpy-62077</span></a></p>
    </div>
    <h2 id="_idParaDest-138" class="title">The Total function</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Total</code> function <a id="_idIndexMarker615"/>deserves its own category because it functions a little differently from the others. Unlike the other functions that work on the <a id="_idIndexMarker616"/>aggregate table in the cache, <code class="Code-In-Text--PACKT-">Total</code> will re-query the underlying source for all the source data rows that make up a given partition. In most cases, this will yield the same result as a window function.</p>
    <p class="normal">For example, <code class="Code-In-Text--PACKT-">Total(SUM([Sales]))</code> gives the same result as <code class="Code-In-Text--PACKT-">Window_Sum(SUM([Sales]))</code>, but <code class="Code-In-Text--PACKT-">Total(AVG([Sales]))</code> will possibly give a different result from <code class="Code-In-Text--PACKT-">Window_AVG(SUM([Sales]))</code> because <code class="Code-In-Text--PACKT-">Total</code> is giving you the actual average of underlying rows, while the <code class="Code-In-Text--PACKT-">Window</code> function is averaging the sums.</p>
    <p class="normal">In this section, we have looked at a number of table calculation functions. These will give you the building blocks to solve all kinds of practical problems and answer a great many questions. From ranking to year-over-year comparisons, you now have a foundation for success. Let's now move on to some practical examples.</p>
    <h1 id="_idParaDest-139" class="title">Practical examples</h1>
    <p class="normal">Having looked at some of the<a id="_idIndexMarker617"/> essential concepts of table calculations, let's consider some practical examples. We'll look at several examples, although the practical use of table calculations is nearly endless. You can do everything from running sums and analyzing year-over-year growth to viewing percentage differences between categories, and much more.</p>
    <h2 id="_idParaDest-140" class="title">Year over year growth</h2>
    <p class="normal">Often, you may want to compare year <a id="_idIndexMarker618"/>over year values. How much has our customer base grown over the last year? How did sales in each quarter compare to sales in the same quarter last year? These types of question can be answered using <strong class="screen-text">Year over Year Growth</strong>.</p>
    <p class="normal">Tableau exposes <strong class="screen-text">Year over Year Growth</strong> as one option in the quick table calculations. Here, for example, is a view that demonstrates <strong class="screen-text">Sales</strong> by <strong class="screen-text">Quarter</strong>, along with the percentage difference in sales for a quarter compared with the previous year:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.24: Year over year growth of Sales</p>
    <p class="normal">The second <strong class="screen-text">Sum(Sales)</strong> field has had the <strong class="screen-text">Year over Year Growth</strong> quick table calculation applied (and the <strong class="screen-text">Mark</strong> type changed to bar). You'll notice the <strong class="screen-text">&gt;4 nulls</strong> indicator in the lower right, alerting you to the fact that there are at least four null values (which makes sense as there is <a id="_idIndexMarker619"/>no 2016 with which to compare quarters in 2017). </p>
    <p class="normal">If you filtered out 2017, the nulls would appear in 2018 as table calculations can only operate on values present in the aggregated data in the cache. Any regular filters applied to the data are applied at the source and the excluded data never makes it to the cache.</p>
    <p class="normal">As easy as it is to build a view like this example, take care, because Tableau assumes each year in the view has the same number of quarters. For example, if the data for <strong class="screen-text">Q1</strong> in 2017 was not present or filtered out, then the resulting view would not necessarily represent what you want. Consider the following, for example:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.25: Year over year growth of Sales—but it doesn't work with Q1 missing in the first year</p>
    <p class="normal">The problem here is<a id="_idIndexMarker620"/> that Tableau is calculating the quick table calculation using an addressing of <strong class="screen-text">Year</strong> and <strong class="screen-text">Quarter</strong> and an <em class="italics">At the Level </em>of value of <strong class="screen-text">Year of Order Date</strong>. This works assuming all quarters are present. However, here, the first quarter in <strong class="screen-text">2018</strong> is matched with the first quarter present in <strong class="screen-text">2017</strong>, which is really <strong class="screen-text">Q2</strong>. To solve this, you would need to edit the table calculation to only use <strong class="screen-text">Year</strong> for addressing. <strong class="screen-text">Quarter</strong> then becomes the partition and thus comparisons are done for the correct quarter.</p>
    <p class="normal">An additional issue arises for consideration: what if you don't want to show 2017 in the view? Filtering it out will cause issues for 2018. In this case, we'll look at <strong class="bold">table calculation filtering</strong>, or <strong class="bold">late filtering</strong>, later in this section. Another potential way to remove 2017 but keep access to its data values is to right-click the 2017 header in the view and select <strong class="screen-text">Hide</strong>.</p>
    <p class="normal">Hide is a special command that simply keeps Tableau from rendering data, even when it is present in the cache. If you later decide you want to show 2017 after hiding it, you can use the menu for the <strong class="screen-text">YEAR(Order Date)</strong> field and select <strong class="screen-text">Show Hidden Data</strong>. Alternately, you can use the menu to select <strong class="screen-text">Analysis</strong> | <strong class="screen-text">Reveal Hidden Data</strong>.</p>
    <p class="normal">You may also<a id="_idIndexMarker621"/> wish to hide the null indicator in the view. You can do this by right-clicking the indicator and selecting <strong class="screen-text">Hide Indicator</strong>. Clicking the indicator will reveal options to filter the data or display it as a default value (typically, 0).</p>
    <p class="normal">Year over year growth (or any period over another) is a common analytical question which table calculations allow you to answer. Next, let's consider another example of table calculations in practice.</p>
    <h2 id="_idParaDest-141" class="title">Dynamic titles with totals</h2>
    <p class="normal">You've likely noticed the titles<a id="_idIndexMarker622"/> that are displayed for every view. There are also captions that are not shown unless you specifically turn them on (to do this, select <strong class="screen-text">Worksheet</strong> | <strong class="screen-text">Show Caption</strong> from the menu).</p>
    <p class="normal">By default, the title displays the sheet name and captions are hidden, but you can show and modify them. At times, you might want to display totals that help your end users understand the broad context or immediately grasp the magnitude.</p>
    <p class="normal">Here, for example, is a view that allows the user to select one or more <strong class="screen-text">Regions</strong> and then see <strong class="screen-text">Sales per State</strong> in each <strong class="screen-text">Region</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.26: Sales per State for two regions</p>
    <p class="normal">It might be useful to show a changing number of states as the user selects different regions. You might first think to use an aggregation on <strong class="screen-text">State</strong>, such as <code class="Code-In-Text--PACKT-">Count Distinct</code>. However, if you try showing that in the title, you will always see the value <code class="Code-In-Text--PACKT-">1</code>. Why? Because the view level of detail is <strong class="screen-text">State</strong> and the distinct count of states per state is <code class="Code-In-Text--PACKT-">1</code>!</p>
    <p class="normal">But there are some <a id="_idIndexMarker623"/>options with table calculations that let you further aggregate aggregates. Or, you might think of determining the number of values in the table based on the size of the window. In fact, here are several possibilities:</p>
    <ul>
      <li class="list">To get the total distinct count: <code class="Code-In-Text--PACKT-">TOTAL(COUNTD([State]))</code></li>
      <li class="list">To get the sum within the window: <code class="Code-In-Text--PACKT-">WINDOW_SUM(SUM(1))</code></li>
      <li class="list">To get the size of the window: <code class="Code-In-Text--PACKT-">SIZE()</code></li>
    </ul>
    <p class="normal">You may recall that a window is defined as the boundaries determined by scope or partition. Whichever we choose, we want to define the window as the entire table. Either a relative computation of <code class="Code-In-Text--PACKT-">Table (down)</code> or a fixed computation using all of the dimensions would accomplish this. Here is a view that illustrates a dynamic title and all three options in the caption:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_27.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.27: Various table calculations could be employed to achieve the total in the title</p>
    <p class="normal">This example illustrated <a id="_idIndexMarker624"/>how you might use various table calculations to work at higher levels of detail, specifically counting all the states in the view. This technique will enable you to solve various analytical questions as you use Tableau. Let's now turn our attention to another technique that helps solve quite a few problems.</p>
    <h2 id="_idParaDest-142" class="title">Table calculation filtering (late filtering)</h2>
    <p class="normal">Let's say you've built a view that allows you to see the percentage of total sales for each department. You <a id="_idIndexMarker625"/>have already used a quick table calculation on the <strong class="screen-text">Sales</strong> field to give you the percent of the total. You've also used <strong class="screen-text">Department</strong> as a filter. But this presents a problem.</p>
    <p class="normal">Since table calculations are performed after the aggregate data is returned to the cache, the filter on department has already been evaluated at the data source and the aggregate rows don't include any departments excluded by the filter. Thus, the percent of the total will always add up to 100%; that is, it is the percentage of the filtered total, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B16021_06_28.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.28: When Office Supplies is filtered out, the percentage table calculation adds up to 100% for the departments remaining in the view</p>
    <p class="normal">What if you wanted to see the percentage of the total sales for all departments, even if you want to exclude some from the display? One option is to use a table calculation as a filter.</p>
    <p class="normal">You might create a calculated field called <code class="Code-In-Text--PACKT-">Department (table calc filter)</code> with the code <code class="Code-In-Text--PACKT-">LOOKUP(ATTR([Department]), 0)</code>. The <code class="Code-In-Text--PACKT-">Lookup()</code> function makes this a table calculation, while <code class="Code-In-Text--PACKT-">ATTR()</code> treats <strong class="screen-text">Department</strong> as an aggregation (further explanation is provided at the end of this section). The second argument, <code class="Code-In-Text--PACKT-">0</code>, tells the lookup function not to look backward or forward. Thus, the calculation returns all values for <strong class="screen-text">Department</strong>, but as a table calculation result.</p>
    <p class="normal">When you place that table calculation on the <strong class="screen-text">Filters</strong> shelf instead of the <strong class="screen-text">Department</strong> dimension, then the filter is not applied at the source. Instead, all the aggregate data is still stored in the cache and the table calculation filter merely <em class="italics">hides</em> it from the view. Other table calculations, such as <strong class="screen-text">Percent of Total</strong>, will still operate on all the data in the cache. In this case, that <a id="_idIndexMarker626"/>allows the percent of total to be calculated for all departments, even though the table calculation filter is hiding one or more, as shown in the following screenshot:</p>
    <figure class="mediaobject"> <img src="../Images/B16021_06_29.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.29: When a table calculation filter is used, all the aggregate data is available in the cache for the % of Total Sales to be calculated for all departments</p>
    <p class="normal">You might have noticed the <code class="Code-In-Text--PACKT-">ATTR</code> function used. Remember that table calculations require aggregate arguments. <code class="Code-In-Text--PACKT-">ATTR</code> (which is short for attribute) is a special aggregation that returns the value of a field if there is only a single value of that field present for a given level of detail or a <code class="Code-In-Text--PACKT-">*</code> if there is more than one value.</p>
    <p class="normal">To understand this, experiment with a view having both <strong class="screen-text">Department</strong> and <strong class="screen-text">Category</strong> on rows. Using the drop-down menu on the active field in the view, change <strong class="screen-text">Category</strong> to <strong class="screen-text">Attribute</strong>. It will display as <code class="Code-In-Text--PACKT-">*</code> because there is more than one category for each department. Then, undo and change <strong class="screen-text">Department</strong> to <strong class="screen-text">Attribute</strong>. It will display the department name because there is only one department per category.</p>
    <p class="normal">In this example, we've seen how to effectively use table calculations as filters when we need other table calculations to <a id="_idIndexMarker627"/>operate on all the data in the cache.</p>
    <h1 id="_idParaDest-143" class="title">Summary</h1>
    <p class="normal">We've covered a lot of concepts surrounding table calculations in this chapter. You now have a foundation for using the simplicity of quick table calculations and leveraging the power of advanced table calculations. We've looked at the concepts of scope and direction as they apply to table calculations that operate relative to the row and column layout of the view. We've also considered the related concepts of addressing and partitioning as they relate to table calculations that have computations fixed to certain dimensions.</p>
    <p class="normal">The practical examples we've covered barely scratch the surface of what is possible, but should give you an idea of what can be achieved. The kinds of problems that can be solved and the diversity of questions that can be answered are almost limitless.</p>
    <p class="normal">We'll turn our attention to some lighter topics in the next couple of chapters, looking at formatting and design, but we'll certainly see another table calculation or two before we're finished!</p>
  </div>
</body></html>