<html><head></head><body>
  <div id="_idContainer016" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-37" class="chapterTitle">Selection and Assignment</h1>
    <p class="normal">In the previous chapter, we looked at how to create a <code class="inlineCode">pd.Series</code> and <code class="inlineCode">pd.DataFrame</code>, and we also looked at their relationship to the <code class="inlineCode">pd.Index</code>. With a foundation in <em class="italic">constructors</em>, we now shift focus to the crucial processes of <em class="italic">selection</em> and <em class="italic">assignment</em>. Selection, also referred to as <em class="italic">indexing</em>, is considered a <em class="italic">getter</em>; i.e., it is used to retrieve values from a pandas object. Assignment, by contrast, is a <em class="italic">setter</em> that is used to update values.</p>
    <p class="normal">The recipes in this chapter start out by showing you how to retrieve values from <code class="inlineCode">pd.Series</code> and <code class="inlineCode">pd.DataFrame</code> objects, with ever-increasing complexity. We will eventually introduce the <code class="inlineCode">pd.MultiIndex</code>, which can be used to select data hierarchically, before finally ending with an introduction to the assignment operators. The pandas API takes great care to reuse many of the same methods for selection and assignment, which ultimately allows you to be very expressive in how you would like to interact with your data.</p>
    <p class="normal">By the end of this chapter, you will be adept at efficiently retrieving data from and updating values within your pandas objects. We are going to cover the following recipes in this chapter: </p>
    <ul>
      <li class="bulletList">Basic selection from a Series</li>
      <li class="bulletList">Basic selection from a DataFrame</li>
      <li class="bulletList">Position-based selection of a Series</li>
      <li class="bulletList">Position-based selection of a DataFrame</li>
      <li class="bulletList">Label-based selection from a Series</li>
      <li class="bulletList">Label-based selection from a DataFrame</li>
      <li class="bulletList">Mixing position-based and label-based selection</li>
      <li class="bulletList">DataFrame.filter</li>
      <li class="bulletList">Selection by data type</li>
      <li class="bulletList">Selection/filtering via Boolean arrays</li>
      <li class="bulletList">Selection with a MultiIndex – A single level</li>
      <li class="bulletList">Selection with a MultiIndex – Multiple levels</li>
      <li class="bulletList">Selection with a MultiIndex – a DataFrame</li>
      <li class="bulletList">Item assignment with .loc and .iloc</li>
      <li class="bulletList">DataFrame column assignment</li>
    </ul>
    <h1 id="_idParaDest-38" class="heading-1">Basic selection from a Series</h1>
    <p class="normal">Selection<a id="_idIndexMarker018"/> from a <code class="inlineCode">pd.Series</code> involves accessing elements either by their position or by their label. This is akin to accessing elements in a list by their index or in a dictionary by their key, respectively. The versatility of the <code class="inlineCode">pd.Series</code> object allows intuitive and straightforward data retrieval, making it an essential tool for data manipulation.</p>
    <p class="normal">The <code class="inlineCode">pd.Series</code> is considered a <em class="italic">container</em> in Python, much like the built-in <code class="inlineCode">list</code>, <code class="inlineCode">tuple</code>, and <code class="inlineCode">dict</code> objects. As such, for simple selection operations, the first place users turn to is the Python index operator, using the <code class="inlineCode">[]</code> syntax.</p>
    <h2 id="_idParaDest-39" class="heading-2">How to do it</h2>
    <p class="normal">To introduce the basics of selection, let’s start with a very simple <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">list</span>(<span class="hljs-string">"abc"</span>) * <span class="hljs-number">3</span>)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    a
1    b
2    c
3    a
4    b
5    c
6    a
7    b
8    c
dtype: object
</code></code></pre>
    <p class="normal">In Python, you’ve already discovered that the <code class="inlineCode">[]</code> operator can be used to select elements from a <em class="italic">container</em>; i.e., <code class="inlineCode">some_dictionary[0]</code> will give you the value associated with a key of 0. With a <code class="inlineCode">pd.Series</code>, basic selection behaves similarly:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[<span class="hljs-number">3</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">a
</code></code></pre>
    <p class="normal">With the expression <code class="inlineCode">ser[3]</code>, pandas tries to find the label 3 in the index of the <code class="inlineCode">pd.Series</code> and, assuming only one match, returns the value associated with that label.</p>
    <p class="normal">Instead of selecting the associated value from the <code class="inlineCode">pd.Series</code>, alternatively, you may want a <code class="inlineCode">pd.Series</code> returned, as doing so helps you keep the label 3 associated with the data element “a.” With <a id="_idIndexMarker019"/>pandas, you can do this by providing a list argument that contains a single element:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[[<span class="hljs-number">3</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">3    a
dtype: object
</code></code></pre>
    <p class="normal">Expanding on the usage of a list argument, you can select multiple values from the <code class="inlineCode">pd.Series</code> if your list contains multiple elements:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    a
2    c
dtype: object
</code></code></pre>
    <p class="normal">Assuming you use the default index, you can use slice arguments that work very similarly to slicing a Python list. For example, to get up to (but not including) the element at position 3 of a <code class="inlineCode">pd.Series</code>, you can use:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[:<span class="hljs-number">3</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    a
1    b
2    c
dtype: object
</code></code></pre>
    <p class="normal">Negative slice indexers are not a problem for pandas. The following code will select the last four elements of the <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[-<span class="hljs-number">4</span>:]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">5    c
6    a
7    b
8    c
dtype: object
</code></code></pre>
    <p class="normal">You can even provide slices with <em class="italic">start</em> and <em class="italic">stop</em> arguments. The following code will retrieve all elements of the <code class="inlineCode">pd.Series</code>, starting in position 2 and up to (but not including) position 6:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2    c
3    a
4    b
5    c
dtype: object
</code></code></pre>
    <p class="normal">This final example on slices uses <em class="italic">start</em>, <em class="italic">stop</em> and <em class="italic">step</em> arguments to grab every third element, starting at<a id="_idIndexMarker020"/> position 1 and stopping when position 8 is encountered:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>:<span class="hljs-number">3</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1    b
4    b
7    b
dtype: object
</code></code></pre>
    <p class="normal">Selection still works when providing your own <code class="inlineCode">pd.Index</code> values. Let’s create a small <code class="inlineCode">pd.Series</code> with string index labels to illustrate:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>), index=[<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Jill"</span>, <span class="hljs-string">"Jayne"</span>])
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack     0
Jill     1
Jayne    2
dtype: int64
</code></code></pre>
    <p class="normal">Selection via <code class="inlineCode">ser["Jill"]</code> will scan the index for the string <code class="inlineCode">Jill</code> and return the corresponding element:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[<span class="hljs-string">"Jill"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1
</code></code></pre>
    <p class="normal">Once again, providing a single-element list argument will ensure that you receive a <code class="inlineCode">pd.Series</code> in return<a id="_idIndexMarker021"/> instead of a single value:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[[<span class="hljs-string">"Jill"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jill    1
dtype: int64
</code></code></pre>
    <h2 id="_idParaDest-40" class="heading-2">There’s more…</h2>
    <p class="normal">A common pitfall <a id="_idIndexMarker022"/>when using the <code class="inlineCode">[]</code> operator is to assume that selection with integer arguments works the same as when selecting from a Python list. This is <em class="italic">only</em> true when you use the default <code class="inlineCode">pd.Index</code>, which is auto-numbered, starting at 0 (this is technically called<a id="_idIndexMarker023"/> a <code class="inlineCode">pd.RangeIndex</code>).</p>
    <p class="normal">When not using a <code class="inlineCode">pd.RangeIndex</code>, extra attention must be paid to the behavior. To illustrate, let’s start with a small <code class="inlineCode">pd.Series</code>, which still uses integers in its <code class="inlineCode">pd.Index</code>, but does not use an auto-incrementing sequence that starts at 0:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">list</span>(<span class="hljs-string">"abc"</span>), index=[<span class="hljs-number">2</span>, <span class="hljs-number">42</span>, <span class="hljs-number">21</span>])
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2     a
42    b
21    c
dtype: object
</code></code></pre>
    <p class="normal">It is important to note that an integer argument selects by <em class="italic">label</em> and not by <em class="italic">position</em>; i.e., the following code will return the value associated with a label of 2, not the value in position 2:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">a
</code></code></pre>
    <p class="normal">While the integer argument matches by label and not by position, slicing still works positionally. The following example does not stop when encountering the number 2 and, instead, gives the first two elements back:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2     a
42    b
dtype: object
</code></code></pre>
    <p class="normal">Users should also be familiar with selection behavior when working with a non-unique <code class="inlineCode">pd.Index</code>. Let’s create<a id="_idIndexMarker024"/> a small <code class="inlineCode">pd.Series</code> where the number 1 appears twice in our row index:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>], index=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     apple
1    banana
1    orange
dtype: object
</code></code></pre>
    <p class="normal">With this <code class="inlineCode">pd.Series</code>, attempting to select the number 1 will <em class="italic">not</em> return a single value and, instead, return another <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[<span class="hljs-number">1</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1    banana
1    orange
dtype: object
</code></code></pre>
    <p class="normal">The fact that a selection like <code class="inlineCode">ser[1]</code> can be thought to be done by position or label interchangeably when using the default <code class="inlineCode">pd.RangeIndex</code> but, in actuality, selects by label with other <code class="inlineCode">pd.Index</code> types can be the source of subtle bugs in user programs. Many users may <em class="italic">think</em> they are selecting the <em class="italic">n</em><sup class="superscript">th</sup> element, only to have that assumption break when their data changes. To<a id="_idIndexMarker025"/> resolve the ambiguity between wanting to select by <em class="italic">label</em> or by <em class="italic">position</em> with an integer argument, it is <strong class="keyWord">highly recommended</strong> to leverage the <code class="inlineCode">.loc</code> and <code class="inlineCode">.iloc</code> methods introduced later in this chapter.</p>
    <h1 id="_idParaDest-41" class="heading-1">Basic selection from a DataFrame</h1>
    <p class="normal">When using the <code class="inlineCode">[]</code> operator with a <code class="inlineCode">pd.DataFrame</code>, simple selection typically involves selecting data<a id="_idIndexMarker026"/> from the <em class="italic">column index</em> rather than the <em class="italic">row index</em>. This distinction is crucial for effective data manipulation and analysis. Columns in a <code class="inlineCode">pd.DataFrame</code> can be accessed by their labels, making it easy to work with named data from a <code class="inlineCode">pd.Series</code> within the larger <code class="inlineCode">pd.DataFrame</code> structure.</p>
    <p class="normal">Understanding this fundamental difference in selection behavior is key to utilizing the full power of a <code class="inlineCode">pd.DataFrame</code> in pandas. By leveraging the <code class="inlineCode">[]</code> operator, you can efficiently access and manipulate specific columns of data, setting the stage for more advanced operations and analyses.</p>
    <h2 id="_idParaDest-42" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start by creating a simple 3x3 <code class="inlineCode">pd.DataFrame</code>. The values of the <code class="inlineCode">pd.DataFrame</code> are not important, but we are intentionally going to provide our own column labels instead of having pandas create an auto-numbered column index for us:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame(np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>), columns=[<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a     b     c
0    0     1     2
1    3     4     5
2    6     7     8
</code></code></pre>
    <p class="normal">To select a single column, use the <code class="inlineCode">[]</code> operator with a scalar argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[<span class="hljs-string">"a"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    0
1    3
2    6
Name: a, dtype: int64
</code></code></pre>
    <p class="normal">To select a single column but still get back a <code class="inlineCode">pd.DataFrame</code> instead of a <code class="inlineCode">pd.Series</code>, pass a single-element list:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[[<span class="hljs-string">"a"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a
0    0
1    3
2    6
</code></code></pre>
    <p class="normal">Multiple columns can be selected using a list:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[[<span class="hljs-string">"</span><span class="hljs-string">a"</span>, <span class="hljs-string">"b"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a     b
0    0     1
1    3     4
2    6     7
</code></code></pre>
    <p class="normal">In all of these examples, the arguments for <code class="inlineCode">[]</code> have been selected from the columns, but providing a slice argument exhibits different behavior and will actually select from rows. Note that the following <a id="_idIndexMarker027"/>example selects all columns and the first two rows of data, not the other way around:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a     b     c
0    0     1     2
1    3     4     5
</code></code></pre>
    <h2 id="_idParaDest-43" class="heading-2">There’s more…</h2>
    <p class="normal">When using a list <a id="_idIndexMarker028"/>argument for the <code class="inlineCode">[]</code> operator, you have the flexibility to specify the order of columns in the output. This allows you to customize the <code class="inlineCode">pd.DataFrame</code> to suit your needs. The order of columns in the output will exactly match the order of labels provided as input. For example:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[[<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a     b
0    0     1
1    3     4
2    6     7
</code></code></pre>
    <p class="normal">Swapping the order of the elements in the list as an argument to <code class="inlineCode">[]</code> will swap the order of the columns in the resulting <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[[<span class="hljs-string">"b"</span>, <span class="hljs-string">"a"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     b     a
0    1     0
1    4     3
2    7     6
</code></code></pre>
    <p class="normal">This feature is particularly useful when you need to reorder columns for presentation purposes, or when preparing data for export to CSV or Excel formats where a specific column order is <a id="_idIndexMarker029"/>required (see <em class="chapterRef">Chapter 4</em>, <em class="italic">The pandas I/O System,</em> for more on the pandas I/O system).</p>
    <h1 id="_idParaDest-44" class="heading-1">Position-based selection of a Series</h1>
    <p class="normal">As discussed back in the <em class="italic">Basic selection from a DataFrame</em> section, using <code class="inlineCode">[]</code> as a selection mechanism does<a id="_idIndexMarker030"/> not signal the clearest intent and can sometimes be downright confusing. The fact that <code class="inlineCode">ser[42]</code> selects from a <em class="italic">label</em> matching the number 42 and not the 42<sup class="superscript">nd</sup> row of a <code class="inlineCode">pd.Series</code> is a common mistake for new users, and such an ambiguity can grow even more complex as you start trying to select two dimensions with the <code class="inlineCode">[]</code> operator from a <code class="inlineCode">pd.DataFrame</code>.</p>
    <p class="normal">To clearly signal that you are trying to select by <em class="italic">position</em> instead of by <em class="italic">label</em>, you should use <code class="inlineCode">pd.Series.iloc</code>.</p>
    <h2 id="_idParaDest-45" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.Series</code> where we have an index using integral labels that are also non-unique:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>], index=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     apple
1    banana
1    orange
dtype: object
</code></code></pre>
    <p class="normal">To select a scalar, you can use <code class="inlineCode">pd.Series.iloc</code> with an integer argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.iloc[<span class="hljs-number">1</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">banana
</code></code></pre>
    <p class="normal">Following the same patterns we have seen before, turning that integer argument into a list containing a single element will return a <code class="inlineCode">pd.Series</code> instead of a scalar:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.iloc[[<span class="hljs-number">1</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1    banana
dtype: object
</code></code></pre>
    <p class="normal">Multiple integers in the list argument will select multiple elements of the <code class="inlineCode">pd.Series</code> by position:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     apple
1    orange
dtype: object
</code></code></pre>
    <p class="normal">Slices are a natural way of expressing a range of elements that you would select, and they pair very nicely as<a id="_idIndexMarker031"/> an argument to <code class="inlineCode">pd.Series.iloc</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.iloc[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     apple
1    banana
dtype: object
</code></code></pre>
    <h1 id="_idParaDest-46" class="heading-1">Position-based selection of a DataFrame</h1>
    <p class="normal">Much like with a <code class="inlineCode">pd.Series</code>, integers, lists of integers, and slice objects are all valid arguments to <code class="inlineCode">DataFrame.iloc</code>. However, with<a id="_idIndexMarker032"/> a <code class="inlineCode">pd.DataFrame</code>, two arguments are required. The first argument handles selecting from the <em class="italic">rows</em>, and the second is responsible for the <em class="italic">columns</em>.</p>
    <p class="normal">In most use cases, users reach for position-based selection when retrieving rows and label-based selection when retrieving columns. We will cover the latter in the <em class="italic">Label-based selection from a DataFrame</em> section and will show you how to combine both in the <em class="italic">Mixing position-based and label-based selection</em> section. However, when your row index uses the default <code class="inlineCode">pd.RangeIndex</code> and the order of columns is significant, the techniques shown in this section will be of immense value.</p>
    <h2 id="_idParaDest-47" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.DataFrame</code> with five rows and four columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame(np.arange(<span class="hljs-number">20</span>).reshape(<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>), columns=<span class="hljs-built_in">list</span>(<span class="hljs-string">"abcd"</span>))
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a     b     c     d
0    0     1     2     3
1    4     5     6     7
2    8     9     10    11
3    12    13    14    15
4    16    17    18    19
</code></code></pre>
    <p class="normal">Passing two integer arguments to <code class="inlineCode">pd.DataFrame.iloc</code> will return a scalar from that row and column position:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">10
</code></code></pre>
    <p class="normal">In some cases, you may not want to select individual values from a particular axis, opting instead for everything that axis has to offer. An empty slice object, <code class="inlineCode">:</code>, allows you to do this; i.e., if you wanted <a id="_idIndexMarker033"/>to select <em class="italic">all</em> rows of data from the first column of a <code class="inlineCode">pd.DataFrame</code>, you would use:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[:, <span class="hljs-number">0</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     0
1     4
2     8
3    12
4    16
Name: a, dtype: int64
</code></code></pre>
    <p class="normal">Flipping the order of the arguments to <code class="inlineCode">pd.DataFrame.iloc</code> will change behavior. Instead of grabbing all rows for the first column, the below code selects all columns and only the first row of data:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[<span class="hljs-number">0</span>, :]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">a    0
b    1
c    2
d    3
Name: 0, dtype: int64
</code></code></pre>
    <p class="normal">Because the preceding examples only return one dimension of data, they implicitly attempt to <em class="italic">squeeze</em> the return value from a <code class="inlineCode">pd.DataFrame</code> down to a <code class="inlineCode">pd.Series</code>. Following the patterns we have seen many times already in this chapter, you can prevent that implicit dimensionality reduction by passing a single-element list argument for the axis, which is not an empty slice. For example, to select all rows for the first column but still get back a <code class="inlineCode">pd.DataFrame</code>, you <a id="_idIndexMarker034"/>would opt for:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[:, [<span class="hljs-number">0</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a
0    0
1    4
2    8
3    12
4    16
</code></code></pre>
    <p class="normal">Reversing those arguments gives us the first row and all columns back as a <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[[<span class="hljs-number">0</span>], :]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     a    b    c    d
0    0    1    2    3
</code></code></pre>
    <p class="normal">Lists can be used to select multiple elements from both the rows and columns. If we wanted the first and <a id="_idIndexMarker035"/>second rows paired with the last and second-to-last columns of our <code class="inlineCode">pd.DataFrame</code>, you could opt for an expression like:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     d    c
0    3    2
1    7    6
</code></code></pre>
    <h2 id="_idParaDest-48" class="heading-2">There’s more…</h2>
    <p class="normal">Empty slices are valid arguments to <code class="inlineCode">.iloc</code>. Both <code class="inlineCode">ser.iloc[:]</code> and <code class="inlineCode">df.iloc[:, :]</code> will return everything from each axis, essentially giving you a copy of the object.</p>
    <h1 id="_idParaDest-49" class="heading-1">Label-based selection from a Series</h1>
    <p class="normal">In pandas, <code class="inlineCode">pd.Series.loc</code> is <a id="_idIndexMarker036"/>used to perform selection by label instead of by position. This method is particularly useful when you consider the <code class="inlineCode">pd.Index</code> of your <code class="inlineCode">pd.Series</code> to contain lookup values, much like the key in a Python dictionary, rather than giving importance to the order or position of data in your <code class="inlineCode">pd.Series</code>.</p>
    <h2 id="_idParaDest-50" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.Series</code> where we have a row index using integral labels that are also non-unique:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series([<span class="hljs-string">"apple"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"orange"</span>], index=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>])
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     apple
1    banana
1    orange
dtype: object
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.Series.loc</code> will select all rows where the index has a label of 1:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[<span class="hljs-number">1</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1    banana
1    orange
dtype: object
</code></code></pre>
    <p class="normal">Of course, you are not limited to integral labels in pandas. Let’s see what this looks like with a <code class="inlineCode">pd.Index</code> composed of string values:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>], index=[<span class="hljs-string">"dog"</span>, <span class="hljs-string">"</span><span class="hljs-string">cat"</span>, <span class="hljs-string">"human"</span>], name=<span class="hljs-string">"num_legs"</span>)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">dog      2
cat      2
human    4
Name: num_legs, dtype: int64
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.Series.loc</code> can select all rows where the index has a label of <code class="inlineCode">"dog"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[<span class="hljs-string">"dog"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2
</code></code></pre>
    <p class="normal">To select all rows where the index has a label of <code class="inlineCode">"dog"</code> or <code class="inlineCode">"cat"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[[<span class="hljs-string">"dog"</span>, <span class="hljs-string">"cat"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">dog    2
cat    2
Name: num_legs, dtype: int64
</code></code></pre>
    <p class="normal">Finally, to select all <a id="_idIndexMarker037"/>rows up to and including the label <code class="inlineCode">"cat"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[:<span class="hljs-string">"cat"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">dog    2
cat    2
Name: num_legs, dtype: int64
</code></code></pre>
    <h2 id="_idParaDest-51" class="heading-2">There’s more…</h2>
    <p class="normal">Understanding label-based selection with <code class="inlineCode">pd.Series.loc</code> provides powerful capabilities to access and manipulate data in a <code class="inlineCode">pd.Series</code>. While this method may seem straightforward, it offers nuances and behaviors that are important to grasp for effective data handling.</p>
    <p class="normal">A very common mistake for users of all experience levels with pandas is to overlook the differences in behavior that slicing with <code class="inlineCode">pd.Series.loc</code> has, compared to slicing in standard Python and the <code class="inlineCode">pd.Series.iloc</code> case.</p>
    <p class="normal">To walk through this, let’s create a small Python list and a <code class="inlineCode">pd.Series</code> with the same data:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">values = [<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"</span><span class="hljs-string">Jill"</span>, <span class="hljs-string">"Jayne"</span>]
ser = pd.Series(values)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     Jack
1     Jill
2    Jayne
dtype: object
</code></code></pre>
    <p class="normal">As you have already seen with lists and other containers built into the Python language, slicing returns values up to <em class="italic">but not including</em> the provided position:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">values[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack    Jill
</code></code></pre>
    <p class="normal">Slicing with <code class="inlineCode">pd.Series.iloc</code> matches this behavior, returning a <code class="inlineCode">pd.Series</code> with the same exact length and<a id="_idIndexMarker038"/> elements as the Python list:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.iloc[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    Jack
1    Jill
dtype: object
</code></code></pre>
    <p class="normal">But slicing with <code class="inlineCode">pd.Series.loc</code> actually produces a different result:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0     Jack
1     Jill
2    Jayne
dtype: object
</code></code></pre>
    <p class="normal">What is going on here? To try and get a grasp on this, it is important to remember that <code class="inlineCode">pd.Series.loc</code> matches by label, not by position. The pandas library does something akin to a loop over each element in the <code class="inlineCode">pd.Series</code> and its accompanying <code class="inlineCode">pd.Index</code>, stopping at the point where it finds the value of 2 in the index. However, pandas cannot guarantee that there is only one value in the <code class="inlineCode">pd.Index</code> with the value of 2, so it must continue going until it finds <em class="italic">something else</em>. You can see that in action if you try the same selection with a <code class="inlineCode">pd.Series</code> that repeats the index label 2:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">repeats_2 = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>), index=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])
repeats_2.loc[:<span class="hljs-number">2</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    0
1    1
2    2
2    3
dtype: int64
</code></code></pre>
    <p class="normal">This can seem downright devious if you expect your row index to contain integers, but the main use case for <code class="inlineCode">pd.Series.loc</code> is for working with a <code class="inlineCode">pd.Index</code> where position/ordering is not important (for that, use <code class="inlineCode">pd.Series.iloc</code>). Taking string labels as a more practical example, the slicing behavior of <code class="inlineCode">pd.Series.loc</code> becomes more natural. The following code can essentially be thought of as asking pandas to loop over the <code class="inlineCode">pd.Series</code> until the label <code class="inlineCode">"xxx"</code> is found<a id="_idIndexMarker039"/> in the row index, continuing until a new label is found:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>), index=[<span class="hljs-string">"zzz"</span>, <span class="hljs-string">"xxx"</span>, <span class="hljs-string">"xxx"</span>, <span class="hljs-string">"yyy"</span>])
ser.loc[:<span class="hljs-string">"xxx"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">zzz    0
xxx    1
xxx    2
dtype: int64
</code></code></pre>
    <p class="normal">In certain cases where<a id="_idIndexMarker040"/> you try to slice with <code class="inlineCode">pd.Series.loc</code> but the index labels have no determinate ordering, pandas will end up raising an error:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>), index=[<span class="hljs-string">"zzz"</span>, <span class="hljs-string">"xxx"</span>, <span class="hljs-string">"yyy"</span>, <span class="hljs-string">"xxx"</span>])
ser.loc[:<span class="hljs-string">"xxx"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">KeyError: "Cannot get right slice bound for non-unique label: 'xxx'"
</code></code></pre>
    <h1 id="_idParaDest-52" class="heading-1">Label-based selection from a DataFrame</h1>
    <p class="normal">As we discussed <a id="_idIndexMarker041"/>back in the <em class="italic">Position-based selection of a DataFrame</em> section, the most common use case with a <code class="inlineCode">pd.DataFrame</code> is to use label-based selection when referring to columns and position-based selection when referring to rows. However, this is not an absolute requirement, and pandas allows you to use label-based selection from both the rows and columns.</p>
    <p class="normal">When compared to other data analysis tools, the ability to select by label from the rows of a <code class="inlineCode">pd.DataFrame</code> is a unique advantage to pandas. For users familiar with SQL, there is no real equivalent to this provided by the language; columns are very easy to select when placed in a <code class="inlineCode">SELECT</code> clause, but rows can only be filtered via a <code class="inlineCode">WHERE</code> clause. For users adept at Microsoft Excel, you could create two-dimensional structures using a pivot table, with both row labels and column labels, but your ability to select or refer to data within that pivot table is effectively limited.</p>
    <p class="normal">For now, we will introduce selection for very small <code class="inlineCode">pd.DataFrame</code> objects to get a feel for the syntax. In <em class="chapterRef">Chapter 8</em>, <em class="italic">Reshaping Data Frames</em>, we will explore ways that you can create meaningful <code class="inlineCode">pd.DataFrame</code> objects where row and column labels are significant. Combined with the knowledge introduced in this section, you will come to appreciate how unique this type of selection is to pandas, as well as how it can help you explore data in meaningful ways that other tools cannot express.</p>
    <h2 id="_idParaDest-53" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.DataFrame</code> where we have indices composed of strings in both the rows and columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    [<span class="hljs-number">24</span>, <span class="hljs-number">180</span>, <span class="hljs-string">"blue"</span>],
    [<span class="hljs-number">42</span>, <span class="hljs-number">166</span>, <span class="hljs-string">"brown"</span>],
    [<span class="hljs-number">22</span>, <span class="hljs-number">160</span>, <span class="hljs-string">"green"</span>],
], columns=[<span class="hljs-string">"age"</span>, <span class="hljs-string">"height_cm"</span>, <span class="hljs-string">"eye_color"</span>], index=[<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Jill"</span>, <span class="hljs-string">"Jayne"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">        age    height_cm    eye_color
Jack    24     180          blue
Jill    42     166          brown
Jayne   22     160          green
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.DataFrame.loc</code> can select by the row and column label:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[<span class="hljs-string">"Jayne"</span>, <span class="hljs-string">"eye_color"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">green
</code></code></pre>
    <p class="normal">To select all rows from the column with the label <code class="inlineCode">"age"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[:, <span class="hljs-string">"age"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack     24
Jill     42
Jayne    22
Name: age, dtype: int64
</code></code></pre>
    <p class="normal">To select all columns<a id="_idIndexMarker042"/> from the row with the label <code class="inlineCode">"Jack"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[<span class="hljs-string">"Jack"</span>, :]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">age            24
height_cm     180
eye_color    blue
Name: Jack, dtype: object
</code></code></pre>
    <p class="normal">To select all rows from the column with the label <code class="inlineCode">"age"</code>, maintaining the <code class="inlineCode">pd.DataFrame</code> shape:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[:, [<span class="hljs-string">"age"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">         age
Jack     24
Jill     42
Jayne    22
</code></code></pre>
    <p class="normal">To select all columns from the row with the label <code class="inlineCode">"Jack"</code>, maintaining the <code class="inlineCode">pd.DataFrame</code> shape:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[[<span class="hljs-string">"Jack"</span>], :]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">        age   height_cm    eye_color
Jack    24    180          blue
</code></code></pre>
    <p class="normal">To select both<a id="_idIndexMarker043"/> rows and columns using lists of labels:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[[<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Jill"</span>], [<span class="hljs-string">"age"</span>, <span class="hljs-string">"eye_color"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">        age   eye_color
Jack    24    blue
Jill    42    brown
</code></code></pre>
    <h1 id="_idParaDest-54" class="heading-1">Mixing position-based and label-based selection</h1>
    <p class="normal">Since <code class="inlineCode">pd.DataFrame.iloc</code> is used for position-based selection and <code class="inlineCode">pd.DataFrame.loc</code> is for label-based <a id="_idIndexMarker044"/>selection, users must<a id="_idIndexMarker045"/> take an extra step if attempting to select by label in one dimension and by position in another. As mentioned in previous sections, the majority of <code class="inlineCode">pd.DataFrame</code> objects constructed will place heavy significance on the labels used for the columns, with little care for how those columns are ordered. The inverse is true for the rows, so being able to effectively mix and match both styles is of immense value.</p>
    <h2 id="_idParaDest-55" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start with a <code class="inlineCode">pd.DataFrame</code> that uses the default auto-numbered <code class="inlineCode">pd.RangeIndex</code> in the rows but has custom string labels for the columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    [<span class="hljs-number">24</span>, <span class="hljs-number">180</span>, <span class="hljs-string">"blue"</span>],
    [<span class="hljs-number">42</span>, <span class="hljs-number">166</span>, <span class="hljs-string">"brown"</span>],
    [<span class="hljs-number">22</span>, <span class="hljs-number">160</span>, <span class="hljs-string">"green"</span>],
], columns=[<span class="hljs-string">"age"</span>, <span class="hljs-string">"height_cm"</span>, <span class="hljs-string">"eye_color"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     age   height_cm    eye_color
0    24    180          blue
1    42    166          brown
2    22    160          green
</code></code></pre>
    <p class="normal">The <code class="inlineCode">pd.Index.get_indexer</code> method can help us convert a label or list of labels into their corresponding positions in a <code class="inlineCode">pd.Index</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">col_idxer = df.columns.get_indexer([<span class="hljs-string">"age"</span>, <span class="hljs-string">"eye_color"</span>])
col_idxer
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">array([0, 2])
</code></code></pre>
    <p class="normal">This can subsequently be used as an argument to <code class="inlineCode">.iloc</code>, ensuring that you use position-based selection across both the rows and columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], col_idxer]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     age    eye_color
0    24     blue
1    42     brown
</code></code></pre>
    <h2 id="_idParaDest-56" class="heading-2">There’s more…</h2>
    <p class="normal">Instead of using <code class="inlineCode">pd.Index.get_indexer</code>, you can split this expression up into a few steps, with one <a id="_idIndexMarker046"/>of <a id="_idIndexMarker047"/>the steps performing index-based selection and the other performing label-based selection. And if you did this, you’d end up getting the exact same result as shown above:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[[<span class="hljs-string">"age"</span>, <span class="hljs-string">"eye_color"</span>]].iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">     age    eye_color
0    24     blue
1    42     brown
</code></code></pre>
    <p class="normal">There’s a strong argument to be made that this is more expressive than using <code class="inlineCode">pd.Index.get_indexer</code>, which developers of all experience levels with pandas would agree with. So why even bother with <code class="inlineCode">pd.Index.get_indexer</code>?</p>
    <p class="normal">While these appear the same on the surface, how pandas computes the result is drastically different. Adding some timing benchmarks to the various methods should highlight this. While the exact numbers will vary on your machine, compare the timing output of the idiomatic approach described in this section:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">import timeit
def get_indexer_approach():
  col_idxer = df.columns.get_indexer([<span class="hljs-string">"age"</span>, <span class="hljs-string">"eye_color"</span>])
  df.iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], col_idxer]
timeit.timeit(get_indexer_approach, number=<span class="hljs-number">10</span>_<span class="hljs-number">000</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1.8184850879988517
</code></code></pre>
    <p class="normal">to the approach with separate steps to select by label and then by position:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">two_step_approach = lambda: df[[<span class="hljs-string">"age"</span>, <span class="hljs-string">"eye_color"</span>]].iloc[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]
timeit.timeit(two_step_approach, number=<span class="hljs-number">10</span>_<span class="hljs-number">000</span>
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2.027099569000711
</code></code></pre>
    <p class="normal">The <code class="inlineCode">pd.Index.get_indexer</code> approach clocks in faster and should scale better to larger datasets. The reason for this is that pandas evaluates its expressions <em class="italic">eagerly</em> or, more specifically, it will do <em class="italic">what you say, when you say it</em>. The expression <code class="inlineCode">df[["age", "eye_color"]].iloc[[0, 1]]</code> first runs <code class="inlineCode">df[["age", "eye_color"]]</code>, which creates an intermediate <code class="inlineCode">pd.DataFrame</code>, to which the <code class="inlineCode">.iloc[[0, 1]]</code> gets applied. By contrast, the expression <code class="inlineCode">df.iloc[[0, 1], col_idxer]</code> performs the label-based and position-based selection all in one go, avoiding the creation of any intermediate <code class="inlineCode">pd.DataFrame</code>.</p>
    <p class="normal">The contrasting approach to the <em class="italic">eager execution</em> approach that pandas takes is often called <em class="italic">lazy execution</em>. If you’ve used SQL before, the latter is a good example of that; you typically do not instruct the SQL engine on what steps to take exactly to produce the desired result. Instead, you <em class="italic">declare</em> what you want your result to look like and leave it up to the SQL database to optimize and execute your query.</p>
    <p class="normal">Will pandas ever support lazy evaluation and optimization? I would posit yes, as it would help pandas scale to larger datasets and take the onus away from the end user to write optimal queries. However, that capability does not exist today, so it is still important for you as a user of the library to understand if the code you produce will be processed efficiently or inefficiently.</p>
    <p class="normal">It is also worth considering the context of your data analysis when deciding if it is worth trying to combine position/label-based selection in one step, or if they are fine as separate steps. In our<a id="_idIndexMarker048"/> trivial <a id="_idIndexMarker049"/>example, the runtime difference of <code class="inlineCode">df.iloc[[0, 1], col_idxer]</code> versus <code class="inlineCode">df[["age", "eye_color"]].iloc[[0, 1]]</code> is probably not worth caring about in the grander scheme of things, but if you were dealing with larger datasets and bottlenecked by performance, the former approach could be a lifesaver.</p>
    <h1 id="_idParaDest-57" class="heading-1">DataFrame.filter</h1>
    <p class="normal"><code class="inlineCode">pd.DataFrame.filter</code> is a specialized<a id="_idIndexMarker050"/> method that allows you to select from either the rows or columns of a <code class="inlineCode">pd.DataFrame</code>.</p>
    <h2 id="_idParaDest-58" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.DataFrame</code> where we have indices composed of strings in both the rows and columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    [<span class="hljs-number">24</span>, <span class="hljs-number">180</span>, <span class="hljs-string">"blue"</span>],
    [<span class="hljs-number">42</span>, <span class="hljs-number">166</span>, <span class="hljs-string">"brown"</span>],
    [<span class="hljs-number">22</span>, <span class="hljs-number">160</span>, <span class="hljs-string">"green"</span>],
], columns=[
    <span class="hljs-string">"age"</span>,
    <span class="hljs-string">"height_cm"</span>,
    <span class="hljs-string">"eye_color"</span>
], index=[<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Jill"</span>, <span class="hljs-string">"Jayne"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">        age   height_cm   eye_color
Jack    24    180         blue
Jill    42    166         brown
Jayne   22    160         green
</code></code></pre>
    <p class="normal">By default, <code class="inlineCode">pd.DataFrame.filter</code> will select columns matching the label argument(s), similar to <code class="inlineCode">pd.DataFrame[]</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.<span class="hljs-built_in">filter</span>([<span class="hljs-string">"age"</span>, <span class="hljs-string">"eye_color"</span>])
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       age   eye_color
Jack   24    blue
Jill   42    brown
Jayne  22    green
</code></code></pre>
    <p class="normal">However, <code class="inlineCode">pd.DataFrame.filter</code> also accepts an <code class="inlineCode">axis=</code> argument, which allows you to change the axis being selected from. To select rows instead of columns, pass <code class="inlineCode">axis=0</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.<span class="hljs-built_in">filter</span>([<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Jill"</span>], axis=<span class="hljs-number">0</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">  age   height_cm   eye_color
Jack   24    180         blue
Jill   42    166         brown
</code></code></pre>
    <p class="normal">You are not limited to exact string matches against labels. If you would like to select any label containing a string, use the <code class="inlineCode">like=</code> parameter. This example will select any column containing an underscore:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.<span class="hljs-built_in">filter</span>(like=<span class="hljs-string">"_"</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">      height_cm   eye_color
Jack   180         blue
Jill   166         brown
Jayne  160         green
</code></code></pre>
    <p class="normal">If simple string containment is not enough, you can also use regular expressions to match index labels with the <code class="inlineCode">regex=</code> parameter. The following example will select any row labels that<a id="_idIndexMarker051"/> start with a <code class="inlineCode">"Ja"</code> but do not end with <code class="inlineCode">"e"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.<span class="hljs-built_in">filter</span>(regex=<span class="hljs-string">r"^Ja.*(?&lt;!e)$"</span>, axis=<span class="hljs-number">0</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       age   height_cm   eye_color
Jack   24    180         blue
</code></code></pre>
    <h1 id="_idParaDest-59" class="heading-1">Selection by data type</h1>
    <p class="normal">So far in this <a id="_idIndexMarker052"/>cookbook, we have <em class="italic">seen</em> data types, but we have not talked too much in depth about what they are. We still aren’t quite there; a deep dive into the type system of pandas is reserved for <em class="chapterRef">Chapter 3</em>, <em class="italic">Data Types</em>. However, for now, you should be aware that the column type provides metadata that <code class="inlineCode">pd.DataFrame.select_dtypes</code> can use for selection.</p>
    <h2 id="_idParaDest-60" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start with a <code class="inlineCode">pd.DataFrame</code> that uses integral, floating point, and string columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    [<span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-string">"2"</span>],
    [<span class="hljs-number">4</span>, <span class="hljs-number">8.0</span>, <span class="hljs-string">"16"</span>],
], columns=[<span class="hljs-string">"int_col"</span>, <span class="hljs-string">"float_col"</span>, <span class="hljs-string">"string_col"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    int_col   float_col   string_col
0   0         1.0         2
1   4         8.0         16
</code></code></pre>
    <p class="normal">Use <code class="inlineCode">pd.DataFrame.select_dtypes</code> to select only integral columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(<span class="hljs-string">"int"</span>)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    int_col
0   0
1   4
</code></code></pre>
    <p class="normal">Multiple types can be selected if you pass a list argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(include=[<span class="hljs-string">"int"</span>, <span class="hljs-string">"float"</span>])
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    int_col   float_col
0   0         1.0
1   4         8.0
</code></code></pre>
    <p class="normal">The default behavior is to<a id="_idIndexMarker053"/> include the data types you pass in as an argument. To exclude them, use the <code class="inlineCode">exclude=</code> parameter instead:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(exclude=[<span class="hljs-string">"int"</span>, <span class="hljs-string">"float"</span>])
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    string_col
0   2
1   16
</code></code></pre>
    <h1 id="_idParaDest-61" class="heading-1">Selection/filtering via Boolean arrays</h1>
    <p class="normal">Using <a id="_idIndexMarker054"/>Boolean lists/arrays (also referred to as <em class="italic">masks</em>) is a very <a id="_idIndexMarker055"/>common method <a id="_idIndexMarker056"/>to select a subset of rows.</p>
    <h2 id="_idParaDest-62" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a mask of <code class="inlineCode">True=/=False</code> values alongside a simple <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">mask = [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>]
ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    0
1    1
2    2
dtype: int64
</code></code></pre>
    <p class="normal">Using the mask as an argument to <code class="inlineCode">pd.Series[]</code> will return each row where the corresponding mask entry is <code class="inlineCode">True</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser[mask]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    0
2    2
dtype: int64
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.Series.loc</code> will match the exact same behavior as <code class="inlineCode">pd.Series[]</code> in this particular case:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[mask]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0    0
2    2
dtype: int64
</code></code></pre>
    <p class="normal">Interestingly, whereas <code class="inlineCode">pd.DataFrame[]</code> usually tries to select from the columns when provided a list argument, its behavior with a sequence of Boolean values is different. Using the mask we have already created, <code class="inlineCode">df[mask]</code> will actually match along the rows rather than the columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame(np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>))
df[mask]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    0   1
0   0   1
2   4   5
</code></code></pre>
    <p class="normal">If you need to<a id="_idIndexMarker057"/> mask <a id="_idIndexMarker058"/>the columns alongside the rows, <code class="inlineCode">pd.DataFrame.loc</code> will accept two mask arguments:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">col_mask = [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]
df.loc[mask, col_mask]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    0
0   0
2   4
</code></code></pre>
    <h2 id="_idParaDest-63" class="heading-2">There’s more…</h2>
    <p class="normal">Commonly, you will <a id="_idIndexMarker059"/>manipulate your masks using some combination of the OR, AND, or INVERT operators. To see these in action, let’s start with a slightly more complicated <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    [<span class="hljs-number">24</span>, <span class="hljs-number">180</span>, <span class="hljs-string">"blue"</span>],
    [<span class="hljs-number">42</span>, <span class="hljs-number">166</span>, <span class="hljs-string">"brown"</span>],
    [<span class="hljs-number">22</span>, <span class="hljs-number">160</span>, <span class="hljs-string">"green"</span>],
], columns=[<span class="hljs-string">"age"</span>, <span class="hljs-string">"height_cm"</span>, <span class="hljs-string">"eye_color"</span>], index=[<span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Jill"</span>, <span class="hljs-string">"Jayne"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       age   height_cm   eye_color
Jack   24    180         blue
Jill   42    166         brown
Jayne  22    160         green
</code></code></pre>
    <p class="normal">If our goal was to filter this only to users with blue or green eyes, we could first identify which users have blue eyes:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">blue_eyes = df[<span class="hljs-string">"eye_color"</span>] == <span class="hljs-string">"blue"</span>
blue_eyes
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack      True
Jill     False
Jayne    False
Name: eye_color, dtype: bool
</code></code></pre>
    <p class="normal">Then, we figure out who has green eyes:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">green_eyes = df[<span class="hljs-string">"eye_color"</span>] == <span class="hljs-string">"green"</span>
green_eyes
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack     False
Jill     False
Jayne     True
Name: eye_color, dtype: bool
</code></code></pre>
    <p class="normal">and combine those together into one Boolean <em class="italic">mask</em> using the OR operator, <code class="inlineCode">|</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">mask = blue_eyes | green_eyes
mask
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack      True
Jill     False
Jayne     True
Name: eye_color, dtype: bool
</code></code></pre>
    <p class="normal">before passing that mask in as an indexer of our <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[mask]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       age   height_cm   eye_color
Jack   24    180         blue
Jayne  22    160         green
</code></code></pre>
    <p class="normal">Instead of using<a id="_idIndexMarker060"/> the<a id="_idIndexMarker061"/> OR <a id="_idIndexMarker062"/>operator, <code class="inlineCode">|</code>, you will often commonly use the AND operator, <code class="inlineCode">&amp;</code>. For example, let’s create a filter for records with an age less than 40:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">age_lt_40 = df[<span class="hljs-string">"</span><span class="hljs-string">age"</span>] &lt; <span class="hljs-number">40</span>
age_lt_40
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack      True
Jill     False
Jayne     True
Name: age, dtype: bool
</code></code></pre>
    <p class="normal">And also, a height greater than 170:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">height_gt_170 = df[<span class="hljs-string">"height_cm"</span>] &gt; <span class="hljs-number">170</span>
height_gt_170
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Jack      True
Jill     False
Jayne    False
Name: height_cm, dtype: bool
</code></code></pre>
    <p class="normal">These can be ANDed together to only select records that meet both conditions:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[age_lt_40 &amp; height_gt_170]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       age   height_cm   eye_color
Jack   24    180         blue
</code></code></pre>
    <p class="normal">The INVERT operator is useful to think of as a NOT operator; i.e., in the context of a mask, it will make any <code class="inlineCode">True</code> value <code class="inlineCode">False</code> and any <code class="inlineCode">False</code> value <code class="inlineCode">True</code>. Continuing with our example above, if we wanted to find records that did not satisfy the condition of having an age under 40 and <a id="_idIndexMarker063"/>a height over 170, we could simply <a id="_idIndexMarker064"/>invert our <a id="_idIndexMarker065"/>mask using <code class="inlineCode">~</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[~(age_lt_40 &amp; height_gt_170)]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       age   height_cm   eye_color
Jill   42    166         brown
Jayne  22    160         green
</code></code></pre>
    <h1 id="_idParaDest-64" class="heading-1">Selection with a MultiIndex – A single level</h1>
    <p class="normal">A <code class="inlineCode">pd.MultiIndex</code> is a <a id="_idIndexMarker066"/>subclass of a <code class="inlineCode">pd.Index</code> that supports hierarchical labels. Depending on who you ask, this can be one of the best or one of the worst features of pandas. After reading this cookbook, I hope you consider it one of the best.</p>
    <p class="normal">Much of the derision toward the <code class="inlineCode">pd.MultiIndex</code> comes from the fact that the syntax used to select from it can easily become ambiguous, especially when using <code class="inlineCode">pd.DataFrame[]</code>. The examples below exclusively use the <code class="inlineCode">pd.DataFrame.loc</code> method and avoid <code class="inlineCode">pd.DataFrame[]</code> to mitigate confusion.</p>
    <h2 id="_idParaDest-65" class="heading-2">How to do it</h2>
    <p class="normal"><code class="inlineCode">pd.MultiIndex.from_tuples</code> can be used to construct a <code class="inlineCode">pd.MultiIndex</code> from a list of tuples. In the following example, we create a <code class="inlineCode">pd.MultiIndex</code> with two levels – <code class="inlineCode">first_name</code> and <code class="inlineCode">last_name</code>, sequentially. We will pair this alongside a very simple <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">index = pd.MultiIndex.from_tuples([
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Smith"</span>),
    (<span class="hljs-string">"</span><span class="hljs-string">John"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Jane"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Stephen"</span>, <span class="hljs-string">"Smith"</span>),
], names=[<span class="hljs-string">"first_name"</span>, <span class="hljs-string">"last_name"</span>])
ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>), index=index)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Smith        0
            Doe          1
Jane        Doe          2
Stephen     Smith        3
dtype: int64
</code></code></pre>
    <p class="normal">Using <code class="inlineCode">pd.Series.loc</code> with a <code class="inlineCode">pd.MultiIndex</code> and a scalar argument will match against the first level of the <code class="inlineCode">pd.MultiIndex</code>. The output will not include this first level in its result:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[<span class="hljs-string">"John"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">last_name
Smith    0
Doe      1
dtype: int64
</code></code></pre>
    <p class="normal">The behavior that drops the first level of the <code class="inlineCode">pd.MultiIndex</code> in the above example is also referred to as <em class="italic">partial slicing</em>. This concept is similar to the dimensionality reduction we saw with <code class="inlineCode">.loc</code> and <code class="inlineCode">.iloc</code> in the previous sections, with the exception that instead of reducing <em class="italic">dimensions</em>, pandas here tries to reduce the number of <em class="italic">levels</em> in a <code class="inlineCode">pd.MultiIndex</code>.</p>
    <p class="normal">To prevent this implicit level reduction from occurring, we can once again provide a list argument containing <a id="_idIndexMarker067"/>a single element:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[[<span class="hljs-string">"John"</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Smith        0
            Doe          1
dtype: int64
</code></code></pre>
    <h1 id="_idParaDest-66" class="heading-1">Selection with a MultiIndex – Multiple levels</h1>
    <p class="normal">Things would not be <a id="_idIndexMarker068"/>that interesting if you could only select from the first level of a <code class="inlineCode">pd.MultiIndex</code>. Fortunately, <code class="inlineCode">pd.DataFrame.loc</code> will scale out to more than just the first level through the creative use of tuple arguments.</p>
    <h2 id="_idParaDest-67" class="heading-2">How to do it</h2>
    <p class="normal">Let’s recreate the <code class="inlineCode">pd.Series</code> from the previous section:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">index = pd.MultiIndex.from_tuples([
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Smith"</span>),
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Jane"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Stephen"</span>, <span class="hljs-string">"Smith"</span>),
], names=[<span class="hljs-string">"first_name"</span>, <span class="hljs-string">"</span><span class="hljs-string">last_name"</span>])
ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>), index=index)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Smith        0
            Doe          1
Jane        Doe          2
Stephen     Smith        3
dtype: int64
</code></code></pre>
    <p class="normal">To select all records where the first index level uses the label <code class="inlineCode">"Jane"</code> and the second uses <code class="inlineCode">"Doe"</code>, pass the following tuple:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[(<span class="hljs-string">"Jane"</span>, <span class="hljs-string">"Doe"</span>)]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2
</code></code></pre>
    <p class="normal">To select all records where the first index level uses the label <code class="inlineCode">"Jane"</code> and the second uses <code class="inlineCode">"Doe"</code>, while maintaining the <code class="inlineCode">pd.MultiIndex</code> shape, place a single element list in the tuple:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[([<span class="hljs-string">"Jane"</span>], <span class="hljs-string">"</span><span class="hljs-string">Doe"</span>)]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
Jane        Doe          2
dtype: int64
</code></code></pre>
    <p class="normal">To select all records where the first index level uses the label <code class="inlineCode">"John"</code> and the second uses the label <code class="inlineCode">"Smith"</code>, OR the first level is <code class="inlineCode">"Jane"</code> and the second is <code class="inlineCode">"Doe"</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[[(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Smith"</span>), (<span class="hljs-string">"Jane"</span>, <span class="hljs-string">"Doe"</span>)]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Smith        0
Jane        Doe          2
dtype: int64
</code></code></pre>
    <p class="normal">To select all records<a id="_idIndexMarker069"/> where the second index level is <code class="inlineCode">"Doe"</code>, use an empty slice as the first tuple element. Note that this drops the second index level and reconstructs the result with a simple <code class="inlineCode">pd.Index</code> from the first index level that remains:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[(<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), <span class="hljs-string">"Doe"</span>)]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name
John    1
Jane    2
dtype: int64
</code></code></pre>
    <p class="normal">To select all records where the second index level is <code class="inlineCode">"Doe"</code> while maintaining the <code class="inlineCode">pd.MultiIndex</code> shape, pass a single-element list as the second tuple element:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[(<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), [<span class="hljs-string">"Doe"</span>])]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Doe          1
Jane        Doe          2
dtype: int64
</code></code></pre>
    <p class="normal">At this point, you might be asking yourself the question, what the heck does <code class="inlineCode">slice(None)</code> mean? This rather cryptic expression actually creates a slice object without a <em class="italic">start</em>, <em class="italic">stop</em>, or <em class="italic">step</em> value, which is easier to illustrate with a simpler Python list – note that the behavior here:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">alist = <span class="hljs-built_in">list</span>(<span class="hljs-string">"abc"</span>)
alist[:]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">['a', 'b', 'c']
</code></code></pre>
    <p class="normal">is exactly the same as with <code class="inlineCode">slice(None)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">alist[<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>)]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">['a', 'b', 'c']
</code></code></pre>
    <p class="normal">When a <code class="inlineCode">pd.MultiIndex</code> expects a tuple argument but doesn’t get one, this issue is caused by a slice within a tuple, similar to how <code class="inlineCode">(:,)</code> is a syntax error in Python. The more <a id="_idIndexMarker070"/>explicit <code class="inlineCode">(slice(None),)</code> fixes the issue.</p>
    <h2 id="_idParaDest-68" class="heading-2">There’s more…</h2>
    <p class="normal">If you find the <code class="inlineCode">slice(None)</code> syntax to be unwieldy, pandas provides a convenient object called the <code class="inlineCode">pd.IndexSlice</code> that acts like a tuple but allows you to use the more natural <code class="inlineCode">:</code> notation for slicing.</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[(<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), [<span class="hljs-string">"</span><span class="hljs-string">Doe"</span>])]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Doe          1
Jane        Doe          2
dtype: int64
</code></code></pre>
    <p class="normal">thus can become:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ixsl = pd.IndexSlice
ser.loc[ixsl[:, [<span class="hljs-string">"Doe"</span>]]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">first_name  last_name
John        Doe          1
Jane        Doe          2
dtype: int64
</code></code></pre>
    <h1 id="_idParaDest-69" class="heading-1">Selection with a MultiIndex – a DataFrame</h1>
    <p class="normal">A <code class="inlineCode">pd.MultiIndex</code> can be <a id="_idIndexMarker071"/>used both as a row index and a column index, and selection via <code class="inlineCode">pd.DataFrame.loc</code> works with both.</p>
    <h2 id="_idParaDest-70" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.DataFrame</code> that uses a <code class="inlineCode">pd.MultiIndex</code> in both the rows and columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">row_index = pd.MultiIndex.from_tuples([
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Smith"</span>),
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Jane"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Stephen"</span>, <span class="hljs-string">"Smith"</span>),
], names=[<span class="hljs-string">"first_name"</span>, <span class="hljs-string">"last_name"</span>])
col_index = pd.MultiIndex.from_tuples([
    (<span class="hljs-string">"music"</span>, <span class="hljs-string">"favorite"</span>),
    (<span class="hljs-string">"music"</span>, <span class="hljs-string">"last_seen_live"</span>),
    (<span class="hljs-string">"art"</span>, <span class="hljs-string">"favorite"</span>),
], names=[<span class="hljs-string">"art_type"</span>, <span class="hljs-string">"category"</span>])
df = pd.DataFrame([
   [<span class="hljs-string">"Swift"</span>, <span class="hljs-string">"Swift"</span>, <span class="hljs-string">"Matisse"</span>],
   [<span class="hljs-string">"Mozart"</span>, <span class="hljs-string">"T. Swift"</span>, <span class="hljs-string">"Van Gogh"</span>],
   [<span class="hljs-string">"Beatles"</span>, <span class="hljs-string">"Wonder"</span>, <span class="hljs-string">"Warhol"</span>],
   [<span class="hljs-string">"Jackson"</span>, <span class="hljs-string">"Dylan"</span>, <span class="hljs-string">"Picasso"</span>],
], index=row_index, columns=col_index)
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">             art_type              music           art
             category   favorite   last_seen_live  favorite
first_name   last_name
John         Smith      Swift      Swift           Matisse
             Doe        Mozart     T. Swift        Van Gogh
Jane         Doe        Beatles    Wonder          Warhol
Stephen      Smith      Jackson    Dylan           Picasso
</code></code></pre>
    <p class="normal">To select all rows where the second level is <code class="inlineCode">"Smith"</code> and all columns where the second level is <code class="inlineCode">"favorite"</code>, you will need to pass two tuples where the second element in each is the desired label:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">row_idxer = (<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), <span class="hljs-string">"Smith"</span>)
col_idxer = (<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), <span class="hljs-string">"favorite"</span>)
df.loc[row_idxer, col_idxer]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">             art_type   music      art
             category   favorite   favorite
first_name   last_name
John         Smith      Swift      Matisse
Stephen      Smith      Jackson    Picasso
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.DataFrame.loc</code> always requires two arguments – the first to specify how the rows should be indexed and the second to specify how the columns should be indexed. When you have a <code class="inlineCode">pd.DataFrame</code> with a <code class="inlineCode">pd.MultiIndex</code> in both the rows and the columns, you may find it stylistically easier to create separate variables for the indexers. The above code could have also been written as:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[(<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), <span class="hljs-string">"Smith"</span>), (<span class="hljs-built_in">slice</span>(<span class="hljs-literal">None</span>), <span class="hljs-string">"favorite"</span>)]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">             art_type   music      art
             category   favorite   favorite
first_name   last_name
John         Smith      Swift      Matisse
Stephen      Smith      Jackson    Picasso
</code></code></pre>
    <p class="normal">Although you could<a id="_idIndexMarker072"/> argue that this is more difficult to interpret. As the old saying goes, beauty is in the eye of the beholder.</p>
    <h1 id="_idParaDest-71" class="heading-1">Item assignment with .loc and .iloc</h1>
    <p class="normal">The pandas library is<a id="_idIndexMarker073"/> optimized for reading, exploring, and<a id="_idIndexMarker074"/> evaluating <a id="_idIndexMarker075"/>data. Operations that try to <em class="italic">mutate</em> or change data are far less efficient.</p>
    <p class="normal">However, when you must mutate your data, you can use <code class="inlineCode">.loc</code> and <code class="inlineCode">.iloc</code> to do it.</p>
    <h2 id="_idParaDest-72" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start with a very small <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>), index=<span class="hljs-built_in">list</span>(<span class="hljs-string">"abc"</span>))
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.Series.loc</code> is useful when you want to assign a value by matching against the label of an index. For example, if we wanted to store the value <code class="inlineCode">42</code> where our row index contained a value of <code class="inlineCode">"b"</code>, we would write:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.loc[<span class="hljs-string">"b"</span>] = <span class="hljs-number">42</span>
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">a     0
b    42
c     2
dtype: int64
</code></code></pre>
    <p class="normal"><code class="inlineCode">pd.Series.iloc</code> is used when you want to assign a value positionally. To assign the value <code class="inlineCode">-42</code> to the second element in our <code class="inlineCode">pd.Series</code>, we would write:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.iloc[<span class="hljs-number">2</span>] = -<span class="hljs-number">42</span>
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">a     0
b    42
c   -42
dtype: int64
</code></code></pre>
    <h2 id="_idParaDest-73" class="heading-2">There’s more…</h2>
    <p class="normal">The cost of mutating data through pandas can depend largely on two factors:</p>
    <ul>
      <li class="bulletList">The type of array backing a pandas <code class="inlineCode">pd.Series</code> (<em class="chapterRef">Chapter 3</em>, <em class="italic">Data Types</em>, will cover data types in more detail)</li>
      <li class="bulletList">How many objects reference a <code class="inlineCode">pd.Series</code></li>
    </ul>
    <p class="normal">A deep dive into those factors is far beyond the scope of this book. For the first point above, my general guidance is that the <em class="italic">simpler</em> an array type is, the better your odds are of being able to mutate it without the array contents having to be copied, which for larger datasets may be prohibitively expensive.</p>
    <p class="normal">For the second bullet, a lot<a id="_idIndexMarker076"/> of <strong class="keyWord">Copy on Write</strong> (<strong class="keyWord">CoW</strong>) work was involved in the pandas 2.x series. CoW is the default behavior in pandas 3.0, and it tries to make the behavior of what does and <a id="_idIndexMarker077"/>does <a id="_idIndexMarker078"/>not get copied when<a id="_idIndexMarker079"/> mutating data more predictable. For advanced users, I highly encourage giving the pandas CoW documentation a read.</p>
    <h1 id="_idParaDest-74" class="heading-1">DataFrame column assignment</h1>
    <p class="normal">While assigning <a id="_idIndexMarker080"/>to <em class="italic">data</em> can be a relatively expensive operation in pandas, assigning columns to a <code class="inlineCode">pd.DataFrame</code> is a common operation.</p>
    <h2 id="_idParaDest-75" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a very simple <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame({<span class="hljs-string">"col1"</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]})
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    col1
0   1
1   2
2   3
</code></code></pre>
    <p class="normal">New columns can be assigned using the <code class="inlineCode">pd.DataFrame[]</code> operator. The simplest type of assignment can take a scalar value and <em class="italic">broadcast</em> it to every row of the <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[<span class="hljs-string">"</span><span class="hljs-string">new_column1"</span>] = <span class="hljs-number">42</span>
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    col1   new_column1
0   1      42
1   2      42
2   3      42
</code></code></pre>
    <p class="normal">You can also assign a <code class="inlineCode">pd.Series</code> or sequence as long as the number of elements matches the number of rows in the <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[<span class="hljs-string">"new_column2"</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-string">"abc"</span>)
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    col1   new_column1   new_column2
0   1      42            a
1   2      42            b
2   3      42            c
</code></code></pre>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[<span class="hljs-string">"new_column3"</span>] = pd.Series([<span class="hljs-string">"dog"</span>, <span class="hljs-string">"cat"</span>, <span class="hljs-string">"human"</span>])
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    col1   new_column1   new_column2   new_column3
0   1      42            a             dog
1   2      42            b             cat
2   3      42            c             human
</code></code></pre>
    <p class="normal">If the new sequence does not match the number of rows in the existing <code class="inlineCode">pd.DataFrame</code>, the assignment will fail:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df[<span class="hljs-string">"should_fail"</span>] = [<span class="hljs-string">"too few"</span>, <span class="hljs-string">"rows"</span>]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">ValueError: Length of values (2) does not match length of index (3)
</code></code></pre>
    <p class="normal">Assignment can <a id="_idIndexMarker081"/>also be done to a <code class="inlineCode">pd.DataFrame</code> with a <code class="inlineCode">pd.MultiIndex</code> in the columns. Let’s take a look at such a <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">row_index = pd.MultiIndex.from_tuples([
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Smith"</span>),
    (<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Jane"</span>, <span class="hljs-string">"Doe"</span>),
    (<span class="hljs-string">"Stephen"</span>, <span class="hljs-string">"Smith"</span>),
], names=[<span class="hljs-string">"first_name"</span>, <span class="hljs-string">"last_name"</span>])
col_index = pd.MultiIndex.from_tuples([
    (<span class="hljs-string">"music"</span>, <span class="hljs-string">"favorite"</span>),
    (<span class="hljs-string">"music"</span>, <span class="hljs-string">"last_seen_live"</span>),
    (<span class="hljs-string">"art"</span>, <span class="hljs-string">"favorite"</span>),
], names=[<span class="hljs-string">"art_type"</span>, <span class="hljs-string">"category"</span>])
df = pd.DataFrame([
   [<span class="hljs-string">"Swift"</span>, <span class="hljs-string">"Swift"</span>, <span class="hljs-string">"Matisse"</span>],
   [<span class="hljs-string">"Mozart"</span>, <span class="hljs-string">"T. Swift"</span>, <span class="hljs-string">"Van Gogh"</span>],
   [<span class="hljs-string">"Beatles"</span>, <span class="hljs-string">"Wonder"</span>, <span class="hljs-string">"Warhol"</span>],
   [<span class="hljs-string">"Jackson"</span>, <span class="hljs-string">"Dylan"</span>, <span class="hljs-string">"Picasso"</span>],
], index=row_index, columns=col_index)
df 
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">             art_type   music            art
             category   favorite   last_seen_live   favorite
first_name   last_name
John         Smith      Swift      Swift            Matisse
             Doe        Mozart     T. Swift         Van Gogh
Jane         Doe        Beatles    Wonder           Warhol
Stephen      Smith      Jackson    Dylan            Picasso
</code></code></pre>
    <p class="normal">To assign a new column under the <code class="inlineCode">"art"</code> hierarchy for the number of museums seen, pass a tuple argument to <code class="inlineCode">pd.DataFrame.loc</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[:, (<span class="hljs-string">"art"</span>, <span class="hljs-string">"museuems_seen"</span>)] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>]
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">             art_type    music            art
             category    favorite   last_seen_live   favorite   museuems_seen
first_name   last_name
John         Smith       Swift       Swift           Matisse    1
             Doe         Mozart      T. Swift        Van Gogh   2
Jane         Doe         Beatles     Wonder          Warhol     4
Stephen      Smith       Jackson     Dylan           Picasso    8
</code></code></pre>
    <p class="normal">Assignment with a <code class="inlineCode">pd.DataFrame</code> follows the same patterns we saw when selecting values with <code class="inlineCode">pd.DataFrame[]</code> and <code class="inlineCode">pd.DataFrame.loc[]</code>. The main difference is that during selection, you would use <code class="inlineCode">pd.DataFrame[]</code> and <code class="inlineCode">pd.DataFrame.loc[]</code> on the right-hand side of an expression, whereas<a id="_idIndexMarker082"/> with assignment, they appear on the left-hand side.</p>
    <h2 id="_idParaDest-76" class="heading-2">There’s more…</h2>
    <p class="normal">The <code class="inlineCode">pd.DataFrame.assign</code> method<a id="_idIndexMarker083"/> can be used to allow <em class="italic">method chaining</em> during assignment. Let’s start with a simple <code class="inlineCode">pd.DataFrame</code> to illustrate the utility:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]], columns=<span class="hljs-built_in">list</span>(<span class="hljs-string">"ab"</span>))
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    a   b
0   0   1
1   2   4
</code></code></pre>
    <p class="normal"><em class="italic">Method chaining</em> refers to the ability of pandas to apply many algorithms in succession to a pandas data structure (algorithms and how to apply them will be covered in more detail in <em class="chapterRef">Chapter 5</em>, <em class="italic">Algorithms and How to Apply Them</em>). So, to take our <code class="inlineCode">pd.DataFrame</code>, double it, and add 42 to each element, we could do something like:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">(
    df
    .mul(<span class="hljs-number">2</span>)
    .add(<span class="hljs-number">42</span>)
)
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    a    b
0   42   44
1   46   50
</code></code></pre>
    <p class="normal">But what happens if we want to add a new column as part of this chain of events? Unfortunately, with the standard assignment operators, you would have to break that chain of events and usually assign a new variable:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df2 = (
    df
    .mul(<span class="hljs-number">2</span>)
    .add(<span class="hljs-number">42</span>)
)
df2[<span class="hljs-string">"assigned_c"</span>] = df2[<span class="hljs-string">"</span><span class="hljs-string">b"</span>] - <span class="hljs-number">3</span>
df2
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    a   b   assigned_c
0   42  44  41
1   46  50  47
</code></code></pre>
    <p class="normal">But with <code class="inlineCode">pd.DataFrame.assign</code>, you can continue chaining along. Simply pass the desired column label as a keyword to <code class="inlineCode">pd.DataFrame.assign</code>, whose argument is the values you would like to <a id="_idIndexMarker084"/>see in the new <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">(
    df
    .mul(<span class="hljs-number">2</span>)
    .add(<span class="hljs-number">42</span>)
    .assign(chained_c=<span class="hljs-keyword">lambda</span> df: df[<span class="hljs-string">"b"</span>] - <span class="hljs-number">3</span>)
) 
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    a    b    chained_c
0   42   44   41
1   46   50   47
</code></code></pre>
    <p class="normal">In this case, you are limited to using labels that meet Python’s syntax requirements for parameter names, and this, unfortunately, does not work with a <code class="inlineCode">pd.MultiIndex</code>. Some users think method chaining makes debugging harder, while others argue that method chaining like this makes <a id="_idIndexMarker085"/>code easier to read. Ultimately, there is no right or wrong answer, and the best advice I can give you for now is to use the form you feel most comfortable with.</p>
    <h1 id="_idParaDest-77" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers:</p>
    <p class="normal"><a href="https://packt.link/pandas"><span class="url">https://packt.link/pandas</span></a></p>
    <p class="normal"><img src="../Images/QR_Code5040900042138312.png" alt=""/></p>
  </div>
</body></html>