<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 1. A Tour of Interactive Computing with IPython"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. A Tour of Interactive Computing with IPython</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introducing the IPython notebook</li><li class="listitem" style="list-style-type: disc">Getting started with exploratory data analysis in IPython</li><li class="listitem" style="list-style-type: disc">Introducing the multidimensional array in NumPy for fast array computations</li><li class="listitem" style="list-style-type: disc">Creating an IPython extension with custom magic commands</li><li class="listitem" style="list-style-type: disc">Mastering IPython's configuration system</li><li class="listitem" style="list-style-type: disc">Creating a simple kernel for IPython</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>This book targets intermediate to advanced users who are familiar with Python, IPython, and scientific computing. In this chapter, we will give a brief recap on the fundamental tools we will be using throughout this book: IPython, the notebook, pandas, NumPy, and matplotlib.</p><p>In this introduction, we will give a broad overview of IPython and the Python scientific stack for high-performance computing and data science.</p><div class="section" title="What is IPython?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>What is IPython?</h2></div></div></div><p>
<span class="strong"><strong>IPython</strong></span><a id="id0" class="indexterm"/> is an open source platform for interactive and parallel computing. It offers powerful interactive shells and a browser-based notebook. The <span class="strong"><strong>notebook</strong></span><a id="id1" class="indexterm"/> combines code, text, mathematical expressions, inline plots, interactive plots, and other rich media within a sharable web document. This platform provides an ideal framework for interactive scientific computing and data analysis. IPython has become essential to researchers, data scientists, and teachers.</p><p>IPython can be used with the Python programming language, but the platform also supports many other languages such as R, Julia, Haskell, or Ruby. The architecture of the project is indeed language-agnostic, consisting of messaging protocols and interactive clients (including the browser-based notebook). The clients are connected to <span class="strong"><strong>kernels</strong></span><a id="id2" class="indexterm"/> that implement the core interactive computing facilities. Therefore, the platform can be useful to technical and scientific communities that use languages other than Python.</p><p>In July 2014, <span class="strong"><strong>Project Jupyter</strong></span><a id="id3" class="indexterm"/> was announced by the IPython developers. This project will focus on the language-independent parts of IPython (including the notebook architecture), whereas the name IPython will be reserved to the Python kernel. In this book, for the sake of simplicity, we will just use the term IPython to refer to either the platform or the Python kernel.</p></div><div class="section" title="A brief historical retrospective on Python as a scientific environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>A brief historical retrospective on Python as a scientific environment</h2></div></div></div><p>Python is a high-level <a id="id4" class="indexterm"/>general-purpose language originally conceived by Guido van Rossum in the late 1980s (the name was inspired by the British comedy <span class="emphasis"><em>Monty Python's Flying Circus</em></span>). This easy-to-use language is the basis of many scripting programs that glue different<a id="id5" class="indexterm"/> software components (<span class="strong"><strong>glue language</strong></span>) together. In addition, Python comes with an extremely rich standard library (the <span class="emphasis"><em>batteries included</em></span> philosophy), which covers string processing, Internet Protocols, operating system interfaces, and many other domains.</p><p>In the late 1990s, Travis Oliphant and others started to build efficient tools to deal with numerical data in Python: Numeric, Numarray, and <a id="id6" class="indexterm"/>finally, <span class="strong"><strong>NumPy</strong></span>. <span class="strong"><strong>SciPy</strong></span>, which <a id="id7" class="indexterm"/>implements many numerical computing algorithms, was also created on top of NumPy. In the early 2000s, John Hunter created <span class="strong"><strong>matplotlib</strong></span><a id="id8" class="indexterm"/> to bring scientific graphics to Python. At the same time, Fernando Perez created IPython to improve interactivity and productivity in Python. All the fundamental tools were here to turn Python into a great open source high-performance framework for scientific computing and data analysis.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>It is worth noting that Python as a platform for scientific computing was built slowly, step-by-step, on top of a programming language that was not originally designed for this purpose. This fact might explain a few minor inconsistencies or weaknesses of the platform, which do not preclude it from being one of the most popular open frameworks for <a id="id9" class="indexterm"/>scientific computing at this time. (You can also refer to <a class="ulink" href="http://cyrille.rossant.net/whats-wrong-with-scientific-python/">http://cyrille.rossant.net/whats-wrong-with-scientific-python/</a>.)</p><p>Notable competing open source platforms for numerical computing and data analysis include R (which focuses on statistics) and Julia (a young, high-level language that focuses on high performance and parallel computing). We will see these two languages very briefly in this book, as they can be used from the IPython notebook.</p></div></div><p>In the late 2000s, Wes<a id="id10" class="indexterm"/> McKinney created <span class="strong"><strong>pandas</strong></span><a id="id11" class="indexterm"/> for the manipulation and analysis of numerical tables and time series. At the same time, the IPython developers started to work on a notebook client inspired by mathematical software such as <a id="id12" class="indexterm"/><span class="strong"><strong>Sage</strong></span>, <span class="strong"><strong>Maple</strong></span>, and <span class="strong"><strong>Mathematica</strong></span>. Finally, IPython 0.12, released in <a id="id13" class="indexterm"/>December 2011, introduced the HTML-based notebook that has<a id="id14" class="indexterm"/> now gone mainstream.</p><p>In 2013, the IPython team received a grant from the Sloan Foundation and a donation from Microsoft to support the development of the notebook. IPython 2.0, released in early 2014, brought many improvements and long-awaited features.</p></div><div class="section" title="What's new in IPython 2.0?"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>What's new in IPython 2.0?</h2></div></div></div><p>Here is a short summary of the<a id="id15" class="indexterm"/> changes brought by IPython 2.0 (succeeding v1.1):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The notebook comes with a new<a id="id16" class="indexterm"/> <span class="strong"><strong>modal user interface</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the<a id="id17" class="indexterm"/> <span class="strong"><strong>edit mode</strong></span>, we can edit a cell by entering code or text.</li><li class="listitem" style="list-style-type: disc">In the <a id="id18" class="indexterm"/><span class="strong"><strong>command mode</strong></span>, we can edit the notebook by moving cells around, duplicating or deleting them, changing their types, and so on. In this mode, the keyboard is mapped to a set of shortcuts that let us perform notebook and cell actions efficiently.<a id="id19" class="indexterm"/></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Notebook widgets</strong></span> are<a id="id20" class="indexterm"/> JavaScript-based GUI widgets that interact dynamically with Python objects. This major feature considerably expands the possibilities of the IPython notebook. Writing Python code in the notebook is no longer the only possible interaction with the kernel. JavaScript widgets and, more generally, any JavaScript-based interactive element, can now interact with the kernel in real-time.</li><li class="listitem" style="list-style-type: disc">We can now open notebooks in different subfolders with the dashboard, using the same server. A REST API maps local URIs to the filesystem.</li><li class="listitem" style="list-style-type: disc">Notebooks are now signed to prevent untrusted code from executing when notebooks are opened.</li><li class="listitem" style="list-style-type: disc">The dashboard now contains a <span class="strong"><strong>Running</strong></span> tab with the list of running kernels.</li><li class="listitem" style="list-style-type: disc">The tooltip now appears when pressing <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>Tab</em></span> instead of <span class="emphasis"><em>Tab</em></span>.</li><li class="listitem" style="list-style-type: disc">Notebooks<a id="id21" class="indexterm"/> can be run in an interactive session via <code class="literal">%run notebook.ipynb</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">%pylab</code> magic is <a id="id22" class="indexterm"/>discouraged in favor of <code class="literal">%matplotlib inline</code> (to embed figures in the notebook) and <code class="literal">import matplotlib.pyplot as plt</code>. The main reason is that <code class="literal">%pylab</code> clutters the interactive namespace by importing a huge number of variables. Also, it might harm the reproducibility and reusability of notebooks.</li><li class="listitem" style="list-style-type: disc">Python 2.6 and 3.2 are no longer supported. IPython now requires Python 2.7 or &gt;= 3.3.</li></ul></div></div><div class="section" title="Roadmap for IPython 3.0 and 4.0"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Roadmap for IPython 3.0 and 4.0</h2></div></div></div><p>IPython 3.0 and 4.0, planned for late 2014/early 2015, should facilitate the use of non-Python kernels and provide multiuser capabilities to the notebook.</p></div><div class="section" title="References"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>References</h2></div></div></div><p>Here are a <a id="id23" class="indexterm"/>few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Python webpage at <a class="ulink" href="http://www.python.org">www.python.org</a></li><li class="listitem" style="list-style-type: disc">Python on Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/Python_%28programming_language%29">http://en.wikipedia.org/wiki/Python_%28programming_language%29</a></li><li class="listitem" style="list-style-type: disc">Python's standard library present at <a class="ulink" href="https://docs.python.org/2/library/">https://docs.python.org/2/library/</a></li><li class="listitem" style="list-style-type: disc">Guido van Rossum on Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/Guido_van_Rossum">http://en.wikipedia.org/wiki/Guido_van_Rossum</a></li><li class="listitem" style="list-style-type: disc">Conversation with Guido van Rossum on the birth of Python available at <a class="ulink" href="http://www.artima.com/intv/pythonP.html">www.artima.com/intv/pythonP.html</a></li><li class="listitem" style="list-style-type: disc">History of scientific Python available at <a class="ulink" href="http://fr.slideshare.net/shoheihido/sci-pyhistory">http://fr.slideshare.net/shoheihido/sci-pyhistory</a></li><li class="listitem" style="list-style-type: disc">What's new in IPython 2.0 at <a class="ulink" href="http://ipython.org/ipython-doc/2/whatsnew/version2.0.html">http://ipython.org/ipython-doc/2/whatsnew/version2.0.html</a></li><li class="listitem" style="list-style-type: disc">IPython on Wikipedia at <a class="ulink" href="http://en.wikipedia.org/wiki/IPython">http://en.wikipedia.org/wiki/IPython</a></li><li class="listitem" style="list-style-type: disc">History of the <a id="id24" class="indexterm"/>IPython notebook at <a class="ulink" href="http://blog.fperez.org/2012/01/ipython-notebook-historical.html">http://blog.fperez.org/2012/01/ipython-notebook-historical.html</a></li></ul></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Introducing the IPython notebook"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Introducing the IPython notebook</h1></div></div></div><p>The notebook is the flagship feature of IPython. This web-based interactive environment combines code, rich text, images, videos, animations, mathematics, and plots into a single document. This modern tool is an<a id="id25" class="indexterm"/> ideal gateway to high-performance numerical computing and data science in Python. This entire book has been written in the notebook, and the code of every recipe is available as a notebook on the book's GitHub repository at <a class="ulink" href="https://github.com/ipython-books/cookbook-code">https://github.com/ipython-books/cookbook-code</a>.</p><p>In this recipe, we give an introduction to IPython and its notebook. In <span class="emphasis"><em>Getting ready</em></span>, we also give general instructions on installing IPython and the Python scientific stack.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Getting ready</h2></div></div></div><p>You will need Python, IPython, NumPy, pandas, and matplotlib in this chapter. Together with SciPy and SymPy, these libraries form the core of the Python scientific stack (<a class="ulink" href="http://www.scipy.org/about.html">www.scipy.org/about.html</a>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>You will find full detailed installation instructions on the book's GitHub repository at <a class="ulink" href="https://github.com/ipython-books/cookbook-code">https://github.com/ipython-books/cookbook-code</a>.</p><p>We only give a summary of these instructions here; please refer to the link above for more up-to-date details.</p></div></div><p>If you're just getting started with scientific computing in Python, the simplest option is to install an all-in-one Python distribution. The most common distributions are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Anaconda</strong></span> (free or commercial license) available<a id="id26" class="indexterm"/> at <a class="ulink" href="http://store.continuum.io/cshop/anaconda/">http://store.continuum.io/cshop/anaconda/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Canopy</strong></span> (free or commercial license) <a id="id27" class="indexterm"/>available at <a class="ulink" href="http://www.enthought.com/products/canopy/">www.enthought.com/products/canopy/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Python(x,y)</strong></span>, a free distribution only <a id="id28" class="indexterm"/>for Windows, available at <a class="ulink" href="https://code.google.com/p/pythonxy/">https://code.google.com/p/pythonxy/</a></li></ul></div><p>We <span class="emphasis"><em>highly</em></span> recommend Anaconda. These distributions contain everything you need to get started. You can also install additional packages as needed. You will find all the installation instructions in the links mentioned previously.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Throughout the book, we assume that you have installed Anaconda. We may not be able to offer support to readers who use another distribution.</p></div></div><p>Alternatively, if you feel brave, you can install Python, IPython, NumPy, pandas, and matplotlib manually. You will find all the instructions on the following websites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Python</strong></span> is the <a id="id29" class="indexterm"/>programming language underlying the ecosystem. The instructions are available at <a class="ulink" href="http://www.python.org/">www.python.org/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>IPython</strong></span> provides tools for interactive computing in Python. The instructions for installation<a id="id30" class="indexterm"/> are available at <a class="ulink" href="http://ipython.org/install.html">http://ipython.org/install.html</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>NumPy/SciPy</strong></span> are used for numerical computing in Python. The instructions for installation are available at <a class="ulink" href="http://www.scipy.org/install.html">www.scipy.org/install.html</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>pandas</strong></span><a id="id31" class="indexterm"/> provides data structures and tools for data analysis in Python. The instructions for installation are available at <a class="ulink" href="http://pandas.pydata.org/getpandas.html">http://pandas.pydata.org/getpandas.html</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>matplotlib</strong></span><a id="id32" class="indexterm"/> helps in creating scientific <a id="id33" class="indexterm"/>figures in Python. The instructions for installation are available at <a class="ulink" href="http://matplotlib.org/index.html">http://matplotlib.org/index.html</a>.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>
<span class="strong"><strong>Python 2 or Python 3?</strong></span>
</p><p>Though <a id="id34" class="indexterm"/>Python 3 is the latest version at this date, many people are still using <a id="id35" class="indexterm"/>Python 2. Python 3 has brought backward-incompatible changes that have slowed down its adoption. If you are just getting started with Python for scientific computing, you might as well choose Python 3. In this book, all the code has been written for Python 3, but it also works with Python 2. We will give more details about this question in <a class="link" href="ch02.html" title="Chapter 2. Best Practices in Interactive Computing">Chapter 2</a>, <span class="emphasis"><em>Best Practices in Interactive Computing</em></span>.</p></div></div><p>Once you have installed either an <a id="id36" class="indexterm"/>all-in-one Python distribution (again, we <span class="emphasis"><em>highly</em></span> recommend Anaconda), or Python and the required packages, you can get started! In this book, the IPython notebook is used in almost all recipes. This tool gives you access to Python from your web browser. We covered the essentials of the notebook in the <span class="emphasis"><em>Learning IPython for Interactive Computing and Data Visualization</em></span> book. You can also find more information on IPython<a id="id37" class="indexterm"/>'s website (<a class="ulink" href="http://ipython.org/ipython-doc/stable/notebook/index.html">http://ipython.org/ipython-doc/stable/notebook/index.html</a>).</p><p>To run the IPython notebook server, type <code class="literal">ipython notebook</code> in a terminal (also called the <a id="id38" class="indexterm"/><span class="strong"><strong>command prompt</strong></span>). Your default web browser should open automatically and load the <code class="literal">127.0.0.1:8888</code> address. Then, you can create a new notebook in the dashboard or open an existing notebook. By default, the notebook server opens in the current directory (the directory you launched the command from). It lists all the notebooks present in this directory (files with the <code class="literal">.ipynb</code> extension).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>On Windows, you can open a command prompt by pressing the Windows key and <span class="emphasis"><em>R</em></span>, then typing <code class="literal">cmd</code> in the prompt, and finally by pressing <span class="emphasis"><em>Enter</em></span>.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We assume that a Python distribution is installed with IPython and that we are now in an IPython notebook. We type the following command in a cell, and press <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>Enter</em></span> to evaluate it:<div class="informalexample"><pre class="programlisting">In [1]: print("Hello world!")
Hello world!</pre></div><div class="mediaobject"><img src="images/4818OS_01_01.jpg" alt="How to do it..."/><div class="caption"><p>Screenshot of the IPython notebook</p></div></div><p>A notebook contains a <a id="id39" class="indexterm"/>linear succession of <span class="strong"><strong>cells</strong></span><a id="id40" class="indexterm"/> and <a id="id41" class="indexterm"/><span class="strong"><strong>output areas</strong></span>. A cell contains Python code, in one or multiple lines. The output of the code is shown in the corresponding output area.</p></li><li class="listitem">Now, we do a simple arithmetic operation:<div class="informalexample"><pre class="programlisting">In [2]: 2+2
Out[2]: 4</pre></div><p>The result of the operation is shown in the output area. Let's be more precise. The output area not only displays the text that is printed by any command in the cell, but it also displays a text representation of the last returned object. Here, the last returned object is the result of <code class="literal">2+2</code>, that is, <code class="literal">4</code>.</p></li><li class="listitem">In the next cell, we can recover the value of the last returned object with the <code class="literal">_</code> (underscore) special variable. In practice, it might be more convenient to assign objects to named variables such as in <code class="literal">myresult = 2+2</code>.<div class="informalexample"><pre class="programlisting">In [3]: _ * 3
Out[3]: 12</pre></div></li><li class="listitem">IPython not only accepts Python code, but also shell commands. These commands are defined by the operating system (mainly Windows, Linux, and Mac OS X). We first type <code class="literal">!</code> in a cell before typing the shell command. Here, assuming a Linux or Mac OS X system, we get the list of all the notebooks in the current directory:<div class="informalexample"><pre class="programlisting">In [4]: !ls *.ipynb
notebook1.ipynb  ...</pre></div><p>On Windows, you should replace <code class="literal">ls</code> with <code class="literal">dir</code>.</p></li><li class="listitem">IPython comes with a library of<a id="id42" class="indexterm"/> <span class="strong"><strong>magic commands</strong></span>. These commands are <a id="id43" class="indexterm"/>convenient shortcuts to common actions. They all start with <code class="literal">%</code> (the percent character). We can get the list of all magic commands with <code class="literal">%lsmagic</code>:<div class="informalexample"><pre class="programlisting">In [5]: %lsmagic
Out[5]: Available line magics:
%alias  %alias_magic  %autocall  %automagic  %autosave  %bookmark  %cd  %clear  %cls  %colors  %config  %connect_info  %copy  %ddir  %debug  %dhist  %dirs  %doctest_mode  %echo  %ed  %edit  %env  %gui  %hist  %history  %install_default_config  %install_ext  %install_profiles  %killbgscripts  %ldir  %less  %load  %load_ext  %loadpy  %logoff  %logon  %logstart  %logstate  %logstop  %ls  %lsmagic  %macro  %magic  %matplotlib  %mkdir  %more  %notebook  %page  %pastebin  %pdb  %pdef  %pdoc  %pfile  %pinfo  %pinfo2  %popd  %pprint  %precision  %profile  %prun  %psearch  %psource  %pushd  %pwd  %pycat  %pylab  %qtconsole  %quickref  %recall  %rehashx  %reload_ext  %ren  %rep  %rerun  %reset  %reset_selective  %rmdir  %run  %save  %sc  %store  %sx  %system  %tb  %time  %timeit  %unalias  %unload_ext  %who  %who_ls  %whos  %xdel  %xmode

Available cell magics:
%%!  %%HTML  %%SVG  %%bash  %%capture  %%cmd  %%debug  %%file  %%html  %%javascript  %%latex  %%perl  %%powershell  %%prun  %%pypy  %%python  %%python3  %%ruby  %%script  %%sh  %%svg  %%sx  %%system  %%time  %%timeit  %%writefile</pre></div><p>Cell magics have a <code class="literal">%%</code> prefix; they concern entire code cells.</p></li><li class="listitem">For example, the <code class="literal">%%writefile</code> cell magic lets us create a text file easily. This magic command accepts a filename as an argument. All the remaining lines in the cell are directly written to this text file. Here, we create a file <code class="literal">test.txt</code> and write <code class="literal">Hello world!</code> in it:<div class="informalexample"><pre class="programlisting">In [6]: %%writefile test.txt
        Hello world!
Writing test.txt
In [7]: # Let's check what this file contains.
        with open('test.txt', 'r') as f:
            print(f.read())
Hello world!</pre></div></li><li class="listitem">As we can see in the output of <code class="literal">%lsmagic</code>, there are many magic commands in IPython. We can find more information about any command by adding <code class="literal">?</code> after it. For example, to get some help about the <code class="literal">%run</code> magic command, we type <code class="literal">%run?</code> as shown here:<div class="informalexample"><pre class="programlisting">In [9]: %run?
Type:        Magic function
Namespace:   IPython internal
...
Docstring:
Run the named file inside IPython as a program.
[full documentation of the magic command...]</pre></div></li><li class="listitem">We covered the basics of <a id="id44" class="indexterm"/>IPython and the notebook. Let's now turn to the rich display and interactive features of the notebook. Until now, we have only created<a id="id45" class="indexterm"/> <span class="strong"><strong>code cells</strong></span> (containing code). IPython supports other types of cells. In the notebook toolbar, there is a drop-down menu to select the cell's type. The most common cell type after the code cell is the <a id="id46" class="indexterm"/><span class="strong"><strong>Markdown cell</strong></span>.<p>Markdown cells contain rich text formatted with <a id="id47" class="indexterm"/><span class="strong"><strong>Markdown</strong></span>, a popular plain text-formatting syntax. This format supports normal text, headers, bold, italics, hypertext links, images, mathematical equations in <a id="id48" class="indexterm"/><span class="strong"><strong>LaTeX</strong></span> (a typesetting system adapted to mathematics), code, HTML elements, and other features, as shown here:</p><div class="informalexample"><pre class="programlisting">### New paragraph 
This is *rich* **text** with [links](http://ipython.org),
equations:

$$\hat{f}(\xi) = \int_{-\infty}^{+\infty} f(x)\,
                 \mathrm{e}^{-i \xi x}$$

code with syntax highlighting: 
```python
print("Hello world!")
``` 
and images: 
![This is an image](http://ipython.org/_static/IPy_header.png)</pre></div><p>Running a Markdown<a id="id49" class="indexterm"/> cell (by pressing <span class="emphasis"><em>Shift</em></span> + <span class="emphasis"><em>Enter</em></span>, for example) displays the output, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/4818OS_01_02.jpg" alt="How to do it..."/><div class="caption"><p>Rich text formatting with Markdown in the IPython notebook</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>LaTeX equations<a id="id50" class="indexterm"/> are rendered with the <code class="literal">MathJax</code> library. We can enter inline equations with <code class="literal">$...$</code> and displayed equations with <code class="literal">$$...$$</code>. We can also use environments such as <code class="literal">equation</code>, <code class="literal">eqnarray</code>, or <code class="literal">align</code>. These features are very useful to scientific users.</p></div></div><p>By combining code cells and Markdown cells, we can create a standalone interactive document that combines computations (code), text, and graphics.</p></li><li class="listitem">IPython also comes with a sophisticated display system that lets us insert rich web elements in the notebook. Here, we show how to <a id="id51" class="indexterm"/>add HTML, <span class="strong"><strong>SVG</strong></span> (<span class="strong"><strong>Scalable Vector Graphics</strong></span>), and even YouTube videos in a notebook.<p>First, we need to import some classes:</p><div class="informalexample"><pre class="programlisting">In [11]: from IPython.display import HTML, SVG, YouTubeVideo</pre></div><p>We create an HTML table dynamically with Python, and we display it in the notebook:</p><div class="informalexample"><pre class="programlisting">In [12]: HTML('''
         &lt;table style="border: 2px solid black;"&gt;
         ''' + 
         ''.join(['&lt;tr&gt;' + 
                  ''.join(['&lt;td&gt;{row},{col}&lt;/td&gt;'.format(
                                 row=row, col=col
                                 ) for col in range(5)]) +
                  '&lt;/tr&gt;' for row in range(5)]) +
         '''
         &lt;/table&gt;
         ''')</pre></div><div class="mediaobject"><img src="images/4818OS_01_03.jpg" alt="How to do it..."/><div class="caption"><p>An HTML table in the notebook</p></div></div><p>Similarly, we can <a id="id52" class="indexterm"/>create SVG graphics dynamically:</p><div class="informalexample"><pre class="programlisting">In [13]: SVG('''&lt;svg width="600" height="80"&gt;''' + 
         ''.join(['''&lt;circle cx="{x}" cy="{y}" r="{r}"
                             fill="red"
                             stroke-width="2"
                             stroke="black"&gt;
                     &lt;/circle&gt;'''.format(x=(30+3*i)*(10-i),
                                         y=30,
                                         r=3.*float(i)
                                         ) for i in range(10)]) + 
         '''&lt;/svg&gt;''')</pre></div><div class="mediaobject"><img src="images/4818OS_01_04.jpg" alt="How to do it..."/><div class="caption"><p>SVG in the notebook</p></div></div><p>Finally, we display a YouTube video by giving its identifier to <code class="literal">YoutubeVideo</code>:</p><div class="informalexample"><pre class="programlisting">In [14]: YouTubeVideo('j9YpkSX7NNM')</pre></div><div class="mediaobject"><img src="images/4818OS_01_05.jpg" alt="How to do it..."/><div class="caption"><p>YouTube in the notebook</p></div></div></li><li class="listitem">Now, we illustrate the<a id="id53" class="indexterm"/> latest interactive features in IPython 2.0+, namely JavaScript widgets. Here, we create a drop-down menu to select videos:<div class="informalexample"><pre class="programlisting">In [15]: from collections import OrderedDict
         from IPython.display import (display,
                                      clear_output,
                                      YouTubeVideo)
         from IPython.html.widgets import DropdownWidget
In [16]: # We create a DropdownWidget, with a dictionary
         # containing the keys (video name) and the values
         # (Youtube identifier) of every menu item.
         dw = DropdownWidget(values=OrderedDict([
                           ('SciPy 2012', 'iwVvqwLDsJo'),
                           ('PyCon 2012', '2G5YTlheCbw'),
                           ('SciPy 2013', 'j9YpkSX7NNM')]
                                                )
                             )
         
         # We create a callback function that displays the 
         # requested Youtube video.
         def on_value_change(name, val):
             clear_output()
             display(YouTubeVideo(val))
         
         # Every time the user selects an item, the 
         # function `on_value_change` is called, and the 
         # `val` argument contains the value of the selected 
         # item.
         dw.on_trait_change(on_value_change, 'value')
         
         # We choose a default value.
         dw.value = dw.values['SciPy 2013']
         
         # Finally, we display the widget.
         display(dw)</pre></div><div class="mediaobject"><img src="images/4818OS_01_06.jpg" alt="How to do it..."/><div class="caption"><p>An interactive widget in the notebook</p></div></div></li></ol></div><p>The interactive features of IPython 2.0 bring a whole new dimension to the notebook, and we can expect many developments in the future.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>There's more...</h2></div></div></div><p>Notebooks are saved as structured text files (JSON format), which makes them easily shareable. Here are the contents of a <a id="id54" class="indexterm"/>simple notebook:</p><div class="informalexample"><pre class="programlisting">{
 "metadata": {
  "name": ""
 },
 "nbformat": 3,
 "nbformat_minor": 0,
 "worksheets": [
  {
   "cells": [
    {
     "cell_type": "code",
     "collapsed": false,
     "input": [
      "print(\"Hello World!\")"
     ],
     "language": "python",
     "metadata": {},
     "outputs": [
      {
       "output_type": "stream",
       "stream": "stdout",
       "text": [
        "Hello World!\n"
       ]
      }
     ],
     "prompt_number": 1
    }
   ],
   "metadata": {}
  }
 ]
}</pre></div><p>IPython comes with a special tool, <span class="strong"><strong>nbconvert</strong></span>, which <a id="id55" class="indexterm"/>converts notebooks to other formats such as HTML and <a id="id56" class="indexterm"/>PDF (<a class="ulink" href="http://ipython.org/ipython-doc/stable/notebook/index.html">http://ipython.org/ipython-doc/stable/notebook/index.html</a>).</p><p>Another online tool, <span class="strong"><strong>nbviewer</strong></span>, allows <a id="id57" class="indexterm"/>us to render a publicly available notebook directly in the <a id="id58" class="indexterm"/>browser <a id="id59" class="indexterm"/>and is available at <a class="ulink" href="http://nbviewer.ipython.org">http://nbviewer.ipython.org</a>.</p><p>We will cover many of these possibilities in the subsequent chapters, notably in <a class="link" href="ch03.html" title="Chapter 3. Mastering the Notebook">Chapter 3</a>, <span class="emphasis"><em>Mastering the Notebook</em></span>.</p><p>Here are a few references<a id="id60" class="indexterm"/> about the notebook:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Official page of the notebook available at <a class="ulink" href="http://ipython.org/notebook">http://ipython.org/notebook</a></li><li class="listitem" style="list-style-type: disc">Documentation of the notebook available at <a class="ulink" href="http://ipython.org/ipython-doc/dev/notebook/index.html">http://ipython.org/ipython-doc/dev/notebook/index.html</a></li><li class="listitem" style="list-style-type: disc">Official notebook examples present at <a class="ulink" href="https://github.com/ipython/ipython/tree/master/examples/Notebook">https://github.com/ipython/ipython/tree/master/examples/Notebook</a></li><li class="listitem" style="list-style-type: disc">User-curated gallery of interesting notebooks available at <a class="ulink" href="https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks">https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks</a></li><li class="listitem" style="list-style-type: disc">Official tutorial on the interactive widgets present at <a class="ulink" href="http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/">http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Getting started with data exploratory analysis in IPython</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Getting started with exploratory data analysis in IPython"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Getting started with exploratory data analysis in IPython</h1></div></div></div><p>In this recipe, we will give an<a id="id61" class="indexterm"/> introduction to IPython for data analysis. Most <a id="id62" class="indexterm"/>of the subject has been covered in the <span class="emphasis"><em>Learning IPython for Interactive Computing and Data Visualization</em></span> book, but we will review the basics here.</p><p>We will download and analyze a dataset about attendance on Montreal's bicycle tracks. This example is largely inspired by a presentation from Julia Evans (available at <a class="ulink" href="http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb">http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb</a>). Specifically, we will introduce the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data manipulation with pandas</li><li class="listitem" style="list-style-type: disc">Data visualization with matplotlib</li><li class="listitem" style="list-style-type: disc">Interactive widgets with IPython 2.0+</li></ul></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The very first step is to import the scientific packages we will be using in this recipe, namely NumPy, pandas, and matplotlib. We also instruct matplotlib to render the figures as inline images in the notebook:<div class="informalexample"><pre class="programlisting">In [1]: import numpy as np
        import pandas as pd
        import matplotlib.pyplot as plt
        %matplotlib inline</pre></div></li><li class="listitem">Now, we create a<a id="id63" class="indexterm"/> new Python variable called <code class="literal">url</code> that<a id="id64" class="indexterm"/> contains the address to a <span class="strong"><strong>CSV</strong></span> (<span class="strong"><strong>Comma-separated values</strong></span>)<a id="id65" class="indexterm"/> data file. This standard text-based file format is used to store tabular data:<div class="informalexample"><pre class="programlisting">In [2]: url = "http://donnees.ville.montreal.qc.ca/storage/f/2014-01-20T20%3A48%3A50.296Z/2013.csv"</pre></div></li><li class="listitem">pandas defines a <code class="literal">read_csv()</code> function that can read any CSV file. Here, we pass the URL to the file. pandas will automatically download and parse the file, and return a <code class="literal">DataFrame</code> object. We need to specify a few options to make sure that the dates are parsed correctly:<div class="informalexample"><pre class="programlisting">In [3]: df = pd.read_csv(url, index_col='Date',
                         parse_dates=True, dayfirst=True)</pre></div></li><li class="listitem">The <code class="literal">df</code> variable contains a <code class="literal">DataFrame</code> object, a specific pandas data structure that contains 2D tabular data. The <code class="literal">head(n)</code> method displays the first <span class="emphasis"><em>n</em></span> rows of this table. In the notebook, pandas displays a <code class="literal">DataFrame</code> object in an HTML table, as shown in the following screenshot:<div class="informalexample"><pre class="programlisting">In [4]: df.head(2)</pre></div><div class="mediaobject"><img src="images/4818OS_01_07.jpg" alt="How to do it..."/><div class="caption"><p>First rows of the DataFrame</p></div></div><p>Here, every row contains the number of bicycles on every track of the city, for every day of the year.</p></li><li class="listitem">We can get some summary statistics of the table with the <code class="literal">describe()</code> method:<div class="informalexample"><pre class="programlisting">In [5]: df.describe()</pre></div><div class="mediaobject"><img src="images/4818OS_01_08.jpg" alt="How to do it..."/><div class="caption"><p>Summary statistics of the DataFrame</p></div></div></li><li class="listitem">Let's display some <a id="id66" class="indexterm"/>figures. We will plot the daily attendance<a id="id67" class="indexterm"/> of two tracks. First, we select the two columns, <code class="literal">Berri1</code> and <code class="literal">PierDup</code>. Then, we call the <code class="literal">plot()</code> method:<div class="informalexample"><pre class="programlisting">In [6]: df[['Berri1', 'PierDup']].plot()</pre></div><div class="mediaobject"><img src="images/4818OS_01_09.jpg" alt="How to do it..."/></div></li><li class="listitem">Now, we move to a slightly more advanced analysis. We will look at the attendance of all tracks as a function of the weekday. We can get the weekday easily with pandas: the <code class="literal">index</code> attribute of the <code class="literal">DataFrame</code> object contains the dates of all rows in the table. This index has a few date-related attributes, including <code class="literal">weekday</code>:<div class="informalexample"><pre class="programlisting">In [7]: df.index.weekday
Out[7]: array([1, 2, 3, 4, 5, 6, 0, 1, 2, ..., 0, 1, 2])</pre></div><p>However, we would like to have names (Monday, Tuesday, and so on) instead of numbers between 0 and 6. This can be done easily. First, we create a <code class="literal">days</code> array with all the weekday names. Then, we index it by <code class="literal">df.index.weekday</code>. This operation replaces every integer in the index by<a id="id68" class="indexterm"/> the corresponding name<a id="id69" class="indexterm"/> in <code class="literal">days</code>. The first element, <code class="literal">Monday</code>, has the index 0, so every 0 in <code class="literal">df.index.weekday</code> is replaced by <code class="literal">Monday</code> and so on. We assign this new index to a new column, <code class="literal">Weekday</code>, in <code class="literal">DataFrame</code>:</p><div class="informalexample"><pre class="programlisting">In [8]: days = np.array(['Monday', 'Tuesday', 'Wednesday', 
                         'Thursday', 'Friday', 'Saturday', 
                         'Sunday'])
        df['Weekday'] = days[df.index.weekday]</pre></div></li><li class="listitem">To get the attendance as a function of the weekday, we need to group the table elements by the weekday. The <code class="literal">groupby()</code> method lets us do just that. Once grouped, we can sum all the rows in every group:<div class="informalexample"><pre class="programlisting">In [9]: df_week = df.groupby('Weekday').sum()
In [10]: df_week</pre></div><div class="mediaobject"><img src="images/4818OS_01_10.jpg" alt="How to do it..."/><div class="caption"><p>Grouped data with pandas</p></div></div></li><li class="listitem">We can now display this information in a figure. We first need to reorder the table by the weekday using <code class="literal">ix</code> (indexing operation). Then, we plot the table, specifying the line width:<div class="informalexample"><pre class="programlisting">In [11]: df_week.ix[days].plot(lw=3)
         plt.ylim(0);  # Set the bottom axis to 0.</pre></div><div class="mediaobject"><img src="images/4818OS_01_11.jpg" alt="How to do it..."/></div></li><li class="listitem">Finally, let's illustrate<a id="id70" class="indexterm"/> the new interactive capabilities of <a id="id71" class="indexterm"/>the notebook in IPython 2.0. We will plot a <span class="emphasis"><em>smoothed</em></span> version of the track attendance as a function of <a id="id72" class="indexterm"/>time (<span class="strong"><strong>rolling mean</strong></span>). The idea is to compute the mean value in the neighborhood of any day. The larger the neighborhood, the smoother the curve. We will create an interactive slider in the notebook to vary this parameter in real time in the plot. All we have to do is add the <code class="literal">@interact</code> decorator above our plotting function:<div class="informalexample"><pre class="programlisting">In [12]: from IPython.html.widgets import interact
         @interact
         def plot(n=(1, 30)):
             pd.rolling_mean(df['Berri1'], n).dropna().plot()
             plt.ylim(0, 8000)
             plt.show()</pre></div><div class="mediaobject"><img src="images/4818OS_01_12.jpg" alt="How to do it..."/><div class="caption"><p>Interactive widget in the notebook</p></div></div></li></ol></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>There's more...</h2></div></div></div><p>pandas<a id="id73" class="indexterm"/> is the right tool to load and manipulate a dataset. Other tools and methods are generally required for more advanced analyses (signal processing, statistics, and mathematical modeling). We will cover these steps in the second part of this book, starting with <a class="link" href="ch07.html" title="Chapter 7. Statistical Data Analysis">Chapter 7</a>, <span class="emphasis"><em>Statistical Data Analysis</em></span>.</p><p>Here are some more references about data manipulation<a id="id74" class="indexterm"/> with pandas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Learning IPython for Interactive Computing and Data Visualization</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>, our previous book</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Python for Data Analysis</em></span>, <span class="emphasis"><em>O'Reilly Media</em></span>, by Wes McKinney, the creator of pandas</li><li class="listitem" style="list-style-type: disc">The documentation of pandas available at <a class="ulink" href="http://pandas.pydata.org/pandas-docs/stable/">http://pandas.pydata.org/pandas-docs/stable/</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Introducing the multidimensional array in NumPy for fast array computations</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Introducing the multidimensional array in NumPy for fast array computations"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Introducing the multidimensional array in NumPy for fast array computations</h1></div></div></div><p>NumPy<a id="id75" class="indexterm"/> is the main foundation of the scientific Python ecosystem. This library offers a specific data structure for high-performance numerical computing: the<a id="id76" class="indexterm"/> <span class="strong"><strong>multidimensional array</strong></span>. The rationale behind NumPy is the following: Python being a high-level dynamic language, it is easier to use but slower than a low-level language such as C. NumPy implements the multidimensional array structure in C and provides a convenient Python interface, thus bringing together high performance and ease of use. NumPy is used by many Python libraries. For example, pandas is built on top of NumPy.</p><p>In this recipe, we will illustrate<a id="id77" class="indexterm"/> the basic concepts of the multidimensional array. A more comprehensive coverage of the topic can be found in the <span class="emphasis"><em>Learning IPython for Interactive Computing and Data Visualization</em></span> book.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import the built-in <code class="literal">random</code> Python module and NumPy:<div class="informalexample"><pre class="programlisting">In [1]: import random
        import numpy as np</pre></div><p>We use the <code class="literal">%precision</code> magic (defined in IPython) to show only three decimals in the Python output. This is just to reduce the number of digits in the output's text.</p><div class="informalexample"><pre class="programlisting">In [2]: %precision 3
Out[2]: u'%.3f'</pre></div></li><li class="listitem">We generate two Python lists, <code class="literal">x</code> and <code class="literal">y</code>, each one containing 1 million random numbers between 0 and 1:<div class="informalexample"><pre class="programlisting">In [3]: n = 1000000
        x = [random.random() for _ in range(n)]
        y = [random.random() for _ in range(n)]
In [4]: x[:3], y[:3]
Out[4]: ([0.996, 0.846, 0.202], [0.352, 0.435, 0.531])</pre></div></li><li class="listitem">Let's compute the element-wise sum of all these numbers: the first element of <code class="literal">x</code> plus the first element of <code class="literal">y</code>, and so on. We use a <code class="literal">for</code> loop in a list comprehension:<div class="informalexample"><pre class="programlisting">In [5]: z = [x[i] + y[i] for i in range(n)]
        z[:3]
Out[5]: [1.349, 1.282, 0.733]</pre></div></li><li class="listitem">How long does this computation take? IPython defines a handy <code class="literal">%timeit</code> magic command to quickly evaluate the time taken by a single statement:<div class="informalexample"><pre class="programlisting">In [6]: %timeit [x[i] + y[i] for i in range(n)]
1 loops, best of 3: 273 ms per loop</pre></div></li><li class="listitem">Now, we will<a id="id78" class="indexterm"/> perform the same operation with NumPy. NumPy works on multidimensional arrays, so we need to convert our lists to arrays. The <code class="literal">np.array()</code> function does just that:<div class="informalexample"><pre class="programlisting">In [7]: xa = np.array(x)
        ya = np.array(y)
In [8]: xa[:3]
Out[8]: array([ 0.996,  0.846,  0.202])</pre></div><p>The <code class="literal">xa</code> and <code class="literal">ya </code>arrays contain the exact same numbers that our original lists, <code class="literal">x</code> and <code class="literal">y</code>, contained. Those lists were instances of the <code class="literal">list</code> built-in class, while our arrays are instances of the <code class="literal">ndarray</code> NumPy class. These types are implemented very differently in Python and NumPy. In this example, we will see that using arrays instead of lists leads to drastic performance improvements.</p></li><li class="listitem">Now, to compute the element-wise sum of these arrays, we don't need to do a <code class="literal">for</code> loop anymore. In NumPy, adding two arrays means adding the elements of the arrays component-by-component. This is the standard mathematical notation in linear algebra (operations on vectors and matrices):<div class="informalexample"><pre class="programlisting">In [9]: za = xa + ya
        za[:3]
Out[9]: array([ 1.349,  1.282,  0.733])</pre></div><p>We see that the <code class="literal">z</code> list and the <code class="literal">za</code> array contain the same elements (the sum of the numbers in <code class="literal">x</code> and <code class="literal">y</code>).</p></li><li class="listitem">Let's compare the performance of this NumPy operation with the native Python loop:<div class="informalexample"><pre class="programlisting">In [10]: %timeit xa + ya
100 loops, best of 3: 10.7 ms per loop</pre></div><p>We observe that this operation is more than one order of magnitude faster in NumPy than in pure Python!</p></li><li class="listitem">Now, we will compute something else: the sum of all elements in <code class="literal">x</code> or <code class="literal">xa</code>. Although this is not an element-wise operation, NumPy is still highly efficient here. The pure Python version uses the built-in <code class="literal">sum()</code> function on an iterable. The NumPy version uses the <code class="literal">np.sum()</code> function on a NumPy array:<div class="informalexample"><pre class="programlisting">In [11]: %timeit sum(x)  # pure Python
         %timeit np.sum(xa)  # NumPy
100 loops, best of 3: 17.1 ms per loop
1000 loops, best of 3: 2.01 ms per loop</pre></div><p>We also observe an impressive speedup here also.</p></li><li class="listitem">Finally, let's perform one last operation: computing the arithmetic distance between any pair of numbers in our two lists (we only consider the first 1000 elements to keep computing times reasonable). First, we implement this in pure Python with two nested <code class="literal">for</code> loops:<div class="informalexample"><pre class="programlisting">In [12]: d = [abs(x[i] - y[j]) 
              for i in range(1000) for j in range(1000)]
In [13]: d[:3]
Out[13]: [0.230, 0.037, 0.549]</pre></div></li><li class="listitem">Now, we use a<a id="id79" class="indexterm"/> NumPy implementation, bringing out two slightly more advanced notions. First, we consider a <span class="strong"><strong>two-dimensional array</strong></span><a id="id80" class="indexterm"/> (or matrix). This is how we deal with the two indices, <span class="emphasis"><em>i</em></span> and <span class="emphasis"><em>j</em></span>. Second, we use <span class="strong"><strong>broadcasting</strong></span><a id="id81" class="indexterm"/> to perform an operation between a 2D array and 1D array. We will give more details in the <span class="emphasis"><em>How it works...</em></span> section.<div class="informalexample"><pre class="programlisting">In [14]: da = np.abs(xa[:1000,None] - ya[:1000])
In [15]: da
Out[15]: array([[ 0.23 ,  0.037,  ...,  0.542,  0.323,  0.473],
                 ...,
                [ 0.511,  0.319,  ...,  0.261,  0.042,  0.192]])
In [16]: %timeit [abs(x[i] - y[j]) 
                  for i in range(1000) for j in range(1000)]
         %timeit np.abs(xa[:1000,None] - ya[:1000])
1 loops, best of 3: 292 ms per loop
100 loops, best of 3: 18.4 ms per loop</pre></div><p>Here again, we observe significant speedups.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How it works...</h2></div></div></div><p>A NumPy array is a homogeneous block of data organized in a multidimensional finite grid. All elements of the array share the same <a id="id82" class="indexterm"/><span class="strong"><strong>data type</strong></span>, also called <span class="strong"><strong>dtype</strong></span> (integer, floating-point number, and so on). The <span class="strong"><strong>shape</strong></span><a id="id83" class="indexterm"/> of the array is an <span class="emphasis"><em>n</em></span>-tuple that gives the size of each axis.</p><p>A 1D array is a <a id="id84" class="indexterm"/><span class="strong"><strong>vector</strong></span>; its shape is just the number of components.</p><p>A 2D array is a <a id="id85" class="indexterm"/><span class="strong"><strong>matrix</strong></span>; its shape is <span class="emphasis"><em>(number of rows, number of columns)</em></span>.</p><p>The following figure<a id="id86" class="indexterm"/> illustrates the structure of a 3D (3, 4, 2) array that contains 24 elements:</p><div class="mediaobject"><img src="images/4818OS_01_13.jpg" alt="How it works..."/><div class="caption"><p>A NumPy array</p></div></div><p>The slicing syntax in Python nicely translates to array indexing in NumPy. Also, we can add an extra dimension to an existing array, using <code class="literal">None</code> or <code class="literal">np.newaxis</code> in the index. We used this trick in our previous example.</p><p>Element-wise arithmetic operations can be performed on NumPy arrays that have the <span class="emphasis"><em>same shape</em></span>. However, broadcasting relaxes this condition by allowing operations on arrays with different shapes in certain conditions. Notably, when one array has fewer dimensions than the other, it can be virtually stretched to match the other array's dimension. This is how we computed the pairwise distance between any pair of elements in <code class="literal">xa</code> and <code class="literal">ya</code>.</p><p>How can array operations be so much faster than Python loops? There are several reasons, and we will review them in detail in <a class="link" href="ch04.html" title="Chapter 4. Profiling and Optimization">Chapter 4</a>, <span class="emphasis"><em>Profiling and Optimization</em></span>. We can already say here that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In NumPy, array operations are implemented internally with C loops rather than Python loops. Python is typically slower than C because of its interpreted and dynamically-typed nature.</li><li class="listitem" style="list-style-type: disc">The data in a NumPy array is stored in a <span class="strong"><strong>contiguous</strong></span> block<a id="id87" class="indexterm"/> of memory in RAM. This property leads to more efficient use of CPU cycles and cache.</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>There's more...</h2></div></div></div><p>There's obviously much more to <a id="id88" class="indexterm"/>say about this subject. Our previous book, <span class="emphasis"><em>Learning IPython for Interactive Computing and Data Visualization</em></span>, contains more details about basic array operations. We will use the array data structure routinely throughout this book. Notably, <a class="link" href="ch04.html" title="Chapter 4. Profiling and Optimization">Chapter 4</a>, <span class="emphasis"><em>Profiling and Optimization</em></span>, covers advanced techniques of using NumPy arrays.</p><p>Here are some more <a id="id89" class="indexterm"/>references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to the <code class="literal">ndarray</code> on NumPy's documentation available at <a class="ulink" href="http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html">http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html</a></li><li class="listitem" style="list-style-type: disc">Tutorial on the NumPy array available at <a class="ulink" href="http://wiki.scipy.org/Tentative_NumPy_Tutorial">http://wiki.scipy.org/Tentative_NumPy_Tutorial</a></li><li class="listitem" style="list-style-type: disc">The NumPy array in the SciPy lectures notes present at <a class="ulink" href="http://scipy-lectures.github.io/intro/numpy/array_object.html">http://scipy-lectures.github.io/intro/numpy/array_object.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Getting started with exploratory data analysis in IPython</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Understanding the internals of NumPy to avoid unnecessary array copying</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Profiling and Optimization">Chapter 4</a>, <span class="emphasis"><em>Profiling and Optimization</em></span></li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating an IPython extension with custom magic commands"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Creating an IPython extension with custom magic commands</h1></div></div></div><p>Although IPython comes with <a id="id90" class="indexterm"/>a wide variety of <a id="id91" class="indexterm"/>magic commands, there are cases where we need to implement custom functionality in a new magic command. In this recipe, we will show how to create line and magic cells, and how to integrate them in an IPython extension.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's import a few functions from the IPython magic system:<div class="informalexample"><pre class="programlisting">In [1]: from IPython.core.magic import (register_line_magic, 
                                        register_cell_magic)</pre></div></li><li class="listitem">Defining a new line magic is particularly simple. First, we create a function that accepts the contents of the line (except the initial <code class="literal">%</code>-prefixed name). The name of this function is the name of the magic. Then, we decorate this function with <code class="literal">@register_line_magic</code>:<div class="informalexample"><pre class="programlisting">In [2]: @register_line_magic
        def hello(line):
            if line == 'french':
                print("Salut tout le monde!")
            else:
                print("Hello world!")
In [3]: %hello
Hello world!
In [4]: %hello french
Salut tout le monde!</pre></div></li><li class="listitem">Let's create a slightly more useful <code class="literal">%%csv</code> cell magic that parses a CSV string and returns a pandas <code class="literal">DataFrame</code> object. This time, the arguments of the function are the <a id="id92" class="indexterm"/>characters that <a id="id93" class="indexterm"/>follow <code class="literal">%%csv</code> in the first line and the contents of the cell (from the cell's second line to the last).<div class="informalexample"><pre class="programlisting">In [5]: import pandas as pd
        #from StringIO import StringIO  # Python 2
        from io import StringIO  # Python 3

        @register_cell_magic
        def csv(line, cell):
            # We create a string buffer containing the
            # contents of the cell.
            sio = StringIO(cell)
            # We use pandas' read_csv function to parse
            # the CSV string.
            return pd.read_csv(sio)
In [6]: %%csv
        col1,col2,col3
        0,1,2
        3,4,5
        7,8,9
Out[6]:
    col1  col2  col3
0     0     1     2
1     3     4     5
2     7     8     9</pre></div><p>We can access the returned object with <code class="literal">_</code>.</p><div class="informalexample"><pre class="programlisting">In [7]: df = _
        df.describe()
Out[7]:
           col1      col2      col3
count  3.000000  3.000000  3.000000
mean   3.333333  4.333333  5.333333
...
min    0.000000  1.000000  2.000000
max    7.000000  8.000000  9.000000</pre></div></li><li class="listitem">The method we described is useful in an interactive session. If we want to use the same magic in multiple notebooks or if we want to distribute it, then we need to create an <span class="strong"><strong>IPython extension</strong></span><a id="id94" class="indexterm"/> that implements our custom magic <a id="id95" class="indexterm"/>command. The first step is to create a Python script (<code class="literal">csvmagic.py</code> here) that implements the magic. We also need to define a special function <code class="literal">load_ipython_extension(ipython)</code>:<div class="informalexample"><pre class="programlisting">In [8]: %%writefile csvmagic.py
        import pandas as pd
        #from StringIO import StringIO  # Python 2
        from io import StringIO  # Python 3
        def csv(line, cell):
            sio = StringIO(cell)
            return pd.read_csv(sio)

        def load_ipython_extension(ipython):
            """This function is called when the extension 
            is loaded. It accepts an 
            IPython InteractiveShell instance.
            We can register the magic with the
            `register_magic_function` method."""
            ipython.register_magic_function(csv, 'cell')
Overwriting csvmagic.py</pre></div></li><li class="listitem">Once the extension<a id="id96" class="indexterm"/> module is created, we need to import it into the IPython session. We can do this with the <code class="literal">%load_ext</code> magic command. Here, loading our extension immediately registers our <code class="literal">%%csv</code> magic function in the interactive shell:<div class="informalexample"><pre class="programlisting">In [9]: %load_ext csvmagic
In [10]: %%csv
         col1,col2,col3
         0,1,2
         3,4,5
         7,8,9
Out[10]:
   col1  col2  col3
0     0     1     2
1     3     4     5
2     7     8     9</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How it works...</h2></div></div></div><p>An<a id="id97" class="indexterm"/> IPython extension is a Python module that implements the top-level <code class="literal">load_ipython_extension(ipython)</code> function. When the <code class="literal">%load_ext</code> magic command is called, the module is <a id="id98" class="indexterm"/>loaded and the <code class="literal">load_ipython_extension(ipython)</code> function is called. This function is passed the current <code class="literal">InteractiveShell</code> instance as an argument. This object implements several methods we can use to interact with the current IPython session.</p><div class="section" title="The InteractiveShell class"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>The InteractiveShell class</h3></div></div></div><p>An interactive IPython session is represented by a (singleton) instance<a id="id99" class="indexterm"/> of the <code class="literal">InteractiveShell</code> class. This object handles the history, interactive namespace, and most features available in the session.</p><p>Within an interactive shell, we can get the current <code class="literal">InteractiveShell</code> instance with the <code class="literal">get_ipython()</code> function.</p><p>The list of all methods of <code class="literal">InteractiveShell</code> can be found in the reference API (see link at the end of this recipe). The following are the most important attributes<a id="id100" class="indexterm"/> and <a id="id101" class="indexterm"/>methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">user_ns</code>: The<a id="id102" class="indexterm"/> <span class="strong"><strong>user namespace</strong></span> (a dictionary).</li><li class="listitem" style="list-style-type: disc"><code class="literal">push()</code>: <span class="strong"><strong>Push</strong></span> (or inject) Python <a id="id103" class="indexterm"/>variables in the interactive namespace.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ev()</code>: <span class="strong"><strong>Evaluate</strong></span> a <a id="id104" class="indexterm"/>Python expression in the user namespace.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ex()</code>: <span class="strong"><strong>Execute</strong></span> a <a id="id105" class="indexterm"/>Python statement in the user namespace.</li><li class="listitem" style="list-style-type: disc"><code class="literal">run_cell()</code>: <span class="strong"><strong>Run a </strong></span><a id="id106" class="indexterm"/><span class="strong"><strong>cell</strong></span> (given as a string), possibly containing IPython magic commands.</li><li class="listitem" style="list-style-type: disc"><code class="literal">safe_execfile()</code>: <span class="strong"><strong>Safely execute</strong></span><a id="id107" class="indexterm"/> a Python script.</li><li class="listitem" style="list-style-type: disc"><code class="literal">system()</code>: Execute a <a id="id108" class="indexterm"/><span class="strong"><strong>system</strong></span> command.</li><li class="listitem" style="list-style-type: disc"><code class="literal">write()</code>: <span class="strong"><strong>Write</strong></span> a <a id="id109" class="indexterm"/>string to the default output.</li><li class="listitem" style="list-style-type: disc"><code class="literal">write_err()</code>: <span class="strong"><strong>Write</strong></span> a <a id="id110" class="indexterm"/>string to the default <span class="strong"><strong>error</strong></span> output.</li><li class="listitem" style="list-style-type: disc"><code class="literal">register_magic_function()</code>: <span class="strong"><strong>Register</strong></span><a id="id111" class="indexterm"/> a standalone function as an IPython <a id="id112" class="indexterm"/><span class="strong"><strong>magic function</strong></span>. We used this method in this recipe.</li></ul></div></div><div class="section" title="Loading an extension"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Loading an extension</h3></div></div></div><p>The Python extension<a id="id113" class="indexterm"/> module needs to be importable when using <code class="literal">%load_ext</code>. Here, our module is in the current directory. In other situations, it has to be in the Python path. It can also be stored in <code class="literal">~\.ipython\extensions</code>, which is automatically put in the Python path.</p><p>To ensure that our magic is automatically defined in our IPython profile, we can instruct IPython to load our extension automatically when a new interactive shell is launched. To do this, we have to open the <code class="literal">~/.ipython/profile_default/ipython_config.py</code> file and put <code class="literal">'csvmagic'</code> in the <code class="literal">c.InteractiveShellApp.extensions</code> list. The <code class="literal">csvmagic</code> module needs to be importable. It is common to create a <span class="strong"><strong>Python package</strong></span><a id="id114" class="indexterm"/> that implements an IPython extension, which itself defines custom magic commands.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>There's more...</h2></div></div></div><p>Many third-party extensions and magic commands exist, notably<a id="id115" class="indexterm"/> <code class="literal">cythonmagic</code>, <code class="literal">octavemagic</code>, and <code class="literal">rmagic</code>, which<a id="id116" class="indexterm"/> all allow us to insert <a id="id117" class="indexterm"/>non-Python code in a cell. For example, with <code class="literal">cythonmagic</code>, we can create a Cython function in a cell and import it in the rest of the notebook.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Documentation of IPython's <a id="id118" class="indexterm"/>extension system available at <a class="ulink" href="http://ipython.org/ipython-doc/dev/config/extensions/">http://ipython.org/ipython-doc/dev/config/extensions/</a></li><li class="listitem" style="list-style-type: disc">Defining new magic <a id="id119" class="indexterm"/>commands explained at <a class="ulink" href="http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics">http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics</a></li><li class="listitem" style="list-style-type: disc">Index of<a id="id120" class="indexterm"/> IPython extensions at <a class="ulink" href="https://github.com/ipython/ipython/wiki/Extensions-Index">https://github.com/ipython/ipython/wiki/Extensions-Index</a></li><li class="listitem" style="list-style-type: disc">API reference <a id="id121" class="indexterm"/>of <code class="literal">InteractiveShell</code> available at <a class="ulink" href="http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html">http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Mastering IPython's configuration system</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Mastering IPython's configuration system"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Mastering IPython's configuration system</h1></div></div></div><p>IPython implements a truly <a id="id122" class="indexterm"/>powerful configuration system. This system<a id="id123" class="indexterm"/> is used throughout the project, but it can also be used by IPython extensions. It could even be used in entirely new applications.</p><p>In this recipe, we show how to use this system to write a configurable IPython extension. We will create a simple magic command that displays random numbers. This magic command comes with configurable parameters that can be set by the user in their IPython configuration file.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create an IPython extension in a <code class="literal">random_magics.py</code> file. Let's start by importing a few objects.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Be sure to put the code in steps 1-5 in an external text file named <code class="literal">random_magics.py</code>, rather than in the notebook's input!</p></div></div><div class="informalexample"><pre class="programlisting">from IPython.utils.traitlets import Int, Float, Unicode, Bool
from IPython.core.magic import (Magics, magics_class, line_magic)
import numpy as np</pre></div></li><li class="listitem">We create a <code class="literal">RandomMagics</code> class deriving from <code class="literal">Magics</code>. This class contains a few configurable parameters:<div class="informalexample"><pre class="programlisting">@magics_class
class RandomMagics(Magics):
    text = Unicode(u'{n}', config=True)
    max = Int(1000, config=True)
    seed = Int(0, config=True)</pre></div></li><li class="listitem">We need to call the parent's constructor. Then, we initialize a random number generator with a seed:<div class="informalexample"><pre class="programlisting">    def __init__(self, shell):
        super(RandomMagics, self).__init__(shell)
        self._rng = np.random.RandomState(self.seed or None)</pre></div></li><li class="listitem">We <a id="id124" class="indexterm"/>create a <code class="literal">%random</code> line magic that <a id="id125" class="indexterm"/>displays a random number:<div class="informalexample"><pre class="programlisting">    @line_magic
    def random(self, line):
        return self.text.format(n=self._rng.randint(self.max))</pre></div></li><li class="listitem">Finally, we register that magic when the extension is loaded:<div class="informalexample"><pre class="programlisting">def load_ipython_extension(ipython):
    ipython.register_magics(RandomMagics)</pre></div></li><li class="listitem">Let's test our extension in the notebook:<div class="informalexample"><pre class="programlisting">In [1]: %load_ext random_magics
In [2]: %random
Out[2]: '635'
In [3]: %random
Out[3]: '47'</pre></div></li><li class="listitem">Our magic command has a few configurable parameters. These variables are meant to be configured by the user in the IPython configuration file or in the console when starting IPython. To configure these variables in the terminal, we can type the following command in a system shell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ipython --RandomMagics.text='Your number is {n}.' --RandomMagics.max=10 --RandomMagics.seed=1</strong></span>
</pre></div><p>In this session, we get the following behavior:</p><div class="informalexample"><pre class="programlisting">In [1]: %load_ext random_magics
In [2]: %random
Out[2]: u'Your number is 5.'
In [3]: %random
Out[3]: u'Your number is 8.'</pre></div></li><li class="listitem">To configure the variables in the IPython configuration file, we have to open the <code class="literal">~/.ipython/profile_default/ipython_config.py</code> file and add the following line:<div class="informalexample"><pre class="programlisting">c.RandomMagics.text = 'random {n}'</pre></div><p>After launching IPython, we get the following behavior:</p><div class="informalexample"><pre class="programlisting">In [4]: %random
Out[4]: 'random 652'</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How it works...</h2></div></div></div><p>IPython's configuration system defines several concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>user profile</strong></span><a id="id126" class="indexterm"/> is a set of <a id="id127" class="indexterm"/>parameters, logs, and command history, which are specific to a user. A user can have different profiles when working on different projects. A <code class="literal">xxx</code> profile is stored in <code class="literal">~/.ipython/profile_xxx</code>, where <code class="literal">~</code> is the user's home directory.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On Linux, the path is generally <code class="literal">/home/yourname/.ipython/profile_xxx</code></li><li class="listitem" style="list-style-type: disc">On Windows, the path is generally <code class="literal">C:\Users\YourName\.ipython\profile_xxx</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">A <a id="id128" class="indexterm"/><span class="strong"><strong>configuration object</strong></span>, or <code class="literal">Config</code>, is a special Python dictionary that contains<a id="id129" class="indexterm"/> key-value pairs. The <code class="literal">Config</code> class derives from Python's <code class="literal">dict</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">HasTraits</code> class<a id="id130" class="indexterm"/> is a class that can have special <code class="literal">trait</code> attributes. <span class="strong"><strong>Traits</strong></span><a id="id131" class="indexterm"/> are sophisticated Python attributes that have a specific type and a default value. Additionally, when a trait's value changes, a callback function is automatically and transparently called. This mechanism allows a class to be notified whenever a trait attribute is changed.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Configurable</code> class<a id="id132" class="indexterm"/> is the base class of all classes that want to <a id="id133" class="indexterm"/>benefit from the configuration system. A <code class="literal">Configurable</code> class can have configurable attributes. These attributes have default values specified directly in the class definition. The main feature of <code class="literal">Configurable</code> classes is that the default values of the traits can be overridden by configuration files on a class-by-class basis. Then, instances of <code class="literal">Configurables</code> can change these values at leisure.</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>configuration file</strong></span><a id="id134" class="indexterm"/> is a Python or JSON file that contains the parameters <a id="id135" class="indexterm"/>of <code class="literal">Configurable</code> classes.</li></ul></div><p>The <code class="literal">Configurable</code> classes and configuration files support an inheritance model. A <code class="literal">Configurable</code> class can derive from another <code class="literal">Configurable</code> class and override its parameters. Similarly, a configuration file can be included in another file.</p><div class="section" title="Configurables"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Configurables</h3></div></div></div><p>Here is a simple example<a id="id136" class="indexterm"/> of a <code class="literal">Configurable</code> class:</p><div class="informalexample"><pre class="programlisting">from IPython.config.configurable import Configurable
from IPython.utils.traitlets import Float

class MyConfigurable(Configurable):
    myvariable = Float(100.0, config=True)</pre></div><p>By default, an instance of the <code class="literal">MyConfigurable</code> class will have its <code class="literal">myvariable</code> attribute equal to <code class="literal">100</code>. Now, let's assume that our IPython configuration file contains the following lines:</p><div class="informalexample"><pre class="programlisting">c = get_config()
c.MyConfigurable.myvariable = 123.</pre></div><p>Then, the <code class="literal">myvariable</code> attribute will default to <code class="literal">123</code>. Instances are free to change this default value after they are instantiated.</p><p>The <code class="literal">get_config()</code> function<a id="id137" class="indexterm"/> is a special function that is available in any configuration file.</p><p>Additionally, <code class="literal">Configurable</code> parameters can be specified in the command-line interface, as we saw in this recipe.</p><p>This configuration system is used by all IPython applications (notably <code class="literal">console</code>, <code class="literal">qtconsole</code>, and <code class="literal">notebook</code>). These applications have many configurable attributes. You will find the list of these attributes in your profile's configuration files.</p></div><div class="section" title="Magics"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Magics</h3></div></div></div><p>The <span class="strong"><strong>Magics</strong></span> class<a id="id138" class="indexterm"/> derives from <code class="literal">Configurable</code> and can contain configurable attributes. Moreover, magic commands can be defined by methods decorated by <code class="literal">@line_magic</code> or <code class="literal">@cell_magic</code>. The advantage of defining class magics instead of function magics (as in the previous recipe) is that we can keep a state between multiple magic calls (because we are using a class instead of a function).</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>There's more...</h2></div></div></div><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring and customizing <a id="id139" class="indexterm"/>IPython at <a class="ulink" href="http://ipython.org/ipython-doc/dev/config/index.html">http://ipython.org/ipython-doc/dev/config/index.html</a></li><li class="listitem" style="list-style-type: disc">Detailed overview of the configuration system at <a class="ulink" href="http://ipython.org/ipython-doc/dev/development/config.html">http://ipython.org/ipython-doc/dev/development/config.html</a></li><li class="listitem" style="list-style-type: disc">Defining custom <a id="id140" class="indexterm"/>magics available at <a class="ulink" href="http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics">http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics</a></li><li class="listitem" style="list-style-type: disc">The traitlets module available at <a class="ulink" href="http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html">http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating an IPython extension with custom magic commands</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating a simple kernel for IPython"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Creating a simple kernel for IPython</h1></div></div></div><p>The architecture that has been <a id="id141" class="indexterm"/>developed for IPython and that will be the core of <a id="id142" class="indexterm"/>Project Jupyter is becoming increasingly language independent. The decoupling between the client and kernel makes it possible to write kernels in any language. The client communicates with the kernel via socket-based messaging protocols. Thus, a kernel can be written in any language that supports sockets.</p><p>However, the messaging protocols are complex. Writing a new kernel from scratch is not straightforward. Fortunately, IPython 3.0 brings a lightweight interface for kernel languages that can be wrapped in Python.</p><p>This interface can also be used to create an entirely customized experience in the IPython notebook (or another client application such as the console). Normally, Python code has to be written in every code cell; however, we can write a kernel for any domain-specific language. We just have to write a Python function that accepts a code string as input (the contents of the code cell), and sends text or rich data as output. We can also easily implement code completion and code inspection.</p><p>We can imagine many interesting interactive applications that go far beyond the original use cases of IPython. These applications might be particularly useful for nonprogrammer end users such as high school students.</p><p>In this recipe, we will create a simple graphing calculator. The calculator is transparently backed by NumPy and matplotlib. We just have to write functions as <code class="literal">y = f(x)</code> in a code cell to get a graph of these functions.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>Getting ready</h2></div></div></div><p>This recipe has been tested on the development version of IPython 3.0. It should work on the final version of IPython 3.0 with no or minimal changes. We give all references about wrapper kernels and messaging protocols at the end of this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>How to do it...</h2></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Warning: This recipe works only on IPython &gt;= 3.0!</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we <a id="id143" class="indexterm"/>create a <code class="literal">plotkernel.py</code> file. This file will <a id="id144" class="indexterm"/>contain the implementation of our custom kernel. Let's import a few modules:<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Be sure to put the code in steps 1-6 in an external text file named <code class="literal">plotkernel.py</code>, rather than in the notebook's input!</p></div></div><div class="informalexample"><pre class="programlisting">from IPython.kernel.zmq.kernelbase import Kernel
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import urllib, base64</pre></div></li><li class="listitem">We write a function that returns a base64-encoded PNG representation of a matplotlib figure:<div class="informalexample"><pre class="programlisting">def _to_png(fig):
    """Return a base64-encoded PNG from a 
    matplotlib figure."""
    imgdata = BytesIO()
    fig.savefig(imgdata, format='png')
    imgdata.seek(0)
    return urllib.parse.quote(
        base64.b64encode(imgdata.getvalue()))</pre></div></li><li class="listitem">Now, we write a function that parses a code string, which has the form <code class="literal">y = f(x)</code>, and returns a NumPy function. Here, <code class="literal">f</code> is an arbitrary Python expression that can use NumPy functions:<div class="informalexample"><pre class="programlisting">_numpy_namespace = {n: getattr(np, n) 
                    for n in dir(np)}
def _parse_function(code):
    """Return a NumPy function from a string 'y=f(x)'."""
    return lambda x: eval(code.split('=')[1].strip(),
                          _numpy_namespace, {'x': x})</pre></div></li><li class="listitem">For our new wrapper kernel, we create a class that derives from <code class="literal">Kernel</code>. There are a few metadata fields we need to provide:<div class="informalexample"><pre class="programlisting">class PlotKernel(Kernel):
    implementation = 'Plot'
    implementation_version = '1.0'
    language = 'python'  # will be used for
                         # syntax highlighting
    language_version = ''
    banner = "Simple plotting"</pre></div></li><li class="listitem">In this class, we <a id="id145" class="indexterm"/>implement a <code class="literal">do_execute()</code> method <a id="id146" class="indexterm"/>that takes code as input and sends responses to the client:<div class="informalexample"><pre class="programlisting">def do_execute(self, code, silent,
               store_history=True,
               user_expressions=None,
               allow_stdin=False):

    # We create the plot with matplotlib.
    fig = plt.figure(figsize=(6,4), dpi=100)
    x = np.linspace(-5., 5., 200)
    functions = code.split('\n')
    for fun in functions:
        f = _parse_function(fun)
        y = f(x)
        plt.plot(x, y)
    plt.xlim(-5, 5)

    # We create a PNG out of this plot.
    png = _to_png(fig)

    if not silent:
        # We send the standard output to the client.
        self.send_response(self.iopub_socket,
            'stream', {
                'name': 'stdout', 
                'data': 'Plotting {n} function(s)'. \
                            format(n=len(functions))})

        # We prepare the response with our rich data
        # (the plot).
        content = {
            'source': 'kernel',

            # This dictionary may contain different
            # MIME representations of the output.
            'data': {
                'image/png': png
            },

            # We can specify the image size
            # in the metadata field.
            'metadata' : {
                  'image/png' : {
                    'width': 600,
                    'height': 400
                  }
                }
        }        

        # We send the display_data message with the
        # contents.
        self.send_response(self.iopub_socket,
            'display_data', content)

    # We return the execution results.
    return {'status': 'ok',
            'execution_count': self.execution_count,
            'payload': [],
            'user_expressions': {},
           }</pre></div></li><li class="listitem">Finally, we add<a id="id147" class="indexterm"/> the following lines at the end of the<a id="id148" class="indexterm"/> file:<div class="informalexample"><pre class="programlisting">if __name__ == '__main__':
    from IPython.kernel.zmq.kernelapp import IPKernelApp
    IPKernelApp.launch_instance(kernel_class=PlotKernel)</pre></div></li><li class="listitem">Our kernel is ready! The next step is to indicate to IPython that this new kernel is available. To do this, we need to create a <span class="strong"><strong>kernel spec</strong></span><a id="id149" class="indexterm"/> <code class="literal">kernel.json</code> file and put it in <code class="literal">~/.ipython/kernels/plot/</code>. This file contains the following lines:<div class="informalexample"><pre class="programlisting">{
 "argv": ["python", "-m",
          "plotkernel", "-f",
          "{connection_file}"],
 "display_name": "Plot",
 "language": "python"
}</pre></div><p>The <code class="literal">plotkernel.py</code> file needs to be importable by Python. For example, we could simply put it in the current directory.</p></li><li class="listitem">In IPython 3.0, we can launch a notebook with this kernel from the IPython notebook dashboard. There is a drop-down menu at the top right of the notebook interface that contains the list of available kernels. Select the Plot kernel to use it.</li><li class="listitem">Finally, in a new notebook backed by our custom plot kernel, we can simply write the mathematical equation, <code class="literal">y = f(x)</code>. The corresponding graph appears in the output area. Here is an example:<div class="mediaobject"><img src="images/4818OS_01_14.jpg" alt="How to do it..."/><div class="caption"><p>Example of our custom plot wrapper kernel</p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How it works...</h2></div></div></div><p>We will give more details <a id="id150" class="indexterm"/>about the architecture of IPython and the notebook<a id="id151" class="indexterm"/> in <a class="link" href="ch03.html" title="Chapter 3. Mastering the Notebook">Chapter 3</a>, <span class="emphasis"><em>Mastering the Notebook</em></span>. We will just give a summary here. Note that these details might change in future versions of IPython.</p><p>The kernel and client live in different processes. They communicate via messaging protocols implemented on top of network sockets. Currently, these messages are encoded in JSON, a structured, text-based document format.</p><p>Our kernel receives code from the client (the notebook, for example). The <code class="literal">do_execute()</code>function is called whenever the user sends a cell's code.</p><p>The kernel can send messages back to the client with the <code class="literal">self.send_response()</code> method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first argument is the socket, here, the<a id="id152" class="indexterm"/> <span class="strong"><strong>IOPub</strong></span> socket</li><li class="listitem" style="list-style-type: disc">The second argument is the <a id="id153" class="indexterm"/><span class="strong"><strong>message type</strong></span>, here, <code class="literal">stream</code>, to send back standard output or a standard error, or <code class="literal">display_data</code> to send back rich data</li><li class="listitem" style="list-style-type: disc">The third argument is the contents of the message, represented as a Python dictionary</li></ul></div><p>The data can <a id="id154" class="indexterm"/>contain multiple MIME <a id="id155" class="indexterm"/>representations: text, HTML, SVG, images, and others. It is up to the client to handle these data types. In particular, the HTML notebook client knows how to represent all these types in the browser.</p><p>The function returns execution results in a dictionary.</p><p>In this toy example, we always return an <code class="literal">ok</code> status. In production code, it would be a good idea to detect errors (syntax errors in the function definitions, for example) and return an error status instead.</p><p>All messaging protocol details can be found at the links given at the end of this recipe.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>There's more...</h2></div></div></div><p>Wrapper kernels<a id="id156" class="indexterm"/> can implement optional methods, notably for code completion and code inspection. For example, to implement code completion, we need to write the following method:</p><div class="informalexample"><pre class="programlisting">def do_complete(self, code, cursor_pos):
    return {'status': 'ok',
            'cursor_start': ...,
            'cursor_end': ...,
            'matches': [...]}</pre></div><p>This method is called whenever the user requests code completion when the cursor is at a given <code class="literal">cursor_pos</code> location in the code cell. In the method's response, the <code class="literal">cursor_start</code> and <code class="literal">cursor_end</code> fields represent the interval that code completion should overwrite in the output. The <code class="literal">matches</code> field contains the list of suggestions.</p><p>These details might have changed by the time IPython 3.0 is released. You will find all up-to-date information in the following references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wrapper kernels, available<a id="id157" class="indexterm"/> at <a class="ulink" href="http://ipython.org/ipython-doc/dev/development/wrapperkernels.html">http://ipython.org/ipython-doc/dev/development/wrapperkernels.html</a></li><li class="listitem" style="list-style-type: disc">Messaging protocols, available <a id="id158" class="indexterm"/>at <a class="ulink" href="http://ipython.org/ipython-doc/dev/development/messaging.html">http://ipython.org/ipython-doc/dev/development/messaging.html</a></li><li class="listitem" style="list-style-type: disc">KernelBase API reference, available<a id="id159" class="indexterm"/> at <a class="ulink" href="http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html">http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html</a></li></ul></div></div></div></div>
</body></html>