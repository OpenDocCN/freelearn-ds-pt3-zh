- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematical Plotting with Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plotting is a fundamental tool in all of mathematics. A good plot can reveal
    hidden details, suggest future directions, verify results, or reinforce an argument.
    It is no surprise, then, that the scientific Python stack features a powerful
    and flexible plotting library called Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will plot functions and data in a variety of styles and
    create figures that are fully labeled and annotated. We will create three-dimensional
    plots, customize the appearance of figures, create figures that contain multiple
    plots using subplots, and save figures directly to files for applications that
    are not running in an interactive environment.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting is one of the most important aspects covered in this book. Plotting
    data, functions, or solutions can often help you gain an understanding of a problem
    that can really help to reason about your methods. We will see plotting again
    in every chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic plotting with Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding subplots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting with error bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving Matplotlib figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surface and contour plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing three-dimensional plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting vector fields with quiver plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main plotting package for Python is Matplotlib, which can be installed
    using your favorite package manager, such as `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will install the most recent version of Matplotlib, which, at the time
    of writing this book, is version 3.5.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matplotlib contains numerous sub-packages, but the main `matplotlib.pyplot`
    package, which, by convention, is imported under the `plt` alias. This is achieved
    using the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Many of the recipes in this chapter also require NumPy, which, as usual, is
    imported under the `np` alias.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the `Chapter 02` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2002).
  prefs: []
  type: TYPE_NORMAL
- en: Basic plotting with Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plotting is an important part of understanding behavior. So much can be learned
    by simply plotting a function or data that would otherwise be hidden. In this
    recipe, we will walk through how to plot simple functions or data using Matplotlib,
    set the plotting style, and add labels to a plot.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib is a very powerful plotting library, which means it can be rather
    intimidating to perform simple tasks with it. For users who are used to working
    with MATLAB and other mathematical software packages, there is a state-based interface
    called `pyplot`. There is also an `pyplot` interface is a convenient way to create
    basic objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most commonly, the data that you wish to plot will be stored in two separate
    NumPy arrays, which we will label `x` and `y` for clarity (although this naming
    does not matter in practice). We will demonstrate plotting the graph of a function,
    so we will generate an array of `x` values and use the function to generate the
    corresponding `y` values. We’re going to plot three different functions over the
    range ![](img/Formula_02_001.png) on the same axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s plot these three functions in Python using Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can plot the function, we must generate `x` and `y` data to be plotted.
    If you are plotting existing data, you can skip these commands. We need to create
    a set of `x` values that cover the desired range, and then use the function to
    create `y` values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linspace` routine from NumPy is ideal for creating arrays of numbers for
    plotting. By default, it will create 50 equally spaced points between the specified
    arguments. The number of points can be customized by providing an additional argument,
    but 50 is sufficient for most cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have created `x` values, we can generate `y` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To plot the data, we first need to create a new figure and attach axes objects,
    which can be achieved by calling the `plt.subplots` routine without any arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use the `plot` method on the `ax` object to plot the first function.
    The first two arguments are ![](img/Formula_02_002.png) and ![](img/Formula_02_003.png)
    coordinates to be plotted, and the third (optional) argument specifies that the
    line color should be black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To help distinguish the plots for the other functions, we plot those with a
    dashed line and a dot-dash line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Every plot should have a title and axis labels. In this case, there isn’t anything
    interesting to label the axes with, so we just label them `"x"` and `"y"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s also add a legend to help you distinguish between the different function
    plots without having to look elsewhere to see which line is which:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s annotate the plot to mark the intersection between the functions
    ![](img/Formula_02_004.png) and ![](img/Formula_02_005.png) with text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will plot the `y` values against the `x` values on a new figure. If you
    are working within IPython or with a Jupyter notebook, then the plot should automatically
    appear at this point; otherwise, you might need to call the `plt.show` function
    to make the plot appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `plt.show`, the figure should appear in a new window. We won’t add
    this command to any further recipes in this chapter, but you should be aware that
    you will need to use it if you are not working in an environment where plots will
    be rendered automatically, such as an IPython console or a Jupyter Notebook. The
    resulting plot should look something like the plot in *Figure 2**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Three functions on a single set of axes, each with a different
    style, with labels, legend, and an annotation](img/B19085_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Three functions on a single set of axes, each with a different
    style, with labels, legend, and an annotation
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Jupyter notebook and the `subplots` command, you must include
    the call to `subplots` within the same cell as the plotting commands or the figure
    will not be produced.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we’re using the OOI because it allows us to keep track of exactly which
    figure and axes object we’re plotting on. This isn’t so important here where we
    have only a single `figure` and `axes`, but one can easily envisage situations
    where you might have two or more figures and axes concurrently. Another reason
    to follow this pattern is to be consistent when you add multiple subplots—see
    the *Adding* *subplots* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can produce the same plot as in the recipe via the state-based interface
    by using the following sequence of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If there are currently no `Figure` or `Axes` objects, the `plt.plot` routine
    creates a new `Figure` object, adds a new `Axes` object to the figure, and populates
    this `Axes` object with the plotted data. A list of handles to the plotted lines
    is returned. Each of these handles is a `Lines2D` object. In this case, this list
    will contain a single `Lines2D` object. We could use this `Lines2D` object to
    further customize the appearance of the line later.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the preceding code, we combined all the calls to the `plot` routine
    together. This is also possible if you use the OOI; the state-based interface
    is passing the arguments to the axes method on the set of axes that it either
    retrieves or creates.
  prefs: []
  type: TYPE_NORMAL
- en: The object layer of Matplotlib interacts with a lower-level *backend*, which
    does the heavy lifting of producing the graphical plot. The `plt.show` function
    issues an instruction to the backend to render the current figure. There are a
    number of backends that can be used with Matplotlib, which can be customized by
    setting the `MPLBACKEND` environment variable, modifying the `matplotlibrc` file,
    or by calling `matplotlib.use` from within Python with the name of an alternative
    backend. By default, Matplotlib picks a backend that is appropriate for the platform
    (Windows, macOS, Linux) and purpose (interactive or non-interactive), based on
    which backends are available. For example, on the author’s system, the `QtAgg`
    backend is the default. This is an interactive backend based on the `QtCairo`
    backend, which uses the Cairo library for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `plt.show` function does more than simply call the `show` method on a figure.
    It also hooks into an event loop to correctly display the figure. The `plt.show`
    routine should be used to display a figure, rather than the `show` method on a
    `Figure` object.
  prefs: []
  type: TYPE_NORMAL
- en: The **format string** used to quickly specify the line style has three optional
    parts, each consisting of one or more characters. The first part controls the
    marker style, which is the symbol that is printed at each data point; the second
    controls the style of the line that connects the data points; the third controls
    the color of the plot. In this recipe, we only specified the line style. However,
    one could specify both line style and marker style or just marker style. If you
    only provide the marker style, no connecting lines are drawn between the points.
    This is useful for plotting discrete data where no interpolation between points
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Four line-style parameters are available: a solid line (`-`), a dashed line
    (`--`), a dash-dot line (`-.`), or a dotted line (`:`). Only a limited number
    of colors can be specified in the format string; they are red, green, blue, cyan,
    yellow, magenta, black, and white. The character used in the format string is
    the first letter of each color (with the exception of black), so the corresponding
    characters are `r`, `g`, `b`, `c`, `y`, `m`, `k`, and `w`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, we saw three examples of these format strings: the single `k`
    format string only changed the color of the line and kept the other settings at
    default (small point markers and unbroken blue line); the `k--` and `k.-` format
    strings both changed the color and the line style. For an example of changing
    the point style, see the *There’s more...* section and *Figure 2**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 - Plot of three sets of data, each plotted using a different marker
    style'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 - Plot of three sets of data, each plotted using a different marker
    style
  prefs: []
  type: TYPE_NORMAL
- en: The `set_title`, `set_xlabel`, and `set_ylabel` methods simply add the text
    argument to the corresponding position of the `Axes` object. The `legend` method,
    as called in the preceding code, adds the labels to the datasets in the order
    that they were added to the plot—in this case, `y1`, `y2`, and then `y3`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of keyword arguments that can be supplied to the `set_title`,
    `set_xlabel`, and `set_ylabel` routines to control the style of the text. For
    example, the `fontsize` keyword can be used to specify the size of the label font
    in the usual `pt` point measure.
  prefs: []
  type: TYPE_NORMAL
- en: The `annotate` method on the `Axes` object adds arbitrary text to a specific
    position on the plot. This routine takes two arguments—the text to display as
    a string and the coordinates of the point at which the annotation should be placed.
    This routine also accepts keyword arguments that can be used to customize the
    style of the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `plt.plot` routine accepts a variable number of positional inputs. In the
    preceding code, we supplied two positional arguments that were interpreted as
    `x` values and `y` values (in that order). If we had instead provided only a single
    array, the `plot` routine would have plotted the values against their position
    in the array; that is, the `x` values are taken to be `0`, `1`, `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot` method also accepts a number of keyword arguments that can also be
    used to control the style of a plot. Keyword arguments take precedence over format
    string parameters if both are present, and they apply to all sets of data plotted
    by the call. The keyword to control the marker style is `marker`, the keyword
    for the line style is `linestyle`, and the keyword for color is `color`. The `color`
    keyword argument accepts a number of different formats to specify a color, which
    includes RGB values as a `(r, g, b)` tuple, where each character is a float between
    `0` and `1` or is a hex string. The width of the line plotted can be controlled
    using the `linewidth` keyword, which should be provided with a `float` value.
    Many other keyword arguments can be passed to `plot`; a list is given in the Matplotlib
    documentation. Many of these keyword arguments have a shorter version, such as
    `c` for `color` and `lw` for `linewidth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the this recipe, we plotted a large number of coordinates generated by evaluating
    functions on a selection of ![](img/Formula_02_017.png) values. In other applications,
    one might have data sampled from the real world (as opposed to generated). In
    these situations, it might be better to leave out the connecting lines and simply
    plot the markers at the points. Here is an example of how this might be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result of these commands is shown in *Figure 2**.2*. Matplotlib has a specialized
    method for producing scatter plots such as this, called `scatter`.
  prefs: []
  type: TYPE_NORMAL
- en: Other aspects of the plot can be customized by using methods on the `Axes` object.
    The axes ticks can be modified using the `set_xticks` and `set_yticks` methods
    on the `Axes` object, and the grid appearance can be configured using the `grid`
    method. There are also convenient methods in the `pyplot` interface that apply
    these modifications to the current axes (if they exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we modify the axis limits, set the ticks at every multiple of
    `0.5` in both the ![](img/Formula_02_006.png) and ![](img/Formula_02_008.png)
    direction, and add a grid to the plot by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we set the limits slightly larger than the extent of the plot. This
    is to avoid markers being placed on the boundary of the plot window.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib has many other plotting routines besides the `plot` routine described
    here. For example, there are plotting methods that use a different scale for the
    axes, including the logarithmic ![](img/Formula_02_009.png) or ![](img/Formula_02_010.png)
    axes separately (`semilogx` or `semilogy`, respectively) or together (`loglog`).
    These are explained in the Matplotlib documentation. The `scatter` plotting routine
    may be useful if you wish to plot discrete data on axes without connecting the
    points with a line. This allows more control over the style of the marker. For
    example, you can scale the marker according to some additional information.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a different font by using the `fontfamily` keyword, the value of
    which can be the name of a font or `serif`, `sans-serif`, or `monospace`, which
    will choose the appropriate built-in font. A complete list of modifiers can be
    found in the Matplotlib documentation for the `matplotlib.text.Text` class.
  prefs: []
  type: TYPE_NORMAL
- en: Text arguments can also be rendered using TeX for additional formatting by supplying
    `usetex=True` to the routine. We’ll demonstrate the use of TeX formatting of labels
    in *Figure 2**.3* in the following recipe. This is especially useful if the title
    or axis label contains a mathematical formula. Unfortunately, the `usetex` keyword
    argument cannot be used if TeX is not installed on the system—it will cause an
    error in this case. However, it is still possible to use the TeX syntax for formatting
    mathematical text within labels, but this will be typeset by Matplotlib, rather
    than by TeX.
  prefs: []
  type: TYPE_NORMAL
- en: Adding subplots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, it is useful to place multiple related plots within the same figure
    side by side but not on the same axes. Subplots allow us to produce a grid of
    individual plots within a single figure. In this recipe, we will see how to create
    two plots side by side on a single figure using subplots.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the data to be plotted on each subplot. As an example, we will
    plot the first five iterates of Newton’s method applied to the ![](img/Formula_02_011.png)
    function with an initial value of ![](img/Formula_02_012.png) on the first subplot,
    and for the second, we will plot the error of the iterate. We first define a generator
    function to get the iterates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This routine generates two lists. The first list contains iterates of Newton’s
    method applied to the function, and the second contains the error in the approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to create a figure that contains multiple subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `subplots` routine to create a new figure and references to all
    of the `Axes` objects in each subplot, arranged in a grid with one row and two
    columns. We also set the `tight_layout` keyword argument to `True` to fix the
    layout of the resulting plots. This isn’t strictly necessary, but it is in this
    case as it produces a better result than the default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once `Figure` and `Axes` objects are created, we can populate the figure by
    calling the relevant plotting method on each `Axes` object. For the first plot
    (displayed on the left), we use the `plot` method on the `ax1` object, which has
    the same signature as the standard `plt.plot` routine. We can then call the `set_title`,
    `set_xlabel`, and `set_ylabel` methods on `ax1` to set the title and the `x` and
    `y` labels. We also use TeX formatting for the axes labels by providing the `usetex`
    keyword argument; you can ignore this if you don’t have TeX installed on your
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can plot the error values on the second plot (displayed on the right)
    using the `ax2` object. We use an alternative plotting method that uses a logarithmic
    scale on the ![](img/Formula_02_014.png) axis, called `semilogy`. The signature
    for this method is the same as the standard `plot` method. Again, we set the axes
    labels and the title. Again, the use of `usetex` can be left out if you don’t
    have TeX installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this sequence of commands is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 - Multiple subplots on the same Matplotlib figure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 - Multiple subplots on the same Matplotlib figure
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side plots the first five iterates of Newton’s method, and the
    right-hand side is the approximation error plotted on a logarithmic scale.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Figure` object in Matplotlib is simply a container for plot elements, such
    as `Axes`, of a certain size. A `Figure` object will usually only hold a single
    `Axes` object, which occupies the entire figure area, but it can contain any number
    of `Axes` objects in the same area. The `subplots` routine does several things.
    It first creates a new figure and then creates a grid with the specified shape
    in the figure area. Then, a new `Axes` object is added to each position of the
    grid. The new `Figure` object and one or more `Axes` objects are then returned
    to the user. If a single subplot is requested (one row and one column, with no
    arguments) then a plain `Axes` object is returned. If a single row or column is
    requested (with more than one column or row, respectively), then a list of `Axes`
    objects is returned. If more than one row and column are requested, a list of
    lists, with rows represented by inner lists filled with `Axes` objects, will be
    returned. We can then use the plotting methods on each of the `Axes` objects to
    populate the figure with the desired plots.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the standard `plot` method for the left-hand side plot,
    as we have seen in previous recipes. However, for the right-hand side plot, we
    used a plot where the ![](img/Formula_02_015.png) axis had been changed to a logarithmic
    scale. This means that each unit on the ![](img/Formula_02_015.png) axis represents
    a change of a power of 10 rather than a change of one unit so that `0` represents
    ![](img/Formula_02_016.png), `1` represents 10, `2` represents 100, and so on.
    The axes labels are automatically changed to reflect this change in scale. This
    type of scaling is useful when the values change by an order of magnitude, such
    as the error in an approximation, as we use more and more iterations. We can also
    plot with a logarithmic scale for ![](img/Formula_02_017.png) only by using the
    `semilogx` method, or both axes on a logarithmic scale by using the `loglog` method.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to create subplots in Matplotlib. If you have already
    created a `Figure` object, then subplots can be added using the `add_subplot`
    method of the `Figure` object. Alternatively, you can use the `subplot` routine
    from `matplotlib.pyplot` to add subplots to the current figure. If one does not
    yet exist, it will be created when this routine is called. The `subplot` routine
    is a convenience wrapper of the `add_subplot` method on the `Figure` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created two plots with differently scaled ![](img/Formula_02_018.png)
    axes. This demonstrates one of the many possible uses of subplots. Another common
    use is for plotting data in a matrix where columns have a common `x` label and
    rows have a common `y` label, which is especially common in multivariate statistics
    when investigating the correlation between various sets of data. The `plt.subplots`
    routine for creating subplots accepts the `sharex` and `sharey` keyword parameters,
    which allows the axes to be shared among all subplots or among a row or column.
    This setting affects the scale and ticks of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib supports more advanced layouts by providing the `gridspec_kw` keyword
    arguments to the `subplots` routine. See the documentation for `matplotlib.gridspec`
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting with error bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite common that the values that we gather from the real world carry
    some uncertainty; no measurement of a real-world quantity is perfectly accurate.
    For example, if we measure a distance with a tape measure, there is a certain
    amount of accuracy that we can assume in our results, but beyond this accuracy,
    we cannot be sure that our measurement is valid. For such a situation, we can
    probably be confident of our accuracy up to about 1 millimeter or a little less
    than 1/16 inch. (This is, of course, assuming that we are measuring perfectly.)
    These values are the smallest subdivisions on typical tape measures. Let’s assume
    that we have collected such a set of 10 measurements (in centimeters) and we wish
    to plot these values along with the accuracy that we are confident about. (The
    range of values that lie above or below the measurement by the accuracy amount
    is called the *error*.) This is what we address in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, we have the Matplotlib `pyplot` interface imported under the alias
    `plt`. We first need to generate our hypothetical data and the assumed accuracy
    in NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how to use plotting routines in Matplotlib to plot these measurements
    with error bars to indicate the uncertainty in each measurement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps show how to plot measurements along with accuracy information
    on a figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to generate a new `figure` and `axis` object as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `errorbar` method on the axis object to plot the data along
    with the error bars. The accuracy information (the error) is passed as the `yerr`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we should always add meaningful labels to the axes and a title to
    the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Matplotlib will not produce `xlabel` ticks at every value by default,
    we set the x-tick values to the measurement IDs so that they are all displayed
    on the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot is shown in *Figure 2**.4*. The recorded value is shown
    at the `x` markers, and the error bar extends above and below that value by an
    accuracy of 0.1 cm (1 mm):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 - Plot of a set of 10 sample measurements (in centimeters) with
    their measurement error shown'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 - Plot of a set of 10 sample measurements (in centimeters) with their
    measurement error shown
  prefs: []
  type: TYPE_NORMAL
- en: We can see here that each of the markers has a vertical bar that indicates the
    range in which we expect the true measurement (![](img/Formula_02_019.png)-value)
    to lie.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `errorbar` method works in a similar way to other plotting methods. The
    first two arguments are the ![](img/Formula_02_020.png) and ![](img/Formula_02_021.png)
    coordinates of the points to be plotted. (Note that both must be provided, which
    is not the case for other plotting methods.) The `yerr` argument indicates the
    size of the error bars to be added to the plot and should all be positive values.
    The form of the value(s) passed to this argument determines the nature of the
    error bars. In the recipe, we provided a flat NumPy array with 10 entries—one
    for each measurement—which leads to error bars above and below each point with
    the same size (the corresponding value from the argument). Alternatively, we could
    have specified a 2-by-10 array, where the first row contains the lower error and
    the second row contains the upper error. (Since all our errors are the same, we
    could also have provided a single float containing the common error for all measurements.)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the data arguments, there are the usual format arguments, including
    the `fmt` format string. (We used this here as a keyword argument because we named
    the `yerr` argument that precedes it.) In addition to the formatting of lines
    and points found in other plotting methods, there are special arguments for customizing
    the look of error bars. In the recipe, we used the `capsize` argument to add “caps”
    to either end of the error bars so that we could easily identify the ends of those
    bars; the default style is a simple line.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we only plotted errors in the ![](img/Formula_02_022.png) axis
    because the ![](img/Formula_02_023.png) values were simply ID values. If both
    sets of values have uncertainty, you can also specify the ![](img/Formula_02_024.png)
    error values using the `xerr` argument. This argument functions in the same way
    as the `yerr` argument used previously.
  prefs: []
  type: TYPE_NORMAL
- en: If you are plotting a very large number of points that follow some kind of trend,
    you might wish to plot error bars more selectively. For this, you can use the
    `errorevery` keyword argument to instruct Matplotlib to add error bars at every
    `n`th data point rather than at all of them. This can be either a positive integer—indicating
    the “stride” to use to select points that will have errors—or a tuple containing
    an offset from the first value and a stride. For example, `errorevery=(2, 5)`
    would place error bars every five data points, starting from the second entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add error bars to bar charts in the same way (except here, the
    `xerr` and `yerr` arguments are keywords only). We could have plotted the data
    from the recipe as a bar chart using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If this line is used instead of the call to `errorbar` in the recipe, then
    we would get a bar chart, as shown in *Figure 2**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 - Bar chart of measurements with error bars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 - Bar chart of measurements with error bars
  prefs: []
  type: TYPE_NORMAL
- en: As before, the measurement bar is capped with an indicator of the ![](img/Formula_02_025.png)
    range in which we expect the true measurement to lie.
  prefs: []
  type: TYPE_NORMAL
- en: Saving Matplotlib figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work in an interactive environment, such as an IPython console or a
    Jupyter notebook, displaying a figure at runtime is perfectly normal. However,
    there are plenty of situations where it would be more appropriate to store a figure
    directly to a file, rather than rendering it on screen. In this recipe, we will
    see how to save a figure directly to a file, rather than displaying it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the data to be plotted and the path or file object in which you
    wish to store the output. We store the result in `savingfigs.png` in the current
    directory. In this example, we will plot the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how to plot this curve using Matplotlib and save the resulting plot
    to a file (without needing to interact with the plot GUI).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to save a Matplotlib plot directly to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a figure, as usual, and add any labels, titles,
    and annotations that are necessary. The figure will be written to the file in
    its current state, so any changes to the figure should be made before saving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use the `savefig` method on `fig` to save this figure to a file. The
    only required argument is the path to output to or a file-like object that the
    figure can be written to. We can adjust various settings for the output format,
    such as the resolution, by providing the appropriate keyword arguments. We’ll
    set the `300`, which is a reasonable resolution for most applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Matplotlib will infer that we wish to save the image in the `format` keyword),
    or it will fall back to the default from the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `savefig` method chooses the appropriate backend for the output format and
    then renders the current figure in that format. The resulting image data is written
    to the specified path or file-like object. If you have manually created a `Figure`
    instance, the same effect can be achieved by calling the `savefig` method on that
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `savefig` routine takes a number of additional optional keyword arguments
    to customize the output image. For example, the resolution of the image can be
    specified using the `dpi` keyword. The plots in this chapter have been produced
    by saving the Matplotlib figures to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The output formats available include PNG, `quality` and `optimize`. A dictionary
    of image metadata can be passed to the `metadata` keyword, which will be written
    as image metadata when saving.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples gallery on the Matplotlib website includes examples of embedding
    Matplotlib figures into a GUI application using several common Python GUI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Surface and contour plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib can also plot three-dimensional data in a variety of ways. Two common
    choices for displaying data such as this are using **surface plots** or **contour
    plots** (think of contour lines on a map). In this recipe, we will see a method
    for plotting surfaces from three-dimensional data and how to plot contours of
    three-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To plot three-dimensional data, it needs to be arranged into two-dimensional
    arrays for the ![](img/Formula_02_026.png), ![](img/Formula_02_027.png), and ![](img/Formula_02_028.png)
    components, where both the ![](img/Formula_02_029.png) and ![](img/Formula_02_030.png)
    components must be of the same shape as the ![](img/Formula_02_031.png) component.
    For the sake of this demonstration, we will plot the surface corresponding to
    the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For 3D data, we can’t just use the routines from the `pyplot` interface. We
    need to import some extra functionality from another part of Matplotlib. We’ll
    see how to do this next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to plot the function ![](img/Formula_02_033.png) on the ![](img/Formula_02_034.png)
    and ![](img/Formula_02_035.png) range. The first task is to create a suitable
    grid of ![](img/Formula_02_036.png) pairs on which to evaluate this function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use `np.linspace` to generate a reasonable number of points in these
    ranges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create a grid on which to create our ![](img/Formula_02_037.png)
    values. For this, we use the `np.meshgrid` routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can create ![](img/Formula_02_038.png) values to plot, which hold the
    value of the function at each of the grid points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To plot three-dimensional surfaces, we need to load a Matplotlib toolbox, `mplot3d`,
    which comes with the Matplotlib package. This won’t be used explicitly in the
    code, but behind the scenes, it makes the three-dimensional plotting utilities
    available to Matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a new figure and a set of three-dimensional axes for the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can call the `plot_surface` method on these axes to plot the data (we
    set the colormap to gray for better visibility in print; see the next recipe for
    a more detailed discussion):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is extra important to add axis labels to three-dimensional plots because
    it might not be clear which axis is which on the displayed plot. We also set the
    title at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use the `plt.show` routine to display the figure in a new window (if
    you are using Python interactively and not in a Jupyter notebook or on an IPython
    console) or `plt.savefig` to save the figure to a file. The result of the preceding
    sequence is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 - A three-dimensional surface plot produced with Matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 - A three-dimensional surface plot produced with Matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'Contour plots do not require the `mplot3d` toolkit, and there is a `contour`
    routine in the `pyplot` interface that produces contour plots. However, unlike
    the usual (two-dimensional) plotting routines, the `contour` routine requires
    the same arguments as the `plot_surface` method. We use the following sequence
    to produce a plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is shown in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 - Contour plot produced using Matplotlib with the default settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 - Contour plot produced using Matplotlib with the default settings
  prefs: []
  type: TYPE_NORMAL
- en: The peak and basin of the function are shown clearly here by the rings of concentric
    circles. In the top right, the shading is lighter, indicating that the function
    is increasing, and in the bottom left, the shade is darker, indicating that the
    function is decreasing. The curve that separates the regions in which the function
    is increasing and decreasing is shown between them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mplot3d` toolkit provides an `Axes3D` object, which is a three-dimensional
    version of the `Axes` object in the core Matplotlib package. This is made available
    to the `axes` method on a `Figure` object when the `projection="3d"` keyword argument
    is given. A surface plot is obtained by drawing quadrilaterals in the three-dimensional
    projection between nearby points in the same way that a two-dimensional curve
    is approximated by straight lines joining adjacent points.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot_surface` method needs the ![](img/Formula_02_039.png) values to be
    provided as a two-dimensional array that encodes the ![](img/Formula_02_040.png)
    values on a grid of ![](img/Formula_02_041.png) pairs. We created a range of ![](img/Formula_02_042.png)
    and ![](img/Formula_02_043.png) values that we are interested in, but if we simply
    evaluate our function on the pairs of corresponding values from these arrays,
    we will get the ![](img/Formula_02_044.png) values along a line and not over a
    grid. Instead, we use the `meshgrid` routine, which takes the two `X` and `Y`
    arrays and creates from them a grid consisting of all the possible combinations
    of values in `X` and `Y`. The output is a pair of two-dimensional arrays on which
    we can evaluate our function. We can then provide all three of these two-dimensional
    arrays to the `plot_surface` method.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The routines described in the preceding section, `contour` and `plot_surface`,
    only work with highly structured data where the ![](img/Formula_02_045.png), ![](img/Formula_02_046.png),
    and ![](img/Formula_02_047.png) components are arranged into grids. Unfortunately,
    real-life data is rarely so structured. In this case, you need to perform some
    kind of interpolation between known points to approximate the value on a uniform
    grid, which can then be plotted. A common method for performing this interpolation
    is by triangulating the collection of ![](img/Formula_02_048.png) pairs and then
    using the values of the function on the vertices of each triangle to estimate
    the value on the grid points. Fortunately, Matplotlib has a method that does all
    of these steps and then plots the result, which is the `plot_trisurf` routine.
    We briefly explain how this can be used here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the use of `plot_trisurf`, we will plot a surface and contours
    from the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we will plot both the surface and contour (approximations) on the
    same figure as two separate subplots. For this, we supply the `projection="3d"`
    keyword argument to the subplot that will contain the surface. We use the `plot_trisurf`
    method on the three-dimensional axes to plot the approximated surface, and the
    `tricontour` method on the two-dimensional axes to plot the approximated contours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now plot the contours for the triangulated surface using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We include the `tight_layout=True` keyword argument with the figure to save
    a call to the `plt.tight_layout` routine later. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 - Approximate surface and contour plots generated from unstructured
    data using triangulation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 - Approximate surface and contour plots generated from unstructured
    data using triangulation
  prefs: []
  type: TYPE_NORMAL
- en: In addition to surface plotting routines, the `Axes3D` object has a `plot` (or
    `plot3D`) routine for simple three-dimensional plotting, which works exactly as
    the usual `plot` routine but on three-dimensional axes. This method can also be
    used to plot two-dimensional data on one of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib is the go-to plotting library for Python, but other options do exist.
    We’ll see the Bokeh library in [*Chapter 6*](B19085_06.xhtml#_idTextAnchor226).
    There are other libraries, such as Plotly (https://plotly.com/python/), that simplify
    the process of creating certain types of plots and adding more features, such
    as interactive plots.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing three-dimensional plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contour plots can hide some detail of the surface that they represent since
    they only show where the “height” is similar and not what the value is, even in
    relation to the surrounding values. On a map, this is remedied by printing the
    height onto certain contours. Surface plots are more revealing, but the problem
    of projecting three-dimensional objects into 2D to be displayed on a screen can
    itself obscure some details. To address these issues, we can customize the appearance
    of a three-dimensional plot (or contour plot) to enhance the plot and make sure
    the detail that we wish to highlight is clear. The easiest way to do this is by
    changing the colormap of the plot, as we saw in the previous recipe. (By default,
    Matplotlib will produce surface plots with a single color, which makes details
    difficult to see in printed media.) In this recipe, we look at some other ways
    we can customize 3D surface plots, including changing the initial angle of the
    display and changing the normalization applied for the colormap.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will further customize the function we plotted in the previous
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We generate points at which this should be plotted, as in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how to customize a three-dimensional plot of these values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to customize the appearance of a 3D plot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, our first task is to create a new figure and axes on which we will
    plot. Since we’re going to customize the properties of the `Axes3D` object, we’ll
    just create a new figure first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a new `Axes3D` object to this figure and change the initial
    viewing angle by setting the `azim` and `elev` keyword arguments along with the
    `projection=``"3d"` keyword argument that we have seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, we can now plot the surface. We’re going to change the bounds
    of the normalization so that the maximum value and minimum value are not at the
    extreme ends of our colormap. We do this by changing the `vmin` and `vmax` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can set up the axes labels and the title as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot is shown in *Figure 2**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 - Customized 3D surface plot with modified normalization and an
    initial viewing angle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 - Customized 3D surface plot with modified normalization and an initial
    viewing angle
  prefs: []
  type: TYPE_NORMAL
- en: Comparing *Figure 2**.6* with *Figure 2**.9*, we can see that the latter generally
    contains darker shades compared to the former, and the viewing angle offers a
    better view of the basin where the function is minimized. The darker shade is
    due to the normalization applied to the values for the colormap, which we altered
    using the `vmin` and `vmax` keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Color mapping works by assigning an RGB value according to a scale—the `0` and
    `1`, which is typically done by a linear transformation that takes the minimum
    value to `0` and the maximum value to `1`. The appropriate color is then applied
    to each face of the surface plot (or line, in another kind of plot).
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we used the `vmin` and `vmax` keyword arguments to artificially
    change the value that is mapped to `0` and `1`, respectively, for the purposes
    of fitting the colormap. In effect, we changed the ends of the color range applied
    to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib comes with a number of built-in colormaps that can be applied by
    simply passing the name to the `cmap` keyword argument. A list of these colormaps
    is given in the documentation ([https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html))
    and also comes with a reversed variant, which is obtained by adding the `_r` suffix
    to the name of the chosen colormap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The viewing angle for a 3D plot is described by two angles: the `Axes3D` is
    -60 Azimuthal and 30 elevation. In the recipe, we used the `azim` keyword argument
    of `plot_surface` to change the initial Azimuthal angle to -80 degrees (almost
    from the direction of the negative ![](img/Formula_02_052.png) axis) and the `elev`
    argument to change the initial elevation to 22 degrees.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The normalization step in applying a colormap is performed by an object derived
    from the `Normalize` class. Matplotlib provides a number of standard normalization
    routines, including `LogNorm` and `PowerNorm`. Of course, you can also create
    your own subclass of `Normalize` to perform the normalization. An alternative
    `Normalize` subclass can be added using the `norm` keyword of `plot_surface` or
    other plotting functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more advanced uses, Matplotlib provides an interface for creating custom
    shading using light sources. This is done by importing the `LightSource` class
    from the `matplotlib.colors` package, and then using an instance of this class
    to shade the surface elements according to the ![](img/Formula_02_053.png) value.
    This is done using the `shade` method on the `LightSource` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Complete examples are shown in the Matplotlib gallery should you wish to learn
    more about how this.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the viewing angle, we can also change the type of projection
    used to represent 3D data as a 2D image. The default is a perspective projection,
    but we can also use an orthogonal projection by setting the `proj_type` keyword
    argument to `"ortho"`.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting vector fields with quiver plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vector field is a function that assigns to each point in a region a vector—it
    is a vector-valued function defined on a space. These are especially common in
    the study of (systems of) differential equations, where a vector field typically
    appears as the right-hand side of the equation. (See the *Solving systems of differential
    equations* recipe from [*Chapter 3*](B19085_03.xhtml#_idTextAnchor078) for more
    details.) For this reason, it is often useful to visualize a vector field and
    understand how the function will evolve over space. For now, we’re simply going
    to produce a plot of a vector field using a quiver plot, which takes a set of
    ![](img/Formula_02_054.png) and ![](img/Formula_02_055.png) coordinates and a
    set of ![](img/Formula_02_056.png) and ![](img/Formula_02_057.png) vectors, and
    produces a plot on which each point has an arrow in the direction ![](img/Formula_02_058.png)
    and whose length is the length of this vector. (Hopefully, this will become more
    clear when we actually create the said plot.)
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we import the Matplotlib `pyplot` interface under the alias `plt`.
    Before we start, we need to define a function that takes a point and produces
    a vector; we’ll use this later to generate ![](img/Formula_02_059.png) and ![](img/Formula_02_060.png)
    data that will be passed to the plotting function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we’re going to plot the following vector field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_02_061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this example, we’ll plot the vector field over the region where ![](img/Formula_02_062.png)
    and ![](img/Formula_02_063.png).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps show how to visualize the aforementioned vector field over
    the specified region.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define a Python function that evaluates our vector field
    at points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create our grid of points covering the region. For this, we
    first create a temporary `linspace` routine with values between `-1` and `1`.
    Then, we use `meshgrid` to generate a grid of points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use our function to generate `dx` and `dy` values that describe the
    vectors at each grid point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new figure and axis and use the `quiver` method to generate
    a plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting plot is shown in *Figure 2**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 - Visualization of a vector field using a quiver plot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 - Visualization of a vector field using a quiver plot
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 2**.10*, we can see the ![](img/Formula_02_064.png) value represented
    as an arrow based at each ![](img/Formula_02_065.png) coordinate. The size of
    the arrow is determined by the magnitude of the vector field. At the origin, the
    vector field has ![](img/Formula_02_066.png), so the arrows nearby are very small.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our example from the recipe is a mathematical construction rather than something
    that might arise from real data. For this particular case, the arrows describe
    how some quantity might evolve if it flows according to the vector field we specified.
  prefs: []
  type: TYPE_NORMAL
- en: Each point in the grid is the base of an arrow. The direction of the arrow is
    given by the corresponding ![](img/Formula_02_067.png) value, and the length of
    the arrow is normalized by length (so, a vector ![](img/Formula_02_068.png) with
    smaller components produces a shorter arrow). This can be customized by changing
    the `scale` keyword argument. Many other aspects of the plot can be customized
    too.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to plot a set of trajectories that follow a vector field, you can
    use the `streamplot` method. This will plot trajectories starting at various points
    to indicate the general flow in different parts of the domain. Each streamline
    has an arrow to indicate the direction of flow. For example, *Figure 2**.11* shows
    the result of using the `streamplot` method with the vector field in the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Plot of the trajectories described by the vector field from
    the recipe'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_02_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Plot of the trajectories described by the vector field from the
    recipe
  prefs: []
  type: TYPE_NORMAL
- en: In a different scenario, you might have data about wind speed (or similar quantities)
    at a number of coordinates—on a map, say—and you want to plot these quantities
    in the standard style for weather charts. Then, we can use the `barbs` plotting
    method. The arguments are similar to the `quiver` method.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Matplotlib package is extensive, and we can scarcely do it justice in such
    a short space. The documentation contains far more detail than is provided here.
    Moreover, there is a large gallery of examples ([https://matplotlib.org/gallery/index.html#](https://matplotlib.org/gallery/index.html#))
    covering many more of the capabilities of the package than in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Other packages build on top of Matplotlib to offer high-level plotting methods
    for specific applications. For example, the Seaborn libraries provide routines
    for visualizing data ([https://seaborn.pydata.org/](https://seaborn.pydata.org/)).
  prefs: []
  type: TYPE_NORMAL
