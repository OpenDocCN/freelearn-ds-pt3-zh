<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Communication by a Graphical User Interface
                </header>
            
            <article>
                
<p class="mce-root"><strong>Graphical user interfaces (GUIs)</strong> are convenient tools to input user data to your Python program. In all likelihood, you have used tools such as <em>selection lists</em>, <em>radio buttons,</em> or <em>sliders</em> to communicate with an application. In this chapter, we show how to add some of these tools to your program. We base this chapter on tools provided by the module <strong>Matplotlib</strong>, which we already met in <a href="86c61820-e645-486c-9418-10079ffac7f8.xhtml">Section 6.2</a>: <em>Working with Matplotlib objects directly</em>.</p>
<p class="mce-root">Although there are alternatives such as the module <strong>Tkinter</strong> for a more sophisticated design of GUIs, Matplotlib appears as an ideal entry point with a low threshold to add this comfortable way of communicating with your code.</p>
<p>The purpose of this chapter is to demonstrate the basic principles of GUI programming within Matplotlib. The role of events, slider movements, or mouse clicks and their interaction with so-called call-back functions is explained, along with a couple of examples.</p>
<p>Clearly, we do not aim for completeness. Having understood the basic principles, the Matplotlib documentation is a reservoir of detailed information on various widgets and their parameters.</p>
<p>We'll cover the following main topics in this chapter:</p>
<ul>
<li>A guiding example to widgets</li>
<li>The button widget and mouse events</li>
</ul>
<h1 id="uuid-8c679fa1-1a8c-499a-8b28-26ffdf31362a">11.1 A guiding example to widgets</h1>
<p class="CDPAlignLeft CDPAlign">In this section, we present the basic components11.1 A guiding example to widgets of a <strong>widget</strong> and their counterparts in <strong>Python</strong>. We do this by using the guiding example displayed in the following figure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/78061f1f-cc54-4907-b56c-dbbe1456ad89.png" style="width:36.33em;height:17.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 11.1: A widget to display <img class="fm-editor-equation" src="assets/b7925514-4664-4123-958a-9553478a9f75.png" style="width:4.92em;height:1.33em;"/> for user-given frequencies <img class="fm-editor-equation" src="assets/9517305e-55a6-4f64-b1c6-3abe53043510.png" style="width:0.83em;height:0.83em;"/></div>
<p>In this figure, we see a slider bar at the top. With the use of a computer mouse, the blue bar can be moved from left to right and the value for <img class="fm-editor-equation" src="assets/591c783c-9836-44ff-8973-c7f37f8af6f9.png" style="width:0.83em;height:0.83em;"/>, ranging between 1 and 5, is displayed on the right of the bar.</p>
<p>Correspondingly, the frequency of the sine wave displayed in the plot window changes.</p>
<p>This widget consists of three parts:</p>
<ul>
<li>A figure object with an axes object and the plot</li>
<li>An axes object containing a slider object</li>
<li>A call-back function for updating the plot as soon as the slider value changes</li>
</ul>
<p>We discussed how to program the first part, in <span><a href="86c61820-e645-486c-9418-10079ffac7f8.xhtml">Section 6.2</a>: </span><em>Working with Matplotlib objects directly</em><span>.</span></p>
<p>In the following code snippet, we first create a figure with a given size and then a sufficiently large axes object that is placed into the figure such that its lower-left corner point is placed at the pair of figure coordinates <img class="fm-editor-equation" src="assets/4eb07a74-351a-45dd-b7d9-ebfdbdbdfd6a.png" style="width:5.00em;height:1.33em;"/>. Then, the user is asked to input a floating-point number between 1 and 5 for the frequency <img class="fm-editor-equation" src="assets/01537198-cd5f-4422-b047-3271dda4542a.png" style="width:0.75em;height:0.75em;"/>:</p>
<pre>from matplotlib.pyplot import *<br/>fig = figure(figsize = (4,2))<br/>ax = axes([0.1, 0.15, 0.8, 0.7]) # axes for the plot<br/>omega=float(input('Give a value for $\omega$ between 1 and 5:\n'))<br/>x = linspace(-2*pi, 2*pi, 800)<br/>ax.set_ylim(-1.2, 1.2)<br/>lines, = ax.plot(x, sin(2.*pi*omega*x))</pre>
<p>Now, in the next step, we add a second axes object and put it into it a slider:</p>
<pre>from matplotlib.widgets import Slider<br/>sld_ax = axes([0.2, 0.9, 0.6, 0.05]) # axes for slider<br/>sld = Slider(sld_ax, '$\omega$ [Hz]', 1., 5., valinit=1.)<br/>omega=sld.val</pre>
<p>The axes object for the slider, <kbd>sld_ax</kbd>, is defined by giving its dimensions and the location of the left lower point in the figure's coordinate system.</p>
<p>The new construction element is the <kbd>Slider</kbd> object. Its constructor uses the slider axes, a label, and maximum and minimum values displayed on the left and right sides of the slider. The slider object has an attribute <kbd>val</kbd>, which contains the value given by the slider position.</p>
<p>Initially, the slider position is set to <kbd>valinit</kbd>.</p>
<p>The last part is the core part of the program, the call-back function, and the update of the plot, whenever the slider value changes:</p>
<pre>def update_frequency(omega):<br/> lines.set_ydata(np.sin(2.*pi*omega*x))<br/> <br/>sld.on_changed(update_frequency) </pre>
<p>A call-back function is a function called when the slider (or another widget object) is changed. In our case, it is the function <kbd>update_frequency</kbd>. The slider method <kbd>on_changed</kbd> defines the action to be performed whenever the slider value changes. Here, the function <kbd>update_frequency</kbd> is called with the slider value <kbd>val</kbd> as its single argument.</p>
<p>We will conclude this introductory section by putting the parts together. Note that there is no longer any need for the input function used in the beginning as we now use the much more elegant GUI method to input values. We also provided the plot with a legend to display the use of the slider value. Note how string formatting and LaTeX commands were combined: </p>
<pre class="mce-root">from matplotlib.pyplot import *<br/>from matplotlib.widgets import Slider<br/><br/>fig = figure(figsize = (4,2))<br/>sld_ax = axes([0.2, 0.9, 0.6, 0.05]) # axes for slider<br/>ax = axes([0.1, 0.15, 0.8, 0.7]) # axes for the plot<br/>ax.xaxis.set_label_text('Time [s]')<br/>ax.yaxis.set_label_text('Amplitude [m]')<br/>sld = Slider(sld_ax, '$\omega$ [Hz]', 1., 5., valinit=1.5)<br/>omega=sld.val<br/>x = linspace(-2*pi, 2*pi, 800)<br/>ax.set_ylim(-1.2, 1.2)<br/># Plot of the initial curve<br/># Note, how LaTeX commands and string formatting is combined in the <br/># next command<br/>lines, = ax.plot(x, sin(2.*pi*omega*x), label=f'$\sin(2\pi\; {omega} x)$ ')<br/>ax.legend()<br/><br/>def update_frequency(omega):<br/> lines.set_ydata(np.sin(2.*pi*omega*x))<br/> # A legend is updated by p text box widget set_varroviding tuples <br/> # with line objects and tuples with labels<br/> ax.legend((lines,),(f'$\sin(2\pi\; {omega} x)$',)) <br/><br/> <br/>sld.on_changed(update_frequency)</pre>
<p>In this section, we demonstrated the use of a widget for user input. It is a user-friendly way to ask for parameters and to display related results.</p>
<h2 id="uuid-377752d1-ffbc-4146-9bbf-9ebb70298fc8">11.1.1 Changing a value with a slider bar</h2>
<p class="mce-root">In the last section, we covered the use of a slider. The most important attribute of a slider is its value, <kbd>val</kbd>. This is communicated to the call-back function.</p>
<p>Other attributes are the limits of the value given by the slider, <kbd>valmin</kbd>, and <kbd>valmax</kbd>, and a stepping functionality, <kbd>valstep</kbd>, to make the change to the value discrete. A formatting attribute, <kbd>valfmt</kbd>, allows us to specify how <kbd>valmin</kbd> and <kbd>valmax</kbd> are displayed.</p>
<p>In the next example, we modify the slider definition from above and provide it with these more specific attributes:</p>
<pre class="mce-root">sld = Slider(sld_ax, label='$\omega$ [Hz]', valmin=1., valmax=5., <br/>             valinit=1.5, valfmt='%1.1f', valstep=0.1)</pre>
<p>The formatting argument, <kbd>%1.1f</kbd>, in this example says that the value should be displayed as a floating-point number, with one digit to the left of the decimal point and one digit to the right of it.</p>
<h3 id="uuid-351816dd-281f-4874-ae10-dea7af340f2a">An example with two sliders</h3>
<p>We extend the preceding example by providing two sliders, one for the amplitude and another for the frequency, and we put the sliders in vertical mode.</p>
<p>First, we define the two slider axes:</p>
<pre>sldo_ax = axes([0.95, 0.15, 0.01, 0.6]) # axes for frequency slider<br/>slda_ax = axes([0.85, 0.15, 0.01, 0.6]) # axes for amplitude slider</pre>
<p>Then, we define the two sliders with different minimum and max<span>imum</span> values and an orientation parameter:</p>
<pre>sld_omega = Slider(sldo_ax, label='$\omega$ [Hz]', valmin=1., <br/>                   valmax=5., valinit=1.5, valfmt='%1.1f', <br/>                   valstep=0.1, orientation='vertical')<br/>sld_amp = Slider(slda_ax, label='$a$ [m]', valmin=0.5, <br/>                 valmax=2.5, valinit=1.0, valfmt='%1.1f', <br/>                 valstep=0.1, orientation='vertical')</pre>
<p>Both sliders have different call-back functions. They use the value of the related slider as an argument and the value of the other slider as a global variable:</p>
<pre>def update_frequency(omega):<br/>    lines.set_ydata(sld_amp.val*sin(2.*pi*omega*x))<br/>    ax.legend((lines,),(f'${sld_amp.val} \sin(2\pi\; {omega} x)$',)) <br/> <br/>def update_amplitude(amp):<br/>    lines.set_ydata(amp*sin(2.*pi*sld_omega.val*x))<br/>    ax.legend((lines,),(f'${amp} \sin(2\pi\; {sld_omega.val} x)$',)) <br/>    ax.set_ylim(-(amp+0.2), amp+0.2)<br/><br/>sld_omega.on_changed(update_frequency)     <br/>sld_amp.on_changed(update_amplitude) </pre>
<p>In the following figure, the GUI is displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b3cf3597-3db5-46a7-ac04-38ca819f57c1.png" style="width:38.67em;height:12.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 11.2: A curve with two parameters given by two vertical sliders</div>
<p>Some actions require that the user has to wait until the result of a change is seen. Often, it is more convenient and user-friendly to first collect the changes and then do the update. This can be made by a special button widget, which will be introduced in the next section.</p>
<h1 id="uuid-5c8cfcec-b358-4993-a1ed-2ed0c1c30b92">11.2 The button widget and mouse events</h1>
<p>The button widget is a simple little tool with a big variety of useful applications. We introduce it here by continuing the previous example and adding an update button to the GUI. Then we use a button to extract data from a curve.</p>
<h2 id="uuid-f4984eaa-7f08-4647-b74e-a495992384bb">11.2.1 Updating curve parameters with a button</h2>
<p>So far, we have updated the curve when the slider value changed and used the method <kbd>on_changed</kbd> <span>for this. </span>A complicated graphical output might take some computing time to update. In such a case, you would like to design the GUI in such a way that first, the curve parameters are set by sliders, and then a button is pressed to initiate the updating of the curve.</p>
<p>This can be achieved by the <kbd>Button</kbd> widget:</p>
<pre class="mce-root">from matplotlib.widgets import Button<br/>button_ax = axes([0.85, 0.01, 0.05, 0.05]) # axes for update button<br/>btn = Button(button_ax, 'Update', hovercolor='red')</pre>
<p>The coordinates in this example are set in such a way that the button is located under the two sliders. It is labeled by <span class="packt_screen">Update</span> and its color turns to red when the mouse is placed over the button.</p>
<p>This widget has a method, <kbd>on_clicked</kbd>, that is used instead of the slider method <kbd>on_changed</kbd>:</p>
<pre>def update(event):<br/>    lines.set_ydata(sld_amp.val*sin(2.*pi*sld_omega.val*x))<br/>    ax.legend((lines,),<br/>              (f'${sld_amp.val:1.1f} \sin(2\pi\; \<br/>              {sld_omega.val:1.1f} x)$',)) <br/>    <br/>btn.on_clicked(update)</pre>
<p>The call-back function has a single parameter, <kbd>event</kbd>. It is not used in this example. It could be used to assign different actions to the button depending on how the mouse was clicked – by a single click, double click, right-button click, or left-button click. We will look at events in more detail in the next section.</p>
<h2 id="uuid-0ad3368b-5317-4ff7-8935-1c4f3e31c689">11.2.2 Mouse events and textboxes</h2>
<p>In the last example, we encountered mouse events in the context of a button widget. We can also catch a mouse event without using a button. To this end, we need to connect a general button click to a call-back function.</p>
<p>To demonstrate this, we consider again <span>the previously generated plot of the sine wave </span>and pick <span>by mouse clicks points</span> and display their coordinates in a textbox to the plot. If clicked with the right mouse button, we also display the point <span>picked </span>by means of a red circle in the plot.</p>
<p>First, we prepare a textbox widget. We already know that we first have to position the widget by defining an axes object and then providing the widget with the desired properties:</p>
<pre class="mce-root">from matplotlib.widgets import TextBox<br/>textbox_ax=axes([0.85,0.6,0.1,0.15])<br/>txtbx=TextBox(textbox_ax, label='', initial='Clicked on:\nx=--\ny=--')</pre>
<p>We provided the box with no label but some initial text. The textbox has the attribute <kbd>val</kbd> containing the text. We will change this attribute now depending on the position of a mouse click:</p>
<pre>points, = ax.plot([], [], 'ro')<br/><br/>def onclick(event):<br/>    if event.inaxes == ax:<br/>       txtbx.set_val(<br/>           f'clicked on:\nx={event.xdata:1.1f}\ny={event.ydata:1.1f}')<br/>       if event.button==3:  # Mouse button right<br/>          points.set_xdata([event.xdata])<br/>          points.set_ydata([event.ydata])<br/>    else:<br/>           txtbx.set_val(f'clicked on:\noutside axes\n area')<br/>    fig.canvas.draw_idle() <br/>cid = fig.canvas.mpl_connect('button_press_event', onclick)</pre>
<p>As there is no widget like a button widget used, we have to couple an event to a call-back function. This is done by the canvas method, <kbd>mpl_connect</kbd>. The call-back function <kbd>onclick</kbd> reacts to the position of the mouse click. We know from the event attribute <kbd>inaxes</kbd> in which axes object the mouse click occurred. Through this, we can even access information about the button pressed, and the exact coordinates of the mouse click are also available. The call-back function makes use of a <kbd>Line2D</kbd> object, <kbd>points</kbd>, which is initialized with empty data lists before the call-back function is used for the first time. This initialization defines the plot style, red circles in this case:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f660987-525b-46b8-a02b-df6051726003.png" style="width:49.17em;height:15.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 11.3: Displaying a value on the curve by using a mouse click</div>
<h1 id="uuid-fc1bcd61-2cf2-406e-b587-b2d3feaa17d0">11.3 Summary</h1>
<p>In this chapter, we learned the basic principles of GUI programming within Matplotlib. We also considered an example that helped us to learn more about widgets. In the next chapter, we are going to learn about error and exception handling.</p>


            </article>

            
        </section>
    </body></html>