- en: Chapter 13. Stochastic Dynamical Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a discrete-time Markov chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a Poisson process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a Brownian motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a stochastic differential equation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stochastic dynamical systems** are dynamical systems subjected to the effect
    of noise. The randomness brought by the noise takes into account the variability
    observed in real-world phenomena. For example, the evolution of a share price
    typically exhibits long-term behaviors along with faster, smaller-amplitude oscillations,
    reflecting day-to-day or hour-to-hour variations.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications of stochastic systems to data science include methods for statistical
    inference (such as Markov chain Monte Carlo) and stochastic modeling for time
    series or geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic discrete-time systems include discrete-time **Markov chains**. The
    **Markov property** means that the state of a system at time *n+1* only depends
    on its state at time *n*. **Stochastic cellular automata**, which are stochastic
    extensions of cellular automata, are particular Markov chains.
  prefs: []
  type: TYPE_NORMAL
- en: As far as continuous-time systems are concerned, Ordinary Differential Equations
    with noise yield **Stochastic Differential Equations** (**SDEs**). Partial Differential
    Equations with noise yield **Stochastic Partial Differential Equations** (**SPDEs**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Point processes** are another type of stochastic process. These processes
    model the random occurrence of instantaneous events over time (arrival of customers
    in a queue or action potentials in the nervous system) or space (locations of
    trees in a forest, cities in a territory, or stars in the sky).'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, the theory of stochastic dynamical systems is based on probability
    theory and measure theory. The study of continuous-time stochastic systems builds
    upon stochastic calculus, an extension of infinitesimal calculus (including derivatives
    and integrals) to stochastic processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to simulate different kinds of stochastic systems
    with Python.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references on the subject:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of stochastic dynamical systems, available at [www.scholarpedia.org/article/Stochastic_dynamical_systems](http://www.scholarpedia.org/article/Stochastic_dynamical_systems)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Markov property on Wikipedia, available at [https://en.wikipedia.org/wiki/Markov_property](https://en.wikipedia.org/wiki/Markov_property)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a discrete-time Markov chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discrete-time Markov chains are stochastic processes that undergo transitions
    from one state to another in a state space. Transitions occur at every time step.
    Markov chains are characterized by their lack of memory in that the probability
    to undergo a transition from the current state to the next depends only on the
    current state, not the previous ones. These models are widely used in scientific
    and engineering applications.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous-time Markov processes also exist and we will cover particular instances
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains are relatively easy to study mathematically and to simulate numerically.
    In this recipe, we will simulate a simple Markov chain modeling the evolution
    of a population.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We consider a population that cannot comprise more than *N=100* individuals,
    and define the birth and death rates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We simulate a Markov chain on the finite space *{0, 1, ..., N}*. Each state
    represents a population size. The `x` vector will contain the population size
    at each time step. We set the initial state to *x[0]=25* (that is, there are 25
    individuals in the population at initialization time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we simulate our chain. At each time step *t*, there is a new birth with
    probability *ax[t]*, and independently, there is a new death with probability
    *bx[t]*. These probabilities are proportional to the size of the population at
    that time. If the population size reaches *0* or *N*, the evolution stops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s look at the evolution of the population size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We see that, at every time step, the population size can stay stable, increase,
    or decrease by 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will simulate many independent trials of this Markov chain. We could
    run the previous simulation with a loop, but it would be very slow (two nested
    `for` loops). Instead, we *vectorize* the simulation by considering all independent
    trials at once. There is a single loop over time. At every time step, we update
    all trials simultaneously with vectorized operations on vectors. The `x` vector
    now contains the population size of all trials, at a particular time. At initialization
    time, the population sizes are set to random numbers between *0* and *N*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a function that performs the simulation. At every time step, we find
    the trials that undergo births and deaths by generating random vectors, and we
    update the population sizes with vector operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s look at the histograms of the population size at different times.
    These histograms represent the probability distribution of the Markov chain, estimated
    with independent trials (the Monte Carlo method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Whereas, initially, the population sizes look uniformly distributed between
    *0* and *N*, they appear to converge to *0* or *N* after a sufficiently long time.
    This is because the states *0* and *N* are **absorbing**; once reached, the chain
    cannot leave these states. Furthermore, these states can be reached from any other
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mathematically, a discrete-time Markov chain on a space *E* is a sequence of
    random variables *X[1], X[2], ...* that satisfy the Markov property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A (stationary) Markov chain is characterized by the probability of transitions
    *P(X[j] | X[i])*. These values form a matrix called the **transition matrix**.
    This matrix is the adjacency matrix of a directed graph called the **state diagram**.
    Every node is a state, and the node *i* is connected to the node *j* if the chain
    has a non-zero probability of transition between these nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simulating a single Markov chain in Python is not particularly efficient because
    we need a `for` loop. However, simulating many independent chains following the
    same process can be made efficient with vectorization and parallelization (all
    tasks are independent, thus the problem is **embarrassingly parallel**). This
    is useful when we are interested in statistical properties of the chain (example
    of the Monte Carlo method).
  prefs: []
  type: TYPE_NORMAL
- en: There is a vast literature on Markov chains. Many theoretical results can be
    established with linear algebra and probability theory. You can find references
    and textbooks on Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: Many generalizations of discrete-time Markov chains exist. Markov chains can
    be defined on infinite state spaces, or with a continuous time. Also, the Markov
    property is important in a broad class of stochastic processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains on Wikipedia, available at [https://en.wikipedia.org/wiki/Markov_chain](https://en.wikipedia.org/wiki/Markov_chain)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absorbing Markov chains on Wikipedia, available at [https://en.wikipedia.org/wiki/Absorbing_Markov_chain](https://en.wikipedia.org/wiki/Absorbing_Markov_chain)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monte-Carlo methods on Wikipedia, available at [https://en.wikipedia.org/wiki/Monte_Carlo_method](https://en.wikipedia.org/wiki/Monte_Carlo_method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Simulating a Brownian motion* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a Poisson process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Poisson process** is a particular type of **point process**, a stochastic
    model that represents random occurrences of instantaneous events. Roughly speaking,
    the Poisson process is the least structured, or the most random, point process.
  prefs: []
  type: TYPE_NORMAL
- en: The Poisson process is a particular continuous-time Markov process.
  prefs: []
  type: TYPE_NORMAL
- en: Point processes, and notably Poisson processes, can model random instantaneous
    events such as the arrival of clients in a queue or on a server, telephone calls,
    radioactive disintegrations, action potentials of nerve cells, and many other
    phenomena.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show different methods to simulate a homogeneous stationary
    Poisson process.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s specify the `rate` value, that is, the average number of events per
    second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we will simulate the process using small time bins of 1 millisecond:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On every time bin, the probability that an event occurs is about *rate * dt*
    if *dt* is small enough. Besides, as the Poisson process has no memory, the occurrence
    of an event is independent from one bin to another. Therefore, we can sample Bernoulli
    random variables (either 1 or 0, respectively representing an experiment''s success
    or failure) in a vectorized way in order to simulate our process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `x` vector contains zeros and ones on all time bins, `1` corresponding
    to the occurrence of an event:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s display the simulated process. We draw a vertical line for each event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Another way of representing that same object is by considering the associated
    **counting process** *N(t)*,which is the number of events that have occurred until
    time *t*. Here, we can display this process using the `cumsum()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'The other (and more efficient) way of simulating the homogeneous Poisson process
    is to use the property that the time intervals between two successive events follow
    an exponential distribution. Furthermore, these intervals are independent. Thus,
    we can sample them in a vectorized way. Finally, we get our process by cumulatively
    summing all of these intervals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `y` vector contains another realization of our Poisson process, but the
    data structure is different. Every component of the vector is an event time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s display the simulated process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a Poisson process with rate ![How it works...](img/4818OS_13_25.jpg), the
    number of events in a time window of length ![How it works...](img/4818_13_15.jpg)
    follows a Poisson distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When ![How it works...](img/4818_13_16.jpg) is small, we can show that, at first
    order, this probability is about ![How it works...](img/4818_13_17.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Also, the **holding times** (delays between two consecutive events) are independent
    and follow an exponential distribution. The Poisson process satisfies other useful
    properties, such as the independent and stationary increments. This property justifies
    the first simulation method used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we only considered homogeneous time-dependent Poisson processes.
    Other types of Poisson processes include inhomogeneous (or non-homogeneous) processes
    that are characterized by a time-varying rate, and multidimensional spatial Poisson
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are further references:'
  prefs: []
  type: TYPE_NORMAL
- en: The Poisson process on Wikipedia, available at [http://en.wikipedia.org/wiki/Poisson_process](http://en.wikipedia.org/wiki/Poisson_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point processes on Wikipedia, available at [http://en.wikipedia.org/wiki/Point_process](http://en.wikipedia.org/wiki/Point_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous-time processes on Wikipedia, available at [http://en.wikipedia.org/wiki/Continuous-time_process](http://en.wikipedia.org/wiki/Continuous-time_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renewal theory on Wikipedia, available at [http://en.wikipedia.org/wiki/Renewal_theory](http://en.wikipedia.org/wiki/Renewal_theory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spatial Poisson processes on Wikipedia, available at [http://en.wikipedia.org/wiki/](http://en.wikipedia.org/wiki/)
    [Spatial_Poisson_process](http://Spatial_Poisson_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Simulating a discrete-time Markov chain* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a Brownian motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Brownian motion** (or **Wiener process**) is a fundamental object in mathematics,
    physics, and many other scientific and engineering disciplines. This model describes
    the movement of a particle suspended in a fluid resulting from random collisions
    with the quick molecules in the fluid (diffusion). More generally, the Brownian
    motion models a continuous-time **random walk**, where a particle evolves in space
    by making independent random steps in all directions.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, the Brownian motion is a particular Markov continuous stochastic
    process. The Brownian motion is at the core of mathematical domains such as stochastic
    calculus and the theory of stochastic processes, but it is also central in applied
    fields such as quantitative finance, ecology, and neuroscience.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how to simulate and plot a Brownian motion in two
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We simulate Brownian motions with 5000 time steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We simulate two independent one-dimensional Brownian processes to form a single
    two-dimensional Brownian process. The (discrete) Brownian motion makes independent
    Gaussian jumps at each time step. Therefore, we merely have to compute the cumulative
    sum of independent normal random variables (one for each time step):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to display the Brownian motion, we could just use `plot(x, y)`. However,
    the result would be monochromatic and a bit boring. We would like to use a gradient
    of color to illustrate the progression of the motion in time (the hue is a function
    of time). matplotlib forces us to use a small hack based on `scatter()`. This
    function allows us to assign a different color to each point at the expense of
    dropping out line segments between points. To work around this issue, we linearly
    interpolate the process to give the illusion of a continuous line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Brownian motion *W(t)* has several important properties. First, it gives
    rise (almost surely) to continuous trajectories. Second, its increments ![How
    it works...](img/4818_13_18.jpg) are independent on non-overlapping intervals.
    Third, these increments are Gaussian random variables. More precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In particular, the density of *W(t)* is a normal distribution with variance
    *t*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the Brownian motion, and stochastic processes in general, have
    deep connections with partial differential equations. Here, the density of *W(t)*
    is a solution of the **heat equation**, a particular diffusion equation. More
    generally, the **Fokker-Planck equation** is a partial differential equation satisfied
    by the density of solutions of a stochastic differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Brownian motion is a limit of a random walk with an infinitesimal step size.
    We used this property here to simulate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: The Brownian motion (physical phenomenon) described at [http://en.wikipedia.org/wiki/Brownian_motion](http://en.wikipedia.org/wiki/Brownian_motion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Wiener process (mathematical object) explained at [http://en.wikipedia.org/wiki/Wiener_process](http://en.wikipedia.org/wiki/Wiener_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Brownian motion is a particular type of the Lévy process; refer to [http://en.wikipedia.org/wiki/L%C3%A9vy_process](http://en.wikipedia.org/wiki/L%C3%A9vy_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Fokker-Planck equation links stochastic processes to partial differential
    equations; refer to [http://en.wikipedia.org/wiki/Fokker%E2%80%93Planck_equation](http://en.wikipedia.org/wiki/Fokker%E2%80%93Planck_equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Simulating a stochastic differential equation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a stochastic differential equation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stochastic differential equations** (**SDEs**) model dynamical systems that
    are subject to noise. They are widely used in physics, biology, finance, and other
    disciplines.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we simulate an **Ornstein-Uhlenbeck process**, which is a solution
    of the **Langevin equation**. This model describes the stochastic evolution of
    a particle in a fluid under the influence of friction. The particle's movement
    is due to collisions with the molecules of the fluid (diffusion). The difference
    with the Brownian motion is the presence of friction.
  prefs: []
  type: TYPE_NORMAL
- en: The Ornstein-Uhlenbeck process is stationary, Gaussian, and Markov, which makes
    it a good candidate to represent stationary random noise.
  prefs: []
  type: TYPE_NORMAL
- en: We will simulate this process with a numerical method called the **Euler-Maruyama
    method**. It is a simple generalization to SDEs of the Euler method for ODEs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a few parameters for our model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s define a few simulation parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also define renormalized variables (to avoid recomputing these constants
    at every time step):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a vector that will contain all successive values of our process during
    the simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s simulate the process with the Euler-Maruyama method. It is really
    like the standard Euler method for ODEs, but with an extra stochastic term (which
    is just a scaled normal random variable). We will give the equation of the process
    along with the details of this method in the *How it works...* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s display the evolution of the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, we are going to take a look at the time evolution of the distribution
    of the process. To do this, we will simulate many independent realizations of
    the same process in a vectorized way. We define a vector `X` that will contain
    all realizations of the process at a given time (that is, we do not keep all realizations
    at all times in memory). This vector will be overwritten at every time step. We
    will show the estimated distribution (histograms) at several points in time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_13_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The distribution of the process tends to a Gaussian distribution with mean ![How
    to do it...](img/4818_13_19.jpg) and standard deviation ![How to do it...](img/4818_13_20.jpg).
    The process would be stationary if the initial distribution was also a Gaussian
    with the adequate parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Langevin equation that we use in this recipe is the following stochastic
    differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *x(t)* is our stochastic process, *dx* is the infinitesimal increment,
    ![How it works...](img/4818_13_21.jpg) is the mean, ![How it works...](img/4818_13_22.jpg)
    is the standard deviation, and ![How it works...](img/4818_13_15.jpg) is the time
    constant. Also, *W* is a Brownian motion (or the Wiener process) that underlies
    our SDE.
  prefs: []
  type: TYPE_NORMAL
- en: The first term on the right-hand side is the deterministic term (in *dt*), while
    the second term is the stochastic term. Without that last term, the equation would
    be a regular deterministic ODE.
  prefs: []
  type: TYPE_NORMAL
- en: The infinitesimal step of a Brownian motion is a Gaussian random variable. Specifically,
    the derivative (in a certain sense) of a Brownian motion is a **white noise**,
    a sequence of independent Gaussian random variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euler-Maruyama method involves discretizing time and adding infinitesimal
    steps to the process at every time step. This method involves a deterministic
    term (like in the standard Euler method for ODEs) and a stochastic term (random
    Gaussian variable). Specifically, for an equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The numerical scheme is (with *t=n * dt*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![How it works...](img/4818_13_23.jpg) is a random Gaussian variable with
    variance *1* (independent at each time step). The normalization factor ![How it
    works...](img/4818_13_24.jpg) comes from the fact that the infinitesimal step
    for a Brownian motion has the standard deviation ![How it works...](img/4818_13_24.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mathematics of SDEs comprises the theory of stochastic calculus, Itō calculus,
    martingales, and other topics. Although these theories are quite involved, simulating
    stochastic processes numerically can be relatively straightforward, as we have
    seen in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The error of the Euler-Maruyama method is of order ![There's more...](img/4818_13_24.jpg).
    The Milstein method is a more precise numerical scheme, of order *dt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references on these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic differential equations on Wikipedia, available at [http://en.wikipedia.org/wiki/Stochastic_differential_equation](http://en.wikipedia.org/wiki/Stochastic_differential_equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White noise, described at [http://en.wikipedia.org/wiki/White_noise](http://en.wikipedia.org/wiki/White_noise)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Langevin equation on Wikipedia, available at [http://en.wikipedia.org/wiki/Langevin_equation](http://en.wikipedia.org/wiki/Langevin_equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ornstein-Uhlenbeck process described at [http://en.wikipedia.org/wiki/Ornstein%E2%80%93Uhlenbeck_process](http://en.wikipedia.org/wiki/Ornstein%E2%80%93Uhlenbeck_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diffusion processes described at [http://en.wikipedia.org/wiki/Diffusion_process](http://en.wikipedia.org/wiki/Diffusion_process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Itō calculus, described at [http://en.wikipedia.org/wiki/It%C5%8D_calculus](http://en.wikipedia.org/wiki/It%C5%8D_calculus)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Euler-Maruyama method, explained at [http://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method](http://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Milstein method on Wikipedia, available at [http://en.wikipedia.org/wiki/Milstein_method](http://en.wikipedia.org/wiki/Milstein_method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Simulating a Brownian motion* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
