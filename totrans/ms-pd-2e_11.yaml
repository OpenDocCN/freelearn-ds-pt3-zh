- en: Time Series and Plotting Using Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time series data is generated by a variety of processes, including the **Internet
    of Things** (**IoT**) sensors, machine/server logs, and monthly sales data from
    **Customer Relationship Management** (**CRM**) system. Some common characteristics
    of time series data is that the data points are generated at a fixed frequency
    and that there is an inherent trend and seasonality associated with the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a tour of some topics that are necessary to develop
    expertise in using pandas. Knowledge of these topics is very useful for the preparation
    of data as input to programs for data analysis, prediction, or visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we''ll discuss in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling time series data and dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulation of time series data—rolling, resampling, shifting, lagging, and
    time element separation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting—changing the date format and converting text to a date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting time series using `matplotlib`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be proficient in these critical areas.
  prefs: []
  type: TYPE_NORMAL
- en: Handling time series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we show you how to handle time series data. Handling involves
    reading, creating, resampling, and reindexing timestamp data. These tasks need
    to be performed on timestamp data to make it usable. We will start by showing
    you how to create time series data using the data read in from a `csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading in time series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we demonstrate the various ways to read in time series data,
    starting with the simple `read_csv` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source of this information can be found at [http://datamarket.com](http://datamarket.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like the `TradeDate` column to be a series of `datetime` values so
    that we can index it and create a time series:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first check the type of values in the `TradeDate` series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we convert these values to a `Timestamp` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `TradeDate` column as an index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will learn how to assign a date column as an index and
    then perform subsetting based on the index. For this section, we will use the `Object
    Occupancy` dataset where some room parameters were observed every few minutes
    for several weeks and the corresponding room occupancy was observed. This dataset
    is present as three separate files.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning date indexes and subsetting in time series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s read them and concatenate them to make a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using the date column as an index, we will convert it to a `datetime`
    format and drop the actual date column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the new `datetime` column is set to an index, it can be used for subsetting.
    For example, for filtering all the records for a particular day, we can just enclose
    the data inside the subsetting (square, `[]`) brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/8acdc469-d177-4f1c-8511-9e479596289b.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering all records for a particular day
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter all the records for a particular hour across all days, the following
    snippet will do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/a7dbe9a1-b3f1-41d0-93b7-67de1a672bc5.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering all records for a particular hour
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also filter out all the records between two timestamps by using the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/e28e9cb3-69b6-4c1e-aa92-beb5afef08a3.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering all records between two timestamps
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the time series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand the trends and any seasonality present in the data, it
    can be plotted using a basic plot function. Here, the humidity and CO[2] variables
    of the dataset have been plotted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/25071ff0-694a-4ad7-9012-482ff022599b.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting humidity and CO2 levels across time in the same graph using matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: Resampling and rolling of the time series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resampling means changing the frequency of the observed time series. For example,
    in this dataset, a data point is observed every few seconds. This dataset can
    be resampled to an hourly frequency where all the data points for an hour will
    be aggregated using an aggregation function of choice to result in one data point
    for an hour. It can be done at a daily level as well, where all the data points
    in a day will be aggregated. Resampling can also be thought of as data smoothing
    as it smooths or averages out the bumps in data.
  prefs: []
  type: TYPE_NORMAL
- en: In pandas, it is easy to resample time series data as there is a built-in function
    for that. Let's see how we can use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to resample at an hourly level, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3f93f85-a726-4c49-96d8-a0e87fb1a0c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Resampling the data at an hourly level using the median as the aggregate measure
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to resample at a daily level, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbde9823-3ad5-41c6-85e3-42c7f2479aab.png)'
  prefs: []
  type: TYPE_IMG
- en: Resampling the data at a daily level using the median as the aggregate measure
  prefs: []
  type: TYPE_NORMAL
- en: Please note how data sampled at an hourly level has more variations than the
    daily one, which is smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling is also a similar concept for aggregating data points, although it is
    more flexible. A rolling window, that is, the number of data points that are aggregated
    can be provided to control the level of aggregation or smoothing.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the `datetime` column carefully, you can see that a data point
    has been observed every minute. Hence, 60 such points constitute an hour. Let's
    see how we can use the rolling method to aggregate the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For rolling 60 data points, starting from each data point as one record, we
    provide 60 as the rolling window, which is shown as follows. This should return
    a plot similar to the hourly resampling previously obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37f46407-9043-45da-be80-c267de613b0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Rolling every consecutive 60 points and aggregating them to give the median
    as the final value
  prefs: []
  type: TYPE_NORMAL
- en: 'For rolling at a day level, the rolling window should be *60 x 24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06283f03-667e-4846-894d-f5c8fefb263f.png)'
  prefs: []
  type: TYPE_IMG
- en: Rolling every consecutive 60*24 points and aggregating them to give their median
    as the final value; this amounts to finding daily aggregate values for minute-level
    data
  prefs: []
  type: TYPE_NORMAL
- en: Note that the median has been used for aggregation. You can also use any other
    function such as mean or sum.
  prefs: []
  type: TYPE_NORMAL
- en: Separating timestamp components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A timestamp object is made of several components, namely, year, month, day,
    hour, minute, and second. For many time series analyses, it is important to segregate
    these components and keep them as new columns for later usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have made the date column our index, it becomes a lot easier. A separate
    column for each component can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/0c99ae6f-a5b8-4684-9a77-5efe6f1c9140.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Time series components created as separate columns
  prefs: []
  type: TYPE_NORMAL
- en: DateOffset and TimeDelta objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `DateOffset` object represents a change or offset in time. The key features
    of a `DateOffset` object are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This can be added to/subtracted from a `datetime` object to obtain a shifted
    date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be multiplied by an integer (positive or negative) so that the increment
    can be applied multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This has the `rollforward` and `rollback` methods to move a date forward to
    the next offset date or backward to the previous offset date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create some date objects using the `datetime` method in `pandas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that `datetime.datetime` is different from `pd.Timestamp`. The former is
    a Python class and is inefficient, while the latter is based on the `numpy.datetime64`
    datatype.
  prefs: []
  type: TYPE_NORMAL
- en: The `pd.DateOffset` object works with `pd.Timestamp`, and adding it to a `datetime.datetime`
    function casts that object into a `pd.Timestamp` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates the command for 1 week from today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following illustrates the command for 5 years from today:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of using the `rollforward` functionality. `QuarterBegin`
    is a `DateOffset` object that is used to increment a given `datetime` object to
    the start of the next calendar quarter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we can see that the next quarter after December 31, 2013 starts on March
    1, 2014\. `Timedelta` is similar to `DateOffset` but works with `datetime.datetime`
    objects. The use of these objects is explained with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have learned about datatypes, conversions between datatypes, date offsets,
    separating time components from timestamps, and so on, up to now. Next, we will
    see how we can apply some mathematical operators such as lagging, shifting, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Time series-related instance methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we explore various methods for time series objects such as
    shifting, frequency conversion, and resampling.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting/lagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we may wish to shift the values in a time series backward or forward
    in time. One possible scenario is when a dataset contains the list of start dates
    of the new employees in a firm, and the company''s HR program wishes to shift
    these dates forward by one year so that the employees'' benefits can be activated.
    We can do this by using the `shift()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This shifts all the calendar days. However, if we wish to shift only business
    days, we must use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have specified the `freq` argument to shift; this
    tells the function to shift only the business days. The `shift` function has a
    `freq` argument whose value can be a `DateOffset` class, `TimeDelta`-like object,
    or an offset alias. Thus, using `ibmTS.shift(3, freq='B')` would also produce
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time series usually comes with a fixed frequency, for example, every microsecond,
    every second, every minute, and so on. These frequencies can be changed from one
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `asfreq` function to change frequencies, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we just obtain the values corresponding to the last day of the
    month from the `ibmTS` time series. Here, `bm` stands for business month end frequency.
    For a list of all possible frequency aliases, go to [http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases](http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we specify a frequency that is smaller than the granularity of the data,
    the gaps will be filled in with `NaN` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can also apply the `asfreq` method to the `Period` and `PeriodIndex` objects,
    similar to how we do it for the `datetime` and `Timestamp` objects. `Period` and
    `PeriodIndex` are introduced later and are used to represent time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `asfreq` method accepts a method argument that allows you to forward fill
    (`ffill`) or back fill the gaps, similar to `fillna`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Resampling of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TimeSeries.resample` function enables us to summarize/aggregate more granular
    data, based on a sampling interval and a sampling function.
  prefs: []
  type: TYPE_NORMAL
- en: Downsampling is a term that originates from digital signal processing and refers
    to the process of reducing the sampling rate of a signal. In the case of data,
    we use it to reduce the amount of data that we wish to process.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite process is upsampling, which is used to increase the amount of
    data to be processed and requires interpolation to obtain the intermediate data
    points.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on downsampling and upsampling, refer to *Practical Applications
    of Upsampling and Downsampling* at [http://bit.ly/1JC95HD](http://bit.ly/1JC95HD)
    and *Downsampling Time Series for Visual Representation* at [http://bit.ly/1zrExVP](http://bit.ly/1zrExVP).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we examine some tick data for use in resampling. Before we examine the
    data, we need to prepare it. In doing so, we will learn some useful techniques
    for time series data, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Epoch timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time zone handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that uses tick data for the stock prices of Google for Tuesday,
    May 27, 2014:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The source for the preceding data can be found at [http://chartapi.finance.yahoo.com/instrument/1.0/GOOG/chartdata;type=quote;range=1d/csv](http://chartapi.finance.yahoo.com/instrument/1.0/GOOG/chartdata;type=quote;range=1d/csv).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding code, we have a `Timestamp` column along with
    the columns for the closing, high, low, and opening prices, and the volume of
    trades of the Google stock.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why does the `Timestamp` column seem a bit strange? Well, tick data timestamps
    are generally expressed in epoch time (for more information, refer to [http://en.wikipedia.org/wiki/Unix_epoch](http://en.wikipedia.org/wiki/Unix_epoch))
    as a more compact means of storage. We''ll need to convert this into a more human-readable
    time format, and we can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We would now like to make the `tstamp` column the index and eliminate the epoch
    `Timestamp` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `tstamp` index column has the times in **Universal Time Coordinated**
    (**UTC**), and we can convert these times to US/Eastern Time using two operators: `tz_localize`
    and `tz_convert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output (`**Out[213]**`), we can see ticks for every minute
    of the trading day—from 9:30 a.m., when the stock market opens, to 4:00 p.m.,
    when it closes. This results in 390 rows in the dataset since there are 390 minutes
    between 9:30 a.m. and 4:00 p.m.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to obtain a snapshot every 5 minutes instead of every minute?
    We can achieve this using downsampling as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The default function used for resampling is the mean. However, we can also
    specify other functions, such as the minimum, and we can do this using the `how`
    parameter to resample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Various function names can be passed to the `how` parameter, such as `sum`,
    `ohlc`, `max`, `min`, `std`, `mean`, `median`, `first`, and `last`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ohlc` function returns open-high-low-close values on time series data,
    which are the first, maximum, minimum, and last values. To specify whether the
    left or right interval is closed, we can pass the `closed` parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Thus, in the preceding command, we can see that the last row shows the tick
    at 15:55 instead of 16:00.
  prefs: []
  type: TYPE_NORMAL
- en: 'For upsampling, we need to specify a fill method to determine how the gaps
    should be filled through the `fill_method` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `fill_method` parameter currently supports only two methods—`forwardfill`
    and `backfill.` An interpolation method can also be supported, though, which would
    be vary.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases for time series frequencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To specify offsets, a number of aliases are available; some of the most commonly
    used ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**B, BM**: This stands for business day, business month. These are the working
    days of the month, that is, any day that is not a holiday or a weekend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D, W, M, Q, A**: This stands for calendar day, week, month, quarter, and
    year end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H, T, S, L, U**: This stands for hour, minute, second, millisecond, and microsecond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These aliases can also be combined. In the following case, we resample every
    7 minutes and 30 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Suffixes can be applied to the frequency aliases to specify when in frequency
    period to start. These are known as anchoring offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**W – SUN, MON, ... example**: W-TUE indicates a weekly frequency starting
    on a Tuesday.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q – JAN, FEB, ... DEC example**: Q-MAY indicates a quarterly frequency with
    the year end in May.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A – JAN, FEB, ... DEC example**: A-MAY indicates an annual frequency with
    the year end in May.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These offsets can be used as arguments for the `date_range` and `bdate_range`
    functions, as well as constructors for index types such as `PeriodIndex` and `DatetimeIndex`.
    A comprehensive discussion on this can be found in the pandas documentation at
    [http://pandas.pydata.org/pandas-docs/stable/timeseries.html#](http://pandas.pydata.org/pandas-docs/stable/timeseries.html#).
  prefs: []
  type: TYPE_NORMAL
- en: Time series concepts and datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with time series, there are two main concepts that you have to
    consider: points in time ranges, and time spans. In pandas, the former is represented
    by the `Timestamp` datatype, which is equivalent to the Python `datatime.datetime`
    (`datetime`) datatype and is interchangeable with it. The latter (time span) is
    represented by the `Period` datatype, which is specific to pandas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these datatypes has index datatypes associated with them: `DatetimeIndex`
    for `Timestamp`/`Datetime` and `PeriodIndex` for `Period`. These index datatypes
    are basically subtypes of `numpy.ndarray` that contain the corresponding `Timestamp`
    and `Period` datatypes and can be used as indexes for the `Series` and `DataFrame`
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Period and PeriodIndex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Period` datatype is used to represent a range or span of time. Here are
    a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add integers to the `Period` datatypes to advance the period by the
    requisite number of frequency units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also calculate the difference between two the `Period` datatypes and
    return the number of units of frequency between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `PeriodIndex` function, which is an `index` type for a `Period` object, can
    be created in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do it from a series of Period objects using the `period_range` function
    to create an analogue of `date_range`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we can confirm from the preceding command, when you pull the covers, a `PeriodIndex`
    function is really an `ndarray` of `Period` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be done through a direct call to the `Period` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two approaches, as can be seen from the preceding
    output, is that `period_range` fills in the resulting `ndarray`, but the `Period`
    constructor does not, and you have to specify all the values that should be in
    the index.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion between time series datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can convert the `Period` and `PeriodIndex` datatypes to the `Datetime`/`Timestamp`
    and `DatetimeIndex` datatypes through the `to_period` and `to_timestamp` functions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, note how periods are converted into timestamps and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of time series-related objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many time series-related objects in pandas that are used for manipulating,
    creating, and processing timestamp data. The following table gives a summary of
    time series-related objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Object** | **Summary** |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime.datetime` | This is a standard Python `datetime` class. |'
  prefs: []
  type: TYPE_TB
- en: '| `Timestamp` | This is a `pandas` class derived from. `datetime.datetime`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DatetimeIndex` | This is a `pandas` class and is implemented as an immutable
    `numpy.ndarray` of the `Timestamp`/`datetime` object type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Period` | This is a `pandas` class representing a time period. |'
  prefs: []
  type: TYPE_TB
- en: '| `PeriodIndex` | This is a `pandas` class and is implemented as an immutable
    `numpy.ndarray` of the `Period` object type. |'
  prefs: []
  type: TYPE_TB
- en: '| `DateOffset` | `DataOffset` is used to move forward a date by a given number
    of valid dates (days, weeks, months, and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `timedelta` | `Timedelta` calculates the difference in time between two dates.
    |'
  prefs: []
  type: TYPE_TB
- en: Interconversions between strings and timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following `DataFrame` with a column containing strings representing
    dates and a column containing numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bdd565b-0582-4426-9c33-008102116533.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a DataFrame with a date column
  prefs: []
  type: TYPE_NORMAL
- en: 'The datatype of the time series column can be seen to be an object and not
    a timestamp. The following code and its output confirms that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6604fc4c-1dfc-4498-9edb-545c717c878c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `to_datetime` function helps in converting the string to `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/766f3bd6-abc8-48b6-a585-e4bbb61eb554.png)'
  prefs: []
  type: TYPE_IMG
- en: Converting the string format date column to a datetime format
  prefs: []
  type: TYPE_NORMAL
- en: The pandas `to_datetime` function converts a column of strings into `datetime`,
    given the format of the string. The `infer_datetime_format` argument of this function
    automatically detects the format and parses the string into `datetime`. The `exact`
    argument, when set to `False`, looks for the closest matching format and helps
    to overcome cases where there is not an exact match to the specified format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion shown can also be done using the `strptime` function from the `datetime`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion from `datetime` to a string is aided by the `strftime` function,
    which accepts the format for the resulting string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3983b78-e499-4916-ace1-8fd56f743eec.png)'
  prefs: []
  type: TYPE_IMG
- en: Converting the datetime format date column to a string format
  prefs: []
  type: TYPE_NORMAL
- en: Here, the original `datetime` value was in the `%Y-%m-%d` format. However, the
    `strftime` function allowed a change in format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interconversion between the string and `datetime` can also be achieved through
    the `astype()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Data-processing techniques for time series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section deals with common data manipulation or feature engineering techniques
    used with time series data before applying machine learning techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Data transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following pieces of a single dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the head of sensor data that contains the time
    series components of unequal length:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fee3fe00-8e18-4b45-9b88-c9063e610620.png)'
  prefs: []
  type: TYPE_IMG
- en: Head of sensor data containing time series components of unequal length
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the tail of sensor data that contains the time
    series components of unequal length:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fc2a5d7-ada6-4945-bb5e-93b52c307a6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Tail of sensor data containing time series components of unequal length
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset here consists of time series data in 10-minute intervals for 314
    different devices. All these 314 devices have data captured for different durations.
    Let''s examine the duration for which data has been captured in each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/505b227b-c76c-463d-b5de-2e9a7dd85ae7.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary of sensor data
  prefs: []
  type: TYPE_NORMAL
- en: 'The lengths of data for each device vary drastically. Several time series problems
    such as Shapelet transformation and **Long-Short Term Memory** (**LSTM**) require
    the length of data for each device to be the same. The following code snippet
    truncates each device to the highest possible length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After truncating, the length can be seen to be uniform. It can be checked by
    running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf564c0-479f-4a63-a45b-070775bdf62a.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary of sensor data after all the time series components have been made 
    equal in length
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform feature extraction for the following univariate time series
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fc244c0-36bd-42a8-8245-d940e8f00af7.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading the occupancy data and setting the datetime column as an index
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature extraction is vital for performing machine learning with time series
    data in order to obtain better performance metrics. Here, let''s extract the rolling
    mean, rolling standard deviation, and gradient for the temperature data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6016b1a5-e00f-4334-a740-2df6ad4bfe4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature (5_day_mean, 5_day_std) generation using rolling functions
  prefs: []
  type: TYPE_NORMAL
- en: The first 5 rows with `NA` values have been dropped in the feature extraction
    process. Here, the features have been extracted for a rolling window of 5 days.
    Using a similar method, it is possible to extract hundreds of features from a
    time series variable.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting using matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section provides a brief introduction to plotting in `pandas` using `matplotlib`.
    The `matplotlib` API is imported using the standard convention, as shown in the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`Series` and `DataFrame` have a plot method, which is simply a wrapper around
    `plt.plot`. Here, we will examine how we can do a simple plot of a sine and cosine
    function. Suppose we wished to plot the following functions over the interval
    pi to pi:'
  prefs: []
  type: TYPE_NORMAL
- en: f(x) = cos(x) + sin (x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: g(x) = cos (x) - sin (x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This gives the following interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now plot the DataFrame using the `plot()` command and the `plt.show()`
    command to display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0e5ea2c-63ff-427d-b75d-6284324de2ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Plotting time series data using matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also plot the two series (functions) separately in different subplots,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c66a11d-0623-4c75-966d-87f52a41c6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Plotting some more time series data using matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to using the plotting functionality of `matplotlib` within
    pandas. For more information, take a look at the documentation at [http://pandas.pydata.org/pandas-docs/dev/visualization.html](http://pandas.pydata.org/pandas-docs/dev/visualization.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is often quite useful to visualize all the variables of a multivariate time
    series data. Let''s plot all the variables of the following data in a single plot.
    Note that the `date` column is the index here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/835188e4-e7f5-4bdd-bc95-0a2bcc444ec5.png)'
  prefs: []
  type: TYPE_IMG
- en: Occupancy dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'The subplot feature in matplotlib lets us plot all of the variables at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea11a97f-7055-4c48-a0f6-3a2a02556819.png)'
  prefs: []
  type: TYPE_IMG
- en: Time series plot for all the variables in the occupancy dataset
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed time series data and the steps you can take to
    process and manipulate it. A `date` column can be assigned as an index for `Series`
    or `DataFrame` and can then be used for subsetting them based on the index column. Time
    series data can be resampled—to either increase or decrease the frequency of the
    time series. For example, data generated every millisecond can be resampled to
    capture the data only every second or can be averaged for 1,000 milliseconds for
    each second. Similarly, data generated every minute can be resampled to have data
    every second by backfilling or forward filling (filling in the same value as the
    last or next minute value for all the seconds in that minute).
  prefs: []
  type: TYPE_NORMAL
- en: String to datetime conversion can be done via the `datetime`, `strptime`, and `strftime` packages
    , and each type of date entry (for example, 22^(nd) July, 7/22/2019, and so on)
    needs to be decoded differently based on a convention. pandas has the following
    types of time series objects—`datetime.datetime`, `Timestamp`, `DateIndex`, `Period`,
    `PeriodIndex`, `timedelta`, and so on. Certain algorithms for time series classification
    such as shapelets and LSTM require time series components (one separable data
    entity containing multiple entries of time series data) to be of the same length.
    This can be done either by truncating all the components to the smallest length
    or expanding them to the longest length and imputing with zeros or some other
    value. Matplotlib can be used to plot basic time series data. Shifting, lagging,
    and rolling functions are used to calculate moving averages, detecting behavioral
    change at time series component change points.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use the power of pandas in Jupyter
    Notebooks to make powerful and interactive reports.
  prefs: []
  type: TYPE_NORMAL
