<html><head></head><body>
		<div id="_idContainer052">
			<h1 id="_idParaDest-120" class="chapter-number"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.2.1">Data Grouping, Aggregation, Filtering, and Applying Functions</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Data grouping</span></strong><span class="koboSpan" id="kobo.4.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">aggregation</span></strong><span class="koboSpan" id="kobo.6.1"> are </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.7.1">fundamental techniques in data cleaning </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.8.1">and preprocessing, serving several critical purposes. </span><span class="koboSpan" id="kobo.8.2">Firstly, they enable the summarization of large datasets, transforming extensive raw data into concise, meaningful summaries that facilitate analysis and insight derivation. </span><span class="koboSpan" id="kobo.8.3">Additionally, aggregation helps manage missing or noisy data by smoothing out inconsistencies and filling gaps with combined data points. </span><span class="koboSpan" id="kobo.8.4">These techniques also contribute to reducing data volume, enhancing processing efficiency, and creating valuable features for further analysis or machine </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">learning models.</span></span></p>
			<p><span class="koboSpan" id="kobo.10.1">The main components of data grouping and aggregation include group keys, which define how data is segmented; aggregation functions, which perform operations such as summing, averaging, counting, and more; and output columns, which display the group keys and </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">aggregated values.</span></span></p>
			<p><span class="koboSpan" id="kobo.12.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">main points:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.14.1">Grouping data using one or </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">multiple keys</span></span></li>
				<li><span class="koboSpan" id="kobo.16.1">Applying aggregate functions on </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">grouped data</span></span></li>
				<li><span class="koboSpan" id="kobo.18.1">Applying functions on </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">grouped data</span></span></li>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Data filtering</span></span></li>
			</ul>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.22.1">You can find the code for the chapter in the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">repository: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/tree/main/chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/tree/main/chapter06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.26.1">Grouping data using one or multiple keys</span></h1>
			<p><span class="koboSpan" id="kobo.27.1">In pandas, grouping data is a fundamental operation that involves splitting data into groups based on one or more keys and then performing operations within each group. </span><span class="koboSpan" id="kobo.27.2">Grouping is often used in data analysis to gain insights and perform aggregate calculations on subsets of data. </span><span class="koboSpan" id="kobo.27.3">Let’s dive deeper into grouping data and provide examples to illustrate their usage. </span><span class="koboSpan" id="kobo.27.4">The code for this section can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/2.groupby_full_example.py"><span class="No-Break"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/2.groupby_full_example.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.30.1">.</span></span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.31.1">Grouping data using one key</span></h2>
			<p><span class="koboSpan" id="kobo.32.1">Grouping data </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.33.1">with pandas using one key is a common operation for </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">data analysis.</span></span></p>
			<p><span class="koboSpan" id="kobo.35.1">To group data using one key, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">groupby()</span></strong><span class="koboSpan" id="kobo.37.1"> method of a DataFrame and specify the column that we want to use as the key </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">for grouping:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.39.1">
grouped = df.groupby('column_name')</span></pre>			<p><span class="koboSpan" id="kobo.40.1">After grouping, you typically want to perform some aggregation. </span><span class="koboSpan" id="kobo.40.2">Common aggregation functions include </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">the following:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">grouped.sum()</span></strong><span class="koboSpan" id="kobo.43.1">: This calculates the sum of all </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">numeric columns</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">grouped.mean()</span></strong><span class="koboSpan" id="kobo.46.1">: This calculates the average (</span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">arithmetic mean)</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">grouped.count()</span></strong><span class="koboSpan" id="kobo.49.1">: This counts the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">non-null values</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">grouped.agg(['sum', 'mean', 'count'])</span></strong><span class="koboSpan" id="kobo.52.1">: This applies multiple aggregation functions at once: </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">sum</span></strong><span class="koboSpan" id="kobo.54.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">mean</span></strong><span class="koboSpan" id="kobo.56.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">count</span></strong></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.59.1">Let’s present a common use case on which to apply our learnings. </span><span class="koboSpan" id="kobo.59.2">Let’s pretend we are working for an electronics retail company and we need to analyze the sales data for the different products. </span><span class="koboSpan" id="kobo.59.3">A sample of the data is </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">presented here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
       Category Sub-Category Region  Sales        Date
0   Electronics       Mobile  North    200  2023-01-01
1   Electronics       Laptop  South    300  2023-01-02
2   Electronics       Tablet   East    250  2023-01-03
3   Electronics       Laptop   West    400  2023-01-04
4     Furniture        Chair  North    150  2023-01-05
5     Furniture        Table  South    350  2023-01-06</span></pre>			<p><span class="koboSpan" id="kobo.62.1">In data analysis, certain </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.63.1">columns are typically candidates for grouping due to their </span><em class="italic"><span class="koboSpan" id="kobo.64.1">categorical</span></em><span class="koboSpan" id="kobo.65.1"> nature. </span><span class="koboSpan" id="kobo.65.2">These columns often represent categories, classifications, or time-related segments that make sense to aggregate </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">data around:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.67.1">Category columns</span></strong><span class="koboSpan" id="kobo.68.1">: Columns </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.69.1">that represent distinct groups or types within the data. </span><span class="koboSpan" id="kobo.69.2">Examples include product categories, user types, or service types. </span><span class="koboSpan" id="kobo.69.3">These columns help in understanding the performance or behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">each group.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.71.1">Geographical columns</span></strong><span class="koboSpan" id="kobo.72.1">: Columns</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.73.1"> that denote geographical divisions, such as country, region, city, or store location. </span><span class="koboSpan" id="kobo.73.2">These are useful for regional </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">performance analysis.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Temporal columns</span></strong><span class="koboSpan" id="kobo.76.1">: Columns </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.77.1">representing time-related information, such as year, quarter, month, week, or day. </span><span class="koboSpan" id="kobo.77.2">Grouping by these columns helps in trend analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">over time.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Demographic columns</span></strong><span class="koboSpan" id="kobo.80.1">: Columns </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.81.1">that describe demographic attributes, such as age group, gender, or income level. </span><span class="koboSpan" id="kobo.81.2">These are useful for segmenting data based on </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">population characteristics.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Transaction-related columns</span></strong><span class="koboSpan" id="kobo.84.1">: Columns</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.85.1"> related to the nature of transactions, such as transaction type, payment method, or order status. </span><span class="koboSpan" id="kobo.85.2">These help in understanding different aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">transactional data.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.87.1">Given the data we have in our example, the candidate columns for grouping are </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Category</span></strong><span class="koboSpan" id="kobo.89.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Subcategory</span></strong><span class="koboSpan" id="kobo.91.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">Region</span></strong><span class="koboSpan" id="kobo.93.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Date</span></strong><span class="koboSpan" id="kobo.95.1"> could also be a candidate if we had multiple records per day and we wanted to calculate the number of sales per day. </span><span class="koboSpan" id="kobo.95.2">In our case, our manager asked us to report on the total number of sales (sales volume) for each category. </span><span class="koboSpan" id="kobo.95.3">Let’s see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">calculate this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
category_sales = df.groupby('Category')['Sales'].sum().reset_index()</span></pre>			<p><span class="koboSpan" id="kobo.98.1">In this code example, we group the data by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Category</span></strong><span class="koboSpan" id="kobo.100.1"> column, sum the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Sales</span></strong><span class="koboSpan" id="kobo.102.1"> column for each category, and</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.103.1"> reset the index. </span><span class="koboSpan" id="kobo.103.2">The resulting DataFrame is </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.105.1">
      Category  Sales
0     Clothing   1070
1  Electronics   1370
2    Furniture   1270</span></pre>			<p><span class="koboSpan" id="kobo.106.1">Now that we have seen how to group data by a single key, let’s add more complexity by grouping the data by </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Category</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.108.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Region</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">.</span></span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.111.1">Grouping data using multiple keys</span></h2>
			<p><span class="koboSpan" id="kobo.112.1">Grouping by multiple keys </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.113.1">allows for a more granular and detailed examination of the data. </span><span class="koboSpan" id="kobo.113.2">This approach helps uncover insights that may be hidden when only using a single key, offering a deeper understanding of relationships and patterns within the dataset. </span><span class="koboSpan" id="kobo.113.3">In our example, grouping by both </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Region</span></strong><span class="koboSpan" id="kobo.115.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Category</span></strong><span class="koboSpan" id="kobo.117.1"> allows the company to see not only the overall sales performance but also how different categories perform in each region. </span><span class="koboSpan" id="kobo.117.2">This helps in identifying which products are popular in specific regions and tailoring marketing </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">strategies accordingly.</span></span></p>
			<p><span class="koboSpan" id="kobo.119.1">To group data using multiple keys, we pass a list of column names to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">groupby()</span></strong><span class="koboSpan" id="kobo.121.1"> method. </span><span class="koboSpan" id="kobo.121.2">Pandas will create groups based on </span><em class="italic"><span class="koboSpan" id="kobo.122.1">unique combinations</span></em><span class="koboSpan" id="kobo.123.1"> of values from </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">these columns:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.125.1">
category_region_sales = df.groupby(['Category', 'Region'])['Sales'].sum().reset_index()</span></pre>			<p><span class="koboSpan" id="kobo.126.1">In this piece of code, we group the data by both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">Category</span></strong><span class="koboSpan" id="kobo.128.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Region</span></strong><span class="koboSpan" id="kobo.130.1"> columns, and then we perform the aggregation by summing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Sales</span></strong><span class="koboSpan" id="kobo.132.1"> column for each group. </span><span class="koboSpan" id="kobo.132.2">Finally, we reset the index. </span><span class="koboSpan" id="kobo.132.3">Let’s see the output from </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">this operation:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
       Category Region  Sales
0      Clothing   East    420
1      Clothing  North    100
2      Clothing  South    250
3      Clothing   West    300
4   Electronics   East    250
5   Electronics  North    420
6   Electronics  South    300
7   Electronics   West    400
8     Furniture   East    200
9     Furniture  North    150
10    Furniture  South    350
11    Furniture   West    570</span></pre>			<p><span class="koboSpan" id="kobo.135.1">With </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.136.1">just a line of code, we have managed to summarize and present all the sales for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">Category</span></strong><span class="koboSpan" id="kobo.138.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">Region</span></strong><span class="koboSpan" id="kobo.140.1"> value, making our manager very happy. </span><span class="koboSpan" id="kobo.140.2">Now, let’s have a look at some best practices when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">groupby statements.</span></span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.142.1">Best practices for grouping</span></h2>
			<p><span class="koboSpan" id="kobo.143.1">When</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.144.1"> grouping data in pandas, there are several things to consider to ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">accurate results:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.146.1">Missing data</span></strong><span class="koboSpan" id="kobo.147.1">: Be aware of missing data in the columns used for grouping. </span><span class="koboSpan" id="kobo.147.2">Pandas will </span><em class="italic"><span class="koboSpan" id="kobo.148.1">exclude</span></em><span class="koboSpan" id="kobo.149.1"> rows with missing data from the grouped result, which can affect the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">final calculations.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">MultiIndex</span></strong><span class="koboSpan" id="kobo.152.1">: When grouping by multiple columns, pandas returns a hierarchical index (</span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">MultiIndex</span></strong><span class="koboSpan" id="kobo.154.1">). </span><span class="koboSpan" id="kobo.154.2">Be familiar when working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">MultiIndex</span></strong><span class="koboSpan" id="kobo.156.1"> and consider resetting the index if needed as we have been doing </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">for simplicity.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Order of operations</span></strong><span class="koboSpan" id="kobo.159.1">: The order in which you perform groupings and aggregations </span><em class="italic"><span class="koboSpan" id="kobo.160.1">can affect the results</span></em><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">Be mindful of the sequence in which you apply grouping and </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">aggregation functions.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.163.1">Grouping large datasets</span></strong><span class="koboSpan" id="kobo.164.1">: For large datasets, grouping can be memory intensive. </span><span class="koboSpan" id="kobo.164.2">Consider using techniques such as chunking or parallel processing to manage memory usage and </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">computation time.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.166.1">Our managing</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.167.1"> team saw the efficiency of the groupby operations we performed, and they asked us for a more detailed summary of sales! </span><span class="koboSpan" id="kobo.167.2">With multiple keys in place, we can further enhance our analysis by applying multiple aggregation functions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Sales</span></strong><span class="koboSpan" id="kobo.169.1"> column. </span><span class="koboSpan" id="kobo.169.2">This will give us a more detailed summary of </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">the data.</span></span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.171.1">Applying aggregate functions on grouped data</span></h1>
			<p><span class="koboSpan" id="kobo.172.1">In pandas, after grouping data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">groupby()</span></strong><span class="koboSpan" id="kobo.174.1"> method, you can apply aggregate functions to </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.175.1">perform calculations on the grouped data. </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">Aggregate functions</span></strong><span class="koboSpan" id="kobo.177.1"> are used to</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.178.1"> summarize or compute statistics for each group, resulting in a new DataFrame or Series. </span><span class="koboSpan" id="kobo.178.2">Let’s dive deeper into applying aggregate functions on grouped data and provide examples to illustrate </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">their usage.</span></span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.180.1">Basic aggregate functions</span></h2>
			<p><span class="koboSpan" id="kobo.181.1">We have</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.182.1"> touched base on the basic aggregation function in the first section as you cannot perform groupby without an aggregation function. </span><span class="koboSpan" id="kobo.182.2">In this section, we will expand a bit more on what each function does and when should we use each one, starting by presenting all the available functions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">following table:</span></span></p>
			<table id="table001-3" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><span class="koboSpan" id="kobo.184.1">Aggregation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.185.1">function</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.186.1">Description</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold"><span class="koboSpan" id="kobo.187.1">When </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.188.1">to use</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.189.1">Code example</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">sum</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.191.1">Adds up all values in </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.193.1">When you need the total value for </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">each group.</span></span></p>
							<p><strong class="bold"><span class="koboSpan" id="kobo.195.1">Example</span></strong><span class="koboSpan" id="kobo.196.1">: Total sales </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">per category.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">df.groupby('Category')['Sales'].sum()</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">mean</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.200.1">Calculates the average of values in </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.202.1">When you need the average value for </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">each group.</span></span></p>
							<p><strong class="bold"><span class="koboSpan" id="kobo.204.1">Example</span></strong><span class="koboSpan" id="kobo.205.1">: Average sales </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">per region.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">df.groupby('Category')['Sales'].mean()</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">count</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.209.1">Counts the number of non-null values in </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.211.1">When you need to know the number of occurrences in </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">each group.</span></span></p>
							<p><strong class="bold"><span class="koboSpan" id="kobo.213.1">Example</span></strong><span class="koboSpan" id="kobo.214.1">: Number of sales transactions </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">per sub-category.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">df.groupby('Category')['Sales'].count()</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">min</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.218.1">Finds the minimum value in </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.220.1">When you need the smallest value in </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">each group.</span></span></p>
							<p><strong class="bold"><span class="koboSpan" id="kobo.222.1">Example</span></strong><span class="koboSpan" id="kobo.223.1">: Minimum sales value </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">per region.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">df.groupby('Category')['Sales'].min()</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><span class="koboSpan" id="kobo.226.1">Aggregation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.227.1">function</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.228.1">Description</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold"><span class="koboSpan" id="kobo.229.1">When </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.230.1">to use</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.231.1">Code example</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">max</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.233.1">Finds the maximum value in </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.235.1">When</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.236.1"> you need the largest value in </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">each group.</span></span></p>
							<p><strong class="bold"><span class="koboSpan" id="kobo.238.1">Example</span></strong><span class="koboSpan" id="kobo.239.1">: Maximum sales value </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">per category.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">df.groupby('Category')['Sales'].max()</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">median</span></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.243.1">Finds the median value in </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.245.1">When you need the middle value in a sorted list of numbers. </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Example</span></strong><span class="koboSpan" id="kobo.247.1">: Median sales value </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">per category.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">df.groupby('Category')['Sales'].median()</span></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">std</span></strong></span></p>
							<p><span class="koboSpan" id="kobo.251.1">(Standard </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">Deviation)</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.253.1">Measures the spread of values in </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">a group</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="koboSpan" id="kobo.255.1">When you need to understand the variation </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">in values.</span></span></p>
							<p><strong class="bold"><span class="koboSpan" id="kobo.257.1">Example</span></strong><span class="koboSpan" id="kobo.258.1">: Standard deviation of sales </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">per region.</span></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">df.groupby('Category')['Sales'].std()</span></strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.261.1">Table 6.1 – Summary table of the basic aggregation functions</span></p>
			<p><span class="koboSpan" id="kobo.262.1">You can call each of these</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.263.1"> functions one by one or all together, </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">for example:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
total_sales = df.groupby('Category')['Sales'].sum().reset_index()</span></pre>			<p><span class="koboSpan" id="kobo.266.1">This calculates the number of sales per category, as we’ve learned, and it’s sufficient if this is the only aggregate information you want to extract from the dataset. </span><span class="koboSpan" id="kobo.266.2">However, if you find yourself being asked to produce multiple sale aggregates for the different product categories, a more efficient way is to perform all the aggregates </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">at once:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
category_region_sales_agg = df.groupby(['Category', 'Region'])['Sales'].agg(['sum', 'mean']).reset_index()</span></pre>			<p><span class="koboSpan" id="kobo.269.1">In this code, we apply multiple aggregation functions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">sum</span></strong><span class="koboSpan" id="kobo.271.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">mean</span></strong><span class="koboSpan" id="kobo.273.1">) to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Sales</span></strong><span class="koboSpan" id="kobo.275.1"> column. </span><span class="koboSpan" id="kobo.275.2">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
       Category Region  sum   mean
0      Clothing   East  420  210.0
1      Clothing  North  100  100.0
2      Clothing  South  250  250.0
3      Clothing   West  300  300.0
4   Electronics   East  250  250.0
5   Electronics  North  420  210.0
6   Electronics  South  300  300.0
7   Electronics   West  400  400.0
8     Furniture   East  200  200.0
9     Furniture  North  150  150.0
10    Furniture  South  350  350.0
11    Furniture   West  570  285.0</span></pre>			<p class="callout-heading"><span class="koboSpan" id="kobo.278.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.279.1">We can add as many aggregations as we want in the group </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">by clause.</span></span></p>
			<p><span class="koboSpan" id="kobo.281.1">We’ve been</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.282.1"> really efficient with calculating all the different metrics our managing team asked for, and as a result, they are now keen to understand the sales metrics and the number of unique sub-category sales per region and category. </span><span class="koboSpan" id="kobo.282.2">Let’s do </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">that next.</span></span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.284.1">Advanced aggregation with multiple columns</span></h2>
			<p><span class="koboSpan" id="kobo.285.1">To understand </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.286.1">the sales metrics and the number of unique sub-category sales per region and category, we can group additional columns and apply multiple aggregations to both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Sales</span></strong><span class="koboSpan" id="kobo.288.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Subcategory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1"> columns:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
advanced_agg = df.groupby(['Category', 'Region']).agg({
  'Sales': ['sum', 'mean', 'count'],
  'Sub-Category': 'nunique' # Unique count of Sub-Category
}).reset_index()</span></pre>			<p><span class="koboSpan" id="kobo.292.1">In this code, we group the DataFrame by </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Category</span></strong><span class="koboSpan" id="kobo.294.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Region</span></strong><span class="koboSpan" id="kobo.296.1"> and we perform a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">of aggregations:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">'Sales': ['sum', 'mean', 'count']</span></strong><span class="koboSpan" id="kobo.299.1"> calculates the total sales, average sales, and number of transactions (count of rows) for </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">each group</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">'Sub-Category': 'nunique'</span></strong><span class="koboSpan" id="kobo.302.1"> calculates the number of unique sub-categories within each group of </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Category</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.304.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Region</span></strong></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.306.1">The</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.307.1"> summarized results are </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">presented here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
       Category Region Sales              Sub-Category
                         sum   mean count      nunique
0      Clothing   East   420  210.0     2            2
1      Clothing  North   100  100.0     1            1
2      Clothing  South   250  250.0     1            1
3      Clothing   West   300  300.0     1            1
4   Electronics   East   250  250.0     1            1
5   Electronics  North   420  210.0     2            1
6   Electronics  South   300  300.0     1            1</span></pre>			<p><span class="koboSpan" id="kobo.310.1">Now, you may be wondering, what have we learned by making these calculations? </span><span class="koboSpan" id="kobo.310.2">Let me answer that! </span><span class="koboSpan" id="kobo.310.3">Total sales, average sales, and transaction count were calculated to understand the financial performance across different category-region combinations. </span><span class="koboSpan" id="kobo.310.4">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Sub-Category</span></strong><span class="koboSpan" id="kobo.312.1"> unique count revealed crucial aspects of our product distribution strategy. </span><span class="koboSpan" id="kobo.312.2">This analysis serves multiple purposes: it provides insights into the diversity of products within each category-region segment, for example, in the context of our data, knowing the number of unique products (sub-categories) sold in each region under different categories provides insights into the market segmentation and product assortment strategies. </span><span class="koboSpan" id="kobo.312.3">It also aids in assessing market penetration by highlighting regions with a broader product offering and supports strategic decisions in product portfolio management, including expansion and inventory strategies tailored to </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">regional preferences.</span></span></p>
			<p><span class="koboSpan" id="kobo.314.1">Standard aggregation functions, such as sum, mean, and count, provide fundamental statistics. </span><span class="koboSpan" id="kobo.314.2">However, custom functions allow you to calculate metrics that are specific to your business needs or analysis goals. </span><span class="koboSpan" id="kobo.314.3">For example, calculating the range or coefficient of variation in sales data can reveal insights into the distribution and variability of sales within different groups. </span><span class="koboSpan" id="kobo.314.4">As</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.315.1"> you can imagine, we were asked to implement these custom metrics, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">do next.</span></span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.317.1">Applying custom aggregate functions</span></h2>
			<p><span class="koboSpan" id="kobo.318.1">Custom functions </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.319.1">are valuable when the aggregation requires complex calculations that go beyond simple statistics. </span><span class="koboSpan" id="kobo.319.2">You can use them when you need to calculate metrics that are unique to your analysis objectives or business context. </span><span class="koboSpan" id="kobo.319.3">For example, in sales analysis, you might want to compute profit margins, customer lifetime value, or churn rates, which are not typically available through standard </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">aggregation functions.</span></span></p>
			<p><span class="koboSpan" id="kobo.321.1">Let’s go back to our example and build the metrics we were asked about: For each region, we want to calculate the sales range and the variability of sales. </span><span class="koboSpan" id="kobo.321.2">Let’s have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">following code:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.323.1">We create a function that calculates the range (difference between max and min) </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">of sales:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.325.1">
def range_sales(series):
  return series.max() - series.min()</span></pre></li>				<li><span class="koboSpan" id="kobo.326.1">Then, we create a function that computes the coefficient of variation of sales, which measures the relative variability in relation to </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">the mean:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.328.1">
def coefficient_of_variation(series):
  return series.std() / series.mean()</span></pre></li>				<li><span class="koboSpan" id="kobo.329.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">df</span></strong><span class="koboSpan" id="kobo.331.1"> DataFrame is then grouped </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Region</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.335.1">
advanced_agg_custom = df.groupby('Region').agg({
  'Sales': ['sum', 'mean', 'count', range_sales, coefficient_of_variation],
  'Sub-Category': 'nunique'
}).reset_index()</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Sales: ['sum', 'mean', 'count', range_sales, coefficient_of_variation]</span></strong><span class="koboSpan" id="kobo.337.1"> calculates the total sales, average sales, transaction count, sales range, and coefficient of variation using the custom functions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">'Sub-Category':'nunique'</span></strong><span class="koboSpan" id="kobo.339.1"> counts the number of unique sub-categories within each group. </span><span class="koboSpan" id="kobo.339.2">Then, we reset the index to flatten the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">df</span></strong><span class="koboSpan" id="kobo.341.1"> DataFrame and make it easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">work with.</span></span></p></li>				<li><span class="koboSpan" id="kobo.343.1">Finally, we </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.344.1">rename the aggregated columns for clarity and better readability of </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">the output:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.346.1">
advanced_agg_custom.columns = [
  'Region', 'Total Sales', 'Average Sales', 'Number of Transactions',
  'Sales Range', 'Coefficient of Variation', 'Unique Sub-Categories'
]</span></pre></li>				<li><span class="koboSpan" id="kobo.347.1">Let’s print the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">final DataFrame:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.349.1">
print(advanced_agg_custom)</span></pre></li>			</ol>
			<p><span class="koboSpan" id="kobo.350.1">The final DataFrame is </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">presented here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
  Region  TotalSales SalesRange  Coef Unique Sub-Categories
0   East         870        120  0.24                     4
1  North         670        120  0.32                     3
2  South         900        100  0.16                     3
3   West        1270        230  0.34                     4</span></pre>			<p><span class="koboSpan" id="kobo.353.1">Let’s spend some time understanding the sales variability for each region. </span><span class="koboSpan" id="kobo.353.2">The range of sales within each region can reveal the </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">spread</span></strong><span class="koboSpan" id="kobo.355.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">difference</span></strong><span class="koboSpan" id="kobo.357.1"> between the highest and lowest sales figures. </span><span class="koboSpan" id="kobo.357.2">For instance, a wide range may indicate significant variability in consumer demand or sales performance across different regions. </span><span class="koboSpan" id="kobo.357.3">The coefficient of variation helps to standardize the variability of sales relative to their average. </span><span class="koboSpan" id="kobo.357.4">A higher coefficient suggests greater relative variability, which may prompt further investigation into factors influencing </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">sales fluctuations.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.359.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.360.1">I hope it’s clear to you that you can build any function that you want as a custom aggregate function as long as it computes a </span><em class="italic"><span class="koboSpan" id="kobo.361.1">single</span></em><span class="koboSpan" id="kobo.362.1"> aggregation result from an input series of values. </span><span class="koboSpan" id="kobo.362.2">The function should also return a single scalar value, which is the result of the aggregation for </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">that group.</span></span></p>
			<p><span class="koboSpan" id="kobo.364.1">Now, let’s have a look at some best practices when working with </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">aggregate functions.</span></span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.366.1">Best practices for aggregate functions</span></h2>
			<p><span class="koboSpan" id="kobo.367.1">When </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.368.1">working with aggregate functions in pandas, there are several things to consider to ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">accurate results:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.370.1">Write efficient custom functions that minimize computational overhead, especially when working with large datasets. </span><span class="koboSpan" id="kobo.370.2">Avoid unnecessary loops or operations that can slow down </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">processing time.</span></span></li>
				<li><span class="koboSpan" id="kobo.372.1">Clearly document the logic and purpose of your custom aggregation functions. </span><span class="koboSpan" id="kobo.372.2">This helps in maintaining and sharing code within your team or organization, ensuring transparency and reproducibility </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">of analysis.</span></span></li>
				<li><span class="koboSpan" id="kobo.374.1">Validate the accuracy of custom aggregation functions by comparing results with known benchmarks or manual calculations. </span><span class="koboSpan" id="kobo.374.2">This step is crucial to ensure that your custom metrics are reliable and </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">correctly implemented.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.376.1">In pandas, when using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">.agg()</span></strong><span class="koboSpan" id="kobo.378.1"> method with </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">groupby</span></strong><span class="koboSpan" id="kobo.380.1">, the aggregation function you define should </span><em class="italic"><span class="koboSpan" id="kobo.381.1">ideally</span></em><span class="koboSpan" id="kobo.382.1"> return a single scalar value for each column it operates on within each group. </span><span class="koboSpan" id="kobo.382.2">However, there are scenarios where you might want to return multiple values or perform more complex operations. </span><span class="koboSpan" id="kobo.382.3">While the pandas </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">.agg()</span></strong><span class="koboSpan" id="kobo.384.1"> method expects scalar values, you can achieve more complex aggregations by using custom functions that return tuples or lists. </span><span class="koboSpan" id="kobo.384.2">However, this requires careful handling and often isn’t straightforward within pandas’ native aggregation framework. </span><span class="koboSpan" id="kobo.384.3">For more complex scenarios where you need to return multiple values or perform intricate calculations, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">apply()</span></strong><span class="koboSpan" id="kobo.386.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">agg()</span></strong><span class="koboSpan" id="kobo.388.1">, which is more flexible, as we will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">next section.</span></span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.390.1">Using the apply function on grouped data</span></h1>
			<p><span class="koboSpan" id="kobo.391.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">apply()</span></strong><span class="koboSpan" id="kobo.393.1"> function</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.394.1"> in Pandas is a powerful method used to apply a custom function along an axis of a DataFrame or Series. </span><span class="koboSpan" id="kobo.394.2">It is highly versatile and can be used in various scenarios to manipulate data, compute complex aggregations, or transform data based on custom logic. </span><span class="koboSpan" id="kobo.394.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">apply()</span></strong><span class="koboSpan" id="kobo.396.1"> function can be used to do </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the following:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.398.1">Apply functions row-wise </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">or column-wise</span></span></li>
				<li><span class="koboSpan" id="kobo.400.1">Apply functions to groups of data when used in conjunction </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">groupby()</span></strong></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.403.1">In the next section, we will focus on using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">apply</span></strong><span class="koboSpan" id="kobo.405.1"> function on groups of data by first grouping on the column we want and then performing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1"> operation.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.408.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.409.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">apply</span></strong><span class="koboSpan" id="kobo.411.1"> function without </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">groupby</span></strong><span class="koboSpan" id="kobo.413.1"> allows you to apply a function across either rows or columns of a DataFrame directly. </span><span class="koboSpan" id="kobo.413.2">This is useful when you need to perform row-wise or column-wise operations that don’t require grouping the data. </span><span class="koboSpan" id="kobo.413.3">Apply the same learnings and just skip the group </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">by clause.</span></span></p>
			<p><span class="koboSpan" id="kobo.415.1">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">apply</span></strong><span class="koboSpan" id="kobo.417.1"> function in pandas, </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">axis=0</span></strong><span class="koboSpan" id="kobo.419.1"> (default) applies the function to each column, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">axis=1</span></strong><span class="koboSpan" id="kobo.421.1"> applies it to each row. </span><span class="koboSpan" id="kobo.421.2">Let’s go a little bit deeper </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">on this.</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">axis=0</span></strong><span class="koboSpan" id="kobo.424.1"> applies the function along the </span><em class="italic"><span class="koboSpan" id="kobo.425.1">rows</span></em><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">In other words, it processes each </span><em class="italic"><span class="koboSpan" id="kobo.427.1">column</span></em><span class="koboSpan" id="kobo.428.1"> independently. </span><span class="koboSpan" id="kobo.428.2">This is typically used when you want to aggregate data column-wise (e.g., summing up values in each column), as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">following figure:</span></span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<span class="koboSpan" id="kobo.430.1"><img src="image/B19801_06_1.jpg" alt="Figure 6.1 – Apply() with axis=0"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.431.1">Figure 6.1 – Apply() with axis=0</span></p>
			<p><span class="koboSpan" id="kobo.432.1">If we go back to our use case, the managing team wants to understand more about the actual quantity sold for the products per category apart from the sum of dollars in sales we achieved. </span><span class="koboSpan" id="kobo.432.2">Our </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.433.1">example gets more and more complex; so, it’s a good idea to implement that with </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">apply()</span></strong><span class="koboSpan" id="kobo.435.1">. </span><span class="koboSpan" id="kobo.435.2">Let’s see this with a code example that can also be found </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/3.apply_axis0.py"><span class="No-Break"><span class="koboSpan" id="kobo.437.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/3.apply_axis0.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.438.1">.</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.439.1">Let’s extend our DataFrame to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Quantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1"> column:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.442.1">
data = {
  'Category': ['Electronics', 'Electronics', 'Furniture', 'Furniture', 'Clothing', 'Clothing'],
  'Sub-Category': ['Mobile', 'Laptop', 'Chair', 'Table', 'Men', 'Women'],
  'Sales': [100, 200, 150, 300, 120, 180],
  'Quantity': [10, 5, 8, 3, 15, 12],
  'Date': ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06']
}
df = pd.DataFrame(data)</span></pre></li>				<li><span class="koboSpan" id="kobo.443.1">We then convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Date</span></strong><span class="koboSpan" id="kobo.445.1"> column to </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">datetime format:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
df['Date'] = pd.to_datetime(df['Date'])</span></pre></li>				<li><span class="koboSpan" id="kobo.448.1">Now, let’s define a custom function to compute multiple statistics for </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Sales</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.450.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">Quantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.453.1">
def compute_statistics(series):
    sum_sales = series['Sales'].sum()
    mean_sales = series['Sales'].mean()
    std_sales = series['Sales'].std()
    cv_sales = std_sales / mean_sales
    sum_quantity = series['Quantity'].sum()
    mean_quantity = series['Quantity'].mean()
    std_quantity = series['Quantity'].std()
    cv_quantity = std_quantity / mean_quantity
    return pd.Series([sum_sales, mean_sales, std_sales, cv_sales, sum_quantity, mean_quantity, std_quantity, cv_quantity],
index=['Sum_Sales', 'Mean_Sales', 'Std_Sales', 'CV_Sales',
'Sum_Quantity', 'Mean_Quantity', 'Std_Quantity', 'CV_Quantity'])</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.454.1">The </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.455.1">custom function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">compute_statistics</span></strong><span class="koboSpan" id="kobo.457.1">) now computes multiple statistics (sum, mean, std, CV) for both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Sales</span></strong><span class="koboSpan" id="kobo.459.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">Quantity</span></strong><span class="koboSpan" id="kobo.461.1"> columns within each group defined by </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">Category</span></strong><span class="koboSpan" id="kobo.463.1">. </span><span class="koboSpan" id="kobo.463.2">For each category group (series), it calculates </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">the following:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Sum_Sales</span></strong><span class="koboSpan" id="kobo.466.1">: The sum </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">of sales</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Mean_Sales</span></strong><span class="koboSpan" id="kobo.469.1">: The mean </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">of sales</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">Std_Sales</span></strong><span class="koboSpan" id="kobo.472.1">: The standard deviation </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">of sales</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">CV_Sales</span></strong><span class="koboSpan" id="kobo.475.1">: The </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">coefficient of variation</span></strong><span class="koboSpan" id="kobo.477.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.478.1">CV</span></strong><span class="koboSpan" id="kobo.479.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">of </span></span><span class="No-Break"><a id="_idIndexMarker414"/></span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">sales</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Sum_Quantity</span></strong><span class="koboSpan" id="kobo.483.1">: Sum </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">of quantities</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Mean_Quantity</span></strong><span class="koboSpan" id="kobo.486.1">: Mean </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">of quantities</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Std_Quantity</span></strong><span class="koboSpan" id="kobo.489.1">: Standard deviation </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">of quantities</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">CV_Quantity</span></strong><span class="koboSpan" id="kobo.492.1">: The CV </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">of quantities</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.494.1">In the end, it returns a pandas Series with these computed statistics, </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">indexed appropriately.</span></span></p></li>				<li><span class="koboSpan" id="kobo.496.1">Next, we’ll perform a groupby operation on </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Category</span></strong><span class="koboSpan" id="kobo.498.1"> and apply our custom function to compute statistics of </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">Sales</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.500.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Quantity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.503.1">
result_complex = df.groupby('Category').apply(compute_statistics).reset_index()</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.504.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">apply()</span></strong><span class="koboSpan" id="kobo.506.1"> in conjunction with </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">groupby('Category')</span></strong><span class="koboSpan" id="kobo.508.1"> to apply the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">compute_statistics</span></strong><span class="koboSpan" id="kobo.510.1"> function to each group of sales data defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Category</span></strong><span class="koboSpan" id="kobo.512.1"> column. </span><span class="koboSpan" id="kobo.512.2">The</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.513.1"> function operates on the entire group (series), allowing the computation of statistics for both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Sales</span></strong><span class="koboSpan" id="kobo.515.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">Quantity</span></strong><span class="koboSpan" id="kobo.517.1"> columns simultaneously. </span><span class="koboSpan" id="kobo.517.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">reset_index()</span></strong><span class="koboSpan" id="kobo.519.1"> is used to flatten the resulting DataFrame, providing a structured output with category-wise statistics for both columns. </span><span class="koboSpan" id="kobo.519.2">Let’s have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">final DataFrame:</span></span></p></li>			</ol>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<span class="koboSpan" id="kobo.521.1"><img src="image/B19801_06_2.jpg" alt="" role="presentation"/></span>
				</div>
			</div>
			<p class="list-inset"><span class="koboSpan" id="kobo.522.1">By grouping the data by </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">Category</span></strong><span class="koboSpan" id="kobo.524.1">, we can analyze sales and quantity metrics at the category level, which helps us understand how different types of products (electronics, furniture, clothing) perform in terms of sales and quantity. </span><span class="koboSpan" id="kobo.524.2">As we can see from the presented results, </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Furniture</span></strong><span class="koboSpan" id="kobo.526.1"> is the key income generator as it has the highest </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Sum_Sales</span></strong><span class="koboSpan" id="kobo.528.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Mean_Sales</span></strong><span class="koboSpan" id="kobo.530.1">, indicating a category with popular or high-value products. </span><span class="koboSpan" id="kobo.530.2">Categories with lower </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">CV_Sales</span></strong><span class="koboSpan" id="kobo.532.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">CV_Quantity</span></strong><span class="koboSpan" id="kobo.534.1"> values, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Clothing</span></strong><span class="koboSpan" id="kobo.536.1">, are more consistent in sales and quantity, suggesting stable demand or predictable sales patterns whereas categories with higher variability (</span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Std_Sales</span></strong><span class="koboSpan" id="kobo.538.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Std_Quantity</span></strong><span class="koboSpan" id="kobo.540.1">) may indicate products with fluctuating sales or </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">seasonal demand.</span></span></p>
			<p><span class="koboSpan" id="kobo.542.1">This is great in terms of data analysis, but now, we get asked to come up with some strategic decisions related to product assortment, pricing strategies, and marketing initiatives. </span><span class="koboSpan" id="kobo.542.2">Let’s be a little bit more creative at </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">this point:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.544.1">Categories with high </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Sum_Sales</span></strong><span class="koboSpan" id="kobo.546.1"> values and stable metrics (</span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">CV_Sales</span></strong><span class="koboSpan" id="kobo.548.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">CV_Quantity</span></strong><span class="koboSpan" id="kobo.550.1">) are prime candidates for expanding product lines or investing in </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">marketing efforts</span></span></li>
				<li><span class="koboSpan" id="kobo.552.1">Categories with high variability (</span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">Std_Sales</span></strong><span class="koboSpan" id="kobo.554.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">Std_Quantity</span></strong><span class="koboSpan" id="kobo.556.1">) may require dynamic pricing strategies or seasonal promotions to </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">optimize sales</span></span></li>
				<li><span class="koboSpan" id="kobo.558.1">We can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">Mean_Sales</span></strong><span class="koboSpan" id="kobo.560.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Mean_Quantity</span></strong><span class="koboSpan" id="kobo.562.1"> values to identify categories with potential </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">for growth</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.564.1">When </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.565.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">apply()</span></strong><span class="koboSpan" id="kobo.567.1"> function in pandas without specifying the axis parameter, the default behavior is </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">axis=0</span></strong><span class="koboSpan" id="kobo.569.1">. </span><span class="koboSpan" id="kobo.569.2">This means that the function will be applied to each column (i.e., it will process each column independently). </span><span class="koboSpan" id="kobo.569.3">This is what we have applied in the example code provided earlier. </span><span class="koboSpan" id="kobo.569.4">Depending on your specific use case, adjust </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">apply()</span></strong><span class="koboSpan" id="kobo.571.1"> to operate row-wise (</span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">axis=1</span></strong><span class="koboSpan" id="kobo.573.1">) or column-wise (</span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">axis=0</span></strong><span class="koboSpan" id="kobo.575.1">) as needed. </span><span class="koboSpan" id="kobo.575.2">Next, let’s focus </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">axis=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">.</span></span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">axis=1</span></strong><span class="koboSpan" id="kobo.580.1"> applies the function along the columns, so it processes each row independently. </span><span class="koboSpan" id="kobo.580.2">This is typically used when you want to perform row-wise operations (e.g., calculating a custom metric for </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">each row).</span></span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<span class="koboSpan" id="kobo.582.1"><img src="image/B19801_06_3.jpg" alt="Figure 6.2 – Apply() with axis=1"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.583.1">Figure 6.2 – Apply() with axis=1</span></p>
			<p><span class="koboSpan" id="kobo.584.1">Applying functions row-wise allows for row-level transformations and calculations. </span><span class="koboSpan" id="kobo.584.2">Let’s see a code example with </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">axis=1</span></strong><span class="koboSpan" id="kobo.586.1">. </span><span class="koboSpan" id="kobo.586.2">Let’s start by defining a function to be applied across columns (</span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">axis=1</span></strong><span class="koboSpan" id="kobo.588.1">). </span><span class="koboSpan" id="kobo.588.2">The code can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/4.apply_axis1.py"><span class="No-Break"><span class="koboSpan" id="kobo.590.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/4.apply_axis1.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.591.1">:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.592.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">row_summary</span></strong><span class="koboSpan" id="kobo.594.1"> function takes a single row of a DataFrame as input and returns a summary of that row’s data. </span><span class="koboSpan" id="kobo.594.2">The input for the function is key to understanding that</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.595.1"> is a single row of the DataFrame, passed as a </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">pandas Series:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
def row_summary(row):
    total_sales_quantity = row['Sales'] + row['Quantity']
    sales_quantity_ratio = row['Sales'] / row['Quantity'] if row['Quantity'] != 0 else np.nan
    return pd.Series(
        [total_sales_quantity,sales_quantity_ratio],
        index=['Total_Sales_Quantity',
        'Sales_Quantity_Ratio'])</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.598.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">total_sales_quantity</span></strong><span class="koboSpan" id="kobo.600.1"> variable will store the sum of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Sales</span></strong><span class="koboSpan" id="kobo.602.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Quantity</span></strong><span class="koboSpan" id="kobo.604.1"> for the row. </span><span class="koboSpan" id="kobo.604.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">sales_quantity_ratio</span></strong><span class="koboSpan" id="kobo.606.1"> variable will store the ratio of </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Sales</span></strong><span class="koboSpan" id="kobo.608.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">Quantity</span></strong><span class="koboSpan" id="kobo.610.1"> for the row, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">np.nan</span></strong><span class="koboSpan" id="kobo.612.1"> if the quantity is zero, providing insight into the </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">sales efficiency.</span></span></p></li>				<li><span class="koboSpan" id="kobo.614.1">We apply the function </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">row-wise (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">axis=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.618.1">
df_row_summary = df.apply(row_summary, axis=1)
   Total_Sales_Quantity  Sales_Quantity_Ratio
0                 110.0                 10.00
1                 205.0                 40.00
2                 158.0                 18.75
3                 303.0                100.00
4                 135.0                  8.00
5                 192.0                 15.0</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.619.1">This will produce a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">df_row_summary</span></strong><span class="koboSpan" id="kobo.621.1"> DataFrame where each row corresponds to the calculated values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">total_sales_quantity</span></strong><span class="koboSpan" id="kobo.623.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">sales_quantity_ratio</span></strong><span class="koboSpan" id="kobo.625.1"> for the original rows </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">df</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">.</span></span></p></li>				<li><span class="koboSpan" id="kobo.629.1">Finally, we</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.630.1"> group by </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Category</span></strong><span class="koboSpan" id="kobo.632.1"> to calculate metrics </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">per category:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
category_metrics = df.groupby('Category')[['Total_Sales_Quantity', 'Sales_Quantity_Ratio']].mean().reset_index()</span></pre></li>			</ol>
			<p><span class="koboSpan" id="kobo.635.1">Let’s see the </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">final result:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
     Category  Total_Sales_Quantity  Sales_Quantity_Ratio
0     Clothing                 163.5                11.500
1  Electronics                 157.5                25.000
2    Furniture                 230.5                59.375</span></pre>			<p><span class="koboSpan" id="kobo.638.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">total_sales_quantity</span></strong><span class="koboSpan" id="kobo.640.1"> metric provides a simple yet effective measure of overall sales performance per transaction, helping to understand the combined impact of the number of items sold (</span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">Quantity</span></strong><span class="koboSpan" id="kobo.642.1">) and their sales value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Sales</span></strong><span class="koboSpan" id="kobo.644.1">). </span><span class="koboSpan" id="kobo.644.2">By analyzing </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">total_sales_quantity</span></strong><span class="koboSpan" id="kobo.646.1">, we can identify transactions with high combined sales and quantity, which might indicate popular product categories or successful sales strategies. </span><span class="koboSpan" id="kobo.646.2">Conversely, it also helps recognize low-performing transactions, thereby guiding inventory management and promotional adjustments to improve sales efficiency and product performance. </span><span class="koboSpan" id="kobo.646.3">This dual insight aids in strategic decision-making to optimize sales and </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">inventory management.</span></span></p>
			<p><span class="koboSpan" id="kobo.648.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">sales_quantity_ratio</span></strong><span class="koboSpan" id="kobo.650.1"> metric provides valuable insights into the efficiency of sales per unit quantity, revealing how effectively products convert quantity into revenue. </span><span class="koboSpan" id="kobo.650.2">This metric is crucial for assessing the value derived from each unit sold. </span><span class="koboSpan" id="kobo.650.3">With this, we can identify products that generate high revenue per unit, indicating high-value items that may warrant prioritized marketing efforts. </span><span class="koboSpan" id="kobo.650.4">Conversely, it helps uncover products with a low revenue per unit, signaling potential areas for price adjustments, targeted promotions, or re-evaluation within the product portfolio to optimize profitability and </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">sales performance.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.652.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.653.1">Whenever feasible, prefer using vectorized operations (built-in pandas methods or NumPy functions) over </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">apply</span></strong><span class="koboSpan" id="kobo.655.1"> for performance reasons. </span><span class="koboSpan" id="kobo.655.2">Vectorized operations are generally faster because they leverage optimized C code under </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">the hood.</span></span></p>
			<p><span class="koboSpan" id="kobo.657.1">The concepts </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.658.1">and techniques we have explored so far directly lead to the importance of filtering in data cleaning. </span><span class="koboSpan" id="kobo.658.2">Once we have applied transformations or aggregated data, filtering allows us to focus on specific subsets of data that are relevant to our analysis or meet certain conditions. </span><span class="koboSpan" id="kobo.658.3">For example, after calculating sales performance metrics, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Total_Sales_Quantity</span></strong><span class="koboSpan" id="kobo.660.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Sales_Quantity_Ratio</span></strong><span class="koboSpan" id="kobo.662.1">, across different product categories, filtering can help identify categories or products that require further investigation, such as those with unusually high or low </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">performance metrics.</span></span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.664.1">Data filtering</span></h1>
			<p><strong class="bold"><span class="koboSpan" id="kobo.665.1">Data filtering</span></strong><span class="koboSpan" id="kobo.666.1"> is a</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.667.1"> fundamental operation in data manipulation that involves selecting a subset of data based on specified conditions or criteria. </span><span class="koboSpan" id="kobo.667.2">It is used to extract relevant information from a larger dataset, exclude unwanted data points, or focus on specific segments that are of interest for analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">or reporting.</span></span></p>
			<p><span class="koboSpan" id="kobo.669.1">In the following example, we filter the DataFrame to only include rows where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">Quantity</span></strong><span class="koboSpan" id="kobo.671.1"> column is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">10</span></strong><span class="koboSpan" id="kobo.673.1">. </span><span class="koboSpan" id="kobo.673.2">This operation selects products that have sold more than 10 units, focusing our analysis on potentially high-performing </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">products. </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/5.simple_filtering.py"><span class="No-Break"><span class="koboSpan" id="kobo.675.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/5.simple_filtering.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.676.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.677.1">
filtered_data = df[df['Quantity'] &gt; 10]</span></pre>			<p><span class="koboSpan" id="kobo.678.1">Let’s have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">resulting DataFrame:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.680.1">
   Category Sub-Category  Sales  Quantity        Date
4  Clothing          Men    120        15  2023-01-05
5  Clothing        Women    180        12  2023-01-06</span></pre>			<p><span class="koboSpan" id="kobo.681.1">Moving beyond simple filters allows us to identify electronic products that satisfy more complex conditions, as we will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">next section.</span></span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.683.1">Multiple criteria for filtering</span></h2>
			<p><span class="koboSpan" id="kobo.684.1">Filtering may</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.685.1"> involve complex conditions, such as combining logical </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">AND</span></strong><span class="koboSpan" id="kobo.687.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">OR</span></strong><span class="koboSpan" id="kobo.689.1"> operations, or using nested conditions. </span><span class="koboSpan" id="kobo.689.2">Let’s say that the management team wants us to identify high-value electronics products (</span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">sales &gt; 1000</span></strong><span class="koboSpan" id="kobo.691.1">) with relatively low sales quantities (</span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">quantity &lt; </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">30</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">).</span></span></p>
			<p><span class="koboSpan" id="kobo.695.1">Let’s see how we can do this with multiple filtering criteria (the code can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/6.advanced_filtering.py"><span class="No-Break"><span class="koboSpan" id="kobo.697.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter06/6.advanced_filtering.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.698.1">):</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.699.1">
filtered_data = df[(df['Sales'] &gt; 1000) &amp; (df['Quantity'] &lt; 30)]</span></pre>			<p><span class="koboSpan" id="kobo.700.1">In this example, we define a filter condition that filters rows where the sales are greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">1000</span></strong><span class="koboSpan" id="kobo.702.1"> and the quantity is less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">30</span></strong><span class="koboSpan" id="kobo.704.1">. </span><span class="koboSpan" id="kobo.704.2">Let’s have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">resulting DataFrame:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.706.1">
      Category Sub-Category  Sales  Quantity        Date
1  Electronics       Laptop   1500        25  2023-01-02</span></pre>			<p><span class="koboSpan" id="kobo.707.1">Filtering is a straightforward operation to implement, but let’s explore some best practices to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">its effectiveness.</span></span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.709.1">Best practices for filtering</span></h2>
			<p><span class="koboSpan" id="kobo.710.1">Let’s </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.711.1">explore the best practices that can enhance the effectiveness of </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">filtering operations:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.713.1">Clearly define the filtering criteria based on the analysis goals. </span><span class="koboSpan" id="kobo.713.2">Use conditions that are specific and relevant to the insights you want </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">to derive.</span></span></li>
				<li><span class="koboSpan" id="kobo.715.1">Utilize built-in filter functions provided by data manipulation libraries, such as pandas in Python or SQL queries in databases. </span><span class="koboSpan" id="kobo.715.2">These functions are optimized for performance and ease </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">of use.</span></span></li>
				<li><span class="koboSpan" id="kobo.717.1">Ensure that the filtering criteria do not exclude important data points that might be valuable for analysis. </span><span class="koboSpan" id="kobo.717.2">Validate the results to confirm they align with the </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">expected outcomes.</span></span></li>
				<li><span class="koboSpan" id="kobo.719.1">Document the filtering criteria and steps applied to maintain transparency and facilitate reproducibility of </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">the analysis.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.721.1">As datasets grow, filtering</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.722.1"> becomes essential to manage and extract insights efficiently. </span><span class="koboSpan" id="kobo.722.2">Operations that involve processing large volumes of data can become prohibitively slow without effective filtering strategies. </span><span class="koboSpan" id="kobo.722.3">Filtering helps in optimizing resource utilization, such as memory and processing power, by reducing the amount of data that needs to be stored and processed at any </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">given time.</span></span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.724.1">Performance considerations as data grows</span></h2>
			<p><span class="koboSpan" id="kobo.725.1">Let’s have a </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.726.1">look at things to keep in mind as </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">data grows:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.728.1">Filtering operations optimize query execution by reducing the number of rows or columns that need to be processed, leading to faster response times for data queries </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">and analyses.</span></span></li>
				<li><span class="koboSpan" id="kobo.730.1">Large datasets consume significant memory and storage resources. </span><span class="koboSpan" id="kobo.730.2">Filtering reduces the amount of data held in memory or stored on disk, improving efficiency, and reducing operational costs associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">data storage.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.732.1">Let’s now summarize the learnings from </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">this chapter.</span></span></p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.734.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.735.1">In this chapter, we’ve explored some powerful techniques, such as grouping, aggregation, and applying custom functions. </span><span class="koboSpan" id="kobo.735.2">These methods are essential for summarizing and transforming data, enabling deeper insights into datasets. </span><span class="koboSpan" id="kobo.735.3">We’ve learned how to efficiently group data by categorical variables, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">Category</span></strong><span class="koboSpan" id="kobo.737.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">Region</span></strong><span class="koboSpan" id="kobo.739.1">, and apply aggregate functions, such as sum, mean, and custom metrics to derive </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">meaningful summaries.</span></span></p>
			<p><span class="koboSpan" id="kobo.741.1">Additionally, we deep-dived into the versatility of </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">apply</span></strong><span class="koboSpan" id="kobo.743.1"> functions, which allow for row-wise or column-wise custom computations. </span><span class="koboSpan" id="kobo.743.2">Best practices, such as optimizing function efficiency, handling missing values, and understanding performance implications, were emphasized to ensure effective data processing. </span><span class="koboSpan" id="kobo.743.3">Finally, we discussed the strategic application of filters to refine datasets based on specific criteria, enhancing data </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">analysis precision.</span></span></p>
			<p><span class="koboSpan" id="kobo.745.1">In the next chapter, we will discuss designing and optimizing data write operations to efficiently store the transformed and </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">cleaned data.</span></span></p>
		</div>
	</body></html>