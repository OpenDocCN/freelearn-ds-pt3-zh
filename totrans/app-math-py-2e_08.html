<html><head></head><body>
		<div id="_idContainer983">
			<h1 class="chapter-number" id="_idParaDest-328"><a id="_idTextAnchor327"/>8</h1>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor328"/>Geometric Problems</h1>
			<p>This chapter describes solutions to several problems concerning two-dimensional geometry. Geometry<a id="_idIndexMarker876"/> is a branch of mathematics concerned with the characteristics of points, lines, and other figures (shapes), the interaction between these figures, and the transformation of these figures. In this chapter, we’ll focus on the characteristics of two-dimensional figures and the interactions between <span class="No-Break">these objects.</span></p>
			<p>There are several <a id="_idIndexMarker877"/>problems we must overcome when working with geometric objects in Python. The biggest hurdle is the problem of representation. Most geometric objects occupy a region on the two-dimensional plane and, as such, it is impossible to store every point that lies within the region. Instead, we have to find a more compact way to represent the region that can be stored as a relatively small number of points or other attributes. For example, we might store a selection of points along the boundary of an object that we can reconstruct the boundary and the object itself from. We also have to reformulate the problems into questions that can be answered using <span class="No-Break">representative data.</span></p>
			<p>The second biggest problem is converting purely geometric questions into a form that can be understood and solved using software. This can be relatively simple – for example, finding the point at which two straight lines intersect is a matter of solving a matrix equation – or it can be extremely complex, depending on the type of question being asked. A common technique that’s used to solve these problems is to represent the figure in question using more simple objects and solve the (hopefully) easier problem using each of the simple objects. This should then give us an idea of the solution to the <span class="No-Break">original problem.</span></p>
			<p>We will start by showing you how to visualize two-dimensional shapes using patches, and then learn how to determine whether a point is contained within another figure. Then, we’ll move on and look at edge detection, triangulation, and finding convex hulls. We’ll conclude this chapter by constructing <span class="No-Break">Bezier curves.</span></p>
			<p>This chapter covers the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Visualizing two-dimensional <span class="No-Break">geometric shapes</span></li>
				<li>Finding <span class="No-Break">interior points</span></li>
				<li>Finding edges in <span class="No-Break">an image</span></li>
				<li>Triangulating <span class="No-Break">planar figures</span></li>
				<li>Computing <span class="No-Break">convex hulls</span></li>
				<li>Constructing <span class="No-Break">Bezier curves</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>Technical requirements</h1>
			<p>For this chapter, we will need the NumPy package and the Matplotlib package, as usual. We will also need the Shapely package and the <strong class="source-inline">scikit-image</strong> package, which can be installed using your favorite package manager, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
python3.10 -m pip install numpy matplotlib shapely scikit-image</pre>
			<p>The code for this chapter can be found in the <span class="No-Break"><strong class="source-inline">Chapter 08</strong></span> folder of the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008"><span class="No-Break">https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor330"/>Visualizing two-dimensional geometric shapes</h1>
			<p>The <a id="_idIndexMarker878"/>focus of this chapter is on two-dimensional geometry, so our first task is to learn how to visualize two-dimensional geometric figures. Some of the techniques and tools mentioned here might apply to three-dimensional geometric figures, but generally, this will require more specialized packages and tools. The first method for plotting a region on the plane might be to pick a selection of points around the boundary and plot these with the usual tools. However, this is generally going to be inefficient. Instead, we’re going to implement Matplotlib patches that make use of efficient representations of these figures – in this recipe, the center and radius of a circle (disk) – that Matplotlib can fill efficiently on <span class="No-Break">a plot.</span></p>
			<p>A <strong class="bold">geometric figure</strong>, at<a id="_idIndexMarker879"/> least in the context of this book, is any point, line, curve, or closed region (including the boundary) whose boundary is a collection of lines and curves. Simple examples include points and lines (obviously), rectangles, polygons, <span class="No-Break">and circles.</span></p>
			<p>In this recipe, we will learn how to visualize geometric figures using <span class="No-Break">Matplotlib patches.</span></p>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor331"/>Getting ready</h2>
			<p>For this <a id="_idIndexMarker880"/>recipe, we need the NumPy package imported as <strong class="source-inline">np</strong>, and the Matplotlib <strong class="source-inline">pyplot</strong> module imported as <strong class="source-inline">plt</strong>. We also need to import the <strong class="source-inline">Circle</strong> class from the Matplotlib <strong class="source-inline">patches</strong> module and the <strong class="source-inline">PatchCollection</strong> class from the Matplotlib <strong class="source-inline">collections</strong> module. </p>
			<p>This can be done with the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection</pre>
			<p>We will also need the <strong class="source-inline">swisscheese-grid-10411.csv</strong> data file from the code repository for <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor332"/>How to do it...</h2>
			<p>The<a id="_idIndexMarker881"/> following steps show you to visualize a two-dimensional <span class="No-Break">geometric figure:</span></p>
			<ol>
				<li>First, we load the data from the <strong class="source-inline">swisscheese-grid-10411.csv</strong> file from this book’s <span class="No-Break">code repository:</span><pre class="console">
data = np.loadtxt("swisscheese-grid-10411.csv")</pre></li>
				<li>We create a new patch object that represents a region on a plot. This is going to be a circle (disk) with the center at the origin and a radius of <strong class="source-inline">1</strong>. We create a new set of axes and add this patch <span class="No-Break">to them:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
outer = Circle((0.0, 0.0), 1.0, zorder=0, fc="k")</pre><pre class="console">
ax.add_patch(outer)</pre></li>
				<li>Next, we <a id="_idIndexMarker882"/>create a <strong class="source-inline">PatchCollection</strong> object from the data we loaded in <em class="italic">step 1</em>, which contains centers and radii for a number of other circles. We then add this <strong class="source-inline">PatchCollection</strong> to the axes we created in <span class="No-Break"><em class="italic">step 2</em></span><span class="No-Break">:</span><pre class="console">
col = PatchCollection(</pre><pre class="console">
    (Circle((x, y), r) for x, y, r in data),</pre><pre class="console">
    facecolor="white", zorder=1, linewidth=0.2,</pre><pre class="console">
    ls="-", ec="k"</pre><pre class="console">
)</pre><pre class="console">
ax.add_collection(col)</pre></li>
				<li>Finally, we set the <img alt="" src="image/Formula_08_001.png"/>- and <img alt="" src="image/Formula_08_002.png"/>-axis ranges so that the whole image is displayed and then turn the <span class="No-Break">axes off:</span><pre class="console">
ax.set_xlim((-1.1, 1.1))</pre><pre class="console">
ax.set_ylim((-1.1, 1.1))</pre><pre class="console">
ax.set_axis_off()</pre></li>
			</ol>
			<p>The resulting image is of a <em class="italic">Swiss cheese</em>, as <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer947">
					<img alt="Figure 8.1 – Plot of a Swiss cheese&#13;&#10;" src="image/B19085_08_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Plot of a Swiss cheese</p>
			<p>You can<a id="_idIndexMarker883"/> see in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> that most of the<a id="_idIndexMarker884"/> original disk (shaded black) has been covered by subsequent disks (<span class="No-Break">shaded white).</span></p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor333"/>How it works...</h2>
			<p>Key to this recipe are the <strong class="source-inline">Circle</strong> and <strong class="source-inline">PatchCollection</strong> objects, which represent the regions of the plot area on Matplotlib axes. In this case, we are creating one large circular patch, centered at the origin and with a radius of <strong class="source-inline">1</strong>, that has a black face color and uses <strong class="source-inline">zorder=0</strong> to place it behind other patches. This patch is added to the <strong class="source-inline">Axes</strong> object using the <span class="No-Break"><strong class="source-inline">add_patch</strong></span><span class="No-Break"> method.</span></p>
			<p>The next step is to create an object that will render the circles represented by the data that we loaded from the CSV file in <em class="italic">step 1</em>. This data consisted of <img alt="" src="image/Formula_08_003.png"/>, <img alt="" src="image/Formula_08_004.png"/>, and <img alt="" src="image/Formula_08_005.png"/> values for the center <img alt="" src="image/Formula_08_006.png"/> and the radius, <img alt="" src="image/Formula_08_007.png"/>, of the individual circles (10,411 in total). The <strong class="source-inline">PatchCollection</strong> object combines a sequence of patches into a single object that can be added to an <strong class="source-inline">Axes</strong> object. Here, we add one <strong class="source-inline">Circle</strong> for each row in our data, which is then added to the <strong class="source-inline">Axes</strong> object using the <strong class="source-inline">add_collection</strong> method. Notice that we have applied the face color to the whole collection, rather than to each individual <strong class="source-inline">Circle</strong> constituent. We set the face color to white (using the <strong class="source-inline">facecolor="w"</strong> argument), the edge color to black (using <strong class="source-inline">ec="k"</strong>), the line width (of the edge lines) to 0.2 (using <strong class="source-inline">linewidth=0.2</strong>), and the edge style to a continuous line. All of this, when put together, results in <span class="No-Break">our image.</span></p>
			<p>The<a id="_idIndexMarker885"/> image that we have created here is called a <em class="italic">Swiss cheese</em>. It was <a id="_idIndexMarker886"/>first used in rational approximation theory in 1938 by Alice Roth; it was subsequently rediscovered, and similar constructions have been used many times since. We used this example because it consists of one large individual part, plus a large collection of smaller individual parts. Roth’s Swiss cheese is an example of a set in the plane that has a positive area but no topological interior. This means that we cannot find any disk of positive radius that is wholly contained within the set (it is amazing that such a set can even exist!). More importantly, there are continuous functions defined on this Swiss cheese that cannot be uniformly approximated by rational functions. This property has made similar constructions useful in the theory<a id="_idIndexMarker887"/> of <span class="No-Break"><em class="italic">uniform algebras</em></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Circle</strong> class is a subclass of the more general <strong class="source-inline">Patch</strong> class. There are numerous other <strong class="source-inline">Patch</strong> classes that represent different planar figures, such as <strong class="source-inline">Polygon</strong> and <strong class="source-inline">PathPatch</strong>, which represent the region bounded by a path (curve or collection of curves). These can be used to generate complex patches that can be rendered in a Matplotlib figure. Collections can be used to apply settings to a number of patch objects simultaneously, which can be especially useful if, as in this recipe, you have a large number of objects that will all be rendered in the <span class="No-Break">same style.</span></p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/>There’s more...</h2>
			<p>There are many different patch types<a id="_idIndexMarker888"/> available in Matplotlib. In this recipe, we used the <strong class="source-inline">Circle</strong> patch class, which represents a circular region on the axes. There is <a id="_idIndexMarker889"/>also the <strong class="source-inline">Polygon</strong> patch class, which represents a polygon (regular or otherwise). There are also <strong class="source-inline">PatchPath</strong> objects, which are regions that are surrounded by a curve that does not necessarily consist of straight-line segments. This is similar to the way a shaded region can be constructed in many vector graphics <span class="No-Break">software packages.</span></p>
			<p>In addition to the single patch types in Matplotlib, there are a number of collection types that gather a number of patches together to be used as a single object. In this recipe, we used the <strong class="source-inline">PatchCollection</strong> class to gather a large number of <strong class="source-inline">Circle</strong> patches. There are more specialized patch collections that can be used to generate these internal patches automatically, rather than us generating <span class="No-Break">them ourselves.</span></p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/>See also</h2>
			<p>A more detailed history of Swiss cheeses in mathematics can be found in the following biographical article: Daepp, U., Gauthier, P., Gorkin, P., and Schmieder, G., 2005. <em class="italic">Alice in Switzerland: The life and mathematics of Alice Roth</em>. <em class="italic">The Mathematical Intelligencer</em>, 27(1), <span class="No-Break">pp. 41-54.</span></p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor336"/>Finding interior points</h1>
			<p>One problem<a id="_idIndexMarker890"/> with working with two-dimensional figures in a programming environment is that you can’t possibly store all the points that lie within the figure. Instead, we usually store far fewer points that represent the figure in some way. In most cases, this will be a number of points (connected by lines) that describe the boundary of the figure. This is efficient in terms of memory and makes it easy to visualize them on screen using Matplotlib patches, for example. However, this approach makes it more difficult to determine whether a point or another figure lies within a given figure. This is a crucial question in many <span class="No-Break">geometric problems.</span></p>
			<p>In this recipe, we will learn how to represent geometric figures and determine whether a point lies within a figure <span class="No-Break">or not.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/>Getting ready</h2>
			<p>For this recipe, we will need to import the <strong class="source-inline">matplotlib</strong> package (as a whole) as <strong class="source-inline">mpl</strong> and the <strong class="source-inline">pyplot</strong> module <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import matplotlib as mpl
import matplotlib.pyplot as plt</pre>
			<p>We also need to import the <strong class="source-inline">Point</strong> and <strong class="source-inline">Polygon</strong> objects from the <strong class="source-inline">geometry</strong> module of the Shapely package. The Shapely package contains many routines and objects for representing, manipulating, and analyzing two-dimensional <span class="No-Break">geometric figures:</span></p>
			<pre class="source-code">
from shapely.geometry import Polygon, Point</pre>
			<p>These two classes will be used to represent our two-dimensional geometric figures. Let’s see how to use these classes to see whether a polygon contains a point <span class="No-Break">or not.</span></p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/>How to do it...</h2>
			<p>The following <a id="_idIndexMarker891"/>steps show you how to create a Shapely representation of a polygon and then test whether a point lies within <span class="No-Break">this polygon:</span></p>
			<ol>
				<li value="1">Create a sample polygon <span class="No-Break">to test:</span><pre class="console">
polygon = Polygon(</pre><pre class="console">
    [(0, 2), (-1, 1), (-0.5, -1), (0.5, -1), (1, 1)],</pre><pre class="console">
)</pre></li>
				<li>Next, we plot the polygon onto a new figure. First, we need to convert the polygon into a Matplotlib <strong class="source-inline">Polygon</strong> patch that can be added to <span class="No-Break">the figure:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
poly_patch = mpl.patches.Polygon(</pre><pre class="console">
    polygon.exterior.coords,</pre><pre class="console">
    ec=(0,0,0,1), fc=(0.5,0.5,0.5,0.4))</pre><pre class="console">
ax.add_patch(poly_patch)</pre><pre class="console">
ax.set(xlim=(-1.05, 1.05), ylim=(-1.05, 2.05))</pre><pre class="console">
ax.set_axis_off()</pre></li>
				<li>Now, we need to create two test points, one of which will be inside the polygon and one of which will be outside <span class="No-Break">the polygon:</span><pre class="console">
p1 = Point(0.0, 0.0)</pre><pre class="console">
p2 = Point(-1.0, -0.75)</pre></li>
				<li>We plot and annotate these two points on top of the polygon to show <span class="No-Break">their positions:</span><pre class="console">
ax.plot(0.0, 0.0, "k*")</pre><pre class="console">
ax.annotate("p1", (0.0, 0.0), (0.05, 0.0))</pre><pre class="console">
ax.plot(-0.8, -0.75, "k*")</pre><pre class="console">
ax.annotate("p2", (-0.8, -0.75), (-0.8 + 0.05, -0.75))</pre></li>
				<li>Finally, we <a id="_idIndexMarker892"/>test where each point lies within the polygon using the <strong class="source-inline">contains</strong> method, and then print the result to <span class="No-Break">the Terminal:</span><pre class="console">
print("p1 inside polygon?", polygon.contains(p1))  # True</pre><pre class="console">
print("p2 inside polygon?", polygon.contains(p2)) </pre><pre class="console">
# False</pre></li>
			</ol>
			<p>The results show that the first point, <strong class="source-inline">p1</strong>, is contained in the polygon, while the second point, <strong class="source-inline">p2</strong>, is not. This can also be seen in the following figure, which clearly shows that one point is contained within the shaded polygon, while the other point <span class="No-Break">is not:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer953">
					<img alt="Figure 8.2 – Points inside and outside a polygonal region&#13;&#10;" src="image/B19085_08_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Points inside and outside a polygonal region</p>
			<p>Once we plot the points and the polygon it is easy (for us) to see that <strong class="bold">p1</strong> lies inside the polygon and <strong class="bold">p2</strong> does not. The <strong class="source-inline">contains</strong> method on the <strong class="source-inline">polygon</strong> object correctly classifies the <span class="No-Break">points too.</span></p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/>How it works...</h2>
			<p>The Shapely <strong class="source-inline">Polygon</strong> class<a id="_idIndexMarker893"/> is a representation of a polygon that stores its vertices as points. The region enclosed by the outer boundary – the five straight lines between the stored vertices – is obvious to us and easily identified by the eye, but the notion of being <em class="italic">inside</em> the boundary is difficult to define in a way that can be easily understood by a computer. It is not even straightforward to give a formal mathematical definition of what it means to lie <em class="italic">within</em> a <span class="No-Break">given curve.</span></p>
			<p>There are two<a id="_idIndexMarker894"/> main ways to determine whether a point lies within a simple closed curve – that is, a curve that starts and ends at the same place that does not contain any self-intersections. The first uses a mathematical concept called the <strong class="bold">winding number</strong>, which <a id="_idIndexMarker895"/>counts the number of times the curve <em class="italic">wraps around</em> a point, and<a id="_idIndexMarker896"/> the <strong class="bold">ray crossing counting</strong> method, where we count the number of times a ray from the point to a point at infinity crosses the curve. Fortunately, we don’t need to compute these numbers ourselves since we can use the tools from the Shapely package to do this computation for us. This is what the <strong class="source-inline">contains</strong> method of a polygon does (under the hood, Shapely uses the GEOS library to perform <span class="No-Break">this calculation).</span></p>
			<p>The Shapely <strong class="source-inline">Polygon</strong> class can<a id="_idIndexMarker897"/> be used to compute many quantities associated with these planar figures, including perimeter length and area. The <strong class="source-inline">contains</strong> method is used to determine whether a point, or a collection of points, lies within the polygon represented by the object (there are some limitations regarding the kinds of polygons that can be represented by this class). In fact, you can use the same method to determine whether one polygon is contained within another since, as we have seen in this recipe, a polygon is represented by a simple collection <span class="No-Break">of points.</span></p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>Finding edges in an image</h1>
			<p>Finding edges <a id="_idIndexMarker898"/>in images is a good way of reducing a complex image that<a id="_idIndexMarker899"/> contains a lot of noise and distractions to a very simple image containing the most prominent outlines. This can be useful as our first step of the analysis process, such as in image classification, or as the process of importing line outlines into computer graphics <span class="No-Break">software packages.</span></p>
			<p>In this recipe, we will learn how to use the <strong class="source-inline">scikit-image</strong> package and the Canny algorithm to find the edges in a <span class="No-Break">complex image.</span></p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor341"/>Getting ready</h2>
			<p>For this recipe, we will need to import the Matplotlib <strong class="source-inline">pyplot</strong> module as <strong class="source-inline">plt</strong>, the <strong class="source-inline">imread</strong> routine from the <strong class="source-inline">skimage.io</strong> module, and the <strong class="source-inline">canny</strong> routine from the <span class="No-Break"><strong class="source-inline">skimage.feature</strong></span><span class="No-Break"> module:</span></p>
			<pre class="source-code">
import matplotlib.pyplot as plt
from skimage.io import imread
from skimage.feature import canny</pre>
			<p>The <strong class="source-inline">canny</strong> routine implements the edge detection algorithm. Let’s see how to <span class="No-Break">use it.</span></p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor342"/>How to do it…</h2>
			<p>Follow these steps<a id="_idIndexMarker900"/> to learn how to use the <strong class="source-inline">scikit-image</strong> package to <a id="_idIndexMarker901"/>find edges in <span class="No-Break">an image:</span></p>
			<ol>
				<li value="1">Load the image data from the source file. This can be found in the GitHub repository for this chapter. Crucially, we pass in <strong class="source-inline">as_gray=True</strong> to load the image <span class="No-Break">in grayscale:</span><pre class="console">
image = imread("mandelbrot."ng", as_gray=True)</pre></li>
			</ol>
			<p>The following is the original image, for reference. The set itself is shown by the white region and, as you can see, the boundary, indicated by the darker shades, is <span class="No-Break">very complex:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer954">
					<img alt="Figure 8.3 – Plot of the Mandelbrot set generated using Python&#13;&#10;" src="image/B19085_08_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Plot of the Mandelbrot set generated using Python</p>
			<ol>
				<li value="2">Next, we use the <strong class="source-inline">canny</strong> routine, which needs to be imported from the <strong class="source-inline">features</strong> module of the <strong class="source-inline">scikit-image</strong> package. The <strong class="source-inline">sigma</strong> value is set to <strong class="source-inline">0.5</strong> for <span class="No-Break">this image:</span><pre class="console">
edges = canny(image, sigma=0.5)</pre></li>
				<li>Finally, we<a id="_idIndexMarker902"/> add the <strong class="source-inline">edges</strong> image to a new figure with a<a id="_idIndexMarker903"/> grayscale (reversed) <span class="No-Break">color map:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
ax.imshow(edges, cmap="gray_r")</pre><pre class="console">
ax.set_axis_off()</pre></li>
			</ol>
			<p>The edges that have been detected can be seen in the following image. The edge-finding algorithm has identified most of the visible details of the boundary of the Mandelbrot set, although it is not perfect (this is an estimate, <span class="No-Break">after all):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer955">
					<img alt="Figure 8.4 – The edges of the Mandelbrot set found using the scikit-image package’s Canny edge detection algorithm" src="image/B19085_08_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The edges of the Mandelbrot set found using the scikit-image package’s Canny edge detection algorithm</p>
			<p>We can see that the edge detection has identified a good amount of the complexity of the edge of the Mandelbrot set. Of course, the boundary of the <em class="italic">true</em> Mandelbrot set is a fractal and has <span class="No-Break">infinite complexity.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>How it works...</h2>
			<p>The <strong class="source-inline">scikit-image</strong> package<a id="_idIndexMarker904"/> provides various utilities and types for manipulating and analyzing data derived from images. As the name suggests, the <strong class="source-inline">canny</strong> routine<a id="_idIndexMarker905"/> uses the Canny edge detection algorithm to find edges in an image. This algorithm uses the intensity gradients in the image to detect edges, where the gradient is larger. It also performs some filtering to reduce the noise in the edges <span class="No-Break">it finds.</span></p>
			<p>The <strong class="source-inline">sigma</strong> keyword value <a id="_idIndexMarker906"/>we provided is the standard deviation of the Gaussian<a id="_idIndexMarker907"/> smoothing that’s applied to the image prior to calculating the gradients for edge detection. This helps us remove some of the noise from the image. The value we set (<strong class="source-inline">0.5</strong>) is smaller than the default (<strong class="source-inline">1</strong>), but it does give us a better resolution in this case. A large value would obscure some of the finer details in the boundary of the <span class="No-Break">Mandelbrot set.</span></p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor344"/>Triangulating planar figures</h1>
			<p>As we saw in <a href="B19085_03.xhtml#_idTextAnchor078"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Calculus and Differential Equations</em>, we often need to break down a continuous region into smaller, simpler regions. In earlier recipes, we reduced an interval of real numbers into a collection of smaller intervals, each with a small length. This process is usually<a id="_idIndexMarker908"/> called <strong class="bold">discretization</strong>. In this chapter, we are working with two-dimensional figures, so we need a two-dimensional version of this process. For this, we’ll break a two-dimensional figure (in this recipe, a polygon) into a collection of smaller and simpler polygons. The simplest of all polygons are triangles, so this is a good place to start for two-dimensional discretization. The process of finding a collection of <a id="_idIndexMarker909"/>triangles that <em class="italic">tiles</em> a geometric figure is <span class="No-Break">called </span><span class="No-Break"><strong class="bold">triangulation</strong></span><span class="No-Break">.</span></p>
			<p>In this recipe, we will <a id="_idIndexMarker910"/>learn how to triangulate a polygon (with a hole) using the <span class="No-Break">Shapely package.</span></p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor345"/>Getting ready</h2>
			<p>For this recipe, we will need the NumPy package imported as <strong class="source-inline">np</strong>, the Matplotlib package imported as <strong class="source-inline">mpl</strong>, and the <strong class="source-inline">pyplot</strong> module imported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np</pre>
			<p>We also need the following items from the <span class="No-Break">Shapely package:</span></p>
			<pre class="source-code">
from shapely.geometry import Polygon
from shapely.ops import triangulate</pre>
			<p>Let’s see how to use the <strong class="source-inline">triangulate</strong> routine to triangulate <span class="No-Break">a polygon.</span></p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor346"/>How to do it...</h2>
			<p>The following steps show<a id="_idIndexMarker911"/> you how to triangulate a polygon with a hole using the <span class="No-Break">Shapely package:</span></p>
			<ol>
				<li value="1">First, we need to create a <strong class="source-inline">Polygon</strong> object that represents the figure that we wish <span class="No-Break">to triangulate:</span><pre class="console">
polygon = Polygon(</pre><pre class="console">
    [(2.0, 1.0), (2.0, 1.5), (-4.0, 1.5), (-4.0, 0.5),</pre><pre class="console">
    (-3.0, -1.5), (0.0, -1.5), (1.0, -2.0), (1.0,-0.5),</pre><pre class="console">
    (0.0, -1.0), (-0.5, -1.0), (-0.5, 1.0)],</pre><pre class="console">
    holes=[np.array([[-1.5, -0.5], [-1.5, 0.5],</pre><pre class="console">
    [-2.5, 0.5], [-2.5, -0.5]])]</pre><pre class="console">
)</pre></li>
				<li>Now, we should plot the figure so that we can understand the region that we will be <span class="No-Break">working within:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
plt_poly = mpl.patches.Polygon(polygon.exterior.coords,</pre><pre class="console">
    ec=(0,0,0,1), fc=(0.5,0.5,0.5,0.4), zorder=0)</pre><pre class="console">
ax.add_patch(plt_poly)</pre><pre class="console">
plt_hole = mpl.patches.Polygon(</pre><pre class="console">
    polygon.interiors[0].coords, ec="k", fc="w")</pre><pre class="console">
ax.add_patch(plt_hole)</pre><pre class="console">
ax.set(xlim=(-4.05, 2.05), ylim=(-2.05, 1.55))</pre><pre class="console">
ax.set_axis_off()</pre></li>
			</ol>
			<p>This polygon can be seen in<a id="_idIndexMarker912"/> the following image. As we can see, the figure has a <em class="italic">hole</em> in it that must be <span class="No-Break">carefully considered:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer956">
					<img alt="Figure 8.5 – Sample polygon but with a hole&#13;&#10;" src="image/B19085_08_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Sample polygon but with a hole</p>
			<ol>
				<li value="3">We use the <strong class="source-inline">triangulate</strong> routine to generate a triangulation of the polygon. This triangulation includes external edges, which is something we don’t want in <span class="No-Break">this recipe:</span><pre class="console">
triangles = triangulate(polygon)</pre></li>
				<li>To remove the triangles that lie outside the original polygon, we need to use the built-in <strong class="source-inline">filter</strong> routine, along with the <strong class="source-inline">contains</strong> method (seen earlier in <span class="No-Break">this chapter):</span><pre class="console">
filtered = filter(lambda p: polygon.contains(p),</pre><pre class="console">
    triangles)</pre></li>
				<li>To plot the triangles on<a id="_idIndexMarker913"/> top of the original polygon, we need to convert the Shapely triangles into Matplotlib <strong class="source-inline">Patch</strong> objects, which we store in <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">PatchCollection</strong></span><span class="No-Break">:</span><pre class="console">
patches = map(lambda p: mpl.patches.Polygon(</pre><pre class="console">
    p.exterior.coords), filtered)</pre><pre class="console">
col = mpl.collections.PatchCollection(</pre><pre class="console">
    patches, fc="none", ec="k")</pre></li>
				<li>Finally, we add the collection of triangular patches to the figure we <span class="No-Break">created earlier:</span><pre class="console">
ax.add_collection(col)</pre></li>
			</ol>
			<p>The triangulation that’s been plotted on top of the original polygon can be seen in the following figure. Here, we can see that every vertex has been connected to two others to form a system of triangles that covers the entire <span class="No-Break">original polygon:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer957">
					<img alt="Figure 8.6 – Triangulation of a sample polygon with a hole&#13;&#10;" src="image/B19085_08_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Triangulation of a sample polygon with a hole</p>
			<p>The internal lines between the vertices of the original polygon in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em> divide the polygon into <span class="No-Break">15 triangles.</span></p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor347"/>How it works...</h2>
			<p>The <strong class="source-inline">triangulate</strong> routine uses a technique <a id="_idIndexMarker914"/>called <strong class="bold">Delaunay triangulation</strong> to connect a collection of points to a system of triangles. In this case, the collection of points is the vertices of the polygon. The Delaunay method finds these triangles in such a way that none of the points are contained within the circumcircle of any of the triangles. This is a technical condition of the method, but it means that the triangles are chosen efficiently, in the sense that it avoids very long, thin triangles. The resulting triangulation makes use of the edges that are present in the original polygon and also connects some of the <span class="No-Break">external edges.</span></p>
			<p>In order to remove the<a id="_idIndexMarker915"/> triangles that lie outside of the original polygon, we use the built-in <strong class="source-inline">filter</strong> routine, which creates a new iterable by removing the items that the criterion function falls under. This is used in conjunction with the <strong class="source-inline">contains</strong> method on Shapely <strong class="source-inline">Polygon</strong> objects to determine whether each triangle lies within the original figure. As we mentioned previously, we need to convert these Shapely items into Matplotlib patches before they can be added to <span class="No-Break">the plot.</span></p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor348"/>There’s more...</h2>
			<p>Triangulations<a id="_idIndexMarker916"/> are usually used to reduce a complex geometric figure into a collection of triangles, which are much simpler for computational tasks. However, they do have other uses. One particularly interesting application of triangulations is to solve <a id="_idIndexMarker917"/>the <em class="italic">art gallery problem</em>. This problem concerns finding the maximum number of guards that are necessary to <em class="italic">guard</em> an art gallery of a particular shape. Triangulations are an essential part of Fisk’s simple proof of the art gallery theorem, which was originally proved <span class="No-Break">by Chvátal.</span></p>
			<p>Suppose that the polygon from this recipe is the floor plan for an art gallery and that some guards need to be placed on the vertices. A small amount of work will show that you’ll need three guards to be placed at the polygon’s vertices for the whole museum to be covered. In the following image, we have plotted one <span class="No-Break">possible arrangement:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer958">
					<img alt="Figure 8.7 – One possible solution to the art gallery problem where guards are placed on vertices&#13;&#10;" src="image/B19085_08_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – One possible solution to the art gallery problem where guards are placed on vertices</p>
			<p>In <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.7</em> here, the guards are indicated by the <strong class="bold">X</strong> symbols and their corresponding fields of vision are shaded. Here, you can see that the whole polygon is covered by at least one color. The solution to the art gallery problem – which is a variation of the original problem – tells us that we need, at most, <span class="No-Break">four guards.</span></p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor349"/>See also</h2>
			<p>More information about the art gallery problem can be found in the classic book by O’Rourke: O’Rourke, J. (1987). <em class="italic">Art gallery theorems and algorithms</em>. New York: Oxford <span class="No-Break">University Press.</span></p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor350"/>Computing convex hulls</h1>
			<p>A geometric figure is said to be <em class="italic">convex</em> if <a id="_idIndexMarker918"/>every pair of points within the figure can be joined using a straight line that is also contained within the figure. Simple examples of convex bodies include points, straight lines, squares, circles (disks), regular polygons, and so on. The geometric figure shown in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.5</em> is not convex since the points on the opposite sides of the hole cannot be connected by a straight line that remains inside <span class="No-Break">the figure.</span></p>
			<p>Convex figures are simple from a certain perspective, which means they are useful in a variety of applications. One problem involves finding the smallest convex set that contains a collection of points. This smallest convex set<a id="_idIndexMarker919"/> is called the <em class="italic">convex hull</em> of the set <span class="No-Break">of points.</span></p>
			<p>In this recipe, we’ll learn how to find the convex hull of a set of points using the <span class="No-Break">Shapely package.</span></p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor351"/>Getting ready</h2>
			<p>For this recipe, we <a id="_idIndexMarker920"/>will need the NumPy package imported as <strong class="source-inline">np</strong>, the Matplotlib package imported as <strong class="source-inline">mpl</strong>, and the <strong class="source-inline">pyplot</strong> module imported <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">plt</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt</pre>
			<p>We will also need a default random number generator from NumPy. We can import this <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from numpy.random import default_rng
rng = default_rng(12345)</pre>
			<p>Finally, we will need to import the <strong class="source-inline">MultiPoint</strong> class <span class="No-Break">from Shapely:</span></p>
			<pre class="source-code">
from shapely.geometry import MultiPoint</pre>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor352"/>How to do it...</h2>
			<p>Follow these steps to find the convex hull of a collection of randomly <span class="No-Break">generated points:</span></p>
			<ol>
				<li value="1">First, we generate a two-dimensional array of <span class="No-Break">random numbers:</span><pre class="console">
raw_points = rng.uniform(-1.0, 1.0, size=(50, 2))</pre></li>
				<li>Next, we create a new figure and plot these raw sample points on <span class="No-Break">this figure:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
ax.plot(raw_points[:, 0], raw_points[:, 1], "kx")</pre><pre class="console">
ax.set_axis_off()</pre></li>
			</ol>
			<p>These randomly generated points can be seen in the following figure. The points are roughly spread over a <span class="No-Break">square region:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer959">
					<img alt="Figure 8.8 – A collection of points on the plane&#13;&#10;" src="image/B19085_08_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – A collection of points on the plane</p>
			<ol>
				<li value="3">Next, we<a id="_idIndexMarker921"/> construct a <strong class="source-inline">MultiPoint</strong> object that collects all these points and put them into a <span class="No-Break">single object:</span><pre class="console">
points = MultiPoint(raw_points)</pre></li>
				<li>Now, we get the convex hull of this <strong class="source-inline">MultiPoint</strong> object using the <span class="No-Break"><strong class="source-inline">convex_hull</strong></span><span class="No-Break"> attribute:</span><pre class="console">
convex_hull = points.convex_hull</pre></li>
				<li>Then, we create a Matplotlib <strong class="source-inline">Polygon</strong> patch that can be plotted onto our figure to show the result of finding the <span class="No-Break">convex hull:</span><pre class="console">
patch = mpl.patches.Polygon(</pre><pre class="console">
    convex_hull.exterior.coords,</pre><pre class="console">
    ec=(0,0,0,1), fc=(0.5,0.5,0.5,0.4), lw=1.2)</pre></li>
				<li>Finally, we add the <strong class="source-inline">Polygon</strong> patch to the figure to show the <span class="No-Break">convex hull:</span><pre class="console">
ax.add_patch(patch)</pre></li>
			</ol>
			<p>The convex hull of the randomly generated points can be seen in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer960">
					<img alt="Figure 8.9 – The convex hull of a collection of points on the plane&#13;&#10;" src="image/B19085_08_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The convex hull of a collection of points on the plane</p>
			<p>The polygon shown in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.9</em> has vertices selected from the original points and all the other points lie within the <span class="No-Break">shaded region.</span></p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor353"/>How it works...</h2>
			<p>The Shapely package<a id="_idIndexMarker922"/> is a Python wrapper around the GEOS library for geometric analysis. The <strong class="source-inline">convex_hull</strong> attribute of Shapely geometric objects calls the convex hull computation<a id="_idIndexMarker923"/> routine from the GEOS library, resulting in a new Shapely object. From this recipe, we can see that the convex hull of the collection of points is a polygon with vertices at the points that are farthest away from <span class="No-Break">the </span><span class="No-Break"><em class="italic">center</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-355"><a id="_idTextAnchor354"/>Constructing Bezier curves</h1>
			<p><em class="italic">Bezier curves</em>, or <em class="italic">B-splines</em>, are<a id="_idIndexMarker924"/> a family of curves that are extremely useful in vector graphics – for instance, they are commonly used in high-quality font packages. This is because they are defined by a small number of points that can then be used to inexpensively calculate a large number of points along the curve. This allows detail to be scaled according to the needs of <span class="No-Break">the user.</span></p>
			<p>In this recipe, we’ll learn how to create a simple class representing a Bezier curve and compute a number of points <span class="No-Break">along it.</span></p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor355"/>Getting ready</h2>
			<p>In this recipe, we will <a id="_idIndexMarker925"/>use the NumPy package imported as <strong class="source-inline">np</strong>, the Matplotlib <strong class="source-inline">pyplot</strong> module imported as <strong class="source-inline">plt</strong>, and the <strong class="source-inline">comb</strong> routine from the Python Standard Library <strong class="source-inline">math</strong> module, imported under the <span class="No-Break"><strong class="source-inline">binom</strong></span><span class="No-Break"> alias:</span></p>
			<pre class="source-code">
from math import comb as binom
import matplotlib.pyplot as plt
import numpy as np</pre>
			<h2 id="_idParaDest-357"><a id="_idTextAnchor356"/>How to do it...</h2>
			<p>Follow these steps to define a class that represents a Bezier curve that can be used to compute points along <span class="No-Break">the curve:</span></p>
			<ol>
				<li value="1">The first step is to set up the basic class. We need to provide the control points (nodes) and some associated numbers to <span class="No-Break">instance attributes:</span><pre class="console">
class Bezier:</pre><pre class="console">
    def __init__(self, *points):</pre><pre class="console">
        self.points = points</pre><pre class="console">
        self.nodes = n = len(points) - 1</pre><pre class="console">
        self.degree = l = points[0].size</pre></li>
				<li>Still inside the <strong class="source-inline">__init__</strong> method, we generate the coefficients for the Bezier curve and store them in a list on an <span class="No-Break">instance attribute:</span><pre class="console">
self.coeffs = [binom(n, i)*p.reshape(</pre><pre class="console">
    (l, 1)) for i, p in enumerate(points)]</pre></li>
				<li>Next, we define a <strong class="source-inline">__call__</strong> method to make the class callable. We load the number of nodes from the instance into a local variable <span class="No-Break">for clarity:</span><pre class="console">
    def __call__(self, t):</pre><pre class="console">
        n = self.nodes</pre></li>
				<li>Next, we reshape the input array so that it contains a <span class="No-Break">single row:</span><pre class="console">
        t = t.reshape((1, t.size))</pre></li>
				<li>Now, we generate a list of arrays of values using each of the coefficients in the <strong class="source-inline">coeffs</strong> attribute for <span class="No-Break">the instance:</span><pre class="console">
        vals = [c @ (t**i)*(1-t)**(n-i) for i,</pre><pre class="console">
           c in enumerate(self.coeffs)]</pre></li>
			</ol>
			<p>Finally, we sum all the arrays that were constructed in <em class="italic">step 5</em> and return the <span class="No-Break">resulting array:</span></p>
			<pre class="console">
       return np.sum(vals, axis=0)</pre>
			<ol>
				<li value="6">Now, we will<a id="_idIndexMarker926"/> test our class using an example. We’ll define four control points for <span class="No-Break">this example:</span><pre class="console">
p1 = np.array([0.0, 0.0])</pre><pre class="console">
p2 = np.array([0.0, 1.0])</pre><pre class="console">
p3 = np.array([1.0, 1.0])</pre><pre class="console">
p4 = np.array([1.0, 3.0])</pre></li>
				<li>Next, we set up a new figure for plotting, and plot the control points with a dashed <span class="No-Break">connecting line:</span><pre class="console">
fig, ax = plt.subplots()</pre><pre class="console">
ax.plot([0.0, 0.0, 1.0, 1.0],</pre><pre class="console">
     [0.0, 1.0, 1.0, 3.0], "*--k")</pre><pre class="console">
ax.set(xlabel="x", ylabel="y",</pre><pre class="console">
    title="Bezier curve with 4 nodes, degree 3")</pre></li>
				<li>Then, we create a new instance of our <strong class="source-inline">Bezier</strong> class using the four points we defined in <span class="No-Break"><em class="italic">step 7</em></span><span class="No-Break">:</span><pre class="console">
b_curve = Bezier(p1, p2, p3, p4)</pre></li>
				<li>We can now create an array of equally spaced points between 0 and 1 using <strong class="source-inline">linspace</strong> and compute the points along the <span class="No-Break">Bezier curve:</span><pre class="console">
t = np.linspace(0, 1)</pre><pre class="console">
v = b_curve(t)</pre></li>
				<li>Finally, we plot this curve on top of the control points that we <span class="No-Break">plotted earlier:</span><pre class="console">
ax.plot(v[0,:], v[1, :], "k")</pre></li>
			</ol>
			<p>The Bezier curve that<a id="_idIndexMarker927"/> we’ve plotted can be seen in the following diagram. As you can see, the curve starts at the first point (<strong class="bold">0</strong>, <strong class="bold">0</strong>) and finishes at the final point (<span class="No-Break"><strong class="bold">1</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="bold">3</strong></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer961">
					<img alt="Figure 8.10 – Bezier curve of degree 3 constructed using four nodes&#13;&#10;" src="image/B19085_08_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Bezier curve of degree 3 constructed using four nodes</p>
			<p>The Bezier curve in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.10</em> is tangent to the vertical lines at the endpoints and smoothly connects these points. Notice that we only have to store the four control points in order to reconstruct this curve with arbitrary accuracy; this makes Bezier curves very efficient <span class="No-Break">to store.</span></p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor357"/>How it works...</h2>
			<p>A Bezier curve is <a id="_idIndexMarker928"/>described by a sequence of control points, from which we construct the curve recursively. A Bezier curve with one point is a constant curve that stays at that point. A Bezier curve with two control points is a line segment between those <span class="No-Break">two points:</span></p>
			<p><img alt="" src="image/Formula_08_008.png"/></p>
			<p>When we add a third control point, we take the line segment between the corresponding points on the Bezier curve of curves that are constructed with one less point. This means that we construct the Bezier curve with three control points using the <span class="No-Break">following formula:</span></p>
			<p><img alt="" src="image/Formula_08_009.png"/></p>
			<p>This construction can be seen in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer964">
					<img alt="Figure 8.11 – Construction of a quadratic Bezier curve using a recursive definition (the two linear Bezier curves are shown by the dashed lines)" src="image/B19085_08_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Construction of a quadratic Bezier curve using a recursive definition (the two linear Bezier curves are shown by the dashed lines)</p>
			<p>The construction continues in this manner to define the Bezier curve on any number of control points. Fortunately, we don’t need to work with this recursive definition in practice because we can flatten the formulae into a single formula for the curve, which is given by the <span class="No-Break">following formula:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer965">
					<img alt="" src="image/Formula_08_010.jpg"/>
				</div>
			</div>
			<p>Here, the <img alt="" src="image/Formula_08_011.png"/> elements are the control points, <img alt="" src="image/Formula_08_012.png"/> is a parameter, and each term involves the <span class="No-Break">binomial coefficient:</span></p>
			<p><img alt="" src="image/Formula_08_013.png"/></p>
			<p>Remember that the <img alt="" src="image/Formula_08_014.png"/> parameter is the quantity that is changing to generate the points of the curve. We can isolate the terms in the previous sum that involve <img alt="" src="image/Formula_08_015.png"/> and those that do not. This defines the coefficients that we defined in <em class="italic">step 2</em>, each of which is given by the following <span class="No-Break">code fragment:</span></p>
			<pre class="source-code">
binom(n, i)*p.reshape((l, 1))</pre>
			<p>We reshape each of the points, <strong class="source-inline">p</strong>, in this step to make sure it is arranged as a column vector. This means that each of the coefficients is a column vector (as a NumPy array) consisting of the control points scaled by the <span class="No-Break">binomial coefficients.</span></p>
			<p>Now, we need to <a id="_idIndexMarker929"/>specify how to evaluate the Bezier curve at various values of <img alt="" src="image/Formula_08_016.png"/>. This is where we make use of the high-performance array operations from the NumPy package. We reshaped our control points as column vectors when forming our coefficients. In <em class="italic">step 4</em>, we reshaped the input, <img alt="" src="image/Formula_08_017.png"/>, values to make a row vector. This means that we can use the matrix multiplication operator to multiply each coefficient by the corresponding (scalar) value, depending on the input, <img alt="" src="image/Formula_08_018.png"/>. This is what happens in <em class="italic">step 5</em>, inside the list comprehension. In the following line, we multiply the <img alt="" src="image/Formula_08_019.png"/> array by the <img alt="" src="image/Formula_08_020.png"/> array to obtain an <img alt="" src="image/Formula_08_021.png"/> <span class="No-Break">array:</span></p>
			<pre class="source-code">
c @ (t**i)*(1-t)**(n-i)</pre>
			<p>We get one of these for each coefficient. We can then use the <strong class="source-inline">np.sum</strong> routine to sum each of these <img alt="" src="image/Formula_08_022.png"/> arrays to get the values along the Bezier curve. In the example provided in this recipe, the top row of the output array contains the <img alt="" src="image/Formula_08_023.png"/> values of the curve and the bottom row contains the <img alt="" src="image/Formula_08_024.png"/> values of the curve. We have to be careful when specifying the <strong class="source-inline">axis=0</strong> keyword argument for the <strong class="source-inline">sum</strong> routine to make sure the sum takes over the list we created, and not the arrays that this <span class="No-Break">list contains.</span></p>
			<p>The class we defined is initialized using the control points for the Bezier curve, which are then used to generate the coefficients. The actual computation of the curve values is done using NumPy, so this implementation should have relatively good performance. Once a specific instance of this class has been created, it functions very much like a function, as you might<a id="_idIndexMarker930"/> expect. However, no type-checking is done here, so we can only call this <em class="italic">function</em> with a NumPy array as <span class="No-Break">an argument.</span></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor358"/>There’s more...</h2>
			<p>Bezier curves <a id="_idIndexMarker931"/>are defined using an iterative construction, where the curve with <img alt="" src="image/Formula_08_025.png"/> points is defined using the straight line connecting the curves defined by the first and last <img alt="" src="image/Formula_08_026.png"/> points. Keeping track of the coefficient of each of the control points using this construction will quickly lead you to the equation we used to define the preceding curve. This construction also leads to interesting – and useful – geometric properties of <span class="No-Break">Bezier curves.</span></p>
			<p>As we mentioned in the introduction to this recipe, Bezier curves appear in many applications that involve vector graphics, such as fonts. They also appear in many common vector graphics software packages. In these software packages, it is common to see <em class="italic">quadratic Bezier curves</em>, which <a id="_idIndexMarker932"/>are defined by a collection of three points. However, you can also define a quadratic Bezier curve by supplying the two endpoints, along with the gradient lines, at those points. This is more common in graphics software packages. The resulting Bezier curve will leave each of the endpoints along the gradient lines and connect the curve smoothly between <span class="No-Break">these points.</span></p>
			<p>The implementation we constructed here will have relatively good performance for small applications but will not be sufficient for applications involving rendering curves with a large number of control points at a large number of <img alt="" src="image/Formula_08_015.png"/> values. For this, it is best to use a low-level package written in a compiled language. For example, the <strong class="source-inline">bezier</strong> Python package uses a compiled Fortran backend for its computations and provides a much richer interface than the class we <span class="No-Break">defined here.</span></p>
			<p>Bezier curves<a id="_idIndexMarker933"/> can, of course, be extended to higher dimensions in a natural way. The result is a Bezier surface, which makes them very useful general-purpose tools for high-quality, <span class="No-Break">scalable graphics.</span></p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor359"/>Further reading</h1>
			<ul>
				<li>A description of some common algorithms from computation geometry can be found in the following book: Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P., 2007. <em class="italic">Numerical recipes: the art of scientific computing</em>. 3rd ed. Cambridge: Cambridge <span class="No-Break">University Press.</span></li>
				<li>For a more detailed account of some problems and techniques from computational geometry, check out the following book: O’Rourke, J., 1994. <em class="italic">Computational geometry in C</em>. Cambridge: Cambridge <span class="No-Break">University Press.</span></li>
			</ul>
		</div>
	</body></html>