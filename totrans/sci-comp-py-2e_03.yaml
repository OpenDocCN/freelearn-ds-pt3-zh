- en: Container Types
  prefs: []
  type: TYPE_NORMAL
- en: 'Container types are used to group objects together. The main difference between
    the different container types is the way individual elements are accessed and
    how operations are defined. In this chapter, we discuss container types such as lists,
    tuples, dictionaries, and sets and related concepts such as indexing techniques.
    More specialized containers such as pandas DataFrames will be presented in [Chapter
    4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *L**inear Algebra – Arrays*, [Chapter
    5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Advanced Array Concepts*, and [Chapter
    10](6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml): *Series and DataFrames.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.1 Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we introduce lists – the most frequently used container datatype
    in Python. With lists, we can refer to several, even totally different, Python
    objects together.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list is, as the name hints, a list of objects of any kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first list in this example contains a string, a float, and an integer object.
    The second list in this example, `M`, contains another list as its second item.
  prefs: []
  type: TYPE_NORMAL
- en: The individual objects are enumerated by assigning each element an index. The
    first element in the list gets index ![](img/24755493-7391-4f8c-ae55-d7059940bc62.png).
    This *zero-based indexing* is frequently used in mathematical notation. Consider
    as an example for zero-based indexing the usual indexing of coefficients of a
    polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index allows us to access the following objects from the two lists defined
    in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The bracket notation here corresponds to the use of subscripts in mathematical
    formulas. `L` is a simple list, while `M` itself contains a list so that you need
    two indexes to access an element of the inner list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list containing subsequent integers can easily be generated by the command `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A more general use is to provide this command with start, stop, and step parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `len` returns the length of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 3.1.1 Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like cutting a slice from a loaf of bread, lists can be cut into slices. Slicing
    a list between `i` and `j` creates a new list containing the elements starting
    at index `i` and ending just before `j`.
  prefs: []
  type: TYPE_NORMAL
- en: For slicing, a range of indexes has to be given. `L[i:j]` means create a list
    by taking all elements from `L` starting at `L[i]` until `L[j-1]`. In other words,
    the new list is obtained by removing the first `i` elements from `L` and taking
    the next `j-i` elements ![](img/8c30c1ca-2375-4303-ae1a-4ce9475c5eba.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `L[i:]` means remove the ![](img/21174276-5eae-46d9-a4fd-c9a015c1b95e.png) first
    elements and `L[:i]` means take only the first ![](img/097a8bc0-54d3-4cd5-a899-9b12859a5e0e.png)elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You may omit the first or last bound of the slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Python allows the use of negative indexes for counting from the right. In particular,
    the element `L[-1]` is the last element in the list `L`. Similarly, `L[:-i]` means
    remove the last ***i*** elements, and `L[-i:]` means take only the last ***i*** elements.
    This may be combined in `L[i:-j]` to remove the first ***i*** and the last ***j*** elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting one index in the range corresponds to half-open intervals in ℝ. The
    half-open interval (∞, *a*) means take all numbers strictly lower than *a*; this
    is similar to the syntax `L[:j] `; see *Figure 3.1* for more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a6c8df0-b30b-4234-bcfb-034a2469b627.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Some typical slicing situations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you never get index errors with *out-of-bound slices*. Possibly,
    you may obtain empty lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful when using variables in indexing that may become negative, since
    it changes the slice completely. This might lead to unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result is `3`, `0`, `1`, `3` while you expect `0`, `0`, `1`, `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sum up the use of slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`L[i:]` amounts to taking all elements except the first *i* ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L[:i]` amounts to taking the first *i* elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L[-i:]` amounts to taking the last *i* elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L[:-i]` amounts to taking all elements except the last *i* ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strides
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When computing slices, you may also specify a stride, which is the length of
    the step from one index to the other. The default stride is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the stride may also be negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to create a new list that is reversed, using a negative
    stride:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you might want to use the method `reverse`, which is explained
    in [Section 3.1.4](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *List methods.*'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 Altering lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typical operations on lists are the insertion and deletion of elements and
    list concatenation. With the slicing notation, list insertion and deletion become
    obvious; deletion is just replacing a part of a list with an empty list `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Insertion means replacing an empty slice with the list to be inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Two lists are concatenated by the plus operator `+` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating a list `n` times with itself motivates the use of the multiplication
    operator `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no arithmetic operations on a list, such as elementwise summation
    or division. For such operations, we use arrays; see [Section 3.2](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml):
    A quick glance at the concept of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.3 Belonging to a list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may use the keywords `in` and `not in` to determine whether an element
    belongs to a list or not, which is similar to ![](img/240418bd-550d-4d6d-a5f3-501370f5490d.png) and ![](img/c905a7b8-fd14-4009-9804-7be9fe23cad1.png) in
    mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 3.1.4 List methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some useful methods of the `list` type are collected in the following *Table
    3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `list.append(x)` | Add `x` to the end of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.extend(L)` | Extend the list by the elements of the list `L`. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.insert(i,x)` | Insert `x` at position `i`. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.remove(x)` | Remove the first item from the list whose value is `x`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `list.sort()` | Sort the items of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.reverse()` | Reverse the elements of the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.pop()` | Remove the last element of the list. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: In-place methods of the datatype list'
  prefs: []
  type: TYPE_NORMAL
- en: These methods are in-place operations, that is, they change the list directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other methods, such as those given in *Table 3.2*, do not alter the list, but
    return some information or create a new list object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `list.count(x)` | Count how often `x` appears in the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `list.copy()` | Create a copy of the list. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Methods of the datatype list that return a new object'
  prefs: []
  type: TYPE_NORMAL
- en: In-place operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most methods that result in a list are in-place operations. These are operations
    that change a Python object directly without creating a new object of the same
    type. They can be best explained by looking at the following example, `reverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware of in-place operations. You might be tempted to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is correct Python. But in-place operations return the value `None` and
    alter the list. Therefore, using the variable `newL` as if it was a (sorted) list,
    for example, as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'causes an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we demonstrate in-place list operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`L` is altered. The method `count` is an example of a method that generates
    a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 3.1.5 Merging lists – zip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A particularly useful function for lists is `zip`. It can be used to merge
    two given lists into a new list by pairing the elements of the original lists.
    The result is a list of tuples (see [Section 3.3](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Tuples*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also demonstrates what happens if the lists have different lengths:
    the length of the zipped list is the shorter of the two input lists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `zip` creates a special iterable object that can be turned into
    a list by applying the function `list`, as in the preceding example. See [Section
    9.3](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Iterable objects *for more
    details on iterable objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.6 List comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A convenient way to build up lists is by using the list comprehension construct,
    possibly with a condition inside. The syntax of a list comprehension is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'or more generally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to have several `for` loops inside a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is of particular interest when dealing with arrays; see [Section 3.2](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *A
    quick glance at the concept of arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: 'List comprehension is closely related to the mathematical notation for sets.
    Compare [![](img/17ea4cf5-e5a8-43b6-ac07-2dd603f247c2.png)]and `L2 = [2*x for
    x in L]`. One big difference though is that lists are ordered while sets aren''t;
    see [Section 3.5](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Sets*.'
  prefs: []
  type: TYPE_NORMAL
- en: As we complete our understanding of lists, we'll now move on to the next section,
    where we will learn about arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 A quick glance at the concept of arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The NumPy package offers arrays, which are container structures for manipulating
    vectors, matrices, or even higher-order tensors in mathematics. In this section,
    we point out the similarities between arrays and lists. But arrays deserve a broader
    presentation, which will be given in [Chapter 4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Linear
    Algebra – Arrays*, and [Chapter 5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Advanced
    Array Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are constructed from lists by the function `array` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element of a vector, we need one index, while an element of a
    matrix is addressed by two indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, arrays are similar to lists, but be aware that they are different
    in a fundamental way, which can be explained by the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access to array data corresponds to that of lists, using square brackets and
    slices. But for arrays representing matrices, a double index is used. Lists assigned
    to a slice of an array can be used to alter the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of elements in a vector, or the number of rows of a matrix, is obtained
    by the function `len`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Arrays store only elements of the same numeric type (usually `float` or `complex` but
    also `int`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operations `+`, `*`, `/`, and `-` are all elementwise. The function `dot` and,
    in Python versions ≥ 3.5, the infix operator `@` are used for the scalar product
    and the corresponding matrix operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike lists, there is no `append` method for arrays. Nevertheless, there are
    special methods to construct arrays by stacking smaller size arrays; see [Section
    4.7](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Stacking*. A related point
    is that arrays are not as elastic as lists; you cannot use slices to change their
    length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vector slices are views, that is, they may be used to modify the original array;
    see [Section 5.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Array views and
    copies*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We gave you in this section a quick glance at the container type `array`. It
    is so central in scientific computing with Python that we will devote two entire
    chapters to it with many more aspects to be presented and discussed; see [Chapter
    4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Linear Algebra – Arrays*, and [Chapter
    5](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Advanced Array Concepts*.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tuple is an immutable list. Immutable means that it cannot be modified. A
    tuple is written as a comma-separated sequence of objects (a list without brackets).
    To increase readability, you often enclose a tuple in a pair of parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting parentheses can have side effects; see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The comma indicates that the object is a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Tuples are useful when a group of values goes together; for example, they are
    used to return multiple values from functions. See [Section 7.3](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Return
    values*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3.1 Packing and unpacking variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may assign several variables at once by unpacking a list or tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Use packing and unpacking to swap the contents of two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 3.4 Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists, tuples, and arrays are ordered sets of objects. Individual objects are
    inserted, accessed, and processed according to their place in the list. On the
    other hand, dictionaries are unordered sets of pairs. You access dictionary data
    by keys.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1 Creating and altering dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For example, we may create a dictionary containing the data of a rigid body
    in mechanics, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A key/data pair is indicated by a colon, `:`. These pairs are comma-separated
    and listed inside a pair of curly brackets, `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual elements are accessed by their keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'New objects are added to the dictionary by creating a new key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries are also used to provide parameters to a function (refer to Section 7.2: *Parameters
    and arguments* in [Chapter 7](1654fae9-6203-4871-8352-e436445fa49a.xhtml), *Functions*,
    for further information).
  prefs: []
  type: TYPE_NORMAL
- en: Keys in a dictionary can be, among others, strings, functions, tuples with immutable
    elements, and classes. Keys cannot be lists or arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command `dict` generates a dictionary from a list with key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `zip` function may come in handy in this context; see [Section 3.15](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml): *Merging
    lists – zip*.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2 Looping over dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are mainly three ways to loop over dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'or equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'By value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By item, that is, key/value pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Please consult [Section 14.4](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml): *Shelves* for
    a special dictionary object for file access.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last container object we introduce in this section is defined by the data
    type `set`.
  prefs: []
  type: TYPE_NORMAL
- en: Sets are containers that share properties and operations with sets in mathematics.
    A mathematical set is a collection of distinct objects. Like in mathematics, in
    Python the elements of a set are also listed within a pair of braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some mathematical set expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aad383dc-c771-4612-9a69-441947c90471.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here are their Python counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Sets contain an element only once, corresponding to the aforementioned definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, a set is unordered; that is, the order of the elements in the set
    is not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Sets in Python can contain all kinds of immutable objects, that is, numeric
    objects, strings, and Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are the methods `union` and `intersection` for the corresponding mathematical
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, sets can be compared using the methods `issubset` and `issuperset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: An empty set is defined in Python by `empty_set=set([])` and not by `{}`, which
    would define an empty dictionary!
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Container conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We summarize in the following *Table 3.3* the most important properties of
    the container types presented so far. (Arrays will be treated separately in [Chapter
    4](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml): *Linear Algebra – Arrays*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Access** | **Order** | **Duplicate Values** | **Mutability**
    |'
  prefs: []
  type: TYPE_TB
- en: '| List | By index | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Tuple | By index | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | By key | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Set | No | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: Container types'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous table, there is a difference in accessing container
    elements, and sets and dictionaries are not ordered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the different properties of the various container types, we frequently
    convert one type to another (see *Table 3.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Container Types** | **Syntax** |'
  prefs: []
  type: TYPE_TB
- en: '| List → Tuple | `tuple([1, 2, 3])` |'
  prefs: []
  type: TYPE_TB
- en: '| Tuple → List | `list((1, 2, 3))` |'
  prefs: []
  type: TYPE_TB
- en: '| List, Tuple → Set | `set([1, 2]), set((1, ))` |'
  prefs: []
  type: TYPE_TB
- en: '| Set → List | `list({1, 2 ,3})` |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary → List | `{''a'':4}.values()` |'
  prefs: []
  type: TYPE_TB
- en: '| List → Dictionary | - |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.4: Conversion rules for container types'
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw in this section how to convert container types. In [Chapter 2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml):
    *Variables and Basic Types*, we saw how to convert more elementary datatypes such
    as numbers. So, it is time now to consider how to actually check which datatype
    a variable has, which is the topic of the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.7 Checking the type of a variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The direct way to see the type of a variable is to use the command type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want to test for a variable to be of a certain type, you should
    use `isinstance` (instead of comparing the types with `type`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for using `isinstance` becomes apparent after having read about
    the concept of subclassing and inheritance in [Section 8.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Subclassing
    and inheritance*. In short, often different types share some common properties
    with some basic type. The classical example is the type `bool`, which is derived
    by subclassing from the more general type `int`. In this situation, we see how
    the command `isinstance` can be used in a more general way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in order to make sure that the variable `test` can be used as if it were an
    integer – the particular type may be irrelevant – you should check that it is
    an instance of `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Python is not a typed language. That means that objects are identified by what
    they can do rather than what they are. For instance, if you have a string manipulating
    function that acts on an object by using the `len` method, then your function
    will probably be useful for any objects implementing the `len` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have come across different datatypes: `float`, `int`, `bool`, `complex`,
    `list`, `tuple`, `module`, `function`, `str`, `dict`, and `array`.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with container types, mainly lists.
    It is important to know how to fill these containers and how to access and manage
    their content. We saw that there is access by position or by keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We will meet the important concept of slicing again in the next chapter on arrays.
    These are specially designed containers for mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Execute the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: What is the content of `L3`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to predict the outcome of the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: What does the following command do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Concatenate `L3` and `L4` to a new list `L5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 2:** Use the `range` command and a list comprehension to generate a list
    with 100 equidistantly spaced values between 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3:** Assume that the following signal is stored in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the outcome of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Do this exercise by inspection only, that is, without using your Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4:** Consider the Python statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: and assume that the variable `m` has been previously assigned an integer value.
    What is the value of `ans`? Answer this question without executing the statements
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5:** Consider the recursion formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11b74e07-fe97-4c9e-a0b6-1b384cff0015.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a list `u`. Store in its first three elements the three values ![](img/921ed357-eca6-4286-ace3-ea396515a5c5.png),
    and ![](img/232fc9b2-0542-4858-843d-d4e57c224f47.png). These represent the starting
    values ![](img/e5832afc-9afc-46ae-b065-53b9711fd5b9.png) and ![](img/0683b5d5-4b9d-4362-8a66-35245b0bc4a7.png)
    in the given formula. Build up the complete list from the recursion formula.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct a second list, `td`, in which you store the values *![](img/4256cd7e-e93c-49c4-9bc6-1404ee654be4.png)*,
    with ![](img/2c943450-f803-4e9c-b44d-66af7f791edd.png). Plot `td` versus `u` (see
    [Section 6.1](86c61820-e645-486c-9418-10079ffac7f8.xhtml): *Making plots*). Make
    a second plot in which you plot the difference, that is, ![](img/13138cdc-1cc2-4ce8-9f80-d82f7a7c630c.png),
    where ![](img/325d4dc1-fe3d-4d4c-907c-f8aa912e0b37.png)represents the values inside
    the vector `td`. Set axis labels and a title.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The recursion is a multistep formula to solve the differential equation ![](img/bddef92b-5e38-4de4-a136-f9b278e2e06a.png)
    with the initial value ![](img/75f4fafd-e7c9-405b-9cf0-a5263202aa3d.png).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](img/e544c41b-2a9b-49b5-b72f-c77590198308.png)] approximates [![](img/9b609804-6bf2-47e1-a952-85b804bab70c.png)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6:** Let ![](img/2f193357-daa9-41f6-a179-e4971501a234.png) and ![](img/b785da32-e046-4761-8745-9258b57b0bf8.png)
    be sets. The set ![](img/59f36140-6831-4e59-a86c-031dc8f9cb56.png) is called the
    symmetric difference of the two sets. Write a function that performs this operation.
    Compare your results to the result of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Ex. 7:** Verify in Python the statement that the empty set is a subset of
    any set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 8:** Study other operations on sets. You can find a complete list of
    those by using the command completion feature of `IPython`. In particular, study
    the `update` and `intersection_update` methods. What is the difference between `intersection` and `intersection_update`?'
  prefs: []
  type: TYPE_NORMAL
