<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Boolean Indexing</h1>
                </header>
            
            <article>
                
<p>Filtering data from a dataset is one of the most common and basic operations. There are numerous ways to filter (or subset) data in pandas with <strong>b</strong><strong>oolean indexing</strong>. Boolean indexing (also known as <strong>boolean selection</strong>) can be a confusing term, but for the purposes of pandas, it refers to selecting rows by providing a boolean value (<kbd>True</kbd> or <kbd>False</kbd>) for each row. These boolean values are usually stored in a Series or NumPy <kbd>ndarray</kbd> and are usually created by applying a boolean condition to one or more columns in a DataFrame. We begin by creating boolean Series and calculating statistics on them and then move on to creating more complex conditionals before using boolean indexing in a wide variety of ways to filter data.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Calculating boolean statistics</li>
<li>Constructing multiple boolean conditions</li>
<li>Filtering with boolean indexing</li>
<li>Replicating boolean indexing with index selection</li>
<li>Selecting with unique and sorted indexes</li>
<li>Gaining perspective on stock prices</li>
<li>Translating SQL WHERE clauses</li>
<li>Determining the normality of stock market returns</li>
<li>Improving readability of boolean indexing with the query method</li>
<li>Preserving Series with the<span> </span><kbd>where</kbd><span> </span>method</li>
<li>Masking DataFrame rows</li>
<li>Selecting with booleans, integer location, and labels</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating boolean statistics</h1>
                </header>
            
            <article>
                
<p>When first getting introduced to boolean Series, it can be informative to calculate basic summary statistics on them. Each value of a boolean series evaluates to 0 or 1 so all the Series methods that work with numerical values also work with booleans.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we create a boolean Series by applying a condition to a column of data and then calculate summary statistics from it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the <kbd>movie</kbd> dataset, set the index to the movie title, and inspect the first few rows:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie = pd.read_csv('data/movie.csv', index_col='movie_title')<br/>&gt;&gt;&gt; movie.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/db52f01e-a8cc-453c-8c12-16c0634faaba.png" style="width:57.75em;height:21.92em;"/></div>
<ol start="2">
<li>Determine whether the duration of each movie is longer than two hours by using the greater than comparison operator with the <kbd>duration</kbd> Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_2_hours = movie['duration'] &gt; 120<br/>&gt;&gt;&gt; movie_2_hours.head(10)<br/>movie_title
Avatar                                         True
Pirates of the Caribbean: At World's End       True
Spectre                                        True
The Dark Knight Rises                          True
Star Wars: Episode VII - The Force Awakens    False
John Carter                                    True
Spider-Man 3                                   True
Tangled                                       False
Avengers: Age of Ultron                        True
Harry Potter and the Half-Blood Prince         True
Name: duration, dtype: bool</pre>
<ol start="3">
<li>We can now use this Series to determine the number of movies that are longer than two hours:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_2_hours.sum()<br/>1039</pre>
<ol start="4">
<li>To find the percentage of movies in the dataset longer than two hours, use the <kbd>mean</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_2_hours.mean()<br/>0.2114</pre>
<ol start="5">
<li>Unfortunately, the output from step 4 is misleading. The <kbd>duration</kbd> column has a few missing values. If you look back at the DataFrame output from step 1, you will see that the last row is missing a value for <kbd>duration</kbd>. The boolean condition in step 2 returns <kbd>False</kbd> for this. We need to drop the missing values first, then evaluate the condition and take the mean:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie['duration'].dropna().gt(120).mean()<br/>.2112</pre>
<ol start="6">
<li>Use the <kbd>describe</kbd> method to output a few summary statistics on the boolean Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_2_hours.describe()<br/>count      4916
unique        2
top       False
freq       3877
Name: duration, dtype: object</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Most DataFrames will not have columns of booleans like our movie dataset. The most straightforward method to produce a boolean Series is to apply a condition to one of the columns using one of the comparison operators. In step 2, we use the greater than operator to test whether or not the duration of each movie was more than two hours (120 minutes). Steps 3 and 4 calculate two important quantities from a boolean Series, its sum and mean. These methods are possible as Python evaluates <kbd>False</kbd>/<kbd>True</kbd> as 0/1.</p>
<p>You can prove to yourself that the mean of a boolean Series represents the percentage of <kbd>True</kbd> values. To do this, use the <kbd>value_counts</kbd> method to count with the <kbd>normalize</kbd> parameter set to <kbd>True</kbd> to get its distribution:</p>
<pre>&gt;&gt;&gt; movie_2_hours.value_counts(normalize=True)<br/>False    0.788649<br/>True     0.211351
Name: duration, dtype: float64</pre>
<p>Step 5 alerts us to the incorrect result from step 4. Even though the <kbd>duration</kbd> column had missing values, the boolean condition evaluated all these comparisons against missing values as <kbd>False</kbd>. Dropping these missing values allows us to calculate the correct statistic. This is done in one step through method chaining.</p>
<p>Step 6 shows that pandas treats boolean columns similarly to how it treats object data types by displaying frequency information. This is a natural way to think about boolean Series, rather than display quantiles like it does with numeric data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is possible to compare two columns from the same DataFrame to produce a boolean Series. For instance, we could determine the percentage of movies that have actor 1 with more Facebook likes than actor 2. To do this, we would select both of these columns and then drop any of the rows that had missing values for either movie. Then we would make the comparison and calculate the mean:</p>
<pre>&gt;&gt;&gt; actors = movie[['actor_1_facebook_likes', <br/>                    'actor_2_facebook_likes']].dropna()<br/>&gt;&gt;&gt; (actors['actor_1_facebook_likes'] &gt; <br/>     actors['actor_2_facebook_likes']).mean()<br/>.978</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constructing multiple boolean conditions</h1>
                </header>
            
            <article>
                
<p>In Python, boolean expressions use the built-in logical operators <kbd>and</kbd>, <kbd>or</kbd>, and <kbd>not</kbd>. These keywords do not work with boolean indexing in pandas and are respectively replaced with <kbd>&amp;</kbd>, <kbd>|</kbd>, and <kbd>~</kbd>. Additionally, each expression must be wrapped in parentheses or an error will be raised.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Constructing a precise filter for your dataset might have you combining multiple boolean expressions together to extract an exact subset. In this recipe, we construct multiple boolean expressions before combining them together to find all the movies that have an <kbd>imdb_score</kbd> greater than 8, a <kbd>content_rating</kbd> of PG-13, and a <kbd>title_year</kbd> either before 2000 or after 2009.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Load in the movie dataset and set the index as the title:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie = pd.read_csv('data/movie.csv', index_col='movie_title')</pre>
<ol start="2">
<li>Create a variable to hold each set of criteria independently as a boolean Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; criteria1 = movie.imdb_score &gt; 8<br/>&gt;&gt;&gt; criteria2 = movie.content_rating == 'PG-13'<br/>&gt;&gt;&gt; criteria3 = ((movie.title_year &lt; 2000) | <br/>                 (movie.title_year &gt; 2009))<br/><br/>&gt;&gt;&gt; criteria2.head()     # all criteria Series look similar<br/>movie_title
Avatar                                         True
Pirates of the Caribbean: At World's End       True
Spectre                                        True
The Dark Knight Rises                          True
Star Wars: Episode VII - The Force Awakens    False
Name: content_rating, dtype: bool</pre>
<ol start="3">
<li>Combine all the criteria together into a single boolean Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; criteria_final = criteria1 &amp; criteria2 &amp; criteria3<br/>&gt;&gt;&gt; criteria_final.head()<br/>movie_title
Avatar                                        False
Pirates of the Caribbean: At World's End      False
Spectre                                       False
The Dark Knight Rises                          True
Star Wars: Episode VII - The Force Awakens    False
dtype: bool</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>All values in a Series can be compared against a scalar value using the standard comparison operators( <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>==</kbd>, <kbd>!=</kbd>, <kbd>&lt;=</kbd>, <kbd>&gt;=</kbd>). The expression <kbd>movie.imdb_score &gt; 8</kbd> yields a Series of booleans where all <kbd>imdb_score</kbd> values prices exceeding 8 are <kbd>True</kbd> and those less than or equal to 8 are <kbd>False</kbd>. The index of this boolean Series retains the same index as the original and in this case, is the title of the movie.</p>
<p>The <kbd>criteria3</kbd> <span>variable</span> is created by two independent boolean expressions. Each expression must be enclosed in parentheses to function properly. The pipe character, <kbd>|</kbd>, is used to create a logical <kbd>or</kbd> condition between each of the values in both Series.</p>
<p>All three criteria need to be <kbd>True</kbd> to match the requirements of the recipe. They are each combined together with the ampersand character, <kbd>&amp;</kbd>, which creates a logical <kbd>and</kbd> condition between each Series value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>A consequence of pandas using different syntax for the logical operators is that operator precedence is no longer the same. The comparison operators have a higher precedence than <kbd>and</kbd>, <kbd>or</kbd>, and <kbd>not</kbd>. However, the new operators for pandas (the bitwise operators <kbd>&amp;</kbd>, <kbd>|</kbd>, and <kbd>~</kbd>) have a higher precedence than the comparison operators, thus the need for parentheses. An example can help clear this up. Take the following expression:</p>
<pre>&gt;&gt;&gt; 5 &lt; 10 and 3 &gt; 4<br/>False </pre>
<p>In the preceding expression, <kbd>5 &lt; 10</kbd> evaluates first, followed by <kbd>3 &lt; 4</kbd>, and finally, the <kbd>and</kbd> evaluates. Python progresses through the expression as follows:</p>
<pre>&gt;&gt;&gt; 5 &lt; 10 and 3 &gt; 4<br/>&gt;&gt;&gt; True and 3 &gt; 4<br/>&gt;&gt;&gt; True and False<br/>&gt;&gt;&gt; False</pre>
<p>Let's take a look at what would happen if the expression in <kbd>criteria3</kbd> was written as follows:</p>
<pre>&gt;&gt;&gt; movie.title_year &lt; 2000 | movie.title_year &gt; 2009<br/><span class="ansi-red-fg">TypeError</span>: cannot compare a dtyped [float64] array with a scalar of type [bool]</pre>
<p>As the bitwise operators have higher precedence than the comparison operators, <kbd>2000 | movie.title_year</kbd> is evaluated first, which is nonsensical and raises an error. Therefore, parentheses are needed to have the operations evaluated in the correct order.</p>
<p>Why can't pandas use <kbd>and</kbd>, <kbd>or</kbd>, and <kbd>not</kbd>? When these keywords are evaluated, Python attempts to find the <strong>truthiness</strong> of the objects as a whole. As it does not make sense for a Series as a whole to be either True or False--only each element--pandas raises an error.</p>
<div class="packt_infobox">Many objects in Python have boolean representation. For instance, all integers except 0 are considered <kbd>True</kbd>. All strings except the empty string are <kbd>True</kbd>. All non-empty sets, tuples, dictionaries, and lists are <kbd>True</kbd>. An empty DataFrame or Series does not evaluate as True or False and instead an error is raised. In general, to retrieve the truthiness of a Python object, pass it to the <kbd>bool</kbd> function.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Python operator precedence (<a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" target="_blank">http://bit.ly/2vxuqSn</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering with boolean indexing</h1>
                </header>
            
            <article>
                
<p>Boolean selection for Series and DataFrame objects is virtually identical. Both work by passing a Series of booleans indexed identically to the object being filtered to the indexing operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe constructs two complex and independent boolean criteria for different sets of movies. The first set of movies comes from the previous recipe and consists of those with an <kbd>imdb_score</kbd> greater than 8, a <kbd>content_rating</kbd> of PG-13, and a <kbd>title_year</kbd> either before 2000 or after 2009. The second set of movies consists of those with <kbd>imdb_score</kbd> less than 5, a <kbd>content_rating</kbd> of R, and a <kbd>title_year</kbd> between 2000 and 2010.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the <kbd>movie</kbd> dataset, set the index to the <kbd>movie_title</kbd>, and create the first set of criteria:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie = pd.read_csv('data/movie.csv', index_col='movie_title')<br/>&gt;&gt;&gt; crit_a1 = movie.imdb_score &gt; 8<br/>&gt;&gt;&gt; crit_a2 = movie.content_rating == 'PG-13'<br/>&gt;&gt;&gt; crit_a3 = (movie.title_year &lt; 2000) | (movie.title_year &gt; 2009)<br/>&gt;&gt;&gt; final_crit_a = crit_a1 &amp; crit_a2 &amp; crit_a3</pre>
<ol start="2">
<li>Create criteria for the second set of movies:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; crit_b1 = movie.imdb_score &lt; 5<br/>&gt;&gt;&gt; crit_b2 = movie.content_rating == 'R'<br/>&gt;&gt;&gt; crit_b3 = ((movie.title_year &gt;= 2000) &amp; <br/>               (movie.title_year &lt;= 2010))<br/>&gt;&gt;&gt; final_crit_b = crit_b1 &amp; crit_b2 &amp; crit_b3</pre>
<ol start="3">
<li>Combine the two sets of criteria using the pandas <kbd>or</kbd> operator. This yields a boolean Series of all movies that are members of either set:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; final_crit_all = final_crit_a | final_crit_b<br/>&gt;&gt;&gt; final_crit_all.head()<br/>movie_title<br/>Avatar                                        False
Pirates of the Caribbean: At World's End      False
Spectre                                       False
The Dark Knight Rises                          True
Star Wars: Episode VII - The Force Awakens    False
dtype: bool</pre>
<ol start="4">
<li>Once you have your boolean Series, you simply pass it to the indexing operator to filter the data:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie[final_crit_all].head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/20f2408c-8036-4718-b24d-414396bf1b93.png" style="width:61.75em;height:19.92em;"/></div>
<ol start="5">
<li>We have successfully filtered the data and all the columns of the DataFrame. We can't easily perform a manual check to determine whether the filter worked correctly. Let's filter both rows and columns with the <kbd>.loc</kbd> indexer:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; cols = ['imdb_score', 'content_rating', 'title_year']<br/>&gt;&gt;&gt; movie_filtered = movie.loc[final_crit_all, cols]<br/>&gt;&gt;&gt; movie_filtered.head(10)</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/45dd3c6c-983d-48ac-a195-cf04a3d34701.png" style="width:25.83em;height:20.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In step 1 and step 2, each set of criteria is built from simpler boolean expressions. It is not necessary to create a different variable for each boolean expression as done here, but it does make it far easier to read and debug any logic mistakes. As we desire both sets of movies, step 3 uses the pandas logical <kbd>or</kbd> operator to combine them.</p>
<p>Step 4 shows the exact syntax of how boolean indexing works. You simply pass the Series of booleans created from step 3 directly to the indexing operator. Only the movies with <kbd>True</kbd> values from <kbd>final_crit_all</kbd> are selected.</p>
<p>Boolean indexing also works with the <kbd>.loc</kbd> indexer as seen in step 5 by simultaneously doing boolean indexing and individual column selection. This slimmed DataFrame is far easier to check <span>manually</span> whether the logic was implemented correctly.</p>
<div class="packt_infobox">Boolean indexing does not quite work with the <kbd>.iloc</kbd> indexing operator. If you pass in a boolean series to it, an exception will get raised. However, if you pass in a boolean ndarray it will the same as it does in this recipe with the other indexers.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>As was stated earlier, it is possible to use one long boolean expression in place of several other shorter ones. To replicate the <kbd>final_crit_a</kbd> <span>variable</span> from step 1 with one long line of code, we can do the following:</p>
<pre>&gt;&gt;&gt; final_crit_a2 = (movie.imdb_score &gt; 8) &amp; \<br/>                    (movie.content_rating == 'PG-13') &amp; \<br/>                    ((movie.title_year &lt; 2000) | <br/>                     (movie.title_year &gt; 2009))<br/>&gt;&gt;&gt; final_crit_a2.equals(final_crit_a)<br/>True</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation on <em>boolean indexing</em> (<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#boolean-indexing" target="_blank">http://bit.ly/2v1xK77</a>)</li>
<li>Checking the truth of a Python object (<a href="https://docs.python.org/3/library/stdtypes.html#truth" target="_blank">http://bit.ly/2vn8WXX</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replicating boolean indexing with index selection</h1>
                </header>
            
            <article>
                
<p>It is possible to replicate specific cases of boolean selection by taking advantage of the index. Selection through the index is more intuitive and makes for greater readability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we use the <kbd>college</kbd> dataset to select all institutions from a particular state with both boolean indexing and index selection and then compare each of their performance against one another.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the <kbd>college</kbd> dataset and use boolean indexing to select all institutions from the state of Texas (TX):</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv')<br/>&gt;&gt;&gt; college[college['STABBR'] == 'TX'].head()</pre>
<p class="CDPAlignLeft CDPAlign">Pandas official documentation on</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d5e22aa2-e86e-4927-afeb-4f898a718bdf.png" style="width:43.67em;height:15.50em;"/></div>
<ol start="2">
<li>To replicate this using index selection, we need to move the <kbd>STABBR</kbd> column into the index. We can then use label-based selection with the <kbd>.loc</kbd> indexer:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college2 = college.set_index('STABBR')<br/>&gt;&gt;&gt; college2.loc['TX'].head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/7500adf0-77c4-4a09-84bd-047e03cb3a84.png" style="width:43.67em;height:16.92em;"/></div>
<ol start="3">
<li>Let's compare the speed of both methods:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; %timeit college[college['STABBR'] == 'TX']<br/>1.43 ms ± 53.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/><br/>&gt;&gt;&gt; %timeit college2.loc['TX']<br/>526 µs ± 6.67 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</pre>
<ol start="4">
<li>Boolean indexing takes three times as long as index selection. As setting the index does not come for free, let's time that operation as well:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; %timeit college2 = college.set_index('STABBR')<br/>1.04 ms ± 5.37 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Step 1 creates a boolean Series by determining which rows of data have <kbd>STABBR</kbd> equal to <kbd>TX</kbd>. This Series is passed to the indexing operator, which subsets the data. This process may be replicated by moving that same column to the index and simply using basic label-based index selection with <kbd>.loc</kbd>. Selection via the index is much faster than boolean selection.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>This recipe only selects a single state. It is possible to select multiple states with both boolean and index selection. Let's select <strong>Texas</strong> (<strong>TX</strong>), <strong>California</strong> (<strong>CA</strong>), and <strong>New York</strong> (<strong>NY</strong>). With boolean selection, you can use the <kbd>isin</kbd> method but with indexing, just pass a list to <kbd>.loc</kbd>:</p>
<pre>&gt;&gt;&gt; states = ['TX', 'CA', 'NY']<br/>&gt;&gt;&gt; college[college['STABBR'].isin(states)]<br/>&gt;&gt;&gt; college2.loc[states]</pre>
<p>There is quite a bit more to the story than what this recipe explains. Pandas implements the index differently based on whether the index is unique or sorted. See the following recipe for more details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting with unique and sorted indexes</h1>
                </header>
            
            <article>
                
<p>Index selection performance drastically improves when the index is unique or sorted. The prior recipe used an unsorted index that contained duplicates, which makes for relatively slow selections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we use the <kbd>college</kbd> dataset to form unique or sorted indexes to increase the performance of index selection. We will continue to compare the performance to boolean indexing as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the college dataset, create a separate DataFrame with <kbd>STABBR</kbd> as the index, and check whether the index is sorted:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college = pd.read_csv('data/college.csv')<br/>&gt;&gt;&gt; college2 = college.set_index('STABBR')<br/>&gt;&gt;&gt; college2.index.is_monotonic<br/>False</pre>
<ol start="2">
<li>Sort the index from <kbd>college2</kbd> and store it as another object:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college3 = college2.sort_index()<br/>&gt;&gt;&gt; college3.index.is_monotonic<br/>True</pre>
<ol start="3">
<li>Time the selection of the state of Texas (TX) from all three DataFrames:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; %timeit college[college['STABBR'] == 'TX']<br/>1.43 ms ± 53.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/><br/>&gt;&gt;&gt; %timeit college2.loc['TX']<br/>526 µs ± 6.67 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/><br/>&gt;&gt;&gt; %timeit college3.loc['TX']<br/>183 µs ± 3.67 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</pre>
<ol start="4">
<li>The sorted index performs nearly an order of magnitude faster than boolean selection. Let's now turn towards unique indexes. For this, we use the institution name as the index:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college_unique = college.set_index('INSTNM')<br/>&gt;&gt;&gt; college_unique.index.is_unique<br/>True</pre>
<ol start="5">
<li>Let's select Stanford University with boolean indexing: </li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; college[college['INSTNM'] == 'Stanford University']</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/54c9850e-c00d-43fb-887c-ccbfdc6b81f1.png" style="width:68.50em;height:4.92em;"/></div>
<div>
<ol start="6">
<li>Let's select Stanford University with index selection:</li>
</ol>
</div>
<pre style="padding-left: 60px">&gt;&gt;&gt; college_unique.loc['Stanford University']<br/>CITY                  Stanford
STABBR                      CA
HBCU                         0<br/>...<br/>UG25ABV                 0.0401
MD_EARN_WNE_P10          86000
GRAD_DEBT_MDN_SUPP       12782
Name: Stanford University, dtype: object</pre>
<ol start="7">
<li>They both produce the same data, just with different objects. Let's time each approach:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; %timeit college[college['INSTNM'] == 'Stanford University']<br/>1.3 ms ± 56.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/><br/>&gt;&gt;&gt; %timeit college_unique.loc['Stanford University']<br/>157 µs ± 682 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When the index is not sorted and contains duplicates, as with <kbd>college2</kbd>, pandas will need to check every single value in the index in order to make the correct selection. When the index is sorted, as with <kbd>college3</kbd>, pandas takes advantage of an algorithm called <strong>binary search</strong> to greatly improve performance.</p>
<p>In the second half of the recipe, we use a unique column as the index. Pandas implements unique indexes with a hash table, which makes for even faster selection. Each index location can be looked up in nearly the same time regardless of its length.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Boolean selection gives much more flexibility than index selection as it is possible to condition on any number of columns. In this recipe, we used a single column as the index. It is possible to concatenate multiple columns together to form an index. For instance, in the following code, we set the index equal to the concatenation of the city and state columns:</p>
<pre>&gt;&gt;&gt; college.index = college['CITY'] + ', ' + college['STABBR']<br/>&gt;&gt;&gt; college = college.sort_index()<br/>&gt;&gt;&gt; college.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/7cbcb510-cb15-4633-9a23-6f3c6f53aa59.png" style="width:61.92em;height:18.33em;"/></div>
<p>From here, we can select all colleges from a particular city and state combination without boolean indexing. Let's select all colleges from <kbd>Miami, FL</kbd>:</p>
<pre>&gt;&gt;&gt; college.loc['Miami, FL'].head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/ee559ed9-bef7-426a-9337-2dc405de57c8.png" style="width:60.08em;height:23.00em;"/></div>
<p>We can compare the speed of this compound index selection with boolean indexing. There is more than an order of magnitude difference:</p>
<pre>&gt;&gt;&gt; %%timeit <br/>&gt;&gt;&gt; crit1 = college['CITY'] == 'Miami' <br/>&gt;&gt;&gt; crit2 = college['STABBR'] == 'FL'<br/>&gt;&gt;&gt; college[crit1 &amp; crit2]<br/>2.43 ms ± 80.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)<br/><br/>&gt;&gt;&gt; %timeit college.loc['Miami, FL']<br/>197 µs ± 8.69 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>The <em>Binary search algorithm</em> (<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank">http://bit.ly/2wbMq20</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gaining perspective on stock prices</h1>
                </header>
            
            <article>
                
<p>Investors who have purchased long stock positions would obviously like to sell stocks at or near their all-time highs. This, of course, is very difficult to do in practice, especially if a stock price has only spent a small portion of its history above a certain threshold. We can use boolean indexing to find all points in time that a stock has spent above or below a certain value. This exercise may help us gain perspective as to what a common range for some stock to be trading within.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we examine Schlumberger stock from the start of 2010 until mid-2017. We use boolean indexing to extract a Series of the lowest and highest ten percent of closing prices during this time period. We then plot all points and highlight those that are in the upper and lower ten percent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the Schlumberger stock data, put the <kbd>Date</kbd> column into the index, and convert it to a <kbd>DatetimeIndex</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; slb = pd.read_csv('data/slb_stock.csv', index_col='Date', <br/>                     parse_dates=['Date'])<br/>&gt;&gt;&gt; slb.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9c889d58-52eb-4eec-8b73-39db375c7b89.png" style="width:23.83em;height:13.67em;"/></div>
<ol start="2">
<li>Select the closing price as a Series and use the <kbd>describe</kbd> method to return summary statistics as a Series:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; slb_close = slb['Close']<br/>&gt;&gt;&gt; slb_summary = slb_close.describe(percentiles=[.1, .9])<br/>&gt;&gt;&gt; slb_summary<br/>count    1895.000000
mean       79.121905
std        11.767802
min        51.750000
10%        64.892000
50%        78.000000
90%        93.248000
max       117.950000
Name: Close, dtype: float64</pre>
<ol start="3">
<li>Using boolean selection, select all closing prices in the upper or lower tenth percentile:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; upper_10 = slb_summary.loc['90%']<br/>&gt;&gt;&gt; lower_10 = slb_summary.loc['10%']<br/>&gt;&gt;&gt; criteria = (slb_close &lt; lower_10) | (slb_close &gt; upper_10)<br/>&gt;&gt;&gt; slb_top_bottom_10 = slb_close[criteria]</pre>
<ol start="4">
<li>Plot the resulting filtered Series in light gray on top of all closing prices in black. Use the <kbd>matplotlib</kbd> library to draw horizontal lines at the tenth and ninetieth percentiles:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; slb_close.plot(color='black', figsize=(12,6))<br/>&gt;&gt;&gt; slb_top_bottom_10.plot(marker='o', style=' ',<br/>                           ms=4, color='lightgray')<br/><br/>&gt;&gt;&gt; xmin = criteria.index[0]<br/>&gt;&gt;&gt; xmax = criteria.index[-1]<br/>&gt;&gt;&gt; plt.hlines(y=[lower_10, upper_10], xmin=xmin,<br/>               xmax=xmax, color='black')</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/787b6fa6-65a8-4550-a293-05ed4e625cdc.png" style="width:40.83em;height:20.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The result of the <kbd>describe</kbd> method in step 2 is itself a Series with the identifying summary statistic as its index labels. This summary Series is used to store the tenth and ninetieth percentiles as their own variables. Step 3 uses boolean indexing to select only those values in the upper and lower tenth of the distribution.</p>
<p>Both Series and DataFrames have direct plotting capabilities through the <kbd>plot</kbd> method. This first call to the <kbd>plot</kbd> method comes from the <kbd>slb_close</kbd> Series, which contains all the SLB closing prices. This is the black line in the plot. The points from <kbd>slb_filtered</kbd> are plotted as gray markers directly on top of the closing prices. The <kbd>style</kbd> parameter is set to a single blank space so that no line is drawn. The <kbd>ms</kbd> parameter sets the marker size.</p>
<p>Matplotlib comes with a convenience function, <kbd>hlines</kbd>, that plots horizontal lines. It takes a list of <kbd>y</kbd> values and plots them from <kbd>xmin</kbd> to <kbd>xmax</kbd>.</p>
<p>Judging from our new perspective from the plots that we created, it's clear to see that although SLB's all-time high is close to $120 per share, only 10% of the trading days in the last seven years have been above $93 per share.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Instead of plotting red points (black points) over the closing prices to indicate the upper and lower tenth percentiles, we can use matplotlib's <kbd>fill_between</kbd> function. This function fills in all the areas between two lines. It takes an optional <kbd>where</kbd> parameter that accepts a boolean Series, alerting it to exactly which locations to fill in:</p>
<pre class="mce-root">&gt;&gt;&gt; slb_close.plot(color='black', figsize=(12,6))<br/>&gt;&gt;&gt; plt.hlines(y=[lower_10, upper_10], <br/>               xmin=xmin, xmax=xmax,color='lightgray')<br/>&gt;&gt;&gt; plt.fill_between(x=criteria.index, y1=lower_10,<br/>                     y2=slb_close.values, color='black')<br/>&gt;&gt;&gt; plt.fill_between(x=criteria.index,y1=lower_10,<br/>                     y2=slb_close.values, where=slb_close &lt; lower_10,<br/>                     color='lightgray')<br/>&gt;&gt;&gt; plt.fill_between(x=criteria.index, y1=upper_10, <br/>                     y2=slb_close.values, where=slb_close &gt; upper_10,<br/>                     color='lightgray')</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1b04de13-e7d7-4d60-ab2d-38b1afc0daef.png" style="width:49.75em;height:24.58em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Translating SQL WHERE clauses</h1>
                </header>
            
            <article>
                
<p>Many pandas users will have a background processing data directly from databases using the ubiquitous <strong>Structured Query Language</strong> (<strong>SQL</strong>). SQL is a standardized language to define, manipulate, and control data stored in a database. The <kbd>SELECT</kbd> statement is the most common way to use SQL to select, filter, aggregate, and order data. Pandas has the ability to connect to databases and send SQL statements to them.</p>
<div class="packt_tip packt_infobox">SQL is a very important language to know for data scientists. Much of the world's data is stored in databases that necessitate SQL to retrieve, manipulate, and perform analyses on. SQL syntax is fairly simple and easy to learn. There are many different SQL implementations from companies such as Oracle, Microsoft, IBM, and more. Although the syntax is not compatible between the different implementations, the core of it will look very much the same.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Within a SQL SELECT statement, the WHERE clause is very common and filters data. This recipe will write pandas code that is equivalent to a SQL query that selects a certain subset of the employee dataset.</p>
<div class="packt_tip">It is not necessary to understand any SQL syntax to make use of this recipe.</div>
<p>Suppose we are given a task to find all the female employees that work in the police or fire departments that have a base salary between 80 and 120 thousand dollars. The following SQL statement would answer this query for us:</p>
<pre>SELECT<br/>    UNIQUE_ID,<br/>    DEPARTMENT,<br/>    GENDER,<br/>    BASE_SALARY<br/>FROM<br/>    EMPLOYEE<br/>WHERE<br/>    DEPARTMENT IN ('Houston Police Department-HPD', <br/>                   'Houston Fire Department (HFD)') AND<br/>    GENDER = 'Female' AND <br/>    BASE_SALARY BETWEEN 80000 AND 120000;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the <kbd>employee</kbd> dataset as a DataFrame:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; employee = pd.read_csv('data/employee.csv')</pre>
<ol start="2">
<li>Before filtering out the data, it is helpful to do some manual inspection of each of the filtered columns to know the exact values that will be used in the filter:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; employee.DEPARTMENT.value_counts().head()<br/>Houston Police Department-HPD     638
Houston Fire Department (HFD)     384
Public Works &amp; Engineering-PWE    343
Health &amp; Human Services           110
Houston Airport System (HAS)      106
Name: DEPARTMENT, dtype: int64<br/><br/>&gt;&gt;&gt; employee.GENDER.value_counts()<br/> Male 1397<br/> Female 603<br/><br/>&gt;&gt;&gt; employee.BASE_SALARY.describe().astype(int)<br/>count      1886
mean      55767
std       21693
min       24960
25%       40170
50%       54461
75%       66614
max      275000
Name: BASE_SALARY, dtype: int64</pre>
<ol start="3">
<li>Write a single statement for each of the criteria. Use the <kbd>isin</kbd> method to test equality to one of many values:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; depts = ['Houston Police Department-HPD', <br/>             'Houston Fire Department (HFD)']<br/>&gt;&gt;&gt; criteria_dept = employee.DEPARTMENT.isin(depts)<br/>&gt;&gt;&gt; criteria_gender = employee.GENDER == 'Female'<br/>&gt;&gt;&gt; criteria_sal = (employee.BASE_SALARY &gt;= 80000) &amp; \<br/>                   (employee.BASE_SALARY &lt;= 120000)</pre>
<ol start="4">
<li>Combine all the boolean Series together:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; criteria_final = (criteria_dept &amp; <br/>                      criteria_gender &amp; <br/>                      criteria_sal)</pre>
<ol start="5">
<li>Use boolean indexing to select only the rows that meet the final criteria:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; select_columns = ['UNIQUE_ID', 'DEPARTMENT',<br/>                     'GENDER', 'BASE_SALARY']<br/>&gt;&gt;&gt; employee.loc[criteria_final, select_columns].head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/5cf310ad-c04c-4212-b5c5-03e9459468cf.png" style="width:35.00em;height:12.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before any filtering is actually done, you will obviously need to know the exact string names that will be used. The Series <kbd>value_counts</kbd> method is an excellent way to get both the exact string name and number of occurrences of that value.</p>
<p>The <kbd>isin</kbd> Series method is equivalent to the SQL <kbd>IN</kbd> operator and accepts a list of all possible values that you would like to keep. It is possible to use a series of <kbd>OR</kbd> conditions to replicate this expression but it would not be as efficient or idiomatic.</p>
<p>The criteria for salary, <kbd>criteria_sal</kbd>, is formed by combining two simple inequality expressions. All the criteria are finally combined together with the pandas <kbd>and</kbd> operator, <kbd>&amp;</kbd>, to yield a single boolean Series as the filter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>For many operations, pandas has multiple ways to do the same thing. In the preceding recipe, the criteria for salary uses two separate boolean expressions. Similarly to SQL, Series have a <kbd>between</kbd> method, with the salary criteria equivalently written as follows:</p>
<pre>&gt;&gt;&gt; criteria_sal = employee.BASE_SALARY.between(80000, 120000)</pre>
<p>Another useful application of <kbd>isin</kbd> is to provide a sequence of values automatically generated by some other pandas statements. This would avoid any manual investigating to find the exact string names to store in a list. Conversely, let's try to exclude the rows from the top five most frequently occurring departments:</p>
<pre>&gt;&gt;&gt; top_5_depts = employee.DEPARTMENT.value_counts().index[:5]<br/>&gt;&gt;&gt; criteria = ~employee.DEPARTMENT.isin(top_5_depts)<br/>&gt;&gt;&gt; employee[criteria]</pre>
<p>The SQL equivalent of this would be as follows:</p>
<pre>SELECT <br/>    * <br/>FROM <br/>    EMPLOYEE <br/>WHERE <br/>    DEPARTMENT not in <br/>    (<br/>      SELECT <br/>          DEPARTMENT <br/>     FROM (<br/>           SELECT<br/>               DEPARTMENT,<br/>               COUNT(1) as CT<br/>           FROM<br/>               EMPLOYEE<br/>           GROUP BY<br/>               DEPARTMENT<br/>           ORDER BY<br/>               CT DESC<br/>           LIMIT 5<br/>          )<br/>   );                          </pre>
<p>Notice the use of the pandas not operator, <kbd>~</kbd>, which negates all boolean values of a Series.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation of the <kbd>isin</kbd> (<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html" target="_blank">http://bit.ly/2v1GPfQ</a>) and <kbd>between</kbd> (<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.between.html" target="_blank">http://bit.ly/2wq9YPF</a>) Series methods</li>
<li>Refer to the <em>Connecting to SQL databases recipe</em> in <a href="40ba859e-6517-458e-8fd5-f3bcaf55a4fc.xhtml" target="_blank">Chapter 15</a>, <em>Combining Pandas Objects</em></li>
<li>A basic introduction to SQL from W3 schools (<a href="https://www.w3schools.com/sql/DEfaULT.asP" target="_blank">http://bit.ly/2hsq8Wp</a>)</li>
<li>The SQL IN operator (<a href="https://www.w3schools.com/sql/sql_in.asp" target="_blank">http://bit.ly/2v3H7Bg</a>)</li>
<li>The SQL BETWEEN operator (<a href="https://www.w3schools.com/sql/sql_between.asp" target="_blank">http://bit.ly/2vn5UTP</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Determining the normality of stock market returns</h1>
                </header>
            
            <article>
                
<p>In elementary statistics textbooks, the normal distribution is heavily relied upon to describe many different populations of data.  Although many random processes do appear to look like normal distributions most of the time, real-life tends to be more complex. Stock market returns are a prime example of a distribution that can look fairly normal but in actuality be quite far off.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe describes how to find daily stock market returns of the internet retail giant Amazon and informally test whether they follow a normal distribution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Load Amazon stock data and set the date as the index:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; amzn = pd.read_csv('data/amzn_stock.csv', index_col='Date',<br/>                      parse_dates=['Date'])<br/>&gt;&gt;&gt; amzn.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/32cbff6f-8e7f-45ec-b066-abff676c389b.png" style="width:20.92em;height:11.50em;"/></div>
<ol start="2">
<li>Create a Series by selecting only the closing price and then using the <kbd>pct_change</kbd> <span>method</span> to get the daily rate of return:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; amzn_daily_return = amzn.Close.pct_change()<br/>&gt;&gt;&gt; amzn_daily_return.head()<br/>Date
2010-01-04         NaN
2010-01-05    0.005900
2010-01-06   -0.018116
2010-01-07   -0.017013
2010-01-08    0.027077
Name: Close, dtype: float64</pre>
<ol start="3">
<li>Drop the missing value and plot a histogram of the returns to visually inspect the distribution:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; amzn_daily_return = amzn_daily_return.dropna()<br/>&gt;&gt;&gt; amzn_daily_return.hist(bins=20)</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d34eaba2-c6be-4b31-9f20-a1517c225a1e.png" style="width:23.75em;height:15.25em;"/></div>
<ol start="4">
<li>Normal distributions approximately follow the 68-95-99.7 rule--meaning that 68% of the data falls between 1 standard deviation of the mean, 95% between 2, and 99.7% between 3. We will now calculate the percentage of daily returns that fall between 1, 2, and 3 standard deviations from the mean. For this, we will need the mean and standard deviation:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; mean = amzn_daily_return.mean() <br/>&gt;&gt;&gt; std = amzn_daily_return.std()</pre>
<ol start="5">
<li>Calculate the absolute value of the <kbd>z-score</kbd> for each observation. The <kbd>z-score</kbd> is the number of standard deviations away from the mean:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; abs_z_score = amzn_daily_return.sub(mean).abs().div(std)</pre>
<ol start="6">
<li>Find the percentage of returns that are within 1, 2, and 3 standard deviations:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; pcts = [abs_z_score.lt(i).mean() for i in range(1,4)]<br/>&gt;&gt;&gt; print('{:.3f} fall within 1 standard deviation. '<br/>          '{:.3f} within 2 and {:.3f} within 3'.format(*pcts))<br/>0.787 fall within 1 standard deviation. 0.957 within 2 and 0.985 within 3</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By default, the <kbd>pct_change</kbd> Series method calculates the percentage change between the current element and the previous element. This transforms the raw stock closing prices into daily percentage returns. The first element of the returned Series is a missing value as there is no previous price.</p>
<p>Histograms are fantastic plots to summarize and visualize one-dimensional numeric data. It is clear from the plot that the distribution is symmetrical but it remains difficult to determine whether it is normal or not. There are formal statistical procedures to determine the normality of a distribution but we will simply find how close the data matches the 68-95-99.7 rule.</p>
<p>Step 5 calculates the number of standard deviations away from the mean for each observation which is referred to as the <kbd>z-score</kbd>. This step uses the methods and not the symbols (<kbd>-</kbd> and <kbd>/</kbd>) to do subtraction and division. The method for less than is also used in favor of the symbols in step 6.</p>
<p>It may seem odd that the mean is being taken in step 6. The result of the <kbd>abs_z_score.lt(1)</kbd> <span>expression</span> is a Series of booleans. As booleans evaluate to 0 or 1, taking the mean of this Series returns the percentage of elements that are <kbd>True</kbd>, which is what we desired.</p>
<p>We can now more easily determine the normality of the returns by comparing the resulting numbers (78.7-95.7-98.5) to the 68-95-99.7 rule. The percentages deviate greatly from the rule for 1 and 3 standard deviations, and we can conclude that Amazon daily stock returns do not follow a normal distribution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>To automate this process, we can write a function that accepts stock data in the and outputs the histogram of daily returns along with the percentages that fall within 1, 2, and 3 standard deviations from the mean. The following function does this and replaces the methods with their symbol counterparts:</p>
<pre>&gt;&gt;&gt; def test_return_normality(stock_data):<br/>        close = stock_data['Close']<br/>        daily_return = close.pct_change().dropna()<br/>        daily_return.hist(bins=20)<br/>        mean = daily_return.mean() <br/>        std = daily_return.std()<br/><br/>        abs_z_score = abs(daily_return - mean) / std <br/>        pcts = [abs_z_score.lt(i).mean() for i in range(1,4)]<br/> <br/>        print('{:.3f} fall within 1 standard deviation. '<br/>              '{:.3f} within 2 and {:.3f} within 3'.format(*pcts))<br/><br/></pre>
<p class="mce-root"/>
<pre>&gt;&gt;&gt; slb = pd.read_csv('data/slb_stock.csv', index_col='Date',<br/>                      parse_dates=['Date'])<br/>&gt;&gt;&gt; test_return_normality(slb)<br/>0.742 fall within 1 standard deviation. 0.946 within 2 and 0.986 within 3</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/9401919f-736c-480a-ba3a-d67a05852b7e.png" style="width:35.67em;height:21.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation of the <kbd>pct_change</kbd> Series method (<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.pct_change.html" target="_blank">http://bit.ly/2wcjmqT</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving readability of boolean indexing with the query method</h1>
                </header>
            
            <article>
                
<p>Boolean indexing is not necessarily the most pleasant syntax to read or write, especially when using a single line to write a complex filter. Pandas has an alternative string-based syntax through the DataFrame <kbd>query</kbd> method that can provide more clarity.</p>
<div class="packt_tip">The <kbd>query</kbd> DataFrame method is experimental and not as capable as boolean indexing and should not be used for production code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe replicates the earlier recipe in this chapter, <em>Translating SQL WHERE clauses,</em> but instead takes advantage of the <kbd>query</kbd> DataFrame method. The goal here is to filter the employee data for female employees from the police or fire departments that earn a salary between 80 and 120 thousand dollars.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the employee data, assign the chosen departments, and import columns to variables:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; employee = pd.read_csv('data/employee.csv')<br/>&gt;&gt;&gt; depts = ['Houston Police Department-HPD',<br/>             'Houston Fire Department (HFD)']<br/>&gt;&gt;&gt; select_columns = ['UNIQUE_ID', 'DEPARTMENT',<br/>                      'GENDER', 'BASE_SALARY']</pre>
<ol start="2">
<li>Build the query string and execute the method:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; qs = "DEPARTMENT in @depts " \<br/>         "and GENDER == 'Female' " \<br/>         "and 80000 &lt;= BASE_SALARY &lt;= 120000"<br/>        <br/>&gt;&gt;&gt; emp_filtered = employee.query(qs)<br/>&gt;&gt;&gt; emp_filtered[select_columns].head()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable CDPAlignCenter CDPAlign"><img class="image-border" src="assets/594a1364-103c-4ce5-be63-1f12a5cc7b17.png" style="width:23.50em;height:8.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Strings passed to the <kbd>query</kbd> method are going to look more like plain English than normal pandas code. It is possible to reference Python variables using the at symbol (<kbd>@</kbd>) as with <kbd>depts</kbd>. All DataFrame column names are available in the query namespace by simply referencing their name without inner quotes. If a string is needed, such as <kbd>Female</kbd>, inner quotes will need to wrap it.</p>
<p>Another nice feature of the <kbd>query</kbd> syntax is the ability to write a double inequality in a single expression and its ability to understand the verbose logical operators <kbd>and</kbd>, <kbd>or</kbd>, and <kbd>not</kbd> instead of their bitwise equivalents as with boolean indexing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Instead of manually typing in a list of department names, we could have programmatically created it. For instance, if we wanted to find all the female employees that were not a member of the top 10 departments by frequency, we can run the following code:</p>
<pre>&gt;&gt;&gt; top10_depts = employee.DEPARTMENT.value_counts() \<br/>                                     .index[:10].tolist()<br/>&gt;&gt;&gt; qs = "DEPARTMENT not in @top10_depts and GENDER == 'Female'"<br/>&gt;&gt;&gt; employee_filtered2 = employee.query(qs)<br/>&gt;&gt;&gt; employee_filtered2.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/04c5bb6f-52a6-44d6-9cc7-862e08c0bc15.png" style="width:20.83em;height:12.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation on the <kbd>query</kbd> method (<a href="http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-query" target="_blank">http://bit.ly/2vnlwXk</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preserving Series with the where method</h1>
                </header>
            
            <article>
                
<p>Boolean indexing necessarily filters your dataset by removing all the rows that don't match the criteria. Instead of dropping all these values, it is possible to keep them using the <kbd>where</kbd> method. The <kbd>where</kbd> method preserves the size of your Series or DataFrame and either sets the values that don't meet the criteria for missing or replaces them with something else.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we pass the <kbd>where</kbd> method boolean conditions to put a floor and ceiling on the minimum and maximum number of Facebook likes for actor 1 in the <kbd>movie</kbd> dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read the <kbd>movie</kbd> dataset, set the movie title as the index, and select all the values in the <kbd>actor_1_facebook_likes</kbd> column that are not missing:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie = pd.read_csv('data/movie.csv', index_col='movie_title')<br/>&gt;&gt;&gt; fb_likes = movie['actor_1_facebook_likes'].dropna()<br/>&gt;&gt;&gt; fb_likes.head()<br/>movie_title
Avatar                                         1000.0
Pirates of the Caribbean: At World's End      40000.0
Spectre                                       11000.0
The Dark Knight Rises                         27000.0
Star Wars: Episode VII - The Force Awakens      131.0
Name: actor_1_facebook_likes, dtype: float64</pre>
<ol start="2">
<li>Let's use the <kbd>describe</kbd> method to get a sense of the distribution:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; fb_likes.describe(percentiles=[.1, .25, .5, .75, .9]) \<br/>            .astype(int)<br/>count      4909
mean       6494
std       15106
min           0
10%         240
25%         607
50%         982
75%       11000
90%       18000
max      640000
Name: actor_1_facebook_likes, dtype: int64</pre>
<ol start="3">
<li>Additionally, we may plot a histogram of this Series to visually inspect the distribution:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; fb_likes.hist()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/18859e7b-eebe-49f7-aed5-c7511b01f94f.png" style="width:29.50em;height:18.75em;"/></div>
<ol start="4">
<li>This is quite a bad visualization and very difficult to get a sense of the distribution. On the other hand, the summary statistics from step 2 appear to be telling us that it is highly skewed to the right with many observations more than an order of magnitude greater than the median. Let's create criteria to test whether the number of likes is less than 20,000:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; criteria_high = fb_likes &lt; 20000<br/>&gt;&gt;&gt; criteria_high.mean().round(2)<br/>.91</pre>
<ol start="5">
<li>About 91% of the movies have an actor 1 with fewer than 20,000 likes. We will now use the <kbd>where</kbd> method, which accepts a boolean condition. The default behavior is to return a Series the same size as the original but which has all the <kbd>False</kbd> locations replaced with a missing value:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; fb_likes.where(criteria_high).head()<br/>movie_title
Avatar                                         1000.0
Pirates of the Caribbean: At World's End          NaN
Spectre                                       11000.0
The Dark Knight Rises                             NaN
Star Wars: Episode VII - The Force Awakens      131.0
Name: actor_1_facebook_likes, dtype: float64</pre>
<ol start="6">
<li>The second parameter to the <kbd>where</kbd> method, <kbd>other</kbd>, allows you to control the replacement value. Let's change all the missing values to 20,000:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; fb_likes.where(criteria_high, other=20000).head()<br/>movie_title
Avatar                                         1000.0
Pirates of the Caribbean: At World's End      20000.0
Spectre                                       11000.0
The Dark Knight Rises                         20000.0
Star Wars: Episode VII - The Force Awakens      131.0
Name: actor_1_facebook_likes, dtype: float64</pre>
<ol start="7">
<li>Similarly, we can create criteria to put a floor on the minimum number of likes. Here, we chain another <kbd>where</kbd> method and replace the values not meeting with the condition to <kbd>300</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; criteria_low = fb_likes &gt; 300<br/>&gt;&gt;&gt; fb_likes_cap = fb_likes.where(criteria_high, other=20000)\<br/>                           .where(criteria_low, 300)<br/>&gt;&gt;&gt; fb_likes_cap.head()<br/>movie_title
Avatar                                         1000.0
Pirates of the Caribbean: At World's End      20000.0
Spectre                                       11000.0
The Dark Knight Rises                         20000.0
Star Wars: Episode VII - The Force Awakens      300.0
Name: actor_1_facebook_likes, dtype: float64</pre>
<ol start="8">
<li>The length of the original Series and modified Series is the same:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; len(fb_likes), len(fb_likes_cap)<br/>(4909, 4909)</pre>
<ol start="9">
<li>Let's make a histogram with the modified Series. With the data in a much tighter range, it should produce a better plot:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; fb_likes_cap.hist()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/7322581b-6241-4bb8-a3b4-b24ea9bf7644.png" style="width:29.58em;height:19.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>where</kbd> method again preserves the size and shape of the calling object and does not modify the values where the passed boolean is <kbd>True</kbd>. It was important to drop the missing values in step 1 as the <kbd>where</kbd> method would have eventually replaced them with a valid number in future steps.</p>
<p>The summary statistics in step 2 give us some intuition where it would make sense to cap our data. The histogram from step 3, on the other hand, appears to clump all the data into one bin. The data has too many outliers for a plain histogram to make a good plot. The <kbd>where</kbd> method allows us to place a ceiling and floor on our data, which results in a histogram with many more visible bars.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Pandas actually has built-in methods <kbd>clip</kbd>, <kbd>clip_lower</kbd>, and <kbd>clip_upper</kbd> that replicate this operation. The <kbd>clip</kbd> method can set a floor and ceiling at the same time. We also check whether this alternate method produces the exact same Series, which it does:</p>
<pre>&gt;&gt;&gt; fb_likes_cap2 = fb_likes.clip(lower=300, upper=20000)<br/>&gt;&gt;&gt; fb_likes_cap2.equals(fb_likes_cap)<br/>True</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation on the <kbd>where</kbd> method (<a href="http://bit.ly/2vmW2cv">http://bit.ly/2vmW2cv</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Masking DataFrame rows</h1>
                </header>
            
            <article>
                
<p>The <kbd>mask</kbd> method performs the exact opposite operation that the <kbd>where</kbd> method does. By default, it creates missing values wherever the boolean condition is <kbd>True</kbd>. In essence, it is literally masking, or covering up, values in your dataset.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will mask all rows of the movie dataset that were made after 2010 and then filter all the rows with missing values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read the <kbd>movie</kbd> dataset, set the movie title as the index, and create the criteria:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie = pd.read_csv('data/movie.csv', index_col='movie_title')<br/>&gt;&gt;&gt; c1 = movie['title_year'] &gt;= 2010<br/>&gt;&gt;&gt; c2 = movie['title_year'].isnull()<br/>&gt;&gt;&gt; criteria = c1 | c2</pre>
<ol start="2">
<li>Use the <kbd>mask</kbd> method on a DataFrame to make all the values in rows with movies that were made from 2010 onward missing. Any movie that originally had a missing value for <kbd>title_year</kbd> is also masked:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie.mask(criteria).head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d7b0fdac-c4b2-4d31-9594-7c8d776fb964.png" style="width:60.75em;height:22.25em;"/></div>
<ol start="3">
<li>Notice how all the values in the third, fourth, and fifth rows from the preceding DataFrame are missing. Chain the <kbd>dropna</kbd> method to remove rows that have all values missing:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_mask = movie.mask(criteria).dropna(how='all')<br/>&gt;&gt;&gt; movie_mask.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d9027ba6-fe62-4ba4-971f-70bfc54f599b.png" style="width:59.75em;height:25.33em;"/></div>
<ol start="4">
<li>The operation in step 3 is just a complex way of doing basic boolean indexing. We can check whether the two methods produce the same DataFrame:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_boolean = movie[movie['title_year'] &lt; 2010]<br/>&gt;&gt;&gt; movie_mask.equals(movie_boolean)<br/>False</pre>
<ol start="5">
<li>The <kbd>equals</kbd> method is telling us that they aren't equal. Something is wrong. Let's do some sanity checking and see if they are the same shape:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_mask.shape == movie_boolean.shape<br/>True</pre>
<ol start="6">
<li>When we used the preceding <kbd>mask</kbd> method, it created many missing values. Missing values are <kbd>float</kbd> data types so any previous integer column is now a float. The <kbd>equals</kbd> method returns <kbd>False</kbd> if the data types of the columns are different, even if the values are the same. Let's check the equality of the data types to see whether this scenario happened:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_mask.dtypes == movie_boolean.dtypes<br/>color                         True
director_name                 True
num_critic_for_reviews        True
duration                      True
director_facebook_likes       True
actor_3_facebook_likes        True
actor_2_name                  True
actor_1_facebook_likes        True
gross                         True
genres                        True
actor_1_name                  True
num_voted_users              False
cast_total_facebook_likes    False
.....
dtype: bool</pre>
<ol start="7">
<li>It turns out that a couple of columns don't have the same data type. Pandas has an alternative for these situations. In its testing module, which is primarily used by developers, there is a function, <kbd>assert_frame_equal</kbd>, that allows you to check the equality of Series and DataFrames without also checking the equality of the data types:</li>
</ol>
<pre style="padding-left: 60px">from pandas.testing import assert_frame_equal<br/>&gt;&gt;&gt; assert_frame_equal(movie_boolean, movie_mask, check_dtype=False)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>By default, the <kbd>mask</kbd> method covers up data with missing values. The first parameter to the <kbd>mask</kbd> method is the condition which is often a boolean Series such as <kbd>criteria</kbd>. Because the <kbd>mask</kbd> method is called from a DataFrame, all the values in each row where the condition is <kbd>False</kbd> change to missing. Step 3 uses this masked DataFrame to drop the rows that contain all missing values. Step 4 shows how to do this same procedure with boolean indexing.</p>
<p>During a data analysis, it is very important to continually validate results. Checking the equality of Series and DataFrames is an extremely common approach to validation. Our first attempt, in step 4, yielded an unexpected result. Some basic sanity checking, such as ensuring that the number of rows and columns are the same or that the row and column names are the same, are good checks before going deeper.</p>
<p>Step 6 compares the two Series of data types together. It is here where we uncover the reason why the DataFrames were not equivalent. The <kbd>equals</kbd> method checks that both the values and data types are the same. The <kbd>assert_frame_equal</kbd> function from step 7 has many available parameters to test equality in a variety of ways. Notice that there is no output after calling <kbd>assert_frame_equal</kbd>. This method returns None when the two passed DataFrames are equal and raises an error when they are not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Let's compare the speed difference between masking and dropping missing rows and boolean indexing. Boolean indexing is about an order of magnitude faster in this case:</p>
<pre>&gt;&gt;&gt; %timeit movie.mask(criteria).dropna(how='all')<br/>11.2 ms ± 144 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)<br/><br/>&gt;&gt;&gt; %timeit movie[movie['title_year'] &lt; 2010]<br/>1.07 ms ± 34.9 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Pandas official documentation on <kbd>assert_frame_equal</kbd> (<a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.testing.assert_frame_equal.html" target="_blank">http://bit.ly/2u5H5Yl</a>)</li>
<li>Python official documentation of the <kbd>assert</kbd> statement (<a href="https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement" target="_blank">http://bit.ly/2v1YKmY</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting with booleans, integer location, and labels</h1>
                </header>
            
            <article>
                
<p><a href="3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml" target="_blank">Chapter 10</a>, <em>Selecting Subsets of Data</em>, covered a wide range of recipes on selecting different subsets of data through the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers. Both these indexers select rows and columns simultaneously by either integer location or label. Both these indexers can also do data selection through boolean indexing, even though booleans are not integers and not labels.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will filter both rows and columns with boolean indexing for both the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Read in the movie dataset, set the index as the title, and then create a boolean Series matching all movies with a content rating of <kbd>G</kbd> and an IMDB score less than <kbd>4</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie = pd.read_csv('data/movie.csv', index_col='movie_title')<br/>&gt;&gt;&gt; c1 = movie['content_rating'] == 'G'<br/>&gt;&gt;&gt; c2 = movie['imdb_score'] &lt; 4<br/>&gt;&gt;&gt; criteria = c1 &amp; c2</pre>
<ol start="2">
<li>Let's first pass these criteria to the <kbd>.loc</kbd> indexer to filter the rows:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_loc = movie.loc[criteria]<br/>&gt;&gt;&gt; movie_loc.head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/c1f67118-c501-4567-898e-2955ae52f71b.png" style="width:60.17em;height:22.50em;"/></div>
<ol start="3">
<li>Let's check whether this DataFrame is exactly equal to the one generated directly from the indexing operator:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_loc.equals(movie[criteria])<br/>True</pre>
<ol start="4">
<li>Now let's attempt the same boolean indexing with the <kbd>.iloc</kbd> indexer:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_iloc = movie.iloc[criteria]<br/>ValueError: iLocation based boolean indexing cannot use an indexable as a mask</pre>
<ol start="5">
<li>It turns out that we cannot directly use a Series of booleans because of the index. We can, however, use ndarray of booleans. To extract the array, use the <kbd>values</kbd> attribute:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie_iloc = movie.iloc[criteria.values]<br/>&gt;&gt;&gt; movie_iloc.equals(movie_loc)<br/>True</pre>
<ol start="6">
<li>Although not very common, it is possible to do boolean indexing to select particular columns. Here, we select all the columns that have a data type of 64-bit integers:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; criteria_col = movie.dtypes == np.int64<br/>&gt;&gt;&gt; criteria_col.head()<br/>color                      False
director_name              False
num_critic_for_reviews     False
duration                   False
director_facebook_likes    False
dtype: bool<br/><br/>&gt;&gt;&gt; movie.loc[:, criteria_col].head()</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/3d5a5522-27c6-4a1f-8c09-ea6f01ac522f.png" style="width:50.50em;height:14.33em;"/></div>
<ol start="7">
<li>As <kbd>criteria_col</kbd> is a Series, which always has an index, you must use the underlying ndarray to make it work with <kbd>.iloc</kbd>. The following produces the same result as step 6.</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; movie.iloc[:, criteria_col.values].head() </pre>
<ol start="8">
<li>A boolean Series may be used to select rows and then simultaneously select columns with either integers or labels. Remember, you need to put a comma between the row and column selections. Let's keep the row criteria and select <kbd>content_rating</kbd>, <kbd>imdb_score</kbd>, <kbd>title_year</kbd>, and <kbd>gross</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; cols = ['content_rating', 'imdb_score', 'title_year', 'gross']<br/>&gt;&gt;&gt; movie.loc[criteria, cols].sort_values('imdb_score')</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/dadc8ffc-c00e-4c21-9dbe-756c1ca4294b.png" style="width:34.25em;height:14.92em;"/></div>
<ol start="9">
<li>This same operation may be replicated with <kbd>.iloc</kbd>, but you need to get the integer location of all the columns:</li>
</ol>
<pre style="padding-left: 60px">&gt;&gt;&gt; col_index = [movie.columns.get_loc(col) for col in cols]<br/>&gt;&gt;&gt; col_index<br/>[20, 24, 22, 8]<br/><br/>&gt;&gt;&gt; movie.iloc[criteria.values, col_index] </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Boolean indexing may be accomplished with both the <kbd>.iloc</kbd> and <kbd>.loc</kbd> indexers with the caveat that <kbd>.iloc</kbd> cannot be passed a Series but the underlying ndarray. Let's take a look at the one-dimensional ndarray underlying the criteria Series:</p>
<pre>&gt;&gt;&gt; a = criteria.values<br/>&gt;&gt;&gt; a[:5]<br/>array([False, False, False, False, False], dtype=bool)<br/><br/>&gt;&gt;&gt; len(a), len(criteria)<br/>(4916, 4916)</pre>
<p>The array is the same length as the Series, which is the same length as the movie DataFrame. The integer location for the boolean array aligns with the integer location of the DataFrame and the filter happens as expected. These arrays also work with the <kbd>.loc</kbd> operator as well but they are a necessity for <kbd>.iloc</kbd>.</p>
<p>Steps 6 and 7 show how to filter by columns instead of by rows. The colon, <kbd>:</kbd>, is needed to indicate the selection of all the rows. The comma following the colon separates the row and column selections. There is actually a much easier way to select columns with integer data types and that is through the <kbd>select_dtypes</kbd> method.</p>
<p>Steps 8 and 9 show a very common and useful way to do boolean indexing on the row and column selections simultaneously. You simply place a comma between the row and column selections. Step 9 uses a list comprehension to loop through all the desired column names to find their integer location with the index method <kbd>get_loc</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It is actually possible to pass <span>arrays and lists of booleans to</span> Series objects that are not the same length as the DataFrame you are doing the indexing on. Let's look at an example of this by selecting the first and third rows, and the first and fourth columns:</p>
<pre class="mce-root">&gt;&gt;&gt; movie.loc[[True, False, True], [True, False, False, True]]</pre>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/07c9bc12-0cc4-4402-bc01-fda1e8ee7958.png" style="width:9.50em;height:5.92em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Both of the boolean lists are not the same length as the axis they are indexing. The rest of the rows and columns not explicitly given a boolean value in the lists are dropped.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Refer to the <em>Selecting data with both integers and labels</em> recipe from <a href="3b938362-1f65-406c-ba9d-3bf735543ca8.xhtml" target="_blank">Chapter 10</a>, <em>Selecting Subsets of Data</em></li>
</ul>


            </article>

            
        </section>
    </body></html>