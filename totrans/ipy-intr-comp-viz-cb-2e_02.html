<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Best Practices in Interactive Computing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Best Practices in Interactive Computing</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Choosing (or not) between Python 2 and Python 3</li><li class="listitem" style="list-style-type: disc">Efficient interactive computing workflows with IPython</li><li class="listitem" style="list-style-type: disc">Learning the basics of the distributed version control system Git</li><li class="listitem" style="list-style-type: disc">A typical workflow with Git branching</li><li class="listitem" style="list-style-type: disc">Ten tips for conducting reproducible interactive computing experiments</li><li class="listitem" style="list-style-type: disc">Writing high-quality Python code</li><li class="listitem" style="list-style-type: disc">Writing unit tests with nose</li><li class="listitem" style="list-style-type: disc">Debugging your code with IPython</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Introduction</h1></div></div></div><p>This is a special chapter about good practices in interactive computing. If the rest of the book is about the content, then this chapter is about the form. It describes how to work efficiently and properly with the tools this book is about. We will cover the essentials of the version control system Git before tackling reproducible computing experiments (notably with the IPython notebook).</p><p>We will also cover more general topics in software development, such as code quality, debugging, and testing. Attention to these subjects can greatly improve the quality of our end products (for example, software, research, and publications). We will only scratch the surface here, but you will find many references to learn more about these important topics.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Choosing (or not) between Python 2 and Python 3"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Choosing (or not) between Python 2 and Python 3</h1></div></div></div><p>In this first recipe, we will briefly cover a transverse and kind of a prosaic subject: Python 2 or Python 3?</p><p>
<span class="strong"><strong>Python 3</strong></span> <a id="id160" class="indexterm"/>has been available since 2008, but many Python users are still stuck with Python 2. By improving many aspects of <a id="id161" class="indexterm"/>Python 2, Python 3 has broken compatibility with the previous branch. Migrating to Python 3 may therefore require a significant investment.</p><p>Even if there aren't that many compatibility-breaking changes, a program that works perfectly fine in Python 2 may not work at all in Python 3. For example, your very first <code class="literal">Hello World</code> Python 2 program doesn't work anymore in Python 3; <code class="literal">print "Hello World!"</code> raises a <code class="literal">SyntaxError</code> in Python 3. Indeed, <code class="literal">print</code> is now a function rather than a statement. You should write <code class="literal">print("Hello World!")</code>, which also works fine in Python 2.</p><p>Whether you start a new project or need to maintain an old Python library, the question of choosing between Python 2 and Python 3 arises. Here, we give some arguments and pointers that should let you make an informed decision.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>When we refer to Python 2, we especially mean Python 2.6 or Python 2.7, as these last versions of the Python 2.<span class="emphasis"><em>x</em></span> branch are closer to Python 3 than Python 2.5 and earlier versions. It is more complicated to support Python 2.5+ and Python 3.<span class="emphasis"><em>x</em></span> at the same time.</p><p>Similarly, when we refer to Python 3 or Python 3.<span class="emphasis"><em>x</em></span>, we especially mean Python 3.3 or above.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How to do it...</h2></div></div></div><p>First, what are the differences between Python 2 and Python 3?</p><div class="section" title="Main differences in Python 3 compared to Python 2"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Main differences in Python 3 compared to Python 2</h3></div></div></div><p>Here is a partial list <a id="id162" class="indexterm"/>of differences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instead of a <a id="id163" class="indexterm"/>statement, <code class="literal">print</code> is a function (parentheses are compulsory).</li><li class="listitem" style="list-style-type: disc">Division of integers yields floating-point numbers and not integers.</li><li class="listitem" style="list-style-type: disc">Several built-in functions return iterators or views instead of lists. For example, <code class="literal">range</code> behaves in Python 3 like <code class="literal">xrange</code> in Python 2, and the latter no longer exists in Python 3.</li><li class="listitem" style="list-style-type: disc">Dictionaries do not have the <code class="literal">iterkeys()</code>, <code class="literal">iteritems()</code>, and <code class="literal">itervalues()</code> methods anymore. You should use the <code class="literal">keys()</code>, <code class="literal">items()</code>, and <code class="literal">values()</code> functions instead.</li><li class="listitem" style="list-style-type: disc">The following is a quote from the official Python documentation:<div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Everything you thought you knew about binary data and Unicode has changed."</em></span></p></blockquote></div></li><li class="listitem" style="list-style-type: disc">String <a id="id164" class="indexterm"/>formatting with <code class="literal">%</code> is deprecated; use <code class="literal">str.format</code> instead.</li><li class="listitem" style="list-style-type: disc">Instead of <a id="id165" class="indexterm"/>a statement, <code class="literal">exec</code> is a function.</li></ul></div><p>Python 3 brings many other improvements and new features regarding syntax and standard library content. You will find more details in the references at the end of this recipe.</p><p>Now, you have basically two options for your project: stick with a single branch (Python 2 or Python 3), or maintain compatibility with both branches.</p></div><div class="section" title="Python 2 or Python 3?"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Python 2 or Python 3?</h3></div></div></div><p>It is natural to have a <a id="id166" class="indexterm"/>preference for Python 3; it is the future, whereas Python 2 is the past. Why bother supporting a deprecated version of Python? Here are a few situations where you might want to keep compatibility with Python 2:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You need to maintain a large project written in Python 2, and it would be too costly to update it to Python 3 (even if semiautomatic updating tools exist).</li><li class="listitem" style="list-style-type: disc">Your project has dependencies that do not work with Python 3.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Most libraries we will be using in this book support both Python 2 and Python 3. This book's code is also compatible with both branches.</p></div></div></li><li class="listitem" style="list-style-type: disc">Your end users work on environments that do not support Python 3 well. For example, they may work in a large institution where deploying a new version of Python on many servers would be too costly.</li></ul></div><p>In these situations, you may choose to stick with Python 2, with the risk that your code becomes obsolete in the near future. Otherwise, you could pick Python 3 and its shiny new features, with the risk of leaving behind Python 2 users. You could also write your code in Python 2 and make it ready for Python 3. Thus, you can reduce the number of changes that will be required during a subsequent port to Python 3.</p><p>Fortunately, you don't necessarily have to choose between Python 2 and Python 3. There are ways to support both versions at the same time. Even if this involves slightly more work than just sticking to a single branch, it can be quite interesting in certain cases. Note, however, that you may miss many Python 3-only features if you go down this road.</p></div><div class="section" title="Supporting both Python 2 and Python 3"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Supporting both Python 2 and Python 3</h3></div></div></div><p>There are basically two ways to support both branches in your code: use the <a id="id167" class="indexterm"/><span class="strong"><strong>2to3</strong></span> tool, or write code that <span class="emphasis"><em>just works</em></span> in both branches.</p></div><div class="section" title="Using 2to3"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Using 2to3</h3></div></div></div><p>2to3 <a id="id168" class="indexterm"/>is a program in the standard library that automatically converts Python 2 code to Python 3. For example, run <code class="literal">2to3 -w example.py</code> to migrate a single Python 2 module to Python 3. You can find more information on the 2to3 tool<a id="id169" class="indexterm"/> at <a class="ulink" href="https://docs.python.org/2/library/2to3.html">https://docs.python.org/2/library/2to3.html</a>.</p><p>You can configure your installation script so that 2to3 runs automatically when users install your package. Python 3 users will get the automatically-converted Python 3 version of your package.</p><p>This solution requires your program to be well-covered by a solid testing suite and a continuous integration system that tests both Python 2 and Python 3 (see the recipes about unit testing later in this chapter). This is how you can ensure that your code works fine in both versions.</p></div><div class="section" title="Writing code that works in Python 2 and Python 3"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Writing code that works in Python 2 and Python 3</h3></div></div></div><p>You can also write<a id="id170" class="indexterm"/> code that works in Python 2 and Python 3. This solution is simpler if you start a new project from scratch. A widely-used method is to rely on a lightweight and mature module called <a id="id171" class="indexterm"/><span class="strong"><strong>six</strong></span>, developed by Benjamin Petersons. This module is only a single file, so you can easily distribute it with your package. Wherever you would use a function or feature that is only supported in one Python branch, you need to use a specific function implemented in six. This function either wraps or emulates the corresponding functionality, thus it can work in both branches. You can find more<a id="id172" class="indexterm"/> information on six at <a class="ulink" href="http://pythonhosted.org/six/">http://pythonhosted.org/six/</a>.</p><p>This method requires you to change some habits. For example, to iterate over all items of a dictionary in Python 2, you would write the following code:</p><div class="informalexample"><pre class="programlisting">for k, v in d.iteritems():
    # ...</pre></div><p>Now, instead of the preceding code, you write the following code with six:</p><div class="informalexample"><pre class="programlisting">from six import iteritems
for k, v in iteritems(d):
    # ...</pre></div><p>The <code class="literal">iteritems()</code> method<a id="id173" class="indexterm"/> of dictionaries in Python 2 is replaced by <code class="literal">items()</code> in Python 3. The six module's <code class="literal">iteritems</code> function internally calls one method or the other, depending on the Python version.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>There's more...</h2></div></div></div><p>As we have seen, there <a id="id174" class="indexterm"/>are many options you can choose regarding the Python 2 or Python 3 question. In brief, you should consider the following options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Decide very carefully whether you absolutely need to support Python 2 or not:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If so, prepare your code for Python 3 by avoiding Python 2-only syntax or features. You can use six, 2to3, or similar tools.</li><li class="listitem" style="list-style-type: disc">If not, stick to Python 3.</li></ul></div></li><li class="listitem" style="list-style-type: disc">In all cases, make sure your project has a solid testing suite, an excellent code coverage (approaching 100 percent), and a continuous integration system that tests your code against all versions of Python that you officially support</li></ul></div><p>Here are several<a id="id175" class="indexterm"/> references <a id="id176" class="indexterm"/>on the subject:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An excellent free book about porting code to Python 3, by Lennart Regebro, available at <a class="ulink" href="http://python3porting.com/">http://python3porting.com/</a></li><li class="listitem" style="list-style-type: disc">Official recommendations on porting code to Python 3, available at <a class="ulink" href="https://docs.python.org/3/howto/pyporting.html">https://docs.python.org/3/howto/pyporting.html</a></li><li class="listitem" style="list-style-type: disc">Official wiki page about the Python 2/Python 3 question, available at <a class="ulink" href="https://wiki.python.org/moin/Python2orPython3">https://wiki.python.org/moin/Python2orPython3</a></li><li class="listitem" style="list-style-type: disc">Python 3 questions and answers, by Nick Coghlan, available at <a class="ulink" href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html">http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>What's new in Python 3</em></span>, available at <a class="ulink" href="https://docs.python.org/3.3/whatsnew/3.0.html">https://docs.python.org/3.3/whatsnew/3.0.html</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Ten awesome features of Python that you can't use because you refuse to upgrade to Python 3</em></span>, a presentation by Aaron Meurer, available at <a class="ulink" href="http://asmeurer.github.io/python3-presentation/slides.html">http://asmeurer.github.io/python3-presentation/slides.html</a></li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">__future__</code> module when writing the compatibility code, available at <a class="ulink" href="https://docs.python.org/2/library/__future__.html">https://docs.python.org/2/library/__future__.html</a></li><li class="listitem" style="list-style-type: disc">Key <a id="id177" class="indexterm"/>differences between<a id="id178" class="indexterm"/> Python 2 and Python 3, available at <a class="ulink" href="https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html">https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing high-quality Python code</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing unit tests with nose</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Efficient interactive computing workflows with IPython"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Efficient interactive computing workflows with IPython</h1></div></div></div><p>There are multiple ways of <a id="id179" class="indexterm"/>using IPython for interactive<a id="id180" class="indexterm"/> computing. Some of them are better in terms of flexibility, modularity, reusability, and reproducibility. We will review and discuss them in this recipe.</p><p>Any interactive computing workflow is based on the following cycle:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Write some code</li><li class="listitem" style="list-style-type: disc">Execute it</li><li class="listitem" style="list-style-type: disc">Interpret the results</li><li class="listitem" style="list-style-type: disc">Repeat</li></ul></div><p>This fundamental loop (also known as <span class="strong"><strong>Read-Eval-Print Loop</strong></span> or<a id="id181" class="indexterm"/> <span class="strong"><strong>REPL</strong></span>) is particularly useful when doing exploratory research on data or model simulations, or when building a complex algorithm step by step. A more classical workflow (the edit-compile-run-debug loop) would consist of writing a full-blown program, and then performing a complete analysis. This is generally more tedious. It is more common to build an algorithmic solution iteratively, by doing small-scale experiments and tweaking the parameters, and this is precisely what interactive computing is about.</p><p>
<span class="strong"><strong>Integrated Development Environments</strong></span> (<span class="strong"><strong>IDEs</strong></span>), providing comprehensive<a id="id182" class="indexterm"/> facilities for software development (such as a source code editor, compiler, and debugger), are widely used for classical workflows. However, when it comes to interactive computing, alternatives to IDEs exist. We will review them here.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How to do it...</h2></div></div></div><p>Here are a few possible workflows for interactive computing, by increasing order of complexity. Of course, IPython is at the core of all of these methods.</p><div class="section" title="The IPython terminal"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>The IPython terminal</h3></div></div></div><p>IPython<a id="id183" class="indexterm"/> is the <span class="emphasis"><em>de facto</em></span> standard for interactive computing in Python. The<a id="id184" class="indexterm"/> IPython terminal (the <code class="literal">ipython</code> command) offers a command-line interface specifically designed for REPLs. It is a much more powerful tool than the native Python interpreter (the <code class="literal">python</code> command). The IPython terminal is a convenient tool for quick experiments, simple shell interactions, and to find help. Forgot the input arguments of NumPy's <code class="literal">savetxt</code> function? Just type in <code class="literal">numpy.savetxt?</code> in IPython (you will first need to use <code class="literal">import numpy</code>, of course). Some people even use the IPython terminal as a (sophisticated) calculator!</p><p>Yet, the terminal quickly becomes limited when it is used alone. The main issue is that the terminal is not a code editor, and thus entering more than a few lines of code can be inconvenient. Fortunately, there are various ways of solving this problem, as detailed in the following sections.</p></div><div class="section" title="IPython and text editor"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>IPython and text editor</h3></div></div></div><p>The simplest solution<a id="id185" class="indexterm"/> to the <span class="emphasis"><em>not-a-text-editor</em></span> problem is, perhaps<a id="id186" class="indexterm"/> unsurprisingly, to use IPython along with a text editor. The <code class="literal">%run</code> magic command<a id="id187" class="indexterm"/> then becomes the central tool in this workflow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Write some code in your favorite text editor and save it in a <code class="literal">myscript.py</code> Python script file.</li><li class="listitem" style="list-style-type: disc">In IPython, assuming you are in the right directory, type in <code class="literal">%run myscript.py</code>.</li><li class="listitem" style="list-style-type: disc">The script is executed. The standard output is displayed in real time in the IPython terminal along with possible errors. Top-level variables defined in the script are accessible in the IPython terminal at the end of the script's execution.</li><li class="listitem" style="list-style-type: disc">If code changes are required in the script, repeat the process.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>The IPython-text editor workflow<a id="id188" class="indexterm"/> can be made yet more efficient with adequate keyboard shortcuts. You can, for instance, automate your text editor such that, when pressing <span class="emphasis"><em>F8</em></span>, the following command is executed in the running IPython interpreter:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%run &lt;CURRENT_FILE_NAME&gt;</strong></span>
</pre></div><p>This approach is described here (on Windows, with Notepad++ and AutoHotKey):</p><p>
<a class="ulink" href="http://cyrille.rossant.net/python-ide-windows/">http://cyrille.rossant.net/python-ide-windows/</a>
</p></div></div><p>With a good text<a id="id189" class="indexterm"/> editor, this workflow can be quite efficient. As<a id="id190" class="indexterm"/> the script is reloaded when you execute <code class="literal">%run</code>, your changes will be taken into account automatically. Things become more complicated when your script imports other Python modules that you modify, as these won't be reloaded with <code class="literal">%run</code>. You can use a deep reload to solve this problem:</p><div class="informalexample"><pre class="programlisting">import myscript
from IPython.lib.deepreload import reload as dreload
dreload(myscript)</pre></div><p>Modules imported in <code class="literal">myscript</code> will then be reloaded. A related IPython magic command is <code class="literal">%autoreload</code> (you first need to execute <code class="literal">%load_ext autoreload</code>). This command tries to automatically reload the modules imported in the interactive namespace, but it is not always successful. You may need to reload the changed modules explicitly with <code class="literal">reload(module)</code> (in Python 2) or <code class="literal">imp.reload(module)</code> (Python 3).</p></div><div class="section" title="The IPython notebook"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>The IPython notebook</h3></div></div></div><p>The IPython notebook<a id="id191" class="indexterm"/> plays a central role in efficient interactive workflows. It is a well-designed mix between a code editor and a terminal, bringing the best of both worlds within a unified environment.</p><p>You can start writing all your code in your notebook's cells. You write, execute, and test your code at the same place, thereby improving your productivity. You can put long comments in Markdown cells and structure your notebook with Markdown headers.</p><p>Once portions of your code become mature enough and do not require further changes, you can (and should) refactor them into reusable Python components (functions, classes, and modules). This will clean up your notebooks and facilitate future reuse of your code. Let's emphasize the fact that it is very important to refactor your code constantly into reusable components. IPython notebooks are currently not easily reusable by third-party code, and they are not designed for this. Notebooks are convenient for preliminary analyses and exploratory research, but they should not preclude you from regularly cleaning and refactoring your code into Python components.</p><p>A major advantage of notebooks is that they give you documents retracing everything you did with your code. They are extremely useful for reproducible research. Notebooks are saved in human-readable JSON documents, thus they work relatively well with version control systems such as Git.</p></div><div class="section" title="Integrated Development Environments"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Integrated Development Environments</h3></div></div></div><p>IDEs<a id="id192" class="indexterm"/> are particularly well-adapted for classic software development, but they can also be used for interactive computing. A good Python IDE combines a powerful text editor (for example, one that includes features such as syntax highlighting and tab completion), an IPython terminal, and a debugger within a unified environment.</p><p>There are multiple commercial and open-source IDEs for most platforms. <span class="strong"><strong>Eclipse</strong></span>/<span class="strong"><strong>PyDev</strong></span> is a<a id="id193" class="indexterm"/> popular (although slightly heavy) open source cross-platform environment. <span class="strong"><strong>Spyder</strong></span><a id="id194" class="indexterm"/> is another open source IDE with good integration of IPython and matplotlib. <span class="strong"><strong>PyCharm</strong></span> <a id="id195" class="indexterm"/>is one of many commercial environments that support IPython.</p><p>Microsoft's IDE for Windows, Visual Studio, has an open source plugin named <span class="strong"><strong>Python Tools for Visual Studio</strong></span> (<span class="strong"><strong>PTVS</strong></span>). This tool brings <a id="id196" class="indexterm"/>Python support to Visual Studio. PTVS natively supports IPython. You don't necessarily need a paid version of Visual Studio; you can download a free package bundling PTVS with Visual Studio.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>There's more...</h2></div></div></div><p>Here are a few links to various IDEs for Python:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://pydev.org">http://pydev.org</a> for PyDev<a id="id197" class="indexterm"/> for Eclipse</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://code.google.com/p/spyderlib/">http://code.google.com/p/spyderlib/</a> for Spyder, an open source IDE</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.jetbrains.com/pycharm/">www.jetbrains.com/pycharm/</a> for PyCharm</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://pytools.codeplex.com">http://pytools.codeplex.com</a> for PyTools for Microsoft Visual Studio on Windows</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://code.google.com/p/pyscripter/">http://code.google.com/p/pyscripter/</a> for PyScripter</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.iep-project.org">www.iep-project.org</a> for IEP, the Interactive Editor for Python</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Learning the basics of the distributed version control system Git</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Debugging your code with IPython</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Learning the basics of the distributed version control system Git"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Learning the basics of the distributed version control system Git</h1></div></div></div><p>Using a <a id="id198" class="indexterm"/><span class="strong"><strong>distributed version control system</strong></span> is so natural nowadays that if you are reading this book, you are probably already using one. However, if you aren't, read this recipe carefully. You should always use a version control system for your code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>Getting ready</h2></div></div></div><p>Notable distributed version control systems include <a id="id199" class="indexterm"/><span class="strong"><strong>Git</strong></span>, <a id="id200" class="indexterm"/><span class="strong"><strong>Mercurial</strong></span>, and <a id="id201" class="indexterm"/><span class="strong"><strong>Bazaar</strong></span>. In this chapter, we chose the popular Git system. You can download the Git program and Git GUI clients from <a class="ulink" href="http://git-scm.com">http://git-scm.com</a>. On Windows, you can also install <a id="id202" class="indexterm"/><span class="strong"><strong>msysGit</strong></span> (<a class="ulink" href="http://msysgit.github.io">http://msysgit.github.io</a>) and<a id="id203" class="indexterm"/> <span class="strong"><strong>TortoiseGit</strong></span> (<a class="ulink" href="https://code.google.com/p/tortoisegit/">https://code.google.com/p/tortoisegit/</a>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Distributed systems tend to be more popular than centralized systems such as SVN or CVS. Distributed systems allow local (offline) changes and offer more flexible collaboration systems.</p></div></div><p>Online providers supporting Git include <a id="id204" class="indexterm"/><span class="strong"><strong>GitHub</strong></span> (<a class="ulink" href="https://github.com">https://github.com</a>), <a id="id205" class="indexterm"/><span class="strong"><strong>Bitbucket</strong></span> (<a class="ulink" href="https://bitbucket.org">https://bitbucket.org</a>), <a id="id206" class="indexterm"/><span class="strong"><strong>Google code</strong></span> (<a class="ulink" href="https://code.google.com">https://code.google.com</a>), <a id="id207" class="indexterm"/><span class="strong"><strong>Gitorious</strong></span> (<a class="ulink" href="https://gitorious.org">https://gitorious.org</a>), and <span class="strong"><strong>SourceForge</strong></span><a id="id208" class="indexterm"/> (<a class="ulink" href="https://sourceforge.net">https://sourceforge.net</a>). At the time of writing this book, creating an account is free on all these websites. GitHub offers free unlimited public repositories, while Bitbucket offers free unlimited public and private repositories. GitHub<a id="id209" class="indexterm"/> offers special features and discounts to academics (<a class="ulink" href="https://github.com/edu">https://github.com/edu</a>). Synchronizing your Git repositories on such a website is particularly convenient when you work on multiple computers.</p><p>You need to install Git (and possibly a GUI) for this recipe (see <a class="ulink" href="http://git-scm.com/downloads">http://git-scm.com/downloads</a>). We also suggest that you create an account on one of these websites. GitHub is a popular choice, notably for its user-friendly web interface and its well-developed social features. GitHub also provides a very good GUI on Windows<a id="id210" class="indexterm"/> (<a class="ulink" href="https://windows.github.com">https://windows.github.com</a>) and <a id="id211" class="indexterm"/>Mac OS X (<a class="ulink" href="https://mac.github.com">https://mac.github.com</a>). Most Python libraries we will be using in this book are being developed on GitHub.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How to do it…</h2></div></div></div><p>We will show two methods to initialize a repository.</p><div class="section" title="Creating a local repository"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Creating a local repository</h3></div></div></div><p>This method is best <a id="id212" class="indexterm"/>when starting to work locally. This can be with using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The very first thing to do when starting a new project or computing experiment is create a new folder locally:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir myproject</strong></span>
<span class="strong"><strong>$ cd myproject</strong></span>
</pre></div></li><li class="listitem">We initialize a Git repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git init</strong></span>
</pre></div></li><li class="listitem">Let's set our name and e-mail address:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git config --global user.name "My Name"</strong></span>
<span class="strong"><strong>$ git config --global user.email "me@home"</strong></span>
</pre></div></li><li class="listitem">We create a new file, and tell Git to track it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ touch __init__.py</strong></span>
<span class="strong"><strong>$ git add __init__.py</strong></span>
</pre></div></li><li class="listitem">Finally, let's create our first commit:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git commit -m "Initial commit."</strong></span>
</pre></div></li></ol></div></div><div class="section" title="Cloning a remote repository"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Cloning a remote repository</h3></div></div></div><p>This method is best when<a id="id213" class="indexterm"/> the repository is to be synchronized with an online provider such as GitHub. Let's perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new repository on the web interface of our online provider.</li><li class="listitem">On the main webpage of the newly created project, we click on the <span class="strong"><strong>Clone</strong></span> button with the repository URL and we type in a terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git clone /path/to/myproject.git</strong></span>
</pre></div></li><li class="listitem">We set our name and e-mail address:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git config --global user.name "My Name"</strong></span>
<span class="strong"><strong>$ git config --global user.email "me@home"</strong></span>
</pre></div></li><li class="listitem">Let's create a new file and tell Git to track it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ touch __init__.py</strong></span>
<span class="strong"><strong>$ git add __init__.py</strong></span>
</pre></div></li><li class="listitem">We create our first commit:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git commit -m "Initial commit."</strong></span>
</pre></div></li><li class="listitem">We push our local changes to the remote server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git push origin</strong></span>
</pre></div></li></ol></div><p>When we have a local repository (created with the first method), we can synchronize it with a <a id="id214" class="indexterm"/>remote server <a id="id215" class="indexterm"/>using a <code class="literal">git remote add</code> command.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec48"/>How it works…</h2></div></div></div><p>When you start a <a id="id216" class="indexterm"/>new project or a new computing experiment, create a new folder on your computer. You will eventually add code, text files, datasets, and other resources in this folder. The distributed version control system keeps track of the changes you make to your files as your project evolves. It is more than a simple backup, as every change you make on any file can be saved along with the corresponding timestamp. You can even revert to a previous state at any time; never be afraid of breaking your code anymore!</p><p>Specifically, you can take a snapshot of your project at any time by doing a <a id="id217" class="indexterm"/><span class="strong"><strong>commit</strong></span>. The snapshot includes all staged (or tracked) files. You are in total control of which files and changes will be tracked. With Git, you specify a file as staged for your next commit with <code class="literal">git add</code>, before committing your changes with <code class="literal">git commit</code>. The <code class="literal">git commit -a</code> command allows you to commit all changes in the files that are already being tracked.</p><p>When committing, you need to provide a message describing the changes you made. This makes the repository's history considerably more informative.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>
<span class="strong"><strong>How often should you commit?</strong></span>
</p><p>The answer is very often. Git only takes responsibility of your work when you commit changes. What happens between two commits may be lost, so you'd better commit very regularly. Besides, commits are quick and cheap as they are local; that is, they do not involve any remote communication with an external server.</p></div></div><p>Git<a id="id218" class="indexterm"/> is a distributed version control system; your local repository does not need to synchronize with an external server. However, you should synchronize if you need to work on several computers, or if you prefer to have a remote backup. Synchronization with a remote repository can be done with <code class="literal">git push</code> (send your local commits on the remote server), <code class="literal">git fetch</code> (download remote branches and objects), or <code class="literal">git pull</code> (synchronize the remote changes on your local repository).</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec49"/>There's more…</h2></div></div></div><p>The simplistic workflow shown in this recipe is linear. In practice though, workflows with Git are typically nonlinear; this is the concept of branching. We will describe this idea in the next recipe, <span class="emphasis"><em>A typical workflow with Git branching</em></span>.</p><p>Here are some excellent references on Git:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hands-on<a id="id219" class="indexterm"/> tutorial, available at <a class="ulink" href="https://try.github.io">https://try.github.io</a></li><li class="listitem" style="list-style-type: disc">Git Guided Tour, at <a class="ulink" href="http://gitimmersion.com">http://gitimmersion.com</a></li><li class="listitem" style="list-style-type: disc">Atlassian Git tutorial, available at <a class="ulink" href="http://www.atlassian.com/git">www.atlassian.com/git</a></li><li class="listitem" style="list-style-type: disc">Online course, available at <a class="ulink" href="http://www.codeschool.com/courses/try-git">www.codeschool.com/courses/try-git</a></li><li class="listitem" style="list-style-type: disc">Git tutorial by Lars Vogel, available at <a class="ulink" href="http://www.vogella.com/tutorials/Git/article.html">www.vogella.com/tutorials/Git/article.html</a></li><li class="listitem" style="list-style-type: disc">GitHub Git tutorial, available at <a class="ulink" href="http://git-lectures.github.io">http://git-lectures.github.io</a></li><li class="listitem" style="list-style-type: disc">Git tutorial for scientists, available at <a class="ulink" href="http://nyuccl.org/pages/GitTutorial/">http://nyuccl.org/pages/GitTutorial/</a></li><li class="listitem" style="list-style-type: disc">GitHub help, available at <a class="ulink" href="https://help.github.com">https://help.github.com</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Pro Git</em></span> by Scott Chacon, available at <a class="ulink" href="http://git-scm.com">http://git-scm.com</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec50"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>A typical workflow with Git branching</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="A typical workflow with Git branching"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>A typical workflow with Git branching</h1></div></div></div><p>A distributed version<a id="id220" class="indexterm"/> control system such as Git is designed for complex and nonlinear workflows typical in interactive computing and exploratory research. A central concept is <a id="id221" class="indexterm"/><span class="strong"><strong>branching</strong></span>, which we will discuss in this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec51"/>Getting ready</h2></div></div></div><p>You need to work in a local <a id="id222" class="indexterm"/>Git repository for this recipe (see the previous recipe, <span class="emphasis"><em>Learning the basics of the distributed version control system Git</em></span>).</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new branch named <code class="literal">newidea</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git branch newidea</strong></span>
</pre></div></li><li class="listitem">We switch to this branch:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git checkout newidea</strong></span>
</pre></div></li><li class="listitem">We make changes to the code, for instance, by creating a new file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ touch newfile.py</strong></span>
</pre></div></li><li class="listitem">We add this file and commit our changes:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git add newfile.py</strong></span>
<span class="strong"><strong>$ git commit -m "Testing new idea."</strong></span>
</pre></div></li><li class="listitem">If we are happy with the changes, we merge the branch to the <span class="emphasis"><em>master</em></span> branch (the default):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git checkout master</strong></span>
<span class="strong"><strong>$ git merge newidea</strong></span>
</pre></div><p>Otherwise, we delete the branch:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git checkout master</strong></span>
<span class="strong"><strong>$ git branch -d newidea</strong></span>
</pre></div></li></ol></div><p>Other<a id="id223" class="indexterm"/> commands <a id="id224" class="indexterm"/>of interest include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">git status</code>: <a id="id225" class="indexterm"/>Find the current <span class="strong"><strong>status</strong></span> of the repository</li><li class="listitem" style="list-style-type: disc"><code class="literal">git log</code>: <a id="id226" class="indexterm"/>Show the commit logs</li><li class="listitem" style="list-style-type: disc"><code class="literal">git branch</code>: <a id="id227" class="indexterm"/>Show the existing <span class="strong"><strong>branches</strong></span> and highlight the current one</li><li class="listitem" style="list-style-type: disc"><code class="literal">git diff</code>: <a id="id228" class="indexterm"/>Show the <span class="strong"><strong>differences</strong></span> between commits or branches</li></ul></div><div class="section" title="Stashing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Stashing</h3></div></div></div><p>It may happen that while we are <a id="id229" class="indexterm"/>halfway through some work, we need to make some other change in another commit or another branch. We could commit our half-done work, but this is not ideal. A better idea is to <span class="strong"><strong>stash</strong></span><a id="id230" class="indexterm"/> our working copy in a secured location so that we can recover all of our uncommitted changes later. Here is how it works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We save our uncommitted changes with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git stash</strong></span>
</pre></div></li><li class="listitem">We can do anything we want with the repository: checkout a branch, commit changes, pull or push from a remote repository, and so on.</li><li class="listitem">When we want to recover our uncommitted changes, we type the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git stash pop</strong></span>
</pre></div></li></ol></div><p>We can have several stashed states in the repository. More information about stashing can be found with <code class="literal">git stash --help</code>.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How it works…</h2></div></div></div><p>Let's imagine that in <a id="id231" class="indexterm"/>order to test a new idea, you need to make non-trivial <a id="id232" class="indexterm"/>changes to your code in multiple files. You create a new branch, test your idea, and end up with a modified version of your code. If this idea was a dead end, you switch back to the original branch of your code. However, if you are happy with the changes, you <span class="strong"><strong>merge</strong></span><a id="id233" class="indexterm"/> it into the main branch.</p><p>The strength of this workflow is that the main branch can evolve independently from the branch with the new idea. This is particularly useful when multiple collaborators are working on the same repository. However, it is also a good habit to have, especially when there is a single contributor.</p><p>Merging <a id="id234" class="indexterm"/>is not always a trivial operation, as it can involve two divergent branches with potential conflicts. Git tries to resolve conflicts automatically, but it is not always successful. In this case, you need to resolve the conflicts manually.</p><p>An alternative to merging is<a id="id235" class="indexterm"/> <span class="strong"><strong>rebasing</strong></span>, which is useful when the main branch has changed while you were working on your branch. Rebasing your branch on the main branch allows you to move your branching point to a more recent point. This process may require you to resolve conflicts.</p><p>Git branches are lightweight objects. Creating and manipulating them is cheap. They are meant to be used frequently. It is important to perfectly grasp all related notions and <code class="literal">git</code> commands (notably <code class="literal">checkout</code>, <code class="literal">merge</code>, and <code class="literal">rebase</code>). The previous recipe contains many excellent references.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>There's more…</h2></div></div></div><p>Many people have thought about effective workflows. For example, a common but complex workflow, called <a id="id236" class="indexterm"/>git-flow, is described at <a class="ulink" href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a>. However, it may be preferable to use a simpler workflow in small and mid-size projects, such as the one described at <a class="ulink" href="http://scottchacon.com/2011/08/31/github-flow.html">http://scottchacon.com/2011/08/31/github-flow.html</a>. The latter workflow elaborates on the simplistic example shown in this recipe.</p><p>A related notion to branching is <a id="id237" class="indexterm"/><span class="strong"><strong>forking</strong></span>. There can be multiple copies of the same repository on different servers. Imagine that you want to contribute to IPython's code stored on GitHub. You probably don't have the permission to modify their repository, but you can make a copy into your personal account—this is called forking. In this copy, you can create a branch and propose a new feature or a bug fix. Then, you can propose the IPython developers to merge your branch into their master branch with a <a id="id238" class="indexterm"/><span class="strong"><strong>pull request</strong></span>. They can review your changes, propose suggestions, and eventually merge your work (or not). GitHub is built around this idea and thereby offers a clean, modern way to collaborate on open source projects.</p><p>Performing code reviews before merging pull requests leads to higher code quality in a collaborative project. When at least two people review any piece of code, the probability of merging bad or wrong code is reduced.</p><p>There is, of course, much more to say about Git. Version control systems are complex and quite powerful in general, and Git is no exception. Mastering Git requires time and experimentation. The previous recipe contains many excellent references.</p><p>Here are a few further references<a id="id239" class="indexterm"/> about branches and <a id="id240" class="indexterm"/>workflows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Git workflows available at <a class="ulink" href="http://www.atlassian.com/git/workflows">www.atlassian.com/git/workflows</a></li><li class="listitem" style="list-style-type: disc">Learn Git branching at <a class="ulink" href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a></li><li class="listitem" style="list-style-type: disc">The Git workflow recommended on the NumPy project (and others), described at <a class="ulink" href="http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html">http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html</a></li><li class="listitem" style="list-style-type: disc">A post on the IPython mailing list about an efficient Git workflow, by Fernando Perez, available at <a class="ulink" href="http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html">http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Learning the basics of the distributed version control system Git</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Ten tips for conducting reproducible interactive computing experiments"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Ten tips for conducting reproducible interactive computing experiments</h1></div></div></div><p>In this recipe, we present ten tips that can help you conduct efficient and <a id="id241" class="indexterm"/><span class="strong"><strong>reproducible</strong></span> interactive computing experiments. These are more guidelines than absolute rules.</p><p>First, we will show how you can improve your productivity by minimizing the time spent doing repetitive tasks and maximizing the time spent thinking about your core work.</p><p>Second, we will demonstrate how you can achieve more reproducibility in your computing work. Notably, academic research requires experiments to be reproducible so that any result or conclusion can be verified independently by other researchers. It is not uncommon for errors or manipulations in methods to result in erroneous conclusions that can have damaging consequences. For example, in the 2010 research paper in economics <span class="emphasis"><em>Growth in a Time of Debt</em></span>, by Carmen Reinhart and Kenneth Rogoff, computational errors were partly responsible for a flawed study with global ramifications for policy makers (see <a class="ulink" href="http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt">http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt</a>).</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Organize your <a id="id242" class="indexterm"/>directory structure carefully and coherently. The specific structure does not matter. What matters is to be consistent throughout your projects regarding file-naming conventions, folders, subfolders, and so on. Here is a simple example:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">my_project/</code><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">data/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">code/</code><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">common.py</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">idea1.ipynb</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">idea2.ipynb</code></li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">figures/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">notes/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">README.md</code></li></ul></div></li></ul></div></li><li class="listitem">Write notes in text files using a lightweight markup language such as <a id="id243" class="indexterm"/><span class="strong"><strong>Markdown</strong></span> (<a class="ulink" href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a>) or <a id="id244" class="indexterm"/><span class="strong"><strong>reStructuredText</strong></span> (<span class="strong"><strong>reST</strong></span>). All meta-information related to your project, files, data sets, code, figures, lab notebooks, and so on, should be written down in text files.</li><li class="listitem">Relatedly, document everything non-trivial in your code with comments, docstrings, and so on. You<a id="id245" class="indexterm"/> can use a documentation tool such as <span class="strong"><strong>Sphinx</strong></span><a id="id246" class="indexterm"/> (<a class="ulink" href="http://sphinx-doc.org">http://sphinx-doc.org</a>). However, do not spend too much time documenting unstable and bleeding-edge code while you are working on it; it might change frequently and your documentation may soon be out of date. Write your code in such a way that it's easily understandable without comments (name your variables and functions well, use Pythonic patterns, and so on). See also the next recipe, <span class="emphasis"><em>Write high-quality Python code</em></span>.</li><li class="listitem">Use a distributed version control system such as Git for all text-based files, but not binary files (except maybe for very small ones when you really need to). You should use one repository per project. Synchronize the repositories on a remote server, using a free or paid hosting provider (such as GitHub or Bitbucket) or your own server (your host institution might be able to set up one for you). Use a specific system to store and share binary data files, such as <a class="ulink" href="http://figshare.com">figshare.com</a> or <a class="ulink" href="http://datadryad.org">datadryad.org</a>.</li><li class="listitem">Write all your interactive computing code in IPython notebooks first and refactor it into standalone Python components only when it is sufficiently mature and stable.</li><li class="listitem">For<a id="id247" class="indexterm"/> full reproducibility, make sure that you record the exact versions of all components in your entire software stack (operating system, Python distribution, modules, and so on). A possibility is to use virtual environments with <a id="id248" class="indexterm"/><span class="strong"><strong>virtualenv</strong></span> or <a id="id249" class="indexterm"/><span class="strong"><strong>conda</strong></span>.</li><li class="listitem">Cache long-to-compute intermediary results using Python's native <span class="strong"><strong>pickle</strong></span> module, <span class="strong"><strong>dill</strong></span> (<a class="ulink" href="https://pypi.python.org/pypi/dill">https://pypi.python.org/pypi/dill</a>),<a id="id250" class="indexterm"/> or <a id="id251" class="indexterm"/><span class="strong"><strong>Joblib</strong></span> (<a class="ulink" href="http://pythonhosted.org/joblib/">http://pythonhosted.org/joblib/</a>). Joblib notably implements a NumPy-aware <span class="strong"><strong>memoize</strong></span> pattern<a id="id252" class="indexterm"/> (not to be confused with memorize), which allows you to cache the results of computationally intensive functions. See also the <span class="strong"><strong>ipycache</strong></span><a id="id253" class="indexterm"/> IPython extension (<a class="ulink" href="https://github.com/rossant/ipycache">https://github.com/rossant/ipycache</a>); it implements a <code class="literal">%%cache</code> cell magic in the notebook.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>
<span class="strong"><strong>Saving persistent data in Python</strong></span>
</p><p>For purely internal purposes, you can use Joblib, NumPy's <code class="literal">save</code> and <code class="literal">savez</code> functions for arrays, and pickle for any other Python object (prefer native types such as lists and dictionaries rather than custom classes). For sharing purposes, prefer text files for small datasets (less than 10k points), for example, CSV for arrays, and JSON or YAML for highly structured data. For larger datasets, you can use HDF5 (see the <span class="emphasis"><em>Manipulating large arrays with HDF5 and PyTables</em></span> and <span class="emphasis"><em>Manipulating large heterogeneous tables with HDF5 and PyTables</em></span> recipes of <a class="link" href="ch04.html" title="Chapter 4. Profiling and Optimization">Chapter 4</a>, <span class="emphasis"><em>Profiling and Optimization</em></span>).</p></div></div></li><li class="listitem">When developing and trying out algorithms on large data sets, run them and compare them on small portions of your data first, before moving to the full sets.</li><li class="listitem">When running jobs in a batch, use parallel computing to take advantage of your multicore processing units, for example, with <code class="literal">IPython.parallel</code>, Joblib, Python's multiprocessing package, or any other parallel computing library.</li><li class="listitem">Automate your work as much as possible with Python functions or scripts. Use command-line arguments for user-exposed scripts, but prefer Python functions over scripts when possible. On Unix systems, learn terminal commands to improve your productivity. For repetitive tasks on Windows or GUI-based systems, use automation tools such as AutoIt<a id="id254" class="indexterm"/> (<a class="ulink" href="http://www.autoitscript.com/site/autoit/">www.autoitscript.com/site/autoit/</a>) or <a id="id255" class="indexterm"/>AutoHotKey (<a class="ulink" href="http://www.autohotkey.com">www.autohotkey.com</a>). Learn keyboard shortcuts in the programs you use a lot, or create your own shortcuts.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>For example, you can create a keyboard shortcut to launch an IPython notebook server in the current directory. The following link contains an AutoHotKey script, which does this in <a id="id256" class="indexterm"/>Windows Explorer:</p><p>
<a class="ulink" href="http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/">http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/</a>
</p></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>How it works…</h2></div></div></div><p>The tips<a id="id257" class="indexterm"/> given in this recipe ultimately aim to optimize your workflows, in terms of human time, computer time, and quality. Using coherent conventions and structure for your code makes it easier for you to organize your work. Documenting everything saves everyone's time, including (eventually) yours! Should you be hit by a bus tomorrow, which I really hope you are not, you should ensure that your substitute can take over quickly, thanks to your conscientiously-written documentation. (You can find more information about the bus factor<a id="id258" class="indexterm"/> at <a class="ulink" href="http://en.wikipedia.org/wiki/Bus_factor">http://en.wikipedia.org/wiki/Bus_factor</a>.)</p><p>Using a distributed version control system with an online hosting service makes it easy for you to work on the same code base from multiple locations, without ever worrying about backups. As you can go back in time in your code, you have very little chance of unintentionally breaking it.</p><p>The IPython notebook is an excellent tool for reproducible interactive computing. It lets you keep a detailed record of your work. Also, the IPython notebook's ease of use means that you don't have to worry about reproducibility; just do all of your interactive work in notebooks, put them under version control, and commit regularly. Don't forget to refactor your code into independent reusable components.</p><p>Be sure to optimize the time you spend in front of your computer. When working on an algorithm, this cycle frequently happens: you do a slight modification, you launch the code, get the results, make another change, and so on and so forth. If you need to try out a lot of changes, you should ensure that the execution time is fast enough (no more than a few seconds). Using advanced optimization techniques is not necessarily the best option at this stage of experimentation. You should cache your results, try out your algorithms on data subsets, and run your simulations with shorter durations. You can also launch batch jobs in parallel when you want to test different parameter values.</p><p>Finally, desperately <a id="id259" class="indexterm"/>try to avoid doing repetitive tasks. It is worth spending time automating such tasks when they occur frequently in your day-to-day work. It is more difficult to automate tasks that involve GUIs, but it is feasible thanks to free tools such as AutoIt or AutoHotKey.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>There's more...</h2></div></div></div><p>Here are a few references<a id="id260" class="indexterm"/> about reproducibility in computing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>An efficient workflow for reproducible science</em></span>, a talk by Trevor Bekolay, available at <a class="ulink" href="http://bekolay.org/scipy2013-workflow/">http://bekolay.org/scipy2013-workflow/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Ten Simple Rules for Reproducible Computational Research</em></span>, <span class="emphasis"><em>Sandve et al.</em></span>, <span class="emphasis"><em>PLoS Computational Biology</em></span>, <span class="emphasis"><em>2013</em></span>, available at <a class="ulink" href="http://dx.doi.org/10.1371/journal.pcbi.1003285">http://dx.doi.org/10.1371/journal.pcbi.1003285</a>.</li><li class="listitem" style="list-style-type: disc">Konrad Hinsen's blog at <a class="ulink" href="http://khinsen.wordpress.com">http://khinsen.wordpress.com</a>.</li><li class="listitem" style="list-style-type: disc">Software Carpentry, a volunteer organization running workshops for scientists; the workshops cover scientific programming, interactive computing, version control, testing, reproducibility, and task automation. You can find more information at <a class="ulink" href="http://software-carpentry.org">http://software-carpentry.org</a>.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Efficient interactive computing workflows with IPython</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing high-quality Python code</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing high-quality Python code"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Writing high-quality Python code</h1></div></div></div><p>Writing code is easy. Writing <a id="id261" class="indexterm"/>high-quality code is much harder. Quality is to be understood both in terms of actual code (variable names, comments, docstrings, and so on) and architecture (functions, modules, and classes). In general, coming up with a well-designed code architecture is much more challenging than the implementation itself.</p><p>In this recipe, we will give a few tips about how to write high-quality code. This is a particularly important topic in academia, as more and more scientists without prior experience in software development need to program.</p><p>The references given at the end of this recipe contain much more details than what we could mention here.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Take the time to learn the Python language seriously. Review the list of all modules in the standard library—you may discover that functions you implemented already exist. Learn to write <span class="emphasis"><em>Pythonic</em></span> code, and do not translate programming idioms from other languages such as Java or C++ to Python.</li><li class="listitem">Learn common <a id="id262" class="indexterm"/><span class="strong"><strong>design patterns</strong></span>; these are general reusable solutions to commonly occurring problems in software engineering.</li><li class="listitem">Use assertions<a id="id263" class="indexterm"/> throughout your code (the <code class="literal">assert</code> keyword) to prevent future bugs (<span class="strong"><strong>defensive programming</strong></span>).</li><li class="listitem">Start writing your code with a bottom-up approach; write independent Python functions that implement focused tasks.</li><li class="listitem">Do not hesitate to refactor your code regularly. If your code is becoming too complicated, think about how you can simplify it.</li><li class="listitem">Avoid classes when you can. If you can use a function instead of a class, choose the function. A class is only useful when you need to store persistent state between function calls. Make your functions as <span class="emphasis"><em>pure</em></span> as possible (no side effects).</li><li class="listitem">In general, prefer Python native types (lists, tuples, dictionaries, and types from Python's collections module) over custom types (classes). Native types lead to more efficient, readable, and portable code.</li><li class="listitem">Choose keyword arguments over positional arguments in your functions. Argument names are easier to remember than argument ordering. They make your functions self-documenting.</li><li class="listitem">Name your variables carefully. Names of functions and methods should start with a verb. A variable name should describe what it is. A function name should describe what it does. The importance of naming things well cannot be overstated.</li><li class="listitem">Every function should have a docstring describing its purpose, arguments, and return values, as shown in the following example. You can also look at the conventions chosen in popular libraries such as NumPy. The important thing is to be consistent within your code. You can use a markup language such as Markdown or reST:<div class="informalexample"><pre class="programlisting">def power(x, n):
    """Compute the power of a number.

    Arguments:
      * x: a number.
      * n: the exponent.

    Returns:
       * c: the number x to the power of n.

    """
    return x ** n</pre></div></li><li class="listitem">Follow (at least partly) Guido van Rossum's Style Guide for Python, also known as <span class="strong"><strong>Python Enhancement Proposal number 8</strong></span> (<span class="strong"><strong>PEP8</strong></span>), available<a id="id264" class="indexterm"/> at <a class="ulink" href="http://www.python.org/dev/peps/pep-0008/">www.python.org/dev/peps/pep-0008/</a>. It is a long read, but it will help you write well-readable Python code. It covers many little things such as spacing between operators, naming conventions, comments, and <a id="id265" class="indexterm"/>docstrings. For instance, you will learn that it is considered a good practice to limit any line of your code to 79 characters (or 99 exceptionally if that improves readability). This way, your code can be correctly displayed in most situations (such as in a command-line interface or on a mobile device) or side by side with another file. Alternatively, you can decide to ignore certain rules. In general, following common guidelines is beneficial on projects involving many developers.</li><li class="listitem">You can check your code automatically against most of the style conventions in PEP8 with the<a id="id266" class="indexterm"/> <span class="strong"><strong>pep8</strong></span> Python package. Install it with <code class="literal">pip install pep8</code> and execute it with <code class="literal">pep8 myscript.py</code>.</li><li class="listitem">Use a tool for static code analysis such as <a id="id267" class="indexterm"/>Pylint (<a class="ulink" href="http://www.pylint.org">www.pylint.org</a>). It lets you find potential errors or low-quality code <span class="emphasis"><em>statically</em></span>, that is, without running your code.</li><li class="listitem">Use blank lines to avoid cluttering your code (see PEP8). You can also demarcate sections in a long Python module with salient comments like this:<div class="informalexample"><pre class="programlisting"># Imports
# -------
import numpy

# Utility functions
# -----------------
def fun():
    pass</pre></div></li><li class="listitem">A Python module should not contain more than a few hundreds lines of code. Having too many lines of code in a module may be a sign that you need to split it into several modules.</li><li class="listitem">Organize important projects (with tens of modules) into subpackages, for example:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">core/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">io/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">utils/</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">__init__.py</code></li></ul></div></li><li class="listitem">Take a look at<a id="id268" class="indexterm"/> how major Python projects are organized. For example, IPython's code is well-organized into a hierarchy of subpackages with focused roles. Reading the code itself is also quite instructive.</li><li class="listitem">Learn best practices to create and distribute a new Python package. Make sure that you know setuptools, pip, wheels, virtualenv, PyPI, and so on. Also, you are highly encouraged to take a serious look at conda<a id="id269" class="indexterm"/> (<a class="ulink" href="http://conda.pydata.org">http://conda.pydata.org</a>), a powerful and generic packaging system created by Continuum Analytics. Packaging <a id="id270" class="indexterm"/>is a chaotic and rapidly evolving topic in Python, so read only the most recent references. There are a few references in the <span class="emphasis"><em>There's more…</em></span> section.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>How it works...</h2></div></div></div><p>Writing readable code means that other people (or you in a few months or years) will understand it quicker and will be more willing to use it. It also facilitates bug tracking.</p><p>Modular code is also easier to understand and to reuse. Implementing your program's functionality in independent functions that are organized as a hierarchy of packages and modules is an excellent way of achieving high code quality.</p><p>It is easier to keep your code loosely coupled when you use functions instead of classes. Spaghetti code is really hard to understand, debug, and reuse.</p><p>Iterate between bottom-up and top-down approaches while working on a new project. Starting with a bottom-up approach lets you gain experience with the code before you start thinking about the overall architecture of your program. Still, make sure you know where you're going by thinking about how your components will work together.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>There's more...</h2></div></div></div><p>Much has been <a id="id271" class="indexterm"/>written on how to write beautiful code—see the following references. You can find many books on the subject. In the next recipe, we will cover standard techniques to make sure that our code not only looks nice <a id="id272" class="indexterm"/>but also works <a id="id273" class="indexterm"/>as expected: unit <a id="id274" class="indexterm"/>testing, code coverage, and continuous integration.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Python Cookbook</em></span>, by David Beazley and Brian K. Jones, with many Python 3 advanced recipes, available at <a class="ulink" href="http://shop.oreilly.com/product/0636920027072.do">http://shop.oreilly.com/product/0636920027072.do</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The Hitchhiker's Guide to Python!</em></span>, available at <a class="ulink" href="http://docs.python-guide.org/en/latest/">http://docs.python-guide.org/en/latest/</a></li><li class="listitem" style="list-style-type: disc">Design patterns on Wikipedia, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Software_design_pattern">http://en.wikipedia.org/wiki/Software_design_pattern</a></li><li class="listitem" style="list-style-type: disc">Design patterns in Python, described at <a class="ulink" href="https://github.com/faif/python-patterns">https://github.com/faif/python-patterns</a></li><li class="listitem" style="list-style-type: disc">Coding standards of Tahoe-LAFS, available at <a class="ulink" href="https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards">https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>How to be a great software developer</em></span>, by Peter Nixey, available at <a class="ulink" href="http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer">http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Why you should write buggy software with as few features as possible</em></span>, a talk by Brian Granger, available at <a class="ulink" href="http://www.youtube.com/watch?v=OrpPDkZef5I">www.youtube.com/watch?v=OrpPDkZef5I</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>The Hitchhiker's Guide to Packaging</em></span>, available at <a class="ulink" href="http://guide.python-distribute.org">http://guide.python-distribute.org</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Python Packaging User Guide</em></span>, available at <a class="ulink" href="http://python-packaging-user-guide.readthedocs.org">http://python-packaging-user-guide.readthedocs.org</a></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Ten tips for conducting reproducible interactive computing experiments</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing unit tests with nose</em></span> recipe</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing unit tests with nose"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Writing unit tests with nose</h1></div></div></div><p>Manual testing<a id="id275" class="indexterm"/> is essential to ensuring that our software works as expected and does not contain critical bugs. However, manual testing is severely limited because bugs <a id="id276" class="indexterm"/>may be introduced every time a change is made in the code. We <a id="id277" class="indexterm"/>can't possibly expect to manually test our entire program at every commit.</p><p>Nowadays, automated testing<a id="id278" class="indexterm"/> is a standard practice in software engineering. In this recipe, we will briefly cover important aspects of automated testing: unit tests, test-driven development, test coverage, and continuous integration. Following these practices is absolutely necessary in order to produce high-quality software.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>Getting ready</h2></div></div></div><p>Python has a native unit-testing module that you can readily use (<code class="literal">unittest</code>). Other third-party unit testing packages exist, such as py.test or nose, which we have chosen here. nose makes it a bit easier to write a test suite, and it has a library of external plugins. Your users don't need that extra dependency unless they want to run the test suite themselves. You can install nose with <code class="literal">pip install nose</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>How to do it...</h2></div></div></div><p>In this example, we will write a unit test for a function that downloads a file from a URL. A testing suite should run and successfully pass even in the absence of a network connection. We take care of that by fooling Python's <code class="literal">urllib</code> module<a id="id279" class="indexterm"/> with a mock HTTP server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The code snippets used in this recipe have been written for Python 3. A few changes are required to make them work with Python 2, and we have indicated these changes in the code. The versions for Python 2 and Python 3 are both available on the book's website.</p><p>You may also be interested in<a id="id280" class="indexterm"/> the <code class="literal">requests</code> module; it provides a much simpler API for HTTP requests (<a class="ulink" href="http://docs.python-requests.org/en/latest/">http://docs.python-requests.org/en/latest/</a>).</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create <a id="id281" class="indexterm"/>a file <a id="id282" class="indexterm"/>named <code class="literal">datautils.py</code> with the following code:<div class="informalexample"><pre class="programlisting">In [1]: %%writefile datautils.py
# Version 1.
import os
from urllib.request import urlopen  # Python 2: use urllib2

def download(url):
    """Download a file and save it in the current folder.
    Return the name of the downloaded file."""
    # Get the filename.
    file = os.path.basename(url)
    # Download the file unless it already exists.
    if not os.path.exists(file):
        with open(file, 'w') as f:
            f.write(urlopen(url).read())
    return file
Writing datautils.py</pre></div></li><li class="listitem">We create a file named <code class="literal">test_datautils.py</code> with the following code:<div class="informalexample"><pre class="programlisting">In [2]: %%writefile test_datautils.py
# Python 2: use urllib2
from urllib.request import (HTTPHandler, install_opener, 
                            build_opener, addinfourl)
import os
import shutil
import tempfile
from io import StringIO  # Python 2: use StringIO
from datautils import download

TEST_FOLDER = tempfile.mkdtemp()
ORIGINAL_FOLDER = os.getcwd()

class TestHTTPHandler(HTTPHandler):
    """Mock HTTP handler."""
    def http_open(self, req):
        resp = addinfourl(StringIO('test'), '',
                          req.get_full_url(), 200)
        resp.msg = 'OK'
        return resp
    
def setup():
    """Install the mock HTTP handler for unit tests."""
    install_opener(build_opener(TestHTTPHandler))
    os.chdir(TEST_FOLDER)
    
def teardown():
    """Restore the normal HTTP handler."""
    install_opener(build_opener(HTTPHandler))
    # Go back to the original folder.
    os.chdir(ORIGINAL_FOLDER)
    # Delete the test folder.
    shutil.rmtree(TEST_FOLDER)

def test_download1():
    file = download("http://example.com/file.txt")
    # Check that the file has been downloaded.
    assert os.path.exists(file)
    # Check that the file contains the contents of
    # the remote file.
    with open(file, 'r') as f:
        contents = f.read()
    print(contents)
    assert contents == 'test'
Writing test_datautils.py</pre></div></li><li class="listitem">Now, to<a id="id283" class="indexterm"/> launch the tests, we execute the following<a id="id284" class="indexterm"/> command in a terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>Ran 1 test in 0.042s</strong></span>
<span class="strong"><strong>OK</strong></span>
</pre></div></li><li class="listitem">Our first unit test passes! Now, let's add a new test. We add some code at the end of <code class="literal">test_datautils.py</code>:<div class="informalexample"><pre class="programlisting">In [4]: %%writefile test_datautils.py -a
        
        def test_download2():
            file = download("http://example.com/")
            assert os.path.exists(file)
Appending to test_datautils.py</pre></div></li><li class="listitem">We launch the tests again with the <code class="literal">nosetests</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
<span class="strong"><strong>.E</strong></span>
<span class="strong"><strong>ERROR: test_datautils.test_download2</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "datautils.py", line 12, in download</strong></span>
<span class="strong"><strong>    with open(file, 'wb') as f:</strong></span>
<span class="strong"><strong>IOError: [Errno 22] invalid mode ('wb') or filename: ''</strong></span>
<span class="strong"><strong>Ran 2 tests in 0.032s</strong></span>
<span class="strong"><strong>FAILED (errors=1)</strong></span>
</pre></div></li><li class="listitem">The<a id="id285" class="indexterm"/> second test fails. In a real-world scenario, we<a id="id286" class="indexterm"/> might need to debug the program. This should be easy because the bug is isolated in a single test function. Here, by inspecting the traceback error and the code, we find that the bug results from the requested URL not ending with a proper file name. Thus, the inferred file name, <code class="literal">os.path.basename(url)</code>, is empty. Let's fix this by replacing the <code class="literal">download</code> function in <code class="literal">datautils.py</code> with the following function:<div class="informalexample"><pre class="programlisting">In [6]: %%file datautils.py
# Version 2.
import os
from urllib.request import urlopen  # Python 2: use urllib2

def download(url):
    """Download a file and save it in the current folder.
    Return the name of the downloaded file."""
    # Get the filename.
    file = os.path.basename(url)
    # Fix the bug, by specifying a fixed filename if the
    # URL does not contain one.
    if not file:
        file = 'downloaded'
    # Download the file unless it already exists.
    if not os.path.exists(file):
        with open(file, 'w') as f:
            f.write(urlopen(url).read())
    return file
Overwriting datautils.py</pre></div></li><li class="listitem">Finally, let's run the tests again:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
<span class="strong"><strong>..</strong></span>
<span class="strong"><strong>Ran 2 tests in 0.036s</strong></span>
<span class="strong"><strong>OK</strong></span>
</pre></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>By default, <code class="literal">nosetests</code> hides the standard output (unless errors occur). If you want the standard output to show up, use <code class="literal">nosetests --nocapture</code>.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>How it works...</h2></div></div></div><p>A <code class="literal">test_xxx.py</code> module should accompany every Python module named <code class="literal">xxx.py</code>. This testing <a id="id287" class="indexterm"/>module contains functions (unit tests) that execute and<a id="id288" class="indexterm"/> test functionality implemented in the <code class="literal">xxx.py</code> module.</p><p>By definition, a given unit test must focus on one very specific functionality. All unit tests should be completely independent. Writing a program as a collection of well-tested, mostly decoupled units forces you to write modular code that is more easily maintainable.</p><p>However, sometimes your module's functions require preliminary work to run (for example, setting up the environment, creating data files, or setting up a web server). The unit testing framework can handle this; just write <code class="literal">setup()</code> and <code class="literal">teardown()</code> functions (called <a id="id289" class="indexterm"/><span class="strong"><strong>fixtures</strong></span>), and they will be called at the beginning and at the end of the test module, respectively. Note that the state of the system environment should be exactly the same before and after a testing module runs (for example, temporarily created files should be deleted in <code class="literal">teardown</code>).</p><p>Here, the <code class="literal">datautils.py</code> module contains a single function, <code class="literal">download</code>, that accepts a URL as an argument, downloads the file, and saves it locally. This module comes with a testing module named <code class="literal">test_datautils.py</code>. You should choose the same convention in your program (<code class="literal">test_&lt;modulename&gt;</code> for the testing module of <code class="literal">modulename</code>). This testing module contains one or several functions prefixed with <code class="literal">test_</code>. This is how nose automatically discovers the unit tests across your project. nose also accepts other similar conventions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>nose runs all tests it can find in your project, but you can, of course, have more fine-grained control over the tests to run. Type <code class="literal">nosetests --help</code> to get the list of all options. You can also <a id="id290" class="indexterm"/>check out the documentation at <a class="ulink" href="http://nose.readthedocs.org/en/latest/testing.html">http://nose.readthedocs.org/en/latest/testing.html</a>.</p></div></div><p>The testing module also contains the <code class="literal">setup</code> and <code class="literal">teardown</code> functions, which are automatically detected as fixtures by nose. A custom HTTP handler object is created within the <code class="literal">setup</code> function. This object captures all HTTP requests, even those with fictional URLs. The <code class="literal">setup</code> function then moves into a test folder (created with the <code class="literal">tempfile</code> module) to avoid potential conflicts between downloaded files and existing files. In general, unit tests should not leave any trace; this is how we ensure that they are fully reproducible. Likewise, the <code class="literal">teardown</code> function deletes the test folder.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>In Python 3.2 and higher versions, you can also use <code class="literal">tempfile.TemporaryDirectory</code> to create a temporary directory.</p></div></div><p>The first<a id="id291" class="indexterm"/> unit test downloads a file from a mock URL and <a id="id292" class="indexterm"/>checks whether it contains the expected contents. By default, a unit test passes if it does not raise an exception. This is where <code class="literal">assert</code> statements, which raise exceptions if the statement is <code class="literal">False</code>, are useful. nose also comes with convenient routines and decorators for precisely determining the conditions under which a particular unit test is expected to pass or fail (for example, it should raise a particular exception to pass, or it should run in less than <span class="emphasis"><em>X</em></span> seconds, and so on).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Further convenient assert-like functions are provided by<a id="id293" class="indexterm"/> NumPy (see <a class="ulink" href="http://docs.scipy.org/doc/numpy/reference/routines.testing.html">http://docs.scipy.org/doc/numpy/reference/routines.testing.html</a>). They are especially useful when working with arrays. For example, <code class="literal">np.testing.assert_allclose(x, y)</code> asserts that the <code class="literal">x</code> and <code class="literal">y</code> arrays are almost equal, up to a given precision that can be specified.</p></div></div><p>Writing a full testing suite takes time. It imposes strong (but good) constraints on your code's architecture. It's a real investment, but it is always profitable in the long run. Also, knowing that your project is backed by a full testing suite is a real load off your mind.</p><p>First, thinking about unit tests from the beginning forces you to think about a modular architecture. It is really difficult to write unit tests for a monolithic program full of interdependencies.</p><p>Second, unit tests make it easier for you to find and fix bugs. If a unit test fails after introducing a change in the program, isolating and reproducing the bugs becomes trivial.</p><p>Third, unit tests help you avoid <a id="id294" class="indexterm"/><span class="strong"><strong>regressions</strong></span>, that is, fixed bugs that silently reappear in a later version. When you discover a new bug, you should write a specific failing unit test for it. To fix it, make this test pass. Now, if the bug reappears later, this unit test will fail and you will immediately be able to address it.</p><p>Let's say that you write a complex program in several layers, with an <span class="emphasis"><em>n+1</em></span> layer based on an <span class="emphasis"><em>n</em></span> layer. Having a battery of successful unit tests for the <span class="emphasis"><em>n</em></span> layer makes you confident that it works as expected. When working on the <span class="emphasis"><em>n+1</em></span> layer, you can focus on this layer instead of constantly worrying whether the layer below works or not.</p><p>Unit testing is not the whole story, as it just concerns independent components. Further levels of testing are<a id="id295" class="indexterm"/> required in order to ensure good integration of the components<a id="id296" class="indexterm"/> within the program.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>There's more...</h2></div></div></div><p>Unit testing is a wide topic, and we only scratched the surface in this recipe. We give some further information here.</p><div class="section" title="Test coverage"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec17"/>Test coverage</h3></div></div></div><p>Using unit tests is good. However, measuring<a id="id297" class="indexterm"/> <span class="strong"><strong>test coverage</strong></span> is even better: it quantifies how much of our code is being covered by your testing suite. Ned Batchelder's <a id="id298" class="indexterm"/><span class="strong"><strong>coverage</strong></span> module (<a class="ulink" href="http://nedbatchelder.com/code/coverage/">http://nedbatchelder.com/code/coverage/</a>) does precisely this. It integrates very well with nose.</p><p>First, install coverage with <code class="literal">pip install coverage</code>. Then run your testing suite with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests --with-cov --cover-package datautils</strong></span>
</pre></div><p>This command instructs nose to launch your testing suite with coverage measurement for the<a id="id299" class="indexterm"/> <code class="literal">datautils</code> package only.</p><p>The <a class="ulink" href="http://coveralls.io">coveralls.io</a> service<a id="id300" class="indexterm"/> brings test-coverage features to a continuous integration server (refer to the <span class="emphasis"><em>Unit testing and continuous integration</em></span> section). It works seamlessly with GitHub.</p></div><div class="section" title="Workflows with unit testing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec18"/>Workflows with unit testing</h3></div></div></div><p>Note the particular <a id="id301" class="indexterm"/>workflow we have used in this example. After writing our <code class="literal">download</code> function, we created a first unit test that passed. Then we created a second test that failed. We investigated the issue and fixed the function. The second test passed. We could continue writing more and more complex unit tests, until we are confident that the function works as expected in most situations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Run <code class="literal">nosetests --pdb</code> to drop into the Python debugger on failures. This is quite convenient to find out quickly why a unit test fails.</p></div></div><p>This is <a id="id302" class="indexterm"/><span class="strong"><strong>test-driven development</strong></span>, which consists of writing unit tests <span class="emphasis"><em>before</em></span> writing the actual code. This workflow forces us to think about what our code does and how one uses it, instead of how it is implemented.</p></div><div class="section" title="Unit testing and continuous integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec19"/>Unit testing and continuous integration</h3></div></div></div><p>A good habit to get into is running the full testing suite of our project at every commit. In fact, it is even possible to do this completely transparently and automatically through <a id="id303" class="indexterm"/><span class="strong"><strong>continuous integration</strong></span>. We can set up a server that automatically runs our testing suite in the cloud at every commit. If a test fails, we get an automatic e-mail telling us what the problem is so that we can fix it.</p><p>There are many continuous integration systems<a id="id304" class="indexterm"/> and services: Jenkins/Hudson, <a class="ulink" href="https://drone.io">https://drone.io</a>, <a class="ulink" href="http://stridercd.com">http://stridercd.com</a>, <a class="ulink" href="https://travis-ci.org">https://travis-ci.org</a>, and many others. Some of them play well with GitHub projects. For example, to use Travis CI with a GitHub project, create an account on Travis CI, link your GitHub project to this account, and then add a <code class="literal">.travis.yml</code> file with various settings in your repository (see the additional details in the following references).</p><p>In conclusion, unit testing, code coverage, and continuous integration are standard practices that should be used for all significant projects.</p><p>Here are a few references:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Test-driven development, available at <a class="ulink" href="http://en.wikipedia.org/wiki/Test-driven_development">http://en.wikipedia.org/wiki/Test-driven_development</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Untested code is broken code: test automation in enterprise software delivery</em></span>, by Martin Aspeli, available at <a class="ulink" href="http://www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver">www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver</a></li><li class="listitem" style="list-style-type: disc">Documentation of Travis CI in Python, at <a class="ulink" href="http://about.travis-ci.org/docs/user/languages/python/">http://about.travis-ci.org/docs/user/languages/python/</a></li></ul></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Debugging your code with IPython"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Debugging your code with IPython</h1></div></div></div><p>Debugging<a id="id305" class="indexterm"/> is an integral part of software development and interactive computing. A widespread debugging technique consists of placing <code class="literal">print</code> statements in various places in the code. Who hasn't done this? It is probably the simplest solution, but it is certainly not the most efficient (it's the poor man's debugger).</p><p>IPython is perfectly <a id="id306" class="indexterm"/>adapted for debugging, and the integrated debugger<a id="id307" class="indexterm"/> is quite easy to use (actually, IPython merely offers a nice interface to the native Python debugger <code class="literal">pdb</code>). In particular, tab completion works in the IPython debugger. This recipe describes how to debug code with IPython.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Earlier versions of the IPython notebook did not support the debugger, that is, the debugger could be used in the IPython terminal and Qt console, but not in the notebook. This issue was fixed in IPython 1.0.</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>How to do it...</h2></div></div></div><p>There are two <a id="id308" class="indexterm"/>not-mutually exclusive ways of debugging code in <a id="id309" class="indexterm"/>Python. In the post-mortem mode, the debugger steps into the code as soon as an exception is raised so that we can investigate what caused it. In the step-by-step mode, we can stop the interpreter at a breakpoint and resume its execution step by step. This process allows us to check carefully the state of our variables as our code is executed.</p><p>Both methods can actually be used simultaneously; we can do step-by-step debugging in the post-mortem mode.</p><div class="section" title="The post-mortem mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec20"/>The post-mortem mode</h3></div></div></div><p>When an exception is raised within IPython, execute the <code class="literal">%debug</code> magic command to<a id="id310" class="indexterm"/> launch the debugger and step into the code. Also, <a id="id311" class="indexterm"/>the <code class="literal">%pdb on</code> command tells IPython to launch the debugger <a id="id312" class="indexterm"/>automatically as soon as an exception is raised.</p><p>Once you are in the debugger, you have access to several special commands, the most important ones being listed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">p varname</code> <span class="strong"><strong>prints</strong></span> the value of a variable</li><li class="listitem" style="list-style-type: disc"><code class="literal">w</code> shows your current location within the stack</li><li class="listitem" style="list-style-type: disc"><code class="literal">u</code> goes <span class="strong"><strong>up</strong></span> in the stack</li><li class="listitem" style="list-style-type: disc"><code class="literal">d</code> goes <span class="strong"><strong>down</strong></span> in the stack</li><li class="listitem" style="list-style-type: disc"><code class="literal">l</code> shows the <span class="strong"><strong>lines</strong></span> of code around your current location</li><li class="listitem" style="list-style-type: disc"><code class="literal">a</code> shows the <span class="strong"><strong>arguments</strong></span> of the current function</li></ul></div><p>The call stack contains the list of all active functions at a given location in the code's execution. You can easily navigate up and down the stack to inspect the values of the function arguments. Although quite simple to use, this mode should let you resolve most of your bugs. For more complex problems, you may need to do step-by-step debugging.</p></div><div class="section" title="Step-by-step debugging"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec21"/>Step-by-step debugging</h3></div></div></div><p>You have several options to start the <a id="id313" class="indexterm"/>step-by-step debugging mode. First, in order to put a breakpoint somewhere in your code, insert the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import pdb; pdb.set_trace()</strong></span>
</pre></div><p>Second, you can run a script from IPython with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%run -d -b extscript.py:20 script</strong></span>
</pre></div><p>This command runs the <code class="literal">script.py</code> file under the control of the debugger with a breakpoint on line 20 in <code class="literal">extscript.py</code> (which is imported at some point by <code class="literal">script.py</code>). Finally, you can do step-by-step debugging as soon as you are in the debugger.</p><p>Step-by-step debugging consists of precisely controlling the course of the interpreter. Starting from the beginning of a script or from a breakpoint, you can resume the execution of the interpreter with the following commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">s</code> executes the current line and stops as soon as possible afterwards (<span class="strong"><strong>step-by-step</strong></span> debugging, that is, the most fine-grained execution pattern)</li><li class="listitem" style="list-style-type: disc"><code class="literal">n</code> continues the execution until the <span class="strong"><strong>next</strong></span> line in the current function is reached</li><li class="listitem" style="list-style-type: disc"><code class="literal">r</code> continues the execution until the current function <span class="strong"><strong>returns</strong></span></li><li class="listitem" style="list-style-type: disc"><code class="literal">c</code> <span class="strong"><strong>continues</strong></span> the execution until the next breakpoint is reached</li><li class="listitem" style="list-style-type: disc"><code class="literal">j 30</code> brings you to line 30 in the current file</li></ul></div><p>You can add breakpoints dynamically from within the debugger using the <code class="literal">b</code> command or with <code class="literal">tbreak</code> (temporary breakpoint). You can also clear all or some of the breakpoints, enable or disable them, and so on. You<a id="id314" class="indexterm"/> can find the full details of the debugger at <a class="ulink" href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a>.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>There's more...</h2></div></div></div><p>To debug your code with IPython, you typically need to execute it first with IPython, for example, with <code class="literal">%run</code>. However, you may not always have an easy way of doing this. For instance, your program may run with a custom command-line Python script, it may be launched by a complex bash script, or it may be integrated within a GUI. In these cases, you can embed an IPython interpreter at any point in your code (launched by Python), instead of running your whole program with IPython (which may be overkill if you just need to debug a small portion of your code).</p><p>To embed IPython<a id="id315" class="indexterm"/> within your program, simply insert the following commands somewhere in your code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from IPython import embed</strong></span>
<span class="strong"><strong>embed()</strong></span>
</pre></div><p>When your Python program reaches this code, it will pause and launch an interactive IPython terminal at this specific point. You will then be able to inspect all local variables, run any code you want, and possibly debug your code before resuming normal execution.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>rfoo, available at <a class="ulink" href="https://code.google.com/p/rfoo/">https://code.google.com/p/rfoo/</a>, lets you inspect and modify the namespace of a running Python script remotely.</p></div></div><div class="section" title="GUI debuggers"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec22"/>GUI debuggers</h3></div></div></div><p>Most Python IDEs offer graphical<a id="id316" class="indexterm"/> debugging features (see the <span class="emphasis"><em>Efficient interactive computing workflows with IPython</em></span> recipe). A GUI can sometimes be more convenient than a command-line debugger. Let's also mention <a id="id317" class="indexterm"/>Winpdb (<a class="ulink" href="http://winpdb.org">winpdb.org</a>), a graphical platform-independent Python debugger.</p></div></div></div></div>
</body></html>