<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer009">
			</div>
		</div>
		<div class="Content" id="_idContainer010">
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>1. Data Exploration and Cleaning</h1>
		</div>
		<div class="Content" id="_idContainer057">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will take your first steps with Python and Jupyter notebooks, some of the most common tools data scientists use. You'll then take the first look at the dataset for the case study project that will form the core of this book. You will begin to develop an intuition for quality assurance checks that data needs to be put through before model building. By the end of the chapter, you will be able to use pandas, the top package for wrangling tabular data in Python, to do exploratory data analysis, quality assurance, and data cleaning.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Introduction</h1>
			<p>Most businesses possess a wealth of data on their operations and customers. Reporting on this data in the form of descriptive charts, graphs, and tables is a good way to understand the current state of the business. However, in order to provide quantitative guidance on future business strategies and operations, it is necessary to go a step further. This is where the practices of machine learning and predictive modeling are needed. In this book, we will show how to go from descriptive analyses to concrete guidance for future operations, using predictive models.</p>
			<p>To accomplish this goal, we'll introduce some of the most widely used machine learning tools via Python and many of its packages. You will also get a sense of the practical skills necessary to execute successful projects: inquisitiveness when examining data and communication with the client. Time spent looking in detail at a dataset and critically examining whether it accurately meets its intended purpose is time well spent. You will learn several techniques for assessing data quality here.</p>
			<p>In this chapter, after getting familiar with the basic tools for data exploration, we will discuss a few typical working scenarios for how you may receive data. Then, we will begin a thorough exploration of the case study dataset and help you learn how you can uncover possible issues, so that when you are ready for modeling, you may proceed with confidence. </p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Python and the Anaconda Package Management System</h1>
			<p>In this book, we will use the Python programming language. Python is a top language for data science and is one of the fastest-growing programming languages. A commonly cited reason for Python's popularity is that it is easy to learn. If you have Python experience, that's great; however, if you have experience with other languages, such as C, Matlab, or R, you shouldn't have much trouble using Python. You should be familiar with the general constructs of computer programming to get the most out of this book. Examples of such constructs are <strong class="source-inline">for</strong> loops and <strong class="source-inline">if</strong> statements that guide the <strong class="bold">control flow</strong> of a program. No matter what language you have used, you are likely familiar with these constructs, which you will also find in Python.</p>
			<p>A key feature of Python that is different from some other languages is that it is zero-indexed; in other words, the first element of an ordered collection has an index of <strong class="source-inline">0</strong>. Python also supports negative indexing, where the index <strong class="source-inline">-1</strong> refers to the last element of an ordered collection and negative indices count backward from the end. The slice operator, <strong class="source-inline">:</strong>, can be used to select multiple elements of an ordered collection from within a range, starting from the beginning, or going to the end of the collection.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Indexing and the Slice Operator</h2>
			<p>Here, we demonstrate how indexing and the slice operator work. To have something to index, we will create a <strong class="bold">list</strong>, which is a <strong class="bold">mutable</strong> ordered collection that can contain any type of data, including numerical and string types. "Mutable" just means the elements of the list can be changed after they are first assigned. To create the numbers for our list, which will be consecutive integers, we'll use the built-in <strong class="source-inline">range()</strong> Python function. The <strong class="source-inline">range()</strong> function technically creates an <strong class="bold">iterator</strong> that we'll convert to a list using the <strong class="source-inline">list()</strong> function, although you need not be concerned with that detail here. The following screenshot shows a list of the first five positive integers being printed on the console, as well as a few indexing operations, and changing the first item of the list to a new value of a different data type:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer011">
					<img alt="Figure 1.1: List creation and indexing&#13;&#10;" src="image/B16925_01_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: List creation and indexing</p>
			<p>A few things to notice about <em class="italic">Figure 1.1</em>: the endpoint of an interval is open for both slice indexing and the <strong class="source-inline">range()</strong> function, while the starting point is closed. In other words, notice how when we specify the start and end of <strong class="source-inline">range()</strong>, endpoint 6 is not included in the result but starting point 1 is. Similarly, when indexing the list with the slice <strong class="source-inline">[:3]</strong>, this includes all elements of the list with indices up to, but not including, 3.</p>
			<p>We've referred to ordered collections, but Python also includes unordered collections. An important one of these is called a <strong class="bold">dictionary</strong>. A dictionary is an unordered collection of <strong class="bold">key:value</strong> pairs. Instead of looking up the values of a dictionary by integer indices, you look them up by keys, which could be numbers or strings. A dictionary can be created using curly braces <strong class="source-inline">{}</strong> and with the <strong class="bold">key:value</strong> pairs separated by commas. The following screenshot is an example of how we can create a dictionary with counts of fruit – examine the number of apples, then add a new type of fruit and its count:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 1.2: An example dictionary&#13;&#10;" src="image/B16925_01_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: An example dictionary</p>
			<p>There are many other distinctive features of Python and we just want to give you a flavor here, without getting into too much detail. In fact, you will probably use packages such as <strong class="bold">pandas</strong> (<strong class="source-inline">pandas</strong>) and <strong class="bold">NumPy</strong> (<strong class="source-inline">numpy</strong>) for most of your data handling in Python. NumPy provides fast numerical computation on arrays and matrices, while pandas provides a wealth of data wrangling and exploration capabilities on tables of data called <strong class="bold">DataFrames</strong>. However, it's good to be familiar with some of the basics of Python—the language that sits at the foundation of all of this. For example, indexing works the same in NumPy and pandas as it does in Python.</p>
			<p>One of the strengths of Python is that it is open source and has an active community of developers creating amazing tools. We will use several of these tools in this book. A potential pitfall of having open source packages from different contributors is the dependencies between various packages. For example, if you want to install pandas, it may rely on a certain version of NumPy, which you may or may not have installed. Package management systems make life easier in this respect. When you install a new package through the package management system, it will ensure that all the dependencies are met. If they aren't, you will be prompted to upgrade or install new packages as necessary.</p>
			<p>For this book, we will use the <strong class="bold">Anaconda</strong> package management system, which you should already have installed. While we will only use Python here, it is also possible to run R with Anaconda. </p>
			<p class="callout-heading">Note: Environments</p>
			<p class="callout">It is recommended to create a new Python 3.x environment for this book. Environments are like separate installations of Python, where the set of packages you have installed can be different, as well as the version of Python. Environments are useful for developing projects that need to be deployed in different versions of Python, possibly with different dependencies. For general information on this, see <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html</a>. See the <em class="italic">Preface</em> for specific instructions on setting up an Anaconda environment for this book before you begin the upcoming exercises.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Exercise 1.01: Examining Anaconda and Getting Familiar with Python</h2>
			<p>In this exercise, you will examine the packages in your Anaconda installation and practice with some basic Python control flow and data structures, including a <strong class="source-inline">for</strong> loop, <strong class="source-inline">dict</strong>, and <strong class="source-inline">list</strong>. This will confirm that you have completed the installation steps in the preface and show you how Python syntax and data structures may be a little different from other programming languages you may be familiar with. Perform the following steps to complete the exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before executing the exercises and the activity in this chapter, please make sure you have followed the instructions regarding setting up your Python environment as mentioned in the <em class="italic">Preface</em>. The code file for this exercise can be found here: <a href="https://packt.link/N0RPT">https://packt.link/N0RPT</a>.</p>
			<ol>
				<li>Open up Terminal, if you're using macOS or Linux, or a Command Prompt window in Windows. If you're using an environment, activate it using <strong class="source-inline">conda activate &lt;name_of_your_environment&gt;</strong>. Then type <strong class="source-inline">conda</strong> <strong class="source-inline">list</strong> at the command line. You should observe an output similar to the following:<div class="IMG---Figure" id="_idContainer013"><img alt="Figure 1.3: Selection of packages from conda list&#13;&#10;" src="image/B16925_01_03.jpg"/></div><p class="figure-caption">Figure 1.3: Selection of packages from conda list</p><p>You can see all the packages installed in your environment, including the packages we will directly interact with, as well as their dependencies which are needed for them to function. Managing dependencies among packages is one of the main advantages of a package management system.</p><p class="callout-heading">Note</p><p class="callout">For more information about Anaconda and command-line interaction, check out this "cheat sheet": <a href="https://docs.conda.io/projects/conda/en/latest/_downloads/843d9e0198f2a193a3484886fa28163c/conda-cheatsheet.pdf">https://docs.conda.io/projects/conda/en/latest/_downloads/843d9e0198f2a193a3484886fa28163c/conda-cheatsheet.pdf</a>.</p></li>
				<li>Type <strong class="source-inline">python</strong> in Terminal to open a command-line Python interpreter. You should obtain an output similar to the following:<div class="IMG---Figure" id="_idContainer014"><img alt="Figure 1.4: Command-line Python&#13;&#10;" src="image/B16925_01_04.jpg"/></div><p class="figure-caption">Figure 1.4: Command-line Python</p><p>You should see some information about your version of Python, as well as the Python Command Prompt (<strong class="source-inline">&gt;&gt;&gt;</strong>). When you type after this prompt, you are writing Python code. </p><p class="callout-heading">Note</p><p class="callout">Although we will be using the Jupyter notebook in this book, one of the aims of this exercise is to go through the basic steps of writing and running Python programs on the Command Prompt.</p></li>
				<li>Write a <strong class="source-inline">for</strong> loop at the Command Prompt to print values from 0 to 4 using the following code (note that the three dots at the beginning of the second and third lines appear automatically if you are writing code in the command-line Python interpreter; if you're instead writing in a Jupyter notebook, these won't appear): <p class="source-code">for counter in range(5):</p><p class="source-code">...    print(counter)</p><p class="source-code">... </p><p>Once you hit <em class="italic">Enter</em> when you see <strong class="source-inline">...</strong> on the prompt, you should obtain this output:</p><div class="IMG---Figure" id="_idContainer015"><img alt="Figure 1.5: Output of a for loop at the command line&#13;&#10;" src="image/B16925_01_05.jpg"/></div><p class="figure-caption">Figure 1.5: Output of a for loop at the command line</p><p>Notice that in Python, the opening of the <strong class="source-inline">for</strong> loop is followed by a colon, and <strong class="bold">the body of the loop requires indentation</strong>. It's typical to use four spaces to indent a code block. Here, the <strong class="source-inline">for</strong> loop prints the values returned by the <strong class="source-inline">range()</strong> iterator, having repeatedly accessed them using the <strong class="source-inline">counter</strong> variable with the <strong class="source-inline">in</strong> keyword.</p><p class="callout-heading">Note</p><p class="callout">For many more details on Python code conventions, refer to the following: <a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a>.</p><p>Now, we will return to our dictionary example. The first step here is to create the dictionary.</p></li>
				<li>Create a dictionary of fruits (<strong class="source-inline">apples</strong>, <strong class="source-inline">oranges</strong>, and <strong class="source-inline">bananas</strong>) using the following code:<p class="source-code">example_dict = {'apples':5, 'oranges':8, 'bananas':13}</p></li>
				<li>Convert the dictionary to a list using the <strong class="source-inline">list()</strong> function, as shown in the following snippet:<p class="source-code">dict_to_list = list(example_dict)</p><p class="source-code">dict_to_list</p><p>Once you run the preceding code, you should obtain the following output:</p><p class="source-code">['apples', 'oranges', 'bananas']</p><p>Notice that when this is done and we examine the contents, only the keys of the dictionary have been captured in the list. If we wanted the values, we would have had to specify that with the <strong class="source-inline">.values()</strong> method of the list. Also, notice that the list of dictionary keys happens to be in the same order that we wrote them when creating the dictionary. This is not guaranteed, however, as dictionaries are unordered collection types.</p><p>One convenient thing you can do with lists is to append other lists to them with the <strong class="source-inline">+</strong> operator. As an example, in the next step, we will combine the existing list of fruit with a list that contains just one more type of fruit, overwriting the variable containing the original list, like this: <strong class="source-inline">list(example_dict.values());</strong> the interested readers can confirm this for themselves.</p></li>
				<li>Use the <strong class="source-inline">+</strong> operator to combine the existing list of fruits with a new list containing only one fruit (<strong class="source-inline">pears</strong>):<p class="source-code">dict_to_list = dict_to_list + ['pears']</p><p class="source-code">dict_to_list</p><p>Your output will be as follows:</p><p class="source-code">['apples', 'oranges', 'bananas', 'pears']</p><p><strong class="bold">What if we wanted to sort our list of fruit types?</strong></p><p>Python provides a built-in <strong class="source-inline">sorted()</strong> function that can be used for this; it will return a sorted version of the input. In our case, this means the list of fruit types will be sorted alphabetically.</p></li>
				<li>Sort the list of fruits in alphabetical order using the <strong class="source-inline">sorted()</strong> function, as shown in the following snippet:<p class="source-code">sorted(dict_to_list)</p><p>Once you run the preceding code, you should see the following output:</p><p class="source-code">['apples', 'bananas', 'oranges', 'pears']</p></li>
			</ol>
			<p>That's enough Python for now. We will show you how to execute the code for this book, so your Python knowledge should improve along the way. While you have the Python interpreter open, you may wish to run the code examples shown in <em class="italic">Figures 1.1</em> and <em class="italic">1.2</em>. When you're done with the interpreter, you can type <strong class="source-inline">quit()</strong> to exit.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As you learn more and inevitably want to try new things, consult the official Python documentation: <a href="https://docs.python.org/3/">https://docs.python.org/3/</a>.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Different Types of Data Science Problems</h1>
			<p>Much of your time as a data scientist is likely to be spent wrangling data: figuring out how to get it, getting it, examining it, making sure it's correct and complete, and joining it with other types of data. pandas is a widely used tool for data analysis in Python, and it can facilitate the data exploration process for you, as we will see in this chapter. However, one of the key goals of this book is to start you on your journey to becoming a machine learning data scientist, for which you will need to master the art and science of <strong class="bold">predictive modeling</strong>. This means using a mathematical model, or idealized mathematical formulation, to learn relationships within the data, in the hope of making accurate and useful predictions when new data comes in.</p>
			<p>For predictive modeling use cases, data is typically organized in a tabular structure, with <strong class="bold">features</strong> and a <strong class="bold">response variable</strong>. For example, if you want to predict the price of a house based on some characteristics about it, such as <strong class="bold">area</strong> and <strong class="bold">number of bedrooms</strong>, these attributes would be considered the features and the <strong class="bold">price of the house</strong> would be the response variable. The response variable is sometimes called the <strong class="bold">target variable</strong> or <strong class="bold">dependent variable</strong>, while the features may also be called the <strong class="bold">independent variables</strong>.</p>
			<p>If you have a dataset of 1,000 houses including the values of these features and the prices of the houses, you can say you have 1,000 <strong class="bold">samples</strong> of <strong class="bold">labeled</strong> data, where the labels are the known values of the response variable: the prices of different houses. Most commonly, the tabular data structure is organized so that different rows are different samples, while features and the response occupy different columns, along with other metadata such as sample IDs, as shown in <em class="italic">Figure 1.6</em>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 1.6: Labeled data (the house prices are the known target variable)&#13;&#10;" src="image/B16925_01_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6: Labeled data (the house prices are the known target variable)</p>
			<p><strong class="bold">Regression Problem</strong></p>
			<p>Once you have trained a model to learn the relationship between the features and response using your labeled data, you can then use it to make predictions for houses where you don't know the price, based on the information contained in the features. The goal of predictive modeling in this case is to be able to make a prediction that is close to the true value of the house. Since we are predicting a numerical value on a continuous scale, this is called a <strong class="bold">regression problem</strong>.</p>
			<p><strong class="bold">Classification Problem</strong></p>
			<p>On the other hand, if we were trying to make a qualitative prediction about the house, to answer a <strong class="bold">yes</strong> or <strong class="bold">no</strong> question such as "will this house go on sale within the next 5 years?" or "will the owner default on the mortgage?", we would be solving what is known as a <strong class="bold">classification problem</strong>. Here, we would hope to answer the yes or no question correctly. The following figure is a schematic illustrating how model training works, and what the outcomes of regression or classification models might be:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 1.7: Schematic of model training and prediction for regression and classification&#13;&#10;" src="image/B16925_01_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7: Schematic of model training and prediction for regression and classification</p>
			<p>Classification and regression tasks are called <strong class="bold">supervised learning</strong>, which is a class of problems that relies on labeled data. These problems can be thought of as needing "supervision" by the known values of the target variable. By contrast, there is also <strong class="bold">unsupervised learning</strong>, which relates to more open-ended questions of trying to find some sort of structure in a dataset that does not necessarily have labels. Taking a broader view, any kind of applied math problem, including fields as varied as <strong class="bold">optimization</strong>, <strong class="bold">statistical inference</strong>, and <strong class="bold">time series modeling</strong>, may potentially be considered an appropriate responsibility for a data scientist.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Loading the Case Study Data with Jupyter and pandas</h1>
			<p>Now it's time to take a first look at the data we will use in our case study. We won't do anything in this section other than ensure that we can load the data into a <strong class="bold">Jupyter notebook</strong> correctly. Examining the data, and understanding the problem you will solve with it, will come later.</p>
			<p>The data file is an Excel spreadsheet called <strong class="source-inline">default_of_credit_card_clients__courseware_version_1_21_19.xls</strong>. We recommend you first open the spreadsheet in Excel or the spreadsheet program of your choice. Note the number of rows and columns. Look at some example values. This will help you know whether or not you have loaded it correctly in the Jupyter notebook.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The dataset can be obtained from the following link: <a href="https://packt.link/wensZ">https://packt.link/wensZ</a>. This is a modified version of the original dataset, which has been sourced from the UCI Machine Learning Repository [<a href="http://archive.ics.uci.edu/ml">http://archive.ics.uci.edu/ml</a>]. Irvine, CA: University of California, School of Information and Computer Science. </p>
			<p><strong class="bold">What is a Jupyter notebook? </strong></p>
			<p>Jupyter notebooks are interactive coding environments that allow for inline text and graphics. They are great tools for data scientists to communicate and preserve their results, since both the methods (code) and the message (text and graphics) are integrated. You can think of the environment as a kind of web page where you can write and execute code. Jupyter notebooks can, in fact, be rendered as web pages, as is done on GitHub. Here is an example notebook: <a href="https://packt.link/pREet">https://packt.link/pREet</a>. Look it over and get a sense of what you can do. An excerpt from this notebook is displayed here, showing code, graphics, and prose, which is known as <strong class="bold">Markdown</strong> in this context:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 1.8: Example of a Jupyter notebook showing code, graphics, and Markdown text&#13;&#10;" src="image/B16925_01_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8: Example of a Jupyter notebook showing code, graphics, and Markdown text</p>
			<p>One of the first things to learn about Jupyter notebooks is how to navigate around and make edits. There are two modes available to you. If you select a cell and press <em class="italic">Enter</em>, you are in <strong class="bold">edit mode</strong> and you can edit the text in that cell. If you press <em class="italic">Esc</em>, you are in <strong class="bold">command mode</strong> and you can navigate around the notebook.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're reading the print version of this book, you can download and browse the color versions of some of the images in this chapter by visiting the following link: <a href="https://packt.link/T5EIH">https://packt.link/T5EIH</a>.</p>
			<p>When you are in command mode, there are many useful hotkeys you can use. The <em class="italic">Up</em> and <em class="italic">Down</em> arrows will help you select different cells and scroll through the notebook. If you press <em class="italic">y</em> on a selected cell in command mode, it changes it to a <strong class="bold">code cell</strong>, in which the text is interpreted as code. Pressing <em class="italic">m</em> changes it to a <strong class="bold">Markdown cell</strong>, where you can write formatted text. <em class="italic">Shift</em> + <em class="italic">Enter</em> evaluates the cell, rendering the Markdown or executing the code, as the case may be. You'll get some practice with a Jupyter notebook in the next exercise.</p>
			<p>Our first task in our first Jupyter notebook will be to load the case study data. To do this, we will use a tool called <strong class="bold">pandas</strong>. It is probably not a stretch to say that pandas is the pre-eminent data-wrangling tool in Python.</p>
			<p>A DataFrame is a foundational class in pandas. We'll talk more about what a class is later, but you can think of it as a template for a data structure, where a data structure is something like the lists or dictionaries we discussed earlier. However, a DataFrame is much richer in functionality than either of these. A DataFrame is similar to spreadsheets in many ways. There are rows, which are labeled by a row index, and columns, which are usually given column header-like labels that can be thought of as a column index. <strong class="source-inline">Index</strong> is, in fact, a data type in pandas used to store indices for a DataFrame, and columns have their own data type called <strong class="source-inline">Series</strong>.</p>
			<p>You can do a lot of the same things with a DataFrame that you can do with Excel sheets, such as creating pivot tables and filtering rows. pandas also includes SQL-like functionality. You can join different DataFrames together, for example. Another advantage of DataFrames is that once your data is contained in one of them, you have the capabilities of a wealth of pandas functionality at your fingertips, for data analysis. The following figure is an example of a pandas DataFrame:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 1.9: Example of a pandas DataFrame with an integer row index at the left and a column index of strings&#13;&#10;" src="image/B16925_01_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9: Example of a pandas DataFrame with an integer row index at the left and a column index of strings</p>
			<p>The example in <em class="italic">Figure 1.9</em> is in fact the data for the case study. As the first step with Jupyter and pandas, we will now see how to create a Jupyter notebook and load data with pandas. There are several convenient functions you can use in pandas to explore your data, including <strong class="source-inline">.head()</strong> to see the first few rows of the DataFrame, <strong class="source-inline">.info()</strong> to see all columns with datatypes, <strong class="source-inline">.columns</strong> to return a list of column names as strings, and others we will learn about in the following exercises.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Exercise 1.02: Loading the Case Study Data in a Jupyter Notebook</h2>
			<p>Now that you've learned about Jupyter notebooks, the environment in which we'll write code, and pandas, the data wrangling package, let's create our first Jupyter notebook. We'll use pandas within this notebook to load the case study data and briefly examine it. Perform the following steps to complete the exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook for this exercise can be found at <a href="https://packt.link/GHPSn">https://packt.link/GHPSn</a>.</p>
			<ol>
				<li value="1">Open a Terminal (macOS or Linux) or a Command Prompt window (Windows) and type <strong class="source-inline">jupyter notebook</strong> (first activating your Anaconda environment if you're using one).<p>You will be presented with the Jupyter interface in your web browser. If the browser does not open automatically, copy and paste the URL from the Terminal into your browser. In this interface, you can navigate around your directories starting from the directory you were in when you launched the notebook server. </p></li>
				<li>Navigate to a convenient location where you will store the materials for this book, and create a new Python 3 notebook from the <strong class="bold">New</strong> menu, as shown here:<div class="IMG---Figure" id="_idContainer020"><img alt="Figure 1.10: Jupyter home screen&#13;&#10;" src="image/B16925_01_10.jpg"/></div><p class="figure-caption">Figure 1.10: Jupyter home screen</p></li>
				<li>Make your very first cell a Markdown cell by typing <em class="italic">m</em> while in command mode (press <em class="italic">Esc</em> to enter command mode), then type a number sign, <strong class="source-inline">#</strong>, at the beginning of the first line, followed by a space, for a heading. Add a title for your notebook here. On the next few lines, place a description. <p>Here is a screenshot of an example, including other kinds of Markdown such as bold, italics, and the way to write code-style text in a Markdown cell:</p><div class="IMG---Figure" id="_idContainer021"><img alt="Figure 1.11: Unrendered Markdown cell&#13;&#10;" src="image/B16925_01_11.jpg"/></div><p class="figure-caption">Figure 1.11: Unrendered Markdown cell</p><p>Note that it is good practice to add a title and brief description for your notebook, to identify its purpose to readers.</p></li>
				<li>Press <em class="italic">Shift</em> + <em class="italic">Enter</em> to render the Markdown cell. <p>This should also create a new cell, which will be a code cell. You can change it to a Markdown cell by pressing <em class="italic">m</em>, and back to a code cell by pressing <em class="italic">y</em>. You will know it's a code cell because of the <strong class="source-inline">In [ ]:</strong> next to it. </p></li>
				<li>Type <strong class="source-inline">import</strong> <strong class="source-inline">pandas</strong> <strong class="source-inline">as</strong> <strong class="source-inline">pd</strong> in the new cell, as shown in the following screenshot:<div class="IMG---Figure" id="_idContainer022"><img alt="Figure 1.12: Rendered Markdown cell and code cell&#13;&#10;" src="image/B16925_01_12.jpg"/></div><p class="figure-caption">Figure 1.12: Rendered Markdown cell and code cell</p><p>After you execute this cell, the <strong class="source-inline">pandas</strong> module will be loaded into your computing environment. It's common to import modules with <strong class="source-inline">as</strong> to create a short alias such as <strong class="source-inline">pd</strong>. Now, we are going to use pandas to load the data file. It's in Microsoft Excel format, so we can use <strong class="source-inline">pd.read_excel</strong>. </p><p class="callout-heading">Note</p><p class="callout">For more information on all the possible options for <strong class="source-inline">pd.read_excel</strong>, refer to the following documentation: <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html</a>. </p></li>
				<li>Import the dataset, which is in the Excel format, as a DataFrame using the <strong class="source-inline">pd.read_excel()</strong> method, as shown in the following snippet:<p class="source-code">df = pd.read_excel('../../Data/default_of_credit_card_clients'\</p><p class="source-code">                   '__courseware_version_1_21_19.xls')</p><p>Note that you need to point the Excel reader to wherever the file is located. If it's in the same directory as your notebook, you could just enter the filename. The <strong class="source-inline">pd.read_excel</strong> method will load the Excel file into a <strong class="source-inline">DataFrame</strong>, which we've called <strong class="source-inline">df</strong>. By default, the first sheet of the spreadsheet is loaded, which in this case is the only sheet. The power of pandas is now available to us. </p><p>Let's do some quick checks in the next few steps. First, does the number of rows and columns match what we know from looking at the file in Excel? </p></li>
				<li>Use the <strong class="source-inline">.shape</strong> method to review the number of rows and columns, as shown in the following snippet:<p class="source-code">df.shape</p><p>Once you run the cell, you will obtain the following output:</p><p class="source-code">Out[3]: (30000, 25)</p><p>This should match your observations from the spreadsheet. If it doesn't, you would then need to look into the various options of <strong class="source-inline">pd.read_excel</strong> to see if you needed to adjust something.</p></li>
			</ol>
			<p>With this exercise, we have successfully loaded our dataset into the Jupyter notebook. You may also wish to try the <strong class="source-inline">.info()</strong> and <strong class="source-inline">.head()</strong> methods on the DataFrame, which will tell you information about all the columns, and show you the first few rows of the <strong class="source-inline">DataFrame</strong>, respectively. Now you're up and running with your data in pandas.</p>
			<p>As a final note, while this may already be clear, observe that if you define a variable in one code cell, it is available to you in other code cells within the notebook. This is because the code cells within a notebook are said to share <strong class="bold">scope</strong> as long as the notebook is running, as shown in the following screenshot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 1.13: Variable in scope between cells&#13;&#10;" src="image/B16925_01_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: Variable in scope between cells</p>
			<p>Every time you launch a Jupyter notebook, while the code and markdown cells are saved from your previous work, the environment starts fresh and you will need to reload all modules and data to start working with them again. You can also shut down or restart the notebook manually using the <strong class="bold">Kernel</strong> menu of the notebook. More details on Jupyter notebooks can be found in the documentation here: <a href="https://jupyter-notebook.readthedocs.io/en/stable/">https://jupyter-notebook.readthedocs.io/en/stable/</a>.</p>
			<p class="callout-heading">note</p>
			<p class="callout">In this book, each new exercise and activity will be done in a new Jupyter notebook. However, some exercise notebooks also contain additional Python code and outputs presented in the sections preceding the exercises. There are also reference notebooks that contain the entirety of each chapter. For example, the notebook for <em class="italic">Chapter 1</em>, <em class="italic">Data Exploration and Cleaning</em>, can be found here: <a href="https://packt.link/zwofX">https://packt.link/zwofX</a>. </p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Getting Familiar with Data and Performing Data Cleaning</h2>
			<p>Now let's take a first look at this data. In your work as a data scientist, there are several possible scenarios in which you may receive such a dataset. These include the following:</p>
			<ol>
				<li value="1">You created the SQL query that generated the data.</li>
				<li>A colleague wrote a SQL query for you, with your input.</li>
				<li>A colleague who knows about the data gave it to you, but without your input.</li>
				<li>You are given a dataset about which little is known. </li>
			</ol>
			<p>In cases 1 and 2, your input was involved in generating/extracting the data. In these scenarios, you probably understood the business problem and then either found the data you needed with the help of a data engineer or did your own research and designed the SQL query that generated the data. Often, especially as you gain more experience in your data science role, the first step will be to meet with the business partner to understand and refine the mathematical definition of the business problem. Then, you would play a key role in defining what is in the dataset.</p>
			<p>Even if you have a relatively high level of familiarity with the data, doing data exploration and looking at <strong class="bold">summary statistics</strong> of different variables is still an important first step. This step will help you select good features, or give you ideas about how you can engineer new features. However, in the third and fourth cases, where your input was not involved or you have little knowledge about the data, data exploration is even more important.</p>
			<p>Another important initial step in the data science process is examining the <strong class="bold">data dictionary</strong>. A data dictionary is a document that explains what the data owner thinks should be in the data, such as definitions of the column labels. It is the data scientist's job to go through the data carefully to make sure that these definitions match the reality of what is in the data. In cases 1 and 2, you will probably need to create the data dictionary yourself, which should be considered essential project documentation. In cases 3 and 4, you should seek out the dictionary if at all possible.</p>
			<p>The case study data we'll use in this book is similar to case 3 here.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>The Business Problem</h2>
			<p>Our client is a credit card company. They have brought us a dataset that includes some demographics and recent financial data, over the past 6 months, for a sample of 30,000 of their account holders. This data is at the credit account level; in other words, there is one row for each account (you should always clarify what the definition of a row is, in a dataset). Rows are labeled by whether, in the next month after the 6-month historical data period, an account owner has defaulted, or in other words, failed to make the minimum payment.</p>
			<p><strong class="bold">Goal</strong></p>
			<p>Your goal is to develop a predictive model for whether an account will default next month, given demographics and historical data. Later in the book, we'll discuss the practical application of the model.</p>
			<p>The data is already prepared, and a data dictionary is available. The dataset supplied with the book, <strong class="source-inline">default_of_credit_card_clients__courseware_version_1_21_19.xls</strong>, is a modified version of this dataset in the UCI Machine Learning Repository: <a href="https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients">https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients</a>. Have a look at that web page, which includes the data dictionary. </p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Data Exploration Steps </h2>
			<p>Now that we've understood the business problem and have an idea of what is supposed to be in the data, we can compare these impressions to what we actually see in the data. Your job in data exploration is to not only look through the data both directly and using numerical and graphical summaries but also to think critically about whether the data make sense and match what you have been told about it. These are helpful steps in data exploration:</p>
			<ol>
				<li value="1">How many columns are there in the data?<p>These may be features, responses, or metadata.</p></li>
				<li>How many rows (samples) are there?</li>
				<li>What kind of features are there? Which are <strong class="bold">categorical</strong> and which are <strong class="bold">numerical</strong>?<p>Categorical features have values in discrete classes such as "Yes," "No," or "Maybe."</p><p>Numerical features are typically on a continuous numerical scale, such as dollar amounts.</p></li>
				<li>What does the data look like in these features?<p>To see this, you can examine the range of values in numeric features, or the frequency of different classes in categorical features, for example.</p></li>
				<li>Is there any missing data?</li>
			</ol>
			<p>We have already answered questions 1 and 2 in the previous section; there are 30,000 rows and 25 columns. As we start to explore the rest of these questions in the following exercise, pandas will be our go-to tool. We begin by verifying basic data integrity in the next exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that compared to the website's description of the data dictionary, <strong class="source-inline">X6</strong>-<strong class="source-inline">X11</strong> are called <strong class="source-inline">PAY_1</strong>-<strong class="source-inline">PAY_6</strong> in our data. Similarly, <strong class="source-inline">X12</strong>-<strong class="source-inline">X17</strong> are <strong class="source-inline">BILL_AMT1</strong>-<strong class="source-inline">BILL_AMT6</strong>, and <strong class="source-inline">X18</strong>-<strong class="source-inline">X23</strong> are <strong class="source-inline">PAY_AMT1</strong>-<strong class="source-inline">PAY_AMT6</strong>.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Exercise 1.03: Verifying Basic Data Integrity</h2>
			<p>In this exercise, we will perform a basic check on whether our dataset contains what we expect and verify whether there is the correct number of samples. </p>
			<p>The data is supposed to have observations for 30,000 credit accounts. While there are 30,000 rows, we should also check whether there are 30,000 unique account IDs. It's possible that, if the SQL query used to generate the data was run on an unfamiliar schema, values that are supposed to be unique are in fact not unique. </p>
			<p>To examine this, we can check if the number of unique account IDs is the same as the number of rows. Perform the following steps to complete the exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook for this exercise can be found here: <a href="https://packt.link/EapDM">https://packt.link/EapDM</a>.</p>
			<ol>
				<li value="1">Import pandas, load the data, and examine the column names by running the following command in a cell, using <em class="italic">Shift</em> + <em class="italic">Enter</em>: <p class="source-code">import pandas as pd</p><p class="source-code">df = pd.read_excel('../Data/default_of_credit_card'\</p><p class="source-code">                   '_clients__courseware_version_1_21_19.xls')</p><p class="source-code">df.columns</p><p>The <strong class="source-inline">.columns</strong> method of the DataFrame is employed to examine all the column names. You will obtain the following output once you run the cell: </p><div class="IMG---Figure" id="_idContainer024"><img alt="Figure 1.14: Columns of the dataset&#13;&#10;" src="image/B16925_01_14.jpg"/></div><p class="figure-caption">Figure 1.14: Columns of the dataset</p><p>As can be observed, all column names are listed in the output. The account ID column is referenced as <strong class="source-inline">ID</strong>. The remaining columns appear to be our features, with the last column being the response variable. Let's quickly review the dataset information that was given to us by the client:</p><p><strong class="source-inline">LIMIT_BAL</strong>: Amount of credit provided (in New Taiwanese (NT) dollar) including individual consumer credit and the family (supplementary) credit. </p><p><strong class="source-inline">SEX</strong>: Gender (1 = male; 2 = female).</p><p class="callout-heading">Note</p><p class="callout">We will not be using the gender data to decide credit-worthiness owing to ethical considerations.</p><p><strong class="source-inline">EDUCATION</strong>: Education (1 = graduate school; 2 = university; 3 = high school; 4 = others). </p><p><strong class="source-inline">MARRIAGE</strong>: Marital status (1 = married; 2 = single; 3 = others). </p><p><strong class="source-inline">AGE</strong>: Age (year). </p><p><strong class="source-inline">PAY_1</strong>–<strong class="source-inline">PAY_6</strong>: A record of past payments. Past monthly payments, recorded from April to September, are stored in these columns. </p><p><strong class="source-inline">PAY_1</strong> represents the repayment status in September; <strong class="source-inline">PAY_2</strong> is the repayment status in August; and so on up to <strong class="source-inline">PAY_6</strong>, which represents the repayment status in April. </p><p>The measurement scale for the repayment status is as follows: -1 = pay duly; 1 = payment delay for 1 month; 2 = payment delay for 2 months; and so on up to 8 = payment delay for 8 months; 9 = payment delay for 9 months and above. </p><p><strong class="source-inline">BILL_AMT1</strong>–<strong class="source-inline">BILL_AMT6</strong>: Bill statement amount (in NT dollar). </p><p><strong class="source-inline">BILL_AMT1</strong> represents the bill statement amount in September; <strong class="source-inline">BILL_AMT2</strong> represents the bill statement amount in August; and so on up to <strong class="source-inline">BILL_AMT6</strong>, which represents the bill statement amount in April. </p><p><strong class="source-inline">PAY_AMT1</strong>–<strong class="source-inline">PAY_AMT6</strong>: Amount of previous payment (NT dollar). <strong class="source-inline">PAY_AMT1</strong> represents the amount paid in September; <strong class="source-inline">PAY_AMT2</strong> represents the amount paid in August; and so on up to <strong class="source-inline">PAY_AMT6</strong>, which represents the amount paid in April. </p><p>Let's now use the <strong class="source-inline">.head()</strong> method in the next step to observe the first few rows of data. By default, this will return the first 5 rows.</p></li>
				<li>Run the following command in the subsequent cell:<p class="source-code">df.head()</p><p>Here is a portion of the output you should see:</p><div class="IMG---Figure" id="_idContainer025"><img alt="Figure 1.15: .head() of a DataFrame&#13;&#10;" src="image/B16925_01_15.jpg"/></div><p class="figure-caption">Figure 1.15: .head() of a DataFrame</p><p>The ID column seems like it contains unique identifiers. Now, to verify whether they are in fact unique throughout the whole dataset, we can count the number of unique values using the <strong class="source-inline">.nunique()</strong> method on the Series (aka column) <strong class="source-inline">ID</strong>. We first select the column using square brackets.</p></li>
				<li>Select the column (<strong class="source-inline">ID</strong>) and count unique values using the following command: <p class="source-code">df['ID'].nunique()</p><p>Here's the output:</p><p class="source-code">29687</p><p>As can be seen from the preceding output, the number of unique entries is <strong class="source-inline">29,687</strong>.</p></li>
				<li>Run the following command to obtain the number of rows in the dataset: <p class="source-code">df.shape </p><p>As can be observed in the following output, the total number of rows in the dataset is <strong class="source-inline">30,000</strong>:</p><p class="source-code">(30000, 25)</p><p>We see here that the number of unique IDs is less than the number of rows. This implies that the ID is not a unique identifier for the rows of the data. So we know that there is some duplication of IDs. But how much? Is one ID duplicated many times? How many IDs are duplicated? </p><p>We can use the <strong class="source-inline">.value_counts()</strong> method on the ID Series to start to answer these questions. This is similar to a <strong class="bold">group by/count</strong> procedure in SQL. It will list the unique IDs and how often they occur. We will perform this operation in the next step and store the value counts in the <strong class="source-inline">id_counts</strong> variable.</p></li>
				<li>Store the value counts in the variable defined as <strong class="source-inline">id_counts</strong> and then display the stored values using the <strong class="source-inline">.head()</strong> method, as shown:<p class="source-code">id_counts = df['ID'].value_counts()</p><p class="source-code">id_counts.head()</p><p>You will obtain the following output:</p><div class="IMG---Figure" id="_idContainer026"><img alt="Figure 1.16: Getting value counts of the account IDs&#13;&#10;" src="image/B16925_01_16.jpg"/></div><p class="figure-caption">Figure 1.16: Getting value counts of the account IDs</p><p>Note that <strong class="source-inline">.head()</strong> returns the first five rows by default. You can specify the number of items to be displayed by passing the required number in the parentheses, <strong class="source-inline">()</strong>.</p></li>
				<li>Display the number of duplicated entries by running another value count:<p class="source-code">id_counts.value_counts()</p><p>You will obtain the following output:</p><div class="IMG---Figure" id="_idContainer027"><img alt="Figure 1.17: Getting value counts of the account IDs&#13;&#10;" src="image/B16925_01_17.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.17: Getting value counts of the account IDs</p>
			<p>Here, we can see that most IDs occur exactly once, as expected. However, 313 IDs occur twice. So, no ID occurs more than twice. With this information, we are ready to begin taking a closer look at this data quality issue and go about fixing it. We will create Boolean masks to do this.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Boolean Masks</h2>
			<p>To help clean the case study data, we introduce the concept of a <strong class="bold">logical mask</strong>, also known as a <strong class="bold">Boolean mask</strong>. A logical mask is a way to filter an array, or Series, by some condition. For example, we can use the "is equal to" operator in Python, <strong class="source-inline">==</strong>, to find all locations of an array that contain a certain value. Other comparisons, such as "greater than" (<strong class="source-inline">&gt;</strong>), "less than" (<strong class="source-inline">&lt;</strong>), "greater than or equal to" (<strong class="source-inline">&gt;=</strong>), and "less than or equal to" (<strong class="source-inline">&lt;=</strong>), can be used similarly. The output of such a comparison is an array or Series of <strong class="source-inline">True/False</strong> values, also known as <strong class="bold">Boolean</strong> values. Each element of the output corresponds to an element of the input, is <strong class="source-inline">True</strong> if the condition is met, and is <strong class="source-inline">False</strong> otherwise. To illustrate how this works, we will use <strong class="bold">synthetic data</strong>. Synthetic data is data that is created to explore or illustrate a concept. First, we are going to import the NumPy package, which has many capabilities for generating random numbers, and give it the alias <strong class="source-inline">np</strong>. We'll also import the default random number generator from the random module within NumPy:</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">from numpy.random import default_rng </p>
			<p>Now we use what's called a <strong class="bold">seed</strong> for the random number generator. If you set the seed, you will get the same results from the random number generator across runs. Otherwise, this is not guaranteed. This can be a helpful option if you use random numbers in some way in your work and want to have consistent results every time you run a notebook. We arbitrarily set the seed to <strong class="source-inline">12345</strong>:</p>
			<p class="source-code">rg = default_rng(12345)</p>
			<p>Next, we generate 100 random integers, using the <strong class="source-inline">integers</strong> method of <strong class="source-inline">rg</strong>, with the appropriate arguments. We generate integers from between 1 and 4. Note the <strong class="source-inline">high</strong> argument specifies an open endpoint by default, that is, the upper limit of the range is not included:</p>
			<p class="source-code">random_integers = rg.integers(low=1,high=5,size=100)</p>
			<p>Let's look at the first five elements of this array, with <strong class="source-inline">random_integers[:5]</strong>. The output should appear as follows:</p>
			<p class="source-code">array ([3, 1, 4, 2, 1])</p>
			<p>Suppose we wanted to know the locations of all elements of <strong class="source-inline">random_integers</strong> equal to 3. We could create a Boolean mask to do this:</p>
			<p class="source-code">is_equal_to_3 = random_integers == 3</p>
			<p>From examining the first 5 elements, we know the first element is equal to 3, but none of the rest are. So in our Boolean mask, we expect <strong class="source-inline">True</strong> in the first position and <strong class="source-inline">False</strong> in the next 4 positions. Is this the case?</p>
			<p class="source-code">is_equal_to_3[:5]</p>
			<p>The preceding code should give this output:</p>
			<p class="source-code">array([ True, False, False, False, False])</p>
			<p>This is what we expected. This shows the creation of a Boolean mask. But what else can we do with them? Suppose we wanted to know how many elements were equal to 3. To know this, you can take the sum of a Boolean mask, which interprets <strong class="source-inline">True</strong> as 1 and <strong class="source-inline">False</strong> as 0:</p>
			<p class="source-code">sum(is_equal_to_3)</p>
			<p>This should give us the following output:</p>
			<p class="source-code">31</p>
			<p>This makes sense, as with a random, equally likely choice of 4 possible values, we would expect each value to appear about 25% of the time. In addition to seeing how many values in the array meet the Boolean condition, we can also use the Boolean mask to select the elements of the array that meet that condition. Boolean masks can be used directly to index arrays, as shown here:</p>
			<p class="source-code">random_integers[is_equal_to_3]</p>
			<p>This outputs the elements of <strong class="source-inline">random_integers</strong> meeting the Boolean condition we specified. In this case, the 31 elements equal to 3:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure 1.18: Using the Boolean mask to index an array&#13;&#10;" src="image/B16925_01_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18: Using the Boolean mask to index an array</p>
			<p>Now you know the basics of Boolean arrays, which are useful in many situations. In particular, you can use the <strong class="source-inline">.loc</strong> method of DataFrames to index the rows by a Boolean mask, and the columns by label, to get values of various columns meeting a condition in a potentially different column. Let's continue exploring the case study data with these skills.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook containing the code and the corresponding outputs presented in the preceding section can be found at <a href="https://packt.link/pT9gT">https://packt.link/pT9gT</a>.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Exercise 1.04: Continuing Verification of Data Integrity</h2>
			<p>In this exercise, with our knowledge of Boolean arrays, we will examine some of the duplicate IDs we discovered. In <em class="italic">Exercise 03</em>, <em class="italic">Verifying Basic Data Integrity</em>, we learned that no ID appears more than twice. We can use this learning to locate the duplicate IDs and examine them. Then we take action to remove rows of dubious quality from the dataset. Perform the following steps to complete the exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook for this exercise can be found here: <a href="https://packt.link/snAP0">https://packt.link/snAP0</a>.</p>
			<ol>
				<li value="1">Continuing where we left off in <em class="italic">Exercise 1.03</em>, <em class="italic">Verifying Basic Data Integrity</em>, we need to get the locations of the <strong class="source-inline">id_counts</strong> Series, where the count is <strong class="source-inline">2</strong>, to locate the duplicates. First, we load the data and get the value counts of IDs to bring us to where we left off in <em class="italic">Exercise 03</em>, <em class="italic">Verifying Basic Data Integrity</em>, then we create a Boolean mask locating the duplicated IDs with a variable called <strong class="source-inline">dupe_mask</strong> and display the first five elements. Use the following commands: <p class="source-code">import pandas as pd</p><p class="source-code">df = pd.read_excel('../../Data/default_of_credit_card_clients'\</p><p class="source-code">                   '__courseware_version_1_21_19.xls')</p><p class="source-code">id_counts = df['ID'].value_counts()</p><p class="source-code">id_counts.head()</p><p class="source-code">dupe_mask = id_counts == 2</p><p class="source-code">dupe_mask[0:5]</p><p>You will obtain the following output (note the ordering of IDs may be different in your output, as <strong class="source-inline">value_counts</strong> sorts on frequency, not the index of IDs):</p><div class="IMG---Figure" id="_idContainer029"><img alt="Figure 1.19: A Boolean mask to locate duplicate IDs&#13;&#10;" src="image/B16925_01_19.jpg"/></div><p class="figure-caption">Figure 1.19: A Boolean mask to locate duplicate IDs</p><p>Note that in the preceding output, we are displaying only the first five entries using <strong class="source-inline">dupe_mask</strong> to illustrate the contents of this array. You can edit the integer indices in the square brackets (<strong class="source-inline">[]</strong>) to change the number of entries displayed.</p><p>Our next step is to use this logical mask to select the IDs that are duplicated. The IDs themselves are contained as the index of the <strong class="source-inline">id_count</strong> Series. We can access the index in order to use our logical mask for selection purposes.</p></li>
				<li>Access the index of <strong class="source-inline">id_count</strong> and display the first five rows as context using the following command:<p class="source-code">id_counts.index[0:5]</p><p>With this, you will obtain the following output:</p><div class="IMG---Figure" id="_idContainer030"><img alt="Figure 1.20: Duplicated IDs &#13;&#10;" src="image/B16925_01_20.jpg"/></div><p class="figure-caption">Figure 1.20: Duplicated IDs </p></li>
				<li>Select and store the duplicated IDs in a new variable called <strong class="source-inline">dupe_ids</strong> using the following command:<p class="source-code">dupe_ids = id_counts.index[dupe_mask]</p></li>
				<li>Convert <strong class="source-inline">dupe_ids</strong> to a list and then obtain the length of the list using the following commands:<p class="source-code">dupe_ids = list(dupe_ids)</p><p class="source-code">len(dupe_ids)</p><p>You should obtain the following output:</p><p class="source-code">313</p><p>We changed the <strong class="source-inline">dupe_ids</strong> variable to a <strong class="source-inline">list</strong>, as we will need it in this form for future steps. The list has a length of <strong class="source-inline">313</strong>, as can be seen in the preceding output, which matches our knowledge of the number of duplicate IDs from the value count.</p></li>
				<li>We verify the data in <strong class="source-inline">dupe_ids</strong> by displaying the first five entries using the following command:<p class="source-code">dupe_ids[0:5]</p><p>We obtain the following output:</p><div class="IMG---Figure" id="_idContainer031"><img alt="Figure 1.21: Making a list of duplicate IDs&#13;&#10;" src="image/B16925_01_21.jpg"/></div><p class="figure-caption">Figure 1.21: Making a list of duplicate IDs</p><p>We can observe from the preceding output that the list contains the required entries of duplicate IDs. We're now in a position to examine the data for the IDs in our list of duplicates. In particular, we'd like to look at the values of the features, to see what, if anything, might be different between these duplicate entries. We will use the <strong class="source-inline">.isin</strong> and <strong class="source-inline">.loc</strong> methods of the DataFrame <strong class="source-inline">df</strong> for this purpose.</p><p>Using the first three IDs on our list of dupes, <strong class="source-inline">dupe_ids[0:3]</strong>, we will plan to first find the rows containing these IDs. If we pass this list of IDs to the <strong class="source-inline">.isin</strong> method of the ID Series, this will create another logical mask we can use on the larger DataFrame to display the rows that have these IDs. The <strong class="source-inline">.isin</strong> method is nested in a <strong class="source-inline">.loc</strong> statement indexing the DataFrame in order to select the location of all rows containing <strong class="source-inline">True</strong> in the Boolean mask. The second argument of the <strong class="source-inline">.loc</strong> indexing statement is <strong class="source-inline">:</strong>, which implies that all columns will be selected. By performing the following steps, we are essentially filtering the DataFrame in order to view all the columns for the first three duplicate IDs.</p></li>
				<li>Run the following command in your notebook to execute the plan we formulated in the previous step:<p class="source-code">df.loc[df['ID'].isin(dupe_ids[0:3]),:]</p><div class="IMG---Figure" id="_idContainer032"><img alt="Figure 1.22: Examining the data for duplicate IDs&#13;&#10;" src="image/B16925_01_22.jpg"/></div><p class="figure-caption">Figure 1.22: Examining the data for duplicate IDs</p><p>What we observe here is that each duplicate ID appears to have one row with what seems like valid data, and one row that's entirely zeros. Take a moment and think to yourself what you would do with this knowledge.</p><p>After some reflection, it should be clear that you ought to delete the rows with all zeros. Perhaps these arose through a faulty join condition in the SQL query that generated the data? Regardless, a row of all zeros is definitely invalid data as it makes no sense for someone to have an age of 0, a credit limit of 0, and so on.</p><p>One approach to deal with this issue would be to find rows that have all zeros, except for the first column, which has the IDs. These would be invalid data in any case, and it may be that if we get rid of all of these, we would also solve our problem of duplicate IDs. We can find the entries of the DataFrame that are equal to zero by creating a Boolean matrix that is the same size as the whole DataFrame, based on the "is equal to zero" condition. </p></li>
				<li>Create a Boolean matrix of the same size as the entire DataFrame using <strong class="source-inline">==</strong>, as shown:<p class="source-code">df_zero_mask = df == 0</p><p>In the next steps, we'll use <strong class="source-inline">df_zero_mask</strong>, which is another DataFrame containing Boolean values. The goal will be to create a Boolean Series, <strong class="source-inline">feature_zero_mask</strong>, that identifies every row where all the elements starting from the second column (the features and response, but not the IDs) are 0. To do so, we first need to index <strong class="source-inline">df_zero_mask</strong> using the integer indexing (<strong class="source-inline">.iloc</strong>) method. In this method, we pass (<strong class="source-inline">:</strong>) to examine all rows and (<strong class="source-inline">1:</strong>) to examine all columns starting with the second one (index <strong class="source-inline">1</strong>). Finally, we will apply the <strong class="source-inline">all()</strong> method along the column axis (<strong class="source-inline">axis=1</strong>), which will return <strong class="source-inline">True</strong> if and only if every column in that row is <strong class="source-inline">True</strong>. This is a lot to think about, but it's pretty simple to code, as will be observed in the following step. The goal is to get one Series, that is the same length as the DataFrame, telling us which rows have all zeros besides the ID.</p></li>
				<li>Create the Boolean Series <strong class="source-inline">feature_zero_mask</strong>, as shown in the following code:<p class="source-code">feature_zero_mask = df_zero_mask.iloc[:,1:].all(axis=1)</p></li>
				<li>Calculate the sum of the Boolean Series using the following command:<p class="source-code">sum(feature_zero_mask)</p><p>You should obtain the following output:</p><p class="source-code">315</p><p>The preceding output tells us that 315 rows have zeros for every column but the first one. This is greater than the number of duplicate IDs (313), so if we delete all the "zero rows," we may get rid of the duplicate ID problem.</p></li>
				<li>Clean the DataFrame by eliminating the rows with all zeros, except for the ID, using the following code:<p class="source-code">df_clean_1 = df.loc[~feature_zero_mask,:].copy()</p><p>While performing the cleaning operation in the preceding step, we return a new DataFrame called <strong class="source-inline">df_clean_1</strong>. Notice that here we've used the <strong class="source-inline">.copy()</strong> method after the <strong class="source-inline">.loc</strong> indexing operation to create a copy of this output, as opposed to a view on the original DataFrame. You can think of this as creating a new DataFrame, as opposed to referencing the original one. Within the <strong class="source-inline">.loc</strong> method, we used the logical not operator, <strong class="source-inline">~</strong>, to select all the rows that don't have zeros for all the features and the response variable, and <strong class="source-inline">:</strong> to select all columns. This is the valid data we wish to keep. After doing this, we now want to know if the number of remaining rows is equal to the number of unique IDs.</p></li>
				<li>Verify the number of rows and columns in <strong class="source-inline">df_clean_1</strong> by running the following code:<p class="source-code">df_clean_1.shape</p><p>You will obtain the following output:</p><p class="source-code">(29685, 25)</p></li>
				<li>Obtain the number of unique IDs by running the following code:<p class="source-code">df_clean_1['ID'].nunique()</p><p>Here's the output: </p><p class="source-code">29685</p><p>From the preceding output, we can see that we have successfully eliminated duplicates, as the number of unique IDs is equal to the number of rows. Now take a breath and pat yourself on the back. That was a whirlwind introduction to quite a few pandas techniques for indexing and characterizing data. Now that we've filtered out the duplicate IDs, we're in a position to start looking at the actual data itself: the features, and eventually, the response variable.</p></li>
			</ol>
			<p>After completing this exercise, save your progress as follows, to a CSV (comma-separated value) file. Notice we don't include the index of the DataFrame when saving, as this is not necessary and can create extra columns when we load it later:</p>
			<p class="source-code">df_clean_1.to_csv('../../Data/df_clean_1.csv', index=False)</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Exercise 1.05: Exploring and Cleaning the Data </h2>
			<p>Thus far, we have identified a data quality issue related to the metadata: we had been told that every sample from our dataset corresponded to a unique account ID, but found that this was not the case. We were able to use logical indexing and pandas to correct this issue. This was a fundamental data quality issue, having to do simply with what samples were present, based on the metadata. Aside from this, we are not really interested in the metadata column of account IDs: these will not help us develop a predictive model for credit default. </p>
			<p>Now, we are ready to start examining the values of the features and response variable, the data we will use to develop our predictive model. Perform the following steps to complete this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook for this exercise can be found here: <a href="https://packt.link/q0huQ">https://packt.link/q0huQ</a>.</p>
			<ol>
				<li value="1">Load the results of the previous exercise and obtain the data type of the columns in the data by using the <strong class="source-inline">.info()</strong> method as shown: <p class="source-code">import pandas as pd</p><p class="source-code">df_clean_1 = pd.read_csv('../../Data/df_clean_1.csv')</p><p class="source-code">df_clean_1.info()</p><p>You should see the following output:</p><div class="IMG---Figure" id="_idContainer033"><img alt="Figure 1.23: Getting column metadata&#13;&#10;" src="image/B16925_01_23.jpg"/></div><p class="figure-caption">Figure 1.23: Getting column metadata</p><p>We can see in <em class="italic">Figure 1.23</em> that there are 25 columns. Each row has 29,685 <strong class="bold">non-null</strong> values, according to this summary, which is the number of rows in the DataFrame. This would indicate that there is no missing data, in the sense that each cell contains some value. However, if there is a fill value to represent missing data, that would not be evident here.</p><p>We also see that most columns say <strong class="source-inline">int64</strong> next to them, indicating they are an <strong class="bold">integer</strong> data type, that is, numbers such as ..., -2, -1, 0, 1, 2,... . The exceptions are <strong class="source-inline">ID</strong> and <strong class="source-inline">PAY_1</strong>. We are already familiar with <strong class="source-inline">ID</strong>; this contains strings, which are account IDs. What about <strong class="source-inline">PAY_1</strong>? According to the data dictionary, we'd expect this to contain integers, like all the other features. Let's take a closer look at this column.</p></li>
				<li>Use the <strong class="source-inline">.head(n)</strong> pandas method to view the top <strong class="source-inline">n</strong> rows of the <strong class="source-inline">PAY_1</strong> Series:<p class="source-code">df_clean_1['PAY_1'].head(5)</p><p>You should obtain the following output:</p><div class="IMG---Figure" id="_idContainer034"><img alt="Figure 1.24: Examine a few columns' contents&#13;&#10;" src="image/B16925_01_24.jpg"/></div><p class="figure-caption">Figure 1.24: Examine a few columns' contents</p><p>The integers on the left of the output are the DataFrame index, which is simply consecutive integers starting with 0. The data from the <strong class="source-inline">PAY_1</strong> column is shown on the right. This is supposed to be the payment status of the most recent month's bill, using the values –1, 1, 2, 3, and so on. However, we can see that there are values of 0 here, which are not documented in the data dictionary. According to the data dictionary, <em class="italic">"The measurement scale for the repayment status is: -1 = pay duly; 1 = payment delay for one month; 2 = payment delay for two months; . . .; 8 = payment delay for eight months; 9 = payment delay for nine months and above"</em> (<a href="https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients">https://archive.ics.uci.edu/ml/datasets/default+of+credit+card+clients</a>). Let's take a closer look, using the value counts of this column.</p></li>
				<li>Obtain the value counts for the <strong class="source-inline">PAY_1</strong> column by using the <strong class="source-inline">.value_counts()</strong> method:<p class="source-code">df_clean_1['PAY_1'].value_counts()</p><p>You should see the following output:</p><div class="IMG---Figure" id="_idContainer035"><img alt="Figure 1.25: Value counts of the PAY_1 column&#13;&#10;" src="image/B16925_01_25.jpg"/></div><p class="figure-caption">Figure 1.25: Value counts of the PAY_1 column</p><p>The preceding output reveals the presence of two undocumented values: 0 and –2, as well as the reason this column was imported by pandas as an <strong class="source-inline">object</strong> data type, instead of <strong class="source-inline">int64</strong> as we would expect for integer data: there is a <strong class="source-inline">'Not available'</strong> string present in this column, symbolizing missing data. Later on in the book, we'll come back to this when we consider how to deal with missing data. For now, we'll remove rows of the dataset in which this feature has a missing value.</p></li>
				<li>Use a logical mask with the <strong class="source-inline">!=</strong> operator (which means "does not equal" in Python) to find all the rows that don't have missing data for the <strong class="source-inline">PAY_1</strong> feature:<p class="source-code">valid_pay_1_mask = df_clean_1['PAY_1'] != 'Not available'</p><p class="source-code">valid_pay_1_mask[0:5]</p><p>By running the preceding code, you will obtain the following output:</p><div class="IMG---Figure" id="_idContainer036"><img alt="Figure 1.26: Creating a Boolean mask&#13;&#10;" src="image/B16925_01_26.jpg"/></div><p class="figure-caption">Figure 1.26: Creating a Boolean mask</p></li>
				<li>Check how many rows have no missing data by calculating the sum of the mask:<p class="source-code">sum(valid_pay_1_mask)</p><p>You will obtain the following output:</p><p class="source-code">26664</p><p>We see that 26,664 rows do not have the value <strong class="source-inline">'Not available'</strong> in the <strong class="source-inline">PAY_1</strong> column. We saw from the value count that 3,021 rows do have this value. Does this make sense? From <em class="italic">Figure 1.23</em> we know there are 29,685 entries (rows) in the dataset, and 29,685 – 3,021 = 26,664, so this checks out.</p></li>
				<li>Clean the data by eliminating the rows with the missing values of <strong class="source-inline">PAY_1</strong> as shown:<p class="source-code">df_clean_2 = df_clean_1.loc[valid_pay_1_mask,:].copy()</p></li>
				<li>Obtain the shape of the cleaned data using the following command:<p class="source-code">df_clean_2.shape</p><p>You will obtain the following output:</p><p class="source-code">(26664, 25)</p><p>After removing these rows, we check that the resulting DataFrame has the expected shape. You can also check for yourself whether the value counts indicate the desired values have been removed like this: <strong class="source-inline">df_clean_2['PAY_1'].value_counts()</strong>.</p><p>Lastly, so this column's data type can be consistent with the others, we will cast it from the generic <strong class="source-inline">object</strong> type to <strong class="source-inline">int64</strong> like all the other features, using the <strong class="source-inline">.astype</strong> method. Then we select a couple of columns, including <strong class="source-inline">PAY_1</strong>, to examine the data types and make sure it worked.</p></li>
				<li>Run the following command to convert the data type for <strong class="source-inline">PAY_1</strong> from <strong class="source-inline">object</strong> to <strong class="source-inline">int64</strong> and show the column metadata for <strong class="source-inline">PAY_1</strong> and <strong class="source-inline">PAY_2</strong> by using a list to select multiple columns:<p class="source-code">df_clean_2['PAY_1'] = df_clean_2['PAY_1'].astype('int64')</p><p class="source-code">df_clean_2[['PAY_1', 'PAY_2']].info()</p></li>
			</ol>
			<p>This is the output you will obtain:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 1.27: Check the data type of the cleaned column&#13;&#10;" src="image/B16925_01_27.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.27: Check the data type of the cleaned column</p>
			<p>Congratulations, you have completed your second data cleaning operation! However, if you recall, during this process we also noticed the undocumented values of –2 and 0 in <strong class="source-inline">PAY_1</strong>. Now, let's imagine we got back in touch with our business partner and learned the following information:</p>
			<ul>
				<li>-2 means the account started that month with a zero balance and never used any credit.</li>
				<li>-1 means the account had a balance that was paid in full.</li>
				<li>0 means that at least the minimum payment was made, but the entire balance wasn't paid (that is, a positive balance was carried to the next month).</li>
			</ul>
			<p>We thank our business partner since this answers our questions, for now. Maintaining a good line of communication and working relationship with the business partner is important, as you can see here, and may determine the success or failure of a project.</p>
			<p>In your notebook, save your progress from this exercise like this:</p>
			<p class="source-code">df_clean_2.to_csv('../../Data/df_clean_2.csv', index=False)</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Data Quality Assurance and Exploration</h1>
			<p>So far, we remedied two data quality issues just by asking basic questions or by looking at the <strong class="source-inline">.info()</strong> summary. Let's now take a look at the first few columns of data. Before we get to the historical bill payments, we have the credit limits of the <strong class="source-inline">LIMIT_BAL</strong> accounts, and the <strong class="source-inline">SEX</strong>, <strong class="source-inline">EDUCATION</strong>, <strong class="source-inline">MARRIAGE</strong>, and <strong class="source-inline">AGE</strong> demographic features. Our business partner has reached out to us, to let us know that gender should not be used to predict credit-worthiness, as this is <strong class="bold">unethical</strong> by their standards. So we keep this in mind for future reference. Now we'll explore the rest of these columns, making any corrections that are necessary.</p>
			<p>In order to further explore the data, we will use <strong class="bold">histograms</strong>. Histograms are a good way to visualize data that is on a continuous scale, such as currency amounts and ages. A histogram groups similar values into bins and shows the number of data points in these bins as a bar graph.</p>
			<p>To plot histograms, we will start to get familiar with the graphical capabilities of pandas. pandas relies on another library called <strong class="bold">Matplotlib</strong> to create graphics, so we'll also set some options using <strong class="source-inline">matplotlib</strong>. Using these tools, we'll also learn how to get quick statistical summaries of data in pandas.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Exercise 1.06: Exploring the Credit Limit and Demographic Features</h2>
			<p>In this exercise, we'll start our exploration of data with the credit limit and age features. We will visualize them and get summary statistics to check that the data contained in these features is sensible. Then we will look at the education and marriage categorical features to see if the values there make sense, correcting them as necessary. <strong class="source-inline">LIMIT_BAL</strong> and <strong class="source-inline">AGE</strong> are numerical features, meaning they are measured on a continuous scale. Consequently, we'll use histograms to visualize them. Perform the following steps to complete the exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook for this exercise found here: <a href="https://packt.link/PRdtP">https://packt.link/PRdtP</a>.</p>
			<ol>
				<li value="1">In addition to pandas, import <strong class="source-inline">matplotlib</strong> and set up some plotting options with this code snippet. Note the use of comments in Python with <strong class="source-inline">#</strong>. Anything appearing after a <strong class="source-inline">#</strong> on a line will be ignored by the Python interpreter:<p class="source-code">import pandas as pd</p><p class="source-code">import matplotlib.pyplot as plt #import plotting package</p><p class="source-code">#render plotting automatically</p><p class="source-code">%matplotlib inline</p><p class="source-code">import matplotlib as mpl #additional plotting functionality</p><p class="source-code">mpl.rcParams['figure.dpi'] = 400 #high resolution figures</p><p>This imports <strong class="source-inline">matplotlib</strong> and uses <strong class="source-inline">.rcParams</strong> to set the resolution (<strong class="source-inline">dpi</strong> = dots per inch) for a nice crisp image; you may not want to worry about this last part unless you are preparing things for presentation, as it could make the images quite large in your notebook.</p></li>
				<li>Load our progress from the previous exercise using the following code:<p class="source-code">df_clean_2 = pd.read_csv('../Data/df_clean_2.csv'),</p></li>
				<li>Run <strong class="source-inline">df_clean_2[['LIMIT_BAL', 'AGE']].hist()</strong> and you should see the following histograms:<div class="IMG---Figure" id="_idContainer038"><img alt="Figure 1.28: Histograms of the credit limit and age data&#13;&#10;" src="image/B16925_01_28.jpg"/></div><p class="figure-caption">Figure 1.28: Histograms of the credit limit and age data</p><p>This is a nice visual snapshot of these features. We can get a quick, approximate look at all of the data in this way. In order to see statistics such as the mean and median (that is, the 50th percentile), there is another helpful pandas function.</p></li>
				<li>Generate a tabular report of summary statistics using the following command:<p class="source-code">df_clean_2[['LIMIT_BAL', 'AGE']].describe()</p><p>You should see the following output:</p><div class="IMG---Figure" id="_idContainer039"><img alt="Figure 1.29: Statistical summaries of credit limit and age data&#13;&#10;" src="image/B16925_01_29.jpg"/></div><p class="figure-caption">Figure 1.29: Statistical summaries of credit limit and age data</p><p>Based on the histograms and the convenient statistics computed by <strong class="source-inline">.describe()</strong>, which include a count of non-nulls, the mean and standard deviation, minimum, maximum, and quartiles, we can make a few judgments.</p><p><strong class="source-inline">LIMIT_BAL</strong>, the credit limit, seems to make sense. The credit limits have a minimum of 10,000. This dataset is from Taiwan; the exact unit of currency (NT dollar) may not be familiar, but intuitively, a credit limit should be above zero. You are encouraged to look up the conversion to your local currency and consider these credit limits. For example, 1 US dollar is about 30 NT dollars.</p><p>The <strong class="source-inline">AGE</strong> feature also looks reasonably distributed, with no one under the age of 21 having a credit account.</p><p>For the categorical features, a look at the value counts is useful, since there are relatively few unique values. </p></li>
				<li>Obtain the value counts for the <strong class="source-inline">EDUCATION</strong> feature using the following code:<p class="source-code">df_clean_2['EDUCATION'].value_counts()</p><p>You should see this output:</p><div class="IMG---Figure" id="_idContainer040"><img alt="Figure 1.30: Value counts of the EDUCATION feature&#13;&#10;" src="image/B16925_01_30.jpg"/></div><p class="figure-caption">Figure 1.30: Value counts of the EDUCATION feature</p><p>Here, we see undocumented education levels 0, 5, and 6, as the data dictionary describes only <strong class="source-inline">Education (1 = graduate school; 2 = university; 3 = high school; 4 = others)</strong>. Our business partner tells us they don't know about the others. Since they are not very prevalent, we will lump them in with the <strong class="source-inline">others</strong> category, which seems appropriate.</p></li>
				<li>Run this code to combine the undocumented levels of the <strong class="source-inline">EDUCATION</strong> feature into the level for <strong class="source-inline">others</strong> and then examine the results: <p class="source-code">df_clean_2['EDUCATION'].replace(to_replace=[0, 5, 6],\</p><p class="source-code">                                value=4, inplace=True)</p><p class="source-code">df_clean_2['EDUCATION'].value_counts()</p><p>The pandas <strong class="source-inline">.replace</strong> method makes doing the replacements described in the preceding step pretty quick. Once you run the code, you should see this output:</p><div class="IMG---Figure" id="_idContainer041"><img alt="Figure 1.31: Cleaning the EDUCATION feature&#13;&#10;" src="image/B16925_01_31.jpg"/></div><p class="figure-caption">Figure 1.31: Cleaning the EDUCATION feature</p><p>Note that here we make this change <strong class="bold">in place</strong> (<strong class="source-inline">inplace=True</strong>). This means that, instead of returning a new DataFrame, this operation will make the change on the existing DataFrame.</p></li>
				<li>Obtain the value counts for the <strong class="source-inline">MARRIAGE</strong> feature using the following code:<p class="source-code">df_clean_2['MARRIAGE'].value_counts()</p><p>You should obtain the following output:</p><div class="IMG---Figure" id="_idContainer042"><img alt="Figure 1.32: Value counts of the raw MARRIAGE feature&#13;&#10;" src="image/B16925_01_32.jpg"/></div><p class="figure-caption">Figure 1.32: Value counts of the raw MARRIAGE feature</p><p>The issue here is similar to that encountered for the <strong class="source-inline">EDUCATION</strong> feature; there is a value, 0, which is not documented in the data dictionary: <strong class="source-inline">1 = married; 2 = single; 3 = others</strong>. So we'll lump it in with <strong class="source-inline">others</strong>.</p></li>
				<li>Change the values of 0 in the <strong class="source-inline">MARRIAGE</strong> feature to 3 and examine the result with this code:<p class="source-code">df_clean_2['MARRIAGE'].replace(to_replace=0, value=3, \</p><p class="source-code">                               inplace=True)</p><p class="source-code">df_clean_2['MARRIAGE'].value_counts()</p><p>The output should be as follows:</p><div class="IMG---Figure" id="_idContainer043"><img alt="Figure 1.33: Value counts of the cleaned MARRIAGE feature&#13;&#10;" src="image/B16925_01_33.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.33: Value counts of the cleaned MARRIAGE feature</p>
			<p>We've now accomplished a lot of exploration and cleaning of the data. We will do some more advanced visualization and exploration of the financial history features that come after this in the DataFrame, later. First, we'll consider the meaning of the <strong class="source-inline">EDUCATION</strong> feature, a categorical feature in our dataset.</p>
			<p>Save your progress from this exercise as follows:</p>
			<p class="source-code">df_clean_2.to_csv('../../Data/df_clean_2_01.csv', index=False)</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Deep Dive: Categorical Features</h2>
			<p>Machine learning algorithms only work with numbers. If your data contains text features, for example, these would require transformation to numbers in some way. We learned above that the data for our case study is, in fact, entirely numerical. However, it's worth thinking about how it got to be that way. In particular, consider the <strong class="source-inline">EDUCATION</strong> feature.</p>
			<p>This is an example of what is called a <strong class="bold">categorical feature</strong>: you can imagine that as raw data, this column consisted of the text labels <strong class="source-inline">graduate school</strong>, <strong class="source-inline">university</strong>, <strong class="source-inline">high school</strong>, and <strong class="source-inline">others</strong>. These are called the <strong class="bold">levels</strong> of the categorical feature; here, there are four levels. It is only through a mapping, which has already been chosen for us, that this data exists as the numbers 1, 2, 3, and 4 in our dataset. This particular assignment of categories to numbers creates what is known as an <strong class="bold">ordinal feature</strong>, since the levels are mapped to numbers in order. As a data scientist, at a minimum, you need to be aware of such mappings, if you are not choosing them yourself. </p>
			<p><strong class="bold">What are the implications of this mapping?</strong></p>
			<p>It makes some sense that the education levels are ranked, with 1 corresponding to the highest level of education in our dataset, 2 to the next highest, 3 to the next, and 4 presumably including the lowest levels. However, when you use this encoding as a numerical feature in a machine learning model, it will be treated just like any other numerical feature. For some models, this effect may not be desired. </p>
			<p><strong class="bold">What if a model seeks to find a straight-line relationship between the features and response? </strong></p>
			<p>This may seem like an arbitrary question, although later in the book you will learn the importance of distinguishing between linear and non-linear models. In this section, we will briefly introduce the concept that some models do look for linear relationships between features and the response variable. Whether or not this would work well in the case of the education feature depends on the actual relationship between different levels of education and the outcome we are trying to predict.</p>
			<p>Here, we examine two hypothetical cases of synthetic data with ordinal categorical variables, each with 10 levels. The levels measure the self-reported satisfaction of customers visiting a website. The average number of minutes spent on the website for customers reporting each level is plotted on the y-axis. We've also plotted the line of best fit in each case to illustrate how a linear model would deal with this data, as shown in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 1.34: Ordinal features may or may not work well in a linear model&#13;&#10;" src="image/B16925_01_34.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.34: Ordinal features may or may not work well in a linear model</p>
			<p>We can see that if an algorithm assumes a linear (straight-line) relationship between the features and response variable, this may or may not work well depending on the true relationship. Notice that in this synthetic example, we are modeling a regression problem: the response variable takes on a continuous range of numbers. While our case study involves a classification problem, some classification algorithms such as <strong class="bold">logistic regression</strong> also assume a linear effect of the features. We will discuss this in greater detail later when we get into modeling the data for our case study.</p>
			<p>Roughly speaking, for a binary classification problem, meaning the response variable only has two outcomes, which we'll assume are coded as 0 and 1, you can look at the different levels of a categorical feature in terms of the average values of the response variable within each level. These average values represent the "rates" of the positive class (that is, the samples where the response variable = 1) for each level. This can give you an idea of whether an ordinal encoding will work well with a linear model. Assuming you've imported the same packages in your Jupyter notebook as in the previous sections, you can quickly look at this using a <strong class="source-inline">groupby</strong>/<strong class="source-inline">agg</strong>regate procedure and a bar plot in pandas. </p>
			<p>This will group the data by the values in the <strong class="source-inline">EDUCATION</strong> feature and then within each group aggregate the data together using the average of the <strong class="source-inline">default payment next month</strong> response variable:</p>
			<p class="source-code">df_clean_2 = pd.read_csv('../../Data/df_clean_2_01.csv')</p>
			<p class="source-code">df_clean_2.groupby('EDUCATION').agg({'default payment next '\</p>
			<p class="source-code">                                     'month':'mean'})\</p>
			<p class="source-code">                               .plot.bar(legend=False)</p>
			<p class="source-code">plt.ylabel('Default rate')</p>
			<p class="source-code">plt.xlabel('Education level: ordinal encoding')</p>
			<p>Once you run the code, you should obtain the following output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 1.35: Default rate within education levels&#13;&#10;" src="image/B16925_01_35.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.35: Default rate within education levels</p>
			<p>Similar to <em class="italic">Example 2</em> in <em class="italic">Figure 1.34</em>, it looks like a straight-line fit would probably not be the best description of the data here. In case a feature has a non-linear effect like this, it may be better to use a more complex algorithm such as a <strong class="bold">decision tree</strong> or <strong class="bold">random forest</strong>. Or, if a simpler and more interpretable linear model such as logistic regression is desired, we could avoid an ordinal encoding and use a different way of encoding categorical variables. A popular way of doing this is called <strong class="bold">one-hot encoding</strong> (<strong class="bold">OHE</strong>). </p>
			<p>OHE is a way to transform a categorical feature, which may consist of text labels in the raw data, into a numerical feature that can be used in mathematical models.</p>
			<p>Let's learn about this in an exercise. And if you are wondering why a logistic regression is more interpretable and a random forest is more complex, we will be learning about these concepts in detail in later chapters.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Exercise 1.07: Implementing OHE for a Categorical Feature</h2>
			<p>In this exercise, we will "reverse engineer" the <strong class="source-inline">EDUCATION</strong> feature in the dataset to obtain the text labels that represent the different education levels, then show how to use pandas to create an OHE. As a preliminary step, please set up the environment and load in the progress from previous exercises:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import matplotlib as mpl #additional plotting functionality</p>
			<p class="source-code">mpl.rcParams['figure.dpi'] = 400 #high resolution figures</p>
			<p class="source-code">df_clean_2 = pd.read_csv('../../Data/df_clean_2_01.csv')</p>
			<p>First, let's consider our <strong class="source-inline">EDUCATION</strong> feature before it was encoded as an ordinal. From the data dictionary, we know that 1 = graduate school, 2 = university, 3 = high school, 4 = others. We would like to recreate a column that has these strings, instead of numbers. Perform the following steps to complete the exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Jupyter notebook for this exercise found here: <a href="https://packt.link/akAYJ">https://packt.link/akAYJ</a>.</p>
			<ol>
				<li value="1">Create an empty column for the categorical labels called <strong class="source-inline">EDUCATION_CAT</strong>. Using the following command, every row will contain the string <strong class="source-inline">'none'</strong>:<p class="source-code">df_clean_2['EDUCATION_CAT'] = 'none'</p></li>
				<li>Examine the first few rows of the DataFrame for the <strong class="source-inline">EDUCATION</strong> and <strong class="source-inline">EDUCATION_CAT</strong> columns:<p class="source-code">df_clean_2[['EDUCATION', 'EDUCATION_CAT']].head(10)</p><p>The output should appear as follows:</p><div class="IMG---Figure" id="_idContainer046"><img alt="Figure 1.36: Selecting columns and viewing the first 10 rows&#13;&#10;" src="image/B16925_01_36.jpg"/></div><p class="figure-caption">Figure 1.36: Selecting columns and viewing the first 10 rows</p><p>We need to populate this new column with the appropriate strings. pandas provides a convenient functionality for mapping all values of a Series onto new values. This function is in fact called <strong class="source-inline">.map</strong> and relies on a dictionary to establish the correspondence between the old values and the new values. Our goal here is to map the numbers in <strong class="source-inline">EDUCATION</strong> onto the strings they represent. For example, where the <strong class="source-inline">EDUCATION</strong> column equals the number 1, we'll assign the <strong class="source-inline">'graduate school'</strong> string to the <strong class="source-inline">EDUCATION_CAT</strong> column, and so on for the other education levels.</p></li>
				<li>Create a dictionary that describes the mapping for education categories using the following code:<p class="source-code">cat_mapping = {1: "graduate school",\</p><p class="source-code">               2: "university",\</p><p class="source-code">               3: "high school",\</p><p class="source-code">               4: "others"}</p></li>
				<li>Apply the mapping to the original <strong class="source-inline">EDUCATION</strong> column using <strong class="source-inline">.map</strong> and assign the result to the new <strong class="source-inline">EDUCATION_CAT</strong> column:<p class="source-code">df_clean_2['EDUCATION_CAT'] = df_clean_2['EDUCATION']\</p><p class="source-code">                              .map(cat_mapping)</p><p class="source-code">df_clean_2[['EDUCATION', 'EDUCATION_CAT']].head(10)</p><p>After running those lines, you should see the following output:</p><div class="IMG---Figure" id="_idContainer047"><img alt="Figure 1.37: Examining the string values corresponding to the ordinal &#13;&#10;encoding of EDUCATION&#13;&#10;" src="image/B16925_01_37.jpg"/></div><p class="figure-caption">Figure 1.37: Examining the string values corresponding to the ordinal encoding of EDUCATION</p><p>Excellent! Note that we could have skipped <em class="italic">Step 1</em>, where we assigned the new column with <strong class="source-inline">'none'</strong>, and gone straight to <em class="italic">Steps 3</em> and <em class="italic">4</em> to create the new column. However, sometimes it's useful to create a new column initialized with a single value, so it's worth knowing how to do that.</p><p>Now we are ready to one-hot encode. We can do this by passing a Series of a <strong class="source-inline">DataFrame</strong> to the pandas <strong class="source-inline">get_dummies()</strong> function. The function got this name because one-hot encoded columns are also referred to as <strong class="bold">dummy variables</strong>. The result will be a new DataFrame, with as many columns as there are levels of the categorical variable.</p></li>
				<li>Run this code to create a one-hot encoded DataFrame of the <strong class="source-inline">EDUCATION_CAT</strong> column. Examine the first 10 rows:<p class="source-code">edu_ohe = pd.get_dummies(df_clean_2['EDUCATION_CAT'])</p><p class="source-code">edu_ohe.head(10)</p><p>This should produce the following output: </p><div class="IMG---Figure" id="_idContainer048"><img alt="Figure 1.38: DataFrame of one-hot encoding&#13;&#10;" src="image/B16925_01_38.jpg"/></div><p class="figure-caption">Figure 1.38: DataFrame of one-hot encoding</p><p>You can now see why this is called "one-hot encoding": across all these columns, any particular row will have a 1 in exactly 1 column, and 0s in the rest. For a given row, the column with the 1 should match up to the level of the original categorical variable. To check this, we need to concatenate this new DataFrame with the original one and examine the results side by side. We will use the pandas <strong class="source-inline">concat</strong> function, to which we pass the list of DataFrames we wish to concatenate, and the <strong class="source-inline">axis=1</strong> keyword saying to concatenate them horizontally; that is, along the column axis. This basically means we are combining these two DataFrames "side by side," which we know we can do because we just created this new DataFrame from the original one: we know it will have the same number of rows, which will be in the same order as the original DataFrame.</p></li>
				<li>Concatenate the one-hot encoded DataFrame to the original DataFrame as follows:<p class="source-code">df_with_ohe = pd.concat([df_clean_2, edu_ohe], axis=1)</p><p class="source-code">df_with_ohe[['EDUCATION_CAT', 'graduate school',\</p><p class="source-code">             'high school', 'university', 'others']].head(10)</p><p>You should see this output:</p><div class="IMG---Figure" id="_idContainer049"><img alt="Figure 1.39: Checking the one-hot encoded columns&#13;&#10;" src="image/B16925_01_39.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.39: Checking the one-hot encoded columns</p>
			<p>Alright, looks like this has worked as intended. OHE is another way to encode categorical features that avoids the implied numerical structure of an ordinal encoding. However, notice what has happened here: we have taken a single column, <strong class="source-inline">EDUCATION</strong>, and exploded it out into as many columns as there were levels in the feature. In this case, since there are only four levels, this is not such a big deal. However, if your categorical variable had a very large number of levels, you may want to consider an alternate strategy, such as grouping some levels together into single categories.</p>
			<p>This is a good time to save the DataFrame we've created here, which encapsulates our efforts at cleaning the data and adding an OHE column.</p>
			<p>Write the latest DataFrame to a file like this: <strong class="source-inline">df_with_ohe.to_csv('../../Data/Chapter_1_cleaned_data.csv', index=False)</strong>. </p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Exploring the Financial History Features in the Dataset</h1>
			<p>We are ready to explore the rest of the features in the case study dataset. First set up the environment and load data from the previous exercise. This can be done using the following snippet:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import matplotlib.pyplot as plt #import plotting package</p>
			<p class="source-code">#render plotting automatically</p>
			<p class="source-code">%matplotlib inline</p>
			<p class="source-code">import matplotlib as mpl #additional plotting functionality</p>
			<p class="source-code">mpl.rcParams['figure.dpi'] = 400 #high resolution figures</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">df = pd.read_csv('../../Data/Chapter_1_cleaned_data.csv')</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The path to your CSV file may be different depending on where you saved it.</p>
			<p>The remaining features to be examined are the financial history features. They fall naturally into three groups: the status of the monthly payments for the last 6 months, and the billed and paid amounts for the same period. First, let's look at the payment statuses. It is convenient to break these out as a list so we can study them together. You can do this using the following code:</p>
			<p class="source-code">pay_feats = ['PAY_1', 'PAY_2', 'PAY_3', 'PAY_4', 'PAY_5', \</p>
			<p class="source-code">             'PAY_6']</p>
			<p>We can use the <strong class="source-inline">.describe</strong> method on these six Series to examine summary statistics:</p>
			<p class="source-code">df[pay_feats].describe()</p>
			<p>This should produce the following output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 1.40: Summary statistics of payment status features&#13;&#10;" src="image/B16925_01_40.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.40: Summary statistics of payment status features</p>
			<p>Here, we observe that the range of values is the same for all of these features: -2, -1, 0, ... 8. It appears that the value of 9, described in the data dictionary as <em class="italic">payment delay for nine months and above</em>, is never observed.</p>
			<p>We have already clarified the meaning of all of these levels, some of which were not in the original data dictionary. Now let's look again at the <strong class="source-inline">value_counts()</strong> of <strong class="source-inline">PAY_1</strong>, now sorted by the values we are counting, which are the <strong class="source-inline">index</strong> of this Series:</p>
			<p class="source-code">df[pay_feats[0]].value_counts().sort_index()</p>
			<p>This should produce the following output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer051">
					<img alt="Figure 1.41: Value counts of the payment status for the previous month&#13;&#10;" src="image/B16925_01_41.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.41: Value counts of the payment status for the previous month</p>
			<p>Compared to the positive integer values, most of the values are either -2, -1, or 0, which correspond to an account that was in good standing last month: not used, paid in full, or made at least the minimum payment.</p>
			<p>Notice that, because of the definition of the other values of this variable (1 = payment delay for 1 month; 2 = payment delay for 2 months, and so on), this feature is sort of a hybrid of categorical and numerical features. Why should no credit usage correspond to a value of -2, while a value of 2 means a 2-month late payment, and so forth? We should acknowledge that the numerical coding of payment statuses -2, -1, and 0 constitute a decision made by the creator of the dataset on how to encode certain categorical features, which were then lumped in with a feature that is truly numerical: the number of months of payment delay (values of 1 and larger). Later on, we will consider the potential effects of this way of doing things on the predictive capability of this feature.</p>
			<p>For now, we will continue to explore the data. This dataset is small enough, with 18 of these financial features and a handful of others, that we can afford to individually examine every feature. If the dataset had thousands of features, we would likely forgo this and instead explore <strong class="bold">dimensionality reduction</strong> techniques, which are ways to condense the information in a large number of features down to a smaller number of derived features, or, alternatively, methods of <strong class="bold">feature selection</strong>, which can be used to isolate the important features from a candidate field of many. We will demonstrate and explain some feature selection techniques later. But on this dataset, it's feasible to visualize every feature. As we know from the last chapter, a histogram is a good way to get a quick visual interpretation of the same kind of information we would get from tables of value counts. You can try this on the most recent month's payment status features with <strong class="source-inline">df[pay_feats[0]].hist()</strong>, to produce this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Figure 1.42: Histogram of PAY_1 using default arguments&#13;&#10;" src="image/B16925_01_42.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.42: Histogram of PAY_1 using default arguments</p>
			<p>Now we're going to take an in-depth look at how this graphic is produced and consider whether it is as informative as it should be. A key point about the graphical functionality of pandas is that <strong class="bold">pandas plotting actually calls matplotlib under the hood</strong>. Notice that the last available argument to the pandas <strong class="source-inline">.hist()</strong> method is <strong class="source-inline">**kwds</strong>, which the documentation indicates are <strong class="source-inline">matplotlib</strong> keyword arguments.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information, refer to the following: <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.hist.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.hist.html</a>.</p>
			<p>Looking at the <strong class="source-inline">matplotlib</strong> documentation for <strong class="source-inline">matplotlib.pyplot.hist</strong> shows additional arguments you can use with the pandas <strong class="source-inline">.hist()</strong> method, such as the type of histogram to plot (see <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html">https://matplotlib.org/api/_as_gen/matplotlib.pyplot.hist.html</a> for more details). In general, to get more details about plotting functionality, it's important to be aware of <strong class="source-inline">matplotlib</strong>, and in some scenarios, you will want to use <strong class="source-inline">matplotlib</strong> directly, instead of pandas, to have more control over the appearance of plots.</p>
			<p>You should be aware that pandas uses <strong class="source-inline">matplotlib</strong>, which in turn uses NumPy. When plotting histograms with <strong class="source-inline">matplotlib</strong>, the numerical calculation for the values that make up the histogram is actually carried out by the NumPy <strong class="source-inline">.histogram</strong> function. This is a key example of code reuse, or "not reinventing the wheel." If a standard functionality, such as plotting a histogram, already has a good implementation in Python, there is no reason to create it anew. And if the mathematical operation to create the histogram data for the plot is already implemented, this should be leveraged as well. This shows the interconnectedness of the Python ecosystem.</p>
			<p>We'll now address a couple of key issues that arise when calculating and plotting histograms.</p>
			<p><strong class="bold">Number of bins</strong></p>
			<p>Histograms work by grouping together values into what are called <strong class="bold">bins</strong>. The number of bins is the number of vertical bars that make up the discrete histogram plot we see. If there are a large number of unique values on a continuous scale, such as the histogram of ages we viewed earlier, histogram plotting works relatively well "out of the box," with default arguments. However, when the number of unique values is close to the number of bins, the results may be a little misleading. The default number of bins is 10, while in the <strong class="source-inline">PAY_1</strong> feature, there are 11 unique values. In cases like this, it's better to manually set the number of histogram bins to the number of unique values.</p>
			<p>In our current example, since there are very few values in the higher bins of <strong class="source-inline">PAY_1</strong>, the plot may not look much different. But in general, this is important to keep in mind when plotting histograms.</p>
			<p><strong class="bold">Bin edges</strong></p>
			<p>The locations of the edges of the bins determine how the values get grouped in the histogram. Instead of indicating the number of bins to the plotting function, you could alternatively supply a list or array of numbers for the <strong class="source-inline">bins</strong> keyword argument. This input would be interpreted as the bin edge locations on the x-axis. The way values are grouped into bins in <strong class="source-inline">matplotlib</strong>, using the edge locations, is important to understand. All bins, except the last one, group together values as low as the left edge, and up to <strong class="bold">but not including</strong> values as high as the right edge. In other words, the left edge is closed but the right edge is open for these bins. However, the last bin includes both edges; it has a closed left and right edge. This is of more practical importance when you are binning a relatively small number of unique values that may land on the bin edges.</p>
			<p>For control over plot appearance, it's usually better to specify the bin edge locations. We'll create an array of 12 numbers, which will result in 11 bins, each one centered around 1 of the unique values of <strong class="source-inline">PAY_1</strong>:</p>
			<p class="source-code">pay_1_bins = np.array(range(-2,10)) - 0.5</p>
			<p class="source-code">pay_1_bins</p>
			<p>The output shows the bin edge locations:</p>
			<p class="source-code">array([-2.5, -1.5, -0.5, 0.5, 1.5, 2.5,\</p>
			<p class="source-code">       3.5,4.5, 5.5, 6.5, 7.5,8.5])</p>
			<p>As a final point of style, it is important to always <em class="italic">label your plots</em> so that they are interpretable. We haven't yet done this manually, because in some cases, pandas does it automatically, and in other cases, we simply left the plots unlabeled. From now on, we will follow best practice and label all plots. We use the <strong class="source-inline">xlabel</strong> and <strong class="source-inline">ylabel</strong> functions in <strong class="source-inline">matplotlib</strong> to add axis labels to this plot. The code is as follows:</p>
			<p class="source-code">df[pay_feats[0]].hist(bins=pay_1_bins)</p>
			<p class="source-code">plt.xlabel('PAY_1')</p>
			<p class="source-code">plt.ylabel('Number of accounts')</p>
			<p>The output should look like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 1.43: A better histogram of PAY_1&#13;&#10;" src="image/B16925_01_43.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.43: A better histogram of PAY_1</p>
			<p><em class="italic">Figure 1.43</em> represents an improved histogram, since the bars are centered over the actual values in the data, and there is 1 bar per unique value. While it's tempting, and often sufficient, to just call plotting functions with the default arguments, one of your jobs as a data scientist is to create <em class="italic">accurate and representative data visualizations</em>. To do that, sometimes you need to dig into the details of plotting code, as we've done here.</p>
			<p><strong class="bold">What have we learned from this data visualization? </strong></p>
			<p>Since we already looked at the value counts, this confirms for us that most accounts are in good standing (values -2, -1, and 0). For those that aren't, it's more common for the "months late" to be a smaller number. This makes sense; likely, most people are paying off their balances before too long. Otherwise, their account may be closed or sold to a collection agency. Examining the distribution of your features and making sure it seems reasonable is a good thing to confirm with your client, as the quality of this data underlies the predictive modeling you seek to do.</p>
			<p>Now that we've established some good plotting style for histograms, let's use pandas to plot multiple histograms together, and visualize the payment status features for each of the last 6 months. We can pass our list of column names <strong class="source-inline">pay_feats</strong> to access multiple columns to plot with the <strong class="source-inline">.hist()</strong> method, specifying the bin edges we've already determined, and indicating we'd like a 2 by 3 grid of plots. First, we set the font size small enough to fit between these <strong class="bold">subplots</strong>. Here is the code for this:</p>
			<p class="source-code">mpl.rcParams['font.size'] = 4</p>
			<p class="source-code">df[pay_feats].hist(bins=pay_1_bins, layout=(2,3))</p>
			<p>The plot titles have been created automatically for us based on the column names. The y-axes are understood to be counts. The resulting visualizations are as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Figure 1.44: Grid of histogram subplots&#13;&#10;" src="image/B16925_01_44.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.44: Grid of histogram subplots</p>
			<p>We've already seen the first of these, and it makes sense. What about the rest of them? Remember the definitions of the positive integer values of these features, and what each feature means. For example, <strong class="source-inline">PAY_2</strong> is the repayment status in August, <strong class="source-inline">PAY_3</strong> is the repayment status in July, and the others go further back in time. A value of 1 means a payment delay for 1 month, while a value of 2 means a payment delay for 2 months, and so forth.</p>
			<p>Did you notice that something doesn't seem right? Consider the values between July (<strong class="source-inline">PAY_3</strong>) and August (<strong class="source-inline">PAY_2</strong>). In July, there are very few accounts that had a 1-month payment delay; this bar is not really visible in the histogram. However, in August, there are suddenly thousands of accounts with a 2-month payment delay. This does not make sense: the number of accounts with a 2-month delay in a given month should be less than or equal to the number of accounts with a 1-month delay in the previous month. </p>
			<p>Let's take a closer look at accounts with a 2-month delay in August and see what the payment status was in July. We can do this with the following code, using a Boolean mask and <strong class="source-inline">.loc</strong>, as shown in the following snippet:</p>
			<p class="source-code">df.loc[df['PAY_2']==2, ['PAY_2', 'PAY_3']].head()</p>
			<p>The output of this should appear as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 1.45: Payment status in July (PAY_3) of accounts with a 2-month payment &#13;&#10;delay in August (PAY_2)&#13;&#10;" src="image/B16925_01_45.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.45: Payment status in July (PAY_3) of accounts with a 2-month payment delay in August (PAY_2)</p>
			<p>From <em class="italic">Figure 1.45</em>, it's clear that accounts with a 2-month delay in August have nonsensical values for the July payment status. The only way to progress to a 2-month delay should be from a 1-month delay the previous month, yet none of these accounts indicate that.</p>
			<p>When you see something like this in the data, you need to either check the logic in the query used to create the dataset or contact the person who gave you the dataset. After double-checking these results, for example using <strong class="source-inline">.value_counts()</strong> to view the numbers directly, we contact our client to inquire about this issue.</p>
			<p>The client lets us know that they had been having problems with pulling the most recent month of data, leading to faulty reporting for accounts that had a 1-month delay in payment. In September, they had mostly fixed these problems (although not entirely; that is why there were missing values in the <strong class="source-inline">PAY_1</strong> feature, as we found). So, in our dataset, the value of 1 is underreported in all months except for September (the <strong class="source-inline">PAY_1</strong> feature). In theory, the client could create a query to look back into their database and determine the correct values for <strong class="source-inline">PAY_2</strong>, <strong class="source-inline">PAY_3</strong>, and so on up to <strong class="source-inline">PAY_6</strong>. However, for practical reasons, they won't be able to complete this retrospective analysis in time for us to receive it and include it in our project.</p>
			<p>Because of this, only the most recent month of our payment status data is correct. This means that, of all the payment status features, only <strong class="source-inline">PAY_1</strong> is representative of future data, those that will be used to make predictions with the model we develop. This is a key point: <em class="italic">a predictive model relies on getting the same kind of data to make predictions as it was built with</em>. This means we can use <strong class="source-inline">PAY_1</strong> as a feature in our model, but not <strong class="source-inline">PAY_2</strong> or the other payment status features from previous months.</p>
			<p>This episode shows the importance of a thorough examination of data quality. Only by carefully combing through the data did we discover this issue. It would have been nice if the client had told us up front that they had been having reporting issues over the last few months, when our dataset was collected, and that the reporting procedure was not <strong class="bold">consistent</strong> during that time period. However, ultimately it is our responsibility to build a credible model, so we need to be sure we believe the data is correct, by making this kind of detailed exploration. We explain to the client that we can't use the older features since they are not representative of the future data the model will be <strong class="bold">scored</strong> on (that is, to make predictions on future months), and ask them to let us know of any further data issues they are aware of. There are none at this time.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Activity 1.01: Exploring the Remaining Financial Features in the Dataset</h2>
			<p>In this activity, you will examine the remaining financial features in a similar way to how we examined <strong class="source-inline">PAY_1</strong>, <strong class="source-inline">PAY_2</strong>, <strong class="source-inline">PAY_3</strong>, and so on. In order to better visualize some of this data, we'll use a mathematical function that should be familiar: the logarithm. You'll use pandas' <strong class="source-inline">apply</strong> method, which serves to apply any function to an entire column or DataFrame in the process. Once you complete the activity, you should have the following set of histograms of logarithmic transformations of non-zero payments:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 1.46: Expected set of histograms&#13;&#10;" src="image/B16925_01_46.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.46: Expected set of histograms</p>
			<p>Perform the following steps to complete the activity:</p>
			<p>Before beginning, set up your environment and load in the cleaned dataset as follows:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import matplotlib.pyplot as plt #import plotting package</p>
			<p class="source-code">#render plotting automatically</p>
			<p class="source-code">%matplotlib inline</p>
			<p class="source-code">import matplotlib as mpl #additional plotting functionality</p>
			<p class="source-code">mpl.rcParams['figure.dpi'] = 400 #high resolution figures</p>
			<p class="source-code">mpl.rcParams['font.size'] = 4 #font size for figures</p>
			<p class="source-code">from scipy import stats</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">df = pd.read_csv('../../Data/Chapter_1_cleaned_data.csv')</p>
			<ol>
				<li value="1">Create lists of feature names for the remaining financial features. </li>
				<li>Use <strong class="source-inline">.describe()</strong> to examine statistical summaries of the bill amount features. Reflect on what you see. Does it make sense?</li>
				<li>Visualize the bill amount features using a 2 by 3 grid of histogram plots.<p>Hint: You can use 20 bins for this visualization.</p></li>
				<li>Obtain the <strong class="source-inline">.describe()</strong> summary of the payment amount features. Does it make sense?</li>
				<li>Plot a histogram of the bill payment features similar to the bill amount features, but also apply some rotation to the x-axis labels with the <strong class="source-inline">xrot</strong> keyword argument so that they don't overlap. In any plotting function, you can include the <strong class="source-inline">xrot=&lt;angle&gt;</strong> keyword argument to rotate x-axis labels by a given angle in degrees. Consider the results.</li>
				<li>Use a Boolean mask to see how much of the payment amount data is exactly equal to 0. Does this make sense given the histogram in the previous step?</li>
				<li>Ignoring the payments of 0 using the mask you created in the previous step, use pandas' <strong class="source-inline">.apply()</strong> and NumPy's <strong class="source-inline">np.log10()</strong> to plot histograms of logarithmic transformations of the non-zero payments. Consider the results.<p>Hint: You can use <strong class="source-inline">.apply()</strong> to apply any function, including <strong class="source-inline">log10</strong>, to all the elements of a DataFrame or a column using the following syntax: <strong class="source-inline">.apply(&lt;function_name&gt;)</strong>. </p><p class="callout-heading">Note</p><p class="callout">The Jupyter notebook containing the Python code and corresponding outputs for this activity can be found here: <a href="https://packt.link/FQQOB">https://packt.link/FQQOB</a>. Detailed step-wise solution to this activity can be found via <a href="B16925_Solution_ePub.xhtml#_idTextAnchor149">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Summary</h1>
			<p>In this introductory chapter, we made extensive use of pandas to load and explore the case study data. We learned how to check for basic consistency and correctness by using a combination of statistical summaries and visualizations. We answered such questions as "Are the unique account IDs truly unique?", "Is there any missing data that has been given a fill value?", and "Do the values of the features make sense given their definition?"</p>
			<p>You may notice that we spent nearly all of this chapter identifying and correcting issues with our dataset. This is often the most time-consuming stage of a data science project. While it is not necessarily the most exciting part of the job, it gives you the raw materials necessary to build exciting models and insights. These will be the subjects of most of the rest of this book.</p>
			<p>Mastery of software tools and mathematical concepts is what allows you to execute data science projects, at a technical level. However, managing your relationships with clients, who are relying on your services to generate insights from their data, is just as important to successful projects. You must make as much use as you can of your business partner's understanding of the data. They are likely going to be more familiar with it than you, unless you are already a subject matter expert in the area. However, even in that case, your first step should be a thorough and critical review of the data you are using.</p>
			<p>In our data exploration, we discovered an issue that could have undermined our project: the data we had received was not internally consistent. Most of the months of the payment status features were plagued by a data reporting issue, included nonsensical values, and were not representative of the most recent month of data, or the data that would be available to the model going forward. We only uncovered this issue by taking a careful look at all of the features. While this is not always possible, especially when there are very many features, you should always take the time to spot-check as many features as you can. If you can't examine every feature, it's useful to check a few of every category of feature, when the features fall into categories, such as financial or demographic features.</p>
			<p>When discussing data issues like this with your client, make sure you are respectful and professional. The client may simply have forgotten about the issue when presenting you with the data. Or, they may have known about it but assumed it wouldn't affect your analysis for some reason. In any case, you are doing them an essential service by bringing it to their attention and explaining why it would be a problem to use flawed data to build a model. Be as specific as you can, presenting the kinds of graphs and tables you used to discover the issue.</p>
			<p>In the next chapter, we will examine the response variable for our case study problem, which completes the initial data exploration. Then we will start to get some hands-on experience with machine learning models and learn how we can decide whether a model is useful or not. These skills will be important when we start building models using the case study data.</p>
		</div>
	</body></html>