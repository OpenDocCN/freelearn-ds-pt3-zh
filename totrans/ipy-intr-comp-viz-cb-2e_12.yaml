- en: Chapter 12. Deterministic Dynamical Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting the bifurcation diagram of a chaotic dynamical system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating an elementary cellular automaton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating an ordinary differential equation with SciPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a partial differential equation – reaction-diffusion systems and
    Turing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapters dealt with classical approaches in data science: statistics,
    machine learning, and signal processing. In this chapter and the next chapter,
    we will cover a different type of approach. Instead of analyzing data directly,
    we will simulate mathematical models that represent how our data was generated.
    A representative model gives us an explanation of the real-world processes underlying
    our data.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will cover a few examples of dynamical systems. These mathematical
    equations describe the evolution of quantities over time and space. They can represent
    a wide variety of real-world phenomena in physics, chemistry, biology, economics,
    social sciences, computer science, engineering, and other disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will consider deterministic dynamical systems. This term
    is used in contrast to stochastic systems, which incorporate randomness in their
    rules. We will cover stochastic systems in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Types of dynamical systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The types of deterministic dynamical systems we will consider here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discrete-time dynamical systems** (iterated functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cellular automata**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordinary Differential Equations** (**ODEs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial Differential Equations** (**PDEs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these models, the quantities of interest depend on one or several **independent
    variables**. Often, these variables include time and/or space. The independent
    variables can be discrete or continuous, resulting in different types of models
    and different analysis and simulation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **discrete-time dynamical system** is described by the iterative application
    of a function on an initial point: *f(x)*, *f(f(x))*, *f(f(f(x)))*, and so on.
    This type of system can lead to complex and **chaotic** behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: A **cellular automaton** is represented by a discrete grid of cells that can
    be in a finite number of states. Rules describe how the state of a cell evolves
    according to the states of the neighboring cells. These simple models can lead
    to highly sophisticated behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: An **ODE** describes the dependence of a continuous function on its derivative
    with respect to the independent variable. In differential equations, the unknown
    variable is a *function* instead of a *number*. ODEs notably arise when the rate
    of change of a quantity depends on the current value of this quantity. For example,
    in classical mechanics, the laws of motion (including movement of planets and
    satellites) can be described by ODEs.
  prefs: []
  type: TYPE_NORMAL
- en: '**PDEs** are similar to ODEs, but they involve several independent variables
    (for example, time and space). These equations contain **partial derivatives**
    of the function with respect to the different independent variables. For example,
    PDEs describe the propagation of waves (acoustic, electromagnetic, or mechanical
    waves) and fluids (**fluid dynamics**). They are also important in quantum mechanics.'
  prefs: []
  type: TYPE_NORMAL
- en: Differential equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ODEs and PDEs can be one-dimensional or multidimensional, depending on the dimensionality
    of the target space. Systems of multiple differential equations can be seen as
    multidimensional equations.
  prefs: []
  type: TYPE_NORMAL
- en: The **order** of an ODE or a PDE refers to the maximal derivative order in the
    equation. For example, a first-order equation only involves simple derivatives,
    a second-order equation also involves second-order derivatives (the derivatives
    of the derivatives), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordinary or partial differential equations come with additional rules: **initial**
    **and** **boundary conditions**. These formulas describe the behavior of the sought
    functions on the spatial and temporal domain boundaries. For example, in classical
    mechanics, boundary conditions include the initial position and initial speed
    of a physical body subject to forces.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamical systems are often classified between **linear** and **nonlinear**
    systems, depending on whether the rules are linear or not (with respect to the
    unknown function). Nonlinear equations are typically much harder to study mathematically
    and numerically than linear equations. They can lead to extremely complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the **Navier–Stokes equations**, a set of nonlinear PDEs that describe
    the motion of fluid substances, can lead to **turbulence**, a highly chaotic behavior
    seen in many fluid flows. Despite their high importance in meteorology, medicine,
    and engineering, fundamental properties of the Navier-Stokes equations remain
    unknown at this time. For example, the existence and smoothness problem in three
    dimensions is one of the seven Clay Mathematics Institute's Millennium Prize Problems.
    One million dollars is offered to anyone who comes up with a solution.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of dynamical systems on Wikipedia, available at [http://en.wikipedia.org/wiki/Dynamical_system](http://en.wikipedia.org/wiki/Dynamical_system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical definition of dynamical systems available at [http://en.wikipedia.org/wiki/Dynamical_system_%28definition%29](http://en.wikipedia.org/wiki/Dynamical_system_%28definition%29)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of dynamical systems topics available at [http://en.wikipedia.org/wiki/List_of_dynamical_systems_and_differential_equations_topics](http://en.wikipedia.org/wiki/List_of_dynamical_systems_and_differential_equations_topics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navier-Stokes equations on Wikipedia, available at [http://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations](http://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A course on Computational Fluid Dynamics by Prof. Lorena Barba, written in the
    IPython notebook, available at [https://github.com/barbagroup/CFDPython](https://github.com/barbagroup/CFDPython)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting the bifurcation diagram of a chaotic dynamical system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **chaotic** dynamical system is highly sensitive to initial conditions; small
    perturbations at any given time yield completely different trajectories. The trajectories
    of a chaotic system tend to have complex and unpredictable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Many real-world phenomena are chaotic, particularly those that involve nonlinear
    interactions among many agents (complex systems). Famous examples can be found
    in meteorology, economics, biology, and other disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will simulate a famous chaotic system: the **logistic map**.
    This is an archetypal example of how chaos can arise from a very simple nonlinear
    equation. The logistic map models the evolution of a population, taking into account
    both reproduction and density-dependent mortality (starvation).'
  prefs: []
  type: TYPE_NORMAL
- en: We will draw the system's **bifurcation diagram**, which shows the possible
    long-term behaviors (equilibria, fixed points, periodic orbits, and chaotic trajectories)
    as a function of the system's parameter. We will also compute an approximation
    of the system's **Lyapunov exponent**, characterizing the model's sensitivity
    to initial conditions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We define the logistic function by:![How to do it...](img/4818OS_12_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our discrete dynamical system is defined by the recursive application of the
    logistic function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/4818OS_12_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Here is the implementation of this function in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We simulate this system for 10000 values of *r* linearly spaced between `2.5`
    and `4`, and vectorize the simulation with NumPy by considering a vector of independent
    systems (one dynamical system per parameter value):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s simulate 1000 iterations of the logistic map and keep the last 100 iterations
    to display the bifurcation diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We initialize our system with the same initial condition *x[0] = 0.00001*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also compute an approximation of the Lyapunov exponent for every value of
    *r*. The Lyapunov exponent is defined by:![How to do it...](img/4818OS_12_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first initialize the `lyapunov` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we simulate the system and plot the bifurcation diagram. The simulation
    only involves the iterative evaluation of the `logistic()` function on our vector
    `x`. Then, to display the bifurcation diagram, we draw one pixel per point *x[n]^((r))*
    during the last 100 iterations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_12_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The bifurcation diagram and Lyapunov exponent of the logistic map
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The bifurcation diagram brings out the existence of a fixed point for *r<3*,
    then two and four equilibria, and a chaotic behavior when r belongs to certain
    areas of the parameter space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We observe an important property of the Lyapunov exponent: it is positive when
    the system is chaotic (in red here).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some references:'
  prefs: []
  type: TYPE_NORMAL
- en: Chaos theory on Wikipedia, available at [http://en.wikipedia.org/wiki/Chaos_theory](http://en.wikipedia.org/wiki/Chaos_theory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex systems on Wikipedia, available at [http://en.wikipedia.org/wiki/Complex_system](http://en.wikipedia.org/wiki/Complex_system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logistic map on Wikipedia, available at [https://en.wikipedia.org/wiki/Logistic_map](https://en.wikipedia.org/wiki/Logistic_map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterated functions (discrete dynamical systems) on Wikipedia, available at [http://en.wikipedia.org/wiki/Iterated_function](http://en.wikipedia.org/wiki/Iterated_function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bifurcation diagrams on Wikipedia, available at [http://en.wikipedia.org/wiki/Bifurcation_diagram](http://en.wikipedia.org/wiki/Bifurcation_diagram)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lyapunov exponent on Wikipedia, available at [http://en.wikipedia.org/wiki/Lyapunov_exponent](http://en.wikipedia.org/wiki/Lyapunov_exponent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Simulating an ordinary differential equation with SciPy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating an elementary cellular automaton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cellular automata are discrete dynamical systems evolving on a grid of cells.
    These cells can be in a finite number of states (for example, on/off). The evolution
    of a cellular automaton is governed by a set of rules, describing how the state
    of a cell changes according to the state of its neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: Although extremely simple, these models can initiate highly complex and chaotic
    behaviors. Cellular automata can model real-world phenomena such as car traffic,
    chemical reactions, propagation of fire in a forest, epidemic propagations, and
    much more. Cellular automata are also found in nature. For example, the patterns
    of some seashells are generated by natural cellular automata.
  prefs: []
  type: TYPE_NORMAL
- en: An **elementary cellular automaton** is a binary, one-dimensional automaton,
    where the rules concern the immediate left and right neighbors of every cell.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will simulate elementary cellular automata with NumPy using
    their Wolfram code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the following vector to obtain numbers written in binary representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s write a function that performs an iteration on the grid, updating all
    cells at once according to the given rule in binary representation (we will give
    all explanations in the *How it works...* section). The first step consists of
    stacking circularly-shifted versions of the grid to get the LCR (left, center,
    right) triplets of each cell (`y`). Then, we convert these triplets into 3-bit
    numbers (`z`). Finally, we compute the next state of every cell using the specified
    rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now write a function that simulates any elementary cellular automaton. First,
    we compute the binary representation of the rule (**Wolfram Code**). Then, we
    initialize the first row of the grid with random values. Finally, we apply the
    function `step()` iteratively on the grid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we simulate and display nine different automata:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_12_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider an elementary cellular automaton in one dimension. Every cell
    *C* has two neighbors (*L* and *R*), and it can be either off (0) or on (1). Therefore,
    the future state of a cell depends on the current state of *L*, *C*, and *R*.
    This triplet can be encoded as a number between 0 and 7 (three digits in binary
    representation).
  prefs: []
  type: TYPE_NORMAL
- en: A particular elementary cellular automaton is entirely determined by the outcome
    of each of these eight configurations. Therefore, there are 256 different elementary
    cellular automata (*2⁸*). Each of these automata is identified by a number between
    0 and 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'We consider all eight LCR states in order: 111, 110, 101, ..., 001, 000\. Each
    of the eight digits in the binary representation of the automaton''s number corresponds
    to a LCR state (using the same order). For example, in the **Rule 110 automaton**
    (`01101110` in binary representation), the state 111 yields a new state of 0 for
    the center cell, 110 yields 1, 101 yields 1, and so on. It has been shown that
    this particular automaton is **Turing complete** (or **universal**); it can theoretically
    simulate any computer program.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other types of cellular automata include **Conway's Game of Life**, in two dimensions.
    This famous system yields various dynamic patterns. It is also Turing complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Cellular automata on Wikipedia, available at [http://en.wikipedia.org/wiki/Cellular_automaton](http://en.wikipedia.org/wiki/Cellular_automaton)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elementary cellular automata on Wikipedia, available at [http://en.wikipedia.org/wiki/Elementary_cellular_automaton](http://en.wikipedia.org/wiki/Elementary_cellular_automaton)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rule 110, described at [http://en.wikipedia.org/wiki/Rule_110](http://en.wikipedia.org/wiki/Rule_110)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Wolfram code, explained at [http://en.wikipedia.org/wiki/Wolfram_code](http://en.wikipedia.org/wiki/Wolfram_code),
    assigns a 1D elementary cellular automaton to any number between 0 and 255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conway's Game of Life on Wikipedia, available at [http://en.wikipedia.org/wiki/Conway's_Game_of_Life](http://en.wikipedia.org/wiki/Conway's_Game_of_Life)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating an ordinary differential equation with SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ordinary Differential Equations** (**ODEs**) describe the evolution of a
    system subject to internal and external dynamics. Specifically, an ODE links a
    quantity depending on a single independent variable (time, for example) to its
    derivatives. In addition, the system can be under the influence of external factors.
    A first-order ODE can typically be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simulating an ordinary differential equation with SciPy](img/4818OS_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More generally, an *n*-th order ODE involves successive derivatives of *y* until
    the order *n*. The ODE is said to be linear or nonlinear depending on whether
    *f* is linear in *y* or not.
  prefs: []
  type: TYPE_NORMAL
- en: ODEs naturally appear when the rate of change of a quantity depends on its value.
    Therefore, ODEs are found in many scientific disciplines such as mechanics (evolution
    of a body subject to dynamic forces), chemistry (concentration of reacting products),
    biology (spread of an epidemic), ecology (growth of a population), economics,
    and finance, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas simple ODEs can be solved analytically, many ODEs require a numerical
    treatment. In this recipe, we will simulate a simple linear second-order autonomous
    ODE, describing the evolution of a particle in the air subject to gravity and
    viscous resistance. Although this equation could be solved analytically, here
    we will use SciPy to simulate it numerically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy, SciPy (the `integrate` package), and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a few parameters appearing in our model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have two variables: *x* and *y* (two dimensions). We note *u=(x,y)*. The
    ODE that we are going to simulate is:![How to do it...](img/4818OS_12_07.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, *g* is the gravity acceleration vector.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Time derivatives are denoted with *dots* above variables (one dot means *first
    derivative* and two dots means *second derivative*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to simulate this second-order ODE with SciPy, we can convert it to
    a first-order ODE (another option would be to solve *u*'' first before integrating
    the solution). To do this, we consider two 2D variables: *u* and *u''*. We note
    *v = (u, u'')*. We can express *v''* as a function of *v*. Now, we create the
    initial vector *v[0]* at time *t=0*: it has four components.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a Python function *f* that takes the current vector *v(t[0])*
    and a time *t[0]* as arguments (with optional parameters) and that returns the
    derivative *v''(t[0])*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we simulate the system for different values of *k*. We use the SciPy `odeint()`
    function, defined in the `scipy.integrate` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_12_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the preceding figure, the most outward trajectory (blue) corresponds to drag-free
    motion (without air resistance). It is a parabola. In the other trajectories,
    we can observe the increasing effect of air resistance, parameterized with `k`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explain how we obtained the differential equation from our model. Let
    *u = (x,y)* encode the 2D position of our particle with mass *m*. This particle
    is subject to two forces: gravity *g = (0, -9.81)* (in *m/s*) and air drag *F
    = -ku''*. This last term depends on the particle''s speed and is only valid at
    low speed. With higher speeds, we need to use more complex nonlinear expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we use **Newton''s second law of motion** in classical mechanics. This
    law states that in an inertial reference frame, the mass multiplied by the acceleration
    of the particle is equal to the sum of all forces applied to that particle. Here,
    we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We immediately obtain our second-order ODE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We transform it into a single-order system of ODEs with *v=(u, u'')*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last term can be expressed as a function of *v* only.
  prefs: []
  type: TYPE_NORMAL
- en: The SciPy `odeint()`function is a black-box solver; we simply specify the function
    that describes the system, and SciPy solves it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This function leverages the FORTRAN library **ODEPACK**, which contains well-tested
    code that has been used for decades by many scientists and engineers.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a simple numerical solver is the **Euler method**. To numerically
    solve the autonomous ODE *y''=f(y)*, the method consists of discretizing time
    with a time step *dt* and replacing *y''* with a first-order approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, starting from an initial condition *y[0] = y(t[0])*, the method evaluates
    *y* successively with the following recurrence relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of the `integrate` package in SciPy available at [http://docs.scipy.org/doc/scipy/reference/integrate.html](http://docs.scipy.org/doc/scipy/reference/integrate.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ODEs on Wikipedia, available at [http://en.wikipedia.org/wiki/Ordinary_differential_equation](http://en.wikipedia.org/wiki/Ordinary_differential_equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newton's laws of motion on Wikipedia, available at [http://en.wikipedia.org/wiki/Newton's_laws_of_motion](http://en.wikipedia.org/wiki/Newton's_laws_of_motion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Air resistance on Wikipedia, available at [http://en.wikipedia.org/wiki/Drag_%28physics%29](http://en.wikipedia.org/wiki/Drag_%28physics%29)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some numerical methods for ODEs described at [http://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations](http://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Euler method on Wikipedia, available at [http://en.wikipedia.org/wiki/Euler_method](http://en.wikipedia.org/wiki/Euler_method)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation of the ODEPACK package in FORTRAN available at [www.netlib.org/odepack/opks-sum](http://www.netlib.org/odepack/opks-sum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Plotting the bifurcation diagram of a chaotic dynamical system* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating a partial differential equation – reaction-diffusion systems and
    Turing patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Partial Differential Equations** (**PDEs**) describe the evolution of dynamical
    systems involving both time and space. Examples in physics include sound, heat,
    electromagnetism, fluid flow, and elasticity, among others. Examples in biology
    include tumor growth, population dynamics, and epidemic propagations.'
  prefs: []
  type: TYPE_NORMAL
- en: PDEs are hard to solve analytically. Therefore, PDEs are often studied via numerical
    simulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will illustrate how to simulate a **reaction-diffusion system**
    described by a PDE called the **FitzHugh–Nagumo equation**. A reaction-diffusion
    system models the evolution of one or several variables subject to two processes:
    reaction (transformation of the variables into each other) and diffusion (spreading
    across a spatial region). Some chemical reactions can be described by this type
    of model, but there are other applications in physics, biology, ecology, and other
    disciplines.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we simulate a system that has been proposed by Alan Turing as a model
    of animal coat pattern formation. Two chemical substances influencing skin pigmentation
    interact according to a reaction-diffusion model. This system is responsible for
    the formation of patterns that are reminiscent of the pelage of zebras, jaguars,
    and giraffes.
  prefs: []
  type: TYPE_NORMAL
- en: We will simulate this system with the finite difference method. This method
    consists of discretizing time and space and replacing the derivatives with their
    discrete equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will simulate the following system of partial differential equations on the
    domain *E=[-1,1]²*:![How to do it...](img/4818OS_12_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The variable *u* represents the concentration of a substance favoring skin pigmentation,
    whereas *v* represents another substance that reacts with the first and impedes
    pigmentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At initialization time, we assume that *u* and *v* contain independent random
    numbers on every grid point. We also take **Neumann boundary conditions**: we
    require the spatial derivatives of the variables with respect to the normal vectors
    to be null on the domain''s boundaries.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s define the four parameters of the model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We discretize time and space. The following condition ensures that the discretization
    scheme we use here is stable:![How to do it...](img/4818OS_12_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We initialize the variables *u* and *v*. The matrices `U` and `V` contain the
    values of these variables on the vertices of the 2D grid. These variables are
    initialized with a uniform noise between 0 and 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we define a function that computes the discrete Laplace operator of a 2D
    variable on the grid, using a five-point stencil finite difference method. This
    operator is defined by:![How to do it...](img/4818OS_12_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can compute the values of this operator on the grid using vectorized matrix
    operations. Because of side effects on the edges of the matrix, we need to remove
    the borders of the grid in the computation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we simulate the system of equations using the finite difference method.
    At each time step, we compute the right-hand sides of the two equations on the
    grid using discrete spatial derivatives (Laplacians). Then, we update the variables
    using a discrete time derivative:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we display the variable `u` after a time `T` of simulation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_12_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Whereas the variables were completely random at initialization time, we observe
    the formation of patterns after a sufficiently long simulation time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explain how the finite difference method allowed us to implement the
    update step. We start from the following system of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We first use the following scheme for the discrete Laplace operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We also use this scheme for the time derivative of *u* and *v*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We end up with the following iterative update step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, our Neumann boundary conditions state that the spatial derivatives with
    respect to the normal vectors are null on the boundaries of the domain *E*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We implement these boundary conditions by duplicating values in matrices `U`
    and `V` on the edges (see the preceding code).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to ensure that our numerical scheme converges to a numerical solution
    that is close to the actual (unknown) mathematical solution, the stability of
    the scheme needs to be ascertained. One can show that a sufficient condition for
    the stability is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_12_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are further references on partial differential equations, reaction-diffusion
    systems, and numerical simulations of those systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Partial differential equations on Wikipedia, available at [http://en.wikipedia.org/wiki/Partial_differential_equation](http://en.wikipedia.org/wiki/Partial_differential_equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reaction-diffusion systems on Wikipedia, available at [http://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system](http://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FitzHugh-Nagumo system on Wikipedia, available at [http://en.wikipedia.org/wiki/FitzHugh%E2%80%93Nagumo_equation](http://en.wikipedia.org/wiki/FitzHugh%E2%80%93Nagumo_equation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neumann boundary conditions on Wikipedia, available at [http://en.wikipedia.org/wiki/Neumann_boundary_condition](http://en.wikipedia.org/wiki/Neumann_boundary_condition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Von Neumann stability analysis on Wikipedia, available at [http://en.wikipedia.org/wiki/Von_Neumann_stability_analysis](http://en.wikipedia.org/wiki/Von_Neumann_stability_analysis)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A course on Computational Fluid Dynamics by Prof. Lorena Barba, written in the
    IPython notebook, available at [https://github.com/barbagroup/CFDPython](https://github.com/barbagroup/CFDPython)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Simulating an elementary cellular automaton* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Simulating an ordinary differential equation with SciPy* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
