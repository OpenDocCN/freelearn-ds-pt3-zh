- en: Variables and Basic Types
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will present the most important and basic types in Python.
    What is a type? It is a set consisting of data content, its representation, and
    all possible operations. Later in this book, we will make this definition much
    more precise when we introduce the concepts of a class in [Chapter 8](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1 Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables are references to Python objects. They are created by assignments,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Variables take names that consist of any combination of capital and small letters,
    the underscore `_`, and digits. A variable name must not start with a digit. Note
    that variable names are case sensitive. A good naming of variables is an essential
    part of documenting your work, so we recommend that you use descriptive variable
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has 33 *reserved keywords*, which cannot be used as variable names (see *Table
    2.1*). Any attempt to use such a keyword as a variable name would raise a syntax
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e2e5bf9-1c77-4493-b5ce-f9f3b88e15c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 2.1: Reserved Python keywords'
  prefs: []
  type: TYPE_NORMAL
- en: 'As opposed to other programming languages, variables require no type declaration
    in Python. The type is automatically deduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create several variables with a multiple assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables can also be altered after their definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two statements can be written by combining the two operations with
    an assignment directly by using increment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 2.2 Numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, you will have to work with numbers, so we start by considering
    different forms of numeric types in Python. In mathematics, we distinguish between
    natural numbers (ℕ), integers (ℤ), rational numbers (ℚ), real numbers (ℝ), and
    complex numbers (ℂ). These are infinite sets of numbers. Operations differ between
    these sets and may even not be defined. For example, the usual division of two
    numbers in ℤ might not result in an integer — it is not defined on ℤ.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, like many other computer languages, we have numeric types:'
  prefs: []
  type: TYPE_NORMAL
- en: The numeric type, `int`, which is at least theoretically the entire ℤ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numeric type, `float`, which is a finite subset of ℝ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numeric type, `complex`, which is a finite subset of ℂ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finite sets have a smallest and a largest number and there is a minimum spacing
    between two numbers; see [Section 2.2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml), *Floating-point
    numbers*, for further details.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest numeric type is the integer type `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Plain integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The statement `k = 3` assigns the variable `k` to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying an operation such as `+`, `-`, or `*` to integers returns an integer.
    The division operator, `//`, returns an integer, while `/` returns a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The set of integers in Python is unbounded; there is no largest integer. The
    limitation here is the computer's memory rather than any fixed value given by
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: If the division operator (`/`) in the preceding example returns 3, you have
    not installed the correct Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2 Floating-point numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you execute the statement `a = 3.0` in Python, you create a floating-point
    number (Python type: `float`). These numbers form a finite subset of rational numbers,
    ℚ.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the constant could have been given in exponent notation as `a
    = 30.0e-1` or simply `a = 30.e-1`. The symbol `e` separates the exponent from
    the mantissa, and the expression reads in mathematical notation as ![](img/34c6a326-b6a8-4985-af30-2f6a912355f8.png).
    The name *floating-point number* refers to the internal representation of these
    numbers and reflects the floating position of the decimal point when considering
    numbers over a wide range.
  prefs: []
  type: TYPE_NORMAL
- en: Applying elementary mathematical operations, such as `+`, `-`, `*`, and `/`, to
    two floating-point numbers, or to an integer and a floating-point number, returns
    a floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations between floating-point numbers rarely return the exact result expected
    from rational number operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This fact matters when comparing floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this becomes apparent when looking at the internal representation
    of floating-point numbers; see also [Section 15.2.6](e921daa2-c37c-4799-a8b8-669dc9ae4d17.xhtml),
    *Float comparisons*.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A floating-point number is represented by three quantities: the sign, the mantissa,
    and the exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/615d5ecf-4f95-44a3-9c98-e91300ce69f1.png)'
  prefs: []
  type: TYPE_IMG
- en: with* [![](img/b7b5b7b3-cd43-4acd-b154-f87023b187c9.png)]* and *[![](img/80605848-6ca8-447f-a52f-05ec9704073e.png)].*
  prefs: []
  type: TYPE_NORMAL
- en: '[*![](img/d356713b-dec1-479a-aebe-e9fd8582010c.png)*]is called the mantissa, [![](img/13125744-0665-46f3-a841-e66b76d162af.png)]
    the basis, and *e* the exponent, with [![](img/773505d0-7d4e-4df5-9bb4-dc90034fd4e8.png)]. ![](img/f6b98d33-ab3e-45ae-8896-4ebd7f803c80.png)
    is called the mantissa length. The condition [![](img/731b9c41-d370-4233-988a-6c2aa92c5bd2.png)]
    makes the representation unique and saves, in the binary case ([![](img/09b99dd9-1794-403f-89a4-364e14b6a5ad.png)]),
    one bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Two-floating point zeros, [![](img/85d74507-c505-4b2d-bf9a-de895f79474d.png)]
    and [![](img/eea53272-b084-44c3-94b5-d13b7f26f9b2.png)], exist, both represented
    by the mantissa ![](img/b5ce2310-aa24-4ac9-93e8-55ebb4e05709.png).
  prefs: []
  type: TYPE_NORMAL
- en: On a typical Intel processor, [![](img/3ab8b74c-2a9e-4dc3-a6d3-9acdc1485486.png)].
    To represent a number in the `float` type, 64 bits are used, namely, 1 bit for
    the sign, ![](img/5d26973f-5573-4563-879e-1274e2f8d403.png) bits for the mantissa,
    and ![](img/ed7fbf30-ec56-4388-a342-d80506b81d79.png) bits for the exponent ![](img/766ba752-823f-4c34-b7de-73e7492d0707.png).
    The upper bound ![](img/b5e73e68-6101-4590-bb39-5a99dab93cea.png) for the exponent
    is consequently [![](img/545a2d24-00a4-48cc-80b9-a4d6ab49e17e.png)].
  prefs: []
  type: TYPE_NORMAL
- en: With this data, the smallest positive representable number is
  prefs: []
  type: TYPE_NORMAL
- en: '[^(![](img/59b1fc2c-de2a-4d2c-b2f4-8d5abbe63ecd.png))], and the largest [^(![](img/e21bd240-907b-4ee6-a79d-104715619589.png))]*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that floating-point numbers are not equally spaced in ![](img/ca6cbce7-a4ce-46d0-99bb-dca5f1794c47.png).
    There is, in particular, a gap at zero (see also [29]). The distance between ![](img/3eb1eae7-94e1-480b-841a-2fed7ac10df9.png)
    and the first positive number is *![](img/67eab6d8-e466-4605-ba04-a14143e434da.png),* while
    the distance between the first and the second is smaller by a factor ![](img/8473ff72-9b9e-487c-879a-2dbe99db75fb.png). This
    effect, caused by the normalization *![](img/a9bba62c-f778-4468-ac75-a5daa0022e28.png)*,
    is visualized in *Figure 2.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2749a48-1a66-4f9b-89c6-a75d5338a8f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The floating-point gap at zero. Here ![](img/d13b67f1-5714-4ab2-9464-57890ea60892.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This gap is filled equidistantly with *subnormal* floating-point numbers to
    which such a result is rounded. Subnormal floating-point numbers have the smallest
    possible exponent and do not follow the normalization convention, *![](img/a9bba62c-f778-4468-ac75-a5daa0022e28.png)*.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite and not a number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are, in total, ![](img/de248920-9ba1-48a4-9ff0-67d55e999013.png) floating-point
    numbers. Sometimes, a numerical algorithm computes floating-point numbers outside
    this range.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates number overflow or underflow. In NumPy, the special floating-point
    number `inf` is assigned to overflow results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with `inf` may lead to mathematically undefined results. This is indicated in Python
    by assigning the result another special floating-point number, `nan`. This stands
    for *not-a-number*, that is, an undefined result of a mathematical operation.
    To demonstrate this, we continue the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are special rules for operations with `nan` and `inf`. For instance, `nan` compared
    to anything (even to itself) always returns `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See *Exercise 4* for some surprising consequences of the fact that `nan` is never
    equal to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The float `inf` behaves much more as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One way to check for `nan` and `inf` is to use the functions `isnan` and `isinf`.
    Often, you want to react directly when a variable gets the value `nan` or `inf`.
    This can be achieved by using the NumPy command `seterr`. The following command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: would raise a `FloatingPointError` if a calculation were to return one of those
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Underflow – Machine epsilon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Underflow occurs when an operation results in a rational number that falls into
    the gap at zero; see *Figure 2.1*.
  prefs: []
  type: TYPE_NORMAL
- en: The *machine epsilon*, or rounding unit, is the largest number ![](img/6d100c01-69a0-4326-a8ed-b2b7ecbb38ef.png)
    such that ![](img/47f7d0b1-c2dd-4fa9-8bff-145c7015cb61.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that ![](img/a7c0bf81-47d4-4b9e-ac42-dd4d5f4dab79.png) on most of today''s computers.
    The value that applies on the actual machine you are running your code on is accessible
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The variable `sys.float_info` contains more information on the internal representation
    of the float type on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `float` converts other types to a floating-point number, if possible.
    This function is especially useful when converting an appropriate string to a
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Other float types in NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NumPy also provides other float types, known from other programming languages
    as double-precision and single-precision numbers, namely, `float64` and `float32`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The second last line demonstrates that `a` and `a1` do not differ in accuracy. A
    difference in accuracy exists between `a` and its single-precision counterpart, `a2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NumPy function `finfo` can be used to display information on these floating-point
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 2.2.3 Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex numbers are an extension of the real numbers frequently used in many
    scientific and engineering fields.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers in mathematics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complex numbers consist of two floating-point numbers, the real part, ![](img/083c68b7-6261-47c5-ba34-1159100bf27c.png),
    of the number, and its imaginary part, ![](img/fb28559a-4054-4030-83de-a51af952b28f.png). In mathematics,
    a complex number is written as ![](img/f0d38862-1d90-4fbb-866c-6452f22f82fb.png),
    where ![](img/76735070-c450-4546-9eb6-5ec65378509d.png) defined by ![](img/7dfea4b2-f817-4a4d-8cd5-df416093471f.png)
    is the *imaginary unit*. The conjugate complex counterpart of ![](img/9a4dbac2-6452-4e15-8c32-e4dfbf9f777f.png)
    is ![](img/f3c4e8c1-1e17-44c0-8d58-e939be4cdc44.png).
  prefs: []
  type: TYPE_NORMAL
- en: If the real part ![](img/226b452e-93e2-4f55-95b9-a56845d21fc0.png) is zero,
    the number is called an imaginary number.
  prefs: []
  type: TYPE_NORMAL
- en: The j notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, imaginary numbers are characterized by suffixing a floating-point
    number with the letter `j`, for example, `z = 5.2j`. A complex number is formed
    by the sum of a real number and an imaginary number, for example, `z = 3.5 + 5.2j`.
  prefs: []
  type: TYPE_NORMAL
- en: While in mathematics the imaginary part is expressed as a product of a real
    number *b* with the imaginary unit ![](img/6c2f614f-c3d2-4a4b-873e-7afdc5a20e1c.png),
    the Python way of expressing an imaginary number is not a product: `j` is just
    a suffix to indicate that the number is imaginary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is demonstrated by the following small experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `conjugate` returns the conjugate of `z`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Real and imaginary parts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may access the real and imaginary parts of a complex number ![](img/66674c49-3c36-41a0-835b-5a9128c904cb.png) using
    the `real` and `imag` attributes. Those attributes are read-only; in other words,
    they cannot be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not possible to convert a complex number to a real number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the `real` and `imag` attributes as well as the conjugate method
    work just as well for complex arrays; see also [Section 4.3.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml),
    *Array properties*. We demonstrate this by computing the *N*^(th) roots of unity,
    which are [![](img/aebd247a-5841-41fe-beb9-7e8703b90bdf.png)], that is, the ![](img/a2c3cdd6-df4f-4a77-914c-d73959af422d.png)
    solutions of the equation ![](img/58eb7ad5-3e96-4cc9-a2b5-b94a5d1f70d6.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The resulting figure shows the 10 roots of unity. In *Figure 2.2,* it is completed
    by a title and axes labels and shown together with the unit circle. (For more
    details on how to make plots, see [Chapter 6](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Plotting.*)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51d4e879-057e-4c49-a384-5d5fa6a0047f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Roots of unity together with the unit circle'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is, of course, possible to mix the previous methods, as illustrated by the
    following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 2.3 Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boolean is a data type named after *George Boole* (1815-1864). A Boolean variable
    can take only two values, `True` or `False`. The main use of this type is in logical
    expressions. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean expressions are often used in conjunction with `if` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 2.3.1 Boolean operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boolean operations are performed using the keywords `and`, `or`, and `not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The operators follow some precedence rules (see also [Section 1.3.5](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml), *Boolean
    expressions*) which would make the parentheses in the third and in the last line
    obsolete. Nevertheless, it is a good practice to use them in any case to increase
    the readability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, the `and` operator is implicitly chained in the following Boolean expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 2.3.2 Boolean casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most Python objects may be converted to Booleans; this is called *Boolean casting*.
    The built-in function `bool` performs that conversion. Note that most objects are
    cast to `True`, except `0`, the empty tuple, the empty list, the empty string,
    or the empty array. These are all cast to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7af5ff18-ba2e-4707-95be-406c33a9baf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 2.2: Casting rules for Booleans'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is *not* possible to cast arrays into Booleans unless they contain no or
    only one element; this is explained further in [Section 5.2.1](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml), *Boolean
    arrays*. The previous table (see Table 2.2: C*asting rules for Booleans*) contains
    summarized rules for Boolean casting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We demonstrate this by means of some usage examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Automatic Boolean casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using an `if` statement with a non-Boolean type will cast it to a Boolean. In other
    words, the following two statements are always equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical example is testing whether a list is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: An empty list, or tuple, will return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a variable in the `if` statement, for example, an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used `%` for the *modulo operation*, which returns the remainder
    of an integer division. In this case, it returns `0` or `1` as the remainder after
    modulo 2.
  prefs: []
  type: TYPE_NORMAL
- en: In this last example, the values `0` or `1` are cast to `bool`; see also [Section
    2.3.4](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml), *Booleans and integers.*
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean operators `or`, `and`, and `not` will also implicitly convert some
    of their arguments to a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3 Return values of and and or
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that the operators `and` and `or` do not necessarily produce Boolean values.
    This can be explained by the fact that the expression `*x* and *y*` is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Correspondingly, the expression `x or y` is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, this means that when executing the statement `True or x`, the
    variable `x` need not even be defined! The same holds for `False and x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, unlike their counterparts in mathematical logic, these operators
    are no longer commutative in Python. Indeed, the following expressions are not
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 2.3.4 Booleans and integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In fact, Booleans and integers are the same. The only difference is in the
    string representations of `0` and `1`, which, in the case of Booleans, is `False` and `True`, respectively.
    This allows constructions such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The last line in this example uses string formatting, which is explained in
    [Section 2.4.3](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml), *String formatting.*
  prefs: []
  type: TYPE_NORMAL
- en: We note for readers already familiar with the concept of subclasses that the
    type `bool` is a subclass of the type `int` (see [Chapter 8](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *Classes*).
    Indeed, all four inquiries – `isinstance(True, bool)`, `isinstance(False, bool)`, `isinstance(True,
    int)`, and `isinstance(False, int)` return the value `True` (see [Section 3.7](c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml), *Checking
    the type of a variable*).
  prefs: []
  type: TYPE_NORMAL
- en: Even rarely used statements such as `True+13` are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The type `string` is a type used for text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A string is enclosed either by single or double quotes. If a string contains
    several lines, it has to be enclosed by three double quotes `"""` or three single
    quotes `'''`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings can be indexed with simple indexes or slices (see  Chapter 3: *Container
    Types*, for a comprehensive explanation on slices):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are immutable; that is, items cannot be altered. They share this property
    with tuples. The command **`book[1] = ''a''`** returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 2.4.1 Escape sequences and raw strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The string `''\n''` is used to insert a line break and `''\t''` inserts a horizontal
    tabulator (TAB) into the string to align several lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These strings are examples of *escape sequences*. Escape sequences always start
    with a backslash, `\`. A multiline string automatically includes escape sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A special escape sequence is `"\\"`, which represents the backslash symbol in text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved by using a *raw string* instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in raw strings, the backslash remains in the string and is used to
    escape some special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A raw string is a convenient tool to construct strings in a readable manner.
    The result is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 2.4.2 Operations on strings and string methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The addition of several strings results in their concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently, multiplication by an integer is repeated addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Multiplication by floating-point or complex numbers is undefined and results
    in a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When strings are compared, lexicographical order applies and the uppercase
    form precedes the lowercase form of the same letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Among the variety of string methods, we will mention here only the most important
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Splitting a string**: This method generates a list from a string by using
    a single or multiple blanks as separators. Alternatively, an argument can be given
    by specifying a particular substring as a separator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Joining a list to a string**: This is the reverse operation of splitting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Searching in a string**: This method returns the first index in the string,
    where a given search substring starts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the search string is not found, the return value of the method is `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**String formatting:** This method inserts values of variables or results of
    expressions into a string. It is so important that we devote the following subsection
    to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.4.3 String formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String formatting is the process of inserting values into a given string and
    determining the way in which they are displayed. This can be done in various ways.
    We first describe the related string method, `format`, and the more modern alternative,
    the so-called *f-string*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example regarding the use of the format method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example of the variant by using an *f-string*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The function `format` is a string method; it scans the string for the occurrence
    of placeholders, which are enclosed by curly brackets. These placeholders are
    replaced in a way specified by the argument of the format method. How they are
    replaced depends on the format specification defined in each `{}` pair. Format
    specifications are indicated by a colon, `":"`, as their prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format method offers a range of possibilities to customize the formatting
    of objects depending on their types. Of particular use in scientific computing
    are the formatting specifiers for the `float` type. You may choose either the
    standard fixed-point notation with `{:f}` or the exponential notation with `{:e}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, format specifiers can be used also in f-strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The format specifiers allow specifying the rounding precision (digits following
    the decimal point in the representation). Also, the total number of symbols, including
    leading blanks, to represent the number can be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the name of the object that gets its value inserted is given
    as an argument to the format method. The first `{}` pair is replaced by the first
    argument, and the following pairs by the subsequent arguments. Alternatively,
    it may also be convenient to use the key-value syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, two values are processed – a string `name` without a format specifier,
    and a float `value` that is printed in fixed-point notation with one digit after
    the decimal point. (Refer to the complete reference documentation for more details
    on *string formatting.)*
  prefs: []
  type: TYPE_NORMAL
- en: '**Braces in the string**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a string might contain a pair of curly braces, which should not
    be considered as placeholders for a `format` method. In that case, double braces
    are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r"we {} in LaTeX \begin{{equation}}".format(''like'')`'
  prefs: []
  type: TYPE_NORMAL
- en: This returns the following string: `'we like in LaTeX \\begin{equation}'`.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you met the basic data types in Python and saw the corresponding
    syntax elements. We will work mostly with numeric types such as integers, floats,
    and complex.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are needed for setting conditions, and by using strings, we often communicate
    results and messages.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Check whether ![](img/454aa923-95fe-4033-881c-b68b24473d7c.png)
    is a zero of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/f3aee195-caa2-4f76-95d7-0c5fda083725.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2:** According to de Moivre''s formula, the following holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5572ccc3-cd6a-47df-9126-121400fec998.png)'
  prefs: []
  type: TYPE_IMG
- en: Choose numbers *n* and *x* and verify that formula in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3:** Complex numbers. Verify Euler''s formula in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87cab0d6-37d2-4738-bbe5-b9606f42424d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 4:** Suppose we are trying to check the convergence of a diverging sequence
    (here, the sequence is defined by the recursive relation ![](img/5bcda964-c7e2-47e7-8cf9-2bae91d8b1b5.png)
    and ![](img/0b4ceaa6-cea3-485e-aa01-10fc06d8fbee.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since the sequence does not converge, the code should print the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`No convergence` message. Execute it to see what happens.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What happens if you replace the line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It should give exactly the same result, shouldn't it? Run the code again to
    see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you replace `u=1.0` with `u=1` (without a decimal point)? Run
    the code to check your predictions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the unexpected behavior of this code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 5:** An implication *C = (A ⇒ B)* is a Boolean expression that is defined
    as'
  prefs: []
  type: TYPE_NORMAL
- en: '*C* is `True` if *A* is `False`, or *A* and *B* are both `True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C* is `False` otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a Python function `implication(A, B)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6:** This exercise is to train Boolean operations. Two binary digits
    (bits) are added by using a logical device called a **half adder**. It produces
    a carry bit (the digit of the next higher value) and the sum as defined by the
    following table, and half adder circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **p** | **q** | **sum** | **carry** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Definition of the half adder operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8bef38d-13a1-4935-bb44-83b698931dd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A half adder circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'A full adder consists of two half adders and sums two bits and an additional
    carry bit on the input (see also the following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52dc0ff0-c354-46a9-ab57-9278142e62f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: A full adder circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function that implements a half adder and another that implements a
    full adder. Test these functions.
  prefs: []
  type: TYPE_NORMAL
