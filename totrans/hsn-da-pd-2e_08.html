<html><head></head><body>
		<div id="_idContainer308">
			<h1 id="_idParaDest-126"><em class="italic"><a id="_idTextAnchor125"/>Chapter 6</em>: Plotting with Seaborn and Customization Techniques</h1>
			<p>In the previous chapter, we learned how to create many different visualizations using <strong class="source-inline">matplotlib</strong> and <strong class="source-inline">pandas</strong> on wide-format data. In this chapter, we will see how we can make visualizations from long-format data, using <strong class="source-inline">seaborn</strong>, and how to customize our plots to improve their interpretability. Remember that the human brain excels at finding patterns in visual representations; by making clear and meaningful data visualizations, we can help others (not to mention ourselves) understand what the data is trying to say.</p>
			<p>Seaborn is capable of making many of the same plots we created in the previous chapter; however, it also makes quick work of long-format data, allowing us to use subsets of our data to encode additional information into our visualizations, such as facets and/or colors for different categories. We will walk through some implementations of what we did in the previous chapter that are easier (or just more aesthetically pleasing) using <strong class="source-inline">seaborn</strong>, such as heatmaps and pair plots (the <strong class="source-inline">seaborn</strong> equivalent of the scatter plot matrix). In addition, we will explore some new plot types that <strong class="source-inline">seaborn</strong> provides to address issues that other plot types may be susceptible to.</p>
			<p>Afterward, we will change gears and begin our discussion on customizing the appearance of our data visualizations. We will walk through the process of creating annotations, adding reference lines, properly labeling our plots, controlling the color palette used, and tailoring the axes to meet our needs. This is the final piece we need to make our visualizations ready to present to others.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Utilizing seaborn for more advanced plot types</li>
				<li>Formatting plots with matplotlib</li>
				<li>Customizing visualizations</li>
			</ul>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Chapter materials</h1>
			<p>The materials for this chapter can be found on GitHub at <a href="https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06">https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_06</a>. We will be working with three datasets once again, all of which can be found in the <strong class="source-inline">data/</strong> directory. In the <strong class="source-inline">fb_stock_prices_2018.csv</strong> file, we have Facebook's stock price for all trading days in 2018. This data is the OHLC data (opening, high, low, and closing price), along with the volume traded. It was gathered using the <strong class="source-inline">stock_analysis</strong> package, which we will build in <a href="B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">Financial Analysis – Bitcoin and the Stock Market</em>. The stock market is closed on the weekends, so we only have data for the trading days.</p>
			<p>The <strong class="source-inline">earthquakes.csv</strong> file contains earthquake data pulled from the <strong class="bold">United States Geological Survey</strong> (<strong class="bold">USGS</strong>) API (<a href="https://earthquake.usgs.gov/fdsnws/event/1/">https://earthquake.usgs.gov/fdsnws/event/1/</a>) for September 18, 2018, through October 13, 2018. For each earthquake, we have the magnitude (the <strong class="source-inline">mag</strong> column), the scale it was measured on (the <strong class="source-inline">magType</strong> column), when (the <strong class="source-inline">time</strong> column), and where (the <strong class="source-inline">place</strong> column) it occurred; we also have the <strong class="source-inline">parsed_place</strong> column, which indicates the state or country in which the earthquake occurred (we added this column back in <a href="B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Pandas DataFrames</em>). Other unnecessary columns have been removed.</p>
			<p>In the <strong class="source-inline">covid19_cases.csv</strong> file, we have an export from the <em class="italic">daily number of new reported cases of COVID-19 by country worldwide</em> dataset provided by the <strong class="bold">European Centre for Disease Prevention and Control</strong> (<strong class="bold">ECDC</strong>), which can be found at <a href="https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide">https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide</a>. For scripted or automated collection of this data, the ECDC makes the current day's CSV file available via this link: <a href="https://opendata.ecdc.europa.eu/covid19/casedistribution/csv">https://opendata.ecdc.europa.eu/covid19/casedistribution/csv</a>. The snapshot we will be using was collected on September 19, 2020 and contains the number of new COVID-19 cases per country from December 31, 2019 through September 18, 2020 with partial data for September 19, 2020. For this chapter, we will look at the 8-month span from January 18, 2020 through September 18, 2020.</p>
			<p>Throughout this chapter, we will be working through three Jupyter Notebooks. These are all numbered according to their order of use. We will begin exploring the capabilities of <strong class="source-inline">seaborn</strong> in the <strong class="source-inline">1-introduction_to_seaborn.ipynb</strong> notebook. Next, we will move on to the <strong class="source-inline">2-formatting_plots.ipynb</strong> notebook as we discuss formatting and labeling our plots. Finally, in the <strong class="source-inline">3-customizing_visualizations.ipynb</strong> notebook, we will learn how to add reference lines, shade regions, include annotations, and customize our visualizations. The text will prompt us when to switch notebooks.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The supplementary <strong class="source-inline">covid19_cases_map.ipynb</strong> notebook walks through an example of plotting data on a map using COVID-19 cases worldwide. It can be used to get started with maps in Python and also builds upon some of the formatting we will discuss in this chapter.</p>
			<p>In addition, we have two Python (<strong class="source-inline">.py</strong>) files that contain functions we will use throughout the chapter: <strong class="source-inline">viz</strong><strong class="source-inline">.py</strong> and <strong class="source-inline">color_utils.py</strong>. Let's get started by exploring <strong class="source-inline">seaborn</strong>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Utilizing seaborn for advanced plotting</h1>
			<p>As we saw in the <a id="_idIndexMarker722"/>previous chapter, <strong class="source-inline">pandas</strong> provides implementations for most visualizations we would want to create; however, there is another library, <strong class="source-inline">seaborn</strong>, that provides<a id="_idIndexMarker723"/> additional functionality for more involved visualizations and makes creating visualizations with long-format data much easier than <strong class="source-inline">pandas</strong>. These also tend to look much nicer than standard visualizations generated by <strong class="source-inline">matplotlib</strong>. </p>
			<p>For this section, we will be working with the <strong class="source-inline">1-introduction_to_seaborn.ipynb</strong> notebook. First, we must import <strong class="source-inline">seaborn</strong>, which is traditionally aliased as <strong class="source-inline">sns</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; import seaborn as sns</p>
			<p>Let's also import <strong class="source-inline">numpy</strong>, <strong class="source-inline">matplotlib.pyplot</strong>, and <strong class="source-inline">pandas</strong>, and then read in the CSV files for the Facebook stock prices and earthquake data:</p>
			<p class="source-code">&gt;&gt;&gt; %matplotlib inline</p>
			<p class="source-code">&gt;&gt;&gt; import matplotlib.pyplot as plt</p>
			<p class="source-code">&gt;&gt;&gt; import numpy as np</p>
			<p class="source-code">&gt;&gt;&gt; import pandas as pd </p>
			<p class="source-code">&gt;&gt;&gt; fb = pd.read_csv(</p>
			<p class="source-code">...     'data/fb_stock_prices_2018.csv',</p>
			<p class="source-code">...     index_col='date', </p>
			<p class="source-code">...     parse_dates=True</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; quakes = pd.read_csv('data/earthquakes.csv')</p>
			<p>While <strong class="source-inline">seaborn</strong> offers<a id="_idIndexMarker724"/> alternatives to many of the plot types we covered in the previous chapter, for the most part, we will only cover new types that <strong class="source-inline">seaborn</strong> makes possible<a id="_idIndexMarker725"/> and leave learning about the rest as an exercise. Additional available functions using the <strong class="source-inline">seaborn</strong> API can be found at <a href="https://seaborn.pydata.org/api.html">https://seaborn.pydata.org/api.html</a>.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Categorical data</h2>
			<p>There was a devastating tsunami in<a id="_idIndexMarker726"/> Indonesia on September 28, 2018; it came after a 7.5 magnitude earthquake occurred near Palu, Indonesia (<a href="https://www.livescience.com/63721-tsunami-earthquake-indonesia.html">https://www.livescience.com/63721-tsunami-earthquake-indonesia.html</a>). Let's create a visualization to understand which magnitude types are used in Indonesia, the range of magnitudes recorded, and how many of the earthquakes were accompanied by a tsunami. To do this, we need a way to plot relationships in which one of the variables is categorical (<strong class="source-inline">magType</strong>) and the other is numeric (<strong class="source-inline">mag</strong>).</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Information on the different magnitude types can be found at <a href="https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types">https://www.usgs.gov/natural-hazards/earthquake-hazards/science/magnitude-types</a>.</p>
			<p>When we discussed scatter plots in <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em>, we were limited to both variables being numeric; however, with <strong class="source-inline">seaborn</strong>, we have two additional plot types at our disposal that allow us to have one categorical and one numeric variable. The first is the <strong class="source-inline">stripplot()</strong> function, which plots the points in strips that denote each category. The second is the <strong class="source-inline">swarmplot()</strong> function, which we will see later.</p>
			<p>Let's create this<a id="_idIndexMarker727"/> visualization with <strong class="source-inline">stripplot()</strong>. We pass the subset of earthquakes occurring in Indonesia to the <strong class="source-inline">data</strong> parameter, and specify that we want to put <strong class="source-inline">magType</strong> on the <em class="italic">x</em>-axis (<strong class="source-inline">x</strong>), magnitudes on the <em class="italic">y</em>-axis (<strong class="source-inline">y</strong>), and color the points by whether the earthquake was accompanied by a tsunami (<strong class="source-inline">hue</strong>):</p>
			<p class="source-code">&gt;&gt;&gt; sns.stripplot(</p>
			<p class="source-code">...     x='magType', </p>
			<p class="source-code">...     y='mag', </p>
			<p class="source-code">...     hue='tsunami',</p>
			<p class="source-code">...     data=quakes.query('parsed_place == "Indonesia"')</p>
			<p class="source-code">... )</p>
			<p>Using the resulting plot, we can see that the earthquake in question is the highest orange point in the <strong class="source-inline">mww</strong> column (don't forget to call <strong class="source-inline">plt.show()</strong> if not using the Jupyter Notebook provided):</p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/fig_6.1.jpg" alt="Figure 6.1 – Seaborn's strip plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Seaborn's strip plot</p>
			<p>For the most part, the tsunamis occurred with higher magnitude earthquakes, as we would expect; however, due to the high concentration of points at lower magnitudes, we can't really see all the points. We could try to adjust the <strong class="source-inline">jitter</strong> argument, which controls how much random noise to add to the point in an attempt to reduce overlaps, or the <strong class="source-inline">alpha</strong> argument <a id="_idIndexMarker728"/>for transparency, as we did in the previous chapter; fortunately, there is another function, <strong class="source-inline">swarmplot()</strong>, that will reduce the overlap as much as possible, so we will use that instead:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">sns.swarmplot</strong>(</p>
			<p class="source-code">...     x='magType', </p>
			<p class="source-code">...     y='mag', </p>
			<p class="source-code">...     hue='tsunami',</p>
			<p class="source-code">...     data=quakes.query('parsed_place == "Indonesia"'),</p>
			<p class="source-code">...     size=3.5 # point size</p>
			<p class="source-code">... )</p>
			<p>The <strong class="bold">swarm plot</strong> (or bee swarm plot) also has<a id="_idIndexMarker729"/> the bonus of giving us a glimpse of what the distribution might be. We can now see many more earthquakes in the lower section of the <strong class="source-inline">mb</strong> column:</p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/fig_6.2.jpg" alt="Figure 6.2 – Seaborn's swarm plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Seaborn's swarm plot</p>
			<p>In the <em class="italic">Plotting with pandas</em> section in the previous chapter, when we discussed how to visualize distributions, we discussed the box plot. Seaborn provides an enhanced box plot for large datasets, which<a id="_idIndexMarker730"/> shows additional quantiles for more information on the shape of the distribution, particularly in the tails. Let's use the enhanced box plot to compare earthquake magnitudes across different magnitude types, as we did in <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em>:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">sns.boxenplot(</strong></p>
			<p class="source-code">...     <strong class="bold">x='magType', y='mag', data=quakes[['magType', 'mag']]</strong></p>
			<p class="source-code">... <strong class="bold">)</strong></p>
			<p class="source-code">&gt;&gt;&gt; plt.title('Comparing earthquake magnitude by magType')</p>
			<p>This results in the following plot:</p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/fig_6.3.jpg" alt="Figure 6.3 – Seaborn's enhanced box plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Seaborn's enhanced box plot</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The enhanced box plot was introduced in the paper <em class="italic">Letter-value plots: Boxplots for large data,</em> by Heike Hofmann, Karen Kafadar, and Hadley Wickham, which can be found at <a href="https://vita.had.co.nz/papers/letter-value-plot.html">https://vita.had.co.nz/papers/letter-value-plot.html</a>.</p>
			<p>Box plots are great for visualizing the quantiles of our data, but we lose information about the distribution. As we saw, an enhanced box plot is one way to address this—another strategy is to use a <a id="_idIndexMarker731"/>violin plot, which combines a kernel density estimate (estimation of the underlying distribution) and a box plot:</p>
			<p class="source-code">&gt;&gt;&gt; fig, axes = plt.subplots(figsize=(10, 5))</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">sns.violinplot(</strong></p>
			<p class="source-code">...     <strong class="bold">x='magType', y='mag', data=quakes[['magType', 'mag']],</strong> </p>
			<p class="source-code">...     <strong class="bold">ax=axes, scale='width'</strong> # all violins have same width</p>
			<p class="source-code">... <strong class="bold">)</strong></p>
			<p class="source-code">&gt;&gt;&gt; plt.title('Comparing earthquake magnitude by magType')</p>
			<p>The box plot portion runs through the <a id="_idIndexMarker732"/>center of each violin plot; the <strong class="bold">kernel density estimate</strong> (<strong class="bold">KDE</strong>) is then drawn on both sides using the box plot as its <em class="italic">x</em>-axis. We can read the KDE from either side of the box plot since it is symmetrical:</p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/fig_6.4.jpg" alt="Figure 6.4 – Seaborn's violin plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Seaborn's violin plot</p>
			<p>The <strong class="source-inline">seaborn</strong> documentation also lists out the plotting functions by the type of data being plotted; the full offering of categorical plots is available at <a href="https://seaborn.pydata.org/api.html#categorical-plots">https://seaborn.pydata.org/api.html#categorical-plots</a>. Be sure to check out the <strong class="source-inline">countplot()</strong> and <strong class="source-inline">barplot()</strong> functions for<a id="_idIndexMarker733"/> variations on the bar plots we created with <strong class="source-inline">pandas</strong> in the previous chapter.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Correlations and heatmaps</h2>
			<p>As promised, let's learn an <a id="_idIndexMarker734"/>easier way to generate heatmaps compared to what we had to do in <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em>. Once again, we will make a heatmap of the correlations between the OHLC stock prices, the log of volume traded, and the daily difference <a id="_idIndexMarker735"/>between the highest and lowest prices (<strong class="source-inline">max_abs_change</strong>); however, this time, we will use <strong class="source-inline">seaborn</strong>, which gives us the <strong class="source-inline">heatmap()</strong> function for an easier way to produce this visualization:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">sns.heatmap(</strong></p>
			<p class="source-code">...     fb.sort_index().assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low</p>
			<p class="source-code">...     ).corr(), </p>
			<p class="source-code">...     <strong class="bold">annot=True, </strong></p>
			<p class="source-code">...     <strong class="bold">center=0, </strong></p>
			<p class="source-code">...     <strong class="bold">vmin=-1, </strong></p>
			<p class="source-code">...     <strong class="bold">vmax=1</strong></p>
			<p class="source-code">... <strong class="bold">)</strong></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When using <strong class="source-inline">seaborn</strong>, we can still use functions from <strong class="source-inline">matplotlib</strong>, such as <strong class="source-inline">plt.savefig()</strong> and <strong class="source-inline">plt.tight_layout()</strong>. Note that if there are issues with <strong class="source-inline">plt.tight_layout()</strong>, pass <strong class="source-inline">bbox_inches='tight'</strong> to <strong class="source-inline">plt.savefig()</strong> instead.</p>
			<p>We pass in <strong class="source-inline">center=0</strong> so that <strong class="source-inline">seaborn</strong> puts values of <strong class="source-inline">0</strong> (no correlation) at the center of the colormap it uses. In order to set the bounds of the color scale to that of the correlation coefficient, we need to provide <strong class="source-inline">vmin=-1</strong> and <strong class="source-inline">vmax=1</strong> as well. Notice that we also passed in <strong class="source-inline">annot=True</strong> to write the correlation coefficients in each box—we get the benefit of the numerical data and the visual data all in one plot with a single function call:</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/fig_6.5.jpg" alt="Figure 6.5 – Seaborn's heatmap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Seaborn's heatmap</p>
			<p>Seaborn also <a id="_idIndexMarker736"/>provides us with an alternative to the <strong class="source-inline">scatter_matrix()</strong> function provided in the <strong class="source-inline">pandas.plotting</strong> module, called <strong class="source-inline">pairplot()</strong>. We can use this to see the correlations between the <a id="_idIndexMarker737"/>columns in the Facebook data as scatter plots instead of the heatmap:</p>
			<p class="source-code">&gt;&gt;&gt; sns.pairplot(fb)</p>
			<p>This result makes it easy to understand the near-perfect positive correlation between the OHLC columns shown in the heatmap, while also showing us histograms for each column along the diagonal:</p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/fig_6.6.jpg" alt="Figure 6.6 – Seaborn's pair plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Seaborn's pair plot</p>
			<p>Facebook's<a id="_idIndexMarker738"/> performance in the latter half of 2018 was <a id="_idIndexMarker739"/>markedly worse than in the first half, so we may be interested to see how the distribution of the data changed each quarter of the year. As with the <strong class="source-inline">pandas.plotting.scatter_matrix()</strong> function, we can specify what to do along the diagonal with the <strong class="source-inline">diag_kind</strong> argument; however, unlike <strong class="source-inline">pandas</strong>, we can easily color everything based on other data with the <strong class="source-inline">hue</strong> argument. To do so, we just add the <strong class="source-inline">quarter</strong> column and then provide it to the <strong class="source-inline">hue</strong> argument:</p>
			<p class="source-code">&gt;&gt;&gt; sns.pairplot(</p>
			<p class="source-code">...     fb.assign(quarter=lambda x: x.index.quarter), </p>
			<p class="source-code">...     <strong class="bold">diag_kind='kde', hue='quarter'</strong></p>
			<p class="source-code">... )</p>
			<p>We can now see how the<a id="_idIndexMarker740"/> distributions of the OHLC columns had lower standard <a id="_idIndexMarker741"/>deviations (and, subsequently, lower variances) in the first quarter and how the stock price lost a lot of ground in the fourth quarter (the distribution shifts to the left):</p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/fig_6.7.jpg" alt="Figure 6.7 – Utilizing the data to determine plot colors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Utilizing the data to determine plot colors</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We can <a id="_idIndexMarker742"/>also pass <strong class="source-inline">kind='reg'</strong> to <strong class="source-inline">pairplot()</strong> to show<a id="_idIndexMarker743"/> regression lines.</p>
			<p>If we only want to compare two variables, we can use <strong class="source-inline">jointplot()</strong>, which will give us a scatter plot along with the distribution of each variable along the side. Let's look once again at how the log of volume traded correlates with the difference between the daily high and low prices in Facebook stock, as we did in <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em>:</p>
			<p class="source-code">&gt;&gt;&gt; sns.jointplot(</p>
			<p class="source-code">...     x='log_volume', </p>
			<p class="source-code">...     y='max_abs_change', </p>
			<p class="source-code">...     data=fb.assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low</p>
			<p class="source-code">...     )</p>
			<p class="source-code">... )</p>
			<p>Using the default value for the <strong class="source-inline">kind</strong> argument, we get histograms for the distributions and a plain scatter plot in the center:</p>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="image/fig_6.8.jpg" alt="Figure 6.8 – Seaborn's joint plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Seaborn's joint plot</p>
			<p>Seaborn gives us <a id="_idIndexMarker744"/>plenty of alternatives for the <strong class="source-inline">kind</strong> argument. For example, we can use hexbins because there is a significant overlap when we use the <a id="_idIndexMarker745"/>scatter plot:</p>
			<p class="source-code">&gt;&gt;&gt; sns.jointplot(</p>
			<p class="source-code">...     x='log_volume', </p>
			<p class="source-code">...     y='max_abs_change', </p>
			<p class="source-code">...     <strong class="bold">kind='hex'</strong>,</p>
			<p class="source-code">...     data=fb.assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low</p>
			<p class="source-code">...     )</p>
			<p class="source-code">... )</p>
			<p>We can now see the large concentration of points in the lower-left corner:</p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="image/fig_6.9.jpg" alt="Figure 6.9 – Joint plot using hexbins&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Joint plot using hexbins</p>
			<p>Another way of viewing the <a id="_idIndexMarker746"/>concentration <a id="_idIndexMarker747"/>of values is to use <strong class="source-inline">kind='kde'</strong>, which gives us a <strong class="bold">contour plot</strong> to represent the joint<a id="_idIndexMarker748"/> density estimate along with KDEs for each of the variables:</p>
			<p class="source-code">&gt;&gt;&gt; sns.jointplot(</p>
			<p class="source-code">...     x='log_volume', </p>
			<p class="source-code">...     y='max_abs_change', </p>
			<p class="source-code">...     <strong class="bold">kind='kde'</strong>,</p>
			<p class="source-code">...     data=fb.assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low</p>
			<p class="source-code">...     )</p>
			<p class="source-code">... )</p>
			<p>Each curve in the <a id="_idIndexMarker749"/>contour plot contains points of a given density:</p>
			<div>
				<div id="_idContainer276" class="IMG---Figure">
					<img src="image/fig_6.10.jpg" alt="Figure 6.10 – Joint distribution plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Joint distribution plot</p>
			<p>Furthermore, we <a id="_idIndexMarker750"/>can plot a regression in the center and get KDEs in addition to histograms along the sides:</p>
			<p class="source-code">&gt;&gt;&gt; sns.jointplot(</p>
			<p class="source-code">...     x='log_volume', </p>
			<p class="source-code">...     y='max_abs_change', </p>
			<p class="source-code">...     <strong class="bold">kind='reg'</strong>,</p>
			<p class="source-code">...     data=fb.assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low</p>
			<p class="source-code">...     )</p>
			<p class="source-code">... )</p>
			<p>This results in a linear regression<a id="_idIndexMarker751"/> line being drawn<a id="_idIndexMarker752"/> through the scatter plot, along with a confidence band surrounding the line in a lighter color:</p>
			<div>
				<div id="_idContainer277" class="IMG---Figure">
					<img src="image/fig_6.11.jpg" alt="Figure 6.11 – Joint plot with linear regression and KDEs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Joint plot with linear regression and KDEs</p>
			<p>The relationship appears to be linear, but <a id="_idIndexMarker753"/>we should look at the <strong class="bold">residuals</strong> to check. Residuals are the observed values minus the values predicted using the regression line. We can look directly at the residuals that would result from the previous regression with <strong class="source-inline">kind='resid'</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; sns.jointplot(</p>
			<p class="source-code">...     x='log_volume', </p>
			<p class="source-code">...     y='max_abs_change', </p>
			<p class="source-code">...     <strong class="bold">kind='resid'</strong>,</p>
			<p class="source-code">...     data=fb.assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low</p>
			<p class="source-code">...     )</p>
			<p class="source-code">... )</p>
			<p class="source-code"># update y-axis label (discussed next section)</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('residuals')</p>
			<p>Notice that the residuals appear to<a id="_idIndexMarker754"/> be getting further away from zero at higher quantities of volume traded, which could mean this isn't the right way <a id="_idIndexMarker755"/>to model this relationship:</p>
			<div>
				<div id="_idContainer278" class="IMG---Figure">
					<img src="image/fig_6.12.jpg" alt="Figure 6.12 – Joint plot showing linear regression residuals&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Joint plot showing linear regression residuals</p>
			<p>We just saw that we can use <strong class="source-inline">jointplot()</strong> to get a regression plot or a residuals plot; naturally, <strong class="source-inline">seaborn</strong> exposes functions to make these directly without the overhead of creating the entire joint plot. Let's discuss those next.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Regression plots</h2>
			<p>The <strong class="source-inline">regplot()</strong> function will calculate a regression line and plot it, while the <strong class="source-inline">residplot()</strong> function will calculate the regression and plot only the residuals. We can write a function to combine these for<a id="_idIndexMarker756"/> us, but first, some setup.</p>
			<p>Our function will plot all permutations of any two columns (as opposed to combinations; order matters with permutations, for example, <strong class="source-inline">(open, close)</strong> is not equivalent to <strong class="source-inline">(close, open)</strong>). This allows us to see each column as the regressor and as the dependent variable; since we don't know the direction of the relationship, we let the viewer decide after calling the function. This generates many subplots, so we will create a new dataframe with just a few columns from our Facebook data.</p>
			<p>We'll be looking at the logarithm of the volume traded (<strong class="source-inline">log_volume</strong>) and the daily difference between the highest and lowest price of Facebook stock (<strong class="source-inline">max_abs_change</strong>). Let's use <strong class="source-inline">assign()</strong> to create these new columns and save them in a new dataframe called <strong class="source-inline">fb_reg_data</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; fb_reg_data = fb.assign(</p>
			<p class="source-code">...     log_volume=np.log(fb.volume), </p>
			<p class="source-code">...     max_abs_change=fb.high - fb.low</p>
			<p class="source-code">... ).iloc[:,-2:]</p>
			<p>Next, we need to import <strong class="source-inline">itertools</strong>, which is part of the Python standard library (<a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a>). When writing plotting functions, <strong class="source-inline">itertools</strong> can be extremely helpful; it makes it very easy to create efficient iterators for things such as permutations, combinations, and infinite cycles or repeats:</p>
			<p class="source-code">&gt;&gt;&gt; import itertools</p>
			<p><strong class="bold">Iterables</strong> are objects<a id="_idIndexMarker757"/> that can be iterated over. When we start a loop, an <strong class="bold">iterator</strong> is created from the iterable. At each iteration, the iterator <a id="_idIndexMarker758"/>provides its next value, until it is exhausted; this means that once we complete a single iteration through all its items, there is nothing left, and it can't be reused. Iterators are iterables, but not all iterables are iterators. Iterables that aren't iterators can be used repeatedly. </p>
			<p>The iterators we get back when using <strong class="source-inline">itertools</strong> can only be used once through:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">iterator = itertools.repeat("I'm an iterator", 1)</strong></p>
			<p class="source-code">&gt;&gt;&gt; for i in iterator:</p>
			<p class="source-code">...     print(f'--&gt;{i}')</p>
			<p class="source-code">--&gt;I'm an iterator</p>
			<p class="source-code">&gt;&gt;&gt; print(</p>
			<p class="source-code">...     'This printed once because the iterator '</p>
			<p class="source-code">...     'has been exhausted'</p>
			<p class="source-code">... )</p>
			<p class="source-code">This printed once because the iterator has been exhausted</p>
			<p class="source-code">&gt;&gt;&gt; for i in iterator:</p>
			<p class="source-code">...     print(f'--&gt;{i}')</p>
			<p>A list, on the other hand, is an <a id="_idIndexMarker759"/>iterable; we can write something that loops over all the elements in the list, and we will still have a list for later reuse:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">iterable = list(itertools.repeat("I'm an iterable", 1))</strong></p>
			<p class="source-code">&gt;&gt;&gt; for i in iterable:</p>
			<p class="source-code">...     print(f'--&gt;{i}')</p>
			<p class="source-code">--&gt;I'm an iterable</p>
			<p class="source-code">&gt;&gt;&gt; print('This prints again because it\'s an iterable:')</p>
			<p class="source-code">This prints again because it's an iterable:</p>
			<p class="source-code">&gt;&gt;&gt; for i in iterable:</p>
			<p class="source-code">...     print(f'--&gt;{i}')</p>
			<p class="source-code"><strong class="bold">--&gt;I'm an iterable</strong></p>
			<p>Now that we have some background on <strong class="source-inline">itertools</strong> and iterators, let's write the function for our<a id="_idIndexMarker760"/> regression and residuals permutation plots:</p>
			<p class="source-code">def reg_resid_plots(data):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Using `seaborn`, plot the regression and residuals plots </p>
			<p class="source-code">    side-by-side for every permutation of 2 columns in data.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - data: A `pandas.DataFrame` object</p>
			<p class="source-code">    Returns:</p>
			<p class="source-code">        A matplotlib `Axes` object.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    num_cols = data.shape[1]</p>
			<p class="source-code">    permutation_count = num_cols * (num_cols - 1)</p>
			<p class="source-code">    fig, ax = \</p>
			<p class="source-code">        plt.subplots(permutation_count, 2, figsize=(15, 8))</p>
			<p class="source-code">    for (x, y), axes, color in zip(</p>
			<p class="source-code">        <strong class="bold">itertools.permutations(data.columns, 2)</strong>, </p>
			<p class="source-code">        ax,</p>
			<p class="source-code">        <strong class="bold">itertools.cycle(['royalblue', 'darkorange'])</strong></p>
			<p class="source-code">    ):</p>
			<p class="source-code">        <strong class="bold">for subplot, func in zip(</strong></p>
			<p class="source-code"><strong class="bold">            axes, (sns.regplot, sns.residplot)</strong></p>
			<p class="source-code"><strong class="bold">        ):</strong></p>
			<p class="source-code">            <strong class="bold">func(x=x, y=y, data=data, ax=subplot, color=color)</strong></p>
			<p class="source-code">            <strong class="bold">if func == sns.residplot:</strong></p>
			<p class="source-code">                <strong class="bold">subplot.set_ylabel('residuals')</strong></p>
			<p class="source-code">    return fig.axes</p>
			<p>In this function, we can <a id="_idIndexMarker761"/>see that all the material covered so far in this chapter and from the previous chapter is coming together; we calculate how many subplots we need, and since we will have two plots for each permutation, we just need the number of permutations to determine the row count. We take advantage of the <strong class="source-inline">zip()</strong> function, which gives us values from multiple iterables at once in tuples, and tuple unpacking to easily iterate over the permutation tuples and the 2D NumPy array of <strong class="source-inline">Axes</strong> objects. Take some time to make sure you understand what is going on here; there are also resources on <strong class="source-inline">zip()</strong> and tuple unpacking in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If we provide different length iterables to <strong class="source-inline">zip()</strong>, we will only get a number of tuples equal to the shortest length. For this reason, we can use infinite iterators, such as those we get when using <strong class="source-inline">itertools.repeat()</strong>, which repeats the same value infinitely (when we don't specify the number of times to repeat the value), and <strong class="source-inline">itertools.cycle()</strong>, which cycles between all the values provided infinitely.</p>
			<p>Calling our function is effortless, with only a single parameter:</p>
			<p class="source-code">&gt;&gt;&gt; from viz import reg_resid_plots</p>
			<p class="source-code">&gt;&gt;&gt; reg_resid_plots(fb_reg_data)</p>
			<p>The first row of subsets is what we saw earlier with the joint plots, and the second row is the regression when flipping the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> variables:</p>
			<div>
				<div id="_idContainer279" class="IMG---Figure">
					<img src="image/fig_6.13.jpg" alt="Figure 6.13 – Seaborn linear regression and residual plots&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Seaborn linear regression and residual plots</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">regplot()</strong> function supports polynomial and logistic regression through the <strong class="source-inline">order</strong> and <strong class="source-inline">logistic</strong> parameters, respectively.</p>
			<p>Seaborn also makes it easy to<a id="_idIndexMarker762"/> plot regressions across different subsets of our data with <strong class="source-inline">lmplot()</strong>. We can split our regression plots with <strong class="source-inline">hue</strong>, <strong class="source-inline">col</strong>, and <strong class="source-inline">row</strong>, which will color by values in a given column, make a new column for each value, and make a new row for each value, respectively.</p>
			<p>We saw that Facebook's performance was different across each quarter of the year, so let's calculate a regression per quarter with the Facebook stock data, using the volume traded and the daily difference between the highest and lowest price, to see whether this relationship also changes:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">sns.lmplot</strong>(</p>
			<p class="source-code">...     x='log_volume', </p>
			<p class="source-code">...     y='max_abs_change', </p>
			<p class="source-code">...     <strong class="bold">col='quarter'</strong>,</p>
			<p class="source-code">...     data=fb.assign(</p>
			<p class="source-code">...         log_volume=np.log(fb.volume), </p>
			<p class="source-code">...         max_abs_change=fb.high - fb.low,</p>
			<p class="source-code">...         quarter=lambda x: x.index.quarter</p>
			<p class="source-code">...     )</p>
			<p class="source-code">... )</p>
			<p>Notice that the regression<a id="_idIndexMarker763"/> line in the fourth quarter has a much steeper slope than previous quarters:</p>
			<div>
				<div id="_idContainer280" class="IMG---Figure">
					<img src="image/fig_6.14.jpg" alt="Figure 6.14 – Seaborn linear regression plots with subsets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – Seaborn linear regression plots with subsets</p>
			<p>Note that the result of running <strong class="source-inline">lmplot()</strong> is a <strong class="source-inline">FacetGrid</strong> object, which is a powerful feature of <strong class="source-inline">seaborn</strong>. Let's now discuss how we can make these directly with any plot inside.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Faceting</h2>
			<p>Faceting allows us to plot subsets (facets) of our <a id="_idIndexMarker764"/>data across subplots. We already saw a few as a result of some <strong class="source-inline">seaborn</strong> functions; however, we can easily make them for ourselves for use with any plotting function. Let's create a visualization that will allow us to compare the distributions of earthquake magnitudes in Indonesia and Papua New Guinea depending on whether there was a tsunami.</p>
			<p>First, we create a <strong class="source-inline">FacetGrid</strong> object with the data we will be using and define how it will be subset with the <strong class="source-inline">row</strong> and <strong class="source-inline">col</strong> arguments:</p>
			<p class="source-code">&gt;&gt;&gt; g = sns.FacetGrid(</p>
			<p class="source-code">...     quakes.query(</p>
			<p class="source-code">...         'parsed_place.isin('</p>
			<p class="source-code">...         '["Indonesia", "Papua New Guinea"]) '</p>
			<p class="source-code">...         'and magType == "mb"'</p>
			<p class="source-code">...     ),   </p>
			<p class="source-code">...     <strong class="bold">row='tsunami'</strong>,</p>
			<p class="source-code">...     <strong class="bold">col='parsed_place'</strong>,</p>
			<p class="source-code">...     height=4</p>
			<p class="source-code">... )</p>
			<p>Then, we use the <strong class="source-inline">FacetGrid.map()</strong> method to run a plotting function on each of the subsets, passing along any necessary arguments. We will make histograms with KDEs for the location and tsunami data subsets using the <strong class="source-inline">sns.histplot()</strong> function:</p>
			<p class="source-code">&gt;&gt;&gt; g = g.map(sns.histplot, 'mag', kde=True)</p>
			<p>For both locations, we can see that tsunamis occurred when the earthquake magnitude was 5.0 or greater:</p>
			<div>
				<div id="_idContainer281" class="IMG---Figure">
					<img src="image/fig_6.15.jpg" alt="Figure 6.15 – Plotting with facet grids&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Plotting with facet grids</p>
			<p>This concludes<a id="_idIndexMarker765"/> our discussion of the plotting capabilities of <strong class="source-inline">seaborn</strong>; however, I encourage you to check out the API (<a href="https://seaborn.pydata.org/api.html">https://seaborn.pydata.org/api.html</a>) to see additional functionality. Also, be sure to consult the <em class="italic">Choosing the appropriate visualization</em> section in the <em class="italic">Appendix</em> as a reference when looking to plot some data.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Formatting plots with matplotlib</h1>
			<p>A big part of making <a id="_idIndexMarker766"/>our visualizations presentable is choosing the right plot type and having them well labeled so they are easy to interpret. By carefully<a id="_idIndexMarker767"/> tuning the final appearance of our visualizations, we make them easier to read and understand. </p>
			<p>Let's now move to the <strong class="source-inline">2-formatting_plots.ipynb</strong> notebook, run the setup code to import the <a id="_idIndexMarker768"/>packages we need, and read in the Facebook stock data and COVID-19 daily new cases data:</p>
			<p class="source-code">&gt;&gt;&gt; %matplotlib inline</p>
			<p class="source-code">&gt;&gt;&gt; import matplotlib.pyplot as plt</p>
			<p class="source-code">&gt;&gt;&gt; import numpy as np</p>
			<p class="source-code">&gt;&gt;&gt; import pandas as pd </p>
			<p class="source-code">&gt;&gt;&gt; fb = pd.read_csv(</p>
			<p class="source-code">...     'data/fb_stock_prices_2018.csv', </p>
			<p class="source-code">...     index_col='date', </p>
			<p class="source-code">...     parse_dates=True</p>
			<p class="source-code">... ) </p>
			<p class="source-code">&gt;&gt;&gt; covid = pd.read_csv('data/covid19_cases.csv').assign(</p>
			<p class="source-code">...     date=lambda x: \</p>
			<p class="source-code">...         pd.to_datetime(x.dateRep, format='%d/%m/%Y')</p>
			<p class="source-code">... ).set_index('date').replace(</p>
			<p class="source-code">...     'United_States_of_America', 'USA'</p>
			<p class="source-code">... ).sort_index()['2020-01-18':'2020-09-18']</p>
			<p>In the next few sections, we will discuss how to add titles, axis labels, and legends to our plots, as well as how to customize the axes. Note that everything in this section needs to be called before running <strong class="source-inline">plt.show()</strong> or within the same Jupyter Notebook cell if using the <strong class="source-inline">%matplotlib inline</strong> magic command.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Titles and labels</h2>
			<p>Some of the <a id="_idIndexMarker769"/>visualizations we have created thus far didn't have titles or axis labels. We know what is going on in the figure, but if we were to<a id="_idIndexMarker770"/> present them to others, there could be some confusion. It's good practice to be explicit with our labels and titles.</p>
			<p>We saw that, when plotting with <strong class="source-inline">pandas</strong>, we could add a title by passing the <strong class="source-inline">title</strong> argument to the <strong class="source-inline">plot()</strong> method, but we can also do this with <strong class="source-inline">matplotlib</strong> using <strong class="source-inline">plt.title()</strong>. Note that we can pass <strong class="source-inline">x</strong>/<strong class="source-inline">y</strong> values to <strong class="source-inline">plt.title()</strong> to control the placement of our text. We can also change the font and its size. Labeling our axes is just as easy; we can use <strong class="source-inline">plt.xlabel()</strong> and <strong class="source-inline">plt.ylabel()</strong>. Let's plot the Facebook closing price and label everything using <strong class="source-inline">matplotlib</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; fb.close.plot()</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.title('FB Closing Price')</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.xlabel('date')</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.ylabel('price ($)')</strong></p>
			<p>This results in the following plot:</p>
			<div>
				<div id="_idContainer282" class="IMG---Figure">
					<img src="image/fig_6.16.jpg" alt="Figure 6.16 – Labeling plots with matplotlib&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Labeling plots with matplotlib</p>
			<p>When working with subplots, we have to take a different approach. To see this firsthand, let's make <a id="_idIndexMarker771"/>subplots of Facebook stock's OHLC data and use <strong class="source-inline">plt.title()</strong> to give the entire <a id="_idIndexMarker772"/>plot a title, along with <strong class="source-inline">plt.ylabel()</strong> to give each subplot's <em class="italic">y</em>-axis a label:</p>
			<p class="source-code">&gt;&gt;&gt; fb.iloc[:,:4]\</p>
			<p class="source-code">...     .plot(subplots=True, layout=(2, 2), figsize=(12, 5))</p>
			<p class="source-code">&gt;&gt;&gt; plt.title('Facebook 2018 Stock Data')</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p>Using <strong class="source-inline">plt.title()</strong> puts the title on the last subplot, instead of being the title for the plots as a whole, as we intended. The same thing happens to the <em class="italic">y</em>-axis label:</p>
			<div>
				<div id="_idContainer283" class="IMG---Figure">
					<img src="image/fig_6.17.jpg" alt="Figure 6.17 – Labeling subplots can be confusing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – Labeling subplots can be confusing</p>
			<p>In the case of subplots, we want to give the entire figure a title; therefore, we use <strong class="source-inline">plt.suptitle()</strong> instead. Conversely, we want to give each subplot a <em class="italic">y</em>-axis label, so we use the <strong class="source-inline">set_ylabel()</strong> method on each of the <strong class="source-inline">Axes</strong> objects returned by the call to <strong class="source-inline">plot()</strong>. Note that the <strong class="source-inline">Axes</strong> objects are returned in a NumPy array of the same dimensions as the subplot layout, so for easier iteration, we call <strong class="source-inline">flatten()</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; axes = fb.iloc[:,:4]\</p>
			<p class="source-code">...     .plot(subplots=True, layout=(2, 2), figsize=(12, 5))</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.suptitle('Facebook 2018 Stock Data')</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">for ax in axes.flatten():</strong></p>
			<p class="source-code">...     <strong class="bold">ax.set_ylabel('price ($)')</strong></p>
			<p>This<a id="_idIndexMarker773"/> results in a title for the plot as a whole and <em class="italic">y</em>-axis labels<a id="_idIndexMarker774"/> for each of the subplots:</p>
			<div>
				<div id="_idContainer284" class="IMG---Figure">
					<img src="image/fig_6.18.jpg" alt="Figure 6.18 – Labeling subplots&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – Labeling subplots</p>
			<p>Note that the <strong class="source-inline">Figure</strong> class also has a <strong class="source-inline">suptitle()</strong> method and that the <strong class="source-inline">Axes</strong> class's <strong class="source-inline">set()</strong> method lets us label the axes, title the plot, and much more in a single call, for example, <strong class="source-inline">set(xlabel='…', ylabel='…', title='…', …)</strong>. Depending on what we are trying to do, we may need to call methods on <strong class="source-inline">Figure</strong> or <strong class="source-inline">Axes</strong> objects directly, so it's important to be aware of them.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Legends</h2>
			<p>Matplotlib makes it <a id="_idIndexMarker775"/>possible to control many aspects of the legend through the <strong class="source-inline">plt.legend()</strong> function and the <strong class="source-inline">Axes.legend()</strong> method. For example, we can specify the legend's location and format how the legend looks, including customizing the fonts, colors, and much more. Both the <strong class="source-inline">plt.legend()</strong> function and the  <strong class="source-inline">Axes.legend()</strong> method can also be used to show a legend when the plot doesn't have one initially. Here is a sampling of some commonly used<a id="_idIndexMarker776"/> parameters:</p>
			<div>
				<div id="_idContainer285" class="IMG---Figure">
					<img src="image/fig_6.19.jpg" alt="Figure 6.19 – Helpful parameters for legend formatting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – Helpful parameters for legend formatting</p>
			<p>The legend will use the label of each object that was plotted. If we don't want something to show up, we can make its label an empty string. However, if we simply want to alter how something shows up, we can pass its display name through the <strong class="source-inline">label</strong> argument. Let's plot Facebook stock's closing price and the 20-day moving average, using the <strong class="source-inline">label</strong> argument to provide a descriptive name for the legend:</p>
			<p class="source-code">&gt;&gt;&gt; fb.assign(</p>
			<p class="source-code">...     ma=lambda x: x.close.rolling(20).mean()</p>
			<p class="source-code">... ).plot(</p>
			<p class="source-code">...     y=['close', 'ma'], </p>
			<p class="source-code">...     title='FB closing price in 2018',</p>
			<p class="source-code">...     <strong class="bold">label=['closing price', '20D moving average']</strong>,</p>
			<p class="source-code">...     style=['-', '--']</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.legend(loc='lower left')</strong></p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p>By default, <strong class="source-inline">matplotlib</strong> tries to find the best location for the plot, but sometimes it covers up parts of the plot as in this case. Therefore, we chose to place the legend in the lower-left corner of the<a id="_idIndexMarker777"/> plot. Note that the text in the legend is what we provided in the <strong class="source-inline">label</strong> argument to <strong class="source-inline">plot()</strong>:</p>
			<div>
				<div id="_idContainer286" class="IMG---Figure">
					<img src="image/fig_6.20.jpg" alt="Figure 6.20 – Moving the legend&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – Moving the legend</p>
			<p>Notice that we passed a string to the <strong class="source-inline">loc</strong> argument to specify the legend location; we also have the option of passing the code as an integer or a tuple for the <strong class="source-inline">(x, y)</strong> coordinates to draw the lower-left corner of the legend box. The following table contains the possible location strings:</p>
			<div>
				<div id="_idContainer287" class="IMG---Figure">
					<img src="image/fig_6.21.jpg" alt="Figure 6.21 – Common legend locations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – Common legend locations</p>
			<p>Let's now take a look at <a id="_idIndexMarker778"/>styling the legend with the <strong class="source-inline">framealpha</strong>, <strong class="source-inline">ncol</strong>, and <strong class="source-inline">title</strong> arguments. We will plot the percentage of the world's daily new COVID-19 cases that occurred in Brazil, China, Italy, Spain, and the USA over the 8-month period from January 18, 2020 through September 18, 2020. In addition, we will remove the top and right spines of the plot to make it look cleaner:</p>
			<p class="source-code">&gt;&gt;&gt; new_cases = covid.reset_index().pivot(</p>
			<p class="source-code">...     index='date',</p>
			<p class="source-code">...     columns='countriesAndTerritories',</p>
			<p class="source-code">...     values='cases'</p>
			<p class="source-code">... ).fillna(0)</p>
			<p class="source-code">&gt;&gt;&gt; pct_new_cases = new_cases.apply(</p>
			<p class="source-code">...     lambda x: x / new_cases.apply('sum', axis=1), axis=0</p>
			<p class="source-code">... )[</p>
			<p class="source-code">...     ['Italy', 'China', 'Spain', 'USA', 'India', 'Brazil']</p>
			<p class="source-code">... ].sort_index(axis=1).fillna(0)</p>
			<p class="source-code">&gt;&gt;&gt; ax = pct_new_cases.plot(</p>
			<p class="source-code">...     figsize=(12, 7),</p>
			<p class="source-code">...     style=['-'] * 3 + ['--', ':', '-.'],</p>
			<p class="source-code">...     title='Percentage of the World\'s New COVID-19 Cases'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">ax.legend(title='Country', framealpha=0.5, ncol=2)</strong></p>
			<p class="source-code">&gt;&gt;&gt; ax.set_xlabel('')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylabel('percentage of the world\'s COVID-19 cases')</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">for spine in ['top', 'right']:</strong></p>
			<p class="source-code">...     <strong class="bold">ax.spines[spine].set_visible(False)</strong></p>
			<p>Our legend is neatly<a id="_idIndexMarker779"/> arranged in two columns and contains a title. We also increased the transparency of the legend's border:</p>
			<div>
				<div id="_idContainer288" class="IMG---Figure">
					<img src="image/fig_6.22.jpg" alt="Figure 6.22 – Formatting the legend&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22 – Formatting the legend</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Don't get overwhelmed<a id="_idIndexMarker780"/> trying to memorize all of the available options. It is easier if we don't try to learn every possible customization, but rather look up the functionality that matches what we have in mind for our visualization when needed.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Formatting axes</h2>
			<p>Back in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>, we discussed how our axis limits can make for misleading plots if we <a id="_idIndexMarker781"/>aren't careful. We have the option of passing this as a tuple to the <strong class="source-inline">xlim</strong>/<strong class="source-inline">ylim</strong> arguments when using the <strong class="source-inline">plot()</strong> method from <strong class="source-inline">pandas</strong>. Alternatively, with <strong class="source-inline">matplotlib</strong>, we can adjust the limits of each axis with the <strong class="source-inline">plt.xlim()</strong>/<strong class="source-inline">plt.ylim()</strong> function or the <strong class="source-inline">set_xlim()</strong>/<strong class="source-inline">set_ylim()</strong> method on an <strong class="source-inline">Axes</strong> object. We pass values for the minimum and maximum, separately; if we want to keep what was automatically generated, we can pass in <strong class="source-inline">None</strong>. Let's modify the previous plot of the percentage of the world's daily new COVID-19 cases per country to start the <em class="italic">y</em>-axis at zero:</p>
			<p class="source-code">&gt;&gt;&gt; ax = pct_new_cases.plot(</p>
			<p class="source-code">...     figsize=(12, 7),</p>
			<p class="source-code">...     style=['-'] * 3 + ['--', ':', '-.'],</p>
			<p class="source-code">...     title='Percentage of the World\'s New COVID-19 Cases'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.legend(framealpha=0.5, ncol=2)</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_xlabel('')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylabel('percentage of the world\'s COVID-19 cases')</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">ax.set_ylim(0, None)</strong></p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>Notice<a id="_idIndexMarker782"/> that the <em class="italic">y</em>-axis now begins at zero:</p>
			<div>
				<div id="_idContainer289" class="IMG---Figure">
					<img src="image/fig_6.23.jpg" alt="Figure 6.23 – Updating axis limits with matplotlib&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23 – Updating axis limits with matplotlib</p>
			<p>If we instead want to change the scale of the axis, we can use <strong class="source-inline">plt.xscale()</strong>/<strong class="source-inline">plt.yscale()</strong> and pass the type of scale we want. So, <strong class="source-inline">plt.yscale('log')</strong>, for example, will use the log scale for the <em class="italic">y</em>-axis; we saw how to do this with <strong class="source-inline">pandas</strong> in the previous chapter.</p>
			<p>We can also control which tick marks show up and what they are labeled as by passing in the tick locations <a id="_idIndexMarker783"/>and labels to <strong class="source-inline">plt.xticks()</strong> or <strong class="source-inline">plt.yticks()</strong>. Note that we can also call these functions to obtain the tick locations and labels. For example, since our data starts and ends on the 18<span class="superscript">th</span> of the month, let's move the tick marks in the previous plot to the 18<span class="superscript">th</span> of each month and then label the ticks accordingly:</p>
			<p class="source-code">&gt;&gt;&gt; ax = pct_new_cases.plot(</p>
			<p class="source-code">...     figsize=(12, 7),</p>
			<p class="source-code">...     style=['-'] * 3 + ['--', ':', '-.'],</p>
			<p class="source-code">...     title='Percentage of the World\'s New COVID-19 Cases'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">tick_locs = covid.index[covid.index.day == 18].unique()</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">tick_labels = \</strong></p>
			<p class="source-code">...     <strong class="bold">[loc.strftime('%b %d\n%Y') for loc in tick_locs]</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.xticks(tick_locs, tick_labels)</strong></p>
			<p class="source-code">&gt;&gt;&gt; ax.legend(framealpha=0.5, ncol=2)</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_xlabel('')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylabel('percentage of the world\'s COVID-19 cases')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylim(0, None)</p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>After moving<a id="_idIndexMarker784"/> the tick marks, we have a tick label on the first data point in the plot (January 18, 2020) and on the last (September 18, 2020):</p>
			<div>
				<div id="_idContainer290" class="IMG---Figure">
					<img src="image/fig_6.24.jpg" alt="Figure 6.24 – Editing tick labels&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24 – Editing tick labels</p>
			<p>We are currently<a id="_idIndexMarker785"/> representing the percentages as decimals, but we may wish to format the labels to be written using the percent sign. Note that there is no need to use the <strong class="source-inline">plt.yticks()</strong> function to do so; instead, we can use the <strong class="source-inline">PercentFormatter</strong> class from the <strong class="source-inline">matplotlib.ticker</strong> module:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">from matplotlib.ticker import PercentFormatter</strong></p>
			<p class="source-code">&gt;&gt;&gt; ax = pct_new_cases.plot(</p>
			<p class="source-code">...     figsize=(12, 7),</p>
			<p class="source-code">...     style=['-'] * 3 + ['--', ':', '-.'],</p>
			<p class="source-code">...     title='Percentage of the World\'s New COVID-19 Cases'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; tick_locs = covid.index[covid.index.day == 18].unique()</p>
			<p class="source-code">&gt;&gt;&gt; tick_labels = \</p>
			<p class="source-code">...     [loc.strftime('%b %d\n%Y') for loc in tick_locs]</p>
			<p class="source-code">&gt;&gt;&gt; plt.xticks(tick_locs, tick_labels)</p>
			<p class="source-code">&gt;&gt;&gt; ax.legend(framealpha=0.5, ncol=2)</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_xlabel('')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylabel('percentage of the world\'s COVID-19 cases')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylim(0, None)</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))</strong></p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>By specifying <strong class="source-inline">xmax=1</strong>, we are<a id="_idIndexMarker786"/> indicating that our values should be divided by 1 (since they are already percentages), before multiplying by 100 and appending the percent sign. This results in percentages along the <em class="italic">y</em>-axis:</p>
			<div>
				<div id="_idContainer291" class="IMG---Figure">
					<img src="image/fig_6.25.jpg" alt="Figure 6.25 – Formatting tick labels as percentages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25 – Formatting tick labels as percentages</p>
			<p>Another useful <a id="_idIndexMarker787"/>formatter is the <strong class="source-inline">EngFormatter</strong> class, which will automatically handle formatting numbers as thousands, millions, and so on using <strong class="bold">engineering notation</strong>. Let's use this to plot the cumulative COVID-19 cases <a id="_idIndexMarker788"/>per continent in millions:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">from matplotlib.ticker import EngFormatter</strong></p>
			<p class="source-code">&gt;&gt;&gt; ax = covid.query('continentExp != "Other"').groupby([</p>
			<p class="source-code">...     'continentExp', pd.Grouper(freq='1D')</p>
			<p class="source-code">... ]).cases.sum().unstack(0).apply('cumsum').plot(</p>
			<p class="source-code">...     style=['-', '-', '--', ':', '-.'],</p>
			<p class="source-code">...     title='Cumulative COVID-19 Cases per Continent'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.legend(title='', loc='center left')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set(xlabel='', ylabel='total COVID-19 cases')</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">ax.yaxis.set_major_formatter(EngFormatter())</strong></p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>Notice that we didn't need to divide the<a id="_idIndexMarker789"/> cumulative case counts by 1 million to get these numbers—the <strong class="source-inline">EngFormatter</strong> object that we passed to <strong class="source-inline">set_major_formatter()</strong> automatically figured out that it should use millions (M) based on the data:</p>
			<div>
				<div id="_idContainer292" class="IMG---Figure">
					<img src="image/fig_6.26.jpg" alt="Figure 6.26 – Formatting tick labels with engineering notation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26 – Formatting tick labels with engineering notation</p>
			<p>Both the <strong class="source-inline">PercentFormatter</strong> and <strong class="source-inline">EngFormatter</strong> classes format the tick labels, but sometimes we want to change the location of the ticks rather than format them. One way of doing so is with the <strong class="source-inline">MultipleLocator</strong> class, which makes it easy for us to place the ticks at multiples of a number of our choosing. To illustrate how we could use this, let's take a look at the daily new COVID-19 cases in New Zealand from April 18, 2020 through September 18, 2020:</p>
			<p class="source-code">&gt;&gt;&gt; ax = new_cases.New_Zealand['2020-04-18':'2020-09-18'].plot(</p>
			<p class="source-code">...     title='Daily new COVID-19 cases in New Zealand'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set(xlabel='', ylabel='new COVID-19 cases')</p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>Without us intervening with the tick locations, <strong class="source-inline">matplotlib</strong> is showing the ticks in increments of 2.5. We<a id="_idIndexMarker790"/> know that there is no such thing as half of a case, so it makes more sense to show this data with only integer ticks:</p>
			<div>
				<div id="_idContainer293" class="IMG---Figure">
					<img src="image/fig_6.27.jpg" alt="Figure 6.27 – Default tick locations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27 – Default tick locations</p>
			<p>Let's fix this by using the <strong class="source-inline">MultipleLocator</strong> class. Here, we aren't formatting the axis labels, but rather controlling which ones are shown; for this reason, we have to call the <strong class="source-inline">set_major_locator()</strong> method instead of <strong class="source-inline">set_major_formatter()</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">from matplotlib.ticker import MultipleLocator</strong></p>
			<p class="source-code">&gt;&gt;&gt; ax = new_cases.New_Zealand['2020-04-18':'2020-09-18'].plot(</p>
			<p class="source-code">...     title='Daily new COVID-19 cases in New Zealand'</p>
			<p class="source-code">...           '\n(source: ECDC)'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set(xlabel='', ylabel='new COVID-19 cases') </p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">ax.yaxis.set_major_locator(MultipleLocator(base=3))</strong></p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>Since we passed in <strong class="source-inline">base=3</strong>, our <em class="italic">y</em>-axis now<a id="_idIndexMarker791"/> contains integers in increments of three:</p>
			<div>
				<div id="_idContainer294" class="IMG---Figure">
					<img src="image/fig_6.28.jpg" alt="Figure 6.28 – Using integer tick locations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28 – Using integer tick locations</p>
			<p>These were only three of the features provided with the <strong class="source-inline">matplotlib.ticker</strong> module, so I highly recommend you check out the documentation for more information. There is also a link in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Customizing visualizations</h1>
			<p>So far, all of the code we've learned for creating data<a id="_idIndexMarker792"/> visualizations has been for making the visualization itself. Now that we have a strong foundation, we are<a id="_idIndexMarker793"/> ready to learn how to add reference lines, control colors and textures, and include annotations.</p>
			<p>In the <strong class="source-inline">3-customizing_visualizations.ipynb</strong> notebook, let's handle our imports and read in the Facebook stock prices and earthquake datasets:</p>
			<p class="source-code">&gt;&gt;&gt; %matplotlib inline</p>
			<p class="source-code">&gt;&gt;&gt; import matplotlib.pyplot as plt</p>
			<p class="source-code">&gt;&gt;&gt; import pandas as pd</p>
			<p class="source-code">&gt;&gt;&gt; fb = pd.read_csv(</p>
			<p class="source-code">...     'data/fb_stock_prices_2018.csv', </p>
			<p class="source-code">...     index_col='date', </p>
			<p class="source-code">...     parse_dates=True</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; quakes = pd.read_csv('data/earthquakes.csv')</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Changing the style in which the <a id="_idIndexMarker794"/>plots are created is an easy way to change their look and feel without setting each aspect separately. To set the style for <strong class="source-inline">seaborn</strong>, use <strong class="source-inline">sns.set_style()</strong>. With <strong class="source-inline">matplotlib</strong>, we can use <strong class="source-inline">plt.style.use()</strong> to specify the stylesheet(s) we want to use. These will be used for all visualizations created in that session. If, instead, we only want it for a single plot, we can use <strong class="source-inline">sns.set_context()</strong> or <strong class="source-inline">plt.style.context()</strong>. Available styles for <strong class="source-inline">seaborn</strong> can be found in the documentation of the aforementioned functions and in <strong class="source-inline">matplotlib</strong> by taking a look at the values in <strong class="source-inline">plt.style.available</strong>.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Adding reference lines</h2>
			<p>Quite often, we<a id="_idIndexMarker795"/> want to draw attention to a specific value on our plot, perhaps as a boundary or turning point. We may be interested in whether the line gets crossed or serves as a partition. In finance, horizontal reference lines may be drawn on top of the line plot of a stock's price, marking the support and resistance.</p>
			<p>The <strong class="bold">support</strong> is a price level at which a downward trend is expected to reverse because the stock is now at a price level at which buyers are more enticed to purchase, driving the price up and away from this point. On the flip side, the <strong class="bold">resistance</strong> is the price level at which an upward trend is expected to<a id="_idIndexMarker796"/> reverse since the price is an attractive selling point; thus, the price falls down and away from this point. Of course, this is not to say these levels don't get surpassed. Since we have Facebook stock data, let's add the support and resistance reference lines to our line plot of the closing price.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Going over how support and resistance are calculated is beyond the scope of this chapter, but <a href="B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">Financial Analysis – Bitcoin and the Stock Market</em>, will include some code for calculating these using pivot points. Also, be sure to check out the <em class="italic">Further reading</em> section for a more in-depth introduction to support and resistance.</p>
			<p>Our two horizontal reference lines will be at the support of $124.46 and the resistance of $138.53. Both these numbers were derived using the <strong class="source-inline">stock_analysis</strong> package, which we will build in <a href="B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">Financial Analysis – Bitcoin and the Stock Market</em>. We simply need to create an instance of the <strong class="source-inline">StockAnalyzer</strong> class to calculate these metrics:</p>
			<p class="source-code">&gt;&gt;&gt; from stock_analysis import StockAnalyzer</p>
			<p class="source-code">&gt;&gt;&gt; fb_analyzer = StockAnalyzer(fb)</p>
			<p class="source-code">&gt;&gt;&gt; support, resistance = (</p>
			<p class="source-code">...     getattr(fb_analyzer, stat)(level=3)</p>
			<p class="source-code">...     for stat in ['support', 'resistance']</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; support, resistance</p>
			<p class="source-code">(124.4566666666667, 138.5266666666667)</p>
			<p>We will use the <strong class="source-inline">plt.axhline()</strong> function for this task, but note that this will also work on the <strong class="source-inline">Axes</strong> object. Remember that the text we provide to the <strong class="source-inline">label</strong> arguments will be populated in the legend:</p>
			<p class="source-code">&gt;&gt;&gt; fb.close['2018-12']\</p>
			<p class="source-code">...     .plot(title='FB Closing Price December 2018')</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.axhline(</strong></p>
			<p class="source-code">...     <strong class="bold">y=resistance, color='r', linestyle='--',</strong></p>
			<p class="source-code">...     <strong class="bold">label=f'resistance (${resistance:,.2f})'</strong></p>
			<p class="source-code">... <strong class="bold">)</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.axhline(</strong></p>
			<p class="source-code">...     <strong class="bold">y=support, color='g', linestyle='--',</strong></p>
			<p class="source-code">...     <strong class="bold">label=f'support (${support:,.2f})'</strong></p>
			<p class="source-code">... <strong class="bold">)</strong></p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p class="source-code">&gt;&gt;&gt; plt.legend()</p>
			<p>We should already be familiar with<a id="_idIndexMarker797"/> the f-string format from earlier chapters, but notice the additional text after the variable name here (<strong class="source-inline">:,.2f</strong>). The support and resistance are stored as floats in the <strong class="source-inline">support</strong> and <strong class="source-inline">resistance</strong> variables, respectively. The colon (<strong class="source-inline">:</strong>) precedes the <strong class="bold">format specifier</strong> (commonly written as <strong class="source-inline">format_spec</strong>), which tells Python how to format that variable; in this case, we are formatting it as a decimal (<strong class="source-inline">f</strong>) with a comma as the thousands separator (<strong class="source-inline">,</strong>) and two digits of precision after the decimal (<strong class="source-inline">.2</strong>). This will also work with the <strong class="source-inline">format()</strong> method, in which case it would look like <strong class="source-inline">'{:,.2f}'.format(resistance)</strong>. This formatting makes for an informative legend in our plot:</p>
			<div>
				<div id="_idContainer295" class="IMG---Figure">
					<img src="image/fig_6.29.jpg" alt="Figure 6.29 – Creating horizontal reference lines with matplotlib&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.29 – Creating horizontal reference lines with matplotlib</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Those with personal investment accounts will likely find some literature there on support and resistance when looking to place limit orders or stop losses based on the stock hitting a certain price point since these can help inform the feasibility of the target price. In addition, these reference lines may be used by traders to analyze the stock's momentum and decide whether it is time to buy/sell the stock.</p>
			<p>Turning back to the earthquake data, let's use <strong class="source-inline">plt.axvline()</strong> to draw <a id="_idIndexMarker798"/>vertical reference lines for the number of standard deviations from the mean on the distribution of earthquake magnitudes in Indonesia. The <strong class="source-inline">std_from_mean_kde()</strong> function located in the <strong class="source-inline">viz.py</strong> module in the GitHub repository uses <strong class="source-inline">itertools</strong> to easily make the combinations of the colors and values we need to plot:</p>
			<p class="source-code">import itertools</p>
			<p class="source-code">def std_from_mean_kde(data):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Plot the KDE along with vertical reference lines</p>
			<p class="source-code">    for each standard deviation from the mean.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - data: `pandas.Series` with numeric data</p>
			<p class="source-code">    Returns:</p>
			<p class="source-code">        Matplotlib `Axes` object.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    mean_mag, std_mean = data.mean(), data.std()</p>
			<p class="source-code">    ax = data.plot(kind='kde')</p>
			<p class="source-code">    <strong class="bold">ax.axvline(mean_mag, color='b', alpha=0.2, label='mean')</strong></p>
			<p class="source-code">    colors = ['green', 'orange', 'red']</p>
			<p class="source-code">    multipliers = [1, 2, 3]</p>
			<p class="source-code">    signs = ['-', '+']</p>
			<p class="source-code">    linestyles = [':', '-.', '--']</p>
			<p class="source-code">    for sign, (color, multiplier, style) in <strong class="bold">itertools.product(</strong></p>
			<p class="source-code">        <strong class="bold">signs, zip(colors, multipliers, linestyles)</strong></p>
			<p class="source-code">    <strong class="bold">)</strong>:</p>
			<p class="source-code">        adjustment = multiplier * std_mean</p>
			<p class="source-code">        if sign == '-':</p>
			<p class="source-code">            value = mean_mag – adjustment</p>
			<p class="source-code">            label = '{} {}{}{}'.format(</p>
			<p class="source-code">                r'$\mu$', r'$\pm$', multiplier, r'$\sigma$'</p>
			<p class="source-code">            )</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            value = mean_mag + adjustment</p>
			<p class="source-code">            label = None # label each color only once</p>
			<p class="source-code">        <strong class="bold">ax.axvline(</strong></p>
			<p class="source-code">            <strong class="bold">value, color=color, linestyle=style, </strong></p>
			<p class="source-code">            <strong class="bold">label=label, alpha=0.5</strong></p>
			<p class="source-code">        <strong class="bold">)</strong></p>
			<p class="source-code">    ax.legend()</p>
			<p class="source-code">    return ax</p>
			<p>The <strong class="source-inline">product()</strong> function from <strong class="source-inline">itertools</strong> will give us all combinations of items from any number of iterables. Here, we have zipped the colors, multipliers, and line styles since we always want a green dotted line for a multiplier of 1; an orange dot-dashed line for a multiplier of 2; and a red <a id="_idIndexMarker799"/>dashed line for a multiplier of 3. When <strong class="source-inline">product()</strong> uses these tuples, we get positive- and negative-signed combinations for everything. To keep our legend from getting too crowded, we only label each color once using the ± sign. Since we have combinations between a string and a tuple at each iteration, we unpack the tuple in our <strong class="source-inline">for</strong> statement for easier use.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We can use LaTeX math symbols (<a href="https://www.latex-project.org/">https://www.latex-project.org/</a>) to label our plots if we follow a certain pattern. First, we must mark the string as <strong class="source-inline">raw</strong> by preceding it with the <strong class="source-inline">r</strong> character. Then, we must surround the LaTeX with <strong class="source-inline">$</strong> symbols. For example, we used <strong class="source-inline">r'$\mu$'</strong> for the Greek letter μ in the preceding code.</p>
			<p>Let's use the <strong class="source-inline">std_from_mean_kde()</strong> function to see which parts of the estimated distribution of earthquake magnitudes in Indonesia are within one, two, or three standard deviations<a id="_idIndexMarker800"/> from the mean:</p>
			<p class="source-code">&gt;&gt;&gt; from viz import std_from_mean_kde</p>
			<p class="source-code">&gt;&gt;&gt; ax = std_from_mean_kde(</p>
			<p class="source-code">...     quakes.query(</p>
			<p class="source-code">...         'magType == "mb" and parsed_place == "Indonesia"'</p>
			<p class="source-code">...     ).mag</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_title('mb magnitude distribution in Indonesia')</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_xlabel('mb earthquake magnitude')</p>
			<p>Notice the KDE is right-skewed—it has a longer tail on the right side, and the mean is to the right of the mode:</p>
			<div>
				<div id="_idContainer296" class="IMG---Figure">
					<img src="image/fig_6.30.jpg" alt="Figure 6.30 – Including vertical reference lines&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.30 – Including vertical reference lines</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To make a straight line of arbitrary slope, simply pass the endpoints of the line as two <strong class="source-inline">x</strong> values and two <strong class="source-inline">y</strong> values (for example, <strong class="source-inline">[0, 2]</strong> and <strong class="source-inline">[2, 0]</strong>) to <strong class="source-inline">plt.plot()</strong> using the same <strong class="source-inline">Axes</strong> object. For lines that aren't straight, <strong class="source-inline">np.linspace()</strong> can be used to create a range of evenly-spaced points on <strong class="source-inline">[start, stop)</strong>, which can be used for the <strong class="source-inline">x</strong> values and to calculate the <strong class="source-inline">y</strong> values. As a reminder, when specifying a range, square brackets mean inclusive of both endpoints and round brackets are exclusive, so [0, 1) goes from 0 to as close to 1 as <a id="_idIndexMarker801"/>possible without being 1. We see these when using <strong class="source-inline">pd.cut()</strong> and <strong class="source-inline">pd.qcut()</strong> if we don't name the buckets.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>Shading regions</h2>
			<p>In some cases, the reference line itself<a id="_idIndexMarker802"/> isn't so interesting, but the area between two of them is; for this purpose, we have <strong class="source-inline">axvspan()</strong> and <strong class="source-inline">axhspan()</strong>. Let's revisit the support and resistance of Facebook stock's closing price. We can use <strong class="source-inline">axhspan()</strong> to shade the area that falls between the two:</p>
			<p class="source-code">&gt;&gt;&gt; ax = fb.close.plot(title='FB Closing Price')</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">ax.axhspan(support, resistance, alpha=0.2)</strong></p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('Price ($)')</p>
			<p>Note that the color of the shaded region is determined by the <strong class="source-inline">facecolor</strong> argument. For this example, we accepted the default:</p>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="image/fig_6.31.jpg" alt="Figure 6.31 – Adding a horizontal shaded region&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.31 – Adding a horizontal shaded region</p>
			<p>When we are interested in shading the area between two curves, we can use the <strong class="source-inline">plt.fill_between()</strong> and <strong class="source-inline">plt.fill_betweenx()</strong> functions. The <strong class="source-inline">plt.fill_between()</strong> function accepts<a id="_idIndexMarker803"/> one set of <strong class="source-inline">x</strong> values and two sets of <strong class="source-inline">y</strong> values; we can use <strong class="source-inline">plt.fill_betweenx()</strong> if we require the opposite. Let's shade the area between Facebook's high price and low price each day of the fourth quarter using <strong class="source-inline">plt.fill_between()</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; fb_q4 = fb.loc['2018-Q4']</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.fill_between(fb_q4.index, fb_q4.high, fb_q4.low)</strong></p>
			<p class="source-code">&gt;&gt;&gt; plt.xticks([</p>
			<p class="source-code">...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'</p>
			<p class="source-code">... ])</p>
			<p class="source-code">&gt;&gt;&gt; plt.xlabel('date')</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p class="source-code">&gt;&gt;&gt; plt.title(</p>
			<p class="source-code">...     'FB differential between high and low price Q4 2018'</p>
			<p class="source-code">... )</p>
			<p>This gives us a better idea of the variation in price on a given day; the taller the vertical distance, the higher the fluctuation:</p>
			<div>
				<div id="_idContainer298" class="IMG---Figure">
					<img src="image/fig_6.32.jpg" alt="Figure 6.32 – Shading between two curves&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.32 – Shading between two curves</p>
			<p>By providing a Boolean <a id="_idIndexMarker804"/>mask to the <strong class="source-inline">where</strong> argument, we can specify when to fill the area between the curves. Let's fill in only December from the previous example. We will add dashed lines for the high price curve and the low price curve throughout the time period to see what is happening:</p>
			<p class="source-code">&gt;&gt;&gt; fb_q4 = fb.loc['2018-Q4']</p>
			<p class="source-code">&gt;&gt;&gt; plt.fill_between(</p>
			<p class="source-code">...     fb_q4.index, fb_q4.high, fb_q4.low, </p>
			<p class="source-code">...     <strong class="bold">where=fb_q4.index.month == 12</strong>, </p>
			<p class="source-code">...     color='khaki', label='December differential'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; plt.plot(fb_q4.index, fb_q4.high, '--', label='daily high')</p>
			<p class="source-code">&gt;&gt;&gt; plt.plot(fb_q4.index, fb_q4.low, '--', label='daily low') </p>
			<p class="source-code">&gt;&gt;&gt; plt.xticks([</p>
			<p class="source-code">...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'</p>
			<p class="source-code">... ])</p>
			<p class="source-code">&gt;&gt;&gt; plt.xlabel('date')</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p class="source-code">&gt;&gt;&gt; plt.legend()</p>
			<p class="source-code">&gt;&gt;&gt; plt.title(</p>
			<p class="source-code">...     'FB differential between high and low price Q4 2018'</p>
			<p class="source-code">... )</p>
			<p>This results in the following plot:</p>
			<div>
				<div id="_idContainer299" class="IMG---Figure">
					<img src="image/fig_6.33.jpg" alt="Figure 6.33 – Selectively shading between two curves&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.33 – Selectively shading between two curves</p>
			<p>With reference<a id="_idIndexMarker805"/> lines and shaded regions, we are able to draw attention to certain areas, and can even label them in the legend, but we are limited in the text we can use to explain them. Let's now discuss how to annotate our plot for additional context.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Annotations</h2>
			<p>We will often find the<a id="_idIndexMarker806"/> need to annotate specific points in our visualizations either to point out events, such as the days on which Facebook's stock price dropped due to certain news stories breaking, or to label values that are important for comparisons. For example, let's use the <strong class="source-inline">plt.annotate()</strong> function to label the <a id="_idIndexMarker807"/>support and resistance:</p>
			<p class="source-code">&gt;&gt;&gt; ax = fb.close.plot(</p>
			<p class="source-code">...     title='FB Closing Price 2018',</p>
			<p class="source-code">...     figsize=(15, 3)</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set_ylabel('price ($)')</p>
			<p class="source-code">&gt;&gt;&gt; ax.axhspan(support, resistance, alpha=0.2)</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.annotate(</strong></p>
			<p class="source-code">...     <strong class="bold">f'support\n(${support:,.2f})',</strong></p>
			<p class="source-code">...     <strong class="bold">xy=('2018-12-31', support),</strong></p>
			<p class="source-code">...     <strong class="bold">xytext=('2019-01-21', support),</strong></p>
			<p class="source-code">...     <strong class="bold">arrowprops={'arrowstyle': '-&gt;'}</strong></p>
			<p class="source-code">... <strong class="bold">)</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">plt.annotate(</strong></p>
			<p class="source-code">...     <strong class="bold">f'resistance\n(${resistance:,.2f})',</strong></p>
			<p class="source-code">...     <strong class="bold">xy=('2018-12-23', resistance)</strong></p>
			<p class="source-code">... <strong class="bold">)</strong> </p>
			<p class="source-code">&gt;&gt;&gt; for spine in ['top', 'right']:</p>
			<p class="source-code">...     ax.spines[spine].set_visible(False)</p>
			<p>Notice the annotations are different; when we annotated the resistance, we only provided the text for the annotation and the coordinates of the point being annotated with the <strong class="source-inline">xy</strong> argument. However, when we annotated the support, we also provided values for the <strong class="source-inline">xytext</strong> and <strong class="source-inline">arrowprops</strong> arguments; this allowed us to put the text somewhere other than where the value occurred and add an arrow indicating where it occurred. By doing so, we avoid obscuring the last few days of data with our label:</p>
			<div>
				<div id="_idContainer300" class="IMG---Figure">
					<img src="image/fig_6.34.jpg" alt="Figure 6.34 – Including annotations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.34 – Including annotations</p>
			<p>The <strong class="source-inline">arrowprops</strong> argument gives us <a id="_idIndexMarker808"/>quite a bit of customization over the type of arrow we want, although it might be difficult to get it perfect. As an example, let's annotate the big decline in the price of Facebook in July with the percentage drop:</p>
			<p class="source-code">&gt;&gt;&gt; close_price = fb.loc['2018-07-25', 'close']</p>
			<p class="source-code">&gt;&gt;&gt; open_price = fb.loc['2018-07-26', 'open']</p>
			<p class="source-code">&gt;&gt;&gt; pct_drop = (open_price - close_price) / close_price</p>
			<p class="source-code">&gt;&gt;&gt; fb.close.plot(title='FB Closing Price 2018', alpha=0.5)</p>
			<p class="source-code">&gt;&gt;&gt; plt.annotate(</p>
			<p class="source-code">...     <strong class="bold">f'{pct_drop:.2%}', va='center',</strong></p>
			<p class="source-code">...     xy=('2018-07-27', (open_price + close_price) / 2),</p>
			<p class="source-code">...     xytext=('2018-08-20', (open_price + close_price) / 2),</p>
			<p class="source-code">...     <strong class="bold">arrowprops=dict(arrowstyle='-[,widthB=4.0,lengthB=0.2')</strong></p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p>Notice that we were able to format the <strong class="source-inline">pct_drop</strong> variable as a percentage with two digits of precision by using <strong class="source-inline">.2%</strong> in the format specifier of the f-string. In addition, by specifying <strong class="source-inline">va='center'</strong>, we tell <strong class="source-inline">matplotlib</strong> to vertically center our annotation in the middle of the arrow:</p>
			<div>
				<div id="_idContainer301" class="IMG---Figure">
					<img src="image/fig_6.35.jpg" alt="Figure 6.35 – Customizing the annotation's arrow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.35 – Customizing the annotation's arrow</p>
			<p>Matplotlib <a id="_idIndexMarker809"/>provides a lot of flexibility to customize these annotations—we can pass any option that the <strong class="source-inline">Text</strong> class in <strong class="source-inline">matplotlib</strong> supports (<a href="https://matplotlib.org/api/text_api.html#matplotlib.text.Text">https://matplotlib.org/api/text_api.html#matplotlib.text.Text</a>). To change colors, simply pass the desired color in the <strong class="source-inline">color</strong> argument. We can also control font size, weight, family, and style through the <strong class="source-inline">fontsize</strong>, <strong class="source-inline">fontweight</strong>, <strong class="source-inline">fontfamily</strong>, and <strong class="source-inline">fontstyle</strong> arguments, respectively.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Colors</h2>
			<p>For the sake of<a id="_idIndexMarker810"/> consistency, the visualizations we produce should stick to a color scheme. Companies and academic institutions alike often have custom color palettes for presentations. We can easily adopt the same color palette in our visualizations too.</p>
			<p>So far, we have either been providing colors to the <strong class="source-inline">color</strong> argument with their single character names, such as <strong class="source-inline">'b'</strong> for blue and <strong class="source-inline">'k'</strong> for black, or their names (<strong class="source-inline">'blue'</strong> or <strong class="source-inline">'black'</strong>). We have also seen that <strong class="source-inline">matplotlib</strong> has many colors that can be specified by name; the full list can be found in the documentation at <a href="https://matplotlib.org/examples/color/named_colors.html">https://matplotlib.org/examples/color/named_colors.html</a>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that if we are providing a color with the <strong class="source-inline">style</strong> argument, we are limited to the colors that have a single-character abbreviation.</p>
			<p>In addition, we can<a id="_idIndexMarker811"/> provide a hex code for the color we want; those who have worked with HTML or CSS in the past will no doubt be familiar with these as a way to specify the exact color (regardless of what different places call it). For those unfamiliar with a hex color code, it specifies the amount of red, green, and blue used to make the color in question in the <strong class="source-inline">#RRGGBB</strong> format. Black is <strong class="source-inline">#000000</strong> and white is <strong class="source-inline">#FFFFFF</strong> (case-insensitive). This may be confusing because <strong class="source-inline">F</strong> is most definitely not a number; however, these are hexadecimal numbers (base 16, not the base 10 we traditionally use), where <strong class="source-inline">0-9</strong> still represents <strong class="source-inline">0-9</strong>, but <strong class="source-inline">A-F</strong> represents <strong class="source-inline">10-15</strong>.</p>
			<p>Matplotlib accepts hex codes as a string to the <strong class="source-inline">color</strong> argument. To illustrate this, let's plot Facebook's opening price in <strong class="source-inline">#8000FF</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; fb.plot(</p>
			<p class="source-code">...     y='open',</p>
			<p class="source-code">...     figsize=(5, 3),</p>
			<p class="source-code">...     <strong class="bold">color='#8000FF'</strong>,</p>
			<p class="source-code">...     legend=False,</p>
			<p class="source-code">...     title='Evolution of FB Opening Price in 2018'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p>This results in a purple line plot:</p>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="image/fig_6.36.jpg" alt="Figure 6.36 – Changing line color&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.36 – Changing line color</p>
			<p>Alternatively, we may be given the values in RGB or <strong class="bold">red, green, blue, alpha</strong> (<strong class="bold">RGBA</strong>) values, in which case we can pass<a id="_idIndexMarker812"/> them to the <strong class="source-inline">color</strong> argument as a tuple. If we don't provide the alpha, it will default to <strong class="source-inline">1</strong> for opaque. One thing to note here is that, while we will find these numbers <a id="_idIndexMarker813"/>presented in the range [0, 255], <strong class="source-inline">matplotlib</strong> requires them to be in the range [0, 1], so we must divide each by 255. The following code is equivalent to the preceding example, except we use the RGB tuple instead of the hex code:</p>
			<p class="source-code">fb.plot(</p>
			<p class="source-code">    y='open',</p>
			<p class="source-code">    figsize=(5, 3),</p>
			<p class="source-code">    <strong class="bold">color=(128 / 255, 0, 1)</strong>,</p>
			<p class="source-code">    legend=False,</p>
			<p class="source-code">    title='Evolution of FB Opening Price in 2018'</p>
			<p class="source-code">)</p>
			<p class="source-code">plt.ylabel('price ($)')</p>
			<p>In the previous chapter, we saw several examples in which we needed many different colors for the varying data we were plotting, but where do these colors come from? Well, <strong class="source-inline">matplotlib</strong> has numerous colormaps that are used for this purpose.</p>
			<h3>Colormaps</h3>
			<p>Rather than having to<a id="_idIndexMarker814"/> specify all the colors we want to use upfront, <strong class="source-inline">matplotlib</strong> can take a colormap and cycle through the colors there. When we discussed heatmaps in the previous chapter, we considered the importance of using the proper class of colormap for the given task. There are three types of colormaps, each with its own purpose, as shown in the following table:</p>
			<div>
				<div id="_idContainer303" class="IMG---Figure">
					<img src="image/fig_6.37.jpg" alt="Figure 6.37 – Types of colormaps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.37 – Types of colormaps</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Browse colors by name, hex, and RGB values at <a href="https://www.color-hex.com/">https://www.color-hex.com/</a>, and find the full color spectrum for the colormaps at <a href="https://matplotlib.org/gallery/color/colormap_reference.html">https://matplotlib.org/gallery/color/colormap_reference.html</a>.</p>
			<p>In Python, we can obtain a list of all the available colormaps by running the following:</p>
			<p class="source-code">&gt;&gt;&gt; from matplotlib import cm</p>
			<p class="source-code">&gt;&gt;&gt; cm.datad.keys()</p>
			<p class="source-code">dict_keys(['Blues', 'BrBG', 'BuGn', 'BuPu', 'CMRmap', 'GnBu', </p>
			<p class="source-code">           'Greens', 'Greys', 'OrRd', 'Oranges', 'PRGn', </p>
			<p class="source-code">           'PiYG', 'PuBu', 'PuBuGn', 'PuOr', 'PuRd', 'Purples', </p>
			<p class="source-code">           'RdBu', 'RdGy', 'RdPu', 'RdYlBu', 'RdYlGn', </p>
			<p class="source-code">           'Reds', ..., 'Blues_r', 'BrBG_r', 'BuGn_r', ...])</p>
			<p>Notice that some of the <a id="_idIndexMarker815"/>colormaps are present twice where one is in the reverse order, signified by the <strong class="source-inline">_r</strong> suffix on the name. This is very helpful since we don't have to invert our data to map the values to the colors we want. Pandas accepts these colormaps as strings or <strong class="source-inline">matplotlib</strong> colormaps with the <strong class="source-inline">colormap</strong> argument of the <strong class="source-inline">plot()</strong> method, meaning we can pass in <strong class="source-inline">'coolwarm_r'</strong>,  <strong class="source-inline">cm.get_cmap('coolwarm_r')</strong>, or <strong class="source-inline">cm.coolwarm_r</strong> and get the same result.</p>
			<p>Let's use the <strong class="source-inline">coolwarm_r</strong> colormap to show how Facebook stock's closing price oscillates between the 20-day rolling minimum and maximum prices:</p>
			<p class="source-code">&gt;&gt;&gt; ax = fb.assign(</p>
			<p class="source-code">...     rolling_min=lambda x: x.low.rolling(20).min(),</p>
			<p class="source-code">...     rolling_max=lambda x: x.high.rolling(20).max()</p>
			<p class="source-code">... ).plot(</p>
			<p class="source-code">...     y=['rolling_max', 'rolling_min'], </p>
			<p class="source-code">...     <strong class="bold">colormap='coolwarm_r'</strong>, </p>
			<p class="source-code">...     label=['20D rolling max', '20D rolling min'],</p>
			<p class="source-code">...     style=[':', '--'],</p>
			<p class="source-code">...     figsize=(12, 3),</p>
			<p class="source-code">...     title='FB closing price in 2018 oscillating between '</p>
			<p class="source-code">...           '20-day rolling minimum and maximum price'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.plot(</p>
			<p class="source-code">...     fb.close, 'purple', alpha=0.25, label='closing price'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; plt.legend()</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p>Notice <a id="_idIndexMarker816"/>how easy it was to get red to represent hot performance (rolling maximum) and blue for cold (rolling minimum), by using the reversed colormap, rather than trying to make sure <strong class="source-inline">pandas</strong> plotted the rolling minimum first:</p>
			<div>
				<div id="_idContainer304" class="IMG---Figure">
					<img src="image/fig_6.38.jpg" alt="Figure 6.38 – Working with colormaps&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.38 – Working with colormaps</p>
			<p>The <strong class="source-inline">colormap</strong> object is a callable, meaning we can pass it values in the range [0, 1] and it will tell us the RGBA value for that point on the colormap, which we can use for the <strong class="source-inline">color</strong> argument. This gives us more fine-tuned control over the colors that we use from the colormap. We can use this technique to control how we spread the colormap across our data. For example, we can ask for the midpoint of the <strong class="source-inline">ocean</strong> colormap to use with the <strong class="source-inline">color</strong> argument:</p>
			<p class="source-code">&gt;&gt;&gt; cm.get_cmap('ocean')(.5)</p>
			<p class="source-code">(0.0, 0.2529411764705882, 0.5019607843137255, 1.0)</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There's an example of using a colormap as a callable in the <strong class="source-inline">covid19_cases_map.ipynb</strong> notebook, where COVID-19 case counts are mapped to colors, with darker colors indicating more cases.</p>
			<p>Despite the wealth of colormaps available, we may find the need to create our own. Perhaps we have a color palette we like to work with or have some requirement that we use a specific color scheme. We can make our own colormaps with <strong class="source-inline">matplotlib</strong>. Let's make a blended colormap that goes from purple (<strong class="source-inline">#800080</strong>) to yellow (<strong class="source-inline">#FFFF00</strong>) with orange (<strong class="source-inline">#FFA500</strong>) in the center. All the functions we need for this are in <strong class="source-inline">color_utils.py</strong>. We can import the functions like this if we are running Python from the same directory as the file:</p>
			<p class="source-code">&gt;&gt;&gt; import color_utils</p>
			<p>First, we need to translate these<a id="_idIndexMarker817"/> hex colors to their RGB equivalents, which is what the <strong class="source-inline">hex_to_rgb_color_list()</strong> function will do. Note that this function can also handle the shorthand hex codes of three digits when the RGB values use the same hexadecimal digit for both of the digits (for example, <strong class="source-inline">#F1D</strong> is the shorthand equivalent of <strong class="source-inline">#FF11DD</strong>):</p>
			<p class="source-code">import re</p>
			<p class="source-code">def hex_to_rgb_color_list(colors):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Take color or list of hex code colors and convert them </p>
			<p class="source-code">    to RGB colors in the range [0,1].</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - colors: Color or list of color strings as hex codes</p>
			<p class="source-code">    Returns:</p>
			<p class="source-code">        The color or list of colors in RGB representation.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    if isinstance(colors, str):</p>
			<p class="source-code">        colors = [colors]</p>
			<p class="source-code">    for i, color in enumerate(</p>
			<p class="source-code">        [color.replace('#', '') for color in colors]</p>
			<p class="source-code">    ):</p>
			<p class="source-code">        hex_length = len(color)</p>
			<p class="source-code">        if hex_length not in [3, 6]:</p>
			<p class="source-code">            raise ValueError(</p>
			<p class="source-code">                'Colors must be of the form #FFFFFF or #FFF'</p>
			<p class="source-code">            )</p>
			<p class="source-code">        regex = '.' * (hex_length // 3)</p>
			<p class="source-code">        <strong class="bold">colors[i] = [</strong></p>
			<p class="source-code">            <strong class="bold">int(val * (6 // hex_length), 16) / 255</strong></p>
			<p class="source-code">            <strong class="bold">for val in re.findall(regex, color)</strong></p>
			<p class="source-code">        <strong class="bold">]</strong></p>
			<p class="source-code">    return colors[0] if len(colors) == 1 else colors</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Take a look at the <strong class="source-inline">enumerate()</strong> function; this lets us grab the index and the value at that index when we iterate, rather than looking up the value in the loop. Also, notice how easy it is for Python to convert base 10 numbers to hexadecimal numbers with the <strong class="source-inline">int()</strong> function by specifying the base. (Remember that <strong class="source-inline">//</strong> is integer division—we have to do this since <strong class="source-inline">int()</strong> expects an integer and not a float.)</p>
			<p>The next function we <a id="_idIndexMarker818"/>need is one to take those RGB colors and create the values for the colormap. This function will need to do the following:</p>
			<ol>
				<li>Create a 4D NumPy array with 256 slots for color definitions. Note that we don't want to change the transparency, so we will leave the fourth dimension (alpha) alone.</li>
				<li>For each dimension (red, green, and blue), use the <strong class="source-inline">np.linspace()</strong> function to create even transitions between the target colors (that is, transition from the red component of color 1 to the red component of color 2, then to the red component of <a id="_idIndexMarker819"/>color 3, and so on, before repeating this process with the green components and finally the blue components).</li>
				<li>Return a <strong class="source-inline">ListedColormap</strong> object that we can use when plotting.</li>
			</ol>
			<p>This is what the <strong class="source-inline">blended_cmap()</strong> function does:</p>
			<p class="source-code">from matplotlib.colors import ListedColormap</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">def blended_cmap(rgb_color_list):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Create a colormap blending from one color to the other.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - rgb_color_list: List of colors represented as </p>
			<p class="source-code">          [R, G, B] values in the range [0, 1], like </p>
			<p class="source-code">          [[0, 0, 0], [1, 1, 1]], for black and white.</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        A matplotlib `ListedColormap` object</p>
			<p class="source-code">    """</p>
			<p class="source-code">    if not isinstance(rgb_color_list, list):</p>
			<p class="source-code">        raise ValueError('Colors must be passed as a list.')</p>
			<p class="source-code">    elif len(rgb_color_list) &lt; 2:</p>
			<p class="source-code">        raise ValueError('Must specify at least 2 colors.')</p>
			<p class="source-code">    elif (</p>
			<p class="source-code">        not isinstance(rgb_color_list[0], list)</p>
			<p class="source-code">        or not isinstance(rgb_color_list[1], list)</p>
			<p class="source-code">    ) or (</p>
			<p class="source-code">        (len(rgb_color_list[0]) != 3 </p>
			<p class="source-code">        or len(rgb_color_list[1]) != 3)</p>
			<p class="source-code">    ):</p>
			<p class="source-code">        raise ValueError(</p>
			<p class="source-code">            'Each color should be a list of size 3.'</p>
			<p class="source-code">        )</p>
			<p class="source-code">    <strong class="bold">N, entries = 256, 4 # red, green, blue, alpha</strong></p>
			<p class="source-code">    <strong class="bold">rgbas = np.ones((N, entries))</strong></p>
			<p class="source-code">    <strong class="bold">segment_count = len(rgb_color_list) – 1</strong></p>
			<p class="source-code">    <strong class="bold">segment_size = N // segment_count</strong></p>
			<p class="source-code">    <strong class="bold">remainder = N % segment_count</strong> # need to add this back later</p>
			<p class="source-code">    for i in range(entries - 1): # we don't alter alphas</p>
			<p class="source-code">        updates = []</p>
			<p class="source-code">        for seg in range(1, segment_count + 1):</p>
			<p class="source-code">            # handle uneven splits due to remainder</p>
			<p class="source-code">            offset = 0 if not remainder or seg &gt; 1 \</p>
			<p class="source-code">                     else remainder</p>
			<p class="source-code">            updates.append(<strong class="bold">np.linspace(</strong></p>
			<p class="source-code">                <strong class="bold">start=rgb_color_list[seg - 1][i], </strong></p>
			<p class="source-code">                <strong class="bold">stop=rgb_color_list[seg][i], </strong></p>
			<p class="source-code">                <strong class="bold">num=segment_size + offset</strong></p>
			<p class="source-code">            <strong class="bold">)</strong>)</p>
			<p class="source-code">        rgbas[:,i] = np.concatenate(updates)</p>
			<p class="source-code">    return ListedColormap(rgbas)</p>
			<p>We can use the <strong class="source-inline">draw_cmap()</strong> function to draw a colorbar, which allows us to visualize our<a id="_idIndexMarker820"/> colormap:</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">def draw_cmap(cmap, values=np.array([[0, 1]]), **kwargs):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Draw a colorbar for visualizing a colormap.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - cmap: A matplotlib colormap</p>
			<p class="source-code">        - values: Values to use for the colormap</p>
			<p class="source-code">        - kwargs: Keyword arguments to pass to `plt.colorbar()`</p>
			<p class="source-code">    Returns:</p>
			<p class="source-code">        A matplotlib `Colorbar` object, which you can save </p>
			<p class="source-code">        with: `plt.savefig(&lt;file_name&gt;, bbox_inches='tight')`</p>
			<p class="source-code">    """</p>
			<p class="source-code">    img = plt.imshow(values, cmap=cmap)</p>
			<p class="source-code">    cbar = plt.colorbar(**kwargs)</p>
			<p class="source-code">    img.axes.remove()</p>
			<p class="source-code">    return cbar</p>
			<p>This function<a id="_idIndexMarker821"/> makes it easy for us to add a colorbar with a custom colormap for any visualization we choose; the <strong class="source-inline">covid19_cases_map.ipynb</strong> notebook has an example using COVID-19 cases plotted on a world map. For now, let's use these functions to create and visualize our colormap. We will be using them by importing the module (which we did earlier):</p>
			<p class="source-code">&gt;&gt;&gt; my_colors = ['#800080', '#FFA500', '#FFFF00']</p>
			<p class="source-code">&gt;&gt;&gt; rgbs = color_utils.hex_to_rgb_color_list(my_colors)</p>
			<p class="source-code">&gt;&gt;&gt; my_cmap = color_utils.blended_cmap(rgbs)</p>
			<p class="source-code">&gt;&gt;&gt; color_utils.draw_cmap(my_cmap, orientation='horizontal')</p>
			<p>This results in the following colorbar showing our colormap:</p>
			<div>
				<div id="_idContainer305" class="IMG---Figure">
					<img src="image/fig_6.39.jpg" alt="Figure 6.39 – Custom blended colormap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.39 – Custom blended colormap</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Seaborn also provides additional color palettes, along with handy utilities for picking colormaps and making custom ones for use with <strong class="source-inline">matplotlib</strong> interactively in a Jupyter Notebook. Check out the <em class="italic">Choosing color palettes</em> tutorial (<a href="https://seaborn.pydata.org/tutorial/color_palettes.html">https://seaborn.pydata.org/tutorial/color_palettes.html</a>) for more information. The notebook also contains a short example.</p>
			<p>As we have seen in the colorbar we created, these colormaps have the ability to show different gradients of the colors to capture values on a continuum. If we merely want each line in our line<a id="_idIndexMarker822"/> plot to be a different color, we most likely want to cycle between different colors. For that, we can use <strong class="source-inline">itertools.cycle()</strong> with a list of colors; they won't be blended, but we can cycle through them endlessly because it will be an infinite iterator. We used this technique earlier in the chapter to define our own colors for the regression residuals plots:</p>
			<p class="source-code">&gt;&gt;&gt; import itertools</p>
			<p class="source-code">&gt;&gt;&gt; colors = itertools.cycle(['#ffffff', '#f0f0f0', '#000000'])</p>
			<p class="source-code">&gt;&gt;&gt; colors</p>
			<p class="source-code">&lt;itertools.cycle at 0x1fe4f300&gt;</p>
			<p class="source-code">&gt;&gt;&gt; next(colors)</p>
			<p class="source-code">'#ffffff'</p>
			<p>Even simpler would be the case where we have a list of colors somewhere, but rather than putting that in our plotting code and storing another copy in memory, we can write a simple <strong class="bold">generator</strong> that just <em class="italic">yields</em> from that<a id="_idIndexMarker823"/> master list. By using generators, we are being efficient with memory without crowding our plotting code with the color logic. Note that a generator is defined as a function, but instead of using <strong class="source-inline">return</strong>, it uses <strong class="source-inline">yield</strong>. The following snippet shows a mock-up for this scenario, which is similar to the <strong class="source-inline">itertools</strong> solution; however, it is not infinite. This just goes to show that we can find many ways to do something in Python; we have to find the implementation that best meets our needs:</p>
			<p class="source-code">from my_plotting_module import master_color_list</p>
			<p class="source-code">def color_generator():</p>
			<p class="source-code">    <strong class="bold">yield from</strong> master_color_list</p>
			<p>Using <strong class="source-inline">matplotlib</strong>, the alternative would be to instantiate a <strong class="source-inline">ListedColormap</strong> object with the color list and define a large value for <strong class="source-inline">N</strong> so that it repeats for long enough (if we don't provide it, it will only go through the colors once):</p>
			<p class="source-code">&gt;&gt;&gt; from matplotlib.colors import ListedColormap</p>
			<p class="source-code">&gt;&gt;&gt; red_black = <strong class="bold">ListedColormap(['red', 'black'], N=2000)</strong></p>
			<p class="source-code">&gt;&gt;&gt; [red_black(i) for i in range(3)]</p>
			<p class="source-code">[(1.0, 0.0, 0.0, 1.0), </p>
			<p class="source-code"> (0.0, 0.0, 0.0, 1.0), </p>
			<p class="source-code"> (1.0, 0.0, 0.0, 1.0)]</p>
			<p>Note that <a id="_idIndexMarker824"/>we can also use <strong class="source-inline">cycler</strong> from the <strong class="source-inline">matplotlib</strong> team, which adds additional flexibility by allowing us to define combinations of colors, line styles, markers, line widths, and more to cycle through. The API details the available functionality and can be found at <a href="https://matplotlib.org/cycler/">https://matplotlib.org/cycler/</a>. We will see an example of this in <a href="B16834_07_Final_SK_ePub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">Financial Analysis – Bitcoin and the Stock Market</em>.</p>
			<h3>Conditional coloring</h3>
			<p>Colormaps make it easy to vary color according to the values in our data, but what happens if we<a id="_idIndexMarker825"/> only want to use a specific color when certain conditions are met? In that case, we need to build a function around color selection.</p>
			<p>We can write a generator to determine plot color based on our data and only calculate it when it is asked for. Let's say we wanted to assign colors to years from 1992 to 200018 (no, that's not a typo) based on whether they are leap years, and distinguish why they aren't leap years (for example, we want a special color for years divisible by 100 but not 400, which aren't leap years). We certainly don't want to keep a list this size in memory, so we create a generator to calculate the color on demand:</p>
			<p class="source-code">def color_generator():</p>
			<p class="source-code">    for year in range(1992, 200019): # integers [1992, 200019)</p>
			<p class="source-code">        if year % 100 == 0 and year % 400 != 0: </p>
			<p class="source-code">            # special case (divisible by 100 but not 400)</p>
			<p class="source-code">            color = '#f0f0f0'</p>
			<p class="source-code">        elif year % 4 == 0:</p>
			<p class="source-code">            # leap year (divisible by 4)</p>
			<p class="source-code">            color = '#000000'</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            color = '#ffffff'</p>
			<p class="source-code">        <strong class="bold">yield color</strong></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="bold">modulo operator</strong> (%) returns the<a id="_idIndexMarker826"/> remainder of a division operation. For example, 4 % 2 equals 0 because 4 is divisible by 2. However, since 4 is not divisible by 3, 4 % 3 is non-zero; it is 1 because we can fit 3 into 4 once and will have 1 left over (4 - 3). The modulo operator can be used to check the divisibility of one number by another and is often used to check whether a number is odd or even. Here, we are using it to see whether the conditions for being a leap year (which depend on divisibility) are met.</p>
			<p>Since we <a id="_idIndexMarker827"/>defined <strong class="source-inline">year_colors</strong> as a generator, Python will remember where we are in this function and resume when <strong class="source-inline">next()</strong> is called:</p>
			<p class="source-code">&gt;&gt;&gt; year_colors = color_generator()</p>
			<p class="source-code">&gt;&gt;&gt; year_colors</p>
			<p class="source-code">&lt;generator object color_generator at 0x7bef148dfed0&gt;</p>
			<p class="source-code">&gt;&gt;&gt; next(year_colors)</p>
			<p class="source-code">'#000000'</p>
			<p>Simpler generators can be<a id="_idIndexMarker828"/> written with <strong class="bold">generator expressions</strong>. For example, if we don't care about the special case anymore, we can use the following:</p>
			<p class="source-code">&gt;&gt;&gt; year_colors = (</p>
			<p class="source-code">...     '#ffffff'</p>
			<p class="source-code">...     if (not year % 100 and year % 400) or year % 4</p>
			<p class="source-code">...     else '#000000' for year in range(1992, 200019)</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; year_colors</p>
			<p class="source-code">&lt;generator object &lt;genexpr&gt; at 0x7bef14415138&gt;</p>
			<p class="source-code">&gt;&gt;&gt; next(year_colors)</p>
			<p class="source-code">'#000000'</p>
			<p>Those not coming from Python might find it strange that our Boolean conditions in the previous code snippet are actually numbers (<strong class="source-inline">year % 400</strong> results in an integer). This is taking advantage of Python's <em class="italic">truthy</em>/<em class="italic">falsey</em> values; values that have zero value (such as the number <strong class="source-inline">0</strong>) or are empty (such as <strong class="source-inline">[]</strong> or <strong class="source-inline">''</strong>) are <em class="italic">falsey</em>. Therefore, while in the first generator, we wrote <strong class="source-inline">year % 400 != 0</strong> to show exactly what was going on, the more <strong class="bold">Pythonic</strong> way is <strong class="source-inline">year % 400</strong>, since if there is no remainder (evaluates to 0), the statement will be<a id="_idIndexMarker829"/> evaluated as <strong class="source-inline">False</strong>, and vice versa. Obviously, we will have times where we must choose between readability and being Pythonic, but it's good to be aware of how<a id="_idIndexMarker830"/> to write Pythonic code, as it will often be more efficient.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Run <strong class="source-inline">import this</strong> in Python to see <strong class="bold">the Zen of Python</strong>, which <a id="_idIndexMarker831"/>gives some ideas of what it means to be Pythonic.</p>
			<p>Now that we have some exposure to working with colors in <strong class="source-inline">matplotlib</strong>, let's consider another way we can make our data stand out. Depending on what we are plotting or how our visualization will be used (for example, in black and white), it might make sense to use textures along with, or instead of, colors.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Textures</h2>
			<p>In addition to <a id="_idIndexMarker832"/>customizing the colors used in our visualizations, <strong class="source-inline">matplotlib</strong> also makes it possible to include textures with a variety of plotting functions. This is achieved via the <strong class="source-inline">hatch</strong> argument, which <strong class="source-inline">pandas</strong> will pass down for us. Let's create a bar plot of weekly volume traded in Facebook stock during Q4 2018 with <a id="_idIndexMarker833"/>textured bars:</p>
			<p class="source-code">&gt;&gt;&gt; weekly_volume_traded = fb.loc['2018-Q4']\</p>
			<p class="source-code">...     .groupby(pd.Grouper(freq='W')).volume.sum()</p>
			<p class="source-code">&gt;&gt;&gt; weekly_volume_traded.index = \</p>
			<p class="source-code">...     weekly_volume_traded.index.strftime('W %W')</p>
			<p class="source-code">&gt;&gt;&gt; ax = weekly_volume_traded.plot(</p>
			<p class="source-code">...     kind='bar',</p>
			<p class="source-code">...     <strong class="bold">hatch='*'</strong>,</p>
			<p class="source-code">...     color='lightgray',</p>
			<p class="source-code">...     title='Volume traded per week in Q4 2018'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set(</p>
			<p class="source-code">...     xlabel='week number', </p>
			<p class="source-code">...     ylabel='volume traded'</p>
			<p class="source-code">... )</p>
			<p>With <strong class="source-inline">hatch='*'</strong>, our bars are filled with stars. Notice that we also set the color for each of the bars, so there is a lot of flexibility here:</p>
			<div>
				<div id="_idContainer306" class="IMG---Figure">
					<img src="image/fig_6.40.jpg" alt="Figure 6.40 – Using textured bars&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.40 – Using textured bars</p>
			<p>Textures can also be combined to make new patterns and repeated to intensify the effect. Let's revisit the <strong class="source-inline">plt.fill_between()</strong> example where we colored the December section only (<em class="italic">Figure 6.33</em>). This time we will use textures to distinguish between each month, rather than only shading December; we will fill October with rings, November with <a id="_idIndexMarker834"/>slashes, and December with small dots:</p>
			<p class="source-code">&gt;&gt;&gt; import calendar</p>
			<p class="source-code">&gt;&gt;&gt; fb_q4 = fb.loc['2018-Q4']</p>
			<p class="source-code">&gt;&gt;&gt; for texture, month in zip(</p>
			<p class="source-code">...     <strong class="bold">['oo', '/\\/\\', '...']</strong>, [10, 11, 12]</p>
			<p class="source-code">... ):</p>
			<p class="source-code">...     plt.fill_between(</p>
			<p class="source-code">...         fb_q4.index, fb_q4.high, fb_q4.low,</p>
			<p class="source-code">...         <strong class="bold">hatch=texture</strong>, facecolor='white',</p>
			<p class="source-code">...         where=fb_q4.index.month == month,</p>
			<p class="source-code">...         label=f'{calendar.month_name[month]} differential'</p>
			<p class="source-code">...     )</p>
			<p class="source-code">&gt;&gt;&gt; plt.plot(fb_q4.index, fb_q4.high, '--', label='daily high')</p>
			<p class="source-code">&gt;&gt;&gt; plt.plot(fb_q4.index, fb_q4.low, '--', label='daily low')</p>
			<p class="source-code">&gt;&gt;&gt; plt.xticks([</p>
			<p class="source-code">...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'</p>
			<p class="source-code">... ])</p>
			<p class="source-code">&gt;&gt;&gt; plt.xlabel('date')</p>
			<p class="source-code">&gt;&gt;&gt; plt.ylabel('price ($)')</p>
			<p class="source-code">&gt;&gt;&gt; plt.title(</p>
			<p class="source-code">...     'FB differential between high and low price Q4 2018'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; plt.legend()</p>
			<p>Using <strong class="source-inline">hatch='o'</strong> would yield thin rings, so we used <strong class="source-inline">'oo'</strong> to get thicker rings for October. For November, we wanted a crisscross pattern, so we combined two forward slashes and two <a id="_idIndexMarker835"/>backslashes (we actually have four backslashes because they must be escaped). To achieve the small dots for December, we used three periods—the more we add, the denser the texture becomes:</p>
			<div>
				<div id="_idContainer307" class="IMG---Figure">
					<img src="image/fig_6.41.jpg" alt="Figure 6.41 – Combining textures&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.41 – Combining textures</p>
			<p>This concludes our discussion of plot customizations. By no means was this meant to be complete, so be sure to explore the <strong class="source-inline">matplotlib</strong> API for more.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Summary</h1>
			<p>Whew, that was a lot! We learned how to create impressive and customized visualizations using <strong class="source-inline">matplotlib</strong>, <strong class="source-inline">pandas</strong>, and <strong class="source-inline">seaborn</strong>. We discussed how we can use <strong class="source-inline">seaborn</strong> for additional plotting types and cleaner versions of some familiar ones. Now we can easily make our own colormaps, annotate our plots, add reference lines and shaded regions, finesse the axes/legends/titles, and control most aspects of how our visualizations will appear. We also got a taste of working with <strong class="source-inline">itertools</strong> and creating our own generators.</p>
			<p>Take some time to practice what we've discussed with the end-of-chapter exercises. In the next chapter, we will apply all that we have learned to finance, as we build our own Python package and compare bitcoin to the stock market.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Exercises</h1>
			<p>Create the following visualizations using what we have learned so far in this book and the data from this chapter. Be sure to add titles, axis labels, and legends (where appropriate) to the plots:</p>
			<ol>
				<li value="1">Using <strong class="source-inline">seaborn</strong>, create a heatmap to visualize the correlation coefficients between earthquake magnitude and whether there was a tsunami for earthquakes measured with the <strong class="source-inline">mb</strong> magnitude type.</li>
				<li>Create a box plot of Facebook volume traded and closing prices, and draw reference lines for the bounds of a Tukey fence with a multiplier of 1.5. The bounds will be at <em class="italic">Q</em><span class="subscript">1</span><em class="italic"> − 1.5 × IQR</em> and <em class="italic">Q</em><span class="subscript">3</span><em class="italic"> + 1.5 × IQR</em>. Be sure to use the <strong class="source-inline">quantile()</strong> method on the data to make this easier. (Pick whichever orientation you prefer for the plot, but make sure to use subplots.)</li>
				<li>Plot the evolution of cumulative COVID-19 cases worldwide, and add a dashed vertical line on the date that it surpassed 1 million. Be sure to format the tick labels on the <em class="italic">y</em>-axis accordingly.</li>
				<li>Use <strong class="source-inline">axvspan()</strong> to shade a rectangle from <strong class="source-inline">'2018-07-25'</strong> to <strong class="source-inline">'2018-07-31'</strong>, which marks the large decline in Facebook price on a line plot of the closing price.</li>
				<li>Using the Facebook stock price data, annotate the following three events on a line plot of the closing price:<p>a) <strong class="bold">Disappointing user growth announced after close</strong> on July 25, 2018</p><p>b) <strong class="bold">Cambridge Analytica story breaks</strong> on March 19, 2018 (when it affected the market)</p><p>c) <strong class="bold">FTC launches investigation</strong> on March 20, 2018</p></li>
				<li>Modify the <strong class="source-inline">reg_resid_plots()</strong> function to use a <strong class="source-inline">matplotlib</strong> colormap instead of cycling between two colors. Remember, for this use case, we should pick a qualitative colormap or make our own.</li>
			</ol>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Further reading</h1>
			<p>Check out the following resources for more information on the topics covered in this chapter:</p>
			<ul>
				<li><em class="italic">Choosing Colormaps</em>: <a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></li>
				<li><em class="italic">Controlling figure aesthetics (seaborn)</em>: <a href="https://seaborn.pydata.org/tutorial/aesthetics.html">https://seaborn.pydata.org/tutorial/aesthetics.html</a></li>
				<li><em class="italic">Customizing Matplotlib with style sheets and rcParams</em>: <a href="https://matplotlib.org/tutorials/introductory/customizing.html">https://matplotlib.org/tutorials/introductory/customizing.html</a></li>
				<li><em class="italic">Format String Syntax</em>: <a href="https://docs.python.org/3/library/string.html#format-string-syntax">https://docs.python.org/3/library/string.html#format-string-syntax</a></li>
				<li><em class="italic">Generator Expressions (PEP 289)</em>: <a href="https://www.python.org/dev/peps/pep-0289/">https://www.python.org/dev/peps/pep-0289/</a></li>
				<li><em class="italic">Information Dashboard Design: Displaying Data for At-a-Glance Monitoring, Second Edition, by Stephen Few</em>: <a href="https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/">https://www.amazon.com/Information-Dashboard-Design-At-Glance/dp/1938377001/</a></li>
				<li><em class="italic">Matplotlib Named Colors</em>: <a href="https://matplotlib.org/examples/color/named_colors.html">https://matplotlib.org/examples/color/named_colors.html</a></li>
				<li><em class="italic">Multiple assignment and tuple unpacking improve Python code readability</em>: <a href="https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/">https://treyhunner.com/2018/03/tuple-unpacking-improves-python-code-readability/</a></li>
				<li><em class="italic">Python: range is not an iterator!</em>: <a href="https://treyhunner.com/2018/02/python-range-is-not-an-iterator/">https://treyhunner.com/2018/02/python-range-is-not-an-iterator/</a></li>
				<li><em class="italic">Python zip() function</em>: <a href="https://www.journaldev.com/15891/python-zip-function">https://www.journaldev.com/15891/python-zip-function</a></li>
				<li><em class="italic">Seaborn API reference</em>: <a href="https://seaborn.pydata.org/api.html">https://seaborn.pydata.org/api.html</a></li>
				<li><em class="italic">Show Me the Numbers: Designing Tables and Graphs to Enlighten, by Stephen Few</em>: <a href="https://www.amazon.com/gp/product/0970601972/">https://www.amazon.com/gp/product/0970601972/</a></li>
				<li><em class="italic">Style sheets reference (Matplotlib)</em>: <a href="https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html">https://matplotlib.org/gallery/style_sheets/style_sheets_reference.html</a></li>
				<li><em class="italic">Support and Resistance Basics</em>: <a href="https://www.investopedia.com/trading/support-and-resistance-basics/">https://www.investopedia.com/trading/support-and-resistance-basics/</a></li>
				<li><em class="italic">The Iterator Protocol: How "For Loops" Work in Python</em>: <a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/</a></li>
				<li><em class="italic">The Visual Display of Quantitative Information, by Edward R. Tufte</em>: <a href="https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130">https://www.amazon.com/Visual-Display-Quantitative-Information/dp/1930824130</a></li>
				<li><em class="italic">Tick formatters</em>: <a href="https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html">https://matplotlib.org/gallery/ticks_and_spines/tick-formatters.html</a></li>
				<li><em class="italic">What does Pythonic mean?</em>: <a href="https://stackoverflow.com/questions/25011078/what-does-pythonic-mean">https://stackoverflow.com/questions/25011078/what-does-pythonic-mean</a></li>
			</ul>
		</div>
	</body></html>