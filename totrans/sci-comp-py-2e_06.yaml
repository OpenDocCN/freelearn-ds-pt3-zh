- en: Plotting
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotting in Python can be done with the `pyplot` part of the module Matplotlib.
    With `matplotlib`, you can create high-quality figures and graphics and also plot
    and visualize your results. Matplotlib is open source and freely available software.
    The Matplotlib website also contains excellent documentation with examples, see
    [35](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml). In this section, we will show
    you how to use the most common features. The examples in the upcoming sections
    assume that you have imported the module as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In case you want to use the plotting commands in IPython, it is recommended
    that you run the *magic command* `%matplotlib` directly after starting the IPython
    shell. This prepares IPython for interactive plotting.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Making plots with basic plotting commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create plots by means of basic commands. It is the
    entry point for studying how to make graphical representations of mathematical
    objects and data using Python.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.1 Using the plot command and some of its variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard plotting function is `plot`. Calling `plot(x,y)` creates a figure
    window with a plot of ![](img/0bebbcfd-cc30-44ee-a0a3-5e07f610d63b.png) as a function
    of ![](img/17e2c94a-5fd0-415b-a4e3-217aebb2fa23.png). The input arguments are
    arrays (or lists) of equal length. It is also possible to use `plot(y)`, in which
    case the values in ![](img/77346714-da93-4af9-97f6-a5ccf7e135d1.png) will be plotted
    against their index, that is, `plot(y)` is a short form of `plot(range(len(y)),y)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that shows how to plot ![](img/d15e859d-6238-4437-987e-6f989435ab76.png)
    using 200 sample points and with markers at every fourth point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following figure (*Figure 6.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8bca15b-e7cd-42d6-bc6b-1dc72d497cd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: A plot of the function sin(x) with grid lines shown'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the standard plot is a solid blue curve. Each axis gets automatically
    scaled to fit the values, but can also be set manually. Color and plot options
    can be given after the first two input arguments. Here, `r*` indicates red star-shaped
    markers. Formatting is covered in more detail in the next section. The command `title` puts a
    title text string above the plot area.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `plot` multiple times will overlay the plots in the same window. To
    get a new clean figure window, use `figure()`. The command `figure` might contain
    an integer, for example, `figure(2)`, which can be used to switch between figure
    windows. If there is no figure window with that number, a new one is created,
    otherwise, the window is activated for plotting and all subsequent plotting commands
    apply to that window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple plots can be explained by using the function `legend`, along with
    adding labels to each plot call. The following example fits polynomials to a set of
    points using the commands `polyfit` and `polyval`, and plots the result with a
    legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can also see how to manually set the range of the axis using `axis([xmin,xmax,ymin,ymax])`.
    The command `legend` takes optional arguments on placement and formatting; in
    this case, the legend is put in the upper-left corner and typeset with a small
    font size, as shown in the following figure (*Figure 6.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a14516df-6320-4707-9dde-d9e1f12eb6ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Two polynomials fitted to the same points'
  prefs: []
  type: TYPE_NORMAL
- en: As final examples for basic plotting, we demonstrate how to do scatter plots and
    logarithmic plots in two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a 2D point scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1abff8af-22ad-4ced-b8a8-6d55a08d1841.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3(a): An example of a scatter plot'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a logarithmic plot using `loglog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/79c6a098-ec45-455b-8a16-454ae29cd3b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3(b): An example of a plot with logarithmic *x* and *y* axes'
  prefs: []
  type: TYPE_NORMAL
- en: The examples shown in the preceding figure (*Figure 6.3(a)* and *Figure 6.3(b)*)
    used some parameters of `plot` and `loglog`, which allow special formatting. In
    the next section, we will explain the parameters in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.2 Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The appearance of figures and plots can be styled and customized to look how
    you want them to look. Some important variables are `linewidth`, which controls
    the thickness of plot lines, `xlabel` and `ylabel`, which set the axis labels, `color` for
    plot colors, and `transparent` for transparency.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will tell you how to use some of them. The following is an example
    with more keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are short commands that can be used if you only need basic style changes,
    for example, setting the color and line style. The following table (*Table 6.1*)
    shows some examples of these formatting commands. You may use either the short
    string syntax `plot(...,'ro-')`, or the more explicit syntax `plot(..., marker='o',
    color='r', linestyle='-')`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb6fd063-8472-4188-8a3e-a95226d58bad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.1: Some common plot formatting arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the color to green with the marker `''o''`, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot histograms instead of regular plots, the command `hist` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9d2b730a-47c1-40ff-b0cd-b5ff99327b78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Normal distribution with 50 bins and a green curve indicating the
    true distribution'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting plot looks similar to *Figure 6.4*. The title, and any other text,
    can be formatted using LaTeX to show mathematical formulas. LaTeX formatting is
    enclosed within a pair of `$` signs. Also, note the string formatting done using
    the method `format`; see [Section 2.4.3](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml),
    *String formatting*.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the brackets for the string formatting interfere with LaTeX bracket
    environments. If this occurs, replace the LaTeX bracket with a double bracket;
    for example, `x_{1}` should be replaced with `x_{{1}}`. The text might contain
    sequences that overlap with string escape sequences, for example, `\tau` will
    be interpreted as the tab character, `\t`. An easy workaround is to add `r` before
    the string, for example, `r'\tau'`. This makes it a raw string.
  prefs: []
  type: TYPE_NORMAL
- en: Placing several plots in one figure window can be done using the command `subplot`.
    Consider the following example, which iteratively averages out the noise on a
    sine curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4ece0cd7-35f1-4ea1-80a4-606d8f8b4633.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: An example of plotting several subplots in the same figure window'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `avg` uses the NumPy function `roll` to shift all values of the
    array. `subplot` takes three arguments: the number of vertical plots, the number
    of horizontal plots, and an index indicating which location to plot in (counted
    row-wise). Note that we used the command `subplots_adjust` to add extra space
    to adjust the distance between the subplots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful command is `savefig`, which lets you save a figure as an image (this
    can also be done from the figure window). Many image and file formats are supported
    by this command; they are specified by the filename''s extension as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can place the image against a non-white background, for example, a web
    page. For this, the parameter `transparent` can be set to make the figure''s background
    transparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you intend to embed a figure into a LaTeX document, it is recommended that
    you reduce the surrounding white space by setting the figure''s bounding box tight around
    the drawing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 6.1.3 Working with meshgrid and contours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common task is a graphical representation of a scalar function over a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf7a60e2-808a-4314-8834-89fbc8f13bed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For this, first we have to generate a grid on the rectangle ![](img/b8fbb3cc-da62-4469-b2e1-8882e423bac6.png).
    This is done using the command `meshgrid` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`X` and `Y` are arrays with an `(n,m)` shape such that `X[i,j]` and `Y[i,j]` contain
    the coordinates of the grid point [![](img/30c2ef7b-8ed9-474e-a2c7-fb9dea5e92f3.png)],
    as shown in *Figure 6.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5b1481f-1499-4c11-8758-b8049dd174cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: A rectangle discretized by meshgrid.'
  prefs: []
  type: TYPE_NORMAL
- en: A rectangle discretized by `meshgrid` will be used in the next section to visualize
    the behavior of an iteration, while we will use it here to plot the level curves
    of a function. This is done by the command `contour`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we choose Rosenbrock''s banana function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ea8cf3c-24a2-416a-a130-2cefe007da25.png)'
  prefs: []
  type: TYPE_IMG
- en: It is used to challenge optimization methods, see [[27]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
    The function values descend toward a banana-shaped valley, which itself decreases
    slowly toward the function's global minimum at (1, 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we display the level curves using `contour`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This plots the level curve at the levels given by the fourth parameter and uses
    the colormap `gray`. Furthermore, we used logarithmically spaced steps from 10^(0.5) to
    10³ using the function `logscale` to define the levels, see *Figure 6.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/297117a6-be35-49fb-bd9a-e882ec0a0d08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: A contour plot of the Rosenbrock function'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, an anonymous function indicated by the keyword `lambda` is
    used to keep the code compact. Anonymous functions are explained in [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml),
    *Anonymous Functions *. If levels are not given as arguments to `contour`, the
    function chooses appropriate levels by itself.
  prefs: []
  type: TYPE_NORMAL
- en: The function `contourf` performs the same task as `contour`, but fills the plot
    with colors according to different levels. Contour plots are ideal for visualizing
    the behavior of a numerical method. We illustrate this here by showing the iterations
    of an optimization method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue the preceding example and depict the steps toward the minimum of
    the Rosenbrock function generated by Powell''s method, which we will apply to
    find the minimum of the Rosenbrock function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The iterative method `fmin_powell` applies Powell's method to find a minimum.
    It is started by a given start value *[![](img/2cc00c09-516b-4d00-828a-1c36ee601c4f.png)]*
    and reports all iterates when the option `retall=True` is given. After 16 iterations,
    the solution ![](img/899aeac0-4ed8-4a07-aa68-aefa0abcfbf9.png) was found. . The
    iterations are depicted as bullets in the contour plot; see *Figure 6.8.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8264e8e-e652-40ce-b542-cd5933ccb2b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: A contour plot of the Rosenbrock function with a search path of
    an optimization method'
  prefs: []
  type: TYPE_NORMAL
- en: The function `contour` also creates a contour set object that we assigned to
    the variable `cs`. This is then used by `clabel` to annotate the levels of the
    corresponding function values, as shown in the *Figure 6.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1.4 Generating images and contours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at some examples of visualizing arrays as images. The following
    function will create a matrix of color values for the Mandelbrot fractal, see
    also [[20]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml). Here, we consider a fixed-point
    iteration, which depends on a complex parameter, ![](img/7da969b2-9b13-46c2-8302-ac87dcd6ea89.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94a571d8-b85c-4c81-b346-4715ff922487.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on the choice of this parameter, it may or may not create a bounded
    sequence of complex values, ![](img/79494086-b942-40d5-8ddd-9d5909102f58.png).
  prefs: []
  type: TYPE_NORMAL
- en: For every value of ![](img/8f79f3af-5180-4652-be25-3ac505e9c0e1.png), we check
    whether [![](img/e18e3d50-d5e0-4d92-9a5b-729259d50640.png)] exceeds a prescribed
    bound. If it remains below the bound within `maxit` iterations, we assume the
    sequence to be bounded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how, in the following piece of code,`meshgrid` is used to generate a matrix
    of complex parameter values, *![](img/23c90700-fa16-49ff-a92c-4d06ad22376d.png)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The command `imshow` displays the matrix as an image. The selected color map
    shows the regions where the sequence appeared unbounded in white and others in
    black. Here, we used `axis('off')` to turn off the axis as this might not be so
    useful for images.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/509af838-00f1-4ec8-acce-bf44d789faa4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: An example of using imshow to visualize a matrix as an image'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `imshow` uses interpolation to make the images look nicer. This
    is clearly seen when the matrices are small. The next figure shows the difference
    between using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the second example, pixel values are just replicated, see [[30]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae936a8e-16d1-4fd1-8a10-bc1a5c07efba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: The difference between using the linear interpolation of imshow
    compared to using nearest-neighbor interpolation'
  prefs: []
  type: TYPE_NORMAL
- en: For more details on working and plotting with images using Python.
  prefs: []
  type: TYPE_NORMAL
- en: After having seen how to make plots in the "command-way," we will consider a
    more object-oriented approach in the following sections. Although slightly more
    complicated, it opens up a vast range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 Working with Matplotlib objects directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we have used the `pyplot` module of matplotlib. This module makes
    it easy for us to use the most important plot commands directly. Mostly, we are
    interested in creating a figure and displaying it immediately. Sometimes, though,
    we want to generate a figure that should be modified later by changing some of
    its attributes. This requires us to work with graphical objects in an object-oriented
    way. In this section, we will present some basic steps to modify figures. For
    a more sophisticated object-oriented approach to plotting in Python, you have
    to leave `pyplot` and have to dive directly into `matplotlib` with its extensive
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.1 Creating axes objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a plot that should be modified later, we need references to a
    figure and an axes object. For this, we have to create a figure first and then
    define some axes and their location in the figure, and we should not forget to
    assign these objects to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A figure can have several axes objects depending on the use of `subplot`. In
    a second step, plots are associated with a given axes object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used an anonymous function indicated by the keyword `lambda`. We will
    explain this construct later in [Section 7.7](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml),
    *Anonymous functions*. In fact, these two plot commands fill the list `ax.lines` with
    two `Lines2D` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a good practice to use labels so that we can later identify objects in
    an easy way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have now set things up in a way that allows further modifications. The figure
    we have obtained thus far is shown in *Figure* *6.11, (left).*
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Modifying line properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just identified a particular line object by its label. It is an element
    of the list `ax.lines` with the index `il`. All of its properties are collected
    in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be obtained by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'They can be changed by corresponding setter methods. Let''s now change the
    line style of the sine curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even modify the data, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in *Figure 6.11, (right)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb85293c-d3b5-49dc-b8b7-c982db0cf062.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: The amplitude-modulated sine function (left) and a curve with
    the last data point corrupted (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.3 Making annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One useful axes method is `annotate`. It sets an annotation at a given position
    and points, with an arrow, to another position in the drawing. The arrow can be
    given properties in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the first annotation example above, the arrow points to a point with the
    coordinates (*2.1, 1.0*), and the left-bottom coordinate of the text is (*3.2,
    0.5*). If not otherwise specified, the coordinates are given in the convenient
    data coordinate system, which refers to the data used to generate the plots.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we demonstrated a couple of arrow properties specified by the dictionary `arrowprop`.
    You can scale the arrow by the key `shrink`. The setting `'shrink':0.05` reduces
    the arrow size by 5% to keep a distance to the curve it points to. You can let
    the arrow take the form of a spline arc or give it other shapes using the key
    `connectionstyle`.
  prefs: []
  type: TYPE_NORMAL
- en: Text properties, or even a bounding box around the text, can be made by extra
    keyword arguments to the annotate method, see *Figure 6.12, (left*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Experimenting with annotations sometimes requires several attempts and we need to
    reject some of those. Therefore, we assigned the annotate object to a variable,
    which allows us to remove the annotation by its `remove` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 6.2.4 Filling areas between curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filling is an ideal tool for highlighting differences between curves, such as
    noise on top of expected data and approximations versus exact functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filling is done by the axis method, `fill_between`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the next figure, we used the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From the last chapter, we already know the NumPy method, `where`. In the context
    here, `where` is a very convenient parameter that requires a Boolean array to
    specify the additional filling conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Boolean array that selects the regions to fill is given by the condition
    `amod_sin(x)-sin(x) > 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next figure shows the curve with both variants of filling areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67407da9-48ee-4d76-9731-3596707d1634.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: The amplitude-modulated sine function with annotations and filled
    areas (left), and a modified figure with only partially filled areas, by using
    the where parameter (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test these commands yourself, do not forget to remove the complete filling
    before you try out the partial filling, otherwise you will not see any change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Related filling commands are `fill` for filling polygons and `fill_betweenx` for
    filling the areas in horizontal directions.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.5 Defining ticks and tick labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Figures in talks, posters, and publications look much nicer if they are not
    overloaded with unnecessary information. You want to direct the spectator to those
    parts that contain the message. In our example, we clean up the picture by removing
    ticks from the *x *axis and the *y *axis and by introducing problem-related tick
    labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc6a84f4-c69e-4d7d-ad83-e4bf7c748600.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: The completed example of the amplitude-modulated sine function,
    with annotations and filled areas and modified ticks and tick labels'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ticks in *Figure 6.13* were set by the following commands. Note the LaTeX-way
    of setting labels with Greek letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used LaTeX formatting in the strings to represent Greek letters,
    to set formulas correctly, and to use a LaTeX font. It is also a good practice
    to increase the font size so that the resulting figure can be scaled down into
    a text document without affecting the readability of the axes. The final result
    of this guiding example is shown in *Figure 6.13*.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.6 Setting spines makes your plot more instructive – a comprehensive example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spines are the lines with ticks and labels displaying the coordinates in a figure.
    If you do not take a special action, Matplotlib places them as four lines – bottom,
    right, top, and left, forming a frame defined by the axis parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Often, pictures look better when not framed, and frequently there is a more
    instructive place to put the spines. In this section, we demonstrate different
    ways to alter the position of spines.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a guiding example, see *Figure* 6.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edcc56e5-af01-4b23-918a-f5ea1413c186.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: A Matplotlib figure with a non-automatic placement of the spines'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we choose to display only two of the four spines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We deselected the spines at the top and on the right by using the method `set_visible`,
    and positioned the left and bottom spines in data coordinates by using the method
    `set_position`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Spines carry ticks and tick labels. Normally, they are set automatically, but
    often placing them manually is advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we even exploited the possibility of two sets of
    ticks, with different placement parameters. Matplotlib refers to these sets as
    ''*minor*'' and ''*major*''. One of these sets was used for horizontally aligning
    the tick labels on the left side of the *y* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in Figure 6.15.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd735ee6-c02a-436f-b715-02b266371708.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Changing the position of ticks and labels'
  prefs: []
  type: TYPE_NORMAL
- en: This example can be elaborated much more by adding more axes and annotations.
    We refer to *Exercise 7* and *Figure 6.20*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have considered 2D plots. We turn now in the next section to the
    visualization of 3D mathematical objects.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Making 3D plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some useful `matplotlib` toolkits and modules that can be used for
    a variety of special purposes. In this section, we describe a method for producing
    3D plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolkit `mplot3d` provides the 3D plotting of points, lines, contours,
    surfaces, and all other basic components, as well as 3D rotation and scaling.
    A 3D plot is generated by adding the keyword `projection=''3d''` to the axes object,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you need to import the type `axes3D` from `mplot3d`. The resulting
    plot displays the scattered 3D data, which can be seen in *Figure 6.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9827dbe5-eab1-4a5d-b0ba-1a75281e3a42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Plotting 3D data using the mplot3d toolkit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotting surfaces is just as easy. The following example uses the built-in
    function `get_test_data` to create sample data for plotting a surface. Consider
    the following example of a surface plot with transparency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The *alpha* value sets the transparency. The surface plot is shown *Figure 6.17.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf60e0f-5670-40bc-863f-5156dc8d1cb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Example of plotting a surface mesh'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also plot contours in any of the coordinate projections, as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note the commands for setting the axis limits. The standard `matplotlib` command
    for setting the axis limits is `axis([-40, 40, -40, 40])`. This works fine for
    2D plots. However, `axis([-40,40,-40,40,-40,40])` does not work. For 3D plots,
    you need to use the object-oriented version of this command, `ax.set_xlim3d(-40,40)`.
    The same goes for labeling the axis; note the commands for setting the labels.
    For 2D plots, you can do `xlabel(’X axis’)` and `ylabel(’Y axis’)`, but there
    is no command `zlabel`. Instead, in 3D plots, you need to use `ax.set_xlabel(’X
    axis’)` and likewise for the other labels, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting figure from this code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90bbde60-4d49-4366-9efe-c6304645e46c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: A 3D plot with additional contour plots in the three coordinate
    projections'
  prefs: []
  type: TYPE_NORMAL
- en: There are many options for formatting the appearance of the plots, including
    color and the transparency of surfaces. The `mplot3d` documentation website [[23]](12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml),
    has the details.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical objects are sometimes better visualized dynamically by a sequence
    of pictures or even movies. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Making movies from plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have data that evolves, you might want to save it as a movie as well
    as showing it in a figure window, similar to the command `savefig`. One way to
    do this is with the module `visvis`, see [37].
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple example of evolving a circle using an implicit representation.
    Let the circle be represented by the zero level,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53d5e400-f103-4d73-8d95-1d9f771a7e14.png) of a function ![](img/3cad0783-6c67-4da2-8bed-6f3de9a998f8.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, consider the disk ![](img/4f11df5a-0c9f-413a-9548-2dc4796ac29b.png) inside
    the zero set of ![](img/6f82cbed-2f3f-4614-9e23-eca35223238a.png). If the value
    of ![](img/2b7a8922-2cce-4811-8ef9-6fce4d09ab58.png)decreases at a rate ![](img/66d4131e-1c59-423c-8242-933277ff6eba.png),
    then the circle will move outward at the rate ![](img/cc1d309a-3955-4e88-980a-1c4eff3b32a9.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be implemented as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The result is a flash movie (`*.swf` file) of a growing black circle, as shown
    in *Figure 6.19.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0683ec0e-d3db-4236-aac8-c127bc6ebfd6.png) ![](img/af022cbe-d334-4cd1-8b0f-a3179199221e.png) ![](img/cb4d0486-dedf-456f-a4ad-60e895a754cd.png) ![](img/03a96259-8454-4516-85ef-f3a9a87f52ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: An example of evolving a circle'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a list of arrays was used to create the movie. The module `visvis` can
    also save a GIF animation and, on certain platforms, an AVI animation (`*.gif`
    and `*.avi` files), and there is also the possibility of capturing movie frames
    directly from the figure window. These options, however, require some more packages
    to be installed on your system (for example, `PyOpenGL` and `PIL`, the Python
    Imaging Library). See the documentation on the `visvis` web page for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use `savefig` to create images, one for each frame. The
    following code example creates a sequence of 200 picture files, which can then
    be combined into a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These images can then be combined using standard video editing software, for
    example, Mencoder or ImageMagick. This approach has the advantage that you can
    make high-resolution videos by saving high-resolution images.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graphical representation is the most compact form in which to present mathematical
    results or the behavior of an algorithm. This chapter provided you with the basic
    tools for plotting and introduced you to a more sophisticated way to work with
    graphical objects, such as figures, axes, and lines in an object-oriented way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to make plots, not only classical *x/y* plots,
    but also 3D plots and histograms. We gave you an appetizer on making films. You
    also saw how to modify plots, considering them to be graphical objects with related
    methods and attributes that can be set, deleted, or modified.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Write a function that plots an ellipse given its center coordinates
    (*x,y*), the half axis *a,* and *b* rotation angle ![](img/41ba9462-862e-42f9-9719-4723a30ee33d.png).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2:** Write a short program that takes a 2D array, for example, the preceding
    Mandelbrot contour image, and iteratively replace each value by the average of
    its neighbors. Update a contour plot of the array in a figure window to animate
    the evolution of the contours. Explain the behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3:** Consider an ![](img/ab1805a6-ee8e-44b4-a1e3-043c630fc03e.png) matrix
    or image with integer values. The mapping'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fb1559c-a1fb-45f5-b477-e3ba88bd5d7e.png)'
  prefs: []
  type: TYPE_IMG
- en: is an example of a mapping of a toroidal square grid of points onto itself.
    This has the interesting property that it distorts the image by shearing and then
    moving the pieces outside the image back using the modulo function, `mod`. Applied
    iteratively, this results in randomizing the image in a way that eventually returns
    the original. Implement the following sequence,
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58f5266a-a958-4494-a86e-0fec0a7dca8d.png),'
  prefs: []
  type: TYPE_NORMAL
- en: and save out the first ![](img/324ad186-7011-4d4f-8639-4ce386dfdc15.png) steps
    to files or plot them in a figure window.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example image, you can use the classic 512 *×* 512 Lena test image from `scipy.misc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![](img/1c2ca42a-82c1-49a3-a149-d04714f1d85e.png) | ![](img/862a99ab-c967-4f3d-9632-cffe8776bc6c.png)
    | … | ![](img/e4cea046-8a57-4eba-a979-c88ea1971f44.png) | … | ![](img/122156fe-df35-41e5-a1e2-6b26cb575482.png)
    | … | ![](img/3173fa79-21df-4333-8883-f524e70bc76a.png) | ![](img/f7dc2216-0045-488d-a339-020a20ed5fa6.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 |   | 128 |   | 256 |   | 511 | 512 |'
  prefs: []
  type: TYPE_TB
- en: Compute the *x* and *y* mappings and use array indexing (see [Section 5.3](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml): *Array
    indexing*) to copy the pixel values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4:** Reading and plotting on images. SciPy comes with the function `imread` (in
    the `scipy.misc` module) for reading images (see [Section 14.6](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml):
    *Reading and Writing Images*). Write a short program that reads an image from
    file and plots the image contour at a given gray-level value overlaid on the original
    image. You can get a grey-level version of the image by averaging the color channels
    like this: `mean(im,axis=2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5:** Image edges. The zero crossings of the 2D Laplacian are a good indication
    of image edges. Modify the program in the previous exercise to use the `gaussian_laplace` or `laplace` function
    from the `scipy.ndimage` module to compute the 2D Laplacian and overlay the edges
    on top of the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 6:** Reformulate the Mandelbrod fractal example [Section 6.1.4](86c61820-e645-486c-9418-10079ffac7f8.xhtml):
    *Generating images and contours*by using `orgid` instead of `meshgrid`. See also
    the explanation of `ogrid` in [Section 5.5.3](e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml), *Typical
    examples*. What is the difference between `orgid`, `mgrid`, and `meshgrid`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 7:** In *Figure* *6.20*, the use of the arctan function for approximating
    a jump (Heaviside function) is studied. A section of this curve is zoomed in to
    visualize the quality of the approximation. Reproduce this picture by means of
    your own code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9ee6bc2-3edd-4d2b-b244-2d86f5b611aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: Approximation of the Heaviside function (jump function) by arctan
    functions'
  prefs: []
  type: TYPE_NORMAL
