- en: Interacting with the Operating System
  prefs: []
  type: TYPE_NORMAL
- en: This section is an add-on to the introduction to Python. It puts Python into
    the context of the operating system on your computer and shows how Python is used
    in a command window, also called a console. We demonstrate how system commands
    and a Python command interact with each other and how you make a new application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among many other operating systems and various *dialects*, there are three
    main operating systems in use on desktop computers and notebooks: Windows 10,
    macOS, and Linux. In this chapter, we discuss how to use Python within the Linux
    world. All examples are tested in the widely distributed Ubuntu environment. The
    principles presented here apply also to the other big operating systems. The presentation
    is nevertheless restricted to Linux as a completely freely accessible environment.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we assume we have written and tested a Python program and want to run
    it now from a console window directly instead of from a Python shell such as IPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running a Python program in a Linux shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module `sys`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to execute Linux commands from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.1 Running a Python program in a Linux shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you open a terminal window with the terminal app, you obtain a window
    with a command prompt; see *Figure 17.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fe516c1-353a-4ac3-834d-099f2709f28d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: A terminal window in Ubuntu 20.04'
  prefs: []
  type: TYPE_NORMAL
- en: The terminal windows come with a command prompt, often prefixed by the username
    and the computer's name followed by the directory name. This depends on the individual
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the Python commands written in a file named `myprogram.py`, you
    have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing the command `python myprogram.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the command `myprogram.py` directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second variant needs some preparation. First, you have to give permission
    to execute that file, and secondly, you have to tell the system which command
    is needed to execute that file. The permission to execute that file is given by
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`chmod` stands for changing the file mode. The command is followed by the filename
    and finally the desired new modes, here `o+x`.'
  prefs: []
  type: TYPE_NORMAL
- en: The modes that are given in that example stand for "give (`+`) the owner (`o`)
    rights to execute (`x`) that file." We suppose that you are the owner of the file
    and that it is in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have to find the location of the command `python` on our computer.
    This is done by running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you installed Python via Anaconda as described in [Section 1.1](cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml):
    *Installation and configuration instructions*, you will get information about
    the location of the command `python` on your system, for example, `/home/claus/anaconda3/bin/python`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This information has to be written in the first line of a Python script to
    tell the system by which program the text file can be transformed into an executable.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line in Python's view is just a comment and ignored. But Linux takes
    the rest of the first line after the so-called *shebang* combination, `#!`, as
    the command needed to transform the file into an executable. Here, it learns to
    use the command `python` located in the directory `/home/claus/anaconda3/bin/`
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of defining the location of the Python interpreter by an absolute path,
    we can define it also by a logical path, which would make the code more portable.
    You can give it to a colleague on a Linux system without any modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can execute the example code in the console directly; see *Figure 17.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f3e3e9d-b6e2-48b8-bd74-e9e4387fe99f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Executing the example file example.py in a Linux terminal'
  prefs: []
  type: TYPE_NORMAL
- en: We have to prefix the command with `./`, which tells the operating system that
    it should look in the current directory to find that command. If this prefix is
    not present, Linux expects the file `example.py` in one of the directories listed
    in the search path.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show how to provide a Python program with arguments
    given directly from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 17.2 The module sys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module `sys` provides tools to communicate from a Python script with system
    commands. We can provide the Python script as a command directly from the command
    line with arguments and we can output the results to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.1 Command-line arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the use of command-line arguments, we consider the following
    piece of code, which we save in a file called `demo_cli.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After giving execution permissions to the file by `chmod o+x demo_cli.py`,
    we can execute it in the shell with arguments; see *Figure 17.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31c103d2-92cc-40dc-9de2-7f30adc91fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Executing a Python script with three arguments on a terminal command
    line'
  prefs: []
  type: TYPE_NORMAL
- en: The three arguments given in the console are accessible in the Python script
    via the list `sys.argv`. The first element in this list—the element with index
    `0`—is the name of the script. The other elements are the given arguments as strings.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments are given to the call of the Python script. They should not be confounded
    with user input during the execution of a script.
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.2 Input and output streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we used the command `print` to display the generated
    message in the terminal (or even in the Python shell). A priory input to the script
    is obtained via arguments and the variable `sys.argv`. The counterpart to `print`
    is the command `input`, which prompts for data from the terminal (or from the
    Python shell).
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Section 14.1](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml): *File handling*,
    we saw how to provide a script with data and how to output data from a script
    by the use of file objects and related methods. The module `sys` makes it possible
    to treat the keyboard as a file object for input (for example, `readline`, `readlines`)
    and the console as a file object for output (for example, `write`, `writelines`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The information flow is organized in UNIX by three streams:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard input stream: `STDIN`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard output stream: `STDOUT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard error stream: `STDERR`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These streams correspond to file objects that can be accessed in Python by `sys.stdin`,
    `sys.stdout`, and `sys.stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have an example, we consider a little script, `pyinput.py`, which sums up
    some numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement `sys.stdin.readlines()` establishes a generator. The command
    `array` iterates this generator until the user inputs an end-of-input symbol,
    which is `CTRL-D` on Linux systems or `CTRL-Z` on Windows systems. See the screenshot
    in *Figure 17.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2912df2b-e88e-4910-84d6-349e3d736b04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Screenshot of the terminal execution of a script using sys.stdin.'
  prefs: []
  type: TYPE_NORMAL
- en: Note, the given end-of-input symbol CTRL-D is not visible
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard input is expecting a data stream from the keyboard. But the input
    can be redirected from a file instead. This is done by using the redirection symbol
    `<` in Linux. We demonstrate this by using the same script as previously, but
    now a data file, `intest.txt`, provides the script with data; see *Figure 17.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52af1605-6205-48c6-83b6-7a35b7ff0861.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Screenshot to demonstrate the redirection of input (sys.stdin)'
  prefs: []
  type: TYPE_NORMAL
- en: No modification in the script itself is required. It can be used in either way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same holds for outputs. By default the output is displayed in the terminal,
    but also here there is the option to redirect the output to a file. In that case,
    the redirect symbol is `>`; see *Figure 17.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/088761b9-9929-4da9-a8e6-5a48d3981eaa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: Screenshot of a redirected input and redirected output'
  prefs: []
  type: TYPE_NORMAL
- en: Now, a file with the name `result.txt` is created and the output of the script
    is written to it. If there was already a file with this name, its content is overwritten.
    If instead the output should be appended to an already-existing file, the redirection
    symbol `>>` has to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it might sometimes be desired to separate the output from an error
    or warning message. That is the reason why Linux provides two stream channels
    for output, `sys.stdout` and `sys.stderr`. By default, both refer to the same
    place, the terminal. But with the use of redirection symbols, error messages can,
    for example, be written into a file while the main output is displayed on the
    screen or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we modify the example `pyinput.py` to generate an error
    message in case no input was provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical call of this script in a terminal window with redirected input and
    error output is presented in *Figure 17.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5b7acb2-75d1-4fee-a747-a8b659caad9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Screenshot of a terminal window with redirection of stdin and
    stderr'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an empty input file, an error message is written into the file
    `error.txt` while the output is in the terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: Error messages are those from uncaught exceptions, even syntax errors and text
    explicitly written to `sys.stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Table 17.1*, the different redirection situations are summarized:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Python Object** | **Redirect Symbol** | **Alt. Symbol** |'
  prefs: []
  type: TYPE_TB
- en: '| Data input | `sys.stdin` |  < |  |'
  prefs: []
  type: TYPE_TB
- en: '| Data output | `sys.stdout` | > | 1> |'
  prefs: []
  type: TYPE_TB
- en: '| Data output append to file | `sys.stdout` | >> | 1>> |'
  prefs: []
  type: TYPE_TB
- en: '| Error output | `sys.stderr` | 2> |  |'
  prefs: []
  type: TYPE_TB
- en: '| Error output append to file | `sys.stderr` | 2>> |  |'
  prefs: []
  type: TYPE_TB
- en: '| All output | `sys.stdout`, `sys.stderr` | &> |  |'
  prefs: []
  type: TYPE_TB
- en: '| All output append to file | `sys.stdout`, `sys.stderr` | &>> |  |'
  prefs: []
  type: TYPE_TB
- en: 'Table 17.1: Summary of different redirection scenarios'
  prefs: []
  type: TYPE_NORMAL
- en: Building a pipe between a Linux command and a Python script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last section, we saw how to redirect the input and output of Python
    programs to files. The data flow between different Python programs or between
    a Python program and a Linux command goes, in that case, via a file. If the data
    is not used elsewhere or should be saved for later use, this is a tedious process:
    creating, naming, and deleting a file just for directly passing information from
    one piece of code to another. The alternative is to use a Linux **pipe** that
    lets the data flow in a direct stream from one command to another.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a pure Linux example and then apply the pipe construction to
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux command `ifconfig` displays a lot of information about the actual
    network configuration of a Linux computer. Among this information, you find the
    IP number(s), which are the current network addresses in use. To automatically
    find out whether a computer, for example, a notebook, is connected via a certain
    network unit to the home network instead of to a foreign network, you would like
    to scan the output of `ifconfig` for a line containing the identifier for the
    network card, for example, `wlp0s20f3`, and some lines below for a string with
    the network prefix, for example, `192.168`. If this string is found, the output
    should be just the line with this string; that is, a line count would return `1`.
    If the computer is not connected to the home network, the line count returns `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ifconfig` for the entire lengthy network information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep` for finding lines containing a certain pattern. The line and, if required
    by the parameter `-A`, some following lines are displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wc` for doing various countings on a file. The argument `-l` specifies that
    lines should be counted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of these commands is directly piped into the next command. This
    is done by using the pipe symbol `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command line displays just `1` on the screen when executed in the home
    network. All the intermediate output is passed directly to the next command without
    displaying anything and without the use of any files to park temporarily the information
    until the next command reads it. The standard output, `stdout`, of one command
    becomes the standard input, `stdin`, of the next.
  prefs: []
  type: TYPE_NORMAL
- en: This also applies directly to Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue the previous example by demonstrating a Python script in the pipe.
    Here we simply use Python to generate a nice message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can extend the pipe by adding this script; see the screenshot in *Figure
    17.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc1a59e2-9485-4ef0-802a-70c614b04370.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.8: A command chain with five pipes and a Python script'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we executed a chain of Linux programs and a Python script in
    the terminal window. Alternatively, it is possible to let the Python script call
    the UNIX commands. That will be demonstrated in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3 How to execute Linux commands from Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in the last section how to execute a Python command from the Linux terminal.
    In this section, we consider the important case of how to execute Linux commands
    within a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1 The modules subprocess and shlex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To execute system commands within Python, we need to import the module `subprocess`
    first. The high-level tool provided by this module is `run`. With this tool, you
    quickly access Linux commands within Python and can process their output.
  prefs: []
  type: TYPE_NORMAL
- en: The more sophisticated tool is `Popen`, which we will shortly present when explaining
    how to mimic Linux pipes in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete process: subprocess.run'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We demonstrate this tool with the most standard and simple UNIX command, `ls`—the
    command for listing the content of a directory. It comes with various optional
    arguments; for example, `ls -l` displays the list with extended information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this command within a Python script, we use `subprocess.run`. The
    simplest usage is using only one argument, a list with the Linux command split
    into several text strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The module `shlex` provides a special tool for performing this split:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It also respects empty spaces in filenames and does not use those as separators.
  prefs: []
  type: TYPE_NORMAL
- en: The command `run` displays the result of the Linux command and the `subprocess.CompletedProcess`
    object `res`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute UNIX commands in this way is quite useless. Mostly, you want to
    process the output. Therefore, the output has to be made available to the Python
    script. For this, the optional parameter `capture_output` has to be set to `True`.
    By this, the `stdout` and `stderr` streams of the UNIX command become available
    as attributes of the return object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note, the method `decode` is used here to decode a byte string to a standard
    string format.
  prefs: []
  type: TYPE_NORMAL
- en: If the Linux command returns an error, the attribute `res.returncode` gets a
    nonzero value, and `res.stderr` contains the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python way would be that an error is raised instead. This can be achieved
    by setting the optional parameter `check` to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating processes: subprocess.Popen'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What happens when you apply `subprocess.run` on a Linux command that starts
    a process that requires user input to terminate?
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of such a program is `xclock`. It opens a new window displaying
    a clock until the window is closed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the command `subprocess.run` creates a `CompletedProcess` object, the following
    Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'starts a process and waits until it ends, that is, until somebody closes the
    window with the clock; see *Figure 17.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48e32eb1-a323-4ac4-b52e-04911dcedb91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.9: The xclock window'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a difference to `subprocess.Popen`. It creates a _`Popen` object.
    The process itself becomes a Python object. It need not be completed to become
    an accessible Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The process is completed by either a user action on the clock window or by
    explicitly terminating the process with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With `Popen`, we can construct Linux pipes in Python. The following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Corresponds to the UNIX pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It displays all files in a directory last accessed in April.
  prefs: []
  type: TYPE_NORMAL
- en: The module `subprocess` has an object `PIPE` that takes the output of the first
    process `p1`. It is then passed as `stdin` to the command `run`. This command
    then returns a `CompletedProcess` object `cp2` with the attribute `stdout` of
    type `bytes`. Finally, calling the method `decode` allows a nice print of the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the same could be achieved by using two `Popen` processes. The
    second also uses a pipe that can be displayed through the method `communicate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The method `communicate` returns a tuple with the output on `stdout` and `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we demonstrated the interaction of a Python script with system
    commands. Either a Python script can be called in a way as if it would be a system
    command or a Python script can itself create system processes. The chapter is
    based on Linux systems such as Ubuntu and serves only as a demonstration of concepts
    and possibilities. It allows putting scientific computing tasks in an application
    context, where often different software have to be combined. Even hardware components
    might come into play.
  prefs: []
  type: TYPE_NORMAL
