- en: Chapter 1. A Tour of Interactive Computing with IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the IPython notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with exploratory data analysis in IPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the multidimensional array in NumPy for fast array computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an IPython extension with custom magic commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering IPython's configuration system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple kernel for IPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This book targets intermediate to advanced users who are familiar with Python,
    IPython, and scientific computing. In this chapter, we will give a brief recap
    on the fundamental tools we will be using throughout this book: IPython, the notebook,
    pandas, NumPy, and matplotlib.'
  prefs: []
  type: TYPE_NORMAL
- en: In this introduction, we will give a broad overview of IPython and the Python
    scientific stack for high-performance computing and data science.
  prefs: []
  type: TYPE_NORMAL
- en: What is IPython?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IPython** is an open source platform for interactive and parallel computing.
    It offers powerful interactive shells and a browser-based notebook. The **notebook**
    combines code, text, mathematical expressions, inline plots, interactive plots,
    and other rich media within a sharable web document. This platform provides an
    ideal framework for interactive scientific computing and data analysis. IPython
    has become essential to researchers, data scientists, and teachers.'
  prefs: []
  type: TYPE_NORMAL
- en: IPython can be used with the Python programming language, but the platform also
    supports many other languages such as R, Julia, Haskell, or Ruby. The architecture
    of the project is indeed language-agnostic, consisting of messaging protocols
    and interactive clients (including the browser-based notebook). The clients are
    connected to **kernels** that implement the core interactive computing facilities.
    Therefore, the platform can be useful to technical and scientific communities
    that use languages other than Python.
  prefs: []
  type: TYPE_NORMAL
- en: In July 2014, **Project Jupyter** was announced by the IPython developers. This
    project will focus on the language-independent parts of IPython (including the
    notebook architecture), whereas the name IPython will be reserved to the Python
    kernel. In this book, for the sake of simplicity, we will just use the term IPython
    to refer to either the platform or the Python kernel.
  prefs: []
  type: TYPE_NORMAL
- en: A brief historical retrospective on Python as a scientific environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a high-level general-purpose language originally conceived by Guido
    van Rossum in the late 1980s (the name was inspired by the British comedy *Monty
    Python's Flying Circus*). This easy-to-use language is the basis of many scripting
    programs that glue different software components (**glue language**) together.
    In addition, Python comes with an extremely rich standard library (the *batteries
    included* philosophy), which covers string processing, Internet Protocols, operating
    system interfaces, and many other domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the late 1990s, Travis Oliphant and others started to build efficient tools
    to deal with numerical data in Python: Numeric, Numarray, and finally, **NumPy**.
    **SciPy**, which implements many numerical computing algorithms, was also created
    on top of NumPy. In the early 2000s, John Hunter created **matplotlib** to bring
    scientific graphics to Python. At the same time, Fernando Perez created IPython
    to improve interactivity and productivity in Python. All the fundamental tools
    were here to turn Python into a great open source high-performance framework for
    scientific computing and data analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that Python as a platform for scientific computing was built
    slowly, step-by-step, on top of a programming language that was not originally
    designed for this purpose. This fact might explain a few minor inconsistencies
    or weaknesses of the platform, which do not preclude it from being one of the
    most popular open frameworks for scientific computing at this time. (You can also
    refer to [http://cyrille.rossant.net/whats-wrong-with-scientific-python/](http://cyrille.rossant.net/whats-wrong-with-scientific-python/).)
  prefs: []
  type: TYPE_NORMAL
- en: Notable competing open source platforms for numerical computing and data analysis
    include R (which focuses on statistics) and Julia (a young, high-level language
    that focuses on high performance and parallel computing). We will see these two
    languages very briefly in this book, as they can be used from the IPython notebook.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 2000s, Wes McKinney created **pandas** for the manipulation and
    analysis of numerical tables and time series. At the same time, the IPython developers
    started to work on a notebook client inspired by mathematical software such as
    **Sage**, **Maple**, and **Mathematica**. Finally, IPython 0.12, released in December
    2011, introduced the HTML-based notebook that has now gone mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: In 2013, the IPython team received a grant from the Sloan Foundation and a donation
    from Microsoft to support the development of the notebook. IPython 2.0, released
    in early 2014, brought many improvements and long-awaited features.
  prefs: []
  type: TYPE_NORMAL
- en: What's new in IPython 2.0?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a short summary of the changes brought by IPython 2.0 (succeeding v1.1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The notebook comes with a new **modal user interface**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **edit mode**, we can edit a cell by entering code or text.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **command mode**, we can edit the notebook by moving cells around, duplicating
    or deleting them, changing their types, and so on. In this mode, the keyboard
    is mapped to a set of shortcuts that let us perform notebook and cell actions
    efficiently.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notebook widgets** are JavaScript-based GUI widgets that interact dynamically
    with Python objects. This major feature considerably expands the possibilities
    of the IPython notebook. Writing Python code in the notebook is no longer the
    only possible interaction with the kernel. JavaScript widgets and, more generally,
    any JavaScript-based interactive element, can now interact with the kernel in
    real-time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now open notebooks in different subfolders with the dashboard, using
    the same server. A REST API maps local URIs to the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notebooks are now signed to prevent untrusted code from executing when notebooks
    are opened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dashboard now contains a **Running** tab with the list of running kernels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tooltip now appears when pressing *Shift* + *Tab* instead of *Tab*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notebooks can be run in an interactive session via `%run notebook.ipynb`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `%pylab` magic is discouraged in favor of `%matplotlib inline` (to embed
    figures in the notebook) and `import matplotlib.pyplot as plt`. The main reason
    is that `%pylab` clutters the interactive namespace by importing a huge number
    of variables. Also, it might harm the reproducibility and reusability of notebooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2.6 and 3.2 are no longer supported. IPython now requires Python 2.7
    or >= 3.3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roadmap for IPython 3.0 and 4.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython 3.0 and 4.0, planned for late 2014/early 2015, should facilitate the
    use of non-Python kernels and provide multiuser capabilities to the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: The Python webpage at [www.python.org](http://www.python.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python on Wikipedia at [http://en.wikipedia.org/wiki/Python_%28programming_language%29](http://en.wikipedia.org/wiki/Python_%28programming_language%29)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python's standard library present at [https://docs.python.org/2/library/](https://docs.python.org/2/library/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guido van Rossum on Wikipedia at [http://en.wikipedia.org/wiki/Guido_van_Rossum](http://en.wikipedia.org/wiki/Guido_van_Rossum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversation with Guido van Rossum on the birth of Python available at [www.artima.com/intv/pythonP.html](http://www.artima.com/intv/pythonP.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History of scientific Python available at [http://fr.slideshare.net/shoheihido/sci-pyhistory](http://fr.slideshare.net/shoheihido/sci-pyhistory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's new in IPython 2.0 at [http://ipython.org/ipython-doc/2/whatsnew/version2.0.html](http://ipython.org/ipython-doc/2/whatsnew/version2.0.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPython on Wikipedia at [http://en.wikipedia.org/wiki/IPython](http://en.wikipedia.org/wiki/IPython)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History of the IPython notebook at [http://blog.fperez.org/2012/01/ipython-notebook-historical.html](http://blog.fperez.org/2012/01/ipython-notebook-historical.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the IPython notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The notebook is the flagship feature of IPython. This web-based interactive
    environment combines code, rich text, images, videos, animations, mathematics,
    and plots into a single document. This modern tool is an ideal gateway to high-performance
    numerical computing and data science in Python. This entire book has been written
    in the notebook, and the code of every recipe is available as a notebook on the
    book's GitHub repository at [https://github.com/ipython-books/cookbook-code](https://github.com/ipython-books/cookbook-code).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we give an introduction to IPython and its notebook. In *Getting
    ready*, we also give general instructions on installing IPython and the Python
    scientific stack.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need Python, IPython, NumPy, pandas, and matplotlib in this chapter.
    Together with SciPy and SymPy, these libraries form the core of the Python scientific
    stack ([www.scipy.org/about.html](http://www.scipy.org/about.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will find full detailed installation instructions on the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-code](https://github.com/ipython-books/cookbook-code).
  prefs: []
  type: TYPE_NORMAL
- en: We only give a summary of these instructions here; please refer to the link
    above for more up-to-date details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re just getting started with scientific computing in Python, the simplest
    option is to install an all-in-one Python distribution. The most common distributions
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anaconda** (free or commercial license) available at [http://store.continuum.io/cshop/anaconda/](http://store.continuum.io/cshop/anaconda/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canopy** (free or commercial license) available at [www.enthought.com/products/canopy/](http://www.enthought.com/products/canopy/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python(x,y)**, a free distribution only for Windows, available at [https://code.google.com/p/pythonxy/](https://code.google.com/p/pythonxy/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We *highly* recommend Anaconda. These distributions contain everything you need
    to get started. You can also install additional packages as needed. You will find
    all the installation instructions in the links mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout the book, we assume that you have installed Anaconda. We may not
    be able to offer support to readers who use another distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you feel brave, you can install Python, IPython, NumPy, pandas,
    and matplotlib manually. You will find all the instructions on the following websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python** is the programming language underlying the ecosystem. The instructions
    are available at [www.python.org/](http://www.python.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPython** provides tools for interactive computing in Python. The instructions
    for installation are available at [http://ipython.org/install.html](http://ipython.org/install.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NumPy/SciPy** are used for numerical computing in Python. The instructions
    for installation are available at [www.scipy.org/install.html](http://www.scipy.org/install.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pandas** provides data structures and tools for data analysis in Python.
    The instructions for installation are available at [http://pandas.pydata.org/getpandas.html](http://pandas.pydata.org/getpandas.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**matplotlib** helps in creating scientific figures in Python. The instructions
    for installation are available at [http://matplotlib.org/index.html](http://matplotlib.org/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Python 2 or Python 3?**'
  prefs: []
  type: TYPE_NORMAL
- en: Though Python 3 is the latest version at this date, many people are still using
    Python 2\. Python 3 has brought backward-incompatible changes that have slowed
    down its adoption. If you are just getting started with Python for scientific
    computing, you might as well choose Python 3\. In this book, all the code has
    been written for Python 3, but it also works with Python 2\. We will give more
    details about this question in [Chapter 2](ch02.html "Chapter 2. Best Practices
    in Interactive Computing"), *Best Practices in Interactive Computing*.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have installed either an all-in-one Python distribution (again, we
    *highly* recommend Anaconda), or Python and the required packages, you can get
    started! In this book, the IPython notebook is used in almost all recipes. This
    tool gives you access to Python from your web browser. We covered the essentials
    of the notebook in the *Learning IPython for Interactive Computing and Data Visualization*
    book. You can also find more information on IPython's website ([http://ipython.org/ipython-doc/stable/notebook/index.html](http://ipython.org/ipython-doc/stable/notebook/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: To run the IPython notebook server, type `ipython notebook` in a terminal (also
    called the **command prompt**). Your default web browser should open automatically
    and load the `127.0.0.1:8888` address. Then, you can create a new notebook in
    the dashboard or open an existing notebook. By default, the notebook server opens
    in the current directory (the directory you launched the command from). It lists
    all the notebooks present in this directory (files with the `.ipynb` extension).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Windows, you can open a command prompt by pressing the Windows key and *R*,
    then typing `cmd` in the prompt, and finally by pressing *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We assume that a Python distribution is installed with IPython and that we
    are now in an IPython notebook. We type the following command in a cell, and press
    *Shift* + *Enter* to evaluate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Screenshot of the IPython notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A notebook contains a linear succession of **cells** and **output areas**. A
    cell contains Python code, in one or multiple lines. The output of the code is
    shown in the corresponding output area.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we do a simple arithmetic operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of the operation is shown in the output area. Let's be more precise.
    The output area not only displays the text that is printed by any command in the
    cell, but it also displays a text representation of the last returned object.
    Here, the last returned object is the result of `2+2`, that is, `4`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next cell, we can recover the value of the last returned object with
    the `_` (underscore) special variable. In practice, it might be more convenient
    to assign objects to named variables such as in `myresult = 2+2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'IPython not only accepts Python code, but also shell commands. These commands
    are defined by the operating system (mainly Windows, Linux, and Mac OS X). We
    first type `!` in a cell before typing the shell command. Here, assuming a Linux
    or Mac OS X system, we get the list of all the notebooks in the current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On Windows, you should replace `ls` with `dir`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'IPython comes with a library of **magic commands**. These commands are convenient
    shortcuts to common actions. They all start with `%` (the percent character).
    We can get the list of all magic commands with `%lsmagic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cell magics have a `%%` prefix; they concern entire code cells.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, the `%%writefile` cell magic lets us create a text file easily.
    This magic command accepts a filename as an argument. All the remaining lines
    in the cell are directly written to this text file. Here, we create a file `test.txt`
    and write `Hello world!` in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see in the output of `%lsmagic`, there are many magic commands in
    IPython. We can find more information about any command by adding `?` after it.
    For example, to get some help about the `%run` magic command, we type `%run?`
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We covered the basics of IPython and the notebook. Let's now turn to the rich
    display and interactive features of the notebook. Until now, we have only created
    **code cells** (containing code). IPython supports other types of cells. In the
    notebook toolbar, there is a drop-down menu to select the cell's type. The most
    common cell type after the code cell is the **Markdown cell**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Markdown cells contain rich text formatted with **Markdown**, a popular plain
    text-formatting syntax. This format supports normal text, headers, bold, italics,
    hypertext links, images, mathematical equations in **LaTeX** (a typesetting system
    adapted to mathematics), code, HTML elements, and other features, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]python'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print("Hello world!")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running a Markdown cell (by pressing *Shift* + *Enter*, for example) displays
    the output, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/4818OS_01_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Rich text formatting with Markdown in the IPython notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: LaTeX equations are rendered with the `MathJax` library. We can enter inline
    equations with `$...$` and displayed equations with `$$...$$`. We can also use
    environments such as `equation`, `eqnarray`, or `align`. These features are very
    useful to scientific users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By combining code cells and Markdown cells, we can create a standalone interactive
    document that combines computations (code), text, and graphics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IPython also comes with a sophisticated display system that lets us insert rich
    web elements in the notebook. Here, we show how to add HTML, **SVG** (**Scalable
    Vector Graphics**), and even YouTube videos in a notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to import some classes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create an HTML table dynamically with Python, and we display it in the notebook:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: An HTML table in the notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, we can create SVG graphics dynamically:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: SVG in the notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we display a YouTube video by giving its identifier to `YoutubeVideo`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: YouTube in the notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we illustrate the latest interactive features in IPython 2.0+, namely
    JavaScript widgets. Here, we create a drop-down menu to select videos:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: An interactive widget in the notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The interactive features of IPython 2.0 bring a whole new dimension to the notebook,
    and we can expect many developments in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notebooks are saved as structured text files (JSON format), which makes them
    easily shareable. Here are the contents of a simple notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: IPython comes with a special tool, **nbconvert**, which converts notebooks to
    other formats such as HTML and PDF ([http://ipython.org/ipython-doc/stable/notebook/index.html](http://ipython.org/ipython-doc/stable/notebook/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Another online tool, **nbviewer**, allows us to render a publicly available
    notebook directly in the browser and is available at [http://nbviewer.ipython.org](http://nbviewer.ipython.org).
  prefs: []
  type: TYPE_NORMAL
- en: We will cover many of these possibilities in the subsequent chapters, notably
    in [Chapter 3](ch03.html "Chapter 3. Mastering the Notebook"), *Mastering the
    Notebook*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references about the notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: Official page of the notebook available at [http://ipython.org/notebook](http://ipython.org/notebook)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation of the notebook available at [http://ipython.org/ipython-doc/dev/notebook/index.html](http://ipython.org/ipython-doc/dev/notebook/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official notebook examples present at [https://github.com/ipython/ipython/tree/master/examples/Notebook](https://github.com/ipython/ipython/tree/master/examples/Notebook)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-curated gallery of interesting notebooks available at [https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official tutorial on the interactive widgets present at [http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/](http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Getting started with data exploratory analysis in IPython* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with exploratory data analysis in IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will give an introduction to IPython for data analysis. Most
    of the subject has been covered in the *Learning IPython for Interactive Computing
    and Data Visualization* book, but we will review the basics here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will download and analyze a dataset about attendance on Montreal''s bicycle
    tracks. This example is largely inspired by a presentation from Julia Evans (available
    at [http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb](http://nbviewer.ipython.org/github/jvns/talks/blob/master/mtlpy35/pistes-cyclables.ipynb)).
    Specifically, we will introduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation with pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data visualization with matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive widgets with IPython 2.0+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The very first step is to import the scientific packages we will be using in
    this recipe, namely NumPy, pandas, and matplotlib. We also instruct matplotlib
    to render the figures as inline images in the notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a new Python variable called `url` that contains the address
    to a **CSV** (**Comma-separated values**) data file. This standard text-based
    file format is used to store tabular data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'pandas defines a `read_csv()` function that can read any CSV file. Here, we
    pass the URL to the file. pandas will automatically download and parse the file,
    and return a `DataFrame` object. We need to specify a few options to make sure
    that the dates are parsed correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `df` variable contains a `DataFrame` object, a specific pandas data structure
    that contains 2D tabular data. The `head(n)` method displays the first *n* rows
    of this table. In the notebook, pandas displays a `DataFrame` object in an HTML
    table, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: First rows of the DataFrame
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, every row contains the number of bicycles on every track of the city,
    for every day of the year.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can get some summary statistics of the table with the `describe()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Summary statistics of the DataFrame
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s display some figures. We will plot the daily attendance of two tracks.
    First, we select the two columns, `Berri1` and `PierDup`. Then, we call the `plot()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, we move to a slightly more advanced analysis. We will look at the attendance
    of all tracks as a function of the weekday. We can get the weekday easily with
    pandas: the `index` attribute of the `DataFrame` object contains the dates of
    all rows in the table. This index has a few date-related attributes, including
    `weekday`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, we would like to have names (Monday, Tuesday, and so on) instead of
    numbers between 0 and 6\. This can be done easily. First, we create a `days` array
    with all the weekday names. Then, we index it by `df.index.weekday`. This operation
    replaces every integer in the index by the corresponding name in `days`. The first
    element, `Monday`, has the index 0, so every 0 in `df.index.weekday` is replaced
    by `Monday` and so on. We assign this new index to a new column, `Weekday`, in
    `DataFrame`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the attendance as a function of the weekday, we need to group the table
    elements by the weekday. The `groupby()` method lets us do just that. Once grouped,
    we can sum all the rows in every group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Grouped data with pandas
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now display this information in a figure. We first need to reorder the
    table by the weekday using `ix` (indexing operation). Then, we plot the table,
    specifying the line width:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, let''s illustrate the new interactive capabilities of the notebook
    in IPython 2.0\. We will plot a *smoothed* version of the track attendance as
    a function of time (**rolling mean**). The idea is to compute the mean value in
    the neighborhood of any day. The larger the neighborhood, the smoother the curve.
    We will create an interactive slider in the notebook to vary this parameter in
    real time in the plot. All we have to do is add the `@interact` decorator above
    our plotting function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_01_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Interactive widget in the notebook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: pandas is the right tool to load and manipulate a dataset. Other tools and methods
    are generally required for more advanced analyses (signal processing, statistics,
    and mathematical modeling). We will cover these steps in the second part of this
    book, starting with [Chapter 7](ch07.html "Chapter 7. Statistical Data Analysis"),
    *Statistical Data Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more references about data manipulation with pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning IPython for Interactive Computing and Data Visualization*, *Packt
    Publishing*, our previous book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python for Data Analysis*, *O''Reilly Media*, by Wes McKinney, the creator
    of pandas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation of pandas available at [http://pandas.pydata.org/pandas-docs/stable/](http://pandas.pydata.org/pandas-docs/stable/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Introducing the multidimensional array in NumPy for fast array computations*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the multidimensional array in NumPy for fast array computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy is the main foundation of the scientific Python ecosystem. This library
    offers a specific data structure for high-performance numerical computing: the
    **multidimensional array**. The rationale behind NumPy is the following: Python
    being a high-level dynamic language, it is easier to use but slower than a low-level
    language such as C. NumPy implements the multidimensional array structure in C
    and provides a convenient Python interface, thus bringing together high performance
    and ease of use. NumPy is used by many Python libraries. For example, pandas is
    built on top of NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will illustrate the basic concepts of the multidimensional
    array. A more comprehensive coverage of the topic can be found in the *Learning
    IPython for Interactive Computing and Data Visualization* book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the built-in `random` Python module and NumPy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `%precision` magic (defined in IPython) to show only three decimals
    in the Python output. This is just to reduce the number of digits in the output's
    text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We generate two Python lists, `x` and `y`, each one containing 1 million random
    numbers between 0 and 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s compute the element-wise sum of all these numbers: the first element
    of `x` plus the first element of `y`, and so on. We use a `for` loop in a list
    comprehension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'How long does this computation take? IPython defines a handy `%timeit` magic
    command to quickly evaluate the time taken by a single statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will perform the same operation with NumPy. NumPy works on multidimensional
    arrays, so we need to convert our lists to arrays. The `np.array()` function does
    just that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `xa` and `ya` arrays contain the exact same numbers that our original lists,
    `x` and `y`, contained. Those lists were instances of the `list` built-in class,
    while our arrays are instances of the `ndarray` NumPy class. These types are implemented
    very differently in Python and NumPy. In this example, we will see that using
    arrays instead of lists leads to drastic performance improvements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to compute the element-wise sum of these arrays, we don''t need to do
    a `for` loop anymore. In NumPy, adding two arrays means adding the elements of
    the arrays component-by-component. This is the standard mathematical notation
    in linear algebra (operations on vectors and matrices):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that the `z` list and the `za` array contain the same elements (the sum
    of the numbers in `x` and `y`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s compare the performance of this NumPy operation with the native Python
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We observe that this operation is more than one order of magnitude faster in
    NumPy than in pure Python!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will compute something else: the sum of all elements in `x` or `xa`.
    Although this is not an element-wise operation, NumPy is still highly efficient
    here. The pure Python version uses the built-in `sum()` function on an iterable.
    The NumPy version uses the `np.sum()` function on a NumPy array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also observe an impressive speedup here also.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let''s perform one last operation: computing the arithmetic distance
    between any pair of numbers in our two lists (we only consider the first 1000
    elements to keep computing times reasonable). First, we implement this in pure
    Python with two nested `for` loops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we use a NumPy implementation, bringing out two slightly more advanced
    notions. First, we consider a **two-dimensional array** (or matrix). This is how
    we deal with the two indices, *i* and *j*. Second, we use **broadcasting** to
    perform an operation between a 2D array and 1D array. We will give more details
    in the *How it works...* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here again, we observe significant speedups.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A NumPy array is a homogeneous block of data organized in a multidimensional
    finite grid. All elements of the array share the same **data type**, also called
    **dtype** (integer, floating-point number, and so on). The **shape** of the array
    is an *n*-tuple that gives the size of each axis.
  prefs: []
  type: TYPE_NORMAL
- en: A 1D array is a **vector**; its shape is just the number of components.
  prefs: []
  type: TYPE_NORMAL
- en: A 2D array is a **matrix**; its shape is *(number of rows, number of columns)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the structure of a 3D (3, 4, 2) array that
    contains 24 elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A NumPy array
  prefs: []
  type: TYPE_NORMAL
- en: The slicing syntax in Python nicely translates to array indexing in NumPy. Also,
    we can add an extra dimension to an existing array, using `None` or `np.newaxis`
    in the index. We used this trick in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Element-wise arithmetic operations can be performed on NumPy arrays that have
    the *same shape*. However, broadcasting relaxes this condition by allowing operations
    on arrays with different shapes in certain conditions. Notably, when one array
    has fewer dimensions than the other, it can be virtually stretched to match the
    other array's dimension. This is how we computed the pairwise distance between
    any pair of elements in `xa` and `ya`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can array operations be so much faster than Python loops? There are several
    reasons, and we will review them in detail in [Chapter 4](ch04.html "Chapter 4. Profiling
    and Optimization"), *Profiling and Optimization*. We can already say here that:'
  prefs: []
  type: TYPE_NORMAL
- en: In NumPy, array operations are implemented internally with C loops rather than
    Python loops. Python is typically slower than C because of its interpreted and
    dynamically-typed nature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data in a NumPy array is stored in a **contiguous** block of memory in RAM.
    This property leads to more efficient use of CPU cycles and cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's obviously much more to say about this subject. Our previous book, *Learning
    IPython for Interactive Computing and Data Visualization*, contains more details
    about basic array operations. We will use the array data structure routinely throughout
    this book. Notably, [Chapter 4](ch04.html "Chapter 4. Profiling and Optimization"),
    *Profiling and Optimization*, covers advanced techniques of using NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more references:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the `ndarray` on NumPy's documentation available at [http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tutorial on the NumPy array available at [http://wiki.scipy.org/Tentative_NumPy_Tutorial](http://wiki.scipy.org/Tentative_NumPy_Tutorial)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NumPy array in the SciPy lectures notes present at [http://scipy-lectures.github.io/intro/numpy/array_object.html](http://scipy-lectures.github.io/intro/numpy/array_object.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Getting started with exploratory data analysis in IPython* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding the internals of NumPy to avoid unnecessary array copying*
    recipe in [Chapter 4](ch04.html "Chapter 4. Profiling and Optimization"), *Profiling
    and Optimization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an IPython extension with custom magic commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although IPython comes with a wide variety of magic commands, there are cases
    where we need to implement custom functionality in a new magic command. In this
    recipe, we will show how to create line and magic cells, and how to integrate
    them in an IPython extension.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import a few functions from the IPython magic system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Defining a new line magic is particularly simple. First, we create a function
    that accepts the contents of the line (except the initial `%`-prefixed name).
    The name of this function is the name of the magic. Then, we decorate this function
    with `@register_line_magic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's create a slightly more useful `%%csv` cell magic that parses a CSV string
    and returns a pandas `DataFrame` object. This time, the arguments of the function
    are the characters that follow `%%csv` in the first line and the contents of the
    cell (from the cell's second line to the last).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can access the returned object with `_`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method we described is useful in an interactive session. If we want to
    use the same magic in multiple notebooks or if we want to distribute it, then
    we need to create an **IPython extension** that implements our custom magic command.
    The first step is to create a Python script (`csvmagic.py` here) that implements
    the magic. We also need to define a special function `load_ipython_extension(ipython)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the extension module is created, we need to import it into the IPython
    session. We can do this with the `%load_ext` magic command. Here, loading our
    extension immediately registers our `%%csv` magic function in the interactive
    shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IPython extension is a Python module that implements the top-level `load_ipython_extension(ipython)`
    function. When the `%load_ext` magic command is called, the module is loaded and
    the `load_ipython_extension(ipython)` function is called. This function is passed
    the current `InteractiveShell` instance as an argument. This object implements
    several methods we can use to interact with the current IPython session.
  prefs: []
  type: TYPE_NORMAL
- en: The InteractiveShell class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interactive IPython session is represented by a (singleton) instance of the
    `InteractiveShell` class. This object handles the history, interactive namespace,
    and most features available in the session.
  prefs: []
  type: TYPE_NORMAL
- en: Within an interactive shell, we can get the current `InteractiveShell` instance
    with the `get_ipython()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of all methods of `InteractiveShell` can be found in the reference
    API (see link at the end of this recipe). The following are the most important
    attributes and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user_ns`: The **user namespace** (a dictionary).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push()`: **Push** (or inject) Python variables in the interactive namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ev()`: **Evaluate** a Python expression in the user namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ex()`: **Execute** a Python statement in the user namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run_cell()`: **Run a** **cell** (given as a string), possibly containing IPython
    magic commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`safe_execfile()`: **Safely execute** a Python script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system()`: Execute a **system** command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write()`: **Write** a string to the default output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_err()`: **Write** a string to the default **error** output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`register_magic_function()`: **Register** a standalone function as an IPython
    **magic function**. We used this method in this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading an extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python extension module needs to be importable when using `%load_ext`. Here,
    our module is in the current directory. In other situations, it has to be in the
    Python path. It can also be stored in `~\.ipython\extensions`, which is automatically
    put in the Python path.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that our magic is automatically defined in our IPython profile, we
    can instruct IPython to load our extension automatically when a new interactive
    shell is launched. To do this, we have to open the `~/.ipython/profile_default/ipython_config.py`
    file and put `'csvmagic'` in the `c.InteractiveShellApp.extensions` list. The
    `csvmagic` module needs to be importable. It is common to create a **Python package**
    that implements an IPython extension, which itself defines custom magic commands.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many third-party extensions and magic commands exist, notably `cythonmagic`,
    `octavemagic`, and `rmagic`, which all allow us to insert non-Python code in a
    cell. For example, with `cythonmagic`, we can create a Cython function in a cell
    and import it in the rest of the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation of IPython's extension system available at [http://ipython.org/ipython-doc/dev/config/extensions/](http://ipython.org/ipython-doc/dev/config/extensions/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining new magic commands explained at [http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics](http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index of IPython extensions at [https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API reference of `InteractiveShell` available at [http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.interactiveshell.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Mastering IPython's configuration system* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering IPython's configuration system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPython implements a truly powerful configuration system. This system is used
    throughout the project, but it can also be used by IPython extensions. It could
    even be used in entirely new applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we show how to use this system to write a configurable IPython
    extension. We will create a simple magic command that displays random numbers.
    This magic command comes with configurable parameters that can be set by the user
    in their IPython configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create an IPython extension in a `random_magics.py` file. Let's start by
    importing a few objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to put the code in steps 1-5 in an external text file named `random_magics.py`,
    rather than in the notebook's input!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a `RandomMagics` class deriving from `Magics`. This class contains
    a few configurable parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to call the parent''s constructor. Then, we initialize a random number
    generator with a seed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a `%random` line magic that displays a random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we register that magic when the extension is loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s test our extension in the notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our magic command has a few configurable parameters. These variables are meant
    to be configured by the user in the IPython configuration file or in the console
    when starting IPython. To configure these variables in the terminal, we can type
    the following command in a system shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this session, we get the following behavior:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To configure the variables in the IPython configuration file, we have to open
    the `~/.ipython/profile_default/ipython_config.py` file and add the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After launching IPython, we get the following behavior:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IPython''s configuration system defines several concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: A **user profile** is a set of parameters, logs, and command history, which
    are specific to a user. A user can have different profiles when working on different
    projects. A `xxx` profile is stored in `~/.ipython/profile_xxx`, where `~` is
    the user's home directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux, the path is generally `/home/yourname/.ipython/profile_xxx`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, the path is generally `C:\Users\YourName\.ipython\profile_xxx`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **configuration object**, or `Config`, is a special Python dictionary that
    contains key-value pairs. The `Config` class derives from Python's `dict`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HasTraits` class is a class that can have special `trait` attributes. **Traits**
    are sophisticated Python attributes that have a specific type and a default value.
    Additionally, when a trait's value changes, a callback function is automatically
    and transparently called. This mechanism allows a class to be notified whenever
    a trait attribute is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Configurable` class is the base class of all classes that want to benefit
    from the configuration system. A `Configurable` class can have configurable attributes.
    These attributes have default values specified directly in the class definition.
    The main feature of `Configurable` classes is that the default values of the traits
    can be overridden by configuration files on a class-by-class basis. Then, instances
    of `Configurables` can change these values at leisure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **configuration file** is a Python or JSON file that contains the parameters
    of `Configurable` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Configurable` classes and configuration files support an inheritance model.
    A `Configurable` class can derive from another `Configurable` class and override
    its parameters. Similarly, a configuration file can be included in another file.
  prefs: []
  type: TYPE_NORMAL
- en: Configurables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a simple example of a `Configurable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, an instance of the `MyConfigurable` class will have its `myvariable`
    attribute equal to `100`. Now, let''s assume that our IPython configuration file
    contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Then, the `myvariable` attribute will default to `123`. Instances are free to
    change this default value after they are instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_config()` function is a special function that is available in any configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `Configurable` parameters can be specified in the command-line
    interface, as we saw in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration system is used by all IPython applications (notably `console`,
    `qtconsole`, and `notebook`). These applications have many configurable attributes.
    You will find the list of these attributes in your profile's configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Magics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Magics** class derives from `Configurable` and can contain configurable
    attributes. Moreover, magic commands can be defined by methods decorated by `@line_magic`
    or `@cell_magic`. The advantage of defining class magics instead of function magics
    (as in the previous recipe) is that we can keep a state between multiple magic
    calls (because we are using a class instead of a function).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and customizing IPython at [http://ipython.org/ipython-doc/dev/config/index.html](http://ipython.org/ipython-doc/dev/config/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed overview of the configuration system at [http://ipython.org/ipython-doc/dev/development/config.html](http://ipython.org/ipython-doc/dev/development/config.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining custom magics available at [http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics](http://ipython.org/ipython-doc/dev/interactive/reference.html#defining-magics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The traitlets module available at [http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.utils.traitlets.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating an IPython extension with custom magic commands* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple kernel for IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture that has been developed for IPython and that will be the core
    of Project Jupyter is becoming increasingly language independent. The decoupling
    between the client and kernel makes it possible to write kernels in any language.
    The client communicates with the kernel via socket-based messaging protocols.
    Thus, a kernel can be written in any language that supports sockets.
  prefs: []
  type: TYPE_NORMAL
- en: However, the messaging protocols are complex. Writing a new kernel from scratch
    is not straightforward. Fortunately, IPython 3.0 brings a lightweight interface
    for kernel languages that can be wrapped in Python.
  prefs: []
  type: TYPE_NORMAL
- en: This interface can also be used to create an entirely customized experience
    in the IPython notebook (or another client application such as the console). Normally,
    Python code has to be written in every code cell; however, we can write a kernel
    for any domain-specific language. We just have to write a Python function that
    accepts a code string as input (the contents of the code cell), and sends text
    or rich data as output. We can also easily implement code completion and code
    inspection.
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine many interesting interactive applications that go far beyond
    the original use cases of IPython. These applications might be particularly useful
    for nonprogrammer end users such as high school students.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a simple graphing calculator. The calculator
    is transparently backed by NumPy and matplotlib. We just have to write functions
    as `y = f(x)` in a code cell to get a graph of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe has been tested on the development version of IPython 3.0\. It should
    work on the final version of IPython 3.0 with no or minimal changes. We give all
    references about wrapper kernels and messaging protocols at the end of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Warning: This recipe works only on IPython >= 3.0!'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `plotkernel.py` file. This file will contain the implementation
    of our custom kernel. Let''s import a few modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to put the code in steps 1-6 in an external text file named `plotkernel.py`,
    rather than in the notebook's input!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We write a function that returns a base64-encoded PNG representation of a matplotlib
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we write a function that parses a code string, which has the form `y =
    f(x)`, and returns a NumPy function. Here, `f` is an arbitrary Python expression
    that can use NumPy functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our new wrapper kernel, we create a class that derives from `Kernel`. There
    are a few metadata fields we need to provide:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this class, we implement a `do_execute()` method that takes code as input
    and sends responses to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the following lines at the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our kernel is ready! The next step is to indicate to IPython that this new
    kernel is available. To do this, we need to create a **kernel spec** `kernel.json`
    file and put it in `~/.ipython/kernels/plot/`. This file contains the following
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `plotkernel.py` file needs to be importable by Python. For example, we could
    simply put it in the current directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In IPython 3.0, we can launch a notebook with this kernel from the IPython notebook
    dashboard. There is a drop-down menu at the top right of the notebook interface
    that contains the list of available kernels. Select the Plot kernel to use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in a new notebook backed by our custom plot kernel, we can simply write
    the mathematical equation, `y = f(x)`. The corresponding graph appears in the
    output area. Here is an example:![How to do it...](img/4818OS_01_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example of our custom plot wrapper kernel
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will give more details about the architecture of IPython and the notebook
    in [Chapter 3](ch03.html "Chapter 3. Mastering the Notebook"), *Mastering the
    Notebook*. We will just give a summary here. Note that these details might change
    in future versions of IPython.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel and client live in different processes. They communicate via messaging
    protocols implemented on top of network sockets. Currently, these messages are
    encoded in JSON, a structured, text-based document format.
  prefs: []
  type: TYPE_NORMAL
- en: Our kernel receives code from the client (the notebook, for example). The `do_execute()`function
    is called whenever the user sends a cell's code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel can send messages back to the client with the `self.send_response()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the socket, here, the **IOPub** socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is the **message type**, here, `stream`, to send back standard
    output or a standard error, or `display_data` to send back rich data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third argument is the contents of the message, represented as a Python dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data can contain multiple MIME representations: text, HTML, SVG, images,
    and others. It is up to the client to handle these data types. In particular,
    the HTML notebook client knows how to represent all these types in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: The function returns execution results in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: In this toy example, we always return an `ok` status. In production code, it
    would be a good idea to detect errors (syntax errors in the function definitions,
    for example) and return an error status instead.
  prefs: []
  type: TYPE_NORMAL
- en: All messaging protocol details can be found at the links given at the end of
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wrapper kernels can implement optional methods, notably for code completion
    and code inspection. For example, to implement code completion, we need to write
    the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This method is called whenever the user requests code completion when the cursor
    is at a given `cursor_pos` location in the code cell. In the method's response,
    the `cursor_start` and `cursor_end` fields represent the interval that code completion
    should overwrite in the output. The `matches` field contains the list of suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These details might have changed by the time IPython 3.0 is released. You will
    find all up-to-date information in the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper kernels, available at [http://ipython.org/ipython-doc/dev/development/wrapperkernels.html](http://ipython.org/ipython-doc/dev/development/wrapperkernels.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging protocols, available at [http://ipython.org/ipython-doc/dev/development/messaging.html](http://ipython.org/ipython-doc/dev/development/messaging.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KernelBase API reference, available at [http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html](http://ipython.org/ipython-doc/dev/api/generated/IPython.kernel.zmq.kernelbase.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
