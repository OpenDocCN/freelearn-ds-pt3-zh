- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Geometric Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes solutions to several problems concerning two-dimensional
    geometry. Geometry is a branch of mathematics concerned with the characteristics
    of points, lines, and other figures (shapes), the interaction between these figures,
    and the transformation of these figures. In this chapter, we’ll focus on the characteristics
    of two-dimensional figures and the interactions between these objects.
  prefs: []
  type: TYPE_NORMAL
- en: There are several problems we must overcome when working with geometric objects
    in Python. The biggest hurdle is the problem of representation. Most geometric
    objects occupy a region on the two-dimensional plane and, as such, it is impossible
    to store every point that lies within the region. Instead, we have to find a more
    compact way to represent the region that can be stored as a relatively small number
    of points or other attributes. For example, we might store a selection of points
    along the boundary of an object that we can reconstruct the boundary and the object
    itself from. We also have to reformulate the problems into questions that can
    be answered using representative data.
  prefs: []
  type: TYPE_NORMAL
- en: The second biggest problem is converting purely geometric questions into a form
    that can be understood and solved using software. This can be relatively simple
    – for example, finding the point at which two straight lines intersect is a matter
    of solving a matrix equation – or it can be extremely complex, depending on the
    type of question being asked. A common technique that’s used to solve these problems
    is to represent the figure in question using more simple objects and solve the
    (hopefully) easier problem using each of the simple objects. This should then
    give us an idea of the solution to the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by showing you how to visualize two-dimensional shapes using patches,
    and then learn how to determine whether a point is contained within another figure.
    Then, we’ll move on and look at edge detection, triangulation, and finding convex
    hulls. We’ll conclude this chapter by constructing Bezier curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing two-dimensional geometric shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding interior points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding edges in an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triangulating planar figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing convex hulls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing Bezier curves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we will need the NumPy package and the Matplotlib package,
    as usual. We will also need the Shapely package and the `scikit-image` package,
    which can be installed using your favorite package manager, such as `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code for this chapter can be found in the `Chapter 08` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2008).
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing two-dimensional geometric shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter is on two-dimensional geometry, so our first task
    is to learn how to visualize two-dimensional geometric figures. Some of the techniques
    and tools mentioned here might apply to three-dimensional geometric figures, but
    generally, this will require more specialized packages and tools. The first method
    for plotting a region on the plane might be to pick a selection of points around
    the boundary and plot these with the usual tools. However, this is generally going
    to be inefficient. Instead, we’re going to implement Matplotlib patches that make
    use of efficient representations of these figures – in this recipe, the center
    and radius of a circle (disk) – that Matplotlib can fill efficiently on a plot.
  prefs: []
  type: TYPE_NORMAL
- en: A **geometric figure**, at least in the context of this book, is any point,
    line, curve, or closed region (including the boundary) whose boundary is a collection
    of lines and curves. Simple examples include points and lines (obviously), rectangles,
    polygons, and circles.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to visualize geometric figures using Matplotlib
    patches.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need the NumPy package imported as `np`, and the Matplotlib
    `pyplot` module imported as `plt`. We also need to import the `Circle` class from
    the Matplotlib `patches` module and the `PatchCollection` class from the Matplotlib
    `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will also need the `swisscheese-grid-10411.csv` data file from the code repository
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you to visualize a two-dimensional geometric figure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the data from the `swisscheese-grid-10411.csv` file from this
    book’s code repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new patch object that represents a region on a plot. This is going
    to be a circle (disk) with the center at the origin and a radius of `1`. We create
    a new set of axes and add this patch to them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a `PatchCollection` object from the data we loaded in *step
    1*, which contains centers and radii for a number of other circles. We then add
    this `PatchCollection` to the axes we created in *step 2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we set the ![](img/Formula_08_001.png)- and ![](img/Formula_08_002.png)-axis
    ranges so that the whole image is displayed and then turn the axes off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting image is of a *Swiss cheese*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Plot of a Swiss cheese'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Plot of a Swiss cheese
  prefs: []
  type: TYPE_NORMAL
- en: You can see in *Figure 8**.1* that most of the original disk (shaded black)
    has been covered by subsequent disks (shaded white).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Key to this recipe are the `Circle` and `PatchCollection` objects, which represent
    the regions of the plot area on Matplotlib axes. In this case, we are creating
    one large circular patch, centered at the origin and with a radius of `1`, that
    has a black face color and uses `zorder=0` to place it behind other patches. This
    patch is added to the `Axes` object using the `add_patch` method.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create an object that will render the circles represented
    by the data that we loaded from the CSV file in *step 1*. This data consisted
    of ![](img/Formula_08_003.png), ![](img/Formula_08_004.png), and ![](img/Formula_08_005.png)
    values for the center ![](img/Formula_08_006.png) and the radius, ![](img/Formula_08_007.png),
    of the individual circles (10,411 in total). The `PatchCollection` object combines
    a sequence of patches into a single object that can be added to an `Axes` object.
    Here, we add one `Circle` for each row in our data, which is then added to the
    `Axes` object using the `add_collection` method. Notice that we have applied the
    face color to the whole collection, rather than to each individual `Circle` constituent.
    We set the face color to white (using the `facecolor="w"` argument), the edge
    color to black (using `ec="k"`), the line width (of the edge lines) to 0.2 (using
    `linewidth=0.2`), and the edge style to a continuous line. All of this, when put
    together, results in our image.
  prefs: []
  type: TYPE_NORMAL
- en: The image that we have created here is called a *Swiss cheese*. It was first
    used in rational approximation theory in 1938 by Alice Roth; it was subsequently
    rediscovered, and similar constructions have been used many times since. We used
    this example because it consists of one large individual part, plus a large collection
    of smaller individual parts. Roth’s Swiss cheese is an example of a set in the
    plane that has a positive area but no topological interior. This means that we
    cannot find any disk of positive radius that is wholly contained within the set
    (it is amazing that such a set can even exist!). More importantly, there are continuous
    functions defined on this Swiss cheese that cannot be uniformly approximated by
    rational functions. This property has made similar constructions useful in the
    theory of *uniform algebras*.
  prefs: []
  type: TYPE_NORMAL
- en: The `Circle` class is a subclass of the more general `Patch` class. There are
    numerous other `Patch` classes that represent different planar figures, such as
    `Polygon` and `PathPatch`, which represent the region bounded by a path (curve
    or collection of curves). These can be used to generate complex patches that can
    be rendered in a Matplotlib figure. Collections can be used to apply settings
    to a number of patch objects simultaneously, which can be especially useful if,
    as in this recipe, you have a large number of objects that will all be rendered
    in the same style.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different patch types available in Matplotlib. In this recipe,
    we used the `Circle` patch class, which represents a circular region on the axes.
    There is also the `Polygon` patch class, which represents a polygon (regular or
    otherwise). There are also `PatchPath` objects, which are regions that are surrounded
    by a curve that does not necessarily consist of straight-line segments. This is
    similar to the way a shaded region can be constructed in many vector graphics
    software packages.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the single patch types in Matplotlib, there are a number of collection
    types that gather a number of patches together to be used as a single object.
    In this recipe, we used the `PatchCollection` class to gather a large number of
    `Circle` patches. There are more specialized patch collections that can be used
    to generate these internal patches automatically, rather than us generating them
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A more detailed history of Swiss cheeses in mathematics can be found in the
    following biographical article: Daepp, U., Gauthier, P., Gorkin, P., and Schmieder,
    G., 2005\. *Alice in Switzerland: The life and mathematics of Alice Roth*. *The
    Mathematical Intelligencer*, 27(1), pp. 41-54.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding interior points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with working with two-dimensional figures in a programming environment
    is that you can’t possibly store all the points that lie within the figure. Instead,
    we usually store far fewer points that represent the figure in some way. In most
    cases, this will be a number of points (connected by lines) that describe the
    boundary of the figure. This is efficient in terms of memory and makes it easy
    to visualize them on screen using Matplotlib patches, for example. However, this
    approach makes it more difficult to determine whether a point or another figure
    lies within a given figure. This is a crucial question in many geometric problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to represent geometric figures and determine
    whether a point lies within a figure or not.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need to import the `matplotlib` package (as a whole)
    as `mpl` and the `pyplot` module as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to import the `Point` and `Polygon` objects from the `geometry`
    module of the Shapely package. The Shapely package contains many routines and
    objects for representing, manipulating, and analyzing two-dimensional geometric
    figures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These two classes will be used to represent our two-dimensional geometric figures.
    Let’s see how to use these classes to see whether a polygon contains a point or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you how to create a Shapely representation of a polygon
    and then test whether a point lies within this polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a sample polygon to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we plot the polygon onto a new figure. First, we need to convert the
    polygon into a Matplotlib `Polygon` patch that can be added to the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to create two test points, one of which will be inside the polygon
    and one of which will be outside the polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We plot and annotate these two points on top of the polygon to show their positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we test where each point lies within the polygon using the `contains`
    method, and then print the result to the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results show that the first point, `p1`, is contained in the polygon, while
    the second point, `p2`, is not. This can also be seen in the following figure,
    which clearly shows that one point is contained within the shaded polygon, while
    the other point is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Points inside and outside a polygonal region'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Points inside and outside a polygonal region
  prefs: []
  type: TYPE_NORMAL
- en: Once we plot the points and the polygon it is easy (for us) to see that `contains`
    method on the `polygon` object correctly classifies the points too.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Shapely `Polygon` class is a representation of a polygon that stores its
    vertices as points. The region enclosed by the outer boundary – the five straight
    lines between the stored vertices – is obvious to us and easily identified by
    the eye, but the notion of being *inside* the boundary is difficult to define
    in a way that can be easily understood by a computer. It is not even straightforward
    to give a formal mathematical definition of what it means to lie *within* a given
    curve.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways to determine whether a point lies within a simple closed
    curve – that is, a curve that starts and ends at the same place that does not
    contain any self-intersections. The first uses a mathematical concept called the
    `contains` method of a polygon does (under the hood, Shapely uses the GEOS library
    to perform this calculation).
  prefs: []
  type: TYPE_NORMAL
- en: The Shapely `Polygon` class can be used to compute many quantities associated
    with these planar figures, including perimeter length and area. The `contains`
    method is used to determine whether a point, or a collection of points, lies within
    the polygon represented by the object (there are some limitations regarding the
    kinds of polygons that can be represented by this class). In fact, you can use
    the same method to determine whether one polygon is contained within another since,
    as we have seen in this recipe, a polygon is represented by a simple collection
    of points.
  prefs: []
  type: TYPE_NORMAL
- en: Finding edges in an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding edges in images is a good way of reducing a complex image that contains
    a lot of noise and distractions to a very simple image containing the most prominent
    outlines. This can be useful as our first step of the analysis process, such as
    in image classification, or as the process of importing line outlines into computer
    graphics software packages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `scikit-image` package and the
    Canny algorithm to find the edges in a complex image.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need to import the Matplotlib `pyplot` module as `plt`,
    the `imread` routine from the `skimage.io` module, and the `canny` routine from
    the `skimage.feature` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `canny` routine implements the edge detection algorithm. Let’s see how to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to use the `scikit-image` package to find edges
    in an image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the image data from the source file. This can be found in the GitHub repository
    for this chapter. Crucially, we pass in `as_gray=True` to load the image in grayscale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the original image, for reference. The set itself is shown
    by the white region and, as you can see, the boundary, indicated by the darker
    shades, is very complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Plot of the Mandelbrot set generated using Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Plot of the Mandelbrot set generated using Python
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `canny` routine, which needs to be imported from the `features`
    module of the `scikit-image` package. The `sigma` value is set to `0.5` for this
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the `edges` image to a new figure with a grayscale (reversed)
    color map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The edges that have been detected can be seen in the following image. The edge-finding
    algorithm has identified most of the visible details of the boundary of the Mandelbrot
    set, although it is not perfect (this is an estimate, after all):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The edges of the Mandelbrot set found using the scikit-image
    package’s Canny edge detection algorithm](img/B19085_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The edges of the Mandelbrot set found using the scikit-image package’s
    Canny edge detection algorithm
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the edge detection has identified a good amount of the complexity
    of the edge of the Mandelbrot set. Of course, the boundary of the *true* Mandelbrot
    set is a fractal and has infinite complexity.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `scikit-image` package provides various utilities and types for manipulating
    and analyzing data derived from images. As the name suggests, the `canny` routine
    uses the Canny edge detection algorithm to find edges in an image. This algorithm
    uses the intensity gradients in the image to detect edges, where the gradient
    is larger. It also performs some filtering to reduce the noise in the edges it
    finds.
  prefs: []
  type: TYPE_NORMAL
- en: The `sigma` keyword value we provided is the standard deviation of the Gaussian
    smoothing that’s applied to the image prior to calculating the gradients for edge
    detection. This helps us remove some of the noise from the image. The value we
    set (`0.5`) is smaller than the default (`1`), but it does give us a better resolution
    in this case. A large value would obscure some of the finer details in the boundary
    of the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: Triangulating planar figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 3*](B19085_03.xhtml#_idTextAnchor078), *Calculus and
    Differential Equations*, we often need to break down a continuous region into
    smaller, simpler regions. In earlier recipes, we reduced an interval of real numbers
    into a collection of smaller intervals, each with a small length. This process
    is usually called **discretization**. In this chapter, we are working with two-dimensional
    figures, so we need a two-dimensional version of this process. For this, we’ll
    break a two-dimensional figure (in this recipe, a polygon) into a collection of
    smaller and simpler polygons. The simplest of all polygons are triangles, so this
    is a good place to start for two-dimensional discretization. The process of finding
    a collection of triangles that *tiles* a geometric figure is called **triangulation**.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to triangulate a polygon (with a hole) using
    the Shapely package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the following items from the Shapely package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how to use the `triangulate` routine to triangulate a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show you how to triangulate a polygon with a hole using
    the Shapely package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a `Polygon` object that represents the figure that
    we wish to triangulate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should plot the figure so that we can understand the region that we
    will be working within:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This polygon can be seen in the following image. As we can see, the figure
    has a *hole* in it that must be carefully considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Sample polygon but with a hole'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Sample polygon but with a hole
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `triangulate` routine to generate a triangulation of the polygon.
    This triangulation includes external edges, which is something we don’t want in
    this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove the triangles that lie outside the original polygon, we need to use
    the built-in `filter` routine, along with the `contains` method (seen earlier
    in this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To plot the triangles on top of the original polygon, we need to convert the
    Shapely triangles into Matplotlib `Patch` objects, which we store in a `PatchCollection`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the collection of triangular patches to the figure we created
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The triangulation that’s been plotted on top of the original polygon can be
    seen in the following figure. Here, we can see that every vertex has been connected
    to two others to form a system of triangles that covers the entire original polygon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Triangulation of a sample polygon with a hole'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Triangulation of a sample polygon with a hole
  prefs: []
  type: TYPE_NORMAL
- en: The internal lines between the vertices of the original polygon in *Figure 8**.6*
    divide the polygon into 15 triangles.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `triangulate` routine uses a technique called **Delaunay triangulation**
    to connect a collection of points to a system of triangles. In this case, the
    collection of points is the vertices of the polygon. The Delaunay method finds
    these triangles in such a way that none of the points are contained within the
    circumcircle of any of the triangles. This is a technical condition of the method,
    but it means that the triangles are chosen efficiently, in the sense that it avoids
    very long, thin triangles. The resulting triangulation makes use of the edges
    that are present in the original polygon and also connects some of the external
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove the triangles that lie outside of the original polygon, we
    use the built-in `filter` routine, which creates a new iterable by removing the
    items that the criterion function falls under. This is used in conjunction with
    the `contains` method on Shapely `Polygon` objects to determine whether each triangle
    lies within the original figure. As we mentioned previously, we need to convert
    these Shapely items into Matplotlib patches before they can be added to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Triangulations are usually used to reduce a complex geometric figure into a
    collection of triangles, which are much simpler for computational tasks. However,
    they do have other uses. One particularly interesting application of triangulations
    is to solve the *art gallery problem*. This problem concerns finding the maximum
    number of guards that are necessary to *guard* an art gallery of a particular
    shape. Triangulations are an essential part of Fisk’s simple proof of the art
    gallery theorem, which was originally proved by Chvátal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the polygon from this recipe is the floor plan for an art gallery
    and that some guards need to be placed on the vertices. A small amount of work
    will show that you’ll need three guards to be placed at the polygon’s vertices
    for the whole museum to be covered. In the following image, we have plotted one
    possible arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – One possible solution to the art gallery problem where guards
    are placed on vertices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – One possible solution to the art gallery problem where guards are
    placed on vertices
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8**.7* here, the guards are indicated by the **X** symbols and their
    corresponding fields of vision are shaded. Here, you can see that the whole polygon
    is covered by at least one color. The solution to the art gallery problem – which
    is a variation of the original problem – tells us that we need, at most, four
    guards.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More information about the art gallery problem can be found in the classic
    book by O’Rourke: O’Rourke, J. (1987). *Art gallery theorems and algorithms*.
    New York: Oxford University Press.'
  prefs: []
  type: TYPE_NORMAL
- en: Computing convex hulls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A geometric figure is said to be *convex* if every pair of points within the
    figure can be joined using a straight line that is also contained within the figure.
    Simple examples of convex bodies include points, straight lines, squares, circles
    (disks), regular polygons, and so on. The geometric figure shown in *Figure 8**.5*
    is not convex since the points on the opposite sides of the hole cannot be connected
    by a straight line that remains inside the figure.
  prefs: []
  type: TYPE_NORMAL
- en: Convex figures are simple from a certain perspective, which means they are useful
    in a variety of applications. One problem involves finding the smallest convex
    set that contains a collection of points. This smallest convex set is called the
    *convex hull* of the set of points.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to find the convex hull of a set of points using
    the Shapely package.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    package imported as `mpl`, and the `pyplot` module imported as `plt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a default random number generator from NumPy. We can import
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need to import the `MultiPoint` class from Shapely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to find the convex hull of a collection of randomly generated
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we generate a two-dimensional array of random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a new figure and plot these raw sample points on this figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These randomly generated points can be seen in the following figure. The points
    are roughly spread over a square region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – A collection of points on the plane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – A collection of points on the plane
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we construct a `MultiPoint` object that collects all these points and
    put them into a single object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we get the convex hull of this `MultiPoint` object using the `convex_hull`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a Matplotlib `Polygon` patch that can be plotted onto our figure
    to show the result of finding the convex hull:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the `Polygon` patch to the figure to show the convex hull:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The convex hull of the randomly generated points can be seen in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The convex hull of a collection of points on the plane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – The convex hull of a collection of points on the plane
  prefs: []
  type: TYPE_NORMAL
- en: The polygon shown in *Figure 8**.9* has vertices selected from the original
    points and all the other points lie within the shaded region.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Shapely package is a Python wrapper around the GEOS library for geometric
    analysis. The `convex_hull` attribute of Shapely geometric objects calls the convex
    hull computation routine from the GEOS library, resulting in a new Shapely object.
    From this recipe, we can see that the convex hull of the collection of points
    is a polygon with vertices at the points that are farthest away from the *center*.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Bezier curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Bezier curves*, or *B-splines*, are a family of curves that are extremely
    useful in vector graphics – for instance, they are commonly used in high-quality
    font packages. This is because they are defined by a small number of points that
    can then be used to inexpensively calculate a large number of points along the
    curve. This allows detail to be scaled according to the needs of the user.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to create a simple class representing a Bezier
    curve and compute a number of points along it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, and the `comb` routine from the Python Standard
    Library `math` module, imported under the `binom` alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to define a class that represents a Bezier curve that can
    be used to compute points along the curve:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up the basic class. We need to provide the control
    points (nodes) and some associated numbers to instance attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still inside the `__init__` method, we generate the coefficients for the Bezier
    curve and store them in a list on an instance attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define a `__call__` method to make the class callable. We load the
    number of nodes from the instance into a local variable for clarity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we reshape the input array so that it contains a single row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we generate a list of arrays of values using each of the coefficients
    in the `coeffs` attribute for the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we sum all the arrays that were constructed in *step 5* and return
    the resulting array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will test our class using an example. We’ll define four control points
    for this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set up a new figure for plotting, and plot the control points with
    a dashed connecting line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we create a new instance of our `Bezier` class using the four points
    we defined in *step 7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now create an array of equally spaced points between 0 and 1 using `linspace`
    and compute the points along the Bezier curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we plot this curve on top of the control points that we plotted earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Bezier curve that we’ve plotted can be seen in the following diagram. As
    you can see, the curve starts at the first point (**0**, **0**) and finishes at
    the final point (**1**, **3**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Bezier curve of degree 3 constructed using four nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19085_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Bezier curve of degree 3 constructed using four nodes
  prefs: []
  type: TYPE_NORMAL
- en: The Bezier curve in *Figure 8**.10* is tangent to the vertical lines at the
    endpoints and smoothly connects these points. Notice that we only have to store
    the four control points in order to reconstruct this curve with arbitrary accuracy;
    this makes Bezier curves very efficient to store.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Bezier curve is described by a sequence of control points, from which we
    construct the curve recursively. A Bezier curve with one point is a constant curve
    that stays at that point. A Bezier curve with two control points is a line segment
    between those two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_08_008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we add a third control point, we take the line segment between the corresponding
    points on the Bezier curve of curves that are constructed with one less point.
    This means that we construct the Bezier curve with three control points using
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_08_009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This construction can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Construction of a quadratic Bezier curve using a recursive
    definition (the two linear Bezier curves are shown by the dashed lines)](img/B19085_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Construction of a quadratic Bezier curve using a recursive definition
    (the two linear Bezier curves are shown by the dashed lines)
  prefs: []
  type: TYPE_NORMAL
- en: 'The construction continues in this manner to define the Bezier curve on any
    number of control points. Fortunately, we don’t need to work with this recursive
    definition in practice because we can flatten the formulae into a single formula
    for the curve, which is given by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the ![](img/Formula_08_011.png) elements are the control points, ![](img/Formula_08_012.png)
    is a parameter, and each term involves the binomial coefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_08_013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember that the ![](img/Formula_08_014.png) parameter is the quantity that
    is changing to generate the points of the curve. We can isolate the terms in the
    previous sum that involve ![](img/Formula_08_015.png) and those that do not. This
    defines the coefficients that we defined in *step 2*, each of which is given by
    the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We reshape each of the points, `p`, in this step to make sure it is arranged
    as a column vector. This means that each of the coefficients is a column vector
    (as a NumPy array) consisting of the control points scaled by the binomial coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to specify how to evaluate the Bezier curve at various values
    of ![](img/Formula_08_016.png). This is where we make use of the high-performance
    array operations from the NumPy package. We reshaped our control points as column
    vectors when forming our coefficients. In *step 4*, we reshaped the input, ![](img/Formula_08_017.png),
    values to make a row vector. This means that we can use the matrix multiplication
    operator to multiply each coefficient by the corresponding (scalar) value, depending
    on the input, ![](img/Formula_08_018.png). This is what happens in *step 5*, inside
    the list comprehension. In the following line, we multiply the ![](img/Formula_08_019.png)
    array by the ![](img/Formula_08_020.png) array to obtain an ![](img/Formula_08_021.png)
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: We get one of these for each coefficient. We can then use the `np.sum` routine
    to sum each of these ![](img/Formula_08_022.png) arrays to get the values along
    the Bezier curve. In the example provided in this recipe, the top row of the output
    array contains the ![](img/Formula_08_023.png) values of the curve and the bottom
    row contains the ![](img/Formula_08_024.png) values of the curve. We have to be
    careful when specifying the `axis=0` keyword argument for the `sum` routine to
    make sure the sum takes over the list we created, and not the arrays that this
    list contains.
  prefs: []
  type: TYPE_NORMAL
- en: The class we defined is initialized using the control points for the Bezier
    curve, which are then used to generate the coefficients. The actual computation
    of the curve values is done using NumPy, so this implementation should have relatively
    good performance. Once a specific instance of this class has been created, it
    functions very much like a function, as you might expect. However, no type-checking
    is done here, so we can only call this *function* with a NumPy array as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bezier curves are defined using an iterative construction, where the curve with
    ![](img/Formula_08_025.png) points is defined using the straight line connecting
    the curves defined by the first and last ![](img/Formula_08_026.png) points. Keeping
    track of the coefficient of each of the control points using this construction
    will quickly lead you to the equation we used to define the preceding curve. This
    construction also leads to interesting – and useful – geometric properties of
    Bezier curves.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to this recipe, Bezier curves appear in
    many applications that involve vector graphics, such as fonts. They also appear
    in many common vector graphics software packages. In these software packages,
    it is common to see *quadratic Bezier curves*, which are defined by a collection
    of three points. However, you can also define a quadratic Bezier curve by supplying
    the two endpoints, along with the gradient lines, at those points. This is more
    common in graphics software packages. The resulting Bezier curve will leave each
    of the endpoints along the gradient lines and connect the curve smoothly between
    these points.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation we constructed here will have relatively good performance
    for small applications but will not be sufficient for applications involving rendering
    curves with a large number of control points at a large number of ![](img/Formula_08_015.png)
    values. For this, it is best to use a low-level package written in a compiled
    language. For example, the `bezier` Python package uses a compiled Fortran backend
    for its computations and provides a much richer interface than the class we defined
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Bezier curves can, of course, be extended to higher dimensions in a natural
    way. The result is a Bezier surface, which makes them very useful general-purpose
    tools for high-quality, scalable graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A description of some common algorithms from computation geometry can be found
    in the following book: Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery,
    B.P., 2007\. *Numerical recipes: the art of scientific computing*. 3rd ed. Cambridge:
    Cambridge University Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more detailed account of some problems and techniques from computational
    geometry, check out the following book: O’Rourke, J., 1994\. *Computational geometry
    in C*. Cambridge: Cambridge University Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
