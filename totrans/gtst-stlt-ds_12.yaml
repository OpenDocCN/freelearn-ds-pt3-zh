- en: '*Chapter 9*: Improving Job Applications with Streamlit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in this book, you should already be an experienced Streamlit user.
    You have a good grasp of everything – from Streamlit design to deployment, to
    data visualization, and everything in between. This chapter is designed to be
    application-focused; it will show you some great use cases for Streamlit applications
    so that you can be inspired to create your own! We will start by demonstrating
    how to use Streamlit for *Proof Of Skill Data Projects*. Then, we will then move
    on to discuss how to use Streamlit in the *Take Home* sections of job applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit for proof of skill data projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving job applications in Streamlit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of software and hardware installations that are required
    for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`streamlit-lottie`: To download this library, run the following code in your
    Terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Interestingly, `streamlit-lottie` uses the `lottie` open source library, which
    allows us to add web-native animations (such as a GIF) to our Streamlit apps.
    Frankly, it is a wonderful library that you can use to beautify Streamlit apps
    and was created by Andy Fanilo, a prolific Streamlit app creator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The job application example folder: The central repository for this book can
    be found at [https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science](https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science).
    Within this repository, the `job_application_example` folder will contain some
    of the files that you will need for the second section of the chapter, covering
    job applications. If you do not have this main repository downloaded already,
    use the following code in your Terminal to clone it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have everything set up, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit for proof of skill data projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proving to others that you are a skilled data scientist is notoriously difficult.
    Anyone can put Python or machine learning on their résumé or even work in a research
    group at a university that might do some machine learning. But often, recruiters,
    professors you want to work with, and data science managers rely on things on
    your résumé that are proxies for competence, such as having attended the "right"
    university or already having a fancy data science internship or job.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Streamlit, there were not many effective solutions to this problem.
    If you put a Python file or Jupyter Notebook on your GitHub profile, the time
    it would take for someone to understand whether the work was impressive or not
    was too much of a risk to take. If the recruiter has to click on the right repository
    in your GitHub profile and then click through numerous files until they find the
    Jupyter notebook with unreadable code (without comments), you've already lost
    them. If the recruiter sees "machine learning" on your résumé, but it takes five
    clicks to see any machine learning product or code that you've written, you've
    already lost them. Most interested parties will spend a very small amount of time
    on your résumé; on average, visitors to my personal portfolio site (www.tylerjrichards.com)
    spend around 2 minutes on the site before moving elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this issue is to try creating and sharing Streamlit apps that
    are specific to the skills that you would like to showcase the most broadly. For
    instance, if you have a lot of experience in fundamental statistics, you might
    create a Streamlit app that proves, or illustrates, a fundamental statistical
    theorem such as the central limit theorem – just as we did earlier in this book.
    If instead, you have experience in natural language processing, you could create
    an app that shows off a new text-generating neural network that you have created.
    The point here is to minimize the number of clicks someone would need to make
    until they get proof of your competence within a desired area.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the Streamlit apps that we have created already do serve this purpose.
    Let's run through a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning – the Penguins app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16864_04_Final_VK_ePub.xhtml#_idTextAnchor049), *Using Machine
    Learning with Streamlit*, we created a random forest model that was trained on
    our Palmer's Penguin dataset to predict the species of penguin according to features
    such as weight, island of habitation, and bill length. Then, we saved that model
    so that we could use it in our Streamlit app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce our Streamlit app, we need (in the first iteration) to run the following
    code. This will create the model to be deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this first section, we import our libraries, load our data, and train/evaluate
    our model while printing out the evaluation results. Then, we save the model results
    to the `pickle` files using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Recall that at the end of the chapter, we added a new feature so that if a user
    uploaded their own dataset, they could use our model training script to train
    a model entirely on their data (provided it was in the same format; it came with
    some preconditions).
  prefs: []
  type: TYPE_NORMAL
- en: This app, in its final form, shows that we have, at least, some knowledge about
    data cleaning, how to do one-hot encoding on our variables, how we think about
    evaluating our models on test data, and finally, how to deploy our pre-trained
    models in an application. That alone is going to look much better than just putting
    "machine learning" on our résumé, and it shows evidence of some of the skills
    that we have. Without this proof of skill, the recruiter or hiring manager who
    is looking at our application will have to either trust that we are being entirely
    honest on our résumé (and from reading hundreds of résumés over the years, that
    is a bad assumption to make) or use a proxy for confidence such as a university
    degree (this is also a bad proxy for assessing competence).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, when we deployed this app to Streamlit Sharing in [*Chapter
    5*](B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056), *Deploying Streamlit with
    Streamlit Sharing*, we discussed an automatic feature that comes free with Streamlit
    Sharing: the **View app source** button. As you can see in the following screenshot,
    when we deploy our apps, Streamlit adds a button to the user''s **Settings** drop-down
    menu that allows them to view the source code behind the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The View app source option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The View app source option
  prefs: []
  type: TYPE_NORMAL
- en: In this way, users can always check to make sure malicious code (for example,
    whether a researcher's Penguin data is not being stored by the app) is not being
    deployed by Streamlit Sharing. As a secondary feature, the user can also view
    the code that you wrote to built the app, which improves the ability for us to
    use Streamlit as a *Proof of Skill* tool.
  prefs: []
  type: TYPE_NORMAL
- en: Visualization – the Pretty Trees app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 6*](B16864_06_Final_VK_ePub.xhtml#_idTextAnchor065), *Beautifying
    Streamlit Apps*, we worked on a Streamlit application that could create beautiful
    and dynamic visualizations of trees in San Francisco, which resulted in the following
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Mapping a web app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Mapping a web app
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this app, we had to create multiple different visualizations (that is,
    two histograms and one map) that dynamically updated based on the user inputs
    on the right-hand side. With an app like this, we were able to show off our data
    manipulation skills, our familiarity with the pandas, Matplotlib, and Seaborn
    libraries, and even that we understood how to deal with datetimes in Python. Let''s
    take a look at the section of the app''s code that focuses on visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code is fairly easy to read for anyone who is familiar with Python or other
    scripting languages, and it is a heck of a lot better than simply putting "data
    visualization" or "pandas" on a résumé.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I hope you are convinced. Streamlit apps are an excellent way
    to showcase your work to recruiters, potential hiring managers, or anyone to whom
    you need to prove your set of skills. In the next section, we will cover this
    process in a little more detail and demonstrate how to use Streamlit to bolster
    your applications to companies that you might want to work for.
  prefs: []
  type: TYPE_NORMAL
- en: Improving job applications in Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, data science and machine learning job applications rely on take-home
    data science challenges to judge candidates. Frankly, this is a brutal and annoying
    experience that companies can demand because of the dynamic between the applicant
    and the employer. For instance, it could take a candidate 5–10 hours to fully
    complete a data science challenge, but it might only take the employer 10 minutes
    to evaluate it. Additionally, an individual virtual or telephone interview might
    take 30–45 minutes for the employer, plus an extra 15 minutes to write up feedback,
    compared to the same 30–45 minutes for the applicant. Because getting 5–10 hours
    of work gives them a very high signal per minute of employee time, employers have
    trended toward including these challenges within their job applications.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the opportunity here to use Streamlit to stand out from the crowd
    by creating a fully functioning application instead of sending the company a Jupyter
    Notebook, Word document, or PowerPoint deck.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s walk through a fictional example about a job applicant who is in the
    middle of applying to a major US airline. They are given two main questions to
    solve – one has a dataset included:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 1**: **Airport distance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first exercise asks, "Given the included dataset of airports and locations
    (in latitude and longitude), write a function that takes an airport code as input
    and returns the airports listed from nearest to furthest from the input airport."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Question 2**: **Representation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second question asks, "How would you transform a collection of searches
    into a numeric vector representing a trip? Assume that we have hundreds of thousands
    of users and we want to represent all of their trips this way. Ideally, we want
    this to be a general representation that we could use in multiple different modeling
    projects, but we definitely care about finding similar trips. How, precisely,
    would you compare two trips to see how similar they are? What information do you
    feel might be missing from the preceding data that would help improve your representation?"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't worry about writing code in this section; you can simply describe any
    transformations of data that you would perform. Your description should be clear
    enough so that a data scientist reading it would know how to implement your solution
    if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the required questions, we can get a new Streamlit app started.
    To do this, I went through the same process that we have used in each chapter
    thus far. We create a new folder for our app within our central folder (`streamlit_apps`),
    called `job_application_example`. Within this folder, we can create a Python file,
    called `job_streamlit.py`, in our Terminal, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Answering Question 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not hugely important for you to understand exactly how to answer the problem
    at hand, but the overall framework is quite important. The Streamlit app we create
    should read like an incredibly dynamic document that answers the question in a
    unique way, depending on the ability of Streamlit to make an application that
    could not easily be replicated by an applicant with a Word document.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we can create a title that introduces us and kicks off the format
    for the whole application. One improvement here is to add an optional animation
    at the top of the application using the `streamlit-lottie` library that we learned
    about in [*Chapter 7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074), *Exploring
    Streamlit Components*, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create an application with a beautiful airplane animation
    at the top, as presented in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – An airplane GIF'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – An airplane GIF
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to copy and paste the question below our subheader. Streamlit
    has many options for putting text into applications. One option that we have not
    used yet is to wrap our text inside three apostrophe signs, which tells Streamlit
    to write this text using the markdown language. This is useful for large blocks
    of text, such as the following one, which begins to answer the first question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the *Technical requirements* section of this chapter, two files
    are needed to complete this application. The first is the dataset of the airport
    locations (called `airport_location.csv`), and the second is a picture that shows
    the Haversine distance (that is, the distance between two points on a sphere;
    the file is appropriately named `haversine.png`). Please copy those files into
    the same folder as the Streamlit application Python file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to complete the first step: loading the data. We need to both
    complete this step in Streamlit and also show the code to the user. This is different
    from other Streamlit applications, where the code is hidden in the background.
    However, because the user definitely wants to see our code, as they will be assessing
    us on it, we need to do both. We can use the `st.echo()` function, which we used
    previously, to print out the code block to our app. We can do this with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I would like to note here that we have placed a comment at the top of this code.
    This is not for the purpose of annotating code for you, the reader, but for the
    application reader. It is good practice to occasionally comment on the purpose
    of the code that you are writing both within the code and in the blocks of text
    before and after; this is so that the reader understands the approach you are
    trying to take. This is especially important in a job application but is good
    practice for collaborative Streamlit apps, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to explain the Haversine formula and show the image in our
    Streamlit application, which we have done in the following code block. It is totally
    acceptable to take a narrative format in your blocks of text. Simply imagine what
    you would like to read as a hiring manager and try to replicate that as well as
    you can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our application should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Loading the data for Question 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Loading the data for Question 1
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our list of items to address, the animation, the Haversine distance
    formula, and the basic code to read in the data. At this point, we need to implement
    the Haversine distance formula in Python and also show our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first section of our code does not create our function but instead, prints
    out the function that we will create to the Streamlit app. This is so that the
    reader of the application can view both pieces of important code that we have
    written and interact with the code itself. If we just created a function to implement
    the Haversine distance, the reader of our application would not really know how
    we solved the problem at hand! The following code block creates this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have completed our Haversine implementation! Whenever we want to find the
    distance between two locations, we can call our formula, input the longitude and
    latitude, and get the distance in kilometers. This app is useful; however, at
    the moment, it is not much better than a Word document. Our next step is to allow
    the user to input their own points to check and see whether the Haversine distance
    is working. Almost no one knows how many kilometers apart two points on the globe
    are, so I have included default points and checked the real distance between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we put in our default values, the app returns a distance that is approximately
    2 kilometers off, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Implementing the Haversine distance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Implementing the Haversine distance
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our next step is to combine all of the pieces by using the implemented
    Haversine distance calculator on our given dataset. This is briefly shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The airport distances that have been given'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – The airport distances that have been given
  prefs: []
  type: TYPE_NORMAL
- en: 'This dataset has airport codes and their corresponding `lat` and `long` values.
    The following code block introduces a solution that combines the two distances
    and leaves out the full `get_distance_list` function, as it is simply a copy of
    the function that we have implemented twice already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can implement this distance formula on the dataframe we have been
    given. We can allow the user to input their own airport code from the options
    that we have data on and return the correct values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the end of our first question. We can add an optional section at the
    end about how we would change our implementation if we had more time to work on
    this problem. This is always a good idea if you know you only want to spend a
    few hours on the total application, but you also want to demonstrate that you
    know how to improve it if you had more time. An example of this is shown in the
    following code block, to be placed directly after the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could always just end with a statement about the preceding
    code and move on to the second question. At this point, our answer to *Question
    1* is complete and should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Taking user input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Taking user input
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully answered *Question 1*! We can always check the distances
    between these airports by hand to obtain the same result. But let's move on to
    the second question in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Answering Question 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second question is far more straightforward and only asks for text responses.
    Here, the trick is to try to add some lists or Python objects in order to break
    up large paragraphs of text. To begin, we will explain our attempt at answering
    the question and then demonstrate how it might look inside a dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can think of some columns that would be useful for when we are making
    a representation of when a user is searching for flights on this major US airline.
    We can put them into an example dataframe, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For the remainder of the question, we can add a bit of knowledge regarding
    how to find the distance between two points using different methods and then call
    it a day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second question''s answer should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Answering Question 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Answering Question 2
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this example demonstrates how to approach take-home data assignments
    with the help of the Streamlit library to make more impressive applications. The
    final step of this work is to deploy this Streamlit app and share the link with
    the recruiter. I would strongly advise you to deploy this on Heroku to guarantee
    that no one else can view the questions or the data that has been provided by
    the company. You can also take further precautions, such as putting a textbox
    at the beginning of the application that functions as a hacky password protector
    for the application, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the entire application will not run unless the user inputs `example_password`
    into the textbox. This is certainly not secure, but it is useful for relatively
    unimportant (at least, in terms of secrecy) applications such as a take-home application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Entering the password'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_09_9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Entering the password
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the only way for this application to load is if the correct
    password has been entered. Otherwise, the user will see a blank page. Alternatively,
    you can also set the password in Streamlit Sharing using Streamlit secrets, which
    is currently a feature in Streamlit for Teams and will be covered in [*Chapter
    11*](B16864_11_Final_VK_ePub.xhtml#_idTextAnchor122), *Using Streamlit for Teams*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is the most application-focused chapter we have created so far.
    We have focused heavily on job applications and the application cycle for data
    science and machine learning interviews. Additionally, we have learned how to
    password protect our applications, how to create applications that prove to recruiters
    and data science hiring managers that we are the skilled data scientists that
    we know we are, and how to stand out in take-home data science interviews by creating
    Streamlit apps. The next chapter will focus on Streamlit as a toy, and you will
    learn how to create public-facing Streamlit projects for the community.
  prefs: []
  type: TYPE_NORMAL
