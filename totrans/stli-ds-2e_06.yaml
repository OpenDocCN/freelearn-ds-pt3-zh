- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beautifying Streamlit Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Section 2* of the book! In *Section 1*, *Creating Basic Streamlit
    Applications*, we focused on the basics – visualization, deployment, and data
    munging – all the topics that are crucial to getting started with Streamlit. In
    this part of the book, the purpose is to explore Streamlit through more complex
    applications and use cases, with the intent of turning you into an expert Streamlit
    user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll work with elements (including sidebars, tabs,
    columns, and colors) to extend our ability to make beautiful Streamlit applications.
    Along with this, we’ll explore how to create multi-page applications to manage
    user flow, creating a cleaner and more structured user experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should feel much more comfortable creating applications
    that are better than the average **Minimum Viable Product** (**MVP**). We’ll start
    by learning about columns and move on to the rest of the elements discussed, weaving
    each into the main Streamlit app for the chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the **San Francisco** (**SF**) Trees dataset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with columns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tabs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring page configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Streamlit sidebar
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking colors with a color picker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-page apps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editable DataFrames
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires a free GitHub account, which can be obtained at [https://www.github.com](https://www.github.com).
    A full primer on GitHub, along with detailed setup instructions, can be found
    in the *A quick primer on GitHub* section in the previous chapter, *Chapter 5*,
    *Deploying Streamlit with Streamlit Community Cloud*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SF Trees dataset
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we will be working with the SF Trees dataset again, the same
    dataset that we used in *Chapter 3,* *Data Visualization*. As we did in the previous
    chapters, we need to follow this list of steps for the setup:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for the chapter.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our data to the folder.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Python file for our app.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s see each of these steps in detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main `streamlit_apps` folder, run the following code in your terminal
    to make a new folder cleverly called `pretty_trees`. You can also create a new
    folder manually outside the terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to move our data from *Chapter 3,* *Data Visualization*, into
    our folder for this chapter. The following code copies the data into the correct
    folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you do not have the `trees_app` folder and have not yet completed *Chapter
    3,* *Data Visualization*, you can also download the necessary data from [https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)
    within the folder titled `trees_app`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our data ready, we need to create a Python file to host our
    Streamlit app’s code; the following code does precisely this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `pretty_trees` file will hold our Python code, so go ahead and open it up
    in the text editor of your choice and the chapter can officially begin with us
    learning how to work with columns in Streamlit!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Working with columns in Streamlit
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all of our apps prior to this point, we have viewed each Streamlit task as
    a top-down experience. We output text as our title, collect some user input, and
    then put our visualizations below that. However, Streamlit allows us to format
    our app into dynamic columns using the `st.columns()` feature.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We can divide our Streamlit app into multiple columns of different lengths and
    then treat each column as its own unique space (called a container) in our app
    to include text, graphs, images, or anything else we would like.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for columns in Streamlit uses the `with` notation, which you may
    already have been familiar with for use cases such as resource management and
    dealing with opening and writing to files in Python. The easiest way to think
    about the `with` notation in Streamlit columns is that they are self-contained
    blocks of code that tell Streamlit exactly where to place items in our apps. Let’s
    check out an example to see how it works. The following code imports our SF Trees
    dataset and creates three columns of equal length within it, writing text into
    each one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code will create the app shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: First three columns'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, `st.columns()` defines three columns of equal length, and we
    can use the `with` notation to print some text in each. We can also call the `st.write()`
    function (or any other Streamlit function that writes content to our Streamlit
    app) directly on our predefined columns for the same outcome, as shown in the
    following code. The following code will have the exact same output as the preceding
    code block:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we write more complex Streamlit apps with more content in each column, `with`
    statements tend to make for cleaner apps that are easier to understand and debug.
    The majority of this book will use `with` statements whenever possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'In Streamlit, the column width is relative to the size of the other defined
    columns. Because of this, if we scale up the width of each column to `10` instead
    of `1`, our app will not change at all. Additionally, we can also pass a single
    number into `st.beta_columns()`, which will return that number of columns of equal
    width. The following code block shows three options for column width that all
    result in the same column width:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a final example, the following code block allows the user input to determine
    the width of each column. Go ahead and play around with the resulting app to better
    understand how we can use columns to change the format behind our Streamlit apps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In *Chapter 3,* *Data Visualization*, we used the following code to show differences
    between the built-in Streamlit functions `st.line_chart()`, `st.bar_chart()`,
    and `st.area_chart()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code block creates the following Streamlit app, with three graphs
    of SF trees grouped by their width placed one right after the other (only the
    two graphs are shown for brevity):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: SF line and bar charts'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of this exercise was to better understand the three Streamlit functions,
    but how can we do that if we need to scroll to see them all? Let’s improve on
    this by putting our three graphs side by side using three columns. The following
    code predefines three equally wide columns and places one graph in each:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run the preceding code, we get a strange result shown in the following
    screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Skinny graphs'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This is most certainly not what we wanted! Each graph is far too narrow. Luckily
    for us, this brings us to our next mini-topic, page configuration in Streamlit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Exploring page configuration
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Streamlit allows us to configure a few essential page-specific features at the
    top of each Streamlit app. So far, we have been using the Streamlit defaults,
    but at the top of our Streamlit app, we can manually configure everything, from
    the page title shown on the web browser that is used to open our Streamlit apps,
    to the page layout, to the sidebar default state (we will cover the sidebar in
    the *Using the Streamlit sidebar* section!).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The default for Streamlit apps is to have a centered page layout, which is
    why there is copious white space on the edges of our apps. The following code
    sets up our Streamlit app in a wide format instead of our default-centered one:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run the preceding code, we now see that our three graphs are well spaced,
    and we can easily compare the three. The following screenshot shows the Streamlit
    app in a wide format:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_04.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Wide-format graphs'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more bits of information that we need to know about Streamlit
    columns. The first is that we can also edit the gap between the column containers
    that we create, and the second is that we can also ensure that graphs stay within
    their columns and don’t bleed over into the other ones. For the gap part, the
    default is to leave a small gap between the columns, but we can change this to
    a medium or a large gap instead. This next bit of code adds a large gap between
    each of the three columns:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if we look between the graphs, we will notice a gap!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_05.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Gap in the graphs'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: As you may notice, Streamlit’s built-in charts that we’re using already ensure
    that the graphs stay in the columns as they’re supposed to and also sit flush
    with the end of the column. This is because the default on each is to set the
    parameter `use_container_width` to `True`, so what happens if we set it to `False`,
    like this next bit of code?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see in this next screenshot, the graph no longer sits flush with
    the column, thereby making our apps look worse (which is why the default has the
    value as `True`!):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_06.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Container width'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our exploration of using columns in Streamlit and also concludes
    our first look at page configuration defaults. We will increasingly use both of
    these skills in the remainder of the book. Our next topic is to introduce the
    Streamlit sidebar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit tabs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a second way to organize your Streamlit app layout that is remarkably
    similar to the Streamlit column, called the tab. Tabs are useful when you have
    content that is too wide to break up into columns, even in wide mode, and also
    are useful when you want to focus attention by only showing one piece of content
    at a time. For example, if we had three very distinct graphs that only looked
    good in wide mode, but we didn’t want to put them vertically on top of each other,
    we could use tabs to selectively show them. Let’s explore exactly how this works!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`st.tabs` works very similarly to `st.columns`, but instead of telling Streamlit
    the number of tabs we want, we instead pass along the names of the tabs and then
    use now-familiar `with` statements to place content into the tab. The next bit
    of code turns the columns from our most recent Streamlit app into tabs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From this, we will get the following app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_07.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: First tabs'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all there is to tabs! Tabs don’t have the gap parameter that columns
    do (because, well, what would a gap be for tabs?), but aside from this, we can
    map all the information we learned about columns onto our knowledge of tabs. Now,
    on to the Streamlit sidebar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using the Streamlit sidebar
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in Streamlit, when we start to both accept large amounts
    of user input and also start to develop longer Streamlit apps, we often lose the
    ability for the user to see both their input and the output on the same screen.
    In other cases, we may want to put all the user input into its own section to
    clearly separate input and output in our Streamlit app. For both of these use
    cases, we can use the Streamlit sidebar, which allows us to place a minimizable
    sidebar on the left side of the Streamlit app and add any Streamlit component
    to it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we can create a basic example that takes one of the graphs from
    our preceding app and filters the data behind it based on the user’s input. In
    this case, we can ask the user to specify the type of tree owner (for example,
    a private owner or the Department of Public Works) and filter on those conditions
    using the `st.multiselect()` function, which allows the user to select multiple
    options from a list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will create the following Streamlit app. As we have done
    before, we hide the `owners` variable within an `if` statement, as we would like
    the app to run with the entire dataset if the user has yet to select from the
    options. The sidebar allows the user to easily see both the options they selected
    and the output to our app:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_08.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: First sidebar'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Our next step for this app is going to be to add a few more visualizations,
    starting with the tree map we created in *Chapter 3,* *Data Visualization*, and
    then combine the sidebar with what we have already learned about columns in this
    chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的下一步是添加更多的可视化，从我们在*第3章*，*数据可视化*中创建的树木地图开始，然后将侧边栏与我们在本章学到的列知识相结合。
- en: 'The following code places the map of trees throughout SF, filtered by our multi-select
    box, below the histogram:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将树木地图放置在SF的直方图下方，并通过我们的多选框进行过滤：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the Streamlit app from the preceding code, with
    the line chart just above the new map of the trees in SF, filtered by the tree
    owner:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了前面代码中的Streamlit应用，线图位于新地图上方，地图显示的是SF的树木，已根据树木拥有者进行过滤：
- en: '![](img/B18444_06_09.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_09.png)'
- en: 'Figure 6.9: Filtered map with sidebar'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：带侧边栏的过滤地图
- en: 'Our next step for this app will be to combine what we learned about columns
    with the sidebar by adding another graph on top of the map. In *Chapter 3,* *Data
    Visualization*, we created a histogram of the age of the trees. We can use that
    as our third graph in this Streamlit app using the Plotly library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的下一步将是通过在地图上方添加另一个图表，将我们学到的关于列的知识与侧边栏相结合。在*第3章*，*数据可视化*中，我们创建了树木年龄的直方图。我们可以使用它作为这个Streamlit应用中的第三个图表，借助Plotly库：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This first section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分：
- en: Loads the trees dataset.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载树木数据集。
- en: Adds an age column based on the date column in our dataset.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于我们数据集中的日期列，添加一个年龄列。
- en: Creates a multi-select widget on the sidebar.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边栏创建一个多选控件。
- en: Filters, based on the sidebar.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于侧边栏的过滤器。
- en: 'Our next step is to create our three graphs:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是创建三个图表：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we have already discussed in *Chapter 3,* *Data Visualization*, built-in
    Streamlit functions such as `st.map()` and `st.line_chart()` are useful for quick
    visualizations but lack some configuration options, such as proper titles or axis
    renaming. We can do so much more with Plotly! The following screenshot shows our
    Streamlit app with a few tree owner filters pre-set:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第3章*，*数据可视化*中已经讨论过的那样，Streamlit内置的函数，如`st.map()`和`st.line_chart()`，对于快速可视化非常有用，但缺乏一些配置选项，比如合适的标题或轴重命名。我们可以通过Plotly做得更多！下图显示了我们的Streamlit应用，预设了一些树木拥有者过滤器：
- en: '![](img/B18444_06_10.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18444_06_10.png)'
- en: 'Figure 6.10: Three filtered graphs'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：三个过滤后的图表
- en: Our next feature to discuss in this chapter is how to add color input into Streamlit
    apps with a color picker!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来的功能是如何通过颜色选择器将颜色输入添加到Streamlit应用中！
- en: Picking colors with a color picker
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用颜色选择器选择颜色
- en: 'Colors are very difficult to take in as user input in apps. If a user wants
    red, do they want light red or dark red? Maroon or a pinkish red? Streamlit’s
    approach to this problem is `st.color_picker()`, which lets the user pick a color
    as a part of their user input, and returns that color in a hex string (which is
    a unique string that defines very specific color shades used by most graphing
    libraries as input). The following code adds this color picker to our previous
    app and changes the color of the Seaborn graphs to be based on the color that
    the user selects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色作为用户输入在应用中非常难以处理。如果用户想要红色，他们是想要浅红色还是深红色？是栗色还是偏粉红的红色？Streamlit解决这个问题的方法是`st.color_picker()`，它允许用户选择一种颜色作为输入，并以十六进制字符串的形式返回该颜色（这是一个独特的字符串，用于定义大多数图表库用于输入的非常特定的颜色阴影）。以下代码将此颜色选择器添加到我们之前的应用中，并根据用户选择的颜色更改Seaborn图表的颜色：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The change here from our previous app is to add the `graph_color` variable,
    which is a result of the `st.color_picker()` function. We added a name to this
    color picker and placed the color picker in the sidebar right under the owner’s
    multi-select widget. Now that we have the color input from the user, we can use
    this to change the colors in our graphs, as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的应用相比，变化在于添加了`graph_color`变量，它是`st.color_picker()`函数的结果。我们为这个颜色选择器添加了名称，并将其放在侧边栏中，位于拥有者的多选控件下方。现在，我们从用户那里获取了颜色输入，就可以使用它来更改图表中的颜色，如以下代码所示：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run this Streamlit app, you can see exactly how the color picker works
    (this book is published in grayscale, so it is not visible in the hard copy).
    It has a default color (in our case, black), which you can change by selecting
    the component and then clicking on your color of choice. The following screenshot
    shows both the component when clicked on and the result in our SF Trees app:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_11.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Color picker'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to change the colors of visualizations in Streamlit, let’s
    move over to the last section of this chapter: creating multi-page apps.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Multi-page apps
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Streamlit apps thus far have all been single pages, where all or nearly
    all the information in the app has been visible to us with a simple scroll. However,
    Streamlit also has multi-page functionality. Multi-page apps are a powerful tool
    for creating apps that are not limited to one page of content and can extend the
    user experience that comes with Streamlit. For example, the Streamlit data team
    currently primarily builds multi-page apps, having a new app for each project
    or team that they are creating Streamlit apps for.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first multi-page app, we’re going to focus on separating the map section
    of the trees app from the rest of the graphs in two separate apps. The way Streamlit
    creates multi-page apps is it looks in the same directory as our Streamlit app
    for a folder called `pages` and then runs each Python file inside the `pages`
    folder as its own Streamlit app. To do this, create a new folder inside `pretty_trees`
    called `pages`, and then put a file inside `pages` called `map.py`. In your terminal
    from the base folder in the repository, you can run the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, when we run our Streamlit app, we should see the **map** app on the sidebar
    as its own app:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_12.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Our first multi-page app'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click **map** in the top left, it will be completely blank. Now, we
    need to take the map code and move it over into the `map.py` file! Inside the
    `map.py` file, we can include the following code (which is just copied and pasted
    from our original app):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we click on the **map** app, it should no longer be blank but should instead
    look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_13.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Map MPA'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do for this app is to remove the map code from the
    main file. Our main file’s code should now be much smaller and should look like
    this. Here is a snippet of the code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we wanted to add a new app, we would only need to add another file to the
    `pages` folder, and Streamlit would handle all the rest.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, multi-page apps can be extremely powerful. As our apps get longer
    and the user experience of our apps becomes more complicated, we can rely on multi-page
    apps to drive clarity in the user experience. With these, you can easily imagine
    creating one large multi-page app that has individual apps for your different
    business users (like your marketing team, your sales team, etc.) or even just
    as an elegant way to split up your larger apps. If you ever want to create a new
    app, just add another Python file to the `pages` folder, and the new app will
    pop up in the sidebar!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'A member of the Streamlit data science team (Zachary Blackwood, [https://github.com/blackary](https://github.com/blackary))
    created a Python library called `st-pages` that adds a host of new features on
    top of multi-page apps, like adding emojis to page links or creating sections
    for files. The library is fairly young but is a great additional resource if you
    are interested in creating even larger apps than we have worked on in this chapter.
    There is a large and vibrant community around Streamlit, and libraries like these
    are just our first foray into the wonders of open source Streamlit:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_14.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: st-pages'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: That is it for multi-page apps! Now on to editable DataFrames.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Editable DataFrames
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have assumed that we want the data used in these apps
    to be static. We have used mostly CSV files or programmatically generated datasets
    that remain unchanged by the users of our apps.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: This is very often the case, but we might want to give users the ability to
    alter or edit the underlying data in a very user-friendly way. To help solve this,
    Streamlit released `st.experimental_data_editor`, a way to give users edit ability
    on top of an `st.dataframe-style` interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: There are a massive number of potential apps for editing DataFrames, from using
    Streamlit as a quality control system to allowing for direct edits to configuration
    parameters to doing even more of the “what-if” analyses that we have done so far
    in this book. As a creator of many different apps in a work setting, I have noticed
    that people are often extremely comfortable with the everpresent spreadsheet and
    prefer that type of UI.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let’s create a new app called `data_quality.py` in the `pages`
    folder, and try out the new editable DataFrame feature. Imagine that we’re a part
    of the data department in SF, and having missing data in privately owned trees
    is causing some issues for us. We want a few people to come and take a look at
    our data and edit anything that they see might be wrong, and then we also want
    to write that data back to our trusty data source, the CSV file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can start by writing a small message at the top of our new file,
    filtering the data as we have done before, and showing the DataFrame to the user,
    like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make this data editable, we only need to change `st.dataframe` to `st.experimental_data_editor`,
    and then pass the result back to a new DataFrame:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This app, when it is run, looks like the following. I clicked on a cell and
    edited it to show that this works!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_15.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: st-experimental_data_editor'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire DataFrame is passed back by the data editor, so our last step is
    to edit the original, unfiltered DataFrame and then overwrite the CSV file. We
    want to make sure that the user is sure about their changes, so we can add a button
    that writes the result back to the original CSV file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This app now looks like this. We can notice that the plot size measurements
    are missing for many of the rows in this dataset!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_16.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Missing plot size measurements in SF Trees Data Quality App'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add them and then click the save data button to overwrite. Maybe we
    also noticed a data quality issue in the first row, where the x is capitalized
    (dissimilar from the rest!). Let’s edit that too:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_17.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Editing SF Trees Data Quality App'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we reload the app or have this data hosted on Streamlit Community Cloud
    and someone else visits the app, all the data is corrected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: As of the time of writing this book, the data editor is an extremely new feature
    (it was released in Streamlit 1.19, and this book runs on Streamlit 1.20). I am
    sure that by the time you are reading this, there are even more cool new features
    built on top of the data editor and the DataFrame! Please check out the documentation
    ([https://docs.streamlit.io/](https://docs.streamlit.io/)) for more data editor
    knowledge. Now on to the summary!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our adventures with the SF Trees dataset and learning about the
    various ways to make our Streamlit apps more aesthetically pleasing. We covered
    separating our apps into columns and page configuration, along with gathering
    user input in the sidebar, getting specific colors in user input through the `st.color_picker()`
    feature, and finally learning how to use Streamlit multi-page apps and the new
    data editor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the open source community around Streamlit
    by understanding how to download and use Streamlit Components built by users.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/sl](https://packt.link/sl)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code13440134443835796.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
