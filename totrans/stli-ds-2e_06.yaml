- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beautifying Streamlit Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Section 2* of the book! In *Section 1*, *Creating Basic Streamlit
    Applications*, we focused on the basics – visualization, deployment, and data
    munging – all the topics that are crucial to getting started with Streamlit. In
    this part of the book, the purpose is to explore Streamlit through more complex
    applications and use cases, with the intent of turning you into an expert Streamlit
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll work with elements (including sidebars, tabs,
    columns, and colors) to extend our ability to make beautiful Streamlit applications.
    Along with this, we’ll explore how to create multi-page applications to manage
    user flow, creating a cleaner and more structured user experience.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should feel much more comfortable creating applications
    that are better than the average **Minimum Viable Product** (**MVP**). We’ll start
    by learning about columns and move on to the rest of the elements discussed, weaving
    each into the main Streamlit app for the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the **San Francisco** (**SF**) Trees dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring page configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Streamlit sidebar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking colors with a color picker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-page apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editable DataFrames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires a free GitHub account, which can be obtained at [https://www.github.com](https://www.github.com).
    A full primer on GitHub, along with detailed setup instructions, can be found
    in the *A quick primer on GitHub* section in the previous chapter, *Chapter 5*,
    *Deploying Streamlit with Streamlit Community Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SF Trees dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we will be working with the SF Trees dataset again, the same
    dataset that we used in *Chapter 3,* *Data Visualization*. As we did in the previous
    chapters, we need to follow this list of steps for the setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder for the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our data to the folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Python file for our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s see each of these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our main `streamlit_apps` folder, run the following code in your terminal
    to make a new folder cleverly called `pretty_trees`. You can also create a new
    folder manually outside the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to move our data from *Chapter 3,* *Data Visualization*, into
    our folder for this chapter. The following code copies the data into the correct
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you do not have the `trees_app` folder and have not yet completed *Chapter
    3,* *Data Visualization*, you can also download the necessary data from [https://github.com/tylerjrichards/Streamlit-for-Data-Science](https://github.com/tylerjrichards/Streamlit-for-Data-Science)
    within the folder titled `trees_app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our data ready, we need to create a Python file to host our
    Streamlit app’s code; the following code does precisely this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `pretty_trees` file will hold our Python code, so go ahead and open it up
    in the text editor of your choice and the chapter can officially begin with us
    learning how to work with columns in Streamlit!
  prefs: []
  type: TYPE_NORMAL
- en: Working with columns in Streamlit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all of our apps prior to this point, we have viewed each Streamlit task as
    a top-down experience. We output text as our title, collect some user input, and
    then put our visualizations below that. However, Streamlit allows us to format
    our app into dynamic columns using the `st.columns()` feature.
  prefs: []
  type: TYPE_NORMAL
- en: We can divide our Streamlit app into multiple columns of different lengths and
    then treat each column as its own unique space (called a container) in our app
    to include text, graphs, images, or anything else we would like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for columns in Streamlit uses the `with` notation, which you may
    already have been familiar with for use cases such as resource management and
    dealing with opening and writing to files in Python. The easiest way to think
    about the `with` notation in Streamlit columns is that they are self-contained
    blocks of code that tell Streamlit exactly where to place items in our apps. Let’s
    check out an example to see how it works. The following code imports our SF Trees
    dataset and creates three columns of equal length within it, writing text into
    each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create the app shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: First three columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, `st.columns()` defines three columns of equal length, and we
    can use the `with` notation to print some text in each. We can also call the `st.write()`
    function (or any other Streamlit function that writes content to our Streamlit
    app) directly on our predefined columns for the same outcome, as shown in the
    following code. The following code will have the exact same output as the preceding
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we write more complex Streamlit apps with more content in each column, `with`
    statements tend to make for cleaner apps that are easier to understand and debug.
    The majority of this book will use `with` statements whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Streamlit, the column width is relative to the size of the other defined
    columns. Because of this, if we scale up the width of each column to `10` instead
    of `1`, our app will not change at all. Additionally, we can also pass a single
    number into `st.beta_columns()`, which will return that number of columns of equal
    width. The following code block shows three options for column width that all
    result in the same column width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final example, the following code block allows the user input to determine
    the width of each column. Go ahead and play around with the resulting app to better
    understand how we can use columns to change the format behind our Streamlit apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Chapter 3,* *Data Visualization*, we used the following code to show differences
    between the built-in Streamlit functions `st.line_chart()`, `st.bar_chart()`,
    and `st.area_chart()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block creates the following Streamlit app, with three graphs
    of SF trees grouped by their width placed one right after the other (only the
    two graphs are shown for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: SF line and bar charts'
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of this exercise was to better understand the three Streamlit functions,
    but how can we do that if we need to scroll to see them all? Let’s improve on
    this by putting our three graphs side by side using three columns. The following
    code predefines three equally wide columns and places one graph in each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, we get a strange result shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Skinny graphs'
  prefs: []
  type: TYPE_NORMAL
- en: This is most certainly not what we wanted! Each graph is far too narrow. Luckily
    for us, this brings us to our next mini-topic, page configuration in Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring page configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Streamlit allows us to configure a few essential page-specific features at the
    top of each Streamlit app. So far, we have been using the Streamlit defaults,
    but at the top of our Streamlit app, we can manually configure everything, from
    the page title shown on the web browser that is used to open our Streamlit apps,
    to the page layout, to the sidebar default state (we will cover the sidebar in
    the *Using the Streamlit sidebar* section!).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default for Streamlit apps is to have a centered page layout, which is
    why there is copious white space on the edges of our apps. The following code
    sets up our Streamlit app in a wide format instead of our default-centered one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, we now see that our three graphs are well spaced,
    and we can easily compare the three. The following screenshot shows the Streamlit
    app in a wide format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Wide-format graphs'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more bits of information that we need to know about Streamlit
    columns. The first is that we can also edit the gap between the column containers
    that we create, and the second is that we can also ensure that graphs stay within
    their columns and don’t bleed over into the other ones. For the gap part, the
    default is to leave a small gap between the columns, but we can change this to
    a medium or a large gap instead. This next bit of code adds a large gap between
    each of the three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we look between the graphs, we will notice a gap!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Gap in the graphs'
  prefs: []
  type: TYPE_NORMAL
- en: As you may notice, Streamlit’s built-in charts that we’re using already ensure
    that the graphs stay in the columns as they’re supposed to and also sit flush
    with the end of the column. This is because the default on each is to set the
    parameter `use_container_width` to `True`, so what happens if we set it to `False`,
    like this next bit of code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in this next screenshot, the graph no longer sits flush with
    the column, thereby making our apps look worse (which is why the default has the
    value as `True`!):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Container width'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our exploration of using columns in Streamlit and also concludes
    our first look at page configuration defaults. We will increasingly use both of
    these skills in the remainder of the book. Our next topic is to introduce the
    Streamlit sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit tabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a second way to organize your Streamlit app layout that is remarkably
    similar to the Streamlit column, called the tab. Tabs are useful when you have
    content that is too wide to break up into columns, even in wide mode, and also
    are useful when you want to focus attention by only showing one piece of content
    at a time. For example, if we had three very distinct graphs that only looked
    good in wide mode, but we didn’t want to put them vertically on top of each other,
    we could use tabs to selectively show them. Let’s explore exactly how this works!
  prefs: []
  type: TYPE_NORMAL
- en: '`st.tabs` works very similarly to `st.columns`, but instead of telling Streamlit
    the number of tabs we want, we instead pass along the names of the tabs and then
    use now-familiar `with` statements to place content into the tab. The next bit
    of code turns the columns from our most recent Streamlit app into tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we will get the following app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: First tabs'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all there is to tabs! Tabs don’t have the gap parameter that columns
    do (because, well, what would a gap be for tabs?), but aside from this, we can
    map all the information we learned about columns onto our knowledge of tabs. Now,
    on to the Streamlit sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Streamlit sidebar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in Streamlit, when we start to both accept large amounts
    of user input and also start to develop longer Streamlit apps, we often lose the
    ability for the user to see both their input and the output on the same screen.
    In other cases, we may want to put all the user input into its own section to
    clearly separate input and output in our Streamlit app. For both of these use
    cases, we can use the Streamlit sidebar, which allows us to place a minimizable
    sidebar on the left side of the Streamlit app and add any Streamlit component
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we can create a basic example that takes one of the graphs from
    our preceding app and filters the data behind it based on the user’s input. In
    this case, we can ask the user to specify the type of tree owner (for example,
    a private owner or the Department of Public Works) and filter on those conditions
    using the `st.multiselect()` function, which allows the user to select multiple
    options from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create the following Streamlit app. As we have done
    before, we hide the `owners` variable within an `if` statement, as we would like
    the app to run with the entire dataset if the user has yet to select from the
    options. The sidebar allows the user to easily see both the options they selected
    and the output to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: First sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: Our next step for this app is going to be to add a few more visualizations,
    starting with the tree map we created in *Chapter 3,* *Data Visualization*, and
    then combine the sidebar with what we have already learned about columns in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code places the map of trees throughout SF, filtered by our multi-select
    box, below the histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the Streamlit app from the preceding code, with
    the line chart just above the new map of the trees in SF, filtered by the tree
    owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Filtered map with sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step for this app will be to combine what we learned about columns
    with the sidebar by adding another graph on top of the map. In *Chapter 3,* *Data
    Visualization*, we created a histogram of the age of the trees. We can use that
    as our third graph in this Streamlit app using the Plotly library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This first section:'
  prefs: []
  type: TYPE_NORMAL
- en: Loads the trees dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds an age column based on the date column in our dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a multi-select widget on the sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filters, based on the sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next step is to create our three graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already discussed in *Chapter 3,* *Data Visualization*, built-in
    Streamlit functions such as `st.map()` and `st.line_chart()` are useful for quick
    visualizations but lack some configuration options, such as proper titles or axis
    renaming. We can do so much more with Plotly! The following screenshot shows our
    Streamlit app with a few tree owner filters pre-set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Three filtered graphs'
  prefs: []
  type: TYPE_NORMAL
- en: Our next feature to discuss in this chapter is how to add color input into Streamlit
    apps with a color picker!
  prefs: []
  type: TYPE_NORMAL
- en: Picking colors with a color picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Colors are very difficult to take in as user input in apps. If a user wants
    red, do they want light red or dark red? Maroon or a pinkish red? Streamlit’s
    approach to this problem is `st.color_picker()`, which lets the user pick a color
    as a part of their user input, and returns that color in a hex string (which is
    a unique string that defines very specific color shades used by most graphing
    libraries as input). The following code adds this color picker to our previous
    app and changes the color of the Seaborn graphs to be based on the color that
    the user selects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The change here from our previous app is to add the `graph_color` variable,
    which is a result of the `st.color_picker()` function. We added a name to this
    color picker and placed the color picker in the sidebar right under the owner’s
    multi-select widget. Now that we have the color input from the user, we can use
    this to change the colors in our graphs, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this Streamlit app, you can see exactly how the color picker works
    (this book is published in grayscale, so it is not visible in the hard copy).
    It has a default color (in our case, black), which you can change by selecting
    the component and then clicking on your color of choice. The following screenshot
    shows both the component when clicked on and the result in our SF Trees app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Color picker'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to change the colors of visualizations in Streamlit, let’s
    move over to the last section of this chapter: creating multi-page apps.'
  prefs: []
  type: TYPE_NORMAL
- en: Multi-page apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Streamlit apps thus far have all been single pages, where all or nearly
    all the information in the app has been visible to us with a simple scroll. However,
    Streamlit also has multi-page functionality. Multi-page apps are a powerful tool
    for creating apps that are not limited to one page of content and can extend the
    user experience that comes with Streamlit. For example, the Streamlit data team
    currently primarily builds multi-page apps, having a new app for each project
    or team that they are creating Streamlit apps for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first multi-page app, we’re going to focus on separating the map section
    of the trees app from the rest of the graphs in two separate apps. The way Streamlit
    creates multi-page apps is it looks in the same directory as our Streamlit app
    for a folder called `pages` and then runs each Python file inside the `pages`
    folder as its own Streamlit app. To do this, create a new folder inside `pretty_trees`
    called `pages`, and then put a file inside `pages` called `map.py`. In your terminal
    from the base folder in the repository, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run our Streamlit app, we should see the **map** app on the sidebar
    as its own app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Our first multi-page app'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click **map** in the top left, it will be completely blank. Now, we
    need to take the map code and move it over into the `map.py` file! Inside the
    `map.py` file, we can include the following code (which is just copied and pasted
    from our original app):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we click on the **map** app, it should no longer be blank but should instead
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Map MPA'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do for this app is to remove the map code from the
    main file. Our main file’s code should now be much smaller and should look like
    this. Here is a snippet of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to add a new app, we would only need to add another file to the
    `pages` folder, and Streamlit would handle all the rest.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, multi-page apps can be extremely powerful. As our apps get longer
    and the user experience of our apps becomes more complicated, we can rely on multi-page
    apps to drive clarity in the user experience. With these, you can easily imagine
    creating one large multi-page app that has individual apps for your different
    business users (like your marketing team, your sales team, etc.) or even just
    as an elegant way to split up your larger apps. If you ever want to create a new
    app, just add another Python file to the `pages` folder, and the new app will
    pop up in the sidebar!
  prefs: []
  type: TYPE_NORMAL
- en: 'A member of the Streamlit data science team (Zachary Blackwood, [https://github.com/blackary](https://github.com/blackary))
    created a Python library called `st-pages` that adds a host of new features on
    top of multi-page apps, like adding emojis to page links or creating sections
    for files. The library is fairly young but is a great additional resource if you
    are interested in creating even larger apps than we have worked on in this chapter.
    There is a large and vibrant community around Streamlit, and libraries like these
    are just our first foray into the wonders of open source Streamlit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: st-pages'
  prefs: []
  type: TYPE_NORMAL
- en: That is it for multi-page apps! Now on to editable DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Editable DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have assumed that we want the data used in these apps
    to be static. We have used mostly CSV files or programmatically generated datasets
    that remain unchanged by the users of our apps.
  prefs: []
  type: TYPE_NORMAL
- en: This is very often the case, but we might want to give users the ability to
    alter or edit the underlying data in a very user-friendly way. To help solve this,
    Streamlit released `st.experimental_data_editor`, a way to give users edit ability
    on top of an `st.dataframe-style` interface.
  prefs: []
  type: TYPE_NORMAL
- en: There are a massive number of potential apps for editing DataFrames, from using
    Streamlit as a quality control system to allowing for direct edits to configuration
    parameters to doing even more of the “what-if” analyses that we have done so far
    in this book. As a creator of many different apps in a work setting, I have noticed
    that people are often extremely comfortable with the everpresent spreadsheet and
    prefer that type of UI.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, let’s create a new app called `data_quality.py` in the `pages`
    folder, and try out the new editable DataFrame feature. Imagine that we’re a part
    of the data department in SF, and having missing data in privately owned trees
    is causing some issues for us. We want a few people to come and take a look at
    our data and edit anything that they see might be wrong, and then we also want
    to write that data back to our trusty data source, the CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can start by writing a small message at the top of our new file,
    filtering the data as we have done before, and showing the DataFrame to the user,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this data editable, we only need to change `st.dataframe` to `st.experimental_data_editor`,
    and then pass the result back to a new DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This app, when it is run, looks like the following. I clicked on a cell and
    edited it to show that this works!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: st-experimental_data_editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire DataFrame is passed back by the data editor, so our last step is
    to edit the original, unfiltered DataFrame and then overwrite the CSV file. We
    want to make sure that the user is sure about their changes, so we can add a button
    that writes the result back to the original CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This app now looks like this. We can notice that the plot size measurements
    are missing for many of the rows in this dataset!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Missing plot size measurements in SF Trees Data Quality App'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add them and then click the save data button to overwrite. Maybe we
    also noticed a data quality issue in the first row, where the x is capitalized
    (dissimilar from the rest!). Let’s edit that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18444_06_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Editing SF Trees Data Quality App'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we reload the app or have this data hosted on Streamlit Community Cloud
    and someone else visits the app, all the data is corrected.
  prefs: []
  type: TYPE_NORMAL
- en: As of the time of writing this book, the data editor is an extremely new feature
    (it was released in Streamlit 1.19, and this book runs on Streamlit 1.20). I am
    sure that by the time you are reading this, there are even more cool new features
    built on top of the data editor and the DataFrame! Please check out the documentation
    ([https://docs.streamlit.io/](https://docs.streamlit.io/)) for more data editor
    knowledge. Now on to the summary!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes our adventures with the SF Trees dataset and learning about the
    various ways to make our Streamlit apps more aesthetically pleasing. We covered
    separating our apps into columns and page configuration, along with gathering
    user input in the sidebar, getting specific colors in user input through the `st.color_picker()`
    feature, and finally learning how to use Streamlit multi-page apps and the new
    data editor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the open source community around Streamlit
    by understanding how to download and use Streamlit Components built by users.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/sl](https://packt.link/sl)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code13440134443835796.png)'
  prefs: []
  type: TYPE_IMG
