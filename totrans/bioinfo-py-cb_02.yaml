- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python and the Surrounding Software Ecology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by installing the basic software that is required for most of
    this book. This will include the **Python** distribution, some fundamental Python
    libraries, and external bioinformatics software. Here, we will also look at the
    world outside of Python. In bioinformatics and big data, **R** is also a major
    player; therefore, you will learn how to interact with it via **rpy2**, which
    is a Python/R bridge. Additionally, we will explore the advantages that the **IPython**
    framework (via Jupyter Lab) can give us in order to efficiently interface with
    R. Given that source management with Git and GitHub is pervasive, we will make
    sure that our setup plays well with them. This chapter will set the stage for
    all of the computational biologies that we will perform in the remainder of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: As different users have different requirements, we will cover two different
    approaches for installing the software. One approach is using the Anaconda Python
    ([http://docs.continuum.io/anaconda/](http://docs.continuum.io/anaconda/)) distribution
    and another approach for installing the software is via Docker (which is a server
    virtualization method based on containers sharing the same operating system kernel;
    please refer to https://www.docker.com/). This will still install Anaconda for
    you but inside a container. If you are using a Windows-based operating system,
    you are strongly encouraged to consider changing your operating system or using
    Docker via some of the existing options on Windows. On macOS, you might be able
    to install most of the software natively, though Docker is also available. Learning
    using a local distribution (Anaconda or something else) is easier than Docker,
    but given that package management can be complex in Python, Docker images provide
    a level of stability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required software with Anaconda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the required software with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with R via `rpy2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing R magic with Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the required basic software with Anaconda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, we need to install some basic prerequisite software.
    The following sections will take you through the software and the steps that are
    needed to install them. Each chapter and section might have extra requirements
    on top of these – we will make those clear as the book progresses. An alternative
    way to start is to use the Docker recipe, after which everything will be taken
    care of for you via a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already using a different Python distribution, you are strongly encouraged
    to consider Anaconda, as it has become the *de-facto* standard for data science
    and bioinformatics. Also, it is the distribution that will allow you to install
    software from **Bioconda** ([https://bioconda.github.io/](https://bioconda.github.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python can be run on top of different environments. For instance, you can use
    Python inside the **Java Virtual Machine** (**JVM**) (via **Jython** or with .NET
    via **IronPython**). However, here, we are not only concerned with Python but
    also with the complete software ecology around it. Therefore, we will use the
    standard (**CPython**) implementation, since the JVM and .NET versions exist mostly
    to interact with the native libraries of these platforms.
  prefs: []
  type: TYPE_NORMAL
- en: For our code, we will be using Python 3.10\. If you were starting with Python
    and bioinformatics, any operating system will work. But here, we are mostly concerned
    with intermediate to advanced usage. So, while you can probably use Windows and
    macOS, most of the heavy-duty analysis will be done on Linux (probably on a Linux
    **high-performance computing** or **HPC** cluster). **Next-generation sequencing**
    (**NGS**) data analysis and complex machine learning are mostly performed on Linux
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Windows, you should consider upgrading to Linux for your bioinformatics
    work because most modern bioinformatics software will not run on Windows. Note
    that macOS will be fine for almost all analyses unless you plan to use a computer
    cluster, which will probably be Linux-based.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Windows or macOS and do not have easy access to Linux, don’t worry.
    Modern virtualization software (such as **VirtualBox** and **Docker**) will come
    to your rescue, which will allow you to install a virtual Linux on your operating
    system. If you are working with Windows and decide that you want to go native
    and not use Anaconda, be careful with your choice of libraries; you will probably
    be safer if you install the 32-bit version for everything (including Python itself).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Windows, many tools will be unavailable to you.
  prefs: []
  type: TYPE_NORMAL
- en: Bioinformatics and data science are moving at breakneck speed; this is not just
    hype, it’s a reality. When installing software libraries, choosing a version might
    be tricky. Depending on the code that you have, it might not work with some old
    versions or perhaps not even work with a newer version. Hopefully, any code that
    you use will indicate the correct dependencies – though this is not guaranteed.
    In this book, we will fix the precise versions of all software packages, and we
    will make sure that the code will work with them. It is quite natural that the
    code might need tweaking with other package versions.
  prefs: []
  type: TYPE_NORMAL
- en: The software developed for this book is available at [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition).
    To access it, you will need to install Git. Getting used to Git might be a good
    idea because lots of scientific computing software is being developed with it.
  prefs: []
  type: TYPE_NORMAL
- en: Before you install the Python stack properly, you will need to install all of
    the external non-Python software that you will be interoperating with. The list
    will vary from chapter to chapter, and all chapter-specific packages will be explained
    in their respective chapters. Fortunately, since the previous editions of this
    book, most bioinformatics software has become available via the Bioconda project;
    therefore, installation is usually easy.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install some development compilers and libraries, all of which
    are free. On Ubuntu, consider installing the build-essential package (`apt-get
    install build-essential`), and on macOS, consider **Xcode** ([https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, you will find a list of the most important software
    to develop bioinformatics with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Application** | **URL** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| Project Jupyter | All chapters | https://jupyter.org/ | Interactive computing
    |'
  prefs: []
  type: TYPE_TB
- en: '| pandas | All chapters | https://pandas.pydata.org/ | Data processing |'
  prefs: []
  type: TYPE_TB
- en: '| NumPy | All chapters | http://www.numpy.org/ | Array/matrix processing |'
  prefs: []
  type: TYPE_TB
- en: '| SciPy | All chapters | https://www.scipy.org/ | Scientific computing |'
  prefs: []
  type: TYPE_TB
- en: '| Biopython | All chapters | https://biopython.org/ | Bioinformatics library
    |'
  prefs: []
  type: TYPE_TB
- en: '| seaborn | All chapters | http://seaborn.pydata.org/ | Statistical chart library
    |'
  prefs: []
  type: TYPE_TB
- en: '| R | Bioinformatics and Statistics | https://www.r-project.org/ | Language
    for statistical computing |'
  prefs: []
  type: TYPE_TB
- en: '| rpy2 | R connectivity | https://rpy2.readthedocs.io | R interface |'
  prefs: []
  type: TYPE_TB
- en: '| PyVCF | NGS | https://pyvcf.readthedocs.io | VCF processing |'
  prefs: []
  type: TYPE_TB
- en: '| Pysam | NGS | https://github.com/pysam-developers/pysam | SAM/BAM processing
    |'
  prefs: []
  type: TYPE_TB
- en: '| HTSeq | NGS/Genomes | https://htseq.readthedocs.io | NGS processing |'
  prefs: []
  type: TYPE_TB
- en: '| DendroPY | Phylogenetics | https://dendropy.org/ | Phylogenetics |'
  prefs: []
  type: TYPE_TB
- en: '| PyMol | Proteomics | https://pymol.org | Molecular visualization |'
  prefs: []
  type: TYPE_TB
- en: '| scikit-learn | Machine learning | http://scikit-learn.org | Machine learning
    library |'
  prefs: []
  type: TYPE_TB
- en: '| Cython | Big data | http://cython.org/ | High performance |'
  prefs: []
  type: TYPE_TB
- en: '| Numba | Big data | https://numba.pydata.org/ | High performance |'
  prefs: []
  type: TYPE_TB
- en: '| Dask | Big data | http://dask.pydata.org | Parallel processing |'
  prefs: []
  type: TYPE_TB
- en: Figure 1.1 – A table showing the various software packages that are useful in
    bioinformatics
  prefs: []
  type: TYPE_NORMAL
- en: We will use `pandas` to process most table data. An alternative would be to
    use just standard Python. `pandas` has become so pervasive in data science that
    it will probably make sense to just process all tabular data with it (if it fits
    in memory).
  prefs: []
  type: TYPE_NORMAL
- en: All of our work will be developed inside project Jupyter, namely Jupyter Lab.
    Jupyter has become the *de facto* standard to write interactive data analysis
    scripts. Unfortunately, the default format for Jupyter Notebooks is based on JSON.
    This format is difficult to read, difficult to compare, and needs exporting to
    be fed into a normal Python interpreter. To obviate that problem, we will extend
    Jupyter with `jupytext` ([https://jupytext.readthedocs.io/](https://jupytext.readthedocs.io/)),
    which allows us to save Jupyter notebooks as normal Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by downloading the Anaconda distribution from https://www.anaconda.com/products/individual.
    We will be using version 21.05, although you will probably be fine with the most
    recent one. You can accept all the installation’s default settings, but you might
    want to make sure that the `conda` binaries are in your path (do not forget to
    open a new window so that the path can be updated). If you have another Python
    distribution, be careful with your `PYTHONPATH` and existing Python libraries.
    It’s probably better to unset your `PYTHONPATH`. As much as possible, uninstall
    all other Python versions and installed Python libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s go ahead with the libraries. We will now create a new `conda` environment
    called `bioinformatics_base` with `biopython=1.70`, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s activate the environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s add the `bioconda` and `conda-forge` channels to our source list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, install the basic packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s save our environment so that we can reuse it later to create new
    environments in other machines or if you need to clean up the base environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can even install R from `conda`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `r-essentials` installs a lot of R packages, including ggplot2, which
    we will use later. Additionally, we install `r-gridextra` since we will be using
    it in the Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer not to use Anaconda, you will be able to install many of the Python
    libraries via `pip` using whatever distribution you choose. You will probably
    need quite a few compilers and build tools – not only C compilers but also C++
    and Fortran.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be using the environment we created in the preceding steps. Instead,
    we will use it as a base to clone working environments from it. This is because
    environment management with Python – even with the help of the `conda` package
    system – can still be quite painful. So, we will create a clean environment that
    we never spoil and can derive from if our development environments become unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you want to create an environment for machine learning
    with `scikit-learn`. You can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a clone of the original environment with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `scikit-learn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When inside JupyterLab, we should open our jupytext files with the notebook,
    not the text editor. As the jupytext files have the same extension as Python files
    – this is a feature, not a bug – by default, JupyterLab would use a normal text
    editor. When we open a jupytext file, we need to override the default. When opening
    it, right-click and choose **Notebook**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Opening a jupytext file in Notebook ](img/B17942_01_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Opening a jupytext file in Notebook
  prefs: []
  type: TYPE_NORMAL
- en: Our jupytext files will not be saving graphical outputs and that will suffice
    for this book. If you want to have a version with images, this is possible using
    paired notebooks. For more details, check the Jupytext page ([https://github.com/mwouts/jupytext](https://github.com/mwouts/jupytext)).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: As our code is meant to be run inside Jupyter, many times throughout this book,
    I will not use `print` to output content, as the last line of a cell will be automatically
    rendered. If you are not using notebooks, remember to do a `print`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required software with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker is the most widely-used framework for implementing operating system-level
    virtualization. This technology allows you to have an independent container: a
    layer that is lighter than a virtual machine but still allows you to compartmentalize
    software. This mostly isolates all processes, making it feel like each container
    is a virtual machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker works quite well at both extremes of the development spectrum: it’s
    an expedient way to set up the content of this book for learning purposes and
    could become your platform of choice for deploying your applications in complex
    environments. This recipe is an alternative to the previous recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: However, for long-term development environments, something along the lines of
    the previous recipe is probably your best route, although it can entail a more
    laborious initial setup.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are on Linux, the first thing you have to do is install Docker. The safest
    solution is to get the latest version from [https://www.docker.com/](https://www.docker.com/).
    While your Linux distribution might have a Docker package, it might be too old
    and buggy.
  prefs: []
  type: TYPE_NORMAL
- en: If you are on Windows or macOS, do not despair; take a look at the Docker site.
    There are various options available to save you, but there is no clear-cut formula,
    as Docker advances quite quickly on those platforms. A fairly recent computer
    is necessary to run our 64-bit virtual machine. If you have any problems, reboot
    your machine and make sure that the BIOS, VT-X, or AMD-V is enabled. At the very
    least, you will need 6 GB of memory, preferably more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This will require a very large download from the internet, so be sure that you
    have plenty of bandwidth. Also, be ready to wait for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command on your Docker shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On Linux, you will either need to have root privileges or be added to the Docker
    Unix group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you are ready to run the container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `YOUR_DIRECTORY` with a directory on your operating system. This will
    be shared between your host operating system and the Docker container. `YOUR_DIRECTORY`
    will be seen in the container in `/data` and vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-p 9875:9875` will expose the container’s TCP port `9875` on the host computer
    port, `9875`.'
  prefs: []
  type: TYPE_NORMAL
- en: Especially on Windows (and maybe on macOS), make sure that your directory is
    actually visible inside the Docker shell environment. If not, check the official
    Docker documentation on how to expose directories.
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to use the system. Point your browser to `http://localhost:9875`,
    and you should get the Jupyter environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this does not work on Windows, check the official Docker documentation ([https://docs.docker.com/](https://docs.docker.com/))
    on how to expose ports.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is also worth knowing:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker is the most widely used containerization software and has seen enormous
    growth in usage in recent times. You can read more about it at [https://www.docker.com/](https://www.docker.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A security-minded alternative to Docker is **rkt**, which can be found at [https://coreos.com/rkt/](https://coreos.com/rkt/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are not able to use Docker, for example, if you do not have the necessary
    permissions, as will be the case on most computer clusters, then take a look at
    Singularity at [https://www.sylabs.io/singularity/](https://www.sylabs.io/singularity/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with R via rpy2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is some functionality that you need and you cannot find it in a Python
    library, your first port of call is to check whether it’s been implemented in
    R. For statistical methods, R is still the most complete framework; moreover,
    some bioinformatics functionalities are *only* available in R and are probably
    offered as a package belonging to the Bioconductor project.
  prefs: []
  type: TYPE_NORMAL
- en: '`ggplot2`), we will download its metadata from the Human 1,000 Genomes Project
    ([http://www.1000genomes.org/](http://www.1000genomes.org/)). This is not a book
    on R, but we want to provide interesting and functional examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to get the metadata file from the 1,000 Genomes sequence index.
    Please check [https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition/blob/main/Datasets.py](https://github.com/PacktPublishing/Bioinformatics-with-Python-Cookbook-third-edition/blob/main/Datasets.py),
    and download the `sequence.index` file. If you are using Jupyter Notebook, open
    the `Chapter01/Interfacing_R.py` file and simply execute the `wget` command on
    top.
  prefs: []
  type: TYPE_NORMAL
- en: This file has information about all of the FASTQ files in the project (we will
    use data from the Human 1,000 Genomes Project in the chapters to come). This includes
    the FASTQ file, the sample ID, the population of origin, and important statistical
    information per lane, such as the number of reads and the number of DNA bases
    read.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Anaconda, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With Docker, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we can begin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by doing some imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will be using `pandas` on the Python side. R DataFrames map very well to
    `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will read the data from our file using R’s `read.delim` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing that we do after importing is to access the `read.delim` R function,
    which allows you to read files. The R language specification allows you to put
    dots in the names of objects. Therefore, we have to convert a function name into
    `read_delim`. Then, we call the function name proper; note the following highly
    declarative features. Firstly, most atomic objects, such as strings, can be passed
    without conversion. Secondly, argument names are converted seamlessly (barring
    the dot issue). Finally, objects are available in the Python namespace (however,
    objects are actually not available in the R namespace; we will discuss this further
    later).
  prefs: []
  type: TYPE_NORMAL
- en: For reference, I have included the corresponding R code. I hope it’s clear that
    it’s an easy conversion. The `seq_data` object is a DataFrame. If you know basic
    R or `pandas`, you are probably aware of this type of data structure. If not,
    then this is essentially a table, that is, a sequence of rows where each column
    has the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform a basic inspection of this DataFrame, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, note the code similarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even mix styles using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can call R functions directly; in this case, we will call `ncol` if they
    do not have dots in their name; however, be careful. This will display an output,
    not 26 (the number of columns), but [26], which is a vector that’s composed of
    the `26` element. This is because, by default, most operations in R return vectors.
    If you want the number of columns, you have to perform `my_cols[0]`. Also, talking
    about pitfalls, note that R array indexing starts with 1, whereas Python starts
    with 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to perform some data cleanup. For example, some columns should
    be interpreted as numbers, but instead, they are read as strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `match` function is somewhat similar to the `index` method in Python lists.
    As expected, it returns a vector so that we can extract the `0` element. It’s
    also 1-indexed, so we subtract 1 when working on Python. The `as_integer` function
    will convert a column into integers. The first print will show strings (that is
    values surrounded by `"`), whereas the second print will show numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to massage this table a bit more; details on this can be found
    in the notebook. Here, we will finalize getting the DataFrame to R (remember that
    while it’s an R object, it’s actually visible on the Python namespace):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a variable in the R namespace called `seq.data`, with the content
    of the DataFrame from the Python namespace. Note that after this operation, both
    objects will be independent (if you change one, it will not be reflected in the
    other).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While you can perform plotting on Python, R has default built-in plotting functionalities
    (which we will ignore here). It also has a library called `ggplot2` that implements
    the **Grammar of Graphics** (a declarative language to specify statistical charts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding our concrete example based on the Human 1,000 Genomes Project, first,
    we will plot a histogram with the distribution of center names, where all sequencing
    lanes were generated. For this, we will use `ggplot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second line is a bit uninteresting but is an important piece of boilerplate
    code. One of the R functions that we will call has a parameter with a dot in its
    name. As Python function calls cannot have this, we must map the `axis.text.x`
    R parameter name to the `axis_text_r` Python name in the function theme. We monkey
    patch it (that is, we replace `ggplot2.theme` with a patched version of itself).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we draw the chart itself. Note the declarative nature of `ggplot2` as
    we add features to the chart. First, we specify the `seq_data` DataFrame, then
    we use a histogram bar plot called `geom_bar`. Following this, we annotate the
    `x` variable (`CENTER_NAME`). Finally, we rotate the text of the *x-axis* by changing
    the theme. We finalize this by closing the R printing device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can print the image in the Jupyter Notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following chart is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – The ggplot2-generated histogram of center names, which is responsible
    for sequencing the lanes of the human genomic data from the 1,000 Genomes Project
    ](img/B17942_01_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The ggplot2-generated histogram of center names, which is responsible
    for sequencing the lanes of the human genomic data from the 1,000 Genomes Project
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final example, we will now do a scatter plot of read and base counts for
    all of the sequenced lanes for Yoruban (`YRI`) and Utah residents with ancestry
    from Northern and Western Europe (`CEU`), using the Human 1,000 Genomes Project
    (the summary of the data of this project, which we will use thoroughly, can be
    seen in the *Working with modern sequence formats* recipe of [*Chapter 3*](B17942_03.xhtml#_idTextAnchor068),
    *Next-Generation Sequencing*). Additionally, we are interested in the differences
    between the different types of sequencing (for instance, exome coverage, high
    coverage, and low coverage). First, we generate a DataFrame with just the `YRI`
    and `CEU` lanes, and limit the maximum base and read counts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hopefully, this example (please refer to the following screenshot) makes the
    power of the Grammar of Graphics approach clear. We will start by declaring the
    DataFrame and the type of chart in use (that is, the scatter plot implemented
    by `geom_point`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how easy it is to express that the shape of each point depends on the
    `POPULATION` variable and that the color depends on the `ANALYSIS_GROUP` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The ggplot2-generated scatter plot with base and read counts
    for all sequencing lanes read; the color and shape of each dot reflects categorical
    data (population and the type of data sequenced) ](img/B17942_01_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – The ggplot2-generated scatter plot with base and read counts for
    all sequencing lanes read; the color and shape of each dot reflects categorical
    data (population and the type of data sequenced)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the R DataFrame is so close to `pandas`, it makes sense to convert
    between the two since that is supported by `rpy2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start by importing the necessary conversion module – `rpy2` provides many
    strategies to convert data from R into Python. Here, we are concerned with data
    frame conversion. We then convert the R DataFrame (note that we are converting
    `yri_ceu` in the R namespace, not the one on the Python namespace). We delete
    the column that indicates the name of the paired FASTQ file on the `pandas` DataFrame
    and copy it back to the R namespace. If you print the column names of the new
    R DataFrame, you will see that `PAIRED_FASTQ` is missing.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth repeating that the advances in the Python software ecology are occurring
    at a breakneck pace. This means that if a certain functionality is not available
    today, it might be released sometime in the near future. So, if you are developing
    a new project, be sure to check for the very latest developments on the Python
    front before using functionality from an R package.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of R packages for Bioinformatics in the Bioconductor project
    ([http://www.bioconductor.org/](http://www.bioconductor.org/)). This should probably
    be your first port of call in the R world for bioinformatics functionalities.
    However, note that many R Bioinformatics packages are not on Bioconductor, so
    be sure to search the wider R packages on **Comprehensive R Archive Network**
    (**CRAN**) (refer to CRAN at [http://cran.rproject.org/](http://cran.rproject.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of plotting libraries for Python. Matplotlib is the most common
    library, but you also have a plethora of other choices. In the context of R, it’s
    worth noting that there is a ggplot2-like implementation for Python based on the
    Grammar of Graphics description language for charts, and – surprise, surprise
    – this is called `ggplot`! ([http://yhat.github.io/ggpy/](http://yhat.github.io/ggpy/)).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about these topics, please refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of tutorials and books on R; check the R web page ([http://www.r-project.org/](http://www.r-project.org/))
    for documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Bioconductor, check the documentation at [http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you work with NGS, you might also want to take look at high throughput sequence
    analysis with Bioconductor at [http://manuals.bioinformatics.ucr.edu/home/ht-seq](http://manuals.bioinformatics.ucr.edu/home/ht-seq).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rpy` library documentation is your Python gateway to R and can be found
    at [https://rpy2.bitbucket.io/](https://rpy2.bitbucket.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Grammar of Graphics* approach is described in a book aptly named *The Grammar
    of Graphics*, by Leland Wilkinson, Springer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of data structures, similar functionality to R can be found in the
    `pandas` library. You can find some tutorials at [http://pandas.pydata.org/pandas-docs/dev/tutorials.xhtml](http://pandas.pydata.org/pandas-docs/dev/tutorials.xhtml).
    The book, *Python for Data Analysis*, by Wes McKinney, O’Reilly Media, is also
    an alternative to consider. In the next chapter, we will discuss pandas and use
    it throughout the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing R magic with Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jupyter provides quite a few extra features compared to standard Python. Among
    those features, it provides a framework of extensible commands called **magics**
    (actually, this only works with the IPython kernel of Jupyter since it is actually
    an IPython feature, but that is the one we are concerned with). Magics allow you
    to extend the language in many useful ways. There are magic functions that you
    can use to deal with R. As you will see in our example, it makes R interfacing
    much easier and more declarative. This recipe will not introduce any new R functionalities,
    but hopefully, it will make it clear how IPython can be an important productivity
    boost for scientific computing in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to follow the previous *Getting ready* steps of the *Interfacing
    with R via rpy2* recipe. The notebook is `Chapter01/R_magic.py`. The notebook
    is more complete than the recipe presented here and includes more chart examples.
    For brevity, we will only concentrate on the fundamental constructs to interact
    with R using magics. If you are using Docker, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is an aggressive simplification of the previous one because it
    illustrates the conciseness and elegance of R magics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is load R magics and `ggplot2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `%` starts an IPython-specific directive. Just as a simple example,
    you can write `%R print(c(1, 2))` onto a Jupyter cell.
  prefs: []
  type: TYPE_NORMAL
- en: Check out how easy it is to execute the R code without using the `robjects`
    package. Actually, `rpy2` is being used to look under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s read the `sequence.index` file that was downloaded in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, you can specify that the entire cell should be interpreted as R code by
    using `%%R` (note the double `%%`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now transfer the variable to the Python namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The type of the DataFrame is not a standard Python object, but a `pandas` DataFrame.
    This is a departure from previous versions of the R magic interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have a `pandas` DataFrame, we can operate on it quite easily using the
    `pandas` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s put this DataFrame back into the R namespace, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-i` argument informs the magic system that the variable that follows on
    the Python space is to be copied into the R namespace. The second line just shows
    that the DataFrame is indeed available in R. The name that we are using is different
    from the original – it’s `seq_data`, instead of `seq.data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do some final cleanup (for further details, see the previous recipe)
    and print the same bar chart as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Additionally, the R magic system allows you to reduce code, as it changes the
    behavior of the interaction of R with IPython. For example, in the `ggplot2` code
    of the previous recipe, you do not need to use the `.png` and `dev.off` R functions,
    as the magic system will take care of this for you. When you tell R to print a
    chart, it will magically appear in your notebook or graphical console.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The R magics have seemed to have changed quite a lot over time in terms of their
    interface. For example, I have updated the R code for the first edition of this
    book a few times. The current version of the DataFrame assignment returns `pandas`
    objects, which is a major change.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information, check out these links:'
  prefs: []
  type: TYPE_NORMAL
- en: For basic instructions on IPython magics, see [https://ipython.readthedocs.io/en/stable/interactive/magics.xhtml](https://ipython.readthedocs.io/en/stable/interactive/magics.xhtml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of third-party extensions for IPython, including magic ones can be found
    at [https://github.com/ipython/ipython/wiki/Extensions-Index](https://github.com/ipython/ipython/wiki/Extensions-Index).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
