- en: Indexing and Selecting in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how pandas makes it possible to read from
    any source and store structured data as a pandas object—Series, DataFrame, or
    panel. This chapter elaborates on how to slice and dice these objects. The row
    labels and column labels serve as identifiers that help us with selecting a subset
    of the data. Instead of a label, positional identifiers such as the row index
    and column index can also be used. Indexing and selecting are the most fundamental
    yet vital operations performed on data. The topics that will be addressed in this
    chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels, integer, and mixed indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations on indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have come across lists in Python, you will know that a pair of square
    brackets (`[]`) is used to index and subset a list. This square bracket operator
    is also useful in slicing NumPy arrays. The square bracket `[]` is the basic indexing
    operator in pandas as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a Series, DataFrame, and panel to understand how the square bracket
    operator is used in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For a Series, the square bracket operator can be used to slice by specifying
    the label or the positional index. Both use cases are shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the square bracket operator in a DataFrame does have some restrictions.
    It allows only the column label to be passed and not the positional index or even
    the row label. Passing any other string that does not represent a column name
    raises `KeyError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63e255b7-39ae-4b4d-83af-2a48f5e129f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Subset of a single column by column name
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence of square bracket operators can be used to specify the row index
    or row label following the column attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1f2e659-668c-468d-bd4c-b3001ae6e32b.png)'
  prefs: []
  type: TYPE_IMG
- en: Slicing a single element using the square bracket operator
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules that apply to a DataFrame apply to a panel as well—each item can
    be sliced from the panel by specifying the item name. The square bracket operator
    accepts only a valid item name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01f5d7f-9f80-4977-a4cf-2f354c42c307.png)'
  prefs: []
  type: TYPE_IMG
- en: Subset of a panel
  prefs: []
  type: TYPE_NORMAL
- en: 'To subset multiple values, a list of the labels of the entities to be subset
    should be passed into the square bracket operator. Let''s examine this using the
    DataFrame. This holds good for Series and Panels as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec0a9c3e-8d71-4b21-b10b-fd40e5109ade.png)'
  prefs: []
  type: TYPE_IMG
- en: Slicing multiple columns from a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'When a string that is not a column name is passed in, it raises an exception.
    This can be overcome by using the `get()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The square bracket operator is also useful for inserting a new column in a
    DataFrame, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f45a054-209b-4437-a669-f486965dbc95.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new column to a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: New values can be added to Series and Panels as well, via the method shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing attributes using the dot operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access a single entity (a column, value, or item), the square bracket operator
    can be replaced by the dot operator. Let''s subset `colA` in the DataFrame using
    the dot (`.`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5930687-5da6-4f77-9428-975df89e904f.png)'
  prefs: []
  type: TYPE_IMG
- en: Slicing a column with the dot operator
  prefs: []
  type: TYPE_NORMAL
- en: 'By using two dot operators in a chain, an individual element can be accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also applicable to Panels and Series. However, unlike the square bracket
    operator in Series, the positional index cannot be used here. For the dot operator
    to be used, the row labels or column labels must have valid names. A valid Python
    identifier must follow the following lexical convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the dot operator, the values of existing columns can be changed. However,
    new columns cannot be created.
  prefs: []
  type: TYPE_NORMAL
- en: Range slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Slicing by supplying the start and end position to subset a range of values
    can be done in pandas objects, just as in NumPy arrays. The `[ : ]` operator helps
    in range slicing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s slice the Series that we created earlier to subset the second, third,
    and fourth rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/424795dc-55ee-4ef6-872d-a8551d236324.png)'
  prefs: []
  type: TYPE_IMG
- en: Slicing a Series with a range of indexes
  prefs: []
  type: TYPE_NORMAL
- en: As always with a range in Python, the value after the colon is excluded when
    slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Range slicing can be done by providing either the start or end index. If the
    end index is not provided, values are sliced from the given starting index to
    the end of the data structure. Likewise, when only the end index is given, the
    first row is considered as the starting position for slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5aab6d02-1a19-48cc-be1b-750c176be125.png)'
  prefs: []
  type: TYPE_IMG
- en: Range slicing with the posterior end of the range defined
  prefs: []
  type: TYPE_NORMAL
- en: 'When the starting index is given, the row corresponding to that index value
    is chosen as the starting position for slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43e084aa-1fd6-4607-9cb6-baeabd69b615.png)'
  prefs: []
  type: TYPE_IMG
- en: Range slicing with the anterior end of the range defined
  prefs: []
  type: TYPE_NORMAL
- en: 'Range slicing can be made even more interesting through a property to select
    rows at evenly spaced intervals. For instance, you can select only the odd-numbered
    rows or even-numbered rows this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/174bb860-123e-4a07-a88e-9b7a64b9510a.png)'
  prefs: []
  type: TYPE_IMG
- en: Range slicing to select odd-numbered rows
  prefs: []
  type: TYPE_NORMAL
- en: 'To select even rows, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a981f78-0ceb-4124-a46a-e118457da6ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Range slicing to select even-numbered rows
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to reverse the order of the rows, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66dce428-832c-411c-8070-6783d9d9dee9.png)'
  prefs: []
  type: TYPE_IMG
- en: Range slicing to reverse the order of rows
  prefs: []
  type: TYPE_NORMAL
- en: Labels, integer, and mixed indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the standard indexing operator, `[]`, and attribute operator,
    there are operators provided in pandas to make the job of indexing easier and
    more convenient. By label indexing, we generally mean indexing by a header name,
    which tends to be a string value in most cases. These operators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `.loc` **operator**: This allows label-oriented indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The `.iloc` operator**: This allows integer-based indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The `.ix` operator**: This allows mixed label and integer-based indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll now turn our attention to these operators.
  prefs: []
  type: TYPE_NORMAL
- en: Label-oriented indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.loc` operator supports pure label-based indexing. It accepts the following
    as valid inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: A single label such as `["colC"]`, `[2]`, or `["R1"]`—note that in cases where
    the label is an integer, it doesn't refer to the integer position of the index,
    but the integer is itself a label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list or array of labels, for example, `["colA", "colB" ]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slice object with labels, for example, `"colB":"colD"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s examine each of these four cases with respect to the following two Series—one
    with an integer-based label and another with a string-based label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c79d572a-546a-4917-a5c4-d0e6abd79a7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc1.loc with a list of integer labels
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/fdab5360-f534-4f9e-9cd3-91774a7b7dd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc2.loc with a list of labels
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c722f22a-c2a7-4161-aaab-8ad8a2078ab9.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc with range slicing (integer labels)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/dd3f4e13-5719-4369-8db6-030f8e1708cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc with range slicing
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, unlike the ranges in Python where the posterior end is excluded,
    here, both the exteriors are included in the selected data. pandas objects can
    also be filtered based on logical conditions applied to values within the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f141cc8d-442a-44c9-992e-611072fa7c06.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc with a Boolean array for indexing
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, these techniques for slicing can be applied to a DataFrame. It works the
    same, except for the fact that there is a provision to supply two sets of labels—one
    for each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cd799db4-795c-4d65-932e-190cb3cf9f66.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc for slicing a single column
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a669a756-30ff-48d2-91e3-e974b6d6f0cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc for slicing a single row (integer label)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding case, "2" did not represent the position, but the index label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/63723539-7ee5-47d1-a5be-c0710018880f.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc for slicing a single row
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/c4d8eb7a-0702-4293-8d7c-d98d5062e6a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc for selecting through a list of labels
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/d9d1349d-4334-4f00-8d1e-3791633bf3f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc for range slicing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5bc1bee1-2294-49f6-bc43-f0ad4d174c85.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of loc for slicing based on a Boolean array
  prefs: []
  type: TYPE_NORMAL
- en: Integer-oriented indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integer-oriented indexing can be implemented for the same four cases as label-oriented
    indexing: single labels, a list of labels, range slicing, and Boolean arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same DataFrames as in the previous session to understand integer-oriented
    indexing. Here, let''s use two values—one for each axis—to examine integer-based
    indexing. Passing an index for one axis is also permissible. This can also be
    done with the `loc` operator by passing in both the row and column labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/12d678e0-1364-4f53-acd7-85716669bae2.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of iloc for slicing with a list of indices
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/271db284-08af-455d-acc5-48d826c62034.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of iloc for ranged slicing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f56d6eb3-1b21-49ee-ad00-725ba8cb38f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of iloc for slicing with a Boolean array
  prefs: []
  type: TYPE_NORMAL
- en: For Boolean array-based indexing with the `iloc` operator, the array must be
    extracted using logical conditions around array values.
  prefs: []
  type: TYPE_NORMAL
- en: The .iat and .at operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `.iat` and `.at` operators are equivalent to `.iloc` and `.loc` operators—the
    former is for position-based indexing and the latter for label-based indexing.
    While `.loc` and `.iloc` support the selection of multiple values, `.at` and `.iat`
    can only extract a single scalar value. Hence they require row and column indices
    for slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.iat` and `.at` operators are considerably faster in performance than
    `.iloc` and `.loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9255123f-bdae-46fa-b7c1-e95ffadf7ed7.png)'
  prefs: []
  type: TYPE_IMG
- en: Benchmarking .iat with respect to .iloc
  prefs: []
  type: TYPE_NORMAL
- en: Mixed indexing with the .ix operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.ix` operator accepts both label-based and position-based indexing and
    is considered to be a more generic version of the `.loc` and `.iloc` operators.
    Due to ambiguity, this operator is deprecated and will not be available in a future
    version. Hence, it is advised not to use the `.ix` operator. Let's get an understanding
    of the `.ix` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the row index is label-based and the column index is position-based:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/a33ee537-af4c-47be-acd7-d45df89c359f.png)'
  prefs: []
  type: TYPE_IMG
- en: Mixed indexing with .ix in a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: Multi-indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll now turn to the topic of multi-indexing. Multi-level or hierarchical
    indexing is useful because it enables pandas users to select and massage data
    in multiple dimensions by using data structures such as Series and DataFrames.
    In order to start, let''s save the following data to a file, `stock_index_prices.csv`,
    and read it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a multi-index from the `TradingDate` and `PriceType` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon inspection, we see that the multi-index consists of a list of tuples.
    Applying the `get_level_values` function with the appropriate argument produces
    a list of the labels for each level of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`IndexError` will be thrown if the value passed to `get_level_values()` is
    invalid or out of range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can achieve hierarchical indexing with a multi-indexed DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can slice using a multi-index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try slicing at a lower level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: However, this results in `KeyError` with a rather strange error message. The
    key lesson to be learned here is that the current incarnation of multi-index requires
    the labels to be sorted for the lower-level slicing routines to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, you can utilize the `sortlevel()` method, which sorts
    the labels of an axis within a multi-index. To be on the safe side, sort first
    before slicing with a multi-index. Thus, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass a list of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that by specifying a list of tuples instead of a range, as in the previous
    example, we display only the values of open `PriceType` rather than all three
    for `TradingDate = 2014/02/24`.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping and re-ordering levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `swaplevel` function enables levels within the multi-index to be swapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reorder_levels` function is more general, allowing you to specify the
    order of the levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Cross-sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xs` method provides a shortcut means of selecting data based on a particular
    index-level value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The more long-winded alternative to the preceding command would be to use `swaplevel`
    to switch between the `TradingDate` and `PriceType` levels and then perform the
    selection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Using `.xs` achieves the same effect as obtaining a cross-section in the previous
    section on integer-oriented indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use Boolean indexing to filter or select parts of the data. The operators
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operators** | **Symbol** |'
  prefs: []
  type: TYPE_TB
- en: '| OR | &#124; |'
  prefs: []
  type: TYPE_TB
- en: '| AND | & |'
  prefs: []
  type: TYPE_TB
- en: '| NOT | ~ |'
  prefs: []
  type: TYPE_TB
- en: 'These operators must be grouped using parentheses when used together. Using
    the earlier DataFrame from the previous section, here we display the trading dates
    for which NASDAQ closed above 4,300:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create Boolean conditions in which you use arrays to filter out
    parts of the data, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the preceding code snippet displays the only date in the dataset for which
    the NASDAQ Composite index stayed below the 4,300 level for the entire trading
    session.
  prefs: []
  type: TYPE_NORMAL
- en: The isin and any all methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These methods enable the user to achieve more with Boolean indexing than the
    standard operators used in the preceding sections. The `isin` method takes a list
    of values and returns a Boolean array with `True` at the positions within the
    Series or DataFrame that match the values in the list. This enables the user to
    check for the presence of one or more elements within a Series. Here is an illustration
    using `Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the Boolean array to select a sub-series containing the values
    that we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For our DataFrame example, we switch to a more interesting dataset for those
    of us who are of a biological anthropology bent—that of classifying Australian
    mammals (a pet interest of mine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Some more information on mammals: Marsupials are pouched mammals, monotremes
    are egg-laying, and placentals give birth to live young. The source of this information
    is the following: [http://en.wikipedia.org/wiki/List_of_mammals_of_Australia](http://en.wikipedia.org/wiki/List_of_mammals_of_Australia).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/764b993d-5a63-451a-8e9c-a62c465387e1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The source of the preceding image is Bennett's wallaby at [http://bit.ly/NG4R7N.](http://bit.ly/NG4R7N.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s read the Australian Mammals dataset, convert that to a DataFrame, and
    transpose it before using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to select mammals that are native to Australia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The set of values passed to `isin` can be an array or a dictionary. That works
    to some extent, but we can achieve better results by creating a mask as a combination
    of the `isin` and `all()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we see that kangaroo, koala, and wallaby are the native marsupials in
    our dataset. The `any()` method returns whether any element is `True` in a Boolean
    DataFrame. The `all()` method filters return whether all elements are `True` in
    a Boolean DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: More can be read about the pandas methods from their official documentation
    page: [http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.any.html.](http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.any.html.)
  prefs: []
  type: TYPE_NORMAL
- en: Using the where() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `where()` method is used to ensure that the result of Boolean filtering
    is the same shape as the original data. First, we set the random number generator
    seed to 100 so that the user can generate the same values, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This method seems to be useful only in the case of a Series, as we get this
    behavior for free in the case of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The inverse operation of the `where` method is `mask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Operations on indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, we''ll discuss operations on indexes. We sometimes
    need to operate on indexes when we wish to realign our data or select it in different
    ways. There are various operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `set_index` allows the creation of an index on an existing DataFrame
    and returns an indexed DataFrame, as we have seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can set the index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, `reset_index` reverses `set_index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: After reading this chapter, you have come a long way in wrangling data using
    pandas. We will continue to learn about useful tools for data wrangling in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to access and select data from panda data structures.
    We also looked in detail at basic indexing and label-oriented, integer-oriented,
    and mixed indexing. We also learned how to use a Boolean/logical index as well.
    At the end of the chapter, we discussed the index operations.
  prefs: []
  type: TYPE_NORMAL
- en: For further references about indexing in pandas, please take a look at the official
    documentation at [http://pandas.pydata.org/pandas-docs/stable/indexing.html](http://pandas.pydata.org/pandas-docs/stable/indexing.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the topics of grouping, reshaping, and
    merging data using pandas.
  prefs: []
  type: TYPE_NORMAL
