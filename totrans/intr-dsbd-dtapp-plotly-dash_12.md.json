["```py\n    import numpy as np\n    from sklearn.cluster import KMeans\n    ```", "```py\n    sizes = np.array([1, 2, 3, 4, 5, 7, 9, 11]).reshape(-1, 1)\n    sizes\n    array([[ 1],\n           [ 2],\n           [ 3],\n           [ 4],\n           [ 5],\n           [ 7],\n           [ 9],\n           [11]])\n    ```", "```py\n    kmeans1 = KMeans(n_clusters=1)\n    ```", "```py\n    kmeans1.fit(sizes)\n    KMeans(n_clusters=1)\n    ```", "```py\nkmeans1.cluster_centers_\narray([[5.25]])\n```", "```py\nsizes.mean()\n5.25\n```", "```py\nkmeans1.inertia_\n85.5\n```", "```py\nkmeans2 = KMeans(n_clusters=2)\nkmeans2.fit(sizes)\nkmeans2.cluster_centers_\narray([[3.],\n       [9.]])\n```", "```py\nkmeans2.labels_\narray([0, 0, 0, 0, 0, 1, 1, 1], dtype=int32)\n```", "```py\nlist(zip(sizes, kmeans2.labels_))\n[(array([1]), 0),\n (array([2]), 0),\n (array([3]), 0),\n (array([4]), 0),\n (array([5]), 0),\n (array([7]), 1),\n (array([9]), 1),\n (array([11]), 1)]\n```", "```py\nkmeans2.inertia_\n18.0\n```", "```py\ninertia = []\nfor i in range(1, 9):\n    kmeans = KMeans(i)\n    kmeans.fit(sizes)\n    inertia.append(kmeans.inertia_)\ninertia\n[85.5, 18.0, 10.5, 4.5, 2.5, 1.0, 0.5, 0.0]\n```", "```py\nimport plotly.graph_objects as go\nfig = go.Figure()\nfig.add_scatter(x=list(range(1, 9)), y=inertia)\nfig.layout.xaxis.title = 'Number of clusters'\nfig.layout.yaxis.title = 'Inertia'\nfig.show()\n```", "```py\n    import pandas as pd\n    poverty = pd.read_csv('data/poverty.csv')\n    ```", "```py\n    year = 2018\n    indicators = ['Population, total']\n    ```", "```py\n    kmeans = KMeans(n_clusters=2)\n    ```", "```py\n    df = poverty[poverty['year'].eq(year) & poverty['is_country']]\n    ```", "```py\n    data = df[indicators].values\n    ```", "```py\n    kmeans.fit(data)\n    ```", "```py\npx.choropleth(df,\n              locations='Country Name',\n              locationmode='country names',\n              color=[str(x) for x in  kmeans.labels_])\n```", "```py\n    data = np.array([1, 2, 1, 2, np.nan]).reshape(-1, 1)\n    ```", "```py\n    from sklearn.impute import SimpleImputer\n    ```", "```py\n    imp = SimpleImputer(strategy='mean')\n    ```", "```py\n    imp.fit(data)\n    ```", "```py\n    imp.transform(data)\n    array([[1\\. ],\n           [2\\. ],\n           [1\\. ],\n           [2\\. ],\n           [1.5]])\n    ```", "```py\n    data = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)\n    ```", "```py\n    from sklearn.preprocessing import StandardScaler\n    scaler = StandardScaler()\n    ```", "```py\n    scaler.fit_transform(data)\n    array([[-1.41421356],\n           [-0.70710678],\n           [ 0.        ],\n           [ 0.70710678],\n           [ 1.41421356]])\n    ```", "```py\ndcc.Slider(id='year_cluster_slider', …),\ndcc.Slider(id='ncluster_cluster_slider', …),\ndcc.Dropdown(id='cluster_indicator_dropdown', …),\ndcc.Graph(id='clustered_map_chart', …)\n```", "```py\n    @app.callback(Output('clustered_map_chart', 'figure'),\n                  Input('year_cluster_slider', 'value'),\n                  Input('ncluster_cluster_slider', 'value'),\n                  Input('cluster_indicator_dropdown', 'value'))\n    ```", "```py\n    def clustered_map(year, n_clusters, indicators):\n    ```", "```py\n    imp = SimpleImputer(missing_values=np.nan, strategy='mean')\n    scaler = StandardScaler()\n    kmeans = KMeans(n_clusters=n_clusters)\n    ```", "```py\n    df = poverty[poverty['is_country'] & poverty['year'].eq(year)][indicators + ['Country Name', 'year']]\n    ```", "```py\n    data = df[indicators]\n    ```", "```py\n    if df.isna().all().any():\n        return px.scatter(title='No available data for the selected combination of year/indicators.')\n    ```", "```py\n    data_no_na = imp.fit_transform(data)\n    ```", "```py\n    scaled_data = scaler.fit_transform(data_no_na)\n    ```", "```py\n    kmeans.fit(scaled_data)\n    ```", "```py\n    fig = px.choropleth(df,\n                        locations='Country Name',\n                        locationmode='country names',\n                        color=[str(x) for x in  kmeans.labels_],\n                        labels={'color': 'Cluster'},\n                        hover_data=indicators,\n                        height=650,\n                        title=f'Country clusters - {year}. Number of clusters: {n_clusters}<br>Inertia: {kmeans.inertia_:,.2f}')\n    ```", "```py\n@app.callback(Output('clustered_map_chart', 'figure'),\n              Input('year_cluster_slider', 'value'),\n              Input('ncluster_cluster_slider', 'value'),\n              Input('cluster_indicator_dropdown', 'value'))\ndef clustered_map(year, n_clusters, indicators):\n    imp = SimpleImputer(missing_values=np.nan, strategy='mean')\n    scaler = StandardScaler()\n    kmeans = KMeans(n_clusters=n_clusters)\n    df = poverty[poverty['is_country'] & poverty['year'].eq(year)][indicators + ['Country Name', 'year']]\n    data = df[indicators]\n    if df.isna().all().any():\n        return px.scatter(title='No available data for the selected combination of year/indicators.')\n    data_no_na = imp.fit_transform(data)\n    scaled_data = scaler.fit_transform(data_no_na)\n    kmeans.fit(scaled_data)\n    fig = px.choropleth(df,\n                        locations='Country Name',\n                        locationmode='country names',\n                        color=[str(x) for x in  kmeans.labels_],\n                        labels={'color': 'Cluster'},\n                        hover_data=indicators,\n                        height=650,\n                        title=f'Country clusters - {year}. Number of clusters: {n_clusters}<br>Inertia: {kmeans.inertia_:,.2f}',\n                  color_discrete_sequence=px.colors.qualitative.T10)\n    fig.layout.geo.showframe = False\n    fig.layout.geo.showcountries = True\n    fig.layout.geo.projection.type = 'natural earth'\n    fig.layout.geo.lataxis.range = [-53, 76]\n    fig.layout.geo.lonaxis.range = [-137, 168]\n    fig.layout.geo.landcolor = 'white'\n    fig.layout.geo.bgcolor = '#E5ECF6'\n    fig.layout.paper_bgcolor = '#E5ECF6'\n    fig.layout.geo.countrycolor = 'gray'\n    fig.layout.geo.coastlinecolor = 'gray'\n    return fig\n```"]