- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization is a critical component in exploratory data analysis, as well
    as presentations and applications. During exploratory data analysis, you are usually
    working alone or in small groups and need to create plots quickly to help you
    better understand your data. Visualizations can help you identify outliers and
    missing data, or they can spark other questions of interest that will lead to
    further analysis and more visualizations. This type of visualization is usually
    not done with the end user in mind. It is strictly to help you better your current
    understanding. The plots do not have to be perfect.
  prefs: []
  type: TYPE_NORMAL
- en: When preparing visualizations for a report or application, a different approach
    must be used. You should pay attention to small details. Also, you usually will
    have to narrow down all possible visualizations to only the select few that best
    represent your data. Good data visualizations have the viewer enjoying the experience
    of extracting information. Almost like movies that viewers can get lost in, good
    visualizations will have lots of information that really sparks interest.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, pandas has the `pd.Series.plot` and `pd.DataFrame.plot` methods
    to help you quickly generate plots. These methods dispatch to a *plotting backend*,
    which by default is Matplotlib ([https://matplotlib.org/](https://matplotlib.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss different backends later in this chapter, but for now, let’s
    start by installing Matplotlib and PyQt5, which Matplotlib uses to draw plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All code samples in this chapter are assumed to be preceded by the following
    import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous command enables Matplotlib’s *interactive mode*, which will create
    and update your plots automatically every time a plotting command is executed.
    If, for whatever reason, you run a plotting command but no plot appears, you likely
    are in non-interactive mode (you can check this with `matplotlib.pyplot.isinteractive()`),
    and you will need to explicitly call `matplotlib.pyplot.show()` to make your plots
    appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating charts from aggregated data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting distributions of non-aggregated data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further plot customization with Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring scatter plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring categorical data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring continuous data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using seaborn for advanced plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating charts from aggregated data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pandas library makes it easy to visualize data in `pd.Series` and `pd.DataFrame`
    objects, using the `pd.Series.plot` and `pd.DataFrame.plot` methods, respectively.
    In this recipe we are going to start with relatively basic line, bar, area, and
    pie charts, while also seeing the high-level customization options pandas offers.
    While, these chart types are simple, using them effectively can be immensely helpful
    to explore your data, identify trends, and share your research with non-technical
    associates.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that these chart types expect your data to already be
    aggregated, which our sample data in this recipe will reflect. If you are working
    with data that is not yet aggregated, you will need to use techniques that you
    will encounter in *Chapter 7*, *Reshaping DataFrames*, and *Chapter 8*, *Group
    By*, or use the techniques shown in the *Using Seaborn for advanced plots* recipe
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a simple `pd.Series` showing book sales over the course of a 7-day
    period. We are intentionally going to use row index labels of the form *Day n*,
    which will provide a good visual clue on the different chart types we create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to `pd.Series.plot` without any arguments will produce a line chart,
    where the labels used on the *x*-axis come from the row index and the values on
    the *Y*-axis correspond to the data within the `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A line chart treats our data as if it is completely continuous, yielding a
    visualization that appears to show values in between each day, even though that
    does not exist in our data. A better visualization for our `pd.Series` would be
    a bar chart that displays each day discretely, which we can get just by passing
    the `kind="bar"` argument to the `pd.Series.plot` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once again, the row index labels appear on the *X*-axis and the values appear
    on the *Y*-axis. This helps you read the visualization from left to right, but
    in some circumstances, you may find it easier to read values from top to bottom.
    In pandas, such a visualization would be considered a *horizontal bar chart*,
    which can be rendered by using the `kind="barh"` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph with blue bars](img/B31091_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A `kind="area"` argument will produce an area chart, which is like a line chart
    but fills in the area underneath the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![A blue line graph with numbers](img/B31091_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Last but not least, we have pie charts. Unlike all of the visualizations introduced
    so far, a pie chart does not have both an x- and a y-axis. Instead, each label
    from the row index represents a different slice of the pie, whose size is dictated
    by the associated value in our `pd.Series`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![A pie chart with numbers and a number of days](img/B31091_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: When working with a `pd.DataFrame`, the API through which you generate charts
    stays consistent, although you may find that you need to provide more keyword
    arguments to get the desired visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, let’s extend our data to show both `book_sales` and
    `book_returns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we saw with `pd.Series.plot`, the default call to `pd.DataFrame.plot`
    will give us a line plot, with each column represented by its own line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once again, to turn this into a bar chart, you would just need to pass `kind="bar"`
    to the plotting method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, pandas will present each column as a separate bar on the chart.
    If you wanted instead to stack the columns on top of one another, pass `stacked=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same behavior can be seen with a horizontal bar chart. By default, the
    columns will not be stacked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But passing `stacked=True` will place the bars on top of one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When using a `pd.DataFrame` with an area chart, the default behavior is to
    stack the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To unstack, pass `stacked=False` and include an `alpha=` argument to introduce
    transparency. The value of this argument should be between 0 and 1, with values
    closer to 0 making the chart more transparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples in this recipe used the minimum amount of arguments to produce
    visuals. However, the plotting methods accept many more arguments to control things
    like titles, labels, colors, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add a title to your visualization, simply pass it as the `title=`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `color=` argument can be used to change the color of the lines, bars, and
    markers in your chart. Color can be expressed using RGB hex codes (like `#00008B`
    for dark blue) or by using a Matplotlib named color like `seagreen` ([https://matplotlib.org/stable/gallery/color/named_colors.html](https://matplotlib.org/stable/gallery/color/named_colors.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When working with a `pd.DataFrame`, you can pass a dictionary to `pd.DataFrame.plot`
    to control which columns should use which colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `grid=` argument controls whether gridlines are shown or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can control how your *x* and *y* axes are labeled with the `xlabel=` and
    `ylabel=` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When working with a `pd.DataFrame`, pandas will default to placing each column’s
    data on the same chart. However, you can easily generate separate charts with
    `subplots=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With separate charts, the legend becomes superfluous. To toggle that off, simply
    pass `legend=False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When using subplots, it is also worth noting that by default, the *x*-axis
    labels are shared, but the *y*-axis value ranges may differ. If you want the *y*
    axis to be shared, simply add `sharey=True` to your method invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When working with `pd.DataFrame.plot`, the `y=` argument can control which
    columns should be visualized, which can be helpful when you don’t want all of
    the columns to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_21.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, pandas has a wealth of options to control what is being displayed
    and how. While pandas makes a best effort at figuring out where and how to place
    all of these elements on your visual, it may not always get it right. Later in
    this chapter, the *Further plot customization with Matplotlib* recipe will show
    you how to more finely control the layout of your visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting distributions of non-aggregated data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualizations can be of immense help in recognizing patterns and trends in
    your data. Is your data normally distributed? Does it skew left? Does it skew
    right? Is it multimodal? While you may be able to work out the answers to these
    questions, a visualization can very easily highlight these patterns for you, yielding
    deeper insight into your data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to see how easy pandas makes it to visualize the
    distribution of your data. Histograms are a very popular choice for plotting distributions,
    so we will start with them before showcasing the even more powerful **Kernel Density
    Estimate** (**KDE**) plot.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a `pd.Series` using 10,000 random records that are known to follow
    a normal distribution. NumPy can be used to easily generate this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A histogram can be used to plot this data with the `kind="hist"` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![A blue graph with numbers](img/B31091_06_22.png)'
  prefs: []
  type: TYPE_IMG
- en: Rather than attempting to plot every single point, the histogram places our
    values into an automatically generated number of “bins.” The range of each bin
    is plotted along the *X*-axis of the visualization, with the count of occurrences
    within each bin appearing on the y-axis of the histogram.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have created the data we are visualizing, we already know that we have
    a normally distributed set of numbers, and the preceding histogram hints at that
    as well. However, we can elect to visualize a different number of bins by providing
    a `bins=` argument to `pd.Series.plot`, which can have a significant impact on
    the visualization and how it is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, if we were to pass `bins=2`, we would have so few bins that
    our normal distribution would not be obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the flip side, passing `bins=100` makes it clear that we generally have
    a normal distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![A blue graph with numbers  Description automatically generated](img/B31091_06_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same issue is apparent when making a histogram from a `pd.DataFrame`.
    To illustrate, let’s create a `pd.DataFrame` with two columns, where one column
    is normally distributed and the other uses a triangular distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic plotting call to `pd.DataFrame.plot` will produce a chart that looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, the bins from one distribution overlap with the bins of the
    other. You can solve this by either introducing some transparency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Or generating subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first glance, these distributions look pretty much the same, but using more
    bins reveals that they are not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_28.png)'
  prefs: []
  type: TYPE_IMG
- en: While the histogram is commonly used, the fact that the choice of binning can
    have an impact on the interpretation of the data is rather unfortunate; you would
    not want your interpretation of the data to change just from picking the “wrong”
    number of bins!
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is a similar but arguably more powerful visualization you
    can use that does not require you to choose any type of binning strategy, known
    as the **Kernel Density Estimate** (or **KDE**) plot. To use this plot, you will
    need to have SciPy installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing SciPy, you can simply pass `kind="kde"` to `pd.Series.plot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![A blue line graph with numbers  Description automatically generated](img/B31091_06_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With our `pd.DataFrame`, the KDE plot makes it clear that we have two distinct
    distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_30.png)'
  prefs: []
  type: TYPE_IMG
- en: Further plot customization with Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For very simple plots, the default layouts may suffice, but you will inevitably
    run into cases where you need to further tweak the generated visualization. To
    go beyond the out-of-the-box features in pandas, it is helpful to understand some
    Matplotlib terminology. In Matplotlib, the *figure* refers to the drawing area,
    and an *axes* or *subplot* is the region on that figure that you can draw upon.
    Be careful not to confuse an **axes**, which is an area for plotting data, with
    an **axis**, which refers to the *X*- or *Y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a `pd.Series` of our book sales data and try to plot it three
    different ways on the same figure – once as a line chart, once as a bar chart,
    and once as a pie chart. To set up our drawing area, we will make a call to `plt.subplots(nrows=1,
    ncols=3)`, essentially telling matplotlib how many rows and columns of visualizations
    we want in our drawing area. This will return a two-tuple containing the figure
    itself and a sequence of the individual Axes objects that we can plot against.
    We will unpack this into two variables, `fig` and `axes`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we asked for one row and three columns, the length of the returned
    `axes` sequence will be three. We can pass the individual Axes we want pandas
    to plot on to the `ax=` argument of `pd.DataFrame.plot`. Our first attempt at
    drawing all of these plots should look as follows, generating a result that is,
    well, hideous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_31.png)'
  prefs: []
  type: TYPE_IMG
- en: Because we did not tell it any different, Matplotlib gives us three equally
    sized axes objects to draw upon. However, this makes the line/bar charts above
    very tall and skinny, and we end up producing a ton of wasted space above and
    below the pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control this more finely, we can use the Matplotlib `GridSpec` to create
    a 2x2 grid. With that, we can place our bar and line charts side by side in the
    first row, and then we can make the pie chart take up the entire second row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph and pie chart  Description automatically generated](img/B31091_06_32.png)'
  prefs: []
  type: TYPE_IMG
- en: That looks a little better, but now, we still have an issue with the labels
    of the pie chart overlapping the *X*-axis labels of our bar chart. Fortunately,
    we can still modify each axes object individually to rotate labels, remove labels,
    change titles, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph and pie chart  Description automatically generated](img/B31091_06_33.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no limit to the amount of customization that can be done to charts
    via Matplotlib, and unfortunately, we cannot hope to even scratch the surface
    in this book. If you have a keen interest in visualizations, I highly encourage
    you to read the Matplotlib documentation or find a dedicated book on the topic.
    However, many users who just want to see their data may find the amount of customizations
    burdensome to handle. For those users (myself included), there are, thankfully,
    higher-level plotting packages like seaborn, which can produce better-looking
    charts with minimal extra effort. The *Using seaborn for advanced plots* recipe
    later in this chapter will give you an idea of just how useful that package can
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring scatter plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scatter plots are one of the most powerful types of visualizations that you
    can create. In a very compact area, a scatter plot can help you visualize the
    relationship between two variables, measure the scale of individual data points,
    and even see how these relationships and scales may vary within different categories.
    Being able to effectively visualize data in a scatter plot represents a significant
    leap in analytical capabilities when lined up against some of the more commonplace
    visualizations we have seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how we can measure all of these things at once
    just on one scatter plot.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scatter plots by definition measure the relationship of at least two variables.
    As such, the scatter plot can only be created with a `pd.DataFrame`. A `pd.Series`
    simply does not have enough variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let’s create a sample `pd.DataFrame` that contains four different
    columns of data. Three of these columns are continuous variables, and the fourth
    is a color that we will eventually use to categorize different data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Alongside `kind="scatter"`, we will want to explicitly control what gets plotted
    on the *X*-axis, what gets plotted on the *Y*-axis, how big a given data point
    should be, and what color a given data point should appear as. These are controlled
    via the `x=`, `y=`, `s=`, and `c=` arguments, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_34.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple scatter plot like this is not very interesting, but now that we have
    the basics down, let’s try out a more realistic dataset. The United States Department
    of Energy releases annual reports ([https://www.fueleconomy.gov/feg/download.shtml](https://www.fueleconomy.gov/feg/download.shtml))
    that summarize the results of detailed fuel economy testing for vehicles sold
    in the United States. This book includes a local copy of that dataset covering
    the model years 1985–2025.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s just read in a select few columns that are of interest to us,
    namely `city08` (city miles-per-gallon), `highway08` (highway miles-per-gallon),
    `VClass` (compact car, SUV, etc). `fuelCost08` (annual fuel cost), and the model
    `year` of each vehicle (for a full definition of terms included with this dataset,
    refer to [www.fueleconomy.gov](https://www.fueleconomy.gov)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This dataset includes many different vehicle classes, so to keep our analysis
    focused, for now, we are just going to look at different classes of cars from
    2015 onwards. Trucks, SUVs, and vans can be saved for another analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A scatter plot can be used to help us answer a question like, *What is the
    relationship between city miles-per-gallon and highway miles-per-gallon?* by plotting
    these columns on the *X*- and *Y*-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_35.png)'
  prefs: []
  type: TYPE_IMG
- en: Perhaps not surprisingly, there is a strong linear trend. Chances are that the
    better mileage a vehicle gets on city roads, the better mileage it will get on
    highways.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we still see a rather large spread in values; many vehicles are clustered
    down in the range of 10–35 MPG, but some exceed 100\. To dive in a little further,
    we can assign colors to each of our vehicle classes and add them to the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few ways to do this, but one of the generally best approaches
    is to ensure that the value you would like to use for a color is a categorical
    data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, you can pass the categorical column to the `c=` argument
    of `pd.DataFrame.plot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph of different sizes and colors  Description automatically generated
    with medium confidence](img/B31091_06_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding a `colormap=` argument may help to visually discern data points. For
    a list of acceptable values for this argument, please refer to the Matplotlib
    documentation ([https://matplotlib.org/stable/users/explain/colors/colormaps.html](https://matplotlib.org/stable/users/explain/colors/colormaps.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_37.png)'
  prefs: []
  type: TYPE_IMG
- en: From these graphs alone, we can theorize a few things. There are not that many
    “Two Seaters,” but when there are, they tend to do poorly on both city and highway
    mileage. “Midsize Cars” appear to dominate the 40–60 MPG ranges, but as you look
    at the vehicles that produce 100 MPG or better on both highways or cities, “Large
    Cars” and “Midsize Cars” both appear to be reasonably represented.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have used the *X*-axis, *Y*-axis, and color of our scatter plot
    to dive into data, but we can take this one step further and size each data point
    by fuel cost, passing `fuelCost08` as the `s=` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph of a line of colorful circles  Description automatically generated
    with medium confidence](img/B31091_06_38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The size of the individual bubbles here is likely too large to be useful. Our
    fuel economy column has values that are in the range of thousands, which creates
    too large of a plot area to be useful. Simply scaling those values can quickly
    get us to a more reasonable-looking visualization; here, I have chosen to divide
    by 25 and introduce some transparency with the `alpha=` argument to get a more
    pleasing graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_39.png)'
  prefs: []
  type: TYPE_IMG
- en: The general trend of larger circles appearing toward the origin confirms that,
    generally, vehicles with worse mileage have a higher annual fuel cost. You may
    find individual points on this scatter plot where a relatively higher mileage
    still has a higher fuel cost compared to other vehicles with a similar range,
    likely due to different fuel type requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nice complement to the scatter plot is the scatter matrix, which generates
    pairwise relationships between all of the continuous columns of data within your
    `pd.DataFrame`. Let’s see what that looks like with our vehicle data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph of a graph  Description automatically generated with medium confidence](img/B31091_06_40.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a lot of information in one chart, so let’s start by digesting just
    the first column of visualizations. If you look at the bottom of the chart, the
    label is `city08`, which means that `city08` is the *Y*-axis for each chart in
    that column.
  prefs: []
  type: TYPE_NORMAL
- en: The visualization in the first row of the first column would give you the combination
    of `city08` on the y-axis with `city08` on the *X*-axis. Rather than a scatter
    plot that graphs the same column against itself, the scatter matrix shows you
    the distribution of `city08` values in this visual. As you can see, the majority
    of vehicles get less than 50 MPG in the city.
  prefs: []
  type: TYPE_NORMAL
- en: If you look one visual beneath that in the second row of the first column, you
    will see the relationship between fuel cost and city mileage. This would suggest
    that there is an exponential decrease in the amount you spend on fuel annually
    as you opt for cars that get better city mileage.
  prefs: []
  type: TYPE_NORMAL
- en: The visualization in the third row of the first column shows `highway08` on
    the *Y*-axis, which is the same visual that we displayed throughout this recipe.
    Once again, there is a linear relationship between city and highway mileage.
  prefs: []
  type: TYPE_NORMAL
- en: The visualization in the last row of the first column plots the year on the
    *Y*-axis. From this, it appears that there were more vehicles introduced in the
    model years 2023 and 2024 that achieved city mileage of 75 MPG and above.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring categorical data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The adjective *categorical* is applied to data that, in a broad sense, is used
    to classify and help navigate your data, but whose values serve little to no purpose
    when aggregated. For example, if you were working with a dataset that contained
    a field called *eye color* with values of `Brown`, `Green`, `Hazel`, `Blue`, etc.,
    you could use this field to navigate your dataset and answer questions like, *For
    rows where the eye color is X, what is the average pupil diameter?* However, you
    would not ask a question like, *What is the summation of eye color?*, as a formula
    like `"Hazel" + "Blue` would not make sense in this context.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the adjective *continuous* is applied to data that you typically
    aggregate. With a question like, *What is the average pupil diamenter?*, the *pupil
    diameter* column would be considered continuous. There is value to knowing what
    it aggregates to (i.e., minimum, maximum, average, standard deviation, etc.),
    and there are a theoretically infinite amount of values that can be represented.
  prefs: []
  type: TYPE_NORMAL
- en: At times, it can be ambiguous whether your data is categorical or continuous.
    Using a person’s *age* as an example, if you were measuring things like the *average
    age of subjects*, that column would be continuous, although in the context of
    a question like, *How many users do we have between the ages of 20–30?*, that
    same data becomes categorical. Ultimately, whether or not data like *age* is continuous
    or categorical will come down to how you use it in your analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to generate visualizations that help quickly identify
    the distribution of categorical data. Our next recipe, *Exploring continuous data*,
    will give you some ideas on how to work with continuous data instead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the *Scatter plots* recipe, we were introduced to the `vehicles` dataset
    distributed by the United States Department of Energy. This dataset has a good
    mix of categorical and continuous data, so let’s once again start by loading it
    into a `pd.DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that we received a warning that `Columns (72,74,75,77)
    have mixed types`. Before we jump into visualization, let’s take a quick look
    at these columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: While we can see the column names, our `pd.DataFrame` preview does not show
    us any actual values, so to inspect this a bit further, we can use `pd.Series.value_counts`
    on each column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we can see for the `rangeA` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The values here are… interesting. Without yet knowing what we are looking at,
    the column name `rangeA` and most of the values suggest there is some value to
    treating this as continuous. By doing so, we could answer questions like, *What
    is the average rangeA of vehicles that…?*, but the presence of values like `240/290/290`
    and `230/350` that we see will prevent us from being able to do that. For now,
    we are just going to treat this data as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bring us full circle on the warning issued by `pd.read_csv`, pandas tries
    to infer the data type while reading the CSV file. If much of the data at the
    beginning of the file shows one type but later in the file you see another type,
    pandas will intentionally throw this warning so that you are aware of any potential
    issues with your data. For this column, we can use `pd.Series.str.isnumeric` alongside
    `pd.Series.idxmax` to quickly determine the first row where a non-integral value
    was encountered in the CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to inspect the other columns that `pd.read_csv` warned about, you
    would not see a mix of integral and string data, but you would see that much of
    the data at the beginning of the file is missing, which makes it difficult for
    pandas to infer the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the best solution here would have been to avoid the use of CSV files
    in the first place, opting instead for a data storage format that maintains type
    metadata, like Apache Parquet. However, we have no control over how this data
    is generated, so the best we can do for now is explicitly tell `pd.read_csv` to
    treat all of these columns as strings and suppress any warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have loaded the data cleanly, let’s try and identify columns that
    are categorical in nature. Since we know nothing about this dataset, we can make
    the directionally correct assumption that all columns read in as strings by `pd.read_csv`
    are categorical in nature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We could loop over all of these columns and call `pd.Series.value_counts` to
    understand what each column contains, but a more effective way to explore this
    data would be to first understand how many unique values are in each column with
    `pd.Series.nunique`, ordering from low to high. A lower number indicates a *low
    cardinality* (i.e., the number of unique values compared to the value count of
    the `pd.DataFrame` is relatively low). Fields with a higher number would inversely
    be considered to have a *high cardinality*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: For an easy visualization, we are just going to take the nine columns with the
    lowest cardinality. This is by no means an absolute rule for choosing what to
    visualize or not – ultimately, that decision is up to you. For our particular
    dataset, the nine columns with the lowest cardinality have up to seven unique
    values, which can be reasonably plotted on the *X*-axis of bar charts to help
    visualize value distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on what we learned back in the *Further plot customization with Matplotlib*
    recipe in this chapter, we can use `plt.subplots` to create a simple 3x3 grid
    and, with that, plot each visual to its own space in the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That chart is… very difficult to read. Many of the *X*-axis labels overrun
    the chart area, given their length. One way to fix this would be to assign shorter
    labels to our row index values, using a combination of `pd.Index.str[]` along
    with `pd.Index.set_axis` to use those values in a new `pd.Index`. We can also
    use Matplotlib to rotate and resize our *X*-axis labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_42.png)'
  prefs: []
  type: TYPE_IMG
- en: From this visualization, we can more easily understand our dataset at a high
    level. The `mpgData` column appears to be `N` at a much higher frequency than
    `Y`. For the `guzzler` column, we see roughly twice as many `G` values as `T`.
    For the `c240Dscr` column, we can see that the vast majority of entries are `standard`,
    although overall, there are only slightly more than 100 rows in our entire dataset
    that even bother to assign this value, so we may decide that there aren’t enough
    measurements to reliably use it.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring continuous data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Exploring categorical* *data* recipe, we provided a definition for *categorical*
    and *continuous* data, while exploring only the former. The same `vehicles` dataset
    we used in that recipe has a good mix of both types of data (most datasets will),
    so we will reuse that same dataset but shift our focus to continuous data for
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Before going through this recipe, I advise you to get familiar with the techniques
    shown in the *Plotting distributions of non-aggregated data* recipe first. The
    actual plotting calls made will be the same, but this recipe will apply them to
    more of a “real-world” dataset instead of artificially created data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by loading the `vehicles` dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous recipe, we used `pd.DataFrame.select_dtypes` with an `include=`
    argument that kept only string columns, which we used as a proxy for categorical
    data. By passing that same argument to `exclude=` instead, we can get a reasonable
    overview of the continuous columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `pd.Series.nunique` does not make as much sense with continuous data,
    as values may take on a theoretically infinite amount of values. Instead, to identify
    good plotting candidates, we may just want to understand which columns have a
    sufficient amount of non-missing data by using `pd.isna`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, most of our continuous data is complete, but let’s take a look at
    `cylinders` to see what the missing values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'These appear to be electric vehicles, so we could reasonably choose to fill
    these missing values with a `0` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the same pattern with the `displ` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Whether or not we should fill this data with `0` is up for debate. In the case
    of `cylinder`, filling missing values with `0` made sense because our data was
    actually categorical (i.e., there are only so many `cylinder` values that can
    appear, and you cannot simply aggregate those values). If you have one vehicle
    with 2 cylinders and another with 3, it would not make sense to say, “The average
    number of cylinders is 2.5” because a vehicle may not have 2.5 cylinders.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with a column like `displacement`, it may make more sense to measure
    something like the “average displacement.” In such a case, providing many `0`
    values to an average will skew it downwards, whereas missing values would be ignored.
    There are also many more unique values than what we see with `cylinders`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Ultimately, filling missing values in this field is a judgment call; for our
    analysis, we will leave them as missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have validated the missing values in our dataset and feel comfortable
    with our completeness, it is time to start exploring individual fields in more
    detail. When exploring continuous data, a histogram is often the first visualization
    that users reach for. Let’s see what that looks like with our `city08` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The plot looks very skewed, so we will increase the number of bins in the histogram
    to see if the skew is hiding behaviors (as skew makes bins wider):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph with numbers and a blue column  Description automatically generated
    with medium confidence](img/B31091_06_44.png)'
  prefs: []
  type: TYPE_IMG
- en: As we discussed back in the *Plotting distributions of non-aggregated data*
    recipe, you can forgo having to find the optimal number of bins if you have SciPy
    installed. With SciPy, a KDE plot will give you an even better view of the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that, and building from what we saw back in the *Further plot customization
    with Matplotlib* recipe, we can use `plt.subplots` to visualize the KDE plots
    for multiple variables at once, like city and highway mileage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph of a normal distribution  Description automatically generated with
    medium confidence](img/B31091_06_45.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the city mileage tends to skew slightly left, with the peak
    of the distribution occurring around 16 or 17 mpg. Highway mileage peaks closer
    to 23 or 24, with more values than you would expect for a perfectly normal distribution
    appearing around 17 or 18 mpg.
  prefs: []
  type: TYPE_NORMAL
- en: Using seaborn for advanced plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The seaborn library is a popular Python library for creating visualizations.
    It does not do any drawing itself, instead deferring the heavy lifting to Matplotlib.
    However, for users working with a `pd.DataFrame`, seaborn offers beautiful visualizations
    out of the box and an API that abstracts a lot of things you would have to do
    when working more directly with Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using `pd.Series.plot` and `pd.DataFrame.plot`, we will use seaborn’s
    own API. All examples in this section assume the following code to import seaborn
    and use its default theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a small `pd.DataFrame` that shows how many stars two GitHub projects
    have received over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple data makes for a good bar chart, which we can produce with `sns.barplot`.
    Note the difference in the call signature when using seaborn’s API – with seaborn,
    you will provide the `pd.DataFrame` as an argument and explicitly choose the `x`,
    `y`, and `hue` arguments. You will also notice that the seaborn theme uses a different
    color theme than Matplotlib, which you may find more visually appealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_46.png)'
  prefs: []
  type: TYPE_IMG
- en: '`sns.lineplot` can be used to produce this same visualization as a line chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph with a line and a line  Description automatically generated](img/B31091_06_47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An important thing to note when using seaborn is that you will provide your
    data in *long form* instead of wide form. To illustrate the difference, look closely
    at the raw `pd.DataFrame` we just plotted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to make the equivalent line and bar charts with pandas, we would
    have had to structure our data differently before calling `pd.DataFrame.plot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: While the default styling that seaborn provides is helpful to make nice-looking
    charts, there are way more powerful visualizations that the library can help you
    build, with no equivalent when using pandas directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see these types of charts in action, let’s once again work with the `movie`
    dataset we explored back in *Chapter 5*, *Algorithms and How to Apply Them*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to do some data cleansing before we jump into this dataset. For starters,
    it looks like `title_year` is being read as a floating-point value. An integral
    value would have been much more appropriate, so we are going to reread our data
    while passing that explicitly to the `dtype=` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, let’s see when the oldest movie in our dataset was
    released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'And compare that to the last movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'As we think ahead toward visualizing this data, we may not always be so detailed
    as caring about the exact year that a movie was released. Instead, we could place
    each movie into a `decade` bucket by using the `pd.cut` function we covered back
    in *Chapter 5*, *Algorithms and How to Apply Them*, providing a range that will
    start before and extend after the first and last titles in our dataset were released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to understand how the distribution of movie ratings has changed
    over the decades, a boxplot would be a great first step toward visualizing those
    trends. Seaborn exposes an `sns.boxplot` method that makes this trivial to draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B31091_06_48.png)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the median movie rating (i.e., the black vertical line toward
    the middle of each box), you can see that movie ratings have generally trended
    downward over time. At the same time, the lines extending from each box (which
    represent the lowest and highest quartiles of ratings) appear to have a wider
    spread over time, which may suggest that the worst movies each decade are getting
    worse, while the best movies may be getting better, at least since the 1980s.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the boxplot chart provides a decent high-level view into the distribution
    of data by decade, there are other plots that seaborn offers that may be even
    more insightful. One example is the violin plot, which is essentially a KDE plot
    (covered back in the *Plotting distributions of non-aggregated data* recipe) overlaid
    on top of a boxplot. Seaborn allows this via the `sns.violinplot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph of a number of numbers  Description automatically generated with
    medium confidence](img/B31091_06_49.png)'
  prefs: []
  type: TYPE_IMG
- en: Many of the decades show a distribution with a single mode, but if you look
    closely at the 1950s, you will notice that the KDE plot has two peaks (one around
    a score of 7 and the other peak slightly north of 8). The 1960s exhibit a similar
    phenomenon, although the peak around a score of 7 is slightly less pronounced.
    For both of these decades, the KDE overlay suggests that a relatively high volume
    of reviews are distributed toward the 25th and 75th percentiles for ratings, whereas
    other decades tend to regress more toward the median.
  prefs: []
  type: TYPE_NORMAL
- en: However, the violin plot still makes it difficult to discern how many ratings
    there were per decade. While the distribution in each decade is, of course, important,
    the volume may tell another story. Perhaps movie ratings are higher for older
    decades because of survivorship bias, with only the movies that are deemed good
    for those decades actually getting reviewed, or perhaps newer decades have valued
    quality over quantity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever the root cause may be, seaborn can at least help us visually confirm
    the volume alongside our distribution through the use of a swarm plot, which takes
    the KDE portion of the violin plot and scales it vertically, depending on the
    volume of records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph with numbers and lines  Description automatically generated](img/B31091_06_50.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the visual, much of the volume of reviews happened on reviews
    from the 1990s or later, with most of the reviews coming from the years 2000–2010
    (remember that our dataset only contains movies up until 2016). Decades before
    1990 have a relatively small amount of reviews, to the point of making them almost
    indiscernible on the graph.
  prefs: []
  type: TYPE_NORMAL
- en: With a swarm plot, you can go even further into this data by adding more dimensions
    to the visual. So far, we have already discovered that movie ratings have trended
    downward over time, whether it is due to survivorship bias with ratings or a focus
    on quantity over quality. But what if we wanted to know more about different types
    of movies? Are PG-13 movies faring better than R-rated?
  prefs: []
  type: TYPE_NORMAL
- en: 'By controlling the color of each point on a swarm plot, you can add that extra
    dimension to your visuals. To see this in action, let’s drill into just a few
    years of data, as our current plots are getting tough to read. We can also just
    look at movies with ratings, as unrated entries or TV shows are not something
    we care to drill into. As a final data cleansing step, we are going to convert
    our `title_year` column to a categorical data type so that the plotting library
    knows that years like 2013, 2014, 2015, etc. should be treated as discrete values,
    rather than as a continuous range of values from 2013 to 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data cleansing out of the way, we can go ahead and add the `content_rating`
    to our chart and have seaborn assign each a unique color, via the `hue=` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '![A graph of data analysis  Description automatically generated with medium
    confidence](img/B31091_06_51.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding colors adds another dimension of information to our chart, although an
    alternative approach to use a separate chart for each `content_rating` might make
    this even more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, we are going to use the `sns.catplot` function with some extra
    arguments. The first argument of note is `kind=`, through which we will tell seaborn
    to draw “swarm” plots for us. The `col=` argument dictates the field used to generate
    individual charts, and the `col_wrap=` argument tells us how many charts can be
    put together in a row, assuming a grid-like layout for our charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '![A group of blue dots  Description automatically generated](img/B31091_06_52.png)'
  prefs: []
  type: TYPE_IMG
- en: This visualization would appear to suggest that 2013 was a good year for movies,
    at least relative to 2014 and 2015\. Within the PG-13 content rating, it appears
    that there were relatively more movies falling in the 7–8 range than any other
    year. For R-rated movies, it appears that the vast majority of movies were given
    a rating of 5 and above in 2013, with more movies falling below that line as the
    years went on.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/pandas](https://packt.link/pandas)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code5040900042138312.png)'
  prefs: []
  type: TYPE_IMG
- en: Leave a Review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thank you for purchasing this book from Packt Publishing—we hope you enjoy it!
    Your feedback is invaluable and helps us improve and grow. Once you’ve completed
    reading it, please take a moment to leave an Amazon review; it will only take
    a minute, but it makes a big difference for readers like you.
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code below to receive a free ebook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/NzOWQ](Chapter_6.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1474021820358918656.png)'
  prefs: []
  type: TYPE_IMG
