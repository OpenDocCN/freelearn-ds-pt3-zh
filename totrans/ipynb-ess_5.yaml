- en: Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the user will learn how to use `SciPy` to perform scientific
    computations. The `Numba` package will then be introduced as a way to accelerate
    computations. Finally, the `NumbaPro` capabilities of parallel execution in the
    GPU will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of `SciPy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced mathematical algorithms with `SciPy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerating computations with `Numba` and `NumbaPro`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before running the examples in this chapter, load `pylab` by running the following
    command in a computing cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Overview of SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SciPy` is an extensive library for applied mathematics and scientific computation.
    The following is the complete list of all the modules available in the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module | Functionality |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cluster` | Clustering algorithms |'
  prefs: []
  type: TYPE_TB
- en: '| `constants` | Physical and mathematical constants |'
  prefs: []
  type: TYPE_TB
- en: '| `fftpack` | Fast Fourier Transform |'
  prefs: []
  type: TYPE_TB
- en: '| `integrate` | Integration and ordinary differential equations |'
  prefs: []
  type: TYPE_TB
- en: '| `interpolate` | Interpolation and splines |'
  prefs: []
  type: TYPE_TB
- en: '| `io` | Input and output |'
  prefs: []
  type: TYPE_TB
- en: '| `linalg` | Linear algebra |'
  prefs: []
  type: TYPE_TB
- en: '| `ndimage` | Image processing |'
  prefs: []
  type: TYPE_TB
- en: '| `odr` | Orthogonal distance regression |'
  prefs: []
  type: TYPE_TB
- en: '| `optimize` | Optimization and root-finding |'
  prefs: []
  type: TYPE_TB
- en: '| `signal` | Signal processing |'
  prefs: []
  type: TYPE_TB
- en: '| `sparse` | Sparse matrices |'
  prefs: []
  type: TYPE_TB
- en: '| `spatial` | Spatial data structures |'
  prefs: []
  type: TYPE_TB
- en: '| `special` | Special functions |'
  prefs: []
  type: TYPE_TB
- en: '| `stats` | Statistical distributions |'
  prefs: []
  type: TYPE_TB
- en: '| `weave` | C/C++ integration |'
  prefs: []
  type: TYPE_TB
- en: 'The standard way to import `SciPy` modules in scripts is using the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, individual functions can be called with the usual module reference syntax,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, many of the most used functions are available at the top level of
    the `SciPy` hierarchy. Also, we use IPython in the interactive mode and use (as
    we assume in this book) the magic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Many of the functions will be available without explicit module reference.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we present a sample of the functions available in `SciPy`.
    The reader is not expected to know the mathematical techniques and algorithms
    that will be used in the examples in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced mathematical algorithms with SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover some of the algorithms available in `SciPy`.
    Each of the following subsections features a representative example from a significant
    area of applied science. The examples are chosen so as not to require extensive
    domain knowledge but still be realistic. These are the topics and examples that
    we present:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solving equations and finding optimal values**: We will study a market model
    that requires the solution of a nonlinear system and a facility location problem
    requiring a nonstandard optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calculus and differential equations**: We will present a volume calculation
    that uses integral calculus, and **Newton''s canon**, a thought experiment proposed
    by Isaac Newton, which we will model using a system of differential equations.
    Finally, we will present a three-dimensional system, the famous Lorenz equations,
    which is an early example displaying chaotic behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving equations and finding optimal values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate this topic, we use a standard supply-versus-demand model from
    economics. In this model, supply and demand are related to prices by functional
    relationships, and the equilibrium market is found by determining the intersection
    of the supply and demand curves. The mathematical formulae we use in the example
    are somewhat arbitrary (thus possibly unrealistic) but will go beyond what is
    found in textbooks, where supply and demand are in general assumed to be linear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formulae that specify the supply and demand curves are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving equations and finding optimal values](img/8341OS_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the *function factory* pattern. Run the following lines of code
    in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code doesn't directly define the supply and demand curves. Instead,
    it specifies function factories. This approach makes it easier to work with parameters,
    which is what we normally want to do in applied problems since we expect the same
    model to be applicable to a variety of situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we set the parameter values and call the function factories to define
    the functions that actually evaluate the supply and demand curves, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code make a graph of the curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the graph that is the output of the preceding lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving equations and finding optimal values](img/8341OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The curves chosen for supply and demand reflect what would be reasonable assumptions:
    supply increases and demand decreases as the price gets higher. Even with a zero
    price, the demand is finite (reflecting the fact that there is a limited population
    interested in the product). On the other hand, the supply curve has a vertical
    asymptote (not shown in the plot), indicating that there is a production limit
    (so, even if the price goes to infinity, there is a limited quantity that can
    be offered in the market).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The equilibrium point of the market is the intersection of the supply and demand
    curves. To find the equilibrium, we use the `optimize` module, which, besides
    providing functions for optimization, also has functions to solve numerical equations.
    The recommended function to find solutions for one-variable functions is `brentq()`,
    as illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `brentq()` function assumes that the right-hand side of the equation we
    want to solve is `0`. So, we start by defining the `opt_func()` function that
    computes the difference between supply and demand. This function is the first
    argument of `brentq()`. The next two numerical arguments give an interval that
    contains the solutions. It is important to choose an interval that contains exactly
    one solution of the equation. In our example, this is easily done by looking at
    the graph, from which it is clear that the curves intersect between 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first value is the equilibrium point, which is the number of units (in thousands)
    that can be sold at the optimal price. The optimal price is computed using both
    the supply and demand curves (to check that the values are indeed the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate an optimization problem in two variables, let''s consider a problem
    of optimal facility location. Suppose a factory has several manufacturing stations
    that need materials to be distributed from a single supply station. The factory
    floor is rectangular, and the distribution rails must be parallel to the walls
    of the factory. This last requirement is what makes the problem interesting. The
    function to be minimized is related to the so-called **taxicab** **distance**,
    which is illustrated in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving equations and finding optimal values](img/8341OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step is to define the points where the manufacturing stations are
    given, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The positions are stored as a 4 x 2 `NumPy` array called `points`, with one
    point in each row. The following command produces a plot of the points mentioned
    in the previous command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The points are displayed using a circular marker specified by the argument
    `o`, which also turns off the line segments connecting the points. The `ms` and
    `mfc` options specify the size of the marker (in pixels) and its color, respectively.
    The following image is then generated as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving equations and finding optimal values](img/8341OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to define the function to be minimized. We again prefer the
    approach of defining a function factory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The main point of this code is the way in which the taxicab distance is computed,
    which takes full advantage of the flexibility of the array operations of `NumPy`.
    This is done in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code first computes the vector difference, `points-p`. Note that, here,
    `points` is a 4 x 2 array, while `p` is a 1 x 2 array. `NumPy` realizes that the
    dimensions of the arrays are different and uses its *broadcasting rules*. The
    effect is that the array `p` is subtracted from each row of the `points` array,
    which is exactly what we want. Then the `abs()` function computes the absolute
    value of each of the entries of the resulting array, and finally `sum()` adds
    all the entries. That's a lot of work done in a single line of code!
  prefs: []
  type: TYPE_NORMAL
- en: We then have to use the function factory to define the function that will actually
    compute the taxicab distance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The function factory is simply called with the array containing the actual
    positions as its argument. At this point, the problem is completely set up, and
    we are ready to compute the optimum, which is done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The minimization is computed by a call to the `minimize()` function. The first
    two arguments of this function are the objective function defined in the previous
    cell, `txmin()`, and an initial guess, `x0`. We just choose the origin as the
    initial guess, but in a real-world problem, we use any information we can gather
    to select a guess that is close to the actual minimum. Several optimization methods
    are available, suitable for different types of objective functions. We use the
    **Nelder-Mead method**, which is a heuristic algorithm that does not require smoothness
    of the objective function. This is well suited for the problem at hand. Finally,
    we specify two options for the method: the desired tolerance and a display option
    to print diagnostics. This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output states that a minimum was successfully found and gives
    its value. Note that, as in any numerical optimization method, in general, it
    can only be guaranteed that a local minimum was found. In this case, since the
    objective function is convex, the minimum is guaranteed to be global. The result
    of the function is stored in a `SciPy` data structure of the `OptimizeResult`
    type defined in the `optimize` module. To get the optimal position of the facility,
    we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish this example, we present the code that displays the optimal solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The calls to the `plot()` function are similar to the ones in the previous
    example. To give a nicely formatted title, we first define the `locstr` string,
    which displays the optimal location coordinates. This is a Python-formatted string
    with the format specification of `{:5.2f}`, that is, a floating-point field with
    width `5` and a precision of `2` digits. The result is the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving equations and finding optimal values](img/8341OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculus and differential equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of a calculus computation, we will show you how to compute the
    volume of a solid of revolution. The solid is created by rotating the curve displayed
    in the following figure around the *y*-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This curve is plotted with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The curve is essentially a stretched and transposed inverse cosine function,
    as defined in the `make_gen()` function. It depends on two parameters, `a` and
    `b`, that specify its height and length, respectively. The `make_gen()` function
    is a function factory that returns a function that actually computes values in
    the curve. The actual function defining the curve is called `gen()` (for *generator*),
    so this is the function that is plotted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this curve is rotated around the vertical axis, we obtain the solid plotted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure, of course, was generated with IPython using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The key function in this code is the call to `plot_trisurf()` in the last line.
    This function accepts three `NumPy` arrays, `xvalues`, `yvalues`, and `zvalues`,
    specifying the coordinates of the points on the surface. The arrays, `xvalues`
    and `yvalues` define points in a succession of concentric circles, as shown in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value of the `z` coordinate is obtained by computing `gen(sqrt(x*x+y*y))`
    at each of these points, which has the effect of assigning the same height in
    the 3D plot to all points of each concentric circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the volume of the solid, we use the method of cylindrical shells.
    An explanation of how the method works is beyond the scope of this book, but it
    boils down to computing an integral, as shown in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this formula, the *f(x)* function represents the curve being rotated around
    the `y`-axis. To compute this integral, we use the `scipy.integrate` package.
    We use the `quad()` function, which is appropriate for the generic integration
    of functions that do not have singularities. The following is the code for this
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the `integrate` module, we define the function to be integrated.
    Note that we use the `lambda` syntax since this is a one-line calculation. Finally,
    we call `quad()` to perform the integration. The arguments to the call are the
    function being integrated and the bounds of integration (from `0` to `b` in this
    case). The following is the output of the preceding lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first number is the value of the integral, and the second one is an error
    estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we consider *Newton''s canon*, a thought experiment at
    the very root of modern physics and calculus. The situation is illustrated in
    the following image, which is an engraving from the book by Sir Isaac Newton,
    *A Treatise of The System of the World*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Newton asks us to imagine a canon sitting at the top of a very high mountain.
    If the canon shoots a projectile, it will fly for a while and eventually hit the
    ground. The larger the initial velocity of the projectile, the further away it
    will hit the ground. Let's imagine that we can shoot the projectile as fast as
    we want, and that there is no air resistance. Then, as the initial velocity increases,
    eventually the projectile will go around the earth and, if the canon is removed
    quickly enough, then the projectile will continue its orbit around Earth forever.
    Newton used this example to explain how the moon could revolve around Earth without
    ever falling under the action of gravity alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'To model this situation, we need to use Newton''s law of gravitation as a system
    of differential equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will not attempt to explain how these formulae were obtained, with the only
    important point for us being that there are four state variables, with the first
    two representing the position of the projectile and the last two representing
    its velocity vector. Since the movement takes place in a plane through the center
    of Earth, only two position variables are needed. *G* and *M* are constants representing
    Newton's universal gravitational constant and the mass of Earth, respectively.
    The mass of the projectile does not appear, since the gravitational mass is exactly
    cancelled by the inertial mass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to solve this using `SciPy` is to define this set of differential
    equations, which is done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All that we need to do is define a function that computes the right-hand side
    of the system of differential equations. We start by defining the constants, `M`
    and `G` (using SI units), and the auxiliary constant `C`, since `G` and `M` only
    appear in the equations through their product. The system is represented by the
    `ode_func()` function. This function must accept at least two parameters: a `NumPy`
    array, `xvec`, and a floating-point value, `t`. In our case, `xvec` is a four-dimensional
    vector since there are four state variables in our system. The variable, `t`,
    is not used in the system since there are no external forces (as there would be
    if we were launching a rocket instead of shooting a projectile). However, it must
    still be listed as an input parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `ode_func()`, we first extract the elements of the `xvec` vector with
    the assignment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is not strictly necessary but improves readability. We then compute the
    auxiliary quantity, `d` (this is the denominator of the last two equations). Finally,
    the output array is computed according to the formulae in the system. Note that
    no derivatives are computed since all information that is needed by the solver
    is contained in the right-hand side of the equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to solve the system of differential equations using the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the preceding code imports the `integrate` module, where the
    differential equations are solved. We then need to specify the initial position
    and velocity of the projectile. We assume that the canon is at the North Pole,
    atop a tower of 50,000 m (although this is clearly unrealistic, we just choose
    such a large value to enhance the visibility of the orbit). Since Earth is not
    a perfect sphere, we use an average value for the radius. The initial velocity
    is set to `8500` m/s.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial conditions are stored in a `NumPy` array with the following assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define the initial time (zero in our case) and the array
    of times at which the solution is sought. This is done with the following three
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We first define `tmax` as being the duration of the simulation (in seconds).
    The variable `dt` stores the time intervals at which we want to record the solution.
    In the preceding code, the solution will be recorded every 60 seconds for 8,650
    seconds. The final time was chosen by trial-and-error to correspond, approximately,
    to one orbit of the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to compute the solution, which is done with a call to the
    `odeint()` function. The solution is stored in the vector, `xsol`, which has one
    row for each time at which the solution is computed. To see the first few rows
    of the vector, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These values are the position and velocity vectors of the projectile from time
    `0` s to time `360` s at intervals of `60` s.
  prefs: []
  type: TYPE_NORMAL
- en: 'We definitely want to produce a plot of the orbit. This can be done by running
    the following code in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We want to use the same scale in both axes since both axes represent spatial
    coordinates in meters. This is done in the first line of code. The second line
    sets the axis limits so that the plot of the orbit fits comfortably in the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we plot a circle to represent Earth using the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have not emphasized using `Artist` objects in our plots since these are
    at a lower level than is usually required for scientific plots. Here, we are constructing
    a `Circle` object by giving its center, radius, and appearance options: a black
    edge color, brown face color, and a line width equal to 3\. The second line of
    code shows how to add the `Circle` object to the plot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After drawing Earth, we plot the orbit using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a standard call to the `plot()` function. Note that we plot only the
    first two columns of the `xsol` array since these represent the position of the
    projectile (recall that the other two represent the velocity). The following image
    is what we get as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A numerical solution for differential equations is a sophisticated topic, and
    a complete treatment of the issue is beyond the scope of this book, but we will
    present the full form of the `odeint()` function and comment on some of the options.
    The `odeint()` function is a Python wrapper on the `lsoda` solver from `ODEPACK`,
    the Fortran library. Detailed information about the solver can be found at [http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html](http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code are the complete signature of `odeint()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments, `ode_func`, `x0` and `tvalues`, have already been discussed.
    The argument `args` allows us to pass extra parameters to the equation being solved.
    This is a very common situation, which is illustrated in the next example. In
    this case, the function defining the system must have the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `p1`, `p2`, and `pn` are extra parameters. These parameters are fixed
    for a single solution but can change from one solution to the other (they are
    normally used to represent the environment). The tuple passed to `args` must have
    a length exactly equal to the number of parameters that `ode_func()` requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a partial list of the meaning of the most common options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dfun` is a function that computes the Jacobian of the system. This may improve
    the accuracy of the solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the Jacobian has the derivatives of the right-hand side along its columns
    (`True`, faster) or rows (`False`) is specified by `col_deriv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `full_output` is set to `True`, the output contains diagnostics about the
    solution process. This may be useful if errors accumulate and the solution process
    is not successfully completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last example in this section, we present the Lorenz oscillator, a simplified
    model for atmospheric convection, and a famous equation that displays chaotic
    behavior for certain values of the parameters. We will also use this example to
    demonstrate how to plot solutions in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lorenz system is defined by the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We start by defining a Python function representing the system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this system and the previous one is the presence
    of the parameters `sigma`, `rho`, and `beta`. Note that they are just added as
    extra arguments to `ode_func()`. Solving the equation is almost the same as solving
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the array of times and the initial condition just as we did in the
    previous example. Notice that since this is a three-dimensional problem, there
    are initial conditions in an array with three components. Then comes the call
    to `odeint()`. The call now has an extra argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This sets `sigma`, `rho`, and `beta`, respectively, to the values `10`, `28`,
    and `8/3`. These are values that are known to correspond to chaotic solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution can then be plotted with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines of code set up the axes for three-dimensional plotting.
    The next line extracts the data in a format suitable for plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This code illustrates a common pattern. The array `sol` contains the coordinates
    of the solutions along its columns, so we transpose the array so that the data
    is along the rows of the array, and then assign each row to one of the variables
    `x`, `y`, and `z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other lines of code are pretty straightforward: we call the `plot()` function
    and then add labels to the axes. The following is the figure that we get as the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculus and differential equations](img/8341OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image is known as the classical Lorenz butterfly, a striking example
    of a strange attractor.
  prefs: []
  type: TYPE_NORMAL
- en: Accelerating computations with Numba and NumbaPro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss `Numba` and `NumbaPro`, two very exciting libraries
    to accelerate the `NumPy` code. `Numba` and `NumbaPro` were created by *Continuum
    Analytics*, the same company that produces the Anaconda distribution. `Numba`
    is part of the standard Anaconda distribution, but `NumbaPro` is a commercial
    product that must be purchased separately as part of the `Accelerate` package.
    However, `NumbaPro` can be downloaded for a free trial period.
  prefs: []
  type: TYPE_NORMAL
- en: 'These libraries are unique in that they allow the acceleration of code with
    the addition of a few lines of code. As the first example, let''s consider the
    following lines of code to multiply two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the straightforward definition of matrix multiplication
    and looks very much like code that would be written if we were implementing the
    algorithm in C. It is not Python-like and definitely not optimized. (In a real-world
    situation, one would simply use the `NumPy` built-in matrix multiplication.) Note,
    in particular, that the dimensions of the matrices are not checked: it is assumed
    that the number of columns of `A` is equal to the number of rows of `B`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first try the computation with small matrices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining the matrices `A` and `B` (note that the dimensions are
    compatible for multiplication). As in all examples in this section, we are careful
    to include a data type specification (this may improve optimization). Then, we
    simply call `matrix_multiply`, store the result in the array `C`, and print the
    three matrices. The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that the algorithm is correct by manually checking a few entries.
    Alternatively, we can check whether the result agrees with the built-in matrix
    multiplication, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything seems to be fine. Now, we want to define some larger random matrices,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In a 64-bit architecture, the preceding lines of code will automatically produce
    matrices of 64-bit floats. Next, we multiply the matrices and time the result
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding computation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The timing results will, of course, differ depending on the machine running
    the code. This example was run on an Intel Core i7 processor at 3.5 GHz with 16
    GB of memory running a Microsoft Windows 7, 64-bit operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how we can quickly optimize this function. First, load the `jit`
    function from the `Numba` module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define the function with the `@jit` decorator preceding it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the only change to the code is the addition of the decorator. (We
    also changed the name of the function to avoid confusion, but this is not necessary.)
    Decorators are an advanced Python topic, but we do not need to go into the details
    of how they work. More information about decorators is available in the excellent
    blog postings by Simeon Franklin at [http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now time our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the resultant output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a 260-fold improvement with a single line of code! You should keep
    things in perspective here since this kind of acceleration cannot be expected
    for generic code. Remember that we wrote our code purposefully in a way that does
    not use the already-optimized functions from `NumPy`. For the sake of comparison
    and full disclosure, let''s compare this with the built-in `dot()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: So, even with acceleration, our function cannot compete with built-in `NumPy`.
    We emphasize again that the goal of this section is to present an overview of
    acceleration techniques and not delve deeply into sophisticated optimization methods.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth having some understanding of how the `@jit` decorator works. When
    a function decorated by `@jit` is called, the library attempts to infer the data
    type of the arguments and return value, and on the fly produces a compiled version
    of the function and then calls it. The result is a function call that is comparable
    to code written in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of letting the type of arguments and return value be inferred, it is
    possible to specify the data types, which may result in improved performance.
    The following table consists of the data types supported and the abbreviations
    used by `Numba`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Abbreviation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `b1` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool_` | `b1` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `u1` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8` | `u1` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16` | `u2` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | `u4` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | `u8` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `i1` |'
  prefs: []
  type: TYPE_TB
- en: '| `int8` | `i1` |'
  prefs: []
  type: TYPE_TB
- en: '| `int16` | `i2` |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | `i4` |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | `i8` |'
  prefs: []
  type: TYPE_TB
- en: '| `float_` | `f4` |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `f4` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `f8` |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `f8` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | `c8` |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | `c16` |'
  prefs: []
  type: TYPE_TB
- en: 'These names are all defined in the `Numba` module. For example, to define a
    function that adds two floating-point values, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the decorator syntax, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies a function that takes two `float64` arguments and returns a
    `float64` value. The function is then called, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the expected result. However, if we try something like the following
    code, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It is, however, possible to use arrays with the `@jit` decorator. To define
    a function that adds two one-dimensional arrays, one would use the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note how a vector is specified. A two-dimensional array is denoted by `f8[:,:]`,
    a three-dimensional array by `f8[:,:,:]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`NumbaPro` is the commercial version of `Numba` and adds several enhancements.
    We will focus on parallel processing using the **Graphics Processing Unit** (**GPU**)
    as an example of an exciting new technology that is made easily available in a
    notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: To run the examples that follow, the reader must have `NumbaPro`, a `CUDA`-compatible
    GPU (henceforth called the "device"), and the latest `CUDA`-compatible driver.
  prefs: []
  type: TYPE_NORMAL
- en: A list of `CUDA`-compatible devices can be found at [https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus).
    After verifying that you have a compatible device, download and install the latest
    version of the `CUDA SDK` from [https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads)
    for the appropriate platform. The `CUDA` toolkit comes with several examples that
    you can use to test the installation.
  prefs: []
  type: TYPE_NORMAL
- en: The `NumbaPro` download is available at [https://store.continuum.io/cshop/accelerate/](https://store.continuum.io/cshop/accelerate/).
    Download and install the `Accelerate` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the setup, start an IPython notebook and run the following in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If everything is fine, this will print a list of the `CUDA` libraries installed
    by Anaconda as well as a list of the `CUDA`-compatible devices available in your
    system. You will also see a `PASSED` message at the end of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `CUDA` programming is a relatively easy path to massive parallelism,
    there are still some concepts that have to be mastered before we can tackle our
    first `CUDA` program. We will outline the basics of the architecture here, discussing
    only enough to run the examples that follow. For a complete specification, see
    the **CUDA Programming Guide**, available at [http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model](http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model).
  prefs: []
  type: TYPE_NORMAL
- en: GPUs were originally designed to process rendering operations with greater speed
    than the computer's CPU is capable of. This processing acceleration is achieved,
    in large measure, by massively parallelizing the graphical operations required
    by the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: A `CUDA`-compatible GPU consists of an array of **Streaming Multiprocessors**
    (**SMs**). Each one of the SMs, by itself, cannot compete with current CPUs in
    terms of speed. However, the fact that many SMs can cooperate to solve a problem
    more than compensates for that. The SMs can also access memory that resides in
    the GPU, referred to as *device memory*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `CUDA`, there is a strict separation between code that runs in the CPU and
    code that runs in the device (the GPU). One particular restriction is that while
    CPU code can only access regular computer memory, device code can only access
    device memory. Code that runs in the device is specified in a function called
    a *kernel*. The kernel is compiled into a low-level language that is understood
    by the SMs and runs into each SM asynchronously (meaning that each SM proceeds
    at its own pace unless special synchronization instructions are found). Thus,
    a simple computation in `CUDA` usually requires the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Transfer input data from the computer memory to the device memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the kernel in the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transfer output data from the device memory to the computer memory so that it
    is accessible to the CPU again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you will see, the memory transfers are made transparent by Python `CUDA`.
    (There is still the possibility to control it programmatically if needed.)
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is launched simultaneously in an array of SMs, and each thread proceeds
    independently with the computation. Each SM can run several threads in parallel
    and can access all the device's memory. (The architecture is more complicated,
    and there are other kinds of memory available that will not be discussed here.)
    In the simplest case, each thread will access only a few memory areas, each containing
    a 64-bit floating value, and the memory accessed by a thread is never accessed
    by any other thread. So, there is no need for synchronization. In more complex
    problems, synchronization may be a major issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of threads being run features a two-level array structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Threads are organized in **blocks**. Each block is an array of threads with
    up to `3` dimensions The dimensions of a block are stored in a variable called
    `blockDim`. Threads in a block are identified by the variable, `threadIdx`. This
    is a structure with three integer fields: `threadIdx.x`, `threadIdx.y`, and `threadIdx.z`.
    These fields uniquely identify each thread in the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blocks are organized in a **grid**. The grid is an array of blocks with up
    to `3` dimensions. The dimensions of the grid are stored in a variable called
    `gridDim`. Blocks in a grid are identified by the variable, `gridIdx`. This is
    a structure with three integer fields: `gridIdx.x`, `gridIdx.y`, and `gridIdx.z`.
    These fields uniquely identify each block in the grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of this organizational structure is given in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accelerating computations with Numba and NumbaPro](img/8341OS_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, `gridDim` is `(2, 3, 1)` since there are two rows
    and three columns of blocks (and a single space dimension). All the blocks in
    the grid are one-dimensional, so `blockDim` is `(4, 1, 1)`. The third thread in
    the first block of the bottom row, for example, is identified by the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, each individual thread has access to this identifying information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key point of the `CUDA` architecture is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All threads in the same block always run concurrently in a single SM until all
    threads in the block have terminated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different blocks can run concurrently or serially depending on the availability
    of an SM to carry out the computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now ready to define the kernel using Python `CUDA`. We will write a
    function that computes the sum of two vectors in the GPU. Run the following code
    in a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We assume that there is only one block of threads, and each thread is responsible
    for adding the elements of the array at a single position. The array position
    that a thread is responsible for is identified by the value of `threadIdx.x`.
    Note that the kernel has no return value. We need to specify an array, `result`,
    to hold the return value of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how this function is called. Note that the grid and block geometry
    is not defined in the kernel. (The kernel can obtain geometry information if necessary;
    more on that later.) This is done when the kernel is launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The main point in this code is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line launches the kernel in a grid with `1` block, with `5` threads
    in the block. Both the grid and the blocks are one-dimensional. Let''s now add
    larger vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code are essentially the same as before but a little
    more generic in that the size of the array can be changed. What we want to do
    is increase the size of `n`. If you try a value such as `n=10000`, an error of
    type `CUDA_ERROR_INVALID_VALUE` occurs. The problem is that there is a hard limit
    on the number of threads that can be run by a single SM, that is, there is a limit
    to the number of threads that can be executed in a single block. To be able to
    handle large vectors, we need to modify the code so that it can handle multiple
    blocks. To this end, change the definition of the `sum()` function in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is that we include an argument of type `int32` to hold
    the size of the arrays being added. The main point now is that threads in different
    blocks must address different areas of memory, so the computation of the index
    `i` associated to a thread is more complicated. Essentially, we must know the
    number of blocks that come before the current block, multiply that by the block
    dimension, and add the current thread index. Then, before adding the relevant
    memory positions, we check if the index is valid. This prevents the thread from
    accessing areas that are not part of the input/output arrays and is an essential
    check in more complex code. To test the code, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should run without a hitch. Note that we are specifying a
    grid with `1000` blocks and `64` threads per block. The number of blocks in a
    grid is unlimited, the device being responsible for allocating the SMs in an optimal
    way. Note that the number of blocks must be large enough to cover the input/output
    arrays. In our case, this means `blockDim.x * gridDim.x >= n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to compute with large vectors. Try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The reader should experiment with different values of `n`, `bd`, and `gd`. Remember
    that the maximum value of `gd` depends on the device in your computer. An interesting
    experiment is to check how the computation scales for larger values of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the use of advanced mathematical algorithms in `SciPy`,
    including solving equations and finding optimal values, integration, and differential
    equations. The chapter concluded with a discussion on using parallelization in
    the GPU to accelerate computations.
  prefs: []
  type: TYPE_NORMAL
