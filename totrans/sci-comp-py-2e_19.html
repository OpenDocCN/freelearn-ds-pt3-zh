<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Comprehensive Examples
                </header>
            
            <article>
                
<p>In this chapter, we will present some comprehensive and longer examples together with a brief introduction to the theoretical background and the examples' complete implementation. Here, we want to show you how the concepts defined in this book are used in practice.</p>
<p class="mce-root">The following topics are covered in this chapter:</p>
<ul>
<li>Polynomials </li>
<li>The polynomial class</li>
<li>Spectral clustering</li>
<li>Solving initial value problems</li>
</ul>
<h1 id="uuid-3e6db758-d0d0-4ea3-b81c-1101cea306ec">19.1 Polynomials</h1>
<p>First, we will demonstrate the power of the Python constructs presented so far by designing a class for polynomials. </p>
<p>Note that this class differs conceptually from the class<span> </span><kbd>numpy.poly1d</kbd>.</p>
<p> We will give some theoretical background, which will lead us to a list of requirements, and then we will give the code, with some comments.</p>
<h2 id="uuid-81339051-3c33-424f-ae39-93eeb2a0c488">19.1.1 Theoretical background</h2>
<p>A polynomial <sub><img class="fm-editor-equation" src="assets/cf676805-9214-4814-86d5-3f6ddf906703.png" style="width:19.67em;height:1.42em;"/></sub> is defined by its degree, representation, and coefficients. The polynomial representation shown in the preceding equation is called a <em>monomial representation</em>. In this representation, the polynomial is written as a linear combination of monomials <img class="fm-editor-equation" src="assets/25b413e8-ec70-4273-8da1-e78fd46d3204.png" style="width:1.25em;height:1.42em;"/>.</p>
<p>Alternatively, the polynomial can be written in:</p>
<ul>
<li><em>Newton representation</em> with the coefficients <img class="fm-editor-equation" src="assets/2e618d07-978d-4237-bb3b-49555b6fe6e6.png" style="width:0.83em;height:0.83em;"/> and <img class="fm-editor-equation" src="assets/776c7cef-d36a-4f49-8901-51d328d1e685.png" style="width:0.58em;height:0.58em;"/> points, <img class="fm-editor-equation" src="assets/70f4144b-4316-4d28-b040-817d7ab6231f.png" style="width:6.50em;height:1.00em;"/>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/176d225f-eaa2-4651-81a8-8553ef1c652a.png" style="width:40.50em;height:1.50em;"/></p>
<ul>
<li><em>Lagrange representation </em>with the coefficients <sub><img class="fm-editor-equation" src="assets/18da50b7-20fb-43eb-9604-eb89b6c8a06e.png" style="width:0.92em;height:0.92em;"/></sub> and <sub><img class="fm-editor-equation" src="assets/01acca46-18e0-49c4-953b-9c7ea04ef10e.png" style="width:2.25em;height:0.83em;"/></sub> points, <img class="fm-editor-equation" src="assets/a116db99-24f1-4ab8-a73d-0faa9559dca3.png" style="width:5.92em;height:0.92em;"/>:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cee88b71-4869-478a-a99b-3d922588ce2d.png" style="width:21.42em;height:1.42em;"/></p>
<p style="padding-left: 60px">with the cardinal functions:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/53259454-4064-48ab-98ae-ba040828abed.png" style="width:11.67em;height:2.75em;"/> </div>
<p>There are infinitely many representations, but we restrict ourselves here to these three typical ones.</p>
<p>A polynomial can be determined from interpolation conditions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/7b6f78ad-9108-4210-861c-da2b195b4552.png" style="width:11.58em;height:1.33em;"/></p>
<p>with the given distinct values <img class="fm-editor-equation" src="assets/df8177e3-c79a-47ce-bc35-4799dd8db630.png" style="width:1.25em;height:1.08em;"/> and arbitrary values <img class="fm-editor-equation" src="assets/ac1fbb98-6657-4d5e-9e9f-8a7a253adf9d.png" style="width:0.83em;height:0.83em;"/> as input. In the Lagrange formulation, the interpolation polynomial is directly available, as its coefficients are the interpolation data. The coefficients for the interpolation polynomial in Newton representation can be obtained by a recursion formula, called the divided differences formula:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f9754f5f-e78a-4dbb-ab86-37ae62e43ecf.png" style="width:4.17em;height:1.08em;"/></p>
<p>and </p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d4e1d2e6-7cbb-4959-944b-b8dbde44a6d9.png" style="width:10.92em;height:2.83em;"/></p>
<p>We then obtain the coefficients by <img class="fm-editor-equation" src="assets/ea7657c7-0560-412c-b631-ab76258bc65a.png" style="width:4.42em;height:1.08em;"/>.</p>
<p>The coefficients of the interpolation polynomial in monomial representation are obtained by solving a linear system:</p>
<div class="CDPAlignLeft CDPAlign">                                                     <img src="assets/b1c6949c-0d77-4b76-aa57-b3ba3ddb7e0a.png" style="width:22.83em;height:7.08em;"/></div>
<p>A matrix that has a given polynomial <img class="fm-editor-equation" src="assets/2baead6e-97d1-4d9e-8b27-d18720ef5356.png" style="width:0.50em;height:0.75em;"/> (or a multiple of it) as its characteristic polynomial is called a <em>companion matrix</em>. The eigenvalues of the companion matrix are the zeros (roots) of the polynomial. An algorithm for computing the zeros of <img class="fm-editor-equation" src="assets/5b023d20-84ee-4e91-b5e8-f6620cfb7579.png" style="width:0.75em;height:1.17em;"/> can be constructed by first setting up its companion matrix and then computing the eigenvalues with <kbd>scipy.linalg.eig</kbd>. The companion matrix for a polynomial in Newton representation reads as follows:</p>
<div class="CDPAlignLeft CDPAlign">                                                               <img src="assets/c8b727bb-a74b-4a36-b9a6-b814fe568d52.png" style="width:20.00em;height:9.33em;"/></div>
<h2 id="uuid-b3e3f6f7-578e-4b28-bc32-74d4a56aeecc">19.1.2 Tasks</h2>
<p>We can now formulate some programming tasks:</p>
<ol>
<li>Write a class called <kbd>PolyNomial</kbd> with the <span>attributes</span> <kbd>points</kbd>, <kbd>degree</kbd>, <kbd>coeff</kbd>, and <kbd>basis</kbd>, where:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>points</kbd> is a list of tuples <img class="fm-editor-equation" src="assets/4afd74eb-4a3f-4f69-bb79-76ec30fe0648.png" style="width:3.42em;height:1.33em;"/>.</li>
<li style="padding-left: 30px"><kbd>degree</kbd> is the degree of the corresponding interpolation polynomial.</li>
<li style="padding-left: 30px"><kbd>coeff</kbd> contains the polynomial coefficients.</li>
<li style="padding-left: 30px"><kbd>basis</kbd> is a string stating which representation is used.</li>
</ul>
<ol start="2">
<li>Provide the class with a method for evaluating the polynomial at a given point.</li>
<li>Provide the class with a method called <kbd>plot</kbd> that plots the polynomial over a given interval.</li>
</ol>
<ol start="4">
<li>Write a method called <kbd>__add__</kbd> that returns a polynomial that is the sum of two polynomials. Be aware that only in the monomial case the sum can be computed by just summing up the coefficients.</li>
<li>Write a method that computes the coefficients of the polynomial represented in a monomial form.</li>
<li>Write a method that computes the polynomial's companion matrix.</li>
<li>Write a method that computes the zeros of the polynomial by computing the eigenvalues of the companion matrix.</li>
<li>Write a method that computes the polynomial that is the <img class="fm-editor-equation" src="assets/9ca472ad-554e-4ea9-b316-765cf23dbeac.png" style="width:0.58em;height:1.42em;"/><sup>th</sup> derivative of the given polynomial.</li>
<li>Write a method that checks whether two polynomials are equal. Equality can be checked by comparing all coefficients (zero leading coefficients should not matter).</li>
</ol>
<h1 id="uuid-7daad4c3-bfa9-41d9-9194-d34cd473f9a5">19.1.3 The polynomial class</h1>
<p>Let's now design a polynomial base class based on a monomial formulation of the polynomial. The polynomial can be initialized either by giving its coefficients with respect to the monomial basis or by giving a list of interpolation points, as follows:</p>
<pre>import scipy.linalg as sl<br/>import matplotlib.pyplot as mp

class PolyNomial:
    base='monomial'
    def __init__(self,**args):
        if 'points' in args:
            self.points = array(args['points'])
            self.xi = self.points[:,0]
            self.coeff = self.point_2_coeff()
            self.degree = len(self.coeff)-1
        elif 'coeff' in args:
            self.coeff = array(args['coeff'])
            self.degree = len(self.coeff)-1
            self.points = self.coeff_2_point()
        else:
            self.points = array([[0,0]])
            self.xi = array([1.])
            self.coeff = self.point_2_coeff()
            self.degree = 0</pre>
<p>The <span>method</span> <kbd>__init__</kbd> of the new class uses the <span>construction </span><kbd>**args</kbd> as discussed in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.2.5</a>: <em>Variable number of arguments</em>. If no arguments are given, a zero polynomial is assumed. If the polynomial is given by interpolation points, the method used to compute the coefficients by solving a Vandermonde system is given as follows:</p>
<pre>def point_2_coeff(self):
    return sl.solve(vander(self.x),self.y)</pre>
<p>From <sub><img class="fm-editor-equation" src="assets/bcadae8d-6f6c-4b63-b486-8cdf1416a059.png" style="width:0.50em;height:0.83em;"/></sub> given coefficients, <sub><img class="fm-editor-equation" src="assets/801a6016-08c3-4345-bec7-9b624ca74d69.png" style="width:0.58em;height:0.92em;"/></sub> interpolation points are constructed by:</p>
<pre>def coeff_2_point(self):
    points = [[x,self(x)] for x in linspace(0,1,self.degree+1)]
    return array(points)</pre>
<p>The <span>command </span><kbd>self(x)</kbd> does a polynomial evaluation, which is done by providing a method <kbd>__call__</kbd>:</p>
<pre>def __call__(self,x):
    return polyval(self.coeff,x)</pre>
<p>(See also the example for the method <kbd>__call__</kbd> in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml"/><a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.1.5</a>: <em>Special methods.</em>) Here, this method uses the NumPy command <kbd>polyval</kbd>. As a next step, we just add for convenience two methods, which we decorate with the <kbd>property</kbd> decorator (see also <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.8</a>: <em>Functions as decorators</em><em>)</em>:</p>
<pre>@property
def x(self):
    return self.points[:,0]
@property
def y(self):
    return self.points[:,1]</pre>
<p>Let's explain what is going on here. We define a method to extract the <img class="fm-editor-equation" src="assets/51485369-65e9-4da0-811d-1947fbb24f27.png" style="width:0.67em;height:0.75em;"/><em> </em>values of the data, which were used to define the polynomial. Similarly, a method to extract the <img class="fm-editor-equation" src="assets/3a9672e4-ff7e-43b3-8049-7fc79880852c.png" style="width:0.67em;height:1.17em;"/><em> </em>values of the data is defined. With the <kbd>property</kbd> decorator, the result of calling the method is presented as if it were just an attribute of the polynomial. There are two coding alternatives:</p>
<ol>
<li>We use a method call:</li>
</ol>
<pre style="padding-left: 60px">def x(self):
    return self.points[:,0]</pre>
<p style="padding-left: 60px"> This gives access to the <img class="fm-editor-equation" src="assets/4b12e4f2-67b2-4d6f-b995-0911ae5ca323.png" style="width:0.75em;height:0.83em;"/><em> </em>values by the call: <kbd>p.x()</kbd>.</p>
<ol start="2">
<li>We use the <kbd>property</kbd> decorator. It permits us to access the <img class="fm-editor-equation" src="assets/35b8b3fb-62ea-4a59-9044-bcb3cffd718c.png" style="width:1.00em;height:1.08em;"/><em> </em>values simply by using this statement: <kbd>p.x</kbd>. We choose here the second variant.</li>
</ol>
<p>It is always a good practice to define a <kbd>__repr__</kbd> method (see also <span><a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.1.5</a>: </span><em>Special methods.</em>). At least for a quick check of the results, this method is useful:</p>
<pre>def __repr__(self):
    txt  = f'Polynomial of degree {self.degree} \n'
    txt += f'with coefficients {self.coeff} \n in {self.base} basis.'
    return txt</pre>
<p>We now provide a method for plotting the polynomial, as follows:</p>
<pre>margin = .05
plotres = 500
def plot(self,ab=None,plotinterp=True):
    if ab is None: # guess a and b
       x = self.x
       a, b = x.min(), x.max()
       h = b-a
       a -= self.margin*h
       b += self.margin*h
    else:
       a,b = ab
    x = linspace(a,b,self.plotres)
    y = vectorize(self.__call__)(x)
    mp.plot(x,y)
    mp.xlabel('$x$')
    mp.ylabel('$p(x)$')
    if plotinterp:
        mp.plot(self.x, self.y, 'ro')</pre>
<p>Note the use of the <span>command </span><kbd>vectorize</kbd> (see <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section 4.8</a>: <em>Functions acting on arrays</em>). The <span>method </span><kbd>__call__</kbd> is specific to the monomial representation and has to be changed if a polynomial is represented in another way. This is also the case for the computation of the polynomial's companion matrix:</p>
<pre>def companion(self):
    companion = eye(self.degree, k=-1)
    companion[0,:] -= self.coeff[1:]/self.coeff[0]
    return companion</pre>
<p>Once the companion matrix is available, the zeros of the polynomial are given by its eigenvalues:</p>
<pre>def zeros(self):
    companion = self.companion()
    return sl.eigvals(companion)</pre>
<p>To this end, the module <kbd>scipy.linalg</kbd> has to be imported first as <kbd>sl</kbd>.</p>
<h2 id="uuid-f94f1906-1617-47cb-a809-6c8a59e92972">19.1.4 Usage examples of the polynomial class</h2>
<p>Let's give some usage examples.</p>
<p>First, we create a polynomial instance from the given interpolation points:</p>
<pre>p = PolyNomial(points=[(1,0),(2,3),(3,8)])</pre>
<p>The polynomial's coefficients with respect to the monomial basis are available as an attribute of <kbd>p</kbd>:</p>
<pre>p.coeff # returns array([ 1., 0., -1.]) (rounded)</pre>
<p>This corresponds to the polynomial <img class="fm-editor-equation" src="assets/7d283009-8ea6-4ff2-b454-6ef8dba0c847.png" style="width:9.00em;height:1.33em;"/> . The default plot of the polynomial, obtained by <kbd>p.plot((-3.5,3.5))</kbd>, results in the following figure (<em>Figure 19.1</em>):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/25f8b282-b144-4a5b-9172-0f4b0a6bb942.png" style="width:27.25em;height:21.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 19.1: Result of the polynomial plot method</div>
<p>Finally, we compute the zeros of the polynomial, which in this case are two real numbers:</p>
<pre>pz = p.zeros() # returns array([-1.+0.j, 1.+0.j])</pre>
<p>The result can be verified by evaluating the polynomial at these points:</p>
<pre>p(pz) # returns array([0.+0.j, 0.+0.j])</pre>
<h2 id="uuid-2b54763b-d0fb-4e52-b56e-4026cf9f8127">19.1.5 Newton polynomial</h2>
<p>The class  <kbd>NewtonPolyNomial</kbd> defines a polynomial described with respect to the Newton basis. We let it inherit some common methods from the polynomial base class, for example, <kbd>polynomial.plot</kbd>, <kbd>polynomial.zeros</kbd>, and even parts of the <kbd>__init__</kbd> method, by using the <span>command </span><kbd>super</kbd> (see <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.5</a>: S<em>ubclasses and inheritance</em>):</p>
<pre>class NewtonPolynomial(PolyNomial):
    base = 'Newton'
    def __init__(self,**args):
        if 'coeff' in args:
            try:
                self.xi = array(args['xi'])
            except KeyError: 
                raise ValueError('Coefficients need to be given'
                'together with abscissae values xi')
        super(NewtonPolynomial, self).__init__(**args)</pre>
<p>Once the interpolation points are given, the computation of the coefficients is performed by:</p>
<pre>def point_2_coeff(self):
    return array(list(self.divdiff()))</pre>
<p>We used divided differences for computing the Newton representation of the polynomial, which is programmed as a generator here (see <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.3.1</a>: <em>Generators</em> and <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.4</a>: <em>List-filling patterns</em>):</p>
<pre>def divdiff(self): 
    xi = self.xi
    row = self.y
    yield row[0]
    for level in range(1,len(xi)):
        row = (row[1:] - row[:-1])/(xi[level:] - xi[:-level])
        if allclose(row,0): # check: elements of row nearly zero
           self.degree = level-1
           break
        yield row[0]</pre>
<p>Let's briefly check how this works:</p>
<pre># here we define the interpolation data: (x,y) pairs<br/>pts = array([[0.,0],[.5,1],[1.,0],[2,0.]]) 

pN = NewtonPolynomial(points=pts) # this creates an instance of the
                                  # polynomial class
pN.coeff # returns the coefficients array([0. , 2. , -4. , 2.66666667])
print(pN)</pre>
<p>The <span>function </span><kbd>print</kbd> executes the <span>method </span><kbd>__repr__</kbd> of the base class and returns the following text:</p>
<pre>Polynomial of degree 3
 with coefficients [ 0.     2.    -4.      2.66666667]
 in Newton basis.</pre>
<p>The polynomial evaluation is different from the corresponding method of the base class. The <span>method </span><kbd>NewtonPolyNomial.__call__</kbd> needs to override <kbd>Polynomial.__call__</kbd>:</p>
<pre>def __call__(self,x):
    # first compute the sequence 1, (x-x_1), (x-x_1)(x-x_2),...
    nps = hstack([1., cumprod(x-self.xi[:self.degree])])
    return self.coeff@nps</pre>
<p>Finally, we give the code for the companion matrix, which overrides the corresponding method of the parent class, as follows:</p>
<pre>def companion(self):
    degree = self.degree
    companion = eye(degree, k=-1)
    diagonal = identity(degree,dtype=bool)
    companion[diagonal] = self.x[:degree]
    companion[:,-1] -= self.coeff[:degree]/self.coeff[degree]
    return companion</pre>
<p>Note the use of Boolean arrays. The exercises will further build on this foundation.</p>
<h1 id="uuid-ae58e42f-60a8-4add-8cdb-fbb3ebc53705">19.2 Spectral clustering</h1>
<p>An interesting application of eigenvectors is for clustering data. Using the eigenvectors of a matrix derived from a distance matrix, unlabeled data can be separated into groups. Spectral clustering methods get their name from the use of the spectrum of this matrix. A distance matrix for <img class="fm-editor-equation" src="assets/e27f1d49-c801-4539-8009-9cae5853b3cf.png" style="width:0.75em;height:0.75em;"/> elements (for example, the pairwise distance between data points) is an <img class="fm-editor-equation" src="assets/a36e8b17-7e0b-488d-96b3-29c79c5257f2.png" style="width:2.75em;height:0.75em;"/> symmetric matrix. Given such an <img class="fm-editor-equation" src="assets/6b3e95b7-0207-425e-b217-6a476a631685.png" style="width:2.75em;height:0.75em;"/> distance matrix <img class="fm-editor-equation" src="assets/3972f882-789e-45e6-afcc-d1663436700b.png" style="width:1.08em;height:0.92em;"/> with distance values <sub><img class="fm-editor-equation" src="assets/3fc43757-4ebf-4dd5-8163-c0a68970c633.png" style="width:2.00em;height:1.17em;"/></sub>, we can create the Laplacian matrix of the data points as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f5e9c5d5-826b-4e10-a5bb-94ca67e03e66.png" style="width:12.67em;height:1.42em;"/></p>
<p>Here, <img class="fm-editor-equation" src="assets/d9020f81-cd8b-4d22-bb23-c67c1326984c.png" style="width:0.42em;height:0.92em;"/>  is the identity matrix and <img class="fm-editor-equation" src="assets/04f5ec10-48e3-4051-822a-b701c6660c95.png" style="width:1.00em;height:1.08em;"/> is the diagonal matrix containing the row sums of <img class="fm-editor-equation" src="assets/a68ab07c-1d27-4a51-ba39-01c32f498aef.png" style="width:1.25em;height:1.00em;"/>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/30e0893d-305e-4689-80f9-af0988bad720.png" style="width:13.08em;height:2.67em;"/></p>
<p>The data clusters are obtained from the eigenvectors of <em>L</em>. In the simplest case of data points with only two classes, the first eigenvector (that is, the one corresponding to the largest eigenvalue) is often enough to separate the data.</p>
<p>Here is an example of simple two-class clustering. The following code creates some 2D data points and clusters them based on the first eigenvector of the Laplacian matrix:</p>
<pre>import scipy.linalg as sl

# create some data points
n = 100
x1 = 1.2 * random.randn(n, 2)
x2 = 0.8 * random.randn(n, 2) + tile([7, 0],(n, 1))
x = vstack((x1, x2))

# pairwise distance matrix
M = array([[ sqrt(sum((x[i] - x[j])**2)) 
             for i in range(2*n)]
             for j in range(2 * n)])
 
# create the Laplacian matrix
D = diag(1 / sqrt( M.sum(axis = 0) ))
L = identity(2 * n) - dot(D, dot(M, D))

# compute eigenvectors of L
S, V = sl.eig(L)
# As L is symmetric the imaginary parts
# in the eigenvalues are only due to negligible numerical errors S=S.real
V=V.real</pre>
<p>The eigenvector corresponding to the largest eigenvalue gives the grouping (for example, by thresholding at <img class="fm-editor-equation" src="assets/e6b3a21e-af03-46d9-80e9-3822e2be13d2.png" style="width:0.75em;height:1.25em;"/>) and can be shown with:</p>
<pre>largest=abs(S).argmax()
plot(V[:,largest])</pre>
<p>The following figure (<em>Figure 19.2</em>) shows the result of spectral clustering of a simple two-class dataset:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d21da077-88f0-432f-9653-866b8bd452e5.png" style="width:25.75em;height:20.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 19.2: The result of a simple two-class clustering</div>
<p>For more difficult datasets and more classes, one usually takes the <img class="fm-editor-equation" src="assets/67e01793-7925-419d-9a24-2f5622e534c5.png" style="width:0.42em;height:0.67em;"/> eigenvectors corresponding to the <img class="fm-editor-equation" src="assets/8a74fede-f0f6-4984-ae52-1fd9ae82de90.png" style="width:0.42em;height:0.67em;"/> largest eigenvalues and then clusters the data with some other method, but using the eigenvectors instead of the original data points. A common choice is the <img class="fm-editor-equation" src="assets/2e934e12-050c-43a9-b47d-31e0f3116490.png" style="width:0.50em;height:0.83em;"/>-means clustering algorithm, which is the topic of the next example.</p>
<p>The eigenvectors are used as input to <img class="fm-editor-equation" src="assets/8ec8c440-a221-41d9-a7e7-5e81d4aa3d23.png" style="width:0.58em;height:0.92em;"/>-means clustering, as follows:</p>
<pre>import scipy.linalg as sl
import scipy.cluster.vq as sc
# simple 4 class data
x = random.rand(1000,2)
ndx = ((x[:,0] &lt; 0.4) | (x[:,0] &gt; 0.6)) &amp; \
                     ((x[:,1] &lt; 0.4) | (x[:,1] &gt; 0.6))
x = x[ndx]
n = x.shape[0]

# pairwise distance matrix
M = array([[ sqrt(sum((x[i]-x[j])**2)) for i in range(n) ]
           for j in range(n)])

# create the Laplacian matrix
D = diag(1 / sqrt( M.sum(axis=0) ))
L = identity(n) - dot(D, dot(M, D))

# compute eigenvectors of L
_,_,V = sl.svd(L)

k = 4
# take k first eigenvectors
eigv = V[:k,:].T

# k-means
centroids,dist = sc.kmeans(eigv,k)
clust_id = sc.vq(eigv,centroids)[0]</pre>
<p>Note that we computed the eigenvectors here using the singular value decomposition <kbd>sl.svd</kbd>. As <em><strong>L</strong></em> is symmetric, the result is the same as if we had used <kbd>sl.eig</kbd>, but <kbd>svd</kbd> gives the eigenvectors already ordered corresponding to the ordering of the eigenvalues. We also used throw-away variables. <kbd>svd</kbd> returns a list with three arrays, the left and right singular vectors, <kbd>U</kbd> and <kbd>V</kbd>, and the singular values, <kbd>S</kbd>, as follows:</p>
<pre>U, S, V = sl.svd(L)</pre>
<p>As we do not need <kbd>U</kbd> and <kbd>S</kbd> here, we can throw them away when unpacking the return value of <kbd>svd</kbd>:</p>
<pre>_, _, V = sl.svd(L)</pre>
<p>The result can be plotted using:</p>
<pre>for i in range(k):
    ndx = where(clust_id == i)[0]
    plot(x[ndx, 0], x[ndx, 1],'o')
axis('equal')</pre>
<p>The following figure shows the result of spectral clustering of a simple <em>multiclass dataset:</em></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d6c2329b-1d89-463c-ae70-1b9a5f9ee6b3.png" style="width:20.33em;height:16.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 19.3: An example of the spectral clustering of a simple four-class dataset</div>
<div class="CDPAlignCenter"/>
<h1 id="uuid-78e6b4ac-65d6-448c-9686-1ecd375754d0">19.3 Solving initial value problems</h1>
<p>In this section, we will consider the mathematical task of numerically solving a system of ordinary equations for given initial values:</p>
<p class="CDPAlignCenter CDPAlign"><em><img class="fm-editor-equation" src="assets/e0418f42-aa8c-4b88-8fce-613f81f6b860.png" style="width:19.50em;height:1.58em;"/>.</em></p>
<p>The solution to this problem is a function <img class="fm-editor-equation" src="assets/b2d66ae4-6c74-4bba-996c-d8e96dfe0de4.png" style="width:0.42em;height:0.75em;"/>. A numerical method computes approximations, <img class="fm-editor-equation" src="assets/86022693-bb97-4372-8e87-d5da6318504d.png" style="width:5.17em;height:1.42em;"/> at discrete  communications points, <img class="fm-editor-equation" src="assets/eca4b607-0793-4c58-b3e8-ea1fc795b35d.png" style="width:0.83em;height:1.08em;"/>, within the interval of interest <img class="fm-editor-equation" src="assets/623b90f9-82a7-4c3d-8b57-3e05a6e609bb.png" style="width:2.83em;height:1.25em;"/>. We collect the data that describes the problem in a class as follows:</p>
<pre>class IV_Problem:
    """
    Initial value problem (IVP) class
    """
    def __init__(self, rhs, y0, interval, name='IVP'):
        """
        rhs 'right hand side' function of the ordinary differential
                                                   equation f(t,y)
        y0 array with initial values
        interval start and end value of the interval of independent
        variables often initial and end time
        name descriptive name of the problem
        """
        self.rhs = rhs
        self.y0 = y0
        self.t0, self.tend = interval
        self.name = name</pre>
<p>The differential equation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/72d19335-7a55-49bd-ab95-52b19bba506a.png" style="width:25.92em;height:2.92em;"/></p>
<p>describes a mathematical pendulum; <em><sub><img class="fm-editor-equation" src="assets/1f7d35f1-bd53-44fd-86b1-227069293644.png" style="width:1.25em;height:1.08em;"/> </sub></em>is its angle with respect to the vertical axis, <em><strong>g</strong></em> is the gravitation constant, and <em><strong>l</strong></em> is its length. The initial angle is <img class="fm-editor-equation" src="assets/d2dd5a5d-e940-4681-8d88-8805e1ad95bb.png" style="width:1.58em;height:1.17em;"/> and the initial angular velocity is zero.</p>
<p>The pendulum problem becomes an instance of the problem class, as follows:</p>
<pre>def rhs(t,y):
    g = 9.81
    l = 1.
    yprime = array([y[1], g / l * sin(y[0])])
    return yprime
 
pendulum = IV_Problem(rhs, array([pi / 2, 0.]), [0., 10.] ,
                      'mathem. pendulum')</pre>
<p>There might be different views on the problem at hand, leading to a different design of the class. For example, one might want to consider the interval of independent variables as a part of a solution process instead of the problem definition. The same holds when considering initial values. They might, as we did here, be considered a part of the mathematical problem, while other authors might want to allow variation of initial values by putting them as a part of the solution process.</p>
<p>The solution process is modeled as another class:</p>
<pre>class IVPsolver:
    """
    IVP solver class for explicit one-step discretization methods
    with constant step size
    """
    def __init__(self, problem, discretization, stepsize):
        self.problem = problem
        self.discretization = discretization
        self.stepsize = stepsize
    def one_stepper(self):
        yield self.problem.t0, self.problem.y0
        ys = self.problem.y0
        ts = self.problem.t0
        while ts &lt;= self.problem.tend:
            ts, ys = self.discretization(self.problem.rhs, ts, ys,
                                         self.stepsize)
            yield ts, ys
    def solve(self):
        return list(self.one_stepper())</pre>
<p>We continue by first defining two discretization schemes:</p>
<ul>
<li><em>Explicit Euler method</em>:</li>
</ul>
<pre style="padding-left: 60px">def expliciteuler(rhs, ts, ys, h):
    return ts + h, ys + h * rhs(ts, ys)</pre>
<ul>
<li><em>Classical Runge-Kutta four-stage method (RK4)</em>:</li>
</ul>
<pre style="padding-left: 60px">def rungekutta4(rhs, ts, ys, h):
    k1 = h * rhs(ts, ys)
    k2 = h * rhs(ts + h/2., ys + k1/2.) 
    k3 = h * rhs(ts + h/2., ys + k2/2.)
    k4 = h * rhs(ts + h, ys + k3)
    return ts + h, ys + (k1 + 2*k2 + 2*k3 + k4)/6.</pre>
<p>With these, we can create instances to obtain the corresponding discretized versions of the pendulum ODE:</p>
<pre>pendulum_Euler = IVPsolver(pendulum, expliciteuler, 0.001) 
pendulum_RK4 = IVPsolver(pendulum, rungekutta4, 0.001)</pre>
<p>We can solve the two discrete models and plot the solution and the angle difference:</p>
<pre>sol_Euler = pendulum_Euler.solve()
sol_RK4 = pendulum_RK4.solve()
tEuler, yEuler = zip(*sol_Euler)
tRK4, yRK4 = zip(*sol_RK4)
subplot(1,2,1), plot(tEuler,yEuler),\
        title('Pendulum result with Explicit Euler'),\
        xlabel('Time'), ylabel('Angle and angular velocity')
subplot(1,2,2), plot(tRK4,abs(array(yRK4)-array(yEuler))),\
        title('Difference between both methods'),\
        xlabel('Time'), ylabel('Angle and angular velocity')</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2465db96-4a0d-44db-af7f-52fb01eae181.png" style="width:28.00em;height:21.50em;"/></div>
<div class="packt_figref">Figure 19.4: Pendulum simulation with the explicit Euler method and comparison with the results of the more accurate Runge–Kutta 4 method</div>
<p>It is worthwhile discussing alternative class designs. What should be put in separate classes, what should be bundled into the same class?</p>
<ul>
<li>We strictly separated the mathematical problem from the numerical method. Where should the initial values go? Should they be part of the problem or part of the solver? Or should they be left as input parameters for the solve method of the solver instance? One might even design the program so that it allows several possibilities. The decision to use one of these alternatives depends on the future use of this program. Looping over various initial values as in parameter identification would be eased by leaving the initial values as input parameters for the solve method. On the other hand, simulating different model variants with the same initial values would make coupling the initial values to the problem preferable.</li>
<li>We presented for simplicity only solvers with a constant and given step size. Is the design of the <kbd>IVPsolver</kbd> class appropriate for a future extension of adaptive methods, where a tolerance rather than a step size is given?</li>
<li>We suggested earlier using a generator construction for the stepping mechanism. Adaptive methods need to reject steps from time to time. Is this need conflicting with the design of the stepping mechanism in <kbd>IVPsolver.onestepper</kbd>?</li>
<li>We encourage you to check the design of the two SciPy tools for solving initial values, namely <kbd>scipy.integrate.ode</kbd> and <kbd>scipy.integrate.odeint</kbd>.</li>
</ul>
<h1 id="uuid-6ae8538d-10a8-436d-9706-3c470c173ca8">19.4 Summary</h1>
<p>Most of what we explained in this book was bundled into the three longer examples in this chapter. These examples mimic code development and give prototypes, which you are encouraged to alter and confront with your own ideas.</p>
<p>You saw that code in scientific computing can have its own flavor due to its strong relationship with mathematically defined algorithms and that it is often wise to keep the relationship between code and formula visible. Python has techniques for this, as you have seen.</p>
<h1 id="uuid-5bfb0f88-0169-40b4-8082-6761b602b5a1">19.5 Exercises</h1>
<p><strong>Ex. 1:</strong> Implement a method <kbd>__add__</kbd> that constructs a new polynomial <img class="fm-editor-equation" src="assets/77fa6522-5de3-4e15-b0df-d9a450605771.png" style="width:2.75em;height:1.17em;"/> by adding two given polynomials <img class="fm-editor-equation" src="assets/724805b9-bea3-4a02-b1d4-5d81e8bd4634.png" style="width:0.67em;height:1.00em;"/> and <img class="fm-editor-equation" src="assets/e174fe97-c3d6-4bfb-a93a-1025e6028d8a.png" style="width:0.58em;height:1.00em;"/>. In monomial form, polynomials are added by just adding the coefficients, whereas in Newton form, the coefficients depend on the abscissas <img class="fm-editor-equation" src="assets/171118dd-dce4-49d6-8f04-7b4855f2b4f2.png" style="width:1.17em;height:1.00em;"/> of the interpolation points. Before adding the coefficients of both polynomials, the polynomial <img class="fm-editor-equation" src="assets/8bdd5965-3db4-42e5-9eae-f37213bda9ef.png" style="width:0.58em;height:1.00em;"/> has to get new interpolation points with the property that their abscissas <img class="fm-editor-equation" src="assets/40eb87a9-fc00-48f8-a883-b285e80c460c.png" style="width:1.08em;height:0.92em;"/> coincide with those of <img class="fm-editor-equation" src="assets/296d4fcd-75bd-4819-8c45-3e084799040e.png" style="width:0.58em;height:0.92em;"/>, and the method <kbd>__changepoints__</kbd> has to be provided for that. It should change the interpolation points and return a new set of coefficients.</p>
<p><strong>Ex. 2:</strong> Write conversion methods to convert a polynomial from Newton form into monomial form and vice versa.</p>
<p><strong>Ex. 3:</strong> Write a method called <kbd>add_point</kbd> that takes a polynomial <em>q</em> and a tuple <sub><img class="fm-editor-equation" src="assets/81f6a09d-5109-4c61-be6a-296173b0cc9a.png" style="width:2.50em;height:1.25em;"/></sub> as parameters and returns a new polynomial that interpolates <kbd>self.points</kbd> and <sub><img class="fm-editor-equation" src="assets/858f86f2-f43e-412f-8888-c5a5f8e7513f.png" style="width:3.00em;height:1.50em;"/></sub><span>.</span></p>
<p><strong>Ex. 4:</strong> Write a class called <kbd>LagrangePolynomial</kbd> that implements polynomials in Lagrange form and inherits as much as possible from the polynomial base class.</p>
<p><strong>Ex. 5:</strong> Write tests for the polynomial class.</p>


            </article>

            
        </section>
    </body></html>