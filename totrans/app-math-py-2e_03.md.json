["```py\npython3.10 -m pip install sympy jaxlib jax sympy diffrax\n```", "```py\n    class Polynomial:\n    ```", "```py\n        \"\"\"Basic polynomial class\"\"\"\n    ```", "```py\n        def __init__(self, coeffs):\n    ```", "```py\n           self.coeffs = coeffs\n    ```", "```py\n        def __repr__(self):\n    ```", "```py\n           return f\"Polynomial({repr(self.coeffs)})\"\n    ```", "```py\n        def __call__(self, x):\n    ```", "```py\n          return sum(coeff*x**i for i, coeff in enumerate(    \t        self.coeffs))\n    ```", "```py\n        def differentiate(self):\n    ```", "```py\n          \"\"\"Differentiate the polynomial and return the derivative\"\"\"\n    ```", "```py\n            coeffs = [i*c for i, c in enumerate(\n    ```", "```py\n                self.coeffs[1:], start=1)]\n    ```", "```py\n            return Polynomial(coeffs)\n    ```", "```py\n        def integrate(self, constant=0):\n    ```", "```py\n          \"\"\"Integrate the polynomial and return the integral\"\"\"\n    ```", "```py\n            coeffs = [float(constant)]\n    ```", "```py\n            coeffs += [c/i for i, c in enumerate(\n    ```", "```py\n                self.coeffs, start=1)]\n    ```", "```py\n            return Polynomial(coeffs)\n    ```", "```py\n    p = Polynomial([1, -2, 1])\n    ```", "```py\n    p.differentiate()\n    ```", "```py\n    # Polynomial([-2, 2])\n    ```", "```py\n    p.integrate(constant=1)\n    ```", "```py\n    # Polynomial([1.0, 1.0, -1.0, 0.3333333333])\n    ```", "```py\nimport sympy\n```", "```py\n    x = sympy.symbols('x')\n    ```", "```py\n    f = (x**2 - 2*x)*sympy.exp(3 - x)\n    ```", "```py\n    fp = sympy.simplify(sympy.diff(f))\n    ```", "```py\n    print(fp)  # (-x**2 + 4*x - 2)*exp(3 - x)\n    ```", "```py\n    fp2 = (2*x - 2)*sympy.exp(3 - x) - (\n    ```", "```py\n        x**2 - 2*x)*sympy.exp(3 - x)\n    ```", "```py\n    print(sympy.simplify(fp2 - fp) == 0)  # True\n    ```", "```py\n    F = sympy.integrate(fp, x)\n    ```", "```py\n    print(F)  # (x**2 - 2*x)*exp(3 - x)\n    ```", "```py\nfrom sympy.utilities import lambdify\nlam_f = lambdify(x, f)\nlam_fp = lambdify(x, fp)\n```", "```py\nlam_f(4)  # 2.9430355293715387\nlam_fp(7)  # -0.4212596944408861\n```", "```py\nlam_f(np.array([0, 1, 2]))  # array([ 0\\. , -7.3890561, 0\\. ])\n```", "```py\n    from scipy import optimize\n    ```", "```py\n    from math import exp\n    ```", "```py\n    def f(x):\n    ```", "```py\n      return x*(x - 2)*exp(3 - x)\n    ```", "```py\n    def fp(x):\n    ```", "```py\n      return -(x**2 - 4*x + 2)*exp(3 - x)\n    ```", "```py\n    optimize.newton(f, 1, fprime=fp) # Using the Newton-Raphson method\n    ```", "```py\n    # 2.0\n    ```", "```py\n    optimize.newton(f, 1., x1=1.5) # Using x1 = 1.5 and the secant method\n    ```", "```py\n    # 1.9999999999999862\n    ```", "```py\nfrom math import copysign\ndef bisect(f, a, b, tol=1e-5):\n    \"\"\"Bisection method for root finding\"\"\"\n    fa, fb = f(a), f(b)\n    assert not copysign(fa, fb) == fa, \"Function must change signs\"\n    while (b - a) > tol:\n        m = (a + b)/2 # mid point of the interval\n        fm = f(m)\n        if fm == 0:\n            return m\n        if copysign(fm, fa) == fm: # fa and fm have the same sign\n            a = m\n            fa = fm\n        else: # fb and fm have the same sign\n            b = m\n    return a\n```", "```py\noptimize.brentq(f, 1.0, 3.0)  # 1.9999999999998792\n```", "```py\nfrom scipy import integrate\n```", "```py\n    def erf_integrand(t):\n    ```", "```py\n        return np.exp(-t**2)\n    ```", "```py\n    val_quad, err_quad = integrate.quad(erf_integrand, -1.0, 1.0)\n    ```", "```py\n    # (1.493648265624854, 1.6582826951881447e-14)\n    ```", "```py\n    val_quadr, err_quadr =\n    ```", "```py\n        integrate.quadrature(\n    ```", "```py\n            erf_integrand, -1.0, 1.0)\n    ```", "```py\n    # (1.4936482656450039, 7.459897144457273e-10)\n    ```", "```py\ndef trapezium(func, a, b, n_steps):\n    \"\"\"Estimate an integral using the trapezium rule\"\"\"\n    h = (b - a) / n_steps\n    x_vals = np.arange(a + h, b, h) \n    y_vals = func(x_vals)\n    return 0.5*h*(func(a) + func(b) + 2.*np.sum(y_vals))\n```", "```py\nfrom scipy import integrate\n```", "```py\ndef f(t, y):\n    return -0.2*y\nt_range = (0, 5)\n```", "```py\nT0 = np.array([50.])\n```", "```py\ndef true_solution(t):\n    return 50.*np.exp(-0.2*t)\n```", "```py\n    sol = integrate.solve_ivp(f, t_range, T0, max_step=0.1)\n    ```", "```py\n    t_vals = sol.t\n    ```", "```py\n    T_vals = sol.y[0, :]\n    ```", "```py\n    fig, (ax1, ax2) = plt.subplots(1, 2, tight_layout=True)\n    ```", "```py\n    ax1.plot(t_vals, T_valsm \"k\")\n    ```", "```py\n    ax1.set_xlabel(\"$t$\")\n    ```", "```py\n    ax1.set_ylabel(\"$T$\")\n    ```", "```py\n    ax1.set_title(\"Solution of the cooling equation\")\n    ```", "```py\n    err = np.abs(T_vals - true_solution(t_vals))\n    ```", "```py\n    ax2.semilogy(t_vals, err, \"k\")\n    ```", "```py\n    ax2.set_xlabel(\"$t$\")\n    ```", "```py\n    ax2.set_ylabel(\"Error\")\n    ```", "```py\n    ax2.set_title(\"Error in approximation\")\n    ```", "```py\ndef euler(func, t_range, y0, step_size):\n    \"\"\"Solve a differential equation using Euler's method\"\"\"\n    t = [t_range[0]]\n    y = [y0]\n    i = 0\n```", "```py\n    while t[i] < t_range[1]:\n        i += 1\n        t.append(t[i-1] + step_size)  # step t\n        y.append(y[i-1] + step_size*func(\n           t[i-1], y[i-1]))   # step y\n    return t, y\n```", "```py\n    def predator_prey_system(t, y):\n    ```", "```py\n        return np.array([5*y[0] - 0.1*y[0]*y[1],\n    ```", "```py\n            0.1*y[1]*y[0] - 6*y[1]])\n    ```", "```py\n    p = np.linspace(0, 100, 25)\n    ```", "```py\n    w = np.linspace(0, 100, 25)\n    ```", "```py\n    P, W = np.meshgrid(p, w)\n    ```", "```py\n    dp, dw = predator_prey_system(0, np.array([P, W]))\n    ```", "```py\n    fig, ax = plt.subplots()\n    ```", "```py\n    ax.quiver(P, W, dp, dw)\n    ```", "```py\n    ax.set_title(\"Population dynamics for two competing species\")\n    ```", "```py\n    ax.set_xlabel(\"P\")\n    ```", "```py\n    ax.set_ylabel(\"W\")\n    ```", "```py\n    initial_conditions = np.array([85, 40])\n    ```", "```py\n    from scipy import integrate\n    ```", "```py\n    t_range = (0.0, 5.0)\n    ```", "```py\n    sol = integrate.solve_ivp(predator_prey_system,\n    ```", "```py\n                              t_range,\n    ```", "```py\n                              initial_conditions,\n    ```", "```py\n                              max_step=0.01)\n    ```", "```py\n    ax.plot(initial_conditions[0],\n    ```", "```py\n        initial_conditions[1], \"ko\")\n    ```", "```py\n    ax.plot(sol.y[0, :], sol.y[1, :], \"k\", linewidth=0.5)\n    ```", "```py\nfrom mpl_toolkits import mplot3d\n```", "```py\n    alpha = 1\n    ```", "```py\n    x0 = 0 # Left hand x limit\n    ```", "```py\n    xL = 2 # Right hand x limit\n    ```", "```py\n    N = 10\n    ```", "```py\n    x = np.linspace(x0, xL, N+1)\n    ```", "```py\n    h = (xL - x0) / N\n    ```", "```py\n    k = 0.01\n    ```", "```py\n    steps = 100\n    ```", "```py\n    t = np.array([i*k for i in range(steps+1)])\n    ```", "```py\nr = alpha*k / h**2\nassert r < 0.5, f\"Must have r < 0.5, currently r={r}\"\n```", "```py\n    from scipy import sparse\n    ```", "```py\n    diag = [1, *(1-2*r for _ in range(N-1)), 1]\n    ```", "```py\n    abv_diag = [0, *(r for _ in range(N-1))]\n    ```", "```py\n    blw_diag = [*(r for _ in range(N-1)), 0]\n    ```", "```py\n    A = sparse.diags([blw_diag, diag, abv_diag], (-1, 0, 1),\n    ```", "```py\n                     shape=(N+1, N+1), dtype=np.float64,\n    ```", "```py\n                     format=\"csr\")\n    ```", "```py\n    u = np.zeros((steps+1, N+1), dtype=np.float64)\n    ```", "```py\n    def initial_profile(x):\n    ```", "```py\n        return 3*np.sin(np.pi*x/2)\n    ```", "```py\n    u[0, :] = initial_profile(x)\n    ```", "```py\n    for i in range(steps):\n    ```", "```py\n        u[i+1, :] = A @ u[i, :]\n    ```", "```py\nX, T = np.meshgrid(x, t)\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\nax.plot_surface(T, X, u, cmap=\"gray\")\nax.set_title(\"Solution of the heat equation\")\nax.set_xlabel(\"t\")\nax.set_ylabel(\"x\")\nax.set_zlabel(\"u\")\n```", "```py\nfor i in range(steps):\n       u[i+1, :] = A @ u[i, :] + f(t[i], x)\n```", "```py\ndiag = [1-r, *(1-2*r for _ in range(N-1)), 1-r]\nabv_diag = [*(r for _ in range(N))]\nblw_diag = [*(r for _ in range(N))]\nA = sparse.diags([blw_diag, diag, abv_diag], (-1, 0, 1),\n                 shape=(N+1, N+1), dtype=np.float64,\n                 format=\"csr\")\n```", "```py\nrng = np.random.default_rng(12345)\n```", "```py\n    def signal(t, freq_1=4.0, freq_2=7.0):\n    ```", "```py\n        return np.sin(freq_1 * 2 * np.pi * t) + np.sin(\n    ```", "```py\n            freq_2 * 2 * np.pi * t)\n    ```", "```py\n    sample_size = 2**7 # 128\n    ```", "```py\n    sample_t = np.linspace(0, 4, sample_size)\n    ```", "```py\n    sample_y = signal(sample_t) + rng.standard_normal(\n    ```", "```py\n        sample_size)\n    ```", "```py\n    sample_d = 4./(sample_size - 1) # Spacing for linspace array\n    ```", "```py\n    true_signal = signal(sample_t)\n    ```", "```py\n    from numpy import fft\n    ```", "```py\n    fig1, ax1 = plt.subplots()\n    ```", "```py\n    fig1, ax1 = plt.subplots()\n    ```", "```py\n    ax1.plot(sample_t, sample_y, \"k.\",\n    ```", "```py\n             label=\"Noisy signal\")\n    ```", "```py\n    ax1.plot(sample_t, true_signal, \"k--\",\n    ```", "```py\n             label=\"True signal\")\n    ```", "```py\n    ax1.set_title(\"Sample signal with noise\")\n    ```", "```py\n    ax1.set_xlabel(\"Time\")\n    ```", "```py\n    ax1.set_ylabel(\"Amplitude\")\n    ```", "```py\n    ax1.legend()\n    ```", "```py\n    spectrum = fft.fft(sample_y)\n    ```", "```py\n    freq = fft.fftfreq(sample_size, sample_d)\n    ```", "```py\n    pos_freq_i = np.arange(1, sample_size//2, dtype=int)\n    ```", "```py\n    psd = np.abs(spectrum[pos_freq_i])**2 + np.abs(\n    ```", "```py\n        spectrum[-pos_freq_i])**2\n    ```", "```py\n    fig2, ax2 = plt.subplots()\n    ```", "```py\n    ax2.plot(freq[pos_freq_i], psd, \"k\")\n    ```", "```py\n    ax2.set_title(\"PSD of the noisy signal\")\n    ```", "```py\n    ax2.set_xlabel(\"Frequency\")\n    ```", "```py\n    ax2.set_ylabel(\"Density\")\n    ```", "```py\n    filtered = pos_freq_i[psd > 2e3]\n    ```", "```py\n    new_spec = np.zeros_like(spectrum)\n    ```", "```py\n    new_spec[filtered] = spectrum[filtered]\n    ```", "```py\n    new_spec[-filtered] = spectrum[-filtered]\n    ```", "```py\n    new_sample = np.real(fft.ifft(new_spec))\n    ```", "```py\n    fig3, ax3 = plt.subplots()\n    ```", "```py\n    ax3.plot(sample_t, true_signal, color=\"#8c8c8c\",\n    ```", "```py\n             linewidth=1.5, label=\"True signal\")\n    ```", "```py\n    ax3.plot(sample_t, new_sample, \"k--\",\n    ```", "```py\n             label=\"Filtered signal\")\n    ```", "```py\n    ax3.legend()\n    ```", "```py\n    ax3.set_title(\"Plot comparing filtered signal and true signal\")\n    ```", "```py\n    ax3.set_xlabel(\"Time\")\n    ```", "```py\n    ax3.set_ylabel(\"Amplitude\")\n    ```", "```py\nimport jax.numpy as jnp\nfrom jax import grad, jit, vmap\n```", "```py\n@jit\ndef f(x, y):\n    return jnp.exp(-(x**2 +y**2))\n```", "```py\nt = jnp.linspace(-1.0, 1.0)\nx, y = jnp.meshgrid(t, t)\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\nax.plot_surface(x, y, f(x, y), cmap=\"gray\")\nax.set_title(\"Plot of the function f(x, y)\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_zlabel(\"z\")\n```", "```py\nfx = jit(grad(f, 0))  # x partial derivative\nfy = jit(grad(f, 1))  # y partial derivative\n```", "```py\nprint(fx(1., -1.), fy(1., -1.))\n# -0.27067056 0.27067056\n```", "```py\nzx = vmap(fx)(x.ravel(), y.ravel()).reshape(x.shape)\nfigpd = plt.figure()\naxpd = figpd.add_subplot(projection=\"3d\")\naxpd.plot_surface(x, y, zx, cmap=\"gray\")\naxpd.set_title(\"Partial derivative with respect to x\")\naxpd.set_xlabel(\"x\")\naxpd.set_ylabel(\"y\")\naxpd.set_zlabel(\"z\")\n```", "```py\ndef f(x, y, args):\n    u = y[...,0]\n    v = y[...,1]\n    return jnp.array([v, 3*x**2*v+(1.-x)*u])\n```", "```py\nterm = diffrax.ODETerm(f)\nsolver = diffrax.Dopri5()\nsave_at = diffrax.SaveAt(ts=jnp.linspace(0., 1.))\ny0 = jnp.array([0., 1.]) # initial condition\n```", "```py\nsolution = diffrax.diffeqsolve(term, solver, t0=0., t1=2.,\n                               dt0=0.1, y0=y0, saveat=save_at)\n```", "```py\nx = solution.ts\ny = solution.ys[:, 0]  # first column is y = u\n```", "```py\nfig, ax = plt.subplots()\nax.plot(x, y, \"k\")\nax.set_title(\"Plot of the solution to the second order ODE\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\n```"]