<html><head></head><body>
		<div id="_idContainer029">
			<h1 id="_idParaDest-32"><em class="italic"><a id="_idTextAnchor031"/>Chapter 2</em>: Exploring the Structure of a Dash App</h1>
			<p>We are now ready to tackle the mechanism through which Dash creates interactivity – the heart of Dash, if you will. Once you are comfortable with creating <strong class="bold">callback functions</strong> that link different elements of the layout, combined with what you learned in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>, you should be well equipped to be able to convert datasets into interactive apps in a very short period of time. The remainder of this book will go into much more detail and offer many more options of how to do this. However, these two chapters should be sufficient for creating visual layouts, as well as connecting them and making them interactive. We will mainly explore callback functions in this chapter; the following topics will be covered:</p>
			<ul>
				<li>Using Jupyter Notebooks to run Dash apps</li>
				<li>Creating a standalone pure Python function</li>
				<li>Understanding the ID parameter of Dash components</li>
				<li>Using Dash inputs and outputs</li>
				<li>Incorporating the function into the app – creating your first reactive program</li>
				<li>Running your first interactive app</li>
			</ul>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Technical requirements</h1>
			<p>In addition to the packages that we used in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em> (for example, Dash, Dash HTML Components, and Dash Bootstrap Components), we will be, most importantly, working with <strong class="bold">Dash Core Components</strong>. We will also look at how to run Dash apps within a Jupyter Notebook environment, and for that, we will be using the <strong class="source-inline">jupyter_dash</strong> package along with <strong class="bold">JupyterLab</strong>. Later in the chapter, when we incorporate new functionality into the app, we will use <strong class="source-inline">pandas</strong> for data manipulation.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3tC0ZsW">https://bit.ly/3tC0ZsW</a>.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Using Jupyter Notebooks to run Dash apps</h1>
			<p>With a change to imports and a minor change to app instantiation, we can easily start to run our <a id="_idIndexMarker060"/>apps within Jupyter Notebook environments. The package that makes this possible is <strong class="source-inline">jupyter_dash</strong>. Essentially, the <a id="_idIndexMarker061"/>difference is that we import the <strong class="bold">JupyterDash</strong> object (instead of importing Dash), and app instantiation occurs by calling this object, as follows:</p>
			<p class="source-code">from jupyter_dash import JupyterDash</p>
			<p class="source-code">app = JupyterDash(__name__)</p>
			<p>One of the advantages of running apps in a notebook environment is that it is less tedious to make small changes, iterate them, and see results. Working with an IDE, the command line, and the browser, you need to constantly shift between them, while in a notebook environment, everything is in one place. This makes introducing simple changes and testing them easier. It can make your notebooks far more powerful and interesting as well. </p>
			<p>The <strong class="source-inline">jupyter_dash</strong> package also provides an additional option while running the app, where you can determine whether you want to run the app in one of three modes: </p>
			<ul>
				<li><strong class="source-inline">external</strong>: In a separate browser window, exactly as we have done so far </li>
				<li><strong class="source-inline">inline</strong>: In the code output area of the notebook, right underneath the code cell</li>
				<li> <strong class="source-inline">jupyterlab</strong>: In a separate tab while/if running in JupyterLab </li>
			</ul>
			<p>You can also set your desired width and height if you wish to. Running the app takes additional optional parameters, as follows:</p>
			<p class="source-code">app.run_server(<strong class="bold">mode='inline', height=600, width='80%'</strong>)</p>
			<p>As you can see, setting the height and width can be done either by specifying an integer, that is, the number of pixels, or, for <strong class="source-inline">width</strong>, a percentage of the screen size as a string.</p>
			<p>Still, there is another important benefit of running apps in a Jupyter Notebook environment, other than keeping the code and narrative in one place.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Isolating functionality for better management and debugging</h2>
			<p>When running and developing apps, you inevitably come across bugs and issues. In order <a id="_idIndexMarker062"/>to handle them, you need to isolate the cause and create the simplest reproducible example that causes the bug to happen. Only then can you properly troubleshoot the problem. And only then can you ask others for help. We won't wait for bugs to happen to isolate issues and figure them out. We will preemptively isolate all new features before incorporating them, so we can better handle and manage them.</p>
			<p>From now on, introducing new features will be done by, first, creating them in an isolated environment, where we create a minimal app containing only this functionality. Once we are comfortable that we understand how it works, and that it functions as expected, we will keep a copy for reference, and see how to incorporate it into the existing app. This will also help us if we want to make changes to that specific functionality in the future, in which case we go through the same process again.</p>
			<p>Let's start with our first example, which will be a drop-down menu with three values. The user selects one, and right underneath it, they see a message showing the value they chose. <em class="italic">Figure 2.1</em> shows an example of what this might look like in its simplest form:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B16780_02_001.jpg" alt="Figure 2.1 – The user's selection is displayed based on the value selected"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The user's selection is displayed based on the value selected</p>
			<p>The following code will create this, except for the function that shows the user's selection: </p>
			<ol>
				<li>Import the required packages with their aliases:<p class="source-code"><strong class="bold">from jupyter_dash import JupyterDash</strong></p><p class="source-code"><strong class="bold">import dash_core_components as dcc</strong></p><p class="source-code">import dash_html_components as html</p></li>
				<li>Instantiate the app:<p class="source-code">app = <strong class="bold">JupyterDash</strong>(__name__)</p></li>
				<li>Create the layout of the app. We will now introduce a new component, the Dash Core Components <strong class="bold">Dropdown</strong>. This will be covered in much more detail later. However, for now, we will primarily use its <strong class="source-inline">options</strong> attribute to set the options <a id="_idIndexMarker063"/>that the user can select from. This parameter is set by using a list of dictionaries, one for each option, where <strong class="source-inline">label</strong> is what the user will see, and <strong class="source-inline">value</strong> is the actual value that we will be dealing with:<p class="source-code">app.layout = html.Div([</p><p class="source-code">    <strong class="bold">dcc.Dropdown(options=[{'label': color, 'value':</strong></p><p class="source-code"><strong class="bold">color}</strong></p><p class="source-code"><strong class="bold">                      for color in ['blue', 'green',</strong></p><p class="source-code"><strong class="bold">'yellow']]),</strong></p><p class="source-code">    html.Div()</p><p class="source-code">])</p></li>
				<li>Run the app as usual, with the minor change of running this in the <strong class="source-inline">inline</strong> mode for easier interactive work in JupyterLab:<p class="source-code">if __name__ == '__main__':</p><p class="source-code">    app.run_server(<strong class="bold">mode='inline'</strong>)</p></li>
			</ol>
			<p><em class="italic">Figure 2.2</em> shows an example of what this would look like in a notebook environment:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B16780_02_002.jpg" alt="Figure 2.2 – The Dash app running in JupyterLab"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Dash app running in JupyterLab</p>
			<p>I'm <a id="_idIndexMarker064"/>sure you have noticed the empty <strong class="source-inline">html.Div</strong> file that was added right underneath the drop-down list. Let's examine how that fits into the structure of the app and how to implement the remaining functionality. We will now look at how to create the function that will link the dropdown to the empty div tag.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Creating a standalone pure Python function</h1>
			<p>This function is what we will be using to take the selected value from the dropdown, process it <a id="_idIndexMarker065"/>somehow, and use its return value to do something that is visible to the user.</p>
			<p>The function is so simple that it doesn't require much explanation:</p>
			<p class="source-code">def display_selected_color(color):</p>
			<p class="source-code">    if color is None:</p>
			<p class="source-code">        color = 'nothing'</p>
			<p class="source-code">    return 'You selected ' + color</p>
			<p>If the user doesn't input anything (or deselects the current option), then the <strong class="source-inline">color</strong> variable is set to <strong class="source-inline">'nothing'</strong>, and the function returns <strong class="source-inline">'You selected ' + &lt;color&gt;</strong>, with whatever value <strong class="source-inline">color</strong> takes. Later in the chapter, we will create a more involved function to get some information on countries.</p>
			<p>A function <a id="_idIndexMarker066"/>is essentially a procedure. It takes in one or more arguments (inputs), does something to them, and returns one or more outputs. So, for this function, what will <strong class="source-inline">Input</strong> be, and what happens to its <strong class="source-inline">Output</strong>? You decide by selecting from the available components from the layout.</p>
			<p>For this function, the dropdown will provide <strong class="source-inline">Input</strong>. Then, after processing it, the return value of the function, that is, its <strong class="source-inline">Output</strong>, will influence what to display in the currently empty <strong class="source-inline">html.Div</strong> right underneath the dropdown. Building on the diagram in <em class="italic">Figure 2.1</em>, <em class="italic">Figure 2.3</em> shows what we are trying to achieve. We will build a way to connect the dropdown (<strong class="source-inline">Input</strong>) to the div that shows the text (<strong class="source-inline">Output</strong>) by using the function we just defined as an intermediary:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B16780_02_003.jpg" alt="Figure 2.3 – Input, Output, and a standalone function"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Input, Output, and a standalone function</p>
			<p>In order for it to work in the context of this app, the function needs to know what its inputs and outputs are.</p>
			<p>Let's now <a id="_idIndexMarker067"/>look at how to identify components by setting their <strong class="source-inline">id</strong> values. After that, we will learn how to declare a component as <strong class="source-inline">Input</strong> or <strong class="source-inline">Output</strong>.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>The id parameter of Dash components</h1>
			<p>As briefly mentioned in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>, every Dash component <a id="_idIndexMarker068"/>has an <strong class="source-inline">id</strong> parameter that you can easily set in order to uniquely identify it. There is actually nothing more to this parameter than making sure that your components have unique and descriptive names.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are <a id="_idIndexMarker069"/>more advanced ways of using the <strong class="bold">id</strong> parameter, and they will be tackled in a later, more advanced chapter. However, for now, we will just focus on it being a unique identifier.</p>
			<p>Using descriptive and explicit names for the <strong class="source-inline">id</strong> parameter becomes more important as the app grows in complexity. This parameter is optional when there is no interactivity, but it becomes mandatory when there is. The following example snippet shows how easy it is to set the <strong class="source-inline">id</strong> parameter for a basic use case:</p>
			<p class="source-code">html.Div([</p>
			<p class="source-code">    html.Div(id='empty_space'),</p>
			<p class="source-code">    html.H2(id='h2_text'),</p>
			<p class="source-code">    dcc.Slider(id='slider'),</p>
			<p class="source-code">])</p>
			<p>Applying this to our current isolated app, we set a descriptive name to each <strong class="source-inline">id</strong> parameter:</p>
			<p class="source-code">app.layout = html.Div([</p>
			<p class="source-code">    dcc.Dropdown(<strong class="bold">id='color_dropdown'</strong>,</p>
			<p class="source-code">                 options=[{'label': color, 'value': color}</p>
			<p class="source-code">                         for color in ['blue', 'green',</p>
			<p class="source-code">'yellow']]),</p>
			<p class="source-code">    html.Div(<strong class="bold">id='color_output'</strong>)</p>
			<p class="source-code">])</p>
			<p>Our app is now complete from a layout perspective, exactly as we did in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>. The difference here is that we set values for the <strong class="source-inline">id</strong> parameter, and we are running it in a Jupyter Notebook environment. Once we can identify <a id="_idIndexMarker070"/>components using their <strong class="source-inline">id</strong> parameter, we can determine which become <strong class="source-inline">Input</strong> and which become <strong class="source-inline">Output</strong>. By updating our conceptual diagram with the ID values that we set, we can view the labels, as shown in <em class="italic">Figure 2.4</em>:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B16780_02_004.jpg" alt="Figure 2.4 – Visible app elements are given names (IDs)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – Visible app elements are given names (IDs)</p>
			<p>Having given our components descriptive names, we are now ready to use them beyond simply displaying them.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Dash inputs and outputs</h1>
			<p>The next <a id="_idIndexMarker071"/>step is to determine which component is going to become an input (to our pure Python function) and which component will get the return value of the function (as an output) to be displayed to the user.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Determining your inputs and outputs</h2>
			<p>The <strong class="source-inline">dash.dependencies</strong> module has several classes, two of which we will be using here: <strong class="source-inline">Output</strong> and <strong class="source-inline">Input</strong>.</p>
			<p>These <a id="_idIndexMarker072"/>classes can be imported by adding the following line to the <strong class="source-inline">imports</strong> section of our app:</p>
			<p class="source-code">from dash.dependencies import Output, Input</p>
			<p>Let's quickly recap what we did earlier before adding the final element that will make this functionality work:</p>
			<ol>
				<li value="1">We instantiated an app in the Jupyter Notebook environment.</li>
				<li>We created a dropdown containing three colors.</li>
				<li>We created a regular function that returns a string, together with the value provided to it: <strong class="source-inline">'Your selected'  + &lt;color&gt;</strong>.</li>
				<li>The components were identified with descriptive names through their <strong class="source-inline">id</strong> parameters.</li>
				<li><strong class="source-inline">Input</strong> and <strong class="source-inline">Output</strong> were imported from <strong class="source-inline">dash.dependencies</strong>.<p>We will now define our callback function.</p></li>
			</ol>
			<p>Callback functions are decorators, and in the most basic use case, they require three things:</p>
			<ol>
				<li value="1"><strong class="bold">Output</strong>: The page element that will be changed as a result of running the function. Dash gives <a id="_idIndexMarker073"/>us the flexibility to also determine which <strong class="bold">property</strong> of the component we want to modify. In our case, we want to modify the <strong class="source-inline">children</strong> property of the empty div. In this case, it can be specified like this: <p class="source-code">Output(component_id='color_output',</p><p class="source-code">component_property='children')</p></li>
				<li><strong class="bold">Input</strong>: Using the <a id="_idIndexMarker074"/>same logic, we need to specify which property of which component will serve as our input to the callback function. In our case, this would be the <strong class="source-inline">value</strong> property: <p class="source-code">Input(component_id='color_dropdown',</p><p class="source-code">component_property='value')</p></li>
				<li><strong class="bold">A normal Python function</strong>: Any function can be used, but obviously, it needs to make <a id="_idIndexMarker075"/>sense in the context of the <strong class="source-inline">Input</strong> and <strong class="source-inline">Output</strong> that we have chosen.</li>
			</ol>
			<p><em class="italic">Figure 2.5</em> shows an <a id="_idIndexMarker076"/>updated view of how things are coming together:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B16780_02_005.jpg" alt="Figure 2.5 – Visible app elements connected through certain properties"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Visible app elements connected through certain properties</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The distinction <a id="_idIndexMarker077"/>between the frontend and the backend in Dash is massively simplified for us. They both exist in the same module, and we don't need to worry about many of the conventional details. For now, anything in <strong class="source-inline">app.layout</strong> can be considered the frontend, and any callback functions that we define outside it can be collectively thought of as the backend.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Specifying your callback function</h2>
			<p>The general <a id="_idIndexMarker078"/>format to specify a callback function is to define it as an attribute of the <strong class="source-inline">app</strong> variable, using the Python classes' dot notation, and then set the output and input, as shown here:</p>
			<p class="source-code">@app.callback(Output(component_id, component_property)</p>
			<p class="source-code">              Input(component_id, component_property))</p>
			<p>Now that we have created a callback as an attribute of our app and determined which components' IDs and properties we want to influence each other, we bring our Python function <a id="_idIndexMarker079"/>and simply place it underneath the callback:</p>
			<p class="source-code">@app.callback(Output(component_id, component_property)</p>
			<p class="source-code">              Input(component_id, component_property)</p>
			<p class="source-code">def regular_function(input):</p>
			<p class="source-code">    output = do_something_with(input)</p>
			<p class="source-code">    return output</p>
			<p>Now our callback is complete and ready to be incorporated into our app.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Implementing the callback</h2>
			<p>Let's take <a id="_idIndexMarker080"/>this abstract structure and implement it using the details of our standalone app:</p>
			<p class="source-code">@app.callback(Output('color_output', 'children'),</p>
			<p class="source-code">              Input('color_dropdown', 'value')</p>
			<p class="source-code">def display_selected_color(color):</p>
			<p class="source-code">    if color is None:</p>
			<p class="source-code">        color = 'nothing'</p>
			<p class="source-code">    return 'You selected ' + color</p>
			<p>Please keep in mind that the order is important. <strong class="source-inline">Output</strong> has to be provided before <strong class="source-inline">Input</strong>.</p>
			<p>Now we have a complete callback function that belongs to our <strong class="source-inline">app</strong>. It knows which property of which <strong class="source-inline">Output</strong> it will modify, as well as which property of which <strong class="source-inline">Input</strong> it will be using for this. It then uses the <strong class="source-inline">display_selected_color</strong> function for processing, taking the output value and sending it to the component where <strong class="source-inline">id='color_output'</strong>. This will, in turn, modify the specified property (<strong class="source-inline">children</strong>).</p>
			<p>For running it in JupyterLab, you can see the full code in <em class="italic">Figure 2.6</em>, as well as several possible outputs based on the selected value:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B16780_02_006.jpg" alt="Figure 2.6 – An interactive Dash app in a Jupyter Notebook"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – An interactive Dash app in a Jupyter Notebook</p>
			<p>I also introduced a simple new component, <strong class="source-inline">html.Br</strong>, which simply provides a regular HTML <strong class="source-inline">&lt;br&gt;</strong> element, for better readability of the output.</p>
			<p>With this, we have completed our first isolated and interactive app. We ran it in JupyterLab, and we did so step by step, analyzing every tiny detail. The app that we have just built uses a toy dataset and implements extremely simple functionality. We did this so that we could focus on the mechanism that creates interactivity. There's not much practical <a id="_idIndexMarker081"/>value in telling the user what color they know they just selected.</p>
			<p>With this knowledge, we will now add functionality to answer a real question for the user – a question that might be tedious to answer if they were to skim through the whole dataset.</p>
			<p>We will also incorporate this new feature into our app and examine how it fits with the other content and functionality that we created already.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Incorporating the function into the app</h1>
			<p>Here is <a id="_idIndexMarker082"/>the plan for the functionality that we are going to introduce:</p>
			<ol>
				<li value="1">Create a drop-down list using the countries and regions available in our dataset.</li>
				<li>Create a callback function that takes the selected country, filters the dataset, and finds the population of that country in the year 2010.</li>
				<li>Return a small report about the found data. <em class="italic">Figure 2.7</em> shows the desired end result:<div id="_idContainer023" class="IMG---Figure"><img src="image/B16780_02_007.jpg" alt="Figure 2.7 – A drop-down list used to display the selected country's population"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 2.7 – A drop-down list used to display the selected country's population</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Now that we are beginning to use our dataset, we will start opening files from the <strong class="source-inline">data</strong> folder. This assumes that the app you are running is in the same folder. The code for each chapter in the GitHub repository is placed in its own folder for easy access; however, the code only works if the <strong class="source-inline">data</strong> folder and <strong class="source-inline">app.py</strong> are both in the same folder.</p>
			<p><em class="italic">Figure 2.8</em> shows <a id="_idIndexMarker083"/>what this folder structure might look like:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B16780_02_008.jpg" alt="Figure 2.8 – The assumed folder structure for the app"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The assumed folder structure for the app</p>
			<p>As agreed, we will run a minimal app in JupyterLab, make sure it is running properly, keep a copy, and then add it to the app.</p>
			<p>We first need to take a look at the dataset, explore it a little bit, and learn how to implement the new functionality.</p>
			<p>To view what files we have in the dataset, we can run the following code:</p>
			<p class="source-code">import os</p>
			<p class="source-code">os.listdir('data')</p>
			<p class="source-code">['PovStatsSeries.csv',</p>
			<p class="source-code"> 'PovStatsCountry.csv',</p>
			<p class="source-code"> 'PovStatsCountry-Series.csv',</p>
			<p class="source-code"> 'PovStatsData.csv',</p>
			<p class="source-code"> 'PovStatsFootNote.csv']</p>
			<p>Feel free <a id="_idIndexMarker084"/>to check out the files and their contents if you wish to. For now, we will be working with the <strong class="source-inline">PovStatsData.csv</strong> file. For a quick overview of its structure, we can run the following:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">poverty_data = pd.read_csv('data/PovStatsData.csv')</p>
			<p class="source-code">poverty_data.head(3)</p>
			<p>Running this code snippet in JupyterLab displays the first three rows of the dataset, as follows:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B16780_02_009.jpg" alt="Figure 2.9 – The first few rows and columns of the poverty dataset"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – The first few rows and columns of the poverty dataset</p>
			<p>It seems that we have two fixed variable columns (<strong class="bold">Country Name</strong> and <strong class="bold">Indicator Name</strong>). Measured variables in the form of numeric data (or missing <strong class="source-inline">NaN</strong>) values are available under their respective year column. Here, the years span from 1974 to 2019 (note that not all of the years are shown for better readability). The countries and indicators also have codes, which can be useful later when we want to merge different DataFrames.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Fixed variables refers to variables that are known in advance and don't change; in this case, they are the countries and the indicators. The measured variables are the values that we are interested in knowing, for example, the population of country A in year B. Fixed variables are also known as "dimensions." Technically, they are all columns in the dataset, and this is a conceptual distinction that is useful for analysis.</p>
			<p>In <a href="B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Manipulation and Preparation -  Paving the Way to Plotly Express</em>, we will explore data formats and how they might affect our analysis and visualization. The current structure can be <a id="_idIndexMarker085"/>improved by having a column for "year," and another column for "values," which makes it standardized and more intuitive for analysis. For now, since we are focusing on callback functions, we will keep the data format as it is so that we don't get distracted.</p>
			<p>Let's now implement the plan with code:</p>
			<ol>
				<li value="1">First, let's create a drop-down list. Here, we use the pandas <strong class="source-inline">Series.unique</strong> method to deduplicate countries and regions. Right underneath that, we create an empty div with <strong class="source-inline">id='report'</strong>:<p class="source-code">dcc.Dropdown(id='country',</p><p class="source-code">             options=[{'label': country, 'value': country}</p><p class="source-code">                      for country in</p><p class="source-code">                      poverty_data['Country Name'].unique()])</p><p class="source-code">html.Div(id='report')</p></li>
				<li>Next, we create a callback function that takes the selected country, filters the dataset, and finds the population of that country in the year 2010. The filtering will take two steps.<p>Check whether no country has been provided to the function, which happens when the user first accesses the page or when the user deselects values from the dropdown. Here, we simply return the empty string:</p><p class="source-code">if country is None:</p><p class="source-code">    return ''</p><p>Now, let's focus on the filtering part. First, we take the selected country and filter the <strong class="source-inline">poverty_data</strong> DataFrame to get the population value. We then define the <strong class="source-inline">filtered_df</strong> variable. This takes the selected country and gives the rows where the <strong class="bold">Country Name</strong> column is equal to the selected country, and the <strong class="bold">Indicator Name</strong> column is equal to <strong class="bold">Population, total</strong>. After that, we create the <strong class="source-inline">population</strong> variable. We do this by using the pandas <strong class="source-inline">loc</strong> method, where we take all of the <strong class="source-inline">:</strong> rows and the column name <strong class="bold">2010</strong>. We then extract the <strong class="source-inline">values</strong> attribute and get the number at index zero:</p><p class="source-code">filtered_df = countrydata[(countrydata['Country</p><p class="source-code">Name']==country) &amp; (countrydata['Indicator</p><p class="source-code">Name']=='Population, total')]</p><p class="source-code">population = filtered_df.loc[:, '2010'].values[0]</p></li>
				<li>Finally, let's <a id="_idIndexMarker086"/>return a small report about the data that has been found. Now that we have the population number that we are interested in, we return a list that contains two elements. The first is an &lt;h3&gt; element, showing the <strong class="source-inline">country</strong> variable using a large font. The second is a sentence that takes two dynamic values, which are inserted where they belong, as you can see in the following code snippet:<p class="source-code">return [</p><p class="source-code">    html.H3(<strong class="bold">country</strong>),</p><p class="source-code">    f'The population of {<strong class="bold">country</strong>} in 2010 was</p><p class="source-code">{<strong class="bold">population</strong>:,.0f}.'</p><p class="source-code">]</p></li>
			</ol>
			<p>Note that since we already have a div element in the layout, and we have indicated that we are modifying its <strong class="source-inline">children</strong> property (which takes a single value or a list), the return value of the function can simply be a list (or a single value).</p>
			<p>I have formatted the <strong class="source-inline">population</strong> value in the report to make it easier to read. The colon indicates that the following string is how we want to format it. The comma indicates that we want thousands to be separated by a comma. The dot indicates how to format decimal places. A zero after the dot indicates the number of decimal places, and the <strong class="source-inline">f</strong> indicates that we are dealing with floats.</p>
			<p>Now, we are <a id="_idIndexMarker087"/>ready to refactor our code to include the new visual elements, as well as the new functionality. </p>
			<p>Picking up where we left off in the last version of our app in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>, the dropdown and report div should go between the <strong class="source-inline">H2</strong> and <strong class="source-inline">Tabs</strong> components:</p>
			<p class="source-code">…</p>
			<p class="source-code">html.H2('The World Bank'),</p>
			<p class="source-code">dcc.Dropdown(id='country',</p>
			<p class="source-code">             options=[{'label': country, 'value': country}</p>
			<p class="source-code">                      for country in poverty_data['Country</p>
			<p class="source-code">Name'].unique()]),</p>
			<p class="source-code">html.Br(),</p>
			<p class="source-code">html.Div(id='report'),</p>
			<p class="source-code">dbc.Tabs([</p>
			<p class="source-code">   dbc.Tab([</p>
			<p class="source-code">…</p>
			<p>The callback <a id="_idIndexMarker088"/>function should come after the closing parentheses of the top-level <strong class="source-inline">html.Div</strong> of the app. Here is the full code of the function:</p>
			<p class="source-code">@app.callback(Output('report', 'children'),</p>
			<p class="source-code">              Input('country', 'value'))</p>
			<p class="source-code">def display_country_report(country):</p>
			<p class="source-code">    if country is None:</p>
			<p class="source-code">        return ''</p>
			<p class="source-code">    filtered_df = poverty_data[(poverty_data['Country</p>
			<p class="source-code">Name']==country) &amp;</p>
			<p class="source-code">                               (poverty_data['Indicator</p>
			<p class="source-code">Name']=='Population, total')]</p>
			<p class="source-code">    population = filtered_df.loc[:, '2010'].values[0]</p>
			<p class="source-code">    return [html.H3(country),</p>
			<p class="source-code">            f'The population of {country} in 2010 was</p>
			<p class="source-code">{population:,.0f}.']</p>
			<p>By running the app again, you should get this updated view:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B16780_02_010.jpg" alt="Figure 2.10 – The updated app with the dropdown and simple population report"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – The updated app with the dropdown and simple population report</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">app.run_server</strong> method takes an optional <strong class="source-inline">port</strong> argument, which defaults to <strong class="bold">8050</strong>, as you can see in the URL in <em class="italic">Figure 2.10</em>. While developing apps, you might want to run two or more apps side by side. The way to do that is to simply run the second app on a different port, for example, <strong class="source-inline">app.run_server(port=1234)</strong>. This also applies to <strong class="source-inline">jupyter_dash</strong>.</p>
			<p>Now that <a id="_idIndexMarker089"/>we have our callbacks enabled and working, we can finally start using that blue button in the bottom-right corner! Clicking on it and then selecting <strong class="bold">Callbacks</strong> shows an interactive diagram displaying the components exactly as we specified them. The <strong class="bold">country</strong> and its <strong class="bold">value</strong>, and the <strong class="bold">report</strong> and its <strong class="bold">children</strong>. <em class="italic">Figure 2.11</em> shows this:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B16780_02_011.jpg" alt="Figure 2.11 – The Dash visual debugger in action"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – The Dash visual debugger in action</p>
			<p>The <strong class="bold">Server</strong> button is green, which means it's running fine. We also see that we have "0 Errors." When you have this debugger opened in a running app, and while modifying the components, you can also see the path of the callbacks and what is triggering what. The components <a id="_idIndexMarker090"/>that are involved in triggering a callback light up, so you can "see" what is going on. This becomes much more useful in complex situations. The nodes of the graph are also interactive, and you can move them around by increasing/decreasing the size of the overall graph so that you can zoom in and out wherever you want. And yes, this graph is a Dash app, using another one of Dash's packages.</p>
			<p>The green rectangle in the middle shows two interesting numbers. The one on top, showing <strong class="bold">1</strong>, tells us how many times this callback has been fired so far. The one at the bottom shows how long it took to run this callback function. This is very helpful in tracking and analyzing performance.</p>
			<p>So far, we have used a single-value input (not a list, for example) to modify an output. But what if we wanted to get multiple values and do something with them? What if we wanted to process values from multiple sources, for example, drop-down values and a date? All this and more is possible with Dash's callback functions. Did I mention that they were the heart of Dash?</p>
			<p>I believe we've done enough coding in this chapter, and I think it's a good idea to have an overview <a id="_idIndexMarker091"/>of what lies ahead in terms of the power of callback functions, what they can do, and some of their interesting attributes. These are just things to keep in mind and know for now; we will be exploring how each feature works as we progress through the later chapters.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Properties of Dash's callback functions</h2>
			<p>Let's recap <a id="_idIndexMarker092"/>the properties of Dash's callback function and introduce a few others that will be explored in more detail later on:</p>
			<ul>
				<li><strong class="bold">Multiple inputs</strong>: As I just mentioned, we can give callbacks to more than one input, and create more complex functionality. Using our dataset as an example, we can easily imagine a dropdown to select countries, another to select dates, and yet another to specify the economic indicator that you want to analyze. Those inputs could be used to filter a subset of the DataFrame and return the values that you want, based on multiple criteria. </li>
				<li><strong class="bold">Inputs can be lists</strong> (effectively multiple values from a single <strong class="source-inline">Input</strong>): The country selector can be made to accept multiple values, so we can loop over them and visualize the same trend for the same indicator for multiple countries in one chart (or a chart per country).</li>
				<li><strong class="bold">Multiple outputs</strong>: As with multiple inputs, multiple outputs can be modified using one callback function. In our example, we might imagine producing two outputs – one that is a chart visualizing the filtered data and another that is a table – providing the user with the raw data if they want to export and further analyze this particular subset.</li>
				<li><strong class="bold">They can do other things before returning</strong>: We have mainly focused on callbacks being simple processors of data, but they can really do anything before returning. For example, you can imagine a function sending an email under certain conditions. Logging is another interesting thing to explore. All you have to do is simply log the arguments given to each function. This can give you insights into what people are interested in, which functionality is being used, and more. You can even parse those logs and develop your own separate analytics app based on that!</li>
				<li><strong class="bold">Order matters</strong>: Outputs have to come before inputs. Additionally, the order of inputs corresponds to the parameters and their order of the callback function. For example, take a look at the following:<p class="source-code">@app.callback(Output('div_1', 'children'), </p><p class="source-code">              Input('dropdown', 'value'),</p><p class="source-code">Input('date', 'value)</p><p class="source-code">def my_function(dropdown, date):</p><p class="source-code">    output = process(dropdown, date)</p><p class="source-code">    return output</p><p>Here, the <a id="_idIndexMarker093"/>first given <strong class="source-inline">Input</strong> in the decorator should correspond to the first parameter of <strong class="source-inline">my_function</strong>. I used the same names in the preceding snippet to make it explicit and clear (<strong class="source-inline">dropdown</strong> and <strong class="source-inline">date</strong>). The same applies to outputs.</p></li>
				<li><strong class="bold">State</strong>: Another optional parameter for callbacks is <strong class="source-inline">State</strong>. In the examples we have discussed so far, the callbacks immediately fire when the values change. Sometimes, you don't want that. For example, if you have multiple inputs, it might be annoying for the user to have the outputs change while they are configuring their options. Imagine having a textbox that modifies another element on the page. Every letter the user enters would modify it, which is not the best user experience. The typical scenario for using <strong class="source-inline">State</strong> is to have buttons. The user selects or enters values, and once they are ready, they can click on a button, which only then triggers the callback function.</li>
			</ul>
			<p><em class="italic">Figure 2.12</em> presents a conceptual diagram of a more complex callback function and what it might look like: </p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B16780_02_012.jpg" alt="Figure 2.12 – A callback function handling multiple inputs and outputs, as well as running other tasks"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – A callback function handling multiple inputs and outputs, as well as running other tasks</p>
			<p>We have <a id="_idIndexMarker094"/>now created and run two callback functions in two different contexts. We also incorporated one of them and built on the work we did in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>,<em class="italic"> Overview of the Dash Ecosystem</em>. With a few more examples, you will have mastered callback functions. The next skills you need to conquer are managing complexity and being comfortable with refactoring code while keeping things organized and under control.</p>
			<p>Let's quickly recap what we learned in this chapter.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Summary</h1>
			<p>First, we introduced a new way to run Dash apps, which is by running them in a Jupyter Notebook environment. We saw how familiar the process is, and we created our first interactive app in a notebook. We went through every detail in the process from creating layout components, giving them IDs, and selecting which of their properties will be used, to connecting all of this with the callback function. We ran another example and familiarized ourselves with our dataset. Most importantly, we learned how to incorporate the new work into the app, and we ran an updated version that produced simple population reports. Congratulations! </p>
			<p>In the next chapter, we will take a deep dive into Plotly's data visualization capabilities. We will mainly focus on the <strong class="bold">Figure</strong> object, its components, how to query them, and how to modify them. This will give us fine-grained control over the visualizations that we will make. </p>
		</div>
	</body></html>