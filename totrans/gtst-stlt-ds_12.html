<html><head></head><body>
		<div id="_idContainer098">
			<h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor094"/>Chapter 9</em>: Improving Job Applications with Streamlit</h1>
			<p>At this point in this book, you should already be an experienced Streamlit user. You have a good grasp of everything – from Streamlit design to deployment, to data visualization, and everything in between. This chapter is designed to be application-focused; it will show you some great use cases for Streamlit applications so that you can be inspired to create your own! We will start by demonstrating how to use Streamlit for <em class="italic">Proof Of Skill Data Projects</em>. Then, we will then move on to discuss how to use Streamlit in the <em class="italic">Take Home</em> sections of job applications.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Using Streamlit for proof of skill data projects</li>
				<li>Improving job applications in Streamlit</li>
			</ul>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>The following is a list of software and hardware installations that are required for this chapter:</p>
			<ul>
				<li><strong class="source-inline">streamlit-lottie</strong>: To download this library, run the following code in your Terminal:<p class="source-code">pip install streamlit-lottie</p><p>Interestingly, <strong class="source-inline">streamlit-lottie</strong> uses the <strong class="source-inline">lottie</strong> open source library, which allows us to add web-native animations (such as a GIF) to our Streamlit apps. Frankly, it is a wonderful library that you can use to beautify Streamlit apps and was created by Andy Fanilo, a prolific Streamlit app creator. </p></li>
				<li>The job application example folder: The central repository for this book can be found at <a href="https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science">https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science</a>. Within this repository, the <strong class="source-inline">job_application_example</strong> folder will contain some of the files that you will need for the second section of the chapter, covering job applications. If you do not have this main repository downloaded already, use the following code in your Terminal to clone it:<p class="source-code">git clone https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science</p></li>
			</ul>
			<p>Now that we have everything set up, let's begin!</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/>Using Streamlit for proof of skill data projects</h1>
			<p>Proving<a id="_idIndexMarker348"/> to others that you are a skilled data<a id="_idIndexMarker349"/> scientist is notoriously difficult. Anyone can put Python or machine learning on their résumé or even work in a research group at a university that might do some machine learning. But often, recruiters, professors you want to work with, and data science managers rely on things on your résumé that are proxies for competence, such as having attended the "right" university or already having a fancy data science internship or job. </p>
			<p>Prior to Streamlit, there were not many effective solutions to this problem. If you put a Python file or Jupyter Notebook on your GitHub profile, the time it would take for someone to understand whether the work was impressive or not was too much of a risk to take. If the recruiter has to click on the right repository in your GitHub profile and then click through numerous files until they find the Jupyter notebook with unreadable code (without comments), you've already lost them. If the recruiter sees "machine learning" on you<a id="_idTextAnchor097"/>r résumé, but it takes five clicks to see any machine learning product or code that you've written, you've already lost them. Most interested parties will spend a very small amount of time on your résumé; on average, visitors to my personal portfolio site (www.tylerjrichards.com) spend around 2 minutes on the site before moving elsewhere.</p>
			<p>One solution to this issue is to try creating and sharing Streamlit apps that are specific to the skills that you would like to showcase the most broadly. For instance, if you have a lot of experience in fundamental statistics, you might create a Streamlit app that proves, or illustrates, a fundamental statistical theorem such as the central limit theorem – just as we did earlier in this book. If instead, you have experience in natural language processing, you could create an app that shows off a new text-generating neural network that you have created. The point here is to<a id="_idIndexMarker350"/> minimize the number of clicks someone would need to make until they get proof of your competence within a desired area.</p>
			<p>Many of the Streamlit apps that we have created already do serve this purpose. Let's run through a few examples. </p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Machine learning – the Penguins app</h2>
			<p>In <a href="B16864_04_Final_VK_ePub.xhtml#_idTextAnchor049"><em class="italic">Chapter 4</em></a>,<em class="italic"> Using Machine Learning with Streamlit</em>, we created a random forest model that was trained <a id="_idIndexMarker351"/>on our Palmer's Penguin dataset to predict the species of penguin according to features such as weight, island of habitation, and bill length. Then, we saved that model so that we could use it in our Streamlit app.</p>
			<p>To produce our Streamlit app, we need (in the first iteration) to run the following code. This will create the model to be deployed:</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from sklearn.metrics import accuracy_score</p>
			<p class="source-code">from sklearn.ensemble import RandomForestClassifier</p>
			<p class="source-code">from sklearn.model_selection import train_test_split</p>
			<p class="source-code">import pickle</p>
			<p class="source-code">penguin_df = pd.read_csv('penguins.csv')</p>
			<p class="source-code">penguin_df.dropna(inplace=True)</p>
			<p class="source-code">output = penguin_df['species']</p>
			<p class="source-code">features = penguin_df[['island', 'bill_length_mm', 'bill_depth_mm',</p>
			<p class="source-code">                       'flipper_length_mm', 'body_mass_g', 'sex']]</p>
			<p class="source-code">features = pd.get_dummies(features)</p>
			<p class="source-code">output, uniques = pd.factorize(output)</p>
			<p class="source-code">x_train, x_test, y_train, y_test = train_test_split(</p>
			<p class="source-code">    features, output, test_size=.8)</p>
			<p class="source-code">rfc = RandomForestClassifier(random_state=15)</p>
			<p class="source-code">rfc.fit(x_train, y_train)</p>
			<p class="source-code">y_pred = rfc.predict(x_test)</p>
			<p class="source-code">score = accuracy_score(y_pred, y_test)</p>
			<p class="source-code">print('Our accuracy score for this model is {}'.format(score))</p>
			<p>In this first section, we<a id="_idIndexMarker352"/> import our libraries, load our data, and train/evaluate our model while printing out the evaluation results. Then, we save the model results to the <strong class="source-inline">pickle</strong> files using the following code:</p>
			<p class="source-code">rf_pickle = open('random_forest_penguin.pickle', 'wb')</p>
			<p class="source-code">pickle.dump(rfc, rf_pickle)</p>
			<p class="source-code">rf_pickle.close()</p>
			<p class="source-code">output_pickle = open('output_penguin.pickle', 'wb')</p>
			<p class="source-code">pickle.dump(uniques, output_pickle)</p>
			<p class="source-code">output_pickle.close()</p>
			<p>Recall that at the end of the chapter, we added a new feature so that if a user uploaded their own dataset, they could use our model training script to train a model entirely on their data (provided it was in the same format; it came with some preconditions). </p>
			<p>This app, in its final form, shows that we have, at least, some knowledge about data cleaning, how to do one-hot encoding on our variables, how we think about evaluating our models on test data, and finally, how to deploy our pre-trained models in an application. That alone is going to look much better than just putting "machine learning" on our résumé, and it shows evidence of some of the skills that we have. Without this proof of skill, the recruiter or hiring manager who is looking at our application will have to either trust that we are being entirely honest on our résumé (and from reading hundreds of résumés over the years, that is a bad assumption to make) or use a proxy for confidence such as a university degree (this is also a bad proxy for assessing competence). </p>
			<p>In addition to this, when we deployed this app to Streamlit Sharing in <a href="B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056"><em class="italic">Chapter 5</em></a>,<em class="italic"> Deploying Streamlit with Streamlit Sharing</em>, we discussed an automatic feature that comes free with Streamlit Sharing: the <strong class="bold">View app source</strong> button. As you can see in the following screenshot, when we deploy our apps, Streamlit adds a button to the user's <strong class="bold">Settings</strong> drop-down menu that allows them to view the source code behind the app:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B16864_09_1.jpg" alt="Figure 9.1 – The View app source option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The View app source option</p>
			<p>In this way, users can always check to make sure malicious code (for example, whether a researcher's Penguin data is not being stored by the app) is not being deployed by Streamlit Sharing. As a secondary feature, the user can also view the code that you wrote to built the app, which improves the ability for us to use Streamlit as a <em class="italic">Proof of Skill</em> tool.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Visualization – the Pretty Trees app</h2>
			<p>In <a href="B16864_06_Final_VK_ePub.xhtml#_idTextAnchor065"><em class="italic">Chapter 6</em></a>, <em class="italic">Beautifying Streamlit Apps</em>, we worked on a Streamlit application that could create beautiful and <a id="_idIndexMarker353"/>dynamic visualizations of trees in San Francisco, which resulted in the following app:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B16864_09_2.jpg" alt="Figure 9.2 – Mapping a web app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Mapping a web app</p>
			<p>Within this app, we had to create multiple different visualizations (that is, two histograms and one map) that dynamically updated based on the user inputs on the right-hand side. With an app like this, we were able to show off our data manipulation skills, our familiarity with the pandas, Matplotlib, and Seaborn libraries, and even that we understood how to deal with datetimes in Python. Let's take a look at the section of the app's code that focuses on visualization: </p>
			<p class="source-code">#define multiple columns, add two graphs</p>
			<p class="source-code">col1, col2 = st.beta_columns(2)</p>
			<p class="source-code">with col1:</p>
			<p class="source-code">     st.write('Trees by Width')</p>
			<p class="source-code">     fig_1, ax_1 = plt.subplots()</p>
			<p class="source-code">     ax_1 = sns.histplot(trees_df['dbh'], </p>
			<p class="source-code">          color=graph_color)</p>
			<p class="source-code">     plt.xlabel('Tree Width')</p>
			<p class="source-code">     st.pyplot(fig_1)</p>
			<p class="source-code">with col2:</p>
			<p class="source-code">     st.write('Trees by Age')</p>
			<p class="source-code">     fig_2, ax_2 = plt.subplots()</p>
			<p class="source-code">     ax_2 = sns.histplot(trees_df['age'],</p>
			<p class="source-code">          color=graph_color)</p>
			<p class="source-code">     plt.xlabel('Age (Days)')</p>
			<p class="source-code">     st.pyplot(fig_2)</p>
			<p class="source-code">st.write('Trees by Location')</p>
			<p class="source-code">trees_df = trees_df.dropna(subset=['longitude', 'latitude'])</p>
			<p class="source-code">trees_df = trees_df.sample(n = 1000, replace=True)</p>
			<p class="source-code">st.map(trees_df)</p>
			<p>This code is fairly easy to <a id="_idIndexMarker354"/>read for anyone who is familiar with Python or other scripting languages, and it is a heck of a lot better than simply putting "data visualization" or "pandas" on a résumé. </p>
			<p>At this point, I hope you are convinced. Streamlit apps are an excellent way to showcase your work to recruiters, potential hiring managers, or anyone to whom you need to prove your set of skills. In the next section, we will cover this process in a little more detail and demonstrate how to use Streamlit to bolster your applications to companies that you might want to work for. </p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Improving job applications in Streamlit</h1>
			<p>Often, data<a id="_idIndexMarker355"/> science and machine learning job applications rely<a id="_idIndexMarker356"/> on take-home data science challenges to judge candidates. Frankly, this is a brutal and annoying experience that companies can demand because of the dynamic between the applicant and the employer. For instance, it could take a candidate 5–10 hours to fully complete a data science challenge, but it might only take the employer 10 minutes to evaluate it. Additionally, an individual virtual or telephone interview might take 30–45 minutes for the employer, plus an extra 15 minutes to write up feedback, compared to the same 30–45 minutes for the applicant. Because getting 5–10 hours of work gives them a very high signal per minute of employee time, employers have trended toward including these challenges within their job applications. </p>
			<p>You can use the<a id="_idIndexMarker357"/> opportunity here to use Streamlit to stand out<a id="_idIndexMarker358"/> from the crowd by creating a fully functioning application instead of sending the company a Jupyter Notebook, Word document, or PowerPoint deck. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor101"/>Questions</h2>
			<p>Let's walk through a fictional example about a job applicant who is in the middle of applying to a major <a id="_idIndexMarker359"/>US airline. They are given two main questions to solve – one has a dataset included:</p>
			<ul>
				<li><strong class="bold">Question 1</strong>: <strong class="bold">Airport distance</strong><p>The first exercise asks, "Given the included dataset of airports and locations (in latitude and longitude), write a function that takes an airport code as input and returns the airports listed from nearest to furthest from the input airport."</p></li>
				<li><strong class="bold">Question 2</strong>: <strong class="bold">Representation</strong><p>The second question asks, "How would you transform a collection of searches into a numeric vector representing a trip? Assume that we have hundreds of thousands of users and we want to represent all of their trips this way. Ideally, we want this to be a general representation that we could use in multiple different modeling projects, but we definitely care about finding similar trips. How, precisely, would you compare two trips to see how similar they are? What information do you feel might be missing from the preceding data that would help improve your representation?"</p><p class="callout-heading">Note</p><p class="callout">Don't worry about writing code in this section; you can simply describe any transformations of data that you would perform. Your description should be clear enough so that a data scientist reading it would know how to implement your solution if necessary.</p></li>
			</ul>
			<p>Now that we have <a id="_idIndexMarker360"/>the required questions, we can get a new Streamlit app started. To do this, I went through the same process that we have used in each chapter thus far. We create a new folder for our app within our central folder (<strong class="source-inline">streamlit_apps</strong>), called <strong class="source-inline">job_application_example</strong>. Within this folder, we can create a Python file, called <strong class="source-inline">job_streamlit.py</strong>, in our Terminal, using the following command: </p>
			<p class="source-code">touch job_streamlit.py</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/>Answering Question 1</h2>
			<p>It is not hugely important for you to understand exactly how to answer the problem at hand, but the overall framework is quite important. The Streamlit app we create should read like an incredibly dynamic document that answers the question in a unique way, depending on the ability of Streamlit to make an application that could not easily be replicated by an applicant with a Word document. </p>
			<p>To begin, we can create a title that introduces us and kicks off the format for the whole application. One improvement here is to add an optional animation at the top of the application using the <strong class="source-inline">streamlit-lottie</strong> library that we learned about in <a href="B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring Streamlit Components</em>, as shown in the following code: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">from streamlit_lottie import st_lottie</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import requests</p>
			<p class="source-code">def load_lottieurl(url: str):</p>
			<p class="source-code">    r = requests.get(url)</p>
			<p class="source-code">    if r.status_code != 200:</p>
			<p class="source-code">        return None</p>
			<p class="source-code">    return r.json()</p>
			<p class="source-code">lottie_airplane = load_lottieurl('https://assets4.lottiefiles.com/packages/lf20_jhu1lqdz.json')</p>
			<p class="source-code">st_lottie(lottie_airplane, speed=1, height=200, key="initial")</p>
			<p class="source-code">st.title('Major US Airline Job Application')</p>
			<p class="source-code">st.write('by Tyler Richards')</p>
			<p class="source-code">st.subheader('Question 1: Airport Distance')</p>
			<p>The <a id="_idIndexMarker361"/>preceding code will create an application with a beautiful airplane animation at the top, as presented in the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B16864_09_3.jpg" alt="Figure 9.3 – An airplane GIF &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – An airplane GIF </p>
			<p>Next, we need to copy and paste the question below our subheader. Streamlit has many options for putting text into applications. One option that we have not used yet is to wrap our text inside three apostrophe signs, which tells Streamlit to write this text using the markdown language. This is useful for large blocks of text, such as the following one, which begins to answer the first question:</p>
			<p class="source-code">'''</p>
			<p class="source-code">The first exercise asks us 'Given the table of airports and </p>
			<p class="source-code">locations (in latitude and longitude) below, </p>
			<p class="source-code">write a function that takes an airport code as input and </p>
			<p class="source-code">returns the airports listed from nearest to furthest from </p>
			<p class="source-code">the input airport.' There are three steps here:</p>
			<p class="source-code">1. Load Data</p>
			<p class="source-code">2. Implement Distance Algorithm</p>
			<p class="source-code">3. Apply distance formula across all airports other than the input</p>
			<p class="source-code">4. Return sorted list of airports Distance</p>
			<p class="source-code">'''</p>
			<p>As mentioned in the <em class="italic">Technical requirements</em> section of this chapter, two files are needed to complete this application. The first is the dataset of the airport locations (called <strong class="source-inline">airport_location.csv</strong>), and the second is a picture that shows the Haversine distance (that is, the distance between two points on a sphere; the file is appropriately named <strong class="source-inline">haversine.png</strong>). Please copy those files into the same folder as the Streamlit application Python file.</p>
			<p>Now, we <a id="_idIndexMarker362"/>need to complete the first step: loading the data. We need to both complete this step in Streamlit and also show the code to the user. This is different from other Streamlit applications, where the code is hidden in the background. However, because the user definitely wants to see our code, as they will be assessing us on it, we need to do both. We can use the <strong class="source-inline">st.echo()</strong> function, which we used previously, to print out the code block to our app. We can do this with the following code:</p>
			<p class="source-code">airport_distance_df = pd.read_csv('airport_location.csv')</p>
			<p class="source-code">with st.echo():</p>
			<p class="source-code">     #load necessary data</p>
			<p class="source-code">     airport_distance_df = pd.read_csv('airport_location.csv')</p>
			<p>I would like to note here that we have placed a comment at the top of this code. This is not for the purpose of annotating code for you, the reader, but for the application reader. It is good practice to occasionally comment on the purpose of the code that you are writing both within the code and in the blocks of text before and after; this is so that the reader understands the approach you are trying to take. This is especially important in a job application but is good practice for collaborative Streamlit apps, too.</p>
			<p>Our next step is to explain the Haversine formula and show the image in our Streamlit application, which we have done in the following code block. It is totally acceptable to take a narrative format in your blocks of text. Simply imagine what you would like to read as a hiring <a id="_idIndexMarker363"/>manager and try to replicate that as well as you can:</p>
			<p class="source-code">'''</p>
			<p class="source-code">From some quick googling, I found that the haversine distance is </p>
			<p class="source-code">a good approximation for distance. At least good enough to get the </p>
			<p class="source-code">distance between airports! Haversine distances can be off by up to .5%, </p>
			<p class="source-code">because the earth is not actually a sphere. It looks like the latitudes </p>
			<p class="source-code">and longitudes are in degrees, so I'll make sure to have a way to account </p>
			<p class="source-code">for that as well. The haversine distance formula is labeled below, </p>
			<p class="source-code">followed by an implementation in python</p>
			<p class="source-code">'''</p>
			<p class="source-code">st.image('haversine.png')</p>
			<p>Now, our application should look similar to the following screenshot:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B16864_09_4.jpg" alt="Figure 9.4 – Loading the data for Question 1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Loading the data for Question 1</p>
			<p>We have our list <a id="_idIndexMarker364"/>of items to address, the animation, the Haversine distance formula, and the basic code to read in the data. At this point, we need to implement the Haversine distance formula in Python and also show our implementation:</p>
			<p class="source-code">with st.echo():</p>
			<p class="source-code">     from math import radians, sin, cos, atan2, sqrt</p>
			<p class="source-code">     def haversine_distance(long1, lat1, long2, lat2, degrees=False):</p>
			<p class="source-code">         #degrees vs radians</p>
			<p class="source-code">         if degrees == True:</p>
			<p class="source-code">             long1 = radians(long1)</p>
			<p class="source-code">             lat1 = radians(lat1)</p>
			<p class="source-code">             long2 = radians(long2)</p>
			<p class="source-code">             lat2 = radians(lat2)</p>
			<p class="source-code">         </p>
			<p class="source-code">         #implementing haversine</p>
			<p class="source-code">         a = sin((lat2-lat1) / 2)**2 + cos(lat1) * cos(lat2) * sin((long2-long1) / 2)**2</p>
			<p class="source-code">         c = 2*atan2(sqrt(a), sqrt(1-a))</p>
			<p class="source-code">         distance = 6371 * c #radius of earth in kilometers</p>
			<p class="source-code">         return(distance)</p>
			<p>The first section of <a id="_idIndexMarker365"/>our code does not create our function but instead, prints out the function that we will create to the Streamlit app. This is so that the reader of the application can view both pieces of important code that we have written and interact with the code itself. If we just created a function to implement the Haversine distance, the reader of our application would not really know how we solved the problem at hand! The following code block creates this function:</p>
			<p class="source-code">#execute haversine function definition</p>
			<p class="source-code">from math import radians, sin, cos, atan2, sqrt</p>
			<p class="source-code">def haversine_distance(long1, lat1, long2, lat2, degrees=False):</p>
			<p class="source-code">    #degrees vs radians</p>
			<p class="source-code">    if degrees == True:</p>
			<p class="source-code">        long1 = radians(long1)</p>
			<p class="source-code">        lat1 = radians(lat1)</p>
			<p class="source-code">        long2 = radians(long2)</p>
			<p class="source-code">        lat2 = radians(lat2)</p>
			<p class="source-code">    </p>
			<p class="source-code">    #implementing haversine</p>
			<p class="source-code">    a = sin((lat2-lat1) / 2)**2 + cos(lat1) * cos(lat2) * sin((long2-long1) / 2)**2</p>
			<p class="source-code">    c = 2*atan2(sqrt(a), sqrt(1-a))</p>
			<p class="source-code">    distance = 6371 * c #radius of earth in kilometers</p>
			<p class="source-code">    return(distance)</p>
			<p>We have completed <a id="_idIndexMarker366"/>our Haversine implementation! Whenever we want to find the distance between two locations, we can call our formula, input the longitude and latitude, and get the distance in kilometers. This app is useful; however, at the moment, it is not much better than a Word document. Our next step is to allow the user to input their own points to check and see whether the Haversine distance is working. Almost no one knows how many kilometers apart two points on the globe are, so I have included default points and checked the real distance between them:</p>
			<p class="source-code">'''</p>
			<p class="source-code">Now, we need to test out our function! The </p>
			<p class="source-code">distance between the default points is </p>
			<p class="source-code">18,986 kilometers, but feel free to try out</p>
			<p class="source-code">your own points of interest. </p>
			<p class="source-code">'''</p>
			<p class="source-code">long1 = st.number_input('Longitude 1', value = 2.55)</p>
			<p class="source-code">long2 = st.number_input('Longitude 2', value = 172.00)</p>
			<p class="source-code">lat1 = st.number_input('Latitude 1', value = 49.01)</p>
			<p class="source-code">lat2 = st.number_input('Latitude 2', value = -43.48)</p>
			<p class="source-code">test_distance = haversine_distance(long1 = long1, long2 = long2,</p>
			<p class="source-code">          lat1 = lat1, lat2 = lat2, degrees=True)</p>
			<p class="source-code">st.write('Your distance is: {} kilometers'.format(int(test_distance)))</p>
			<p>When we put in our <a id="_idIndexMarker367"/>default values, the app returns a distance that is approximately 2 kilometers off, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B16864_09_5.jpg" alt="Figure 9.5 – Implementing the Haversine distance &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Implementing the Haversine distance </p>
			<p>At this point, our next step is to combine all of the pieces by using the implemented Haversine distance calculator on our given dataset. This is briefly shown in the following screenshot:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B16864_09_6.jpg" alt="Figure 9.6 – The airport distances that have been given&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – The airport distances that have been given</p>
			<p>This dataset has airport <a id="_idIndexMarker368"/>codes and their corresponding <strong class="source-inline">lat</strong> and <strong class="source-inline">long</strong> values. The following code block introduces a solution that combines the two distances and leaves out the full <strong class="source-inline">get_distance_list</strong> function, as it is simply a copy of the function that we have implemented twice already: </p>
			<p class="source-code">'''</p>
			<p class="source-code">We have the Haversine distance implemented, and we also have</p>
			<p class="source-code">proven to ourselves that it works reasonably well.</p>
			<p class="source-code">Our next step is to implement this in a function!</p>
			<p class="source-code">'''</p>
			<p class="source-code">def get_distance_list(airport_dataframe, airport_code):</p>
			<p class="source-code">    df = airport_dataframe.copy() </p>
			<p class="source-code">    row = df[df.loc[:,'Airport Code'] == airport_code] </p>
			<p class="source-code">    lat = row['Lat'] </p>
			<p class="source-code">    long = row['Long'] </p>
			<p class="source-code">    df = df[df['Airport Code'] != airport_code] </p>
			<p class="source-code">    df['Distance'] = df.apply(lambda x: haversine_distance(lat1=lat, long1=long, </p>
			<p class="source-code">         lat2 = x.Lat, long2 = x.Long, degrees=True), axis=1)</p>
			<p class="source-code">    return(df.sort_values(by='Distance').reset_index()['Airport Code']) </p>
			<p class="source-code">with st.echo():</p>
			<p class="source-code">     def get_distance_list(airport_dataframe, airport_code):</p>
			<p class="source-code">          *copy of function above with comments*</p>
			<p>Finally, we can implement this distance formula on the dataframe we have been given. We can allow the user to input their own airport code from the options that we have data on and return the<a id="_idIndexMarker369"/> correct values:</p>
			<p class="source-code">'''</p>
			<p class="source-code">To use this function, select an airport from the airports provided in the dataframe</p>
			<p class="source-code">and this application will find the distance between each one, and </p>
			<p class="source-code">return a list of the airports closest to furthest.</p>
			<p class="source-code">'''</p>
			<p class="source-code">selected_airport = st.selectbox('Airport Code', airport_distance_df['Airport Code'])</p>
			<p class="source-code">distance_airports = get_distance_list(</p>
			<p class="source-code">     airport_dataframe=airport_distance_df, airport_code=selected_airport)</p>
			<p class="source-code">st.write('Your closest airports in order are {}'.format(list(distance_airports)))</p>
			<p>This is the end of our first question. We can add an optional section at the end about how we would change our implementation if we had more time to work on this problem. This is always a good idea if you know you only want to spend a few hours on the total application, but you also want to demonstrate that you know how to improve it if you had more time. An example of this is shown in the following code block, to be placed directly after the <a id="_idIndexMarker370"/>preceding code block: </p>
			<p class="source-code">'''</p>
			<p class="source-code">This all seems to work just fine! There are a few ways I would improve this if I was working on </p>
			<p class="source-code">this for a longer period of time.  </p>
			<p class="source-code">1. I would implement the [Vincenty Distance](https://en.wikipedia.org/wiki/Vincenty%27s_formulae) </p>
			<p class="source-code">instead of the Haversine distance, which is much more accurate but cumbersome to implement.  </p>
			<p class="source-code">2. I would vectorize this function and make it more efficient overall. </p>
			<p class="source-code">Because this dataset is only 7 rows long, it wasn't particularly important, </p>
			<p class="source-code">but if this was a crucial function that was run in production we would want to vectorize it for speed. </p>
			<p class="source-code">'''</p>
			<p>Alternatively, you could always just end with a statement about the preceding code and move on to the second question. At this point, our answer to <em class="italic">Question 1</em> is complete and should look similar to the following screenshot:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B16864_09_7.jpg" alt="Figure 9.7 – Taking user input &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Taking user input </p>
			<p>We have now <a id="_idIndexMarker371"/>successfully answered <em class="italic">Question 1</em>! We can always check the distances between these airports by hand to obtain the same result. But let's move on to the second question in our application. </p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>Answering Question 2</h2>
			<p>The second question is far more straightforward and only asks for text responses. Here, the trick is to try to add some lists or Python objects in order to break up large paragraphs of text. To begin, we will explain our attempt at answering the question and then demonstrate how it might look inside a dataframe:</p>
			<p class="source-code">'''</p>
			<p class="source-code">For this transformation, there are a few things </p>
			<p class="source-code">that I would start with. First, I would have to define </p>
			<p class="source-code">what a unique trip actually was. In order to do this, I would </p>
			<p class="source-code">group by the origin, the destination, and the departure date </p>
			<p class="source-code">(for the departure date, often customers will change around </p>
			<p class="source-code">this departure date, so we should group by the date plus or </p>
			<p class="source-code">minus at least 1 buffer day to capture all the correct dates).   </p>
			<p class="source-code">Additionally, we can see that often users search from an entire city, </p>
			<p class="source-code">and then shrink that down into a specific airport. So we should also </p>
			<p class="source-code">consider a group of individual queries from cities and airpots in the </p>
			<p class="source-code">same city, as the same search, and do the same for destination.    </p>
			<p class="source-code">From that point, we should add these important columns to each unique search.</p>
			<p class="source-code">'''</p>
			<p>Now, we can think of some columns that would be useful for when we are making a representation of when a user is searching for flights on this major US airline. We can put them into an example dataframe, as follows: </p>
			<p class="source-code">example_df = pd.DataFrame(columns=['userid', 'number_of_queries', 'round_trip', 'distance', 'number_unique_destinations',</p>
			<p class="source-code">                     'number_unique_origins', 'datetime_first_searched','average_length_of_stay',</p>
			<p class="source-code">                     'length_of_search'])</p>
			<p class="source-code">example_row = {'userid':98593, 'number_of_queries':5, 'round_trip':1,</p>
			<p class="source-code">                   'distance':893, 'number_unique_destinations':5,</p>
			<p class="source-code">                     'number_unique_origins':1, 'datetime_first_searched':'2015-01-09',</p>
			<p class="source-code">                   'average_length_of_stay':5, 'length_of_search':4}</p>
			<p class="source-code">st.write(example_df.append(example_row, ignore_index=True))</p>
			<p>For the remainder of the question, we can add a bit of knowledge regarding how to find the distance between<a id="_idIndexMarker372"/> two points using different methods and then call it a day: </p>
			<p class="source-code">'''</p>
			<p class="source-code">For answering the second part of the question, we should take the euclidian distance </p>
			<p class="source-code">on two normalized vectors. There are two solid options for comparing two </p>
			<p class="source-code">entirely numeric rows, the euclidian distance (which is just the straight line </p>
			<p class="source-code">difference between two values), and the manhattan distance (think of this as the </p>
			<p class="source-code">distance traveled if you had to use city blocks to travel diagonally across manhattan). </p>
			<p class="source-code">Because we have normalized data, and the data is not high dimensional or sparse, I </p>
			<p class="source-code">would recommend using the euclidian distance to start off. This distance would tell </p>
			<p class="source-code">us how similar two trips were.</p>
			<p class="source-code">'''</p>
			<p>The second question's answer should be similar to the following screenshot:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B16864_09_8.jpg" alt="Figure 9.8 – Answering Question 2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Answering Question 2</p>
			<p>As you can see, this example demonstrates how to approach take-home data assignments with the help of the Streamlit library to make more impressive applications. The final step of this work is to deploy this Streamlit app and share the link with the recruiter. I would strongly advise you to deploy this on Heroku to guarantee that no one else can view the <a id="_idIndexMarker373"/>questions or the data that has been provided by the company. You can also take further precautions, such as putting a textbox at the beginning of the application that functions as a hacky password protector for the application, as shown in the following code block:</p>
			<p class="source-code">password_attempt = st.text_input('Please Enter The Password')</p>
			<p class="source-code">if password_attempt != 'example_password':</p>
			<p class="source-code">     st.write('Incorrect Password!')</p>
			<p class="source-code">     st.stop()</p>
			<p>Now, the entire application will not run unless the user inputs <strong class="source-inline">example_password</strong> into the textbox. This is certainly not secure, but it is useful for relatively unimportant (at least, in terms of secrecy) applications such as a take-home application:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B16864_09_9.jpg" alt="Figure 9.9 – Entering the password&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Entering the password</p>
			<p>As you can see, the<a id="_idIndexMarker374"/> only way for this application to load is if the correct password has been entered. Otherwise, the user will see a blank page. Alternatively, you can also set the password in Streamlit Sharing using Streamlit secrets, which is currently a feature in Streamlit for Teams and will be covered in <a href="B16864_11_Final_VK_ePub.xhtml#_idTextAnchor122"><em class="italic">Chapter 11</em></a>, <em class="italic">Using Streamlit for Teams</em>. </p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor104"/>Summary</h1>
			<p>This chapter is the most application-focused chapter we have created so far. We have focused heavily on job applications and the application cycle for data science and machine learning interviews. Additionally, we have learned how to password protect our applications, how to create applications that prove to recruiters and data science hiring managers that we are the skilled data scientists that we know we are, and how to stand out in take-home data science interviews by creating Streamlit apps. The next chapter will focus on Streamlit as a toy, and you will learn how to create public-facing Streamlit projects for the community. </p>
		</div>
	</body></html>