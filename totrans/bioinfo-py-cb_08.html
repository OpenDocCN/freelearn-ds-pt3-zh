<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer059">
<h1 class="chapter-number" id="_idParaDest-184"><a id="_idTextAnchor183"/>7</h1>
<h1 id="_idParaDest-185"><a id="_idTextAnchor184"/>Phylogenetics</h1>
<p>Phylogenetics is the application of molecular sequencing that is used to study the evolutionary relationship among organisms. The typical way to illustrate this process is through the use of phylogenetic trees. The computation of these trees from genomic data is an active field of research with many real-world applications.</p>
<p>In this book, we will take the practical approach that is mentioned to a new level: most of the recipes here are inspired by a recent study on the Ebola virus, researching the recent Ebola outbreak in Africa. This study is called <em class="italic">Genomic surveillance elucidates Ebola virus origin and transmission during the 2014 outbreak</em>, by <em class="italic">Gire et al.</em>, published in <em class="italic">Science</em>. It is available at <a href="https://pubmed.ncbi.nlm.nih.gov/25214632/">https://pubmed.ncbi.nlm.nih.gov/25214632/</a>. Here, we will try to follow a similar methodology to arrive at similar results to the paper.</p>
<p>In this chapter, we will use DendroPy (a phylogenetics library) and Biopython. The <strong class="source-inline">bioinformatics_phylo</strong> Docker image includes all the necessary software.</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Preparing a dataset for phylogenetic analysis</li>
<li>Aligning genetic and genomic data</li>
<li>Comparing sequences</li>
<li>Reconstructing phylogenetic trees</li>
<li>Playing recursively with trees</li>
<li>Visualizing phylogenetic data</li>
</ul>
<h1 id="_idParaDest-186"><a id="_idTextAnchor185"/>Preparing a dataset for phylogenetic analysis</h1>
<p>In this recipe, we <a id="_idIndexMarker505"/>will download and prepare <a id="_idIndexMarker506"/>the dataset to be used for our analysis. The dataset contains complete genomes of the Ebola virus. We will use DendroPy to download and prepare the data.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor186"/>Getting ready</h2>
<p>We will download complete genomes from GenBank; these genomes were collected from various Ebola outbreaks, including several from the 2014 outbreak. Note that there are several virus species that cause the Ebola virus disease; the species involved in the 2014 outbreak (the EBOV virus, which was formally known as the Zaire Ebola virus) is the most common, but this disease is caused by more species of the genus Ebolavirus; four others are also available in a sequenced form. You can read more at <a href="https://en.wikipedia.org/wiki/Ebolavirus">https://en.wikipedia.org/wiki/Ebolavirus</a>.</p>
<p>If you have already gone through the previous chapters, you might panic looking at the potential data sizes involved here; this is not a problem at all because these are genomes of viruses that are each around 19 kbp in size. So, our approximately 100 genomes are actually quite light.</p>
<p>To do this analysis, we will need to install <strong class="source-inline">dendropy</strong>. If you are using Anaconda, please perform the following:</p>
<p class="source-code">conda install –c bioconda dendropy</p>
<p>As usual, this<a id="_idIndexMarker507"/> information is available in the corresponding <a id="_idIndexMarker508"/>Jupyter Notebook file, which is available at <strong class="source-inline">Chapter07/Exploration.py</strong>.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor187"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li>First, let’s start by specifying our data sources using DendroPy, as follows:<p class="source-code">import dendropy</p><p class="source-code">from dendropy.interop import genbank</p><p class="source-code">def get_ebov_2014_sources():</p><p class="source-code">    #EBOV_2014</p><p class="source-code">    #yield 'EBOV_2014', genbank.GenBankDna(id_range=(233036, 233118), prefix='KM')</p><p class="source-code">    yield 'EBOV_2014', genbank.GenBankDna(id_range=(34549, 34563), prefix='KM0')</p><p class="source-code">def get_other_ebov_sources():</p><p class="source-code">    #EBOV other</p><p class="source-code">    yield 'EBOV_1976', genbank.GenBankDna(ids=['AF272001', 'KC242801'])</p><p class="source-code">    yield 'EBOV_1995', genbank.GenBankDna(ids=['KC242796', 'KC242799'])</p><p class="source-code">    yield 'EBOV_2007', genbank.GenBankDna(id_range=(84, 90), prefix='KC2427')</p><p class="source-code">def get_other_ebolavirus_sources():</p><p class="source-code">    #BDBV</p><p class="source-code">    yield 'BDBV', genbank.GenBankDna(id_range=(3, 6), prefix='KC54539')</p><p class="source-code">    yield 'BDBV', genbank.GenBankDna(ids=['FJ217161']) #RESTV</p><p class="source-code">    yield 'RESTV', genbank.GenBankDna(ids=['AB050936', 'JX477165', 'JX477166',  'FJ621583', 'FJ621584', 'FJ621585'])</p><p class="source-code">    #SUDV</p><p class="source-code">    yield 'SUDV', genbank.GenBankDna(ids=['KC242783', 'AY729654', 'EU338380', 'JN638998', 'FJ968794', 'KC589025', 'JN638998'])</p><p class="source-code">    #yield 'SUDV', genbank.GenBankDna(id_range=(89, 92), prefix='KC5453')</p><p class="source-code">    #TAFV</p><p class="source-code">    yield 'TAFV', genbank.GenBankDna(ids=['FJ217162'])</p></li>
</ol>
<p>Here, we have three functions: one to retrieve data from the most recent EBOV outbreak, another to retrieve data from the previous EBOV outbreaks, and one to retrieve data from the outbreaks of other species.</p>
<p>Note that the DendroPy GenBank interface provides several different ways to specify lists or ranges of records to retrieve. Some lines are commented out. These include the code to download more genomes. For our purpose, the subset that we will download is enough.</p>
<ol>
<li value="2">Now, we will<a id="_idIndexMarker509"/> create a set of FASTA files; we <a id="_idIndexMarker510"/>will use these files here and in future recipes:<p class="source-code">other = open('other.fasta', 'w')</p><p class="source-code">sampled = open('sample.fasta', 'w')</p><p class="source-code">for species, recs in get_other_ebolavirus_sources():</p><p class="source-code">    tn = dendropy.TaxonNamespace()</p><p class="source-code">    char_mat = recs.generate_char_matrix(taxon_namespace=tn,</p><p class="source-code">        gb_to_taxon_fn=lambda gb: tn.require_taxon(label='%s_%s' % (species, gb.accession)))</p><p class="source-code">    char_mat.write_to_stream(other, 'fasta')</p><p class="source-code">    char_mat.write_to_stream(sampled, 'fasta')</p><p class="source-code">other.close()</p><p class="source-code">ebov_2014 = open('ebov_2014.fasta', 'w')</p><p class="source-code">ebov = open('ebov.fasta', 'w')</p><p class="source-code">for species, recs in get_ebov_2014_sources():</p><p class="source-code">    tn = dendropy.TaxonNamespace()</p><p class="source-code">    char_mat = recs.generate_char_matrix(taxon_namespace=tn,</p><p class="source-code">        gb_to_taxon_fn=lambda gb: tn.require_taxon(label='EBOV_2014_%s' % gb.accession))</p><p class="source-code">    char_mat.write_to_stream(ebov_2014, 'fasta')</p><p class="source-code">    char_mat.write_to_stream(sampled, 'fasta')</p><p class="source-code">    char_mat.write_to_stream(ebov, 'fasta')</p><p class="source-code">ebov_2014.close()</p><p class="source-code">ebov_2007 = open('ebov_2007.fasta', 'w')</p><p class="source-code">for species, recs in get_other_ebov_sources():</p><p class="source-code">    tn = dendropy.TaxonNamespace()</p><p class="source-code">    char_mat = recs.generate_char_matrix(taxon_namespace=tn,</p><p class="source-code">        gb_to_taxon_fn=lambda gb: tn.require_taxon(label='%s_%s' % (species, gb.accession)))</p><p class="source-code">    char_mat.write_to_stream(ebov, 'fasta')</p><p class="source-code">    char_mat.write_to_stream(sampled, 'fasta')</p><p class="source-code">    if species == 'EBOV_2007':</p><p class="source-code">        char_mat.write_to_stream(ebov_2007, 'fasta')</p><p class="source-code">ebov.close()</p><p class="source-code">ebov_2007.close()</p><p class="source-code">sampled.close()</p></li>
</ol>
<p>We will generate several different FASTA files, which include either all genomes, just EBOV, or just EBOV samples from the 2014 outbreak. In this chapter, we will mostly use the <strong class="source-inline">sample.fasta</strong> file with all genomes.</p>
<p>Note the use of the <strong class="source-inline">dendropy</strong> functions to create FASTA files that are retrieved from GenBank records through conversion. The ID of each sequence in the FASTA file is produced by a lambda function that uses the species and the year, alongside the GenBank accession number.</p>
<ol>
<li value="3">Let’s extract four (of the<a id="_idIndexMarker511"/> total<a id="_idIndexMarker512"/> seven) genes in the virus, as follows:<p class="source-code">my_genes = ['NP', 'L', 'VP35', 'VP40']</p><p class="source-code">def dump_genes(species, recs, g_dls, p_hdls):</p><p class="source-code">    for rec in recs:</p><p class="source-code">        for feature in rec.feature_table:</p><p class="source-code">            if feature.key == 'CDS':</p><p class="source-code">                gene_name = None</p><p class="source-code">                for qual in feature.qualifiers:</p><p class="source-code">                    if qual.name == 'gene':</p><p class="source-code">                        if qual.value in my_genes:</p><p class="source-code">                            gene_name = qual.value</p><p class="source-code">                    elif qual.name == 'translation':</p><p class="source-code">                        protein_translation = qual.value</p><p class="source-code">                if gene_name is not None:</p><p class="source-code">                    locs = feature.location.split('.')</p><p class="source-code">                    start, end = int(locs[0]), int(locs[-1])</p><p class="source-code">                    g_hdls[gene_name].write('&gt;%s_%s\n' % (species, rec.accession))</p><p class="source-code">                    p_hdls[gene_name].write('&gt;%s_%s\n' % (species, rec.accession))</p><p class="source-code">                    g_hdls[gene_name].write('%s\n' % rec.sequence_text[start - 1 : end])</p><p class="source-code">                    p_hdls[gene_name].write('%s\n' % protein_translation)</p><p class="source-code">g_hdls = {}</p><p class="source-code">p_hdls = {}</p><p class="source-code">for gene in my_genes:</p><p class="source-code">    g_hdls[gene] = open('%s.fasta' % gene, 'w')</p><p class="source-code">    p_hdls[gene] = open('%s_P.fasta' % gene, 'w')</p><p class="source-code">for species, recs in get_other_ebolavirus_sources():</p><p class="source-code">    if species in ['RESTV', 'SUDV']:</p><p class="source-code">        dump_genes(species, recs, g_hdls, p_hdls)</p><p class="source-code">for gene in my_genes:</p><p class="source-code">    g_hdls[gene].close()</p><p class="source-code">    p_hdls[gene].close()</p></li>
</ol>
<p>We start by <a id="_idIndexMarker513"/>searching<a id="_idIndexMarker514"/> the first GenBank record for all gene features (please refer to <a href="B17942_03.xhtml#_idTextAnchor068"><em class="italic">Chapter 3</em></a>, <em class="italic">Next Generation Sequencing</em>, or the <strong class="bold">National Center for Biotechnology Information</strong> (<strong class="bold">NCBI</strong>) documentation<a id="_idIndexMarker515"/> for further details; although we will use DendroPy and not Biopython here, the concepts are similar) and write to the FASTA files in order to extract the genes. We put each gene into a different file and only take two virus species. We also get translated proteins, which are available in the records for each gene.</p>
<ol>
<li value="4">Let’s create a function to get the basic statistical information from the alignment, as follows:<p class="source-code">def describe_seqs(seqs):</p><p class="source-code">    print('Number of sequences: %d' % len(seqs.taxon_namespace))</p><p class="source-code">    print('First 10 taxon sets: %s' % ' '.join([taxon.label for taxon in seqs.taxon_namespace[:10]]))</p><p class="source-code">    lens = []</p><p class="source-code">    for tax, seq in seqs.items():</p><p class="source-code">        lens.append(len([x for x in seq.symbols_as_list() if x != '-']))</p><p class="source-code">    print('Genome length: min %d, mean %.1f, max %d' % (min(lens), sum(lens) / len(lens), max(lens)))</p></li>
</ol>
<p>Our function takes a <strong class="source-inline">DnaCharacterMatrix</strong> DendroPy class and counts the number<a id="_idIndexMarker516"/> of<a id="_idIndexMarker517"/> taxons. Then, we extract all the amino acids per sequence (we exclude gaps identified by <strong class="source-inline">-</strong>) to compute the length and report the minimum, mean, and maximum sizes. Take a look at the DendroPy documentation for additional details regarding the API.</p>
<ol>
<li value="5">Let’s inspect the sequence of the EBOV genome and compute the basic statistics, as shown earlier:<p class="source-code">ebov_seqs = dendropy.DnaCharacterMatrix.get_from_path('ebov.fasta', schema='fasta', data_type='dna')</p><p class="source-code">print('EBOV')</p><p class="source-code">describe_seqs(ebov_seqs)</p><p class="source-code">del ebov_seqs</p></li>
</ol>
<p>We then call a function and get 25 sequences with a minimum size of 18,700, a mean size of 18,925.2, and a maximum size of 18,959. This is a small genome when compared to eukaryotes.</p>
<p>Note that at the very end, the memory structure has been deleted. This is because the memory footprint is still quite big (DendroPy is a pure Python library and has some costs in terms of speed and memory). Be careful with your memory usage when you load full genomes.</p>
<ol>
<li value="6">Now, let’s inspect <a id="_idIndexMarker518"/>the other Ebola virus<a id="_idIndexMarker519"/> genome file and count the number of different species:<p class="source-code">print('ebolavirus sequences')</p><p class="source-code">ebolav_seqs = dendropy.DnaCharacterMatrix.get_from_path('other.fasta', schema='fasta', data_type='dna')</p><p class="source-code">describe_seqs(ebolav_seqs)</p><p class="source-code">from collections import defaultdict</p><p class="source-code">species = defaultdict(int)</p><p class="source-code">for taxon in ebolav_seqs.taxon_namespace:</p><p class="source-code">    toks = taxon.label.split('_')</p><p class="source-code">    my_species = toks[0]</p><p class="source-code">    if my_species == 'EBOV':</p><p class="source-code">        ident = '%s (%s)' % (my_species, toks[1])</p><p class="source-code">    else:</p><p class="source-code">        ident = my_species</p><p class="source-code">    species[ident] += 1</p><p class="source-code">for my_species, cnt in species.items():</p><p class="source-code">    print("%20s: %d" % (my_species, cnt))</p><p class="source-code">del ebolav_seqs</p></li>
</ol>
<p>The name prefix of each taxon is indicative of the species, and we leverage that to fill a dictionary of counts.</p>
<p>The output for the species and the EBOV breakdown is detailed next (with the legend as Bundibugyo virus=BDBV, Tai Forest virus=TAFV, Sudan virus=SUDV, and Reston virus=RESTV; we have 1 TAFV, 6 SUDV, 6 RESTV, and 5 BDBV).</p>
<ol>
<li value="7">Let’s extract<a id="_idIndexMarker520"/> the <a id="_idIndexMarker521"/>basic statistics of a gene in the virus:<p class="source-code">gene_length = {}</p><p class="source-code">my_genes = ['NP', 'L', 'VP35', 'VP40']</p><p class="source-code">for name in my_genes:</p><p class="source-code">    gene_name = name.split('.')[0]</p><p class="source-code">    seqs =    </p><p class="source-code">dendropy.DnaCharacterMatrix.get_from_path('%s.fasta' % name, schema='fasta', data_type='dna')</p><p class="source-code">    gene_length[gene_name] = []</p><p class="source-code">    for tax, seq in seqs.items():</p><p class="source-code">        gene_length[gene_name].append(len([x for x in  seq.symbols_as_list() if x != '-'])</p><p class="source-code">for gene, lens in gene_length.items():</p><p class="source-code">    print ('%6s: %d' % (gene, sum(lens) / len(lens)))</p></li>
</ol>
<p>This allows you to have an overview of the basic gene information (that is, the name and the mean size), as follows:</p>
<p class="source-code"><strong class="bold">NP: 2218</strong></p>
<p class="source-code"><strong class="bold">L: 6636</strong></p>
<p class="source-code"><strong class="bold">VP35: 990</strong></p>
<p class="source-code"><strong class="bold">VP40: 988</strong></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor188"/>There’s more...</h2>
<p>Most of the work here can probably be performed with Biopython, but DendroPy has additional functionalities that will be explored in later recipes. Furthermore, as you will discover, it’s more robust with certain tasks (such as file parsing). More importantly, there is another Python library to perform phylogenetics that you should consider. It’s called ETE and is <a id="_idIndexMarker522"/>available at <a href="http://etetoolkit.org/">http://etetoolkit.org/</a>.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor189"/>See also</h2>
<ul>
<li>The US <strong class="bold">Center for Disease Control</strong> (<strong class="bold">CDC</strong>) has <a id="_idIndexMarker523"/>a good introductory page on the Ebola virus disease at <a href="https://www.cdc.gov/vhf/ebola/history/summaries.xhtml">https://www.cdc.gov/vhf/ebola/history/summaries.xhtml</a>.</li>
<li>The reference application in phylogenetics is Joe Felsenstein’s <em class="italic">Phylip</em>, which can be found at <a href="http://evolution.genetics.washington.edu/phylip.xhtml">http://evolution.genetics.washington.edu/phylip.xhtml</a>.</li>
<li>We will use the Nexus and Newick formats in future recipes (<a href="http://evolution.genetics.washington.edu/phylip/newicktree.xhtml">http://evolution.genetics.washington.edu/phylip/newicktree.xhtml</a>), but do also check out the PhyloXML format (<a href="http://en.wikipedia.org/wiki/PhyloXML">http://en.wikipedia.org/wiki/PhyloXML</a>).</li>
</ul>
<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Aligning genetic and genomic data</h1>
<p>Before we <a id="_idIndexMarker524"/>can perform <a id="_idIndexMarker525"/>any phylogenetic analysis, we need to align our genetic and genomic data. Here, we will use MAFFT (<a href="http://mafft.cbrc.jp/alignment/software/">http://mafft.cbrc.jp/alignment/software/</a>) to<a id="_idIndexMarker526"/> perform the genome analysis. The gene <a id="_idIndexMarker527"/>analysis will be performed using MUSCLE (<a href="http://www.drive5.com/muscle/">http://www.drive5.com/muscle/</a>).</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor191"/>Getting ready</h2>
<p>To perform the genomic alignment, you will need to install MAFFT. Additionally, to perform the genic<a id="_idIndexMarker528"/> alignment, MUSCLE will be used. Also, we will use trimAl (<a href="http://trimal.cgenomics.org/">http://trimal.cgenomics.org/</a>) to remove spurious sequences and poorly aligned regions in an automated manner. All packages are available from Bioconda:</p>
<p class="source-code">conda install –c bioconda mafft trimal muscle=3.8</p>
<p>As usual, this information is available in the corresponding Jupyter Notebook file at <strong class="source-inline">Chapter07/Alignment.py</strong>. You will need to run the previous notebook beforehand, as it will generate the files that are required here. In this chapter, we will use Biopython.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor192"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li value="1">Now, we will run MAFFT to align the genomes, as shown in the following code. This task is CPU-intensive and memory-intensive, and it will take quite some time:<p class="source-code">from Bio.Align.Applications import MafftCommandline</p><p class="source-code">mafft_cline = MafftCommandline(input='sample.fasta', ep=0.123, reorder=True, maxiterate=1000, localpair=True)</p><p class="source-code">print(mafft_cline)</p><p class="source-code">stdout, stderr = mafft_cline()</p><p class="source-code">with open('align.fasta', 'w') as w:</p><p class="source-code">    w.write(stdout)</p></li>
</ol>
<p>The<a id="_idIndexMarker529"/> preceding <a id="_idIndexMarker530"/>parameters are the same as the ones specified in the supplementary material of the paper. We will use the Biopython interface to call MAFFT.</p>
<ol>
<li value="2">Let’s use trimAl to trim sequences, as follows:<p class="source-code">os.system('trimal -automated1 -in align.fasta -out trim.fasta -fasta')</p></li>
</ol>
<p>Here, we just call the application using <strong class="source-inline">os.system</strong>. The <strong class="source-inline">-automated1</strong> parameter is from the supplementary material.</p>
<ol>
<li value="3">Additionally, we can run <strong class="source-inline">MUSCLE</strong> to align the proteins:<p class="source-code">from Bio.Align.Applications import MuscleCommandline</p><p class="source-code">my_genes = ['NP', 'L', 'VP35', 'VP40']</p><p class="source-code">for gene in my_genes:</p><p class="source-code">    muscle_cline = MuscleCommandline(input='%s_P.fasta' % gene)</p><p class="source-code">    print(muscle_cline)</p><p class="source-code">    stdout, stderr = muscle_cline()</p><p class="source-code">    with open('%s_P_align.fasta' % gene, 'w') as w:</p><p class="source-code">    w.write(stdout)</p></li>
</ol>
<p>We use Biopython to call an external application. Here, we will align a set of proteins.</p>
<p>Note that to <a id="_idIndexMarker531"/>make <a id="_idIndexMarker532"/>some analysis of molecular evolution, we have to compare aligned genes, not proteins (for example, comparing synonymous and nonsynonymous mutations). However, we just have aligned the proteins. Therefore, we have to convert the alignment into the gene sequence form.</p>
<ol>
<li value="4">Let’s align the genes by finding three nucleotides that correspond to each amino acid:<p class="source-code">from Bio import SeqIO</p><p class="source-code">from Bio.Seq import Seq</p><p class="source-code">from Bio.SeqRecord import SeqRecord</p><p class="source-code">for gene in my_genes:</p><p class="source-code">    gene_seqs = {}</p><p class="source-code">    unal_gene = SeqIO.parse('%s.fasta' % gene, 'fasta')</p><p class="source-code">    for rec in unal_gene:</p><p class="source-code">        gene_seqs[rec.id] = rec.seq</p><p class="source-code">    al_prot = SeqIO.parse('%s_P_align.fasta' % gene, 'fasta')</p><p class="source-code">    al_genes = []</p><p class="source-code">    for protein in al_prot:</p><p class="source-code">        my_id = protein.id</p><p class="source-code">        seq = ''</p><p class="source-code">        pos = 0</p><p class="source-code">        for c in protein.seq:</p><p class="source-code">            if c == '-':</p><p class="source-code">                seq += '---'</p><p class="source-code">            else:</p><p class="source-code">                seq += str(gene_seqs[my_id][pos:pos + 3])</p><p class="source-code">                pos += 3</p><p class="source-code">        al_genes.append(SeqRecord(Seq(seq), id=my_id))</p><p class="source-code">    SeqIO.write(al_genes, '%s_align.fasta' % gene, 'fasta')</p></li>
</ol>
<p>The code gets the <a id="_idIndexMarker533"/>protein <a id="_idIndexMarker534"/>and the gene coding. If a gap is found in a protein, three gaps are written; if an amino acid is found, the corresponding nucleotides of the gene are written.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor193"/>Comparing sequences</h1>
<p>Here, we will <a id="_idIndexMarker535"/>compare the sequences we aligned in the previous recipe. We will perform gene-wide and genome-wide comparisons.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Getting ready</h2>
<p>We will use DendroPy and will require the results from the previous two recipes. As usual, this information is available in the corresponding notebook at <strong class="source-inline">Chapter07/Comparison.py</strong>.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor195"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li value="1">Let’s start analyzing the gene data. For simplicity, we will only use data from two other species of the genus Ebola virus that are available in the extended dataset, that is, the Reston virus (<strong class="source-inline">RESTV</strong>) and the Sudan virus (<strong class="source-inline">SUDV</strong>):<p class="source-code">import os</p><p class="source-code">from collections import OrderedDict</p><p class="source-code">import dendropy</p><p class="source-code">from dendropy.calculate import popgenstat</p><p class="source-code">genes_species = OrderedDict()</p><p class="source-code">my_species = ['RESTV', 'SUDV']</p><p class="source-code">my_genes = ['NP', 'L', 'VP35', 'VP40']</p><p class="source-code">for name in my_genes:</p><p class="source-code">    gene_name = name.split('.')[0]</p><p class="source-code">    char_mat = dendropy.DnaCharacterMatrix.get_from_path('%s_align.fasta' % name, 'fasta')</p><p class="source-code">    genes_species[gene_name] = {}</p><p class="source-code">    </p><p class="source-code">    for species in my_species:</p><p class="source-code">        genes_species[gene_name][species] = dendropy.DnaCharacterMatrix()</p><p class="source-code">    for taxon, char_map in char_mat.items():</p><p class="source-code">        species = taxon.label.split('_')[0]</p><p class="source-code">        if species in my_species:</p><p class="source-code">            genes_species[gene_name][species].taxon_namespace.add_taxon(taxon)</p><p class="source-code">            genes_species[gene_name][species][taxon] = char_map</p></li>
</ol>
<p>We get four genes<a id="_idIndexMarker536"/> that we stored in the first recipe and aligned in the second.</p>
<p>We load all the files (which are FASTA formatted) and create a dictionary with all of the genes. Each entry will be a dictionary itself with the RESTV or SUDV species, including all reads. This is not a lot of data, just a handful of genes.</p>
<ol>
<li value="2">Let’s print some basic information for all four genes, such as the number of segregating sites (<strong class="source-inline">seg_sites</strong>), nucleotide diversity (<strong class="source-inline">nuc_div</strong>), Tajima’s D (<strong class="source-inline">taj_d</strong>), and Waterson’s theta (<strong class="source-inline">wat_theta</strong>) (check out the <em class="italic">There’s more...</em> section of this recipe for links on these statistics):<p class="source-code">import numpy as np</p><p class="source-code">import pandas as pd</p><p class="source-code">summary = np.ndarray(shape=(len(genes_species), 4 * len(my_species)))</p><p class="source-code">stats = ['seg_sites', 'nuc_div', 'taj_d', 'wat_theta']</p><p class="source-code">for row, (gene, species_data) in enumerate(genes_species.items()):</p><p class="source-code">    for col_base, species in enumerate(my_species):</p><p class="source-code">        summary[row, col_base * 4] = popgenstat.num_segregating_sites(species_data[species])</p><p class="source-code">        summary[row, col_base * 4 + 1] = popgenstat.nucleotide_diversity(species_data[species])</p><p class="source-code">        summary[row, col_base * 4 + 2] = popgenstat.tajimas_d(species_data[species])</p><p class="source-code">        summary[row, col_base * 4 + 3] = popgenstat.wattersons_theta(species_data[species])</p><p class="source-code">columns = []</p><p class="source-code">for species in my_species:</p><p class="source-code">    columns.extend(['%s (%s)' % (stat, species) for stat in stats])</p><p class="source-code">df = pd.DataFrame(summary, index=genes_species.keys(), columns=columns)</p><p class="source-code">df # vs print(df)</p></li>
<li>First, let’s look<a id="_idIndexMarker537"/> at the output, and then we’ll explain how to build it:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 7.1 – A DataFrame for the virus dataset " height="128" src="image/B17942_07_001.jpg" width="893"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A DataFrame for the virus dataset</p>
<p>I used a <strong class="source-inline">pandas</strong> DataFrame to print the results because it’s really tailored to deal with an operation like this. We will initialize our DataFrame with a NumPy multidimensional array with four rows (genes) and four statistics times the two species.</p>
<p>The statistics, such as the number of segregating sites, nucleotide diversity, Tajima’s D, and Watterson’s theta, are computed by DendroPy. Note the placement of individual data points in the array (the coordinate computation).</p>
<p>Look at the very last line: if you are in Jupyter, just putting <strong class="source-inline">df</strong> at the end will render the DataFrame and the cell output, too. If you are not in a notebook, use <strong class="source-inline">print(df)</strong> (you can also perform this in a notebook, but it will not look as pretty).</p>
<ol>
<li value="4">Now, let’s extract <a id="_idIndexMarker538"/>similar information, but genome-wide instead of only gene-wide. In this case, we will use a subsample of two EBOV outbreaks (from 2007 and 2014). We will perform a function to display basic statistics, as follows:<p class="source-code">def do_basic_popgen(seqs):</p><p class="source-code">    num_seg_sites = popgenstat.num_segregating_sites(seqs)</p><p class="source-code">    avg_pair = popgenstat.average_number_of_pairwise_differences(seqs)</p><p class="source-code">    nuc_div = popgenstat.nucleotide_diversity(seqs)</p><p class="source-code">    print('Segregating sites: %d, Avg pairwise diffs: %.2f, Nucleotide diversity %.6f' % (num_seg_sites, avg_pair, nuc_div))</p><p class="source-code">    print("Watterson's theta: %s" % popgenstat.wattersons_theta(seqs))</p><p class="source-code">    print("Tajima's D: %s" % popgenstat.tajimas_d(seqs))</p></li>
</ol>
<p>By now, this function should be easy to understand, given the preceding examples.</p>
<ol>
<li value="5">Now, let’s extract a<a id="_idIndexMarker539"/> subsample of the data properly, and output the statistical information:<p class="source-code">ebov_seqs = dendropy.DnaCharacterMatrix.get_from_path(</p><p class="source-code">    'trim.fasta', schema='fasta', data_type='dna')</p><p class="source-code">sl_2014 = []</p><p class="source-code">drc_2007 = []</p><p class="source-code">ebov2007_set = dendropy.DnaCharacterMatrix()</p><p class="source-code">ebov2014_set = dendropy.DnaCharacterMatrix()</p><p class="source-code">for taxon, char_map in ebov_seqs.items():</p><p class="source-code">    print(taxon.label)</p><p class="source-code">    if taxon.label.startswith('EBOV_2014') and len(sl_2014) &lt; 8:</p><p class="source-code">        sl_2014.append(char_map)</p><p class="source-code">        ebov2014_set.taxon_namespace.add_taxon(taxon)</p><p class="source-code">        ebov2014_set[taxon] = char_map</p><p class="source-code">    elif taxon.label.startswith('EBOV_2007'):</p><p class="source-code">        drc_2007.append(char_map)</p><p class="source-code">        ebov2007_set.taxon_namespace.add_taxon(taxon)</p><p class="source-code">        ebov2007_set[taxon] = char_map</p><p class="source-code">        #ebov2007_set.extend_map({taxon: char_map})</p><p class="source-code">del ebov_seqs</p><p class="source-code">print('2007 outbreak:')</p><p class="source-code">print('Number of individuals: %s' % len(ebov2007_set.taxon_set))</p><p class="source-code">do_basic_popgen(ebov2007_set)</p><p class="source-code">print('\n2014 outbreak:')</p><p class="source-code">print('Number of individuals: %s' % len(ebov2014_set.taxon_set))</p><p class="source-code">do_basic_popgen(ebov2014_set)</p></li>
</ol>
<p>Here, we will construct two versions of two datasets: the 2014 outbreak and the 2007 outbreak. We will generate one version as <strong class="source-inline">DnaCharacterMatrix</strong> and another as a list. We will use this list version at the end of this recipe.</p>
<p>As the dataset for the EBOV outbreak of 2014 is large, we subsample it with just eight individuals, which is a comparable sample size to the dataset of the 2007 outbreak.</p>
<p>Again, we <a id="_idIndexMarker540"/>delete the <strong class="source-inline">ebov_seqs</strong> data structure to conserve memory (these are genomes, not only genes).</p>
<p>If you perform this analysis on the complete dataset for the 2014 outbreak available on GenBank (99 samples), be prepared to wait for quite some time.</p>
<p>The output is shown here:</p>
<p class="source-code"><strong class="bold">2007 outbreak:</strong></p>
<p class="source-code"><strong class="bold">Number of individuals: 7</strong></p>
<p class="source-code"><strong class="bold">Segregating sites: 25, Avg pairwise diffs: 7.71, Nucleotide diversity 0.000412</strong></p>
<p class="source-code"><strong class="bold">Watterson's theta: 10.204081632653063</strong></p>
<p class="source-code"><strong class="bold">Tajima's D: -1.383114157484101</strong></p>
<p class="source-code"><strong class="bold">2014 outbreak:</strong></p>
<p class="source-code"><strong class="bold">Number of individuals: 8</strong></p>
<p class="source-code"><strong class="bold">Segregating sites: 6, Avg pairwise diffs: 2.79, Nucleotide diversity 0.000149</strong></p>
<p class="source-code"><strong class="bold">Watterson's theta: 2.31404958677686</strong></p>
<p class="source-code"><strong class="bold">Tajima's D: 0.9501208027581887</strong></p>
<ol>
<li value="6">Finally, we<a id="_idIndexMarker541"/> perform some statistical analysis on the two subsets of 2007 and 2014, as follows:<p class="source-code">pair_stats = popgenstat.PopulationPairSummaryStatistics(sl_2014, drc_2007)</p><p class="source-code">print('Average number of pairwise differences irrespective of population: %.2f' % pair_stats.average_number_of_pairwise_differences)</p><p class="source-code">print('Average number of pairwise differences between populations: %.2f' % pair_stats.average_number_of_pairwise_differences_between)</p><p class="source-code">print('Average number of pairwise differences within populations: %.2f' % pair_stats.average_number_of_pairwise_differences_within)</p><p class="source-code">print('Average number of net pairwise differences : %.2f' % pair_stats.average_number_of_pairwise_differences_net)</p><p class="source-code">print('Number of segregating sites: %d' % pair_stats.num_segregating_sites)</p><p class="source-code">print("Watterson's theta: %.2f" % pair_stats.wattersons_theta)</p><p class="source-code">print("Wakeley's Psi: %.3f" % pair_stats.wakeleys_psi)</p><p class="source-code">print("Tajima's D: %.2f" % pair_stats.tajimas_d)</p></li>
</ol>
<p>Note that we will perform something slightly different here; we will ask DendroPy (<strong class="source-inline">popgenstat.PopulationPairSummaryStatistics</strong>) to directly compare two populations so that we get the following results:</p>
<p class="source-code"><strong class="bold">Average number of pairwise differences irrespective of population: 284.46</strong></p>
<p class="source-code"><strong class="bold">Average number of pairwise differences between populations: 535.82</strong></p>
<p class="source-code"><strong class="bold">Average number of pairwise differences within populations: 10.50</strong></p>
<p class="source-code"><strong class="bold">Average number of net pairwise differences : 525.32</strong></p>
<p class="source-code"><strong class="bold">Number of segregating sites: 549</strong></p>
<p class="source-code"><strong class="bold">Watterson's theta: 168.84</strong></p>
<p class="source-code"><strong class="bold">Wakeley's Psi: 0.308</strong></p>
<p class="source-code"><strong class="bold">Tajima's D: 3.05</strong></p>
<p>Now the number of segregating sites is much bigger because we are dealing with data from two different populations that are reasonably diverged. The average number of pairwise <a id="_idIndexMarker542"/>differences among populations is quite large. As expected, this is much larger than the average number for the population, irrespective of the population information.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>There’s more...</h2>
<p>If you want to get many phylogenetic and population genetics formulas, including the ones used here, I strongly recommend that <a id="_idIndexMarker543"/>you get the manual for the Arlequin software suite (<a href="http://cmpg.unibe.ch/software/arlequin35/">http://cmpg.unibe.ch/software/arlequin35/</a>). If you do not use Arlequin to perform data analysis, its manual is probably the best reference to implement formulas. This free document probably has more relevant details on formula implementation than any book that I can remember.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor197"/>Reconstructing phylogenetic trees</h1>
<p>Here, we will <a id="_idIndexMarker544"/>construct phylogenetic trees for the aligned dataset for all Ebola species. We will follow a procedure that’s quite similar to the one used in the paper.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Getting ready</h2>
<p>This recipe requires RAxML, a program for maximum likelihood-based inference of large phylogenetic trees, which you can check out at <a href="http://sco.h-its.org/exelixis/software.xhtml">http://sco.h-its.org/exelixis/software.xhtml</a>. Bioconda also includes it, but it is named <strong class="source-inline">raxml</strong>. Note that the binary is called <strong class="source-inline">raxmlHPC</strong>. You can perform the following command to install it:</p>
<p class="source-code">conda install –c bioconda raxml</p>
<p>The preceding code is simple, but it will take time to execute because it will call RAxML (which is computationally intensive). If you opt to use the DendroPy interface, it might also become memory-intensive. We will interact with RAxML, DendroPy, and Biopython, leaving you with a choice of which interface to use; DendroPy gives you an easy way to access results, whereas Biopython is less memory-intensive. Although there is a recipe for visualization later in this chapter, we will, nonetheless, plot one of our generated trees here.</p>
<p>As usual, this information is available in the corresponding notebook at <strong class="source-inline">Chapter07/Reconstruction.py</strong>. You will need the output of the previous recipe to complete this one.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor199"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li value="1">For DendroPy, we will load the data first and then reconstruct the genus dataset, as follows:<p class="source-code">import os</p><p class="source-code">import shutil</p><p class="source-code">import dendropy</p><p class="source-code">from dendropy.interop import raxml</p><p class="source-code">ebola_data = dendropy.DnaCharacterMatrix.get_from_path('trim.fasta', 'fasta')</p><p class="source-code">rx = raxml.RaxmlRunner()</p><p class="source-code">ebola_tree = rx.estimate_tree(ebola_data, ['-m', 'GTRGAMMA', '-N', '10'])</p><p class="source-code">print('RAxML temporary directory %s:' % rx.working_dir_path)</p><p class="source-code">del ebola_data</p></li>
</ol>
<p>Remember that the size of the data structure for this is quite big; therefore, ensure that you have enough memory to load this (at least 10 GB).</p>
<p>Be prepared to<a id="_idIndexMarker545"/> wait for some time. Depending on your computer, this could take more than one hour. If it takes longer, consider restarting the process, as sometimes a RAxML bug might occur.</p>
<p>We will run RAxML with the GTRΓ nucleotide substitution model, as specified in the paper. We will only perform 10 replicates to speed up the results, but you should probably do a lot more, say 100. At the end of the process, we will delete the genome data from memory as it takes up a lot of memory.</p>
<p>The <strong class="source-inline">ebola_data</strong> variable will have the best RAxML tree, with distances included. The <strong class="source-inline">RaxmlRunner</strong> object will have access to other information generated by RAxML. Let’s print the directory where DendroPy will execute RAxML. If you inspect this directory, you will find a lot of files. As RAxML returns the best tree, you might want to ignore all of these files, but we will discuss this a little in the alternative Biopython step.</p>
<ol>
<li value="2">We will save trees for future analysis; in our case, it will be a visualization, as shown in the following code:<p class="source-code">ebola_tree.write_to_path('my_ebola.nex', 'nexus')</p></li>
</ol>
<p>We will write sequences to a NEXUS file because we need to store the topology information. FASTA is not enough here.</p>
<ol>
<li value="3">Let’s visualize our genus tree, as follows:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">from Bio import Phylo</p><p class="source-code">my_ebola_tree = Phylo.read('my_ebola.nex', 'nexus')</p><p class="source-code">my_ebola_tree.name = 'Our Ebolavirus tree'</p><p class="source-code">fig = plt.figure(figsize=(16, 18))</p><p class="source-code">ax = fig.add_subplot(1, 1, 1)</p><p class="source-code">Phylo.draw(my_ebola_tree, axes=ax)</p></li>
</ol>
<p>We will defer<a id="_idIndexMarker546"/> the explanation of this code until we come to the proper recipe later, but if you look at the following diagram and compare it with the results from the paper, you will clearly see that it looks like a step in the right direction. For example, all individuals from the same species are clustered together.</p>
<p>You will notice that trimAl changed the names of its sequences, for example, by adding their sizes. This is easy to solve; we will deal with this in the <em class="italic">Visualizing phylogenetic data</em> recipe:</p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 7.2 – The phylogenetic tree that we generated with RAxML for all Ebola viruses " height="1039" src="image/B17942_07_002.jpg" width="944"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The phylogenetic tree that we generated with RAxML for all Ebola viruses</p>
<ol>
<li value="4">Let’s reconstruct <a id="_idIndexMarker547"/>the phylogenetic tree with RAxML via Biopython. The Biopython interface is less declarative, but much more memory-efficient than DendroPy. So, after running it, it will be your responsibility to process the output, whereas DendroPy automatically returns the best tree, as shown in the following code:<p class="source-code">import random</p><p class="source-code">import shutil</p><p class="source-code">from Bio.Phylo.Applications import RaxmlCommandline</p><p class="source-code">raxml_cline = RaxmlCommandline(sequences='trim.fasta', model='GTRGAMMA', name='biopython', num_replicates='10', parsimony_seed=random.randint(0, sys.maxsize), working_dir=os.getcwd() + os.sep + 'bp_rx')</p><p class="source-code">print(raxml_cline)</p><p class="source-code">try:</p><p class="source-code">    os.mkdir('bp_rx')</p><p class="source-code">except OSError:</p><p class="source-code">    shutil.rmtree('bp_rx')</p><p class="source-code">    os.mkdir('bp_rx')</p><p class="source-code">out, err = raxml_cline()</p></li>
</ol>
<p>DendroPy has <a id="_idIndexMarker548"/>a more declarative interface than Biopython, so you can take care of a few extra things. You should specify the seed (Biopython will put a fixed default of 10,000 if you do not do so) and the working directory. With RAxML, the working directory specification requires the absolute path.</p>
<ol>
<li value="5">Let’s inspect the outcome of the Biopython run. While the RAxML output is the same (save for stochasticity) for DendroPy and Biopython, DendroPy abstracts away a few things. With Biopython, you need to take care of the results yourself. You can also perform this with DendroPy; however, in this case, it is optional:<p class="source-code">from Bio import Phylo</p><p class="source-code">biopython_tree = Phylo.read('bp_rx/RAxML_bestTree.biopython', 'newick')</p></li>
</ol>
<p>The preceding code will read the best tree from the RAxML run. The name of the file was appended with the project name that you specified in the previous step (in this case, <strong class="source-inline">biopython</strong>).</p>
<p>Take a look at the content of the <strong class="source-inline">bp_rx</strong> directory; here, you will find all the outputs from RAxML, including<a id="_idIndexMarker549"/> all 10 alternative trees.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor200"/>There’s more...</h2>
<p>Although the purpose of this book is not to teach phylogenetic analysis, it’s important to know why we do not inspect consensus and support information in the tree topology. You should research this in your dataset. For more information, refer to <a href="http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf">http://www.geol.umd.edu/~tholtz/G331/lectures/cladistics5.pdf</a>.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Playing recursively with trees</h1>
<p>This is not a <a id="_idIndexMarker550"/>book about programming in Python, as the topic is vast. Having said that, it’s not common for introductory Python books to discuss recursive programming at length. Usually, recursive programming techniques are well tailored to deal with trees. It is also a required programming strategy with functional programming dialects, which can be quite useful when you perform concurrent processing. This is common when processing very large datasets.</p>
<p>The phylogenetic notion of a tree is slightly different from that in computer science. Phylogenetic trees can be rooted (if so, then they are normal tree data structures) or unrooted, making them undirected acyclic graphs. Additionally, phylogenetic trees can have weights on their edges. Therefore, be mindful of this when you read the documentation; if the text is written by a phylogeneticist, you can expect the tree (rooted and unrooted), while most other documents will use undirected acyclic graphs for unrooted trees. In this recipe, we will assume that all of the trees are rooted.</p>
<p>Finally, note that while this recipe is mostly devised to help you understand recursive algorithms and tree-like structures, the final part is actually quite practical and fundamental for the next recipe to work.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor202"/>Getting ready</h2>
<p>You will need to have the files from the previous recipe. As usual, you can find this content in the <strong class="source-inline">Chapter07/Trees.py</strong> notebook file. Here, we will use DendroPy’s tree representations. Note that most of this code is easily generalizable compared to other tree representations and libraries (phylogenetic or not).</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor203"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li value="1">First, let’s load the RAxML-generated tree for all Ebola viruses, as follows:<p class="source-code">import dendropy</p><p class="source-code">ebola_raxml = dendropy.Tree.get_from_path('my_ebola.nex', 'nexus')</p></li>
<li>Then, we need<a id="_idIndexMarker551"/> to compute the level of each node (the distance to the root node):<p class="source-code">def compute_level(node, level=0):</p><p class="source-code">    for child in node.child_nodes():</p><p class="source-code">        compute_level(child, level + 1)</p><p class="source-code">    if node.taxon is not None:</p><p class="source-code">        print("%s: %d %d" % (node.taxon, node.level(), level))</p><p class="source-code">compute_level(ebola_raxml.seed_node)</p></li>
</ol>
<p>DendroPy’s node representation has a level method (which is used for comparison), but the point here is to introduce a recursive algorithm, so we will implement it anyway.</p>
<p>Note how the function works; it’s called with <strong class="source-inline">seed_node</strong> (which is the root node, since the code works under the assumption that we are dealing with rooted trees). The default level for the root node is <strong class="source-inline">0</strong>. The function will then call itself for all its children nodes, increasing the level by one. Then, for each node that is not a leaf (that is, it is internal to the tree), the calling will be repeated, and this will recurse until we get to the leaf nodes.</p>
<p>For the leaf nodes, we then print the level (we could have done the same for the internal nodes) and show the same information computed by DendroPy’s internal function.</p>
<ol>
<li value="3">Now, let’s compute the height of each node. The height of the node is the number of edges of<a id="_idIndexMarker552"/> the maximum downward path (going to the leaves), starting on that node, as follows:<p class="source-code">def compute_height(node):</p><p class="source-code">    children = node.child_nodes()</p><p class="source-code">    if len(children) == 0:</p><p class="source-code">        height = 0</p><p class="source-code">    else:</p><p class="source-code">    height = 1 + max(map(lambda x: compute_height(x), children))</p><p class="source-code">    desc = node.taxon or 'Internal'</p><p class="source-code">    print("%s: %d %d" % (desc, height, node.level()))</p><p class="source-code">    return height</p><p class="source-code">compute_height(ebola_raxml.seed_node)</p></li>
</ol>
<p>Here, we will use the same recursive strategy, but each node will return its height to its parent. If the node is a leaf, then the height is <strong class="source-inline">0</strong>; if not, then it’s <strong class="source-inline">1</strong> plus the maximum height of its entire offspring.</p>
<p>Note that we use a map over a lambda function to get the heights of all the children of the current node. Then, we choose the maximum (the <strong class="source-inline">max</strong> function performs a <strong class="source-inline">reduce</strong> operation here because it summarizes all of the values that are reported). If you are relating this to MapReduce frameworks, you are correct; they are inspired by functional programming dialects like these.</p>
<ol>
<li value="4">Now, let’s compute the number of offspring for each node. By now, this should be quite easy to understand:<p class="source-code">def compute_nofs(node):</p><p class="source-code">    children = node.child_nodes()</p><p class="source-code">    nofs = len(children)</p><p class="source-code">    map(lambda x: compute_nofs(x), children)</p><p class="source-code">    desc = node.taxon or 'Internal'</p><p class="source-code">    print("%s: %d %d" % (desc, nofs, node.level()))</p><p class="source-code">compute_nofs(ebola_raxml.seed_node)</p></li>
<li>Now we will <a id="_idIndexMarker553"/>print all of the leaves (this is, apparently, trivial):<p class="source-code">def print_nodes(node):</p><p class="source-code">    for child in node.child_nodes():</p><p class="source-code">        print_nodes(child)</p><p class="source-code">    if node.taxon is not None:</p><p class="source-code">        print('%s (%d)' % (node.taxon, node.level()))</p><p class="source-code">print_nodes(ebola_raxml.seed_node)</p></li>
</ol>
<p>Note that all the functions that we have developed so far impose a very clear traversal pattern on the tree. It calls its first offspring, then that offspring will call their offspring, and so on; only after this will the function be able to call its next offspring in a depth-first pattern. However, we can do things differently.</p>
<ol>
<li value="6">Now, let’s print the leaf nodes in a breadth-first manner, that is, we will print the leaves with the lowest level (closer to the root) first, as follows:<p class="source-code">from collections import deque</p><p class="source-code">def print_breadth(tree):</p><p class="source-code">    queue = deque()</p><p class="source-code">    queue.append(tree.seed_node)</p><p class="source-code">    while len(queue) &gt; 0:</p><p class="source-code">        process_node = queue.popleft()</p><p class="source-code">        if process_node.taxon is not None:</p><p class="source-code">            print('%s (%d)' % (process_node.taxon, process_node.level()))</p><p class="source-code">        else:</p><p class="source-code">            for child in process_node.child_nodes():</p><p class="source-code">                queue.append(child)</p><p class="source-code">print_breadth(ebola_raxml)</p></li>
</ol>
<p>Before we explain this algorithm, let’s look at how different the result from this run will be <a id="_idIndexMarker554"/>compared to the previous one. For starters, take a look at the following diagram. If you print the nodes by depth-first order, you will get Y, A, X, B, and C. But if you perform a breath-first traversal, you will get X, B, C, Y, and A. Tree traversal will have an impact on how the nodes are visited; more often than not, this is important.</p>
<p>Regarding the preceding code, here, we will use a completely different approach, as we will perform an iterative algorithm. We will use a <strong class="bold">first-in, first-out</strong> (<strong class="bold">FIFO</strong>) queue <a id="_idIndexMarker555"/>to help order our nodes. Note that Python’s deque can be used as efficiently as FIFO, as well as in <strong class="bold">last-in, first-out</strong> (<strong class="bold">LIFO</strong>). That’s <a id="_idIndexMarker556"/>because it implements an efficient data structure when you operate at both extremes.</p>
<p>The algorithm starts by putting the root node onto the queue. While the queue is not empty, we will take the node out front. If it’s an internal node, we will put all of its children into the queue.</p>
<p>We will iterate the preceding step until the queue is empty. I encourage you to take a pen and paper and see how this works by performing the example shown in the following diagram. The code is small, but not trivial:</p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 7.3 – Visiting a tree; the first number indicates the order in which that node is visited traversing depth-first, while the second assumes breadth-first " height="346" src="image/B17942_07_003.jpg" width="479"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Visiting a tree; the first number indicates the order in which that node is visited traversing depth-first, while the second assumes breadth-first</p>
<ol>
<li value="7">Let’s get back<a id="_idIndexMarker557"/> to the real dataset. As we have a bit too much data to visualize, we will generate a trimmed-down version, where we remove the subtrees that have single species (in the case of EBOV, they have the same outbreak). We will also ladderize the tree, that is, sort the child nodes in order of the number of children:<p class="source-code">from copy import deepcopy</p><p class="source-code">simple_ebola = deepcopy(ebola_raxml)</p><p class="source-code">def simplify_tree(node):</p><p class="source-code">    prefs = set()</p><p class="source-code">    for leaf in node.leaf_nodes():</p><p class="source-code">        my_toks = leaf.taxon.label.split(' ')</p><p class="source-code">        if my_toks[0] == 'EBOV':</p><p class="source-code">            prefs.add('EBOV' + my_toks[1])</p><p class="source-code">        else:</p><p class="source-code">            prefs.add(my_toks[0])</p><p class="source-code">    if len(prefs) == 1:</p><p class="source-code">        print(prefs, len(node.leaf_nodes()))</p><p class="source-code">        node.taxon = dendropy.Taxon(label=list(prefs)[0])</p><p class="source-code">        node.set_child_nodes([])</p><p class="source-code">    else:</p><p class="source-code">        for child in node.child_nodes():</p><p class="source-code">            simplify_tree(child)</p><p class="source-code">simplify_tree(simple_ebola.seed_node)</p><p class="source-code">simple_ebola.ladderize()</p><p class="source-code">simple_ebola.write_to_path('ebola_simple.nex', 'nexus')</p></li>
</ol>
<p>We will perform<a id="_idIndexMarker558"/> a deep copy of the tree structure. As our function and the ladderization are destructive (they will change the tree), we will want to maintain the original tree.</p>
<p>DendroPy is able to enumerate all the leaf nodes (at this stage, a good exercise would be to write a function to perform this). With this functionality, we will get all the leaves for a certain node. If they share the same species and outbreak year as in the case of EBOV, we remove all of the child nodes, leaves, and internal subtree nodes.</p>
<p>If they do not share the same species, we recurse down until that happens. The worst case is that when you are already at a leaf node, the algorithm trivially resolves to the species of the <a id="_idIndexMarker559"/>current node.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor204"/>There’s more...</h2>
<p>There is a massive amount of computer science literature on the topic of trees and data structures; if you want to read more, Wikipedia provides a great introduction at <a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29">http://en.wikipedia.org/wiki/Tree_%28data_structure%29</a>.</p>
<p>Note that the use of <strong class="source-inline">lambda</strong> functions and <strong class="source-inline">map</strong> is not encouraged as a Python dialect; you can read some (older) opinions on the subject from Guido van Rossum at <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">http://www.artima.com/weblogs/viewpost.jsp?thread=98196</a>. I presented it here because it’s a very common dialect within functional and recursive programming. The more common dialect will be based on a list of comprehensions.</p>
<p>In any case, the functional dialect based on using the <strong class="source-inline">map</strong> and <strong class="source-inline">reduce</strong> operations is the conceptual base for MapReduce frameworks, and you can use frameworks such as Hadoop, Disco, or Spark to perform high-performance bioinformatics computing.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor205"/>Visualizing phylogenetic data</h1>
<p>In this recipe, we will <a id="_idIndexMarker560"/>discuss how to visualize phylogenetic trees. DendroPy only has simple visualization mechanisms based on drawing textual ASCII trees, but Biopython has quite a rich infrastructure, which we will leverage here.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>Getting ready</h2>
<p>This will require you to have completed all of the previous recipes. Remember that we have the files for the whole genus of the Ebola virus, including the RAxML tree. Furthermore, a simplified genus version will have been produced in the previous recipe. As usual, you can find this content in the <strong class="source-inline">Chapter07/Visualization.py</strong> notebook file.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor207"/>How to do it...</h2>
<p>Take a look at the following steps:</p>
<ol>
<li value="1">Let’s load all of the phylogenetic data:<p class="source-code">from copy import deepcopy</p><p class="source-code">from Bio import Phylo</p><p class="source-code">ebola_tree = Phylo.read('my_ebola.nex', 'nexus')</p><p class="source-code">ebola_tree.name = 'Ebolavirus tree'</p><p class="source-code">ebola_simple_tree = Phylo.read('ebola_simple.nex', 'nexus')</p><p class="source-code">ebola_simple_tree.name = 'Ebolavirus simplified tree'</p></li>
</ol>
<p>For all of the trees that we read, we will change the name of the tree, as the name will <a id="_idIndexMarker561"/>be printed later.</p>
<ol>
<li value="2">Now, we can draw ASCII representations of the trees:<p class="source-code">Phylo.draw_ascii(ebola_simple_tree)</p><p class="source-code">Phylo.draw_ascii(ebola_tree)</p></li>
</ol>
<p>The ASCII representation of the simplified genus tree is shown in the following diagram. Here, we will not print the complete version because it will take several pages. But if you run the preceding code, you will be able to see that it’s actually quite readable:</p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 7.4 – The ASCII representation of a simplified Ebola virus dataset " height="397" src="image/B17942_07_004.jpg" width="596"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The ASCII representation of a simplified Ebola virus dataset</p>
<ol>
<li value="3"><strong class="source-inline">Bio.Phylo</strong> allows<a id="_idIndexMarker562"/> for the graphical representation of trees by using <strong class="source-inline">matplotlib</strong> as a backend:<p class="source-code">import matplotlib.pyplot as plt</p><p class="source-code">fig = plt.figure(figsize=(16, 22))</p><p class="source-code">ax = fig.add_subplot(111)</p><p class="source-code">Phylo.draw(ebola_simple_tree, branch_labels=lambda c: c.branch_length if c.branch_length &gt; 0.02 else None, axes=ax)</p></li>
</ol>
<p>In this case, we will print the branch lengths at the edges, but we will remove all of the lengths that are less than 0.02 to avoid clutter. The result of doing this is shown in the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 7.5 – A matplotlib-based version of the simplified dataset with branch lengths added " height="1257" src="image/B17942_07_005.jpg" width="944"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – A matplotlib-based version of the simplified dataset with branch lengths added</p>
<ol>
<li value="4">Now we will <a id="_idIndexMarker563"/>plot the complete dataset, but we will color each bit of the tree differently. If a subtree only has a single virus species, it will get its own color. EBOV will have two colors, that is, one for the 2014 outbreak and one for the others, as follows:<p class="source-code">fig = plt.figure(figsize=(16, 22))</p><p class="source-code">ax = fig.add_subplot(111)</p><p class="source-code">from collections import OrderedDict</p><p class="source-code">my_colors = OrderedDict({</p><p class="source-code">'EBOV_2014': 'red',</p><p class="source-code">'EBOV': 'magenta',</p><p class="source-code">'BDBV': 'cyan',</p><p class="source-code">'SUDV': 'blue',</p><p class="source-code">'RESTV' : 'green',</p><p class="source-code">'TAFV' : 'yellow'</p><p class="source-code">})</p><p class="source-code">def get_color(name):</p><p class="source-code">    for pref, color in my_colors.items():</p><p class="source-code">        if name.find(pref) &gt; -1:</p><p class="source-code">            return color</p><p class="source-code">    return 'grey'</p><p class="source-code">def color_tree(node, fun_color=get_color):</p><p class="source-code">    if node.is_terminal():</p><p class="source-code">        node.color = fun_color(node.name)</p><p class="source-code">    else:</p><p class="source-code">        my_children = set()</p><p class="source-code">        for child in node.clades:</p><p class="source-code">            color_tree(child, fun_color)</p><p class="source-code">            my_children.add(child.color.to_hex())</p><p class="source-code">        if len(my_children) == 1:</p><p class="source-code">            node.color = child.color</p><p class="source-code">        else:</p><p class="source-code">            node.color = 'grey'</p><p class="source-code">ebola_color_tree = deepcopy(ebola_tree)</p><p class="source-code">color_tree(ebola_color_tree.root)</p><p class="source-code">Phylo.draw(ebola_color_tree, axes=ax, label_func=lambda x: x.name.split(' ')[0][1:] if x.name is not None else None)</p></li>
</ol>
<p>This is a tree traversing algorithm, not unlike the ones presented in the previous recipe. As a recursive algorithm, it works in the following way. If the node is a leaf, it will get a color based on its species (or the EBOV outbreak year). If it’s an internal node and all the descendant nodes<a id="_idIndexMarker564"/> below it are of the same species, it will get the color of that species; if there are several species after that, it will be colored in gray. Actually, the color function can be changed and will be changed later. Only the edge colors will be used (the labels will be printed in black).</p>
<p>Note that ladderization (performed in the previous recipe with DendroPy) helps quite a lot in terms of a clear visual appearance.</p>
<p>We also deep copy the genus tree to color a copy; remember from the previous recipe that some tree traversal functions can change the state, and in this case, we want to preserve a version without any coloring.</p>
<p>Note the usage of the lambda function to clean up the name that was changed by trimAl, as shown in the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 7.6 – A ladderized and colored phylogenetic tree with the complete Ebola virus dataset " height="1257" src="image/B17942_07_006.jpg" width="944"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – A ladderized and colored phylogenetic tree with the complete Ebola virus dataset</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor208"/>There’s more...</h2>
<p>Tree and graph visualization is a complex topic; arguably, here, the tree’s visualization is rigorous but far from pretty. One alternative to DendroPy, which has more visualization features, is ETE (<a href="http://etetoolkit.org/">http://etetoolkit.org/</a>). General alternatives for drawing trees and graphs include<a id="_idIndexMarker565"/> Cytoscape (<a href="https://cytoscape.org/">https://cytoscape.org/</a>) and <a id="_idIndexMarker566"/>Gephi (<a href="http://gephi.github.io/">http://gephi.github.io/</a>). If you want to know more about the algorithms for rendering trees and graphs, check out the Wikipedia page at <a href="http://en.wikipedia.org/wiki/Graph_drawing">http://en.wikipedia.org/wiki/Graph_drawing</a> for an introduction to this fascinating topic.</p>
<p>Be careful not to trade style for substance, though. For example, the previous edition of this book had a pretty rendering of a phylogenetic tree using a graph-rendering library. While it was clearly the most beautiful image in that chapter, it was misleading in terms of branch lengths.</p>
</div>
<div>
<div id="_idContainer060">
</div>
</div>
</div></body></html>