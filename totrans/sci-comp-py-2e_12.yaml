- en: Error and Exception Handling
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover errors and exceptions and how to find and fix
    them. Handling exceptions is an important part of writing reliable and usable
    code. We will introduce basic built-in exceptions and show how to use and treat
    exceptions. We'll introduce debugging and show you how to use the built-in Python
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are exceptions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finding errors: debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.1 What are exceptions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first error that programmers (even experienced ones) are confronted with
    is when the code has incorrect syntax, meaning that the code instructions are
    not correctly formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example of a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The error occurs because of a missing colon at the end of the `for` declaration.
    This is an example of an exception being raised. In the case of `SyntaxError`,
    it tells the programmer that the code has incorrect syntax and also prints the
    line where the error occurred, with an arrow pointing to where in that line the
    problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions in Python are derived (inherited) from a base class called `Exception`. Python
    comes with a number of built-in exceptions. Some common exception types are listed
    in *Table 12.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two common examples of exceptions. As you might expect, `ZeroDivisionError` is
    raised when you try to divide by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| **Exception** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexError` | Index is out of bounds, for example, `v[10]` when `v` only
    has five elements. |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyError` | A reference to an undefined dictionary key. |'
  prefs: []
  type: TYPE_TB
- en: '| `NameError` | A name not found, for example, an undefined variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `LinAlgError` | Errors in the `linalg` module, for example, when solving a
    system with a singular matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `ValueError` | Incompatible data value, for example, when using `dot` with
    incompatible arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| `IOError` | I/O operation fails, for example, `file not found`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ImportError` | A module or name is not found on import. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: Some frequently used built-in exceptions and their meaning'
  prefs: []
  type: TYPE_NORMAL
- en: A division by zero raises `ZeroDivisionError` and prints out the file name,
    the line, and the function name where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen before, arrays can only contain elements of the same datatype.
    If you try to assign a value of an incompatible type, `ValueError` is raised.
    An example of a value error is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ValueError` is raised because the array contains floats and an element
    cannot be assigned a string value.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.1 Basic principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the basic principles on how to use exceptions by raising them
    with `raise` and catching them with `try` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating an error is referred to as raising an exception. You saw some examples
    of exceptions in the previous section. You can also define your own exceptions
    of a predefined type or use an exception of an unspecified type. Raising an exception
    is done with a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here an exception of an unspecified type was raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be tempting to print out error messages when something goes wrong,
    for example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is not recommended for a number of reasons. Firstly, printouts are easy
    to miss, especially if the message is buried in many other messages being printed
    to your console. Secondly, and more importantly, it renders your code unusable
    by other code. The calling code will not *read* what you printed and will not
    have a way of knowing that an error occurred and therefore has no way of taking
    care of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these reasons, it is always better to raise an exception instead. Exceptions
    should always contain a descriptive message, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This message will stand out clearly to the user. It also gives the opportunity
    for the calling code to know that an error occurred, and to possibly find a remedy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical example of checking the input inside a function to make sure
    it is usable before continuing. A simple check for negative values and the correct
    datatype ensures the intended input of a function to compute factorials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The user of the function will immediately know what the error is, if an incorrect
    input is given, and it is the user's responsibility to handle the exception. Note
    the use of the exception name when raising a predefined exception type, in this
    case, `ValueError` followed by the message. By specifying the type of the exception,
    the calling code can decide to handle errors differently depending on what type
    of error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, it is always better to raise exceptions than to print error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dealing with an exception is referred to as *catching an exception*. Checking
    for exceptions is done with the commands `try` and `except`.
  prefs: []
  type: TYPE_NORMAL
- en: An exception stops the program execution flow and looks for the closest `try` enclosing
    block. If the exception is not caught, the program unit is left and it continues
    searching for the next enclosing `try` block in a program unit higher up in the
    calling stack. If no block is found and the exception is not handled, execution
    stops entirely and the standard traceback information is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the factorial example from previously and use it with the `try` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the code inside the `try` block raises an error of type `ValueError`,
    the exception will be caught and the action in the `except` block is taken. If
    no exception occurs inside the `try` block, the `except` block is skipped entirely
    and execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `except` statement can catch multiple exceptions. This is done by simply
    grouping them in a tuple, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `try` block can also have multiple `except` statements. This makes it possible
    to handle exceptions differently depending on the type. Let''s see another example
    of multiple exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, `FileNotFoundError` will be caught if, for example, the file does not
    exist; and `ValueError` will be caught if, for example, the data in the first
    line of the file is not compatible with the float data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we assigned `FileNotFoundError` to a variable `FnF` by the
    keyword `as`. This allows access to more details when handling this exception.
    Here we printed the error string `FnF.strerror` and the name of the related file
    `FnF.filename`. Each error type can have its own set of attributes depending on
    the type. If the file with the name `data.txt` does not exist, in the preceding
    example, the message is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful way to format the output when catching exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `try`-`except` combination can be extended with optional `else` and `finally` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using `else` can be seen in [Section 15.2.1](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml):
    *Testing the bisection algorithm*. Combining `try` with `finally` gives a useful
    construction when cleanup work needs to happen at the end. This is illustrated
    by an example for making sure a file is closed properly is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure that the file is closed at the end no matter what exceptions are
    thrown while processing the file data. Exceptions that are not handled inside
    the `try` statement are saved and raised after the `finally` block. This combination
    is used in the `with` statement; see Section 12.1.3: *Context managers – the with
    statement*.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.2 User-defined exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the built-in Python exceptions, it is also possible to define your own
    exceptions. Such user-defined exceptions should inherit from the base class `Exception`.
    This can be useful when you define your own classes such as the polynomial class in
    [Section 19.1](2bd9f874-5cdc-4298-873f-12572838a10c.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this small example of a simple user-defined exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A random number is generated. If the number is below `0.5`, an exception is
    thrown and a message that the value is too small is printed. If no exception is
    raised, the number is printed.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you also saw a case of using `else` in a `try` statement. The
    block under `else` will be executed if no exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you define your exceptions with names that end in `Error`,
    like the naming of the standard built-in exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1.3 Context managers – the with statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a very useful construction in Python for simplifying exception handling
    when working with contexts such as files or databases. The statement encapsulates
    the structure `try ... finally` in one simple command. Here is an example of using `with` to
    read a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will try to open the file, run the specified operations on the file (for
    example, reading), and close the file. If anything goes wrong during the execution
    of `process_file_data`, the file is closed properly and then the exception is
    raised. This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this option in [Section 14.1](f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml):
    *File handling*, when reading and writing files.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding file-reading example is an example of using context managers.
    Context managers are Python objects with two special methods, `__enter__` and `__exit__`.
    Any object of a class that implements these two methods can be used as a context
    manager. In this example, the file object `f` is a context manager as there are
    the methods `f.__enter__` and `f.__exit__`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `__enter__` should implement the initialization instructions, for
    example, opening a file or a database connection. If this method has a return
    statement, the returned object is accessed using the construct `as`. Otherwise,
    the keyword `as` is omitted. The method `__exit__` contains the cleanup instructions,
    for example, closing a file or committing transactions and closing a database
    connection. For more explanations and an example of a self-written context manager, see [Section 15.3.3](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Timing
    with a context manager*.
  prefs: []
  type: TYPE_NORMAL
- en: There are NumPy functions that can be used as context managers. For example,
    the function `load` supports the context manager for some file formats. NumPy's
    function `errstate` can be used as a context manager to specify floating-point
    error handling behavior within a block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of working with `errstate` and a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'See [Section 2.2.2](879c0554-386f-4bb1-8fa8-b86c43927545.xhtml): *Floating-point
    numbers* for more details on this example and [Section 15.3.3](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml):
    *Timing wit**h a context manager* for another example.'
  prefs: []
  type: TYPE_NORMAL
- en: '12.2 Finding errors: debugging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors in software code are sometimes referred to as bugs. Debugging is the
    process of finding and fixing bugs in code. This process can be performed at varying
    degrees of sophistication. The most efficient way is to use a tool called a debugger.
    Having unit tests in place is a good way to identify errors early; see [Section
    15.2.2](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Using the unittest package*.
    When it is not obvious where or what the problem is, a debugger is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.1 Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are typically two kinds of bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: An exception is raised and not caught.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code does not function properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first case is usually easier to fix. The second can be more difficult as
    the problem can be a faulty idea or solution, a faulty implementation, or a combination
    of the two.
  prefs: []
  type: TYPE_NORMAL
- en: We are only concerned with the first case in what follows, but the same tools
    can be used to help find why the code does not do what it is supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 The stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is raised, you see the call stack. The call stack contains
    the trace of all the functions that called the code where the exception was raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple stack example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack, in this case, is `f`, `g`, and `h`. The output generated by running
    this piece of code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The error is printed. The sequence of functions leading up to the error is shown.
    The function `f` on `line 11` was called, which in turn called `g` and then `h`.
    This caused `ZeroDivisionError`.
  prefs: []
  type: TYPE_NORMAL
- en: A stack trace reports on the active stack at a certain point in the execution
    of a program. A stack trace lets you track the sequence of functions called up
    to a given point. Often this is after an uncaught exception has been raised. This
    is sometimes called post-mortem analysis, and the stack tracepoint is then the
    place where the exception occurred. Another option is to invoke a stack trace
    manually to analyze a piece of code where you suspect there is an error, perhaps
    before the exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an exception is raised to provoke the generation
    of a stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 12.2.3 The Python debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python comes with its own built-in debugger called `pdb`. Some development environments
    come with the debugger integrated. The following process still holds in most of
    these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to use the debugger is to enable stack tracing at the point
    in your code that you want to investigate. Here is a simple example of triggering
    the debugger based on the example mentioned in [Section 7.3](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Return
    values*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `pdb.set_trace()` starts the debugger and enables the tracing of
    subsequent commands. The preceding code will show this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The debugger prompt is indicated with `(Pdb)`. The debugger stops the program
    execution and gives you a prompt that lets you inspect variables, modify variables,
    step through commands, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current line is printed at each step, so you can follow where you are and
    what will happen next. Stepping through commands is done with the command `n` (next),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `n` (next) will continue to the next line and print the line. If
    you need to see more than one line at a time, the  command `l` (list) shows the
    current line with the surrounding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The inspection of variables can be done by printing their values to the console
    using the command `p` (print) followed by the variable name. An example of printing
    variables is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The command `p` (print) will print the variable; the command `c` (continue)
    continues execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing a variable mid-execution is useful. Simply assign the new value at
    the debugger prompt and step or continue the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here the variable `z` is assigned a new value to be used throughout the remaining
    code. Note that the final printout has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.4 Overview – debug commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Table 12.2*, the most common debug commands are shown. For a full listing and
    description of commands, see the documentation for more information [24]. Note
    that any Python command also works, for example, assigning values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to inspect a variable with a name that coincides with any of the
    debugger's short commands, for example, `h`, you must use `!h` to display the
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Help (without arguments, it prints available commands) |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | Lists the code around the current line |'
  prefs: []
  type: TYPE_TB
- en: '| `q` | Quit (exits the debugger and the execution stops) |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Continues execution |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Continues execution until the current function returns |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | Continues execution until the next line |'
  prefs: []
  type: TYPE_TB
- en: '| `p <expression>` | Evaluates and prints the expression in the current context
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.2: The most common debug commands for the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.5 Debugging in IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython comes with a version of the debugger called `ipdb`. At the time of writing this
    book, the differences to `pdb` are very minor but this may change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a command in IPython, `%pdb`, that automatically turns on the debugger
    in case of an exception. This is very useful when experimenting with new ideas
    or code. An example of how to automatically turn on the debugger in IPython is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The IPython magic command `%pdb` at the IPython prompt automatically enables
    the debugger when exceptions are raised. Here the debugger prompt shows `ipdb` instead
    to indicate that the debugger is running.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key concepts in this chapter were exceptions and errors. We showed how an
    exception is raised to be caught later in another program unit. You can define
    your own exceptions and equip them with messages and current values of given variables.
  prefs: []
  type: TYPE_NORMAL
- en: The code may return unexpected results without throwing an exception. The technique
    to localize the source of the erroneous result is called debugging. We introduced
    debugging methods and hopefully encouraged you to train them so that you have
    them readily available when needed. The need for serious debugging comes sooner
    than you might expect.
  prefs: []
  type: TYPE_NORMAL
