- en: Chapter 3. Mastering the Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Teaching programming in the notebook with IPython blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an IPython notebook to other formats with nbconvert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom controls in the notebook toolbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the CSS style in the notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interactive widgets – a piano in the notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom JavaScript widget in the notebook – a spreadsheet editor for
    pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing webcam images in real time from the notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see many features of the notebook, including the interactive
    widgets that have been brought by IPython 2.0\. As we have only seen basic features
    in the previous chapters, we will dive deeper into the architecture of the notebook
    here.
  prefs: []
  type: TYPE_NORMAL
- en: What is the notebook?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The notebook was released in 2011, ten years after the creation of IPython.
    Its development has a long and complex history that is nicely summarized by Fernando
    Perez on his blog, [http://blog.fperez.org/2012/01/ipython-notebook-historical.html](http://blog.fperez.org/2012/01/ipython-notebook-historical.html).
    Inspired by mathematical software such as Maple, Mathematica, or Sage, the notebook
    really fostered the popularity of IPython.
  prefs: []
  type: TYPE_NORMAL
- en: By mixing together code, text, images, plots, hypertext links, and mathematical
    equations in a single document, the notebook brings reproducibility to interactive
    computing. The notebook, when used correctly, can radically change workflows in
    scientific computing. Prior to the notebook, one had to juggle between a text
    editor and an interactive prompt; now, one can stay focused within a single unified
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The notebook is not only a tool but also a powerful and robust architecture.
    Furthermore, this architecture is mostly language independent, so it's no longer
    tied to Python. The notebook defines a set of messaging protocols, APIs, and JavaScript
    code that can be used by other languages. In effect, we are now seeing non-Python
    kernels that can interact with the notebook such as IJulia, IHaskell, IRuby, and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the SciPy conference in July 2014, the IPython developers even announced
    their decision to split the project into the following two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new **Project** **Jupyter** will implement all language-independent parts:
    the notebook, the messaging protocol, and the overall architecture. For more details,
    visit [http://jupyter.org](http://jupyter.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPython will be the name of the Python kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we do not make that semantic distinction, and we will use the
    term IPython to refer to the project as a whole (language-independent parts and
    Python kernel).
  prefs: []
  type: TYPE_NORMAL
- en: The notebook ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notebooks are represented as **JavaScript Object** **Notation** (**JSON**) documents.
    JSON is a language-independent, text-based file format for representing structured
    documents. As such, notebooks can be processed by any programming language, and
    they can be converted to other formats such as Markdown, HTML, LaTeX/PDF, and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: An ecosystem is being built around the notebook, and we can expect to see more
    and more usage in the near future. For example, Google is working on bringing
    the IPython notebook to Google Drive for collaborative data analytics. Also, notebooks
    are being used to create slides, teaching materials, blog posts, research papers,
    and even books. In fact, this very book is entirely written in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: IPython 2.0 introduced interactive widgets in the notebook. These widgets bring
    Python and the browser even closer. We can now create applications that implement
    bidirectional communication between the IPython kernel and the browser. Also,
    any JavaScript interactive library can be, in principle, integrated within the
    notebook. For example, the `D3.js` JavaScript visualization library is now being
    used by several Python projects to enable interactive visualization capabilities
    to the notebook. We are probably going to see many interesting uses of these interactive
    features in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of the IPython notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython implements a two-process model, with a **kernel** and a **client**.
    The client is the interface offering the user the ability to send Python code
    to the kernel. The kernel executes the code and returns the result to the client
    for display. In the **Read-Evaluate-Print Loop** (**REPL**) terminology, the kernel
    implements the *Evaluate*, whereas the client implements the *Read* and the *Print*
    of the process.
  prefs: []
  type: TYPE_NORMAL
- en: The client can be a Qt widget if we run the Qt console, or a browser if we run
    the notebook. In the notebook, the kernel receives entire cells at once, and thus
    has no notion of a notebook. There is a strong decoupling between the linear document
    containing the notebook, and the underlying kernel. This is a very strong constraint
    that may limit the possibilities, but that nevertheless leads to great simplicity
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamental assumption in the whole architecture is that there can be
    at most one kernel connected to a notebook. However, IPython 3.0 offers the possibility
    of choosing the language kernel for any notebook.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep these points in mind when thinking about new use-case
    scenarios for the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: In the notebook, in addition to the Python kernel and the browser client, there
    is a Python server based on **Tornado** ([www.tornadoweb.org](http://www.tornadoweb.org)).
    This process serves the HTML-based notebook interface.
  prefs: []
  type: TYPE_NORMAL
- en: All communication procedures between the different processes are implemented
    on top of the **ZeroMQ** (or **ZMQ**) messaging protocol ([http://zeromq.org](http://zeromq.org)).
    The notebook communicates with the underlying kernel using **WebSocket**, a TCP-based
    protocol implemented in modern web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browsers that officially support the notebook in IPython 2.x are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Chrome ≥ 13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safari ≥ 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox ≥ 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notebook should also work on Internet Explorer ≥ 10\. These requirements
    are essentially those for WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting multiple clients to one kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a notebook, typing `%connect_info` in a cell gives the information we need
    to connect a new client (such as a Qt console) to the underlying kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<app>` is `console`, `qtconsole`, or `notebook`.
  prefs: []
  type: TYPE_NORMAL
- en: It is even possible to have the kernel and the client running on different machines.
    You will find the instructions to run a public notebook server in the IPython
    documentation, available at [http://ipython.org/ipython-doc/dev/notebook/public_server.html#running-a-public-notebook-server](http://ipython.org/ipython-doc/dev/notebook/public_server.html#running-a-public-notebook-server).
  prefs: []
  type: TYPE_NORMAL
- en: Security in notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible for someone to put malicious code in an IPython notebook. Since
    notebooks may contain hidden JavaScript code in a cell output, it is theoretically
    possible for malicious code to execute surreptitiously when the user opens a notebook.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, IPython 2.0 introduced a security model where HTML and JavaScript
    code in a notebook can be either trusted or untrusted. Outputs generated by the
    user are always trusted. However, outputs that were already there when the user
    first opened an existing notebook are untrusted.
  prefs: []
  type: TYPE_NORMAL
- en: The security model is based on a cryptographic signature present in every notebook.
    This signature is generated using a secret key owned by every user.
  prefs: []
  type: TYPE_NORMAL
- en: You can find further references on the security model in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some references about the notebook architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The IPython two-process model, explained at [http://ipython.org/ipython-doc/stable/overview.html#decoupled-two-process-model](http://ipython.org/ipython-doc/stable/overview.html#decoupled-two-process-model)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation of the notebook, available at [http://ipython.org/ipython-doc/stable/interactive/notebook.html](http://ipython.org/ipython-doc/stable/interactive/notebook.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security in the notebook, described at [http://ipython.org/ipython-doc/dev/notebook/security.html](http://ipython.org/ipython-doc/dev/notebook/security.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notebook server, described at [http://ipython.org/ipython-doc/dev/interactive/public_server.html](http://ipython.org/ipython-doc/dev/interactive/public_server.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IPython messaging protocol, at [http://ipython.org/ipython-doc/dev/development/messaging.html](http://ipython.org/ipython-doc/dev/development/messaging.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tutorial about how to write a custom kernel for the notebook, at [http://andrew.gibiansky.com/blog/ipython/ipython-kernels/](http://andrew.gibiansky.com/blog/ipython/ipython-kernels/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few (mostly experimental) kernels in non-Python languages for the
    notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: IJulia, available at [https://github.com/JuliaLang/IJulia.jl](https://github.com/JuliaLang/IJulia.jl)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IRuby, available at [https://github.com/isotope11/iruby](https://github.com/isotope11/iruby)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IHaskell, available at [https://github.com/gibiansky/IHaskell](https://github.com/gibiansky/IHaskell)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IGo, available at [https://github.com/takluyver/igo](https://github.com/takluyver/igo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IScala, available at [https://github.com/mattpap/IScala](https://github.com/mattpap/IScala)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teaching programming in the notebook with IPython blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The IPython notebook is not only a tool for scientific research and data analysis
    but also a great tool for teaching. In this recipe, we show a simple and fun Python
    library for teaching programming notions: **IPython Blocks** (available at [http://ipythonblocks.org](http://ipythonblocks.org)).
    This library allows you or your students to create grids of colorful blocks. You
    can change the color and size of individual blocks, and you can even animate your
    grids. There are many basic technical notions you can illustrate with this tool.
    The visual aspect of this tool makes the learning process more effective and engaging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will notably perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Illustrate matrix multiplication with an animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display an image as a block grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe is partly inspired by the example at [http://nbviewer.ipython.org/gist/picken19/b0034ba7ec690e89ea79](http://nbviewer.ipython.org/gist/picken19/b0034ba7ec690e89ea79).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to install IPython Blocks for this recipe. You can just type in a terminal
    `pip install ipythonblocks`. Note that you can also execute this shell command
    from the IPython notebook by prefixing this command with `!`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the last part of this recipe, you also need to install Pillow, available
    at [http://pillow.readthedocs.org/en/latest/](http://pillow.readthedocs.org/en/latest/);
    you will find more instructions in [Chapter 11](ch11.html "Chapter 11. Image and
    Audio Processing"), *Image and Audio Processing*. With Anaconda, you can execute
    `conda install pillow` in a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to download the *Portrait* dataset from the book's website
    ([https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data))
    and extract it in the current directory. You can also play with your own images!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we import some modules as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a block grid with five columns and five rows, and we fill each
    block in purple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can access individual blocks with 2D indexing. This illustrates the indexing
    syntax in Python. We can also access an entire row or line with a `:` (colon).
    Each block is represented by an RGB color. The library comes with a handy dictionary
    of colors, assigning RGB tuples to standard color names as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, we are going to illustrate matrix multiplication, a fundamental notion
    in linear algebra. We will represent two (`n,n`) matrices, `A` (in cyan) and `B`
    (lime) aligned with `C = A B` (yellow). To do this, we use a small trick of creating
    a big white grid of size (`2n+1,2n+1`). The matrices `A`, `B`, and `C` are just
    views on parts of the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s turn to matrix multiplication itself. We perform a loop over all rows
    and columns, and we highlight the corresponding rows and columns in A and B that
    are multiplied together during the matrix product. We combine IPython''s `clear_output()`
    method with `grid.show()` and `time.sleep()` (pause) to implement the animation
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, we will display an image with IPython Blocks. We import the JPG image
    with `Image.open()` and we retrieve the data with `getdata()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a `BlockGrid` instance with the appropriate number of rows and
    columns, and we set each block''s color to the corresponding pixel''s color in
    the image. We use a small block size, and we remove the lines between the blocks
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As demonstrated in this recipe, the notebook is an ideal platform for education
    activities at all levels.
  prefs: []
  type: TYPE_NORMAL
- en: This library has been developed prior to the interactive notebook features brought
    by IPython 2.0\. We can now expect even more interactive developments.
  prefs: []
  type: TYPE_NORMAL
- en: Converting an IPython notebook to other formats with nbconvert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An IPython notebook is saved in a JSON text file. This file contains the entire
    contents of the notebook: text, code, and outputs. The matplotlib figures are
    encoded as base64 strings within the notebooks, resulting in standalone, but sometimes
    big, notebook files.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON is a human-readable, text-based, open standard format that can represent
    structured data. Although derived from JavaScript, it is language independent.
    Its syntax bears some resemblance with Python dictionaries. JSON can be parsed
    in many languages including JavaScript and Python (the `json` module in Python's
    standard library).
  prefs: []
  type: TYPE_NORMAL
- en: 'IPython comes with a tool called **nbconvert** that can convert notebooks to
    other formats: raw text, Markdown, HTML, LaTeX/PDF, and even slides with the `reveal.js`
    library. You will find more information about the different supported formats
    on the nbconvert documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to manipulate the contents of a notebook and
    how to convert it to other formats.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to install pandoc, available at [http://johnmacfarlane.net/pandoc/](http://johnmacfarlane.net/pandoc/),
    which is a tool for converting files from one markup language to another.
  prefs: []
  type: TYPE_NORMAL
- en: To convert a notebook to PDF, you need a LaTeX distribution, which is available
    at [http://latex-project.org/ftp.html](http://latex-project.org/ftp.html). You
    also need to download the *Notebook* dataset from the book's website ([https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)),
    and extract it in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you may need the `pywin32` package. If you use Anaconda, you can
    install it with `conda install pywin32`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s open the `test` notebook in the `data` folder. A notebook is just a
    plain text file (JSON), so we open it in the text mode (`r` mode) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is an excerpt of the `test.ipynb` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have loaded the notebook in a string, let''s parse it with the
    `json` module as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a look at the keys in the notebook dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The version of the notebook format is indicated in `nbformat` and `nbformat_minor`.
    Backwards-incompatible changes in the notebook format are to be expected in future
    versions of IPython. This recipe has been tested with the IPython 2.x branch and
    the notebook format v3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The main field is `worksheets`; there is only one by default. A worksheet contains
    a list of cells and some metadata. The `worksheets` field may disappear in a future
    version of the notebook format. Let''s have a look at the contents of a worksheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each cell has a type, optional metadata, some contents (text or code), possibly
    one or several outputs, and other information. Let''s look at a Markdown cell
    and a code cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once parsed, the notebook is represented as a Python dictionary. Manipulating
    it is therefore quite convenient in Python. Here, we count the number of Markdown
    and code cells as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s have a closer look at the image output of the cell with the matplotlib
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In general, there can be zero, one, or multiple outputs. Additionally, each
    output can have multiple representations. Here, the matplotlib figure has a PNG
    representation (the base64-encoded image) and a text representation (the internal
    representation of the figure).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are going to use nbconvert to convert our text notebook to other formats.
    This tool can be used from the command line. Note that the API of nbconvert may
    change in future versions. Here, we convert the notebook to an HTML document as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s display this document in an `<iframe>` (a small window showing an external
    HTML document within the notebook):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can also convert the notebook to LaTeX and PDF. In order to specify the
    title and author of the document, we need to extend the default LaTeX template.
    First, we create a file called `mytemplate.tplx` that extends the default `article.tplx`
    template provided by nbconvert. We specify the contents of the author and title
    blocks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can run nbconvert by specifying our custom template as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We used nbconvert to convert the notebook to LaTeX, and `pdflatex` (coming
    with our LaTeX distribution) to compile the LaTeX document to PDF. The following
    screenshot shows the PDF version of the notebook:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/4818OS_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in this recipe, an `.ipynb` file contains a structured representation
    of the notebook. This JSON file can be easily parsed and manipulated in Python.
  prefs: []
  type: TYPE_NORMAL
- en: nbconvert is a tool for converting a notebook to another format. The conversion
    can be customized in several ways. Here, we extended an existing template using
    `jinja2`, a templating package. You will find more information in the documentation
    of nbconvert.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a free online service, **nbviewer**, that lets us render IPython notebooks
    in HTML dynamically in the cloud. The idea is that we provide to nbviewer a URL
    to a raw notebook (in JSON), and we get a rendered HTML output. The main page
    of nbviewer ([http://nbviewer.ipython.org](http://nbviewer.ipython.org)) contains
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: This service is maintained by the IPython developers and is hosted on Rackspace
    ([www.rackspace.com](http://www.rackspace.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation of nbconvert, at [http://ipython.org/ipython-doc/dev/interactive/nbconvert.html](http://ipython.org/ipython-doc/dev/interactive/nbconvert.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of conversion examples with nbconvert, at [https://github.com/ipython/nbconvert-examples](https://github.com/ipython/nbconvert-examples)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON on Wikipedia, available at [http://en.wikipedia.org/wiki/JSON](http://en.wikipedia.org/wiki/JSON)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom controls in the notebook toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CSS and JavaScript of the HTML notebook can be customized through the files
    in `~/.ipython/profile_default/static/custom`, where `~` is your home directory,
    and `default` is your IPython profile.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use these customization options to add a new button
    in the notebook toolbar that linearly renumbers all code cells.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we are going to inject JavaScript code directly in the notebook. This
    is useful for testing purposes, or if we don''t want the changes to be permanent.
    The JavaScript code will be loaded with that notebook only. To do this, we can
    just use the `%%javascript` cell magic as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the preceding code cell adds a button in the toolbar as shown in the
    following screenshot. Clicking on this button automatically updates the prompt
    numbers of all code cells.![How to do it...](img/4818OS_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a Renumber toolbar button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To make these changes permanent, that is, to add this button on every notebook
    in the current profile, we can open the `~/.ipython/profile_default/static/custom/custom.js`
    file and add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will be automatically loaded in the notebook, and the renumber
    button will appear on top of every notebook in the current profile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The IPython notebook JavaScript API that allowed us to add a button to the
    notebook toolbar is still unstable at the time of writing. It may change at any
    time, and it is not well documented. This recipe has only been tested with IPython
    2.0\. You may nevertheless find a not-so-official and partial API documentation
    on this page: [http://ipjsdoc.herokuapp.com](http://ipjsdoc.herokuapp.com).'
  prefs: []
  type: TYPE_NORMAL
- en: We should expect a more stable API in the future.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Customizing the CSS style in the notebook* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the CSS style in the notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we show how to customize the CSS in the notebook interface and
    in an exported HTML notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are expected to know a bit of CSS3 for this recipe. You can find many tutorials
    online (see the references at the end of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: You also need to download the *Notebook* dataset from the book's website ([http://ipython-books.github.io](http://ipython-books.github.io)),
    and extract it in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we create a new IPython profile to avoid cluttering our default profile
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Python, we retrieve the path to this profile (`~/.ipython`) and to the `custom.css`
    file (empty by default).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now edit this file here. We change the background color, the font size
    of code cells, the border of some cells, and we highlight the selected cells in
    edit mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Opening a notebook with the `custom_css` profile (with the `ipython notebook
    --profile=custom_css` command) leads to a custom style as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/4818OS_03_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Custom CSS in the interactive notebook interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also use this style sheet with nbconvert. We just have to convert a
    notebook to a static HTML document, and copy the `custom.css` file in the current
    directory. Here, we use a test notebook that has been downloaded from the book''s
    website (see *Getting ready*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is what this HTML document looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few tutorials and references about CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: CSS tutorial on w3schools, at [www.w3schools.com/css/DEFAULT.asp](http://www.w3schools.com/css/DEFAULT.asp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS tutorial on Mozilla Developer Network, at [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blog post by Matthias Bussonnier about how to customize the notebook CSS, at
    [http://nbviewer.ipython.org/github/Carreau/posts/blob/master/Blog1.ipynb](http://nbviewer.ipython.org/github/Carreau/posts/blob/master/Blog1.ipynb)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding custom controls in the notebook toolbar* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using interactive widgets – a piano in the notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with IPython 2.0, we can put interactive widgets in notebooks to create
    rich GUI applications that interact with our Python kernel. IPython comes with
    a rich set of graphical controls such as buttons, sliders, and drop-down menus.
    We have full control of their placement and appearance. We can combine different
    widgets to form complex layouts. We can even create our own interactive widgets
    from scratch as we will see in the next recipe, *Creating a custom Javascript
    widget in the notebook – a spreadsheet editor for pandas*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show many possibilities offered by the interactive widget
    API in IPython 2.0+. We will create a very basic piano in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to download the *Piano* dataset from the book's website (http://[ipython-books.github.io](http://ipython-books.github.io)).
    This dataset contains synthetic sounds of piano notes obtained on `archive.org`
    (CC0 1.0 Universal license). It is available at [https://archive.org/details/SynthesizedPianoNotes](https://archive.org/details/SynthesizedPianoNotes).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import a few modules as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a piano, we will draw one button per note. The corresponding note
    plays when the user clicks on the button. This is implemented by displaying an
    `<audio>` element as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to place all buttons within a container widget. In IPython 2.0,
    widgets can be organized hierarchically. One common use case is to organize several
    widgets in a given layout. Here, `piano` will contain 12 buttons for the 12 notes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The API for creating container widgets such as horizontal or vertical boxes
    has changed in IPython 3.0\. Refer to IPython's documentation for more details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We create our first widget: a slider control that specifies the octave (0 or
    1 here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, we create the buttons. There are several steps. First, we instantiate a
    `ButtonWidget` object for each note. Then, we specify a `callback()` function
    that plays the corresponding note (given by an index) at a given octave (given
    by the current value of the octave slider). Finally, we set the CSS of each button,
    notably the white or black color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we arrange all widgets within the containers. The `piano` container
    contains the buttons, and the main container (`container`) contains the slider
    and the piano. This can be implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, widgets are organized vertically within a container. Here, the
    octave slider will be above the piano. Within the piano, we want all notes to
    be arranged horizontally. We do this by replacing the default `vbox` CSS class
    by the `hbox` class. The following screenshot shows the piano in the IPython notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPython widgets are represented by rich objects that are shared between
    the Python kernel and the browser. A widget contains special attributes called
    **trait attributes**. For example, the `value` trait attribute of `SliderWidget`
    is dynamically and automatically linked to the value that is selected by the user
    in the notebook's slider.
  prefs: []
  type: TYPE_NORMAL
- en: This link is bidirectional. Changing this attribute in Python updates the slider
    in the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: The placement of the widgets is controlled by container widgets and with CSS
    classes. You will find more information in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture enables the creation of rich graphical applications in the
    notebook that are backed by Python code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Widget examples at [http://nbviewer.ipython.org/github/ipython/ipython/blob/master/examples/Interactive%20Widgets/Index.ipynb](http://nbviewer.ipython.org/github/ipython/ipython/blob/master/examples/Interactive%20Widgets/Index.ipynb)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a custom JavaScript widget in the notebook – a spreadsheet editor
    for pandas* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom JavaScript widget in the notebook – a spreadsheet editor for
    pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have previously introduced the new interactive features of the IPython notebook
    2.0\. In this recipe, we dive deeper into the subject by showing how to go beyond
    the existing widgets provided by IPython 2.0\. Specifically, we will create a
    custom JavaScript-based widget that communicates with the Python kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will create a basic interactive Excel-like data grid editor
    in the IPython notebook, compatible with pandas' `DataFrame`. Starting from a
    `DataFrame` object, we will be able to edit it within a GUI in the notebook. The
    editor is based on the `Handsontable` JavaScript library ([http://handsontable.com](http://handsontable.com)).
    Other JavaScript data grid editors could be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need both IPython 2.0+ and the Handsontable JavaScript library for
    this recipe. The following are the instructions to load this Javascript library
    in the IPython notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://github.com/handsontable/jquery-handsontable/tree/master/dist](https://github.com/handsontable/jquery-handsontable/tree/master/dist).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, download `jquery.handsontable.full.css` and `jquery.handsontable.full.js`,
    and put these two files in `~\.ipython\profile_default\static\custom\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this folder, add the following line in `custom.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this folder, add the following line in `custom.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, refresh the notebook!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import a few functions and classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a new widget. The `value` trait will contain the JSON representation
    of the entire table. This trait will be synchronized between Python and JavaScript,
    thanks to the IPython 2.0's widget machinery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we write the JavaScript code for the widget. The three important functions
    that are responsible for the synchronization are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`render` is for the widget initialization'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update` is for Python to JavaScript update'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle_table_change` is for JavaScript to Python update'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have a synchronized table widget that we can already use. However,
    we would like to integrate it with pandas. To do this, we create a light wrapper
    around a `DataFrame` instance. We create two callback functions for synchronizing
    the pandas object with the IPython widget. Changes in the GUI will automatically
    trigger a change in `DataFrame`, but the converse is not true. We''ll need to
    re-display the widget if we change the `DataFrame` instance in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s test all that! We first create a random `DataFrame` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We wrap it in `HandsonDataFrame` and show it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We can now change the values interactively, and they will be changed in Python
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explain briefly the architecture underlying the interactive Python-JavaScript
    communication in IPython 2.0+.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation follows the **Model-View-Controller** (**MVC**) design pattern,
    which is popular in GUI applications. There is a model in the backend (Python
    kernel) that holds some data. In the frontend (browser), there are one or several
    views of that model. Those views are dynamically synchronized with the model.
    When an attribute of the model changes on Python's side, it also changes on JavaScript's
    side, and vice versa. We can implement Python and JavaScript functions to respond
    to model changes. These changes are generally triggered by a user action.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, dynamic attributes are implemented as traits. These special class
    attributes automatically trigger callback functions when they are updated. In
    JavaScript, the `Backbone.js` MVC library is used. The communication between Python
    and the browser is done via **Comms**, a special communication protocol in IPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new widget, we need to create a class deriving from `DOMWidget`.
    Then, we define trait attributes that can be synchronized between Python and JavaScript
    if `sync=True` is passed to the trait constructors. We can register callback functions
    that react to trait changes (from either Python or JavaScript), using `widget.on_trait_change(callback,
    trait_name)`. The `callback()` function can have one of the following signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback(trait_name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback(trait_name, new_value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback(trait_name, old_value, new_value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In JavaScript, the `render()` function creates the HTML elements in the cell''s
    widget area upon initialization. The `update()` method allows us to react to changes
    in the model in the backend side (Python). In addition, we can use `Backbone.js`
    to react to changes in the frontend (browser). By extending the widget with the
    `{"change": "callback"}` events, we tell `Backbone.js` to call the `callback()`
    JavaScript function as soon as the HTML input controls change. This is how we
    react to user-triggered actions here.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the ways this proof-of-concept could be improved:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing only changes instead of synchronizing the whole array every time
    (the method used here would be slow on large tables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding recreating a new `DataFrame` instance upon every change, but updating
    the same `DataFrame` instance in-place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting named columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding the wrapper, that is, make it so that the default rich representation
    of `DataFrame` in the notebook is `HandsonDataFrame`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing everything in an easy-to-use extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few references about the widget architecture in the IPython notebook
    2.0+:'
  prefs: []
  type: TYPE_NORMAL
- en: Official example about custom widgets, available at [http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets](http://nbviewer.ipython.org/github/ipython/ipython/tree/master/examples/Interactive%20Widgets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC pattern in Wikipedia, at [https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backbone.js, available at [http://backbonejs.org/](http://backbonejs.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Course on `Backbone.js`, available at [www.codeschool.com/courses/anatomy-of-backbonejs](http://www.codeschool.com/courses/anatomy-of-backbonejs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPEP 21: Widget Messages (comms), available at [https://github.com/ipython/ipython/wiki/IPEP-21%3A-Widget-Messages](https://github.com/ipython/ipython/wiki/IPEP-21%3A-Widget-Messages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPEP 23: IPython widgets, available at [https://github.com/ipython/ipython/wiki/IPEP-23%3A-Backbone.js-Widgets](https://github.com/ipython/ipython/wiki/IPEP-23%3A-Backbone.js-Widgets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Processing webcam images in real time from the notebook* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing webcam images in real time from the notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we show how to let the notebook and the Python kernel communicate
    in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will retrieve the webcam feed from the browser using HTML5's
    `<video>` element, and pass it to Python in real time using the interactive capabilities
    of the IPython notebook 2.0+. Then, we will process the image in Python with an
    edge detector (implemented in scikit-image), and display it in the notebook in
    real time.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code for this recipe comes from Jason Grout's example, available
    at [https://github.com/jasongrout/ipywidgets](https://github.com/jasongrout/ipywidgets).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need Pillow and scikit-image for this recipe. (For more information, refer
    to [Chapter 11](ch11.html "Chapter 11. Image and Audio Processing"), *Image and
    Audio Processing*.)
  prefs: []
  type: TYPE_NORMAL
- en: You also need a recent browser supporting the HTML5 capture API. You can find
    the specification at [http://dev.w3.org/2011/webrtc/editor/getusermedia.html](http://dev.w3.org/2011/webrtc/editor/getusermedia.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to import several modules as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define two functions to convert images from and to base64 strings. This
    conversion is a common way to pass binary data between processes (in our case,
    the browser and Python):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a Python function that will process the webcam image in real time.
    It accepts and returns a NumPy array. This function applies an edge detector with
    the `roberts()` function in scikit-image as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a custom widget to handle the bidirectional communication of
    the video flow between the browser and Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to write the JavaScript code for the widget. The code is long,
    so we just highlight the important parts here. The full code is on the book''s
    website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create and display the widget as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_03_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explain the principle of this implementation. The model has two attributes:
    the incoming (raw) image from the browser and the outgoing (processed) image from
    Python. Every 100 milliseconds, JavaScript makes a capture of the webcam feed
    (in the `<video>` HTML element) by copying it to a first canvas. The canvas image
    is serialized in base64 and assigned to the first model attribute. Then, the Python
    function `_imageurl_changed()` is called. The image is deserialized, processed
    by scikit-image, and reserialized. The second attribute is then modified by Python,
    and is set to the serialized processed image. Finally, the `update()` function
    in JavaScript deserializes the processed image and displays it in a second canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The speed of this example could be greatly improved by capturing the webcam
    image from Python rather than from the browser. Here, the bottleneck probably
    stems from the two transfers that occur at every time step from the browser to
    Python and conversely.
  prefs: []
  type: TYPE_NORMAL
- en: It would be more efficient to capture the webcam's image from Python using a
    library such as `OpenCV` or `SimpleCV`. However, since these libraries may be
    difficult to install, it is much simpler to let the browser access the webcam
    device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a custom JavaScript widget in the notebook – a spreadsheet editor
    for pandas* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
