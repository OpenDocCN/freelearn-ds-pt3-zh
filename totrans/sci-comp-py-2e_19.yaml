- en: Comprehensive Examples
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will present some comprehensive and longer examples together
    with a brief introduction to the theoretical background and the examples' complete
    implementation. Here, we want to show you how the concepts defined in this book
    are used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Polynomials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The polynomial class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spectral clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving initial value problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 19.1 Polynomials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will demonstrate the power of the Python constructs presented so far
    by designing a class for polynomials.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this class differs conceptually from the class `numpy.poly1d`.
  prefs: []
  type: TYPE_NORMAL
- en: We will give some theoretical background, which will lead us to a list of requirements,
    and then we will give the code, with some comments.
  prefs: []
  type: TYPE_NORMAL
- en: 19.1.1 Theoretical background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A polynomial [![](img/cf676805-9214-4814-86d5-3f6ddf906703.png)] is defined
    by its degree, representation, and coefficients. The polynomial representation
    shown in the preceding equation is called a *monomial representation*. In this
    representation, the polynomial is written as a linear combination of monomials
    ![](img/25b413e8-ec70-4273-8da1-e78fd46d3204.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the polynomial can be written in:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Newton representation* with the coefficients ![](img/2e618d07-978d-4237-bb3b-49555b6fe6e6.png) and
    ![](img/776c7cef-d36a-4f49-8901-51d328d1e685.png) points, ![](img/70f4144b-4316-4d28-b040-817d7ab6231f.png):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/176d225f-eaa2-4651-81a8-8553ef1c652a.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Lagrange representation *with the coefficients [![](img/18da50b7-20fb-43eb-9604-eb89b6c8a06e.png)]
    and [![](img/01acca46-18e0-49c4-953b-9c7ea04ef10e.png)] points, ![](img/a116db99-24f1-4ab8-a73d-0faa9559dca3.png):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cee88b71-4869-478a-a99b-3d922588ce2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'with the cardinal functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53259454-4064-48ab-98ae-ba040828abed.png)'
  prefs: []
  type: TYPE_IMG
- en: There are infinitely many representations, but we restrict ourselves here to
    these three typical ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'A polynomial can be determined from interpolation conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6f78ad-9108-4210-861c-da2b195b4552.png)'
  prefs: []
  type: TYPE_IMG
- en: 'with the given distinct values ![](img/df8177e3-c79a-47ce-bc35-4799dd8db630.png) and
    arbitrary values ![](img/ac1fbb98-6657-4d5e-9e9f-8a7a253adf9d.png) as input. In
    the Lagrange formulation, the interpolation polynomial is directly available,
    as its coefficients are the interpolation data. The coefficients for the interpolation
    polynomial in Newton representation can be obtained by a recursion formula, called
    the divided differences formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9754f5f-e78a-4dbb-ab86-37ae62e43ecf.png)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4e1d2e6-7cbb-4959-944b-b8dbde44a6d9.png)'
  prefs: []
  type: TYPE_IMG
- en: We then obtain the coefficients by ![](img/ea7657c7-0560-412c-b631-ab76258bc65a.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The coefficients of the interpolation polynomial in monomial representation
    are obtained by solving a linear system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1c6949c-0d77-4b76-aa57-b3ba3ddb7e0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A matrix that has a given polynomial ![](img/2baead6e-97d1-4d9e-8b27-d18720ef5356.png) (or
    a multiple of it) as its characteristic polynomial is called a *companion matrix*.
    The eigenvalues of the companion matrix are the zeros (roots) of the polynomial.
    An algorithm for computing the zeros of ![](img/5b023d20-84ee-4e91-b5e8-f6620cfb7579.png) can
    be constructed by first setting up its companion matrix and then computing the
    eigenvalues with `scipy.linalg.eig`. The companion matrix for a polynomial in
    Newton representation reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b727bb-a74b-4a36-b9a6-b814fe568d52.png)'
  prefs: []
  type: TYPE_IMG
- en: 19.1.2 Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now formulate some programming tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a class called `PolyNomial` with the attributes `points`, `degree`, `coeff`,
    and `basis`, where:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`points` is a list of tuples ![](img/4afd74eb-4a3f-4f69-bb79-76ec30fe0648.png).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`degree` is the degree of the corresponding interpolation polynomial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coeff` contains the polynomial coefficients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basis` is a string stating which representation is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the class with a method for evaluating the polynomial at a given point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the class with a method called `plot` that plots the polynomial over
    a given interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method called `__add__` that returns a polynomial that is the sum of
    two polynomials. Be aware that only in the monomial case the sum can be computed
    by just summing up the coefficients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the coefficients of the polynomial represented
    in a monomial form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the polynomial's companion matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the zeros of the polynomial by computing the eigenvalues
    of the companion matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the polynomial that is the ![](img/9ca472ad-554e-4ea9-b316-765cf23dbeac.png)^(th)
    derivative of the given polynomial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that checks whether two polynomials are equal. Equality can be
    checked by comparing all coefficients (zero leading coefficients should not matter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 19.1.3 The polynomial class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now design a polynomial base class based on a monomial formulation of
    the polynomial. The polynomial can be initialized either by giving its coefficients
    with respect to the monomial basis or by giving a list of interpolation points,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `__init__` of the new class uses the construction `**args` as discussed
    in [Section 7.2.5](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Variable number
    of arguments*. If no arguments are given, a zero polynomial is assumed. If the
    polynomial is given by interpolation points, the method used to compute the coefficients
    by solving a Vandermonde system is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From [![](img/bcadae8d-6f6c-4b63-b486-8cdf1416a059.png)] given coefficients, [![](img/801a6016-08c3-4345-bec7-9b624ca74d69.png)]
    interpolation points are constructed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `self(x)` does a polynomial evaluation, which is done by providing
    a method `__call__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '(See also the example for the method `__call__` in [Section 8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Special methods.*) Here, this method uses the NumPy command `polyval`. As a next
    step, we just add for convenience two methods, which we decorate with the `property`
    decorator (see also [Section 7.8](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    *Functions as decorators**)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain what is going on here. We define a method to extract the ![](img/51485369-65e9-4da0-811d-1947fbb24f27.png)values
    of the data, which were used to define the polynomial. Similarly, a method to
    extract the ![](img/3a9672e4-ff7e-43b3-8049-7fc79880852c.png)values of the data
    is defined. With the `property` decorator, the result of calling the method is
    presented as if it were just an attribute of the polynomial. There are two coding
    alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a method call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives access to the ![](img/4b12e4f2-67b2-4d6f-b995-0911ae5ca323.png)values
    by the call: `p.x()`.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `property` decorator. It permits us to access the ![](img/35b8b3fb-62ea-4a59-9044-bcb3cffd718c.png)values
    simply by using this statement: `p.x`. We choose here the second variant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is always a good practice to define a `__repr__` method (see also [Section
    8.1.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml): *Special methods.*). At least
    for a quick check of the results, this method is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now provide a method for plotting the polynomial, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of the command `vectorize` (see [Section 4.8](b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml):
    *Functions acting on arrays*). The method `__call__` is specific to the monomial
    representation and has to be changed if a polynomial is represented in another
    way. This is also the case for the computation of the polynomial''s companion
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the companion matrix is available, the zeros of the polynomial are given
    by its eigenvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To this end, the module `scipy.linalg` has to be imported first as `sl`.
  prefs: []
  type: TYPE_NORMAL
- en: 19.1.4 Usage examples of the polynomial class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's give some usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a polynomial instance from the given interpolation points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The polynomial''s coefficients with respect to the monomial basis are available
    as an attribute of `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This corresponds to the polynomial ![](img/7d283009-8ea6-4ff2-b454-6ef8dba0c847.png) .
    The default plot of the polynomial, obtained by `p.plot((-3.5,3.5))`, results
    in the following figure (*Figure 19.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25f8b282-b144-4a5b-9172-0f4b0a6bb942.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.1: Result of the polynomial plot method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we compute the zeros of the polynomial, which in this case are two
    real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be verified by evaluating the polynomial at these points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 19.1.5 Newton polynomial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class  `NewtonPolyNomial` defines a polynomial described with respect to
    the Newton basis. We let it inherit some common methods from the polynomial base
    class, for example, `polynomial.plot`, `polynomial.zeros`, and even parts of the
    `__init__` method, by using the command `super` (see [Section 8.5](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    S*ubclasses and inheritance*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the interpolation points are given, the computation of the coefficients
    is performed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We used divided differences for computing the Newton representation of the
    polynomial, which is programmed as a generator here (see [Section 9.3.1](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml):
    *Generators* and [Section 9.4](66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml): *List-filling
    patterns*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s briefly check how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `print` executes the method `__repr__` of the base class and returns
    the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The polynomial evaluation is different from the corresponding method of the
    base class. The method `NewtonPolyNomial.__call__` needs to override `Polynomial.__call__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we give the code for the companion matrix, which overrides the corresponding
    method of the parent class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of Boolean arrays. The exercises will further build on this foundation.
  prefs: []
  type: TYPE_NORMAL
- en: 19.2 Spectral clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting application of eigenvectors is for clustering data. Using the
    eigenvectors of a matrix derived from a distance matrix, unlabeled data can be
    separated into groups. Spectral clustering methods get their name from the use
    of the spectrum of this matrix. A distance matrix for ![](img/e27f1d49-c801-4539-8009-9cae5853b3cf.png) elements
    (for example, the pairwise distance between data points) is an ![](img/a36e8b17-7e0b-488d-96b3-29c79c5257f2.png) symmetric
    matrix. Given such an ![](img/6b3e95b7-0207-425e-b217-6a476a631685.png) distance
    matrix ![](img/3972f882-789e-45e6-afcc-d1663436700b.png) with distance values
    [![](img/3fc43757-4ebf-4dd5-8163-c0a68970c633.png)], we can create the Laplacian
    matrix of the data points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5e9c5d5-826b-4e10-a5bb-94ca67e03e66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![](img/d9020f81-cd8b-4d22-bb23-c67c1326984c.png)  is the identity matrix
    and ![](img/04f5ec10-48e3-4051-822a-b701c6660c95.png) is the diagonal matrix containing
    the row sums of ![](img/a68ab07c-1d27-4a51-ba39-01c32f498aef.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30e0893d-305e-4689-80f9-af0988bad720.png)'
  prefs: []
  type: TYPE_IMG
- en: The data clusters are obtained from the eigenvectors of *L*. In the simplest
    case of data points with only two classes, the first eigenvector (that is, the
    one corresponding to the largest eigenvalue) is often enough to separate the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of simple two-class clustering. The following code creates
    some 2D data points and clusters them based on the first eigenvector of the Laplacian
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The eigenvector corresponding to the largest eigenvalue gives the grouping
    (for example, by thresholding at ![](img/e6b3a21e-af03-46d9-80e9-3822e2be13d2.png))
    and can be shown with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure (*Figure 19.2*) shows the result of spectral clustering
    of a simple two-class dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d21da077-88f0-432f-9653-866b8bd452e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.2: The result of a simple two-class clustering'
  prefs: []
  type: TYPE_NORMAL
- en: For more difficult datasets and more classes, one usually takes the ![](img/67e01793-7925-419d-9a24-2f5622e534c5.png) eigenvectors
    corresponding to the ![](img/8a74fede-f0f6-4984-ae52-1fd9ae82de90.png) largest
    eigenvalues and then clusters the data with some other method, but using the eigenvectors
    instead of the original data points. A common choice is the ![](img/2e934e12-050c-43a9-b47d-31e0f3116490.png)-means
    clustering algorithm, which is the topic of the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The eigenvectors are used as input to ![](img/8ec8c440-a221-41d9-a7e7-5e81d4aa3d23.png)-means
    clustering, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we computed the eigenvectors here using the singular value decomposition
    `sl.svd`. As ***L*** is symmetric, the result is the same as if we had used `sl.eig`,
    but `svd` gives the eigenvectors already ordered corresponding to the ordering
    of the eigenvalues. We also used throw-away variables. `svd` returns a list with
    three arrays, the left and right singular vectors, `U` and `V`, and the singular
    values, `S`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we do not need `U` and `S` here, we can throw them away when unpacking the
    return value of `svd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be plotted using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows the result of spectral clustering of a simple *multiclass
    dataset:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6c2329b-1d89-463c-ae70-1b9a5f9ee6b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.3: An example of the spectral clustering of a simple four-class dataset'
  prefs: []
  type: TYPE_NORMAL
- en: 19.3 Solving initial value problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will consider the mathematical task of numerically solving
    a system of ordinary equations for given initial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/e0418f42-aa8c-4b88-8fce-613f81f6b860.png).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is a function ![](img/b2d66ae4-6c74-4bba-996c-d8e96dfe0de4.png).
    A numerical method computes approximations, ![](img/86022693-bb97-4372-8e87-d5da6318504d.png) at
    discrete  communications points, ![](img/eca4b607-0793-4c58-b3e8-ea1fc795b35d.png),
    within the interval of interest ![](img/623b90f9-82a7-4c3d-8b57-3e05a6e609bb.png).
    We collect the data that describes the problem in a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72d19335-7a55-49bd-ab95-52b19bba506a.png)'
  prefs: []
  type: TYPE_IMG
- en: describes a mathematical pendulum; *[![](img/1f7d35f1-bd53-44fd-86b1-227069293644.png) ]*is
    its angle with respect to the vertical axis, ***g*** is the gravitation constant,
    and ***l*** is its length. The initial angle is ![](img/d2dd5a5d-e940-4681-8d88-8805e1ad95bb.png)
    and the initial angular velocity is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pendulum problem becomes an instance of the problem class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There might be different views on the problem at hand, leading to a different
    design of the class. For example, one might want to consider the interval of independent
    variables as a part of a solution process instead of the problem definition. The
    same holds when considering initial values. They might, as we did here, be considered
    a part of the mathematical problem, while other authors might want to allow variation
    of initial values by putting them as a part of the solution process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution process is modeled as another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue by first defining two discretization schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit Euler method*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Classical Runge-Kutta four-stage method (RK4)*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With these, we can create instances to obtain the corresponding discretized
    versions of the pendulum ODE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve the two discrete models and plot the solution and the angle difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2465db96-4a0d-44db-af7f-52fb01eae181.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 19.4: Pendulum simulation with the explicit Euler method and comparison
    with the results of the more accurate Runge–Kutta 4 method'
  prefs: []
  type: TYPE_NORMAL
- en: It is worthwhile discussing alternative class designs. What should be put in
    separate classes, what should be bundled into the same class?
  prefs: []
  type: TYPE_NORMAL
- en: We strictly separated the mathematical problem from the numerical method. Where
    should the initial values go? Should they be part of the problem or part of the
    solver? Or should they be left as input parameters for the solve method of the
    solver instance? One might even design the program so that it allows several possibilities.
    The decision to use one of these alternatives depends on the future use of this
    program. Looping over various initial values as in parameter identification would
    be eased by leaving the initial values as input parameters for the solve method.
    On the other hand, simulating different model variants with the same initial values
    would make coupling the initial values to the problem preferable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We presented for simplicity only solvers with a constant and given step size.
    Is the design of the `IVPsolver` class appropriate for a future extension of adaptive
    methods, where a tolerance rather than a step size is given?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We suggested earlier using a generator construction for the stepping mechanism.
    Adaptive methods need to reject steps from time to time. Is this need conflicting
    with the design of the stepping mechanism in `IVPsolver.onestepper`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We encourage you to check the design of the two SciPy tools for solving initial
    values, namely `scipy.integrate.ode` and `scipy.integrate.odeint`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 19.4 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of what we explained in this book was bundled into the three longer examples
    in this chapter. These examples mimic code development and give prototypes, which
    you are encouraged to alter and confront with your own ideas.
  prefs: []
  type: TYPE_NORMAL
- en: You saw that code in scientific computing can have its own flavor due to its
    strong relationship with mathematically defined algorithms and that it is often
    wise to keep the relationship between code and formula visible. Python has techniques
    for this, as you have seen.
  prefs: []
  type: TYPE_NORMAL
- en: 19.5 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Implement a method `__add__` that constructs a new polynomial ![](img/77fa6522-5de3-4e15-b0df-d9a450605771.png) by
    adding two given polynomials ![](img/724805b9-bea3-4a02-b1d4-5d81e8bd4634.png) and
    ![](img/e174fe97-c3d6-4bfb-a93a-1025e6028d8a.png). In monomial form, polynomials
    are added by just adding the coefficients, whereas in Newton form, the coefficients
    depend on the abscissas ![](img/171118dd-dce4-49d6-8f04-7b4855f2b4f2.png) of the
    interpolation points. Before adding the coefficients of both polynomials, the
    polynomial ![](img/8bdd5965-3db4-42e5-9eae-f37213bda9ef.png) has to get new interpolation
    points with the property that their abscissas ![](img/40eb87a9-fc00-48f8-a883-b285e80c460c.png) coincide
    with those of ![](img/296d4fcd-75bd-4819-8c45-3e084799040e.png), and the method `__changepoints__` has
    to be provided for that. It should change the interpolation points and return
    a new set of coefficients.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2:** Write conversion methods to convert a polynomial from Newton form
    into monomial form and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3:** Write a method called `add_point` that takes a polynomial *q* and
    a tuple [![](img/81f6a09d-5109-4c61-be6a-296173b0cc9a.png)] as parameters and
    returns a new polynomial that interpolates `self.points` and [![](img/858f86f2-f43e-412f-8888-c5a5f8e7513f.png)].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4:** Write a class called `LagrangePolynomial` that implements polynomials
    in Lagrange form and inherits as much as possible from the polynomial base class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5:** Write tests for the polynomial class.'
  prefs: []
  type: TYPE_NORMAL
