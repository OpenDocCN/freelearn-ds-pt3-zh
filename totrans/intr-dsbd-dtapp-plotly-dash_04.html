<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-45"><em class="italic"><a id="_idTextAnchor044"/>Chapter 3</em>: Working with Plotly's Figure Objects</h1>
			<p>Imagine that you have published an article that contains a chart. Assume that your readers will, on average, spend 1 minute looking at the chart. If your chart is easy to understand, then they will probably spend 10 seconds understanding it and 50 seconds thinking, analyzing, and pondering its implications. On the other hand, if the chart is difficult to understand, they will spend 50 seconds "reading" it, and very little time thinking about its implications.</p>
			<p>This chapter aims to equip you with tools that will help you to minimize the time an audience spends understanding your charts, and to maximize their analysis and thinking time. The two previous chapters were about structuring apps and making them interactive. In this chapter, we will discuss how to create and control the very charts around which your apps are built. Plotly's <strong class="bold">Figure</strong> object is what we will primarily explore. In this chapter, we will cover the following main topics: </p>
			<ul>
				<li>Understanding the Figure object</li>
				<li>Getting to know the data attribute</li>
				<li>Getting to know the layout attribute</li>
				<li>Learning about figure traces and how to add them</li>
				<li>Exploring the different ways of converting figures</li>
			</ul>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Technical requirements</h1>
			<p>We will focus on using the <strong class="source-inline">Figure</strong> object from the <strong class="source-inline">graph_objects</strong> module of the <strong class="source-inline">plotly</strong> package. Later in the chapter, we will utilize the other packages that we have been using to improve our app and add an interactive chart to it. As a reminder, the packages that we will use are Dash, Dash HTML Components, Dash Core Components, Dash Bootstrap Components, JupyterLab, Jupyter Dash, and pandas.</p>
			<p>The packages can be individually installed by running <strong class="source-inline">pip install &lt;package-name&gt;</strong>, but it would be better to install the exact same versions that we use here, to reproduce the same results. You can install them all by running one command, <strong class="source-inline">pip install –r requirements.txt</strong>, from the root folder of the repository. The latest version of the poverty dataset can be downloaded from this link: <a href="https://datacatalog.worldbank.org/dataset/poverty-and-equity-database">https://datacatalog.worldbank.org/dataset/poverty-and-equity-database</a>. However, as with the packages, if you want to reproduce the same results, you can access the dataset from the <strong class="source-inline">data</strong> folder in the root of the Git repository, along with the rest of the code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3x9VhAA">https://bit.ly/3x9VhAA</a>.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Understanding the Figure object</h1>
			<p>Plotly is a fully<a id="_idIndexMarker095"/> fledged data visualization system, which ships with more than 50 types of charts out of the box (for example, bar charts, scatter plots, and histograms). It supports 2D and 3D visualizations, ternary plots, maps, and more. The available options for customizing almost any aspect of your charts are very detailed and can be overwhelming. This, as they say, is a good problem to have!</p>
			<p>We use charts to uncover certain characteristics of our data or the relationships between different datasets. However, pure data visualization would be meaningless if we didn't know what is being visualized. Imagine a rectangle that has a bunch of dots on it with clear patterns. It would still be meaningless if you didn't know what the <em class="italic">x</em> axis represented, for example. If you have different shapes and colors in a plot, then they would mean nothing without a legend. Usually, titles and annotations are also needed to give us context around the data we are trying to understand.</p>
			<p>Those two groups, <strong class="source-inline">data</strong> and other supporting elements, which are collectively called <strong class="source-inline">layout</strong>, are two top-level attributes of Plotly's <strong class="source-inline">Figure</strong> object. Each attribute has several subattributes, at multiple levels, forming a tree-like structure. There is also the <strong class="source-inline">frames</strong> attribute, which is mainly used with animations, and it is not as common as the other two that are always present in every chart. We will not cover it in this chapter.</p>
			<p>Let's now explore these attributes and start plotting to get a better understanding of how they fit together within the <strong class="source-inline">Figure</strong> object:</p>
			<ul>
				<li><strong class="source-inline">data</strong>: The different attributes of data, and the relationships between them, are expressed using graphical/geometrical shapes, for example, circles, rectangles, lines, and more. The graphical attributes of those shapes are used to express various attributes of the data. The relative size, length, and distance between those shapes are how we understand this. Due to their visual and, therefore, intuitive nature, those attributes are easy to understand and don't require much explanation. The <strong class="source-inline">data</strong> attribute corresponds to the essence of what we are trying to understand. The values you need to provide for the <strong class="source-inline">data</strong> attribute depend on the chart type. For a scatter plot, for example, you need to provide <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> values. For maps, you need to have <strong class="source-inline">lat</strong> and <strong class="source-inline">lon</strong>. You can overlay several sets of data on top of each other on the same chart; each one is referred to as a <strong class="bold">trace</strong>. Each<a id="_idIndexMarker096"/> chart type can take many other optional values, and many of them will be covered in more detail later on in the book.</li>
				<li><strong class="source-inline">layout</strong>: Everything<a id="_idIndexMarker097"/> else around the data belongs to this attribute. Elements of the <strong class="source-inline">layout</strong> attribute are more abstract in nature. They typically use text to inform the user what they are looking at. Many of them are also styling elements, which might not add as much information, but they make the charts easier to understand or conform to certain branding guidelines. There are many attributes that we will explore, but the most prominent ones are the title, axis titles, ticks, and legend. These, in turn, have subattributes, such as the font size, location, and more.</li>
			</ul>
			<p>It's much easier to learn by doing, and we can now start by creating our first figure. The <strong class="source-inline">graph_objects</strong> module is usually imported as <strong class="source-inline">go</strong>, and we instantiate a figure by calling <strong class="source-inline">go.Figure</strong>! <em class="italic">Figure 3.1</em> shows an empty <strong class="source-inline">Figure</strong> object and how it is created and displayed:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B16780_03_001.jpg" alt="Figure 3.1 – The default empty Figure object displayed in JupyterLab"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The default empty Figure object displayed in JupyterLab</p>
			<p>Of course, we don't <a id="_idIndexMarker098"/>get anything from this empty figure, but it is the first step before adding the elements we want to it. Although we can create and display <strong class="source-inline">Figure</strong> objects by defining everything in the <strong class="source-inline">go.Figure</strong> call, we will use a slightly easier and more convenient approach. We will assign the created object to a variable, and then iteratively add and/or modify the elements that we want. An important benefit of this approach is that we can make changes to our charts after creating them.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Once you assign a <strong class="source-inline">Figure</strong> object to a variable, this variable becomes available in the global scope. Since it is mutable, you can make changes to it in other places in your code. Displaying the figure after making such changes will show it with the changes you have made. We will be utilizing this important feature in order to manage our charts.</p>
			<p>Having created the basic object, we are now ready to start adding our first data traces to our first <a id="_idIndexMarker099"/>chart.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Getting to know the data attribute</h1>
			<p>First, we start by <a id="_idIndexMarker100"/>adding a scatter plot using a very small and simple dataset. Later in the chapter, we will use our poverty dataset to create other plots. Once you have created your <strong class="source-inline">Figure</strong> object and assigned it to a variable, you have access to a large number of convenient methods for manipulating that object. The methods related to adding data traces all start with <strong class="source-inline">add_</strong>, followed by the type of chart we are adding, for example, <strong class="source-inline">add_scatter</strong> or <strong class="source-inline">add_bar</strong>.</p>
			<p>Let's go through the full process of creating a scatter plot:</p>
			<ol>
				<li>Import the <strong class="source-inline">graph_objects</strong> module:<p class="source-code">import plotly.graph_objects as go</p></li>
				<li>Create an instance of a <strong class="source-inline">Figure</strong> object and assign it to a variable:<p class="source-code">fig = go.Figure()</p></li>
				<li>Add a scatter trace. The minimum parameters required for this type of chart are two arrays for the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> values. These can be provided as lists, tuples, NumPy arrays, or pandas <strong class="source-inline">Series</strong>:<p class="source-code">fig.add_scatter(x=[1, 2, 3], y=[4, 2, 3])</p></li>
				<li>Display the resulting figure. You can simply have the variable on the last line in your code cell, and it will also be displayed in JupyterLab once you run it. You can also explicitly call the <strong class="source-inline">show</strong> method, which gives you a few more options to customize the display of the figure:<p class="source-code">fig.show()</p></li>
			</ol>
			<p>You can see the full code, as well as the final output, in <em class="italic">Figure 3.2</em>:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B16780_03_002.jpg" alt="Figure 3.2 – A scatter plot displayed in JupyterLab"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – A scatter plot displayed in JupyterLab</p>
			<p>We will now add<a id="_idIndexMarker101"/> another similar scatter plot, overlaid on top of this one. We simply repeat <em class="italic">step 3</em>, but with different values:</p>
			<p class="source-code">fig.add_scatter(x=[1, 2, 3, 4], y=[4, 5, 2, 3])</p>
			<p>This will add the new scatter plot to the same figure. If we call <strong class="source-inline">fig.show()</strong> after running this code, we will be able to see the updated figure. Note that this trace has four data points, whereas the previous trace had three. We don't need to worry about this, as this is handled for us using certain default values. We also have the option to modify those default values if we need to.</p>
			<p>If we want to modify any aspect of our <strong class="source-inline">data</strong> trace, we can do it through the <strong class="source-inline">add_&lt;chart_type&gt;</strong> method. The call to those methods provides a lot of options through many parameters, and they are specific to the type of chart you are producing. Part 2 of this book will go deeper into several chart types and the different options that they provide. On the other hand, if we want to modify anything related to the <strong class="source-inline">layout</strong> attribute, we can do so by accessing and then assigning the attributes and/or subattributes that we want in a simple, declarative way. This is generally done using Python's dot notation, for example, <strong class="source-inline">figure.attribute.sub_attribute = value</strong>. This guideline is not entirely correct, as there are a few exceptions, and in some cases, there is an overlap where an attribute belongs to the <strong class="source-inline">data</strong> attribute but is managed by <a id="_idIndexMarker102"/>the <strong class="source-inline">layout</strong> attribute, for example. In most cases, this is a helpful distinction to keep in mind.</p>
			<p>Let's now take a look at some of the things that we can change in our figure's layout.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Getting to know the layout attribute</h1>
			<p>For the current <a id="_idIndexMarker103"/>figure that we are working on, let's add a title (for the whole figure), along with axis titles, to see how it works: </p>
			<p class="source-code">fig.layout.title = 'The Figure Title'</p>
			<p class="source-code">fig.layout.xaxis.title = 'The X-axis title'</p>
			<p class="source-code">fig.layout.yaxis.title = 'The Y-axis title'</p>
			<p>As you can see, we are exploring the tree-like structure of our figure. There is a <strong class="source-inline">title</strong> attribute that falls directly under <strong class="source-inline">fig.layout</strong>, and there are also titles for <strong class="source-inline">fig.layout.xaxis</strong> and <strong class="source-inline">fig.layout.yaxis</strong>. To give you a sense of how detailed the available options are, <em class="italic">Figure 3.3</em> shows some of the <strong class="source-inline">xaxis</strong> attributes that start with <strong class="source-inline">tick</strong> only:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B16780_03_003.jpg" alt="Figure 3.3 – Some of the Figure object's layout.xaxis options"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Some of the Figure object's layout.xaxis options</p>
			<p>Let's now look at the <a id="_idIndexMarker104"/>effect of the four lines of code we just added:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B16780_03_004.jpg" alt="Figure 3.4 – The updated figure containing two traces, a legend, and titles"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The updated figure containing two traces, a legend, and titles</p>
			<p>The three titles we have added are self-explanatory. New traces take on new default colors to differentiate them. Another interesting thing is the legend, which was added automatically. When you just have one trace, there is usually no need for a legend, but it becomes important when you have more than one. Descriptive names are crucial, of course, and <strong class="bold">trace 0</strong> doesn't mean much, but I'm keeping it as a memory aid to remember the<a id="_idIndexMarker105"/> names of the figure elements.</p>
			<p>The figure we just created and displayed is what your users will see. Let's now take an interactive peek at the components of this figure.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Interactively exploring the Figure object</h2>
			<p>As I mentioned<a id="_idIndexMarker106"/> earlier, the <strong class="source-inline">show</strong> method provides a few handy options for customizing what and how your figures are displayed. A particularly helpful one is setting the <strong class="source-inline">renderer</strong> parameter to JSON. <em class="italic">Figure 3.5</em> shows how this can be useful:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B16780_03_005.jpg" alt="Figure 3.5 – Interactively exploring the Figure object in JupyterLab"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Interactively exploring the Figure object in JupyterLab</p>
			<p>In the top-left corner, you can see the default view. The <strong class="bold">root</strong> represents the <strong class="source-inline">Figure</strong> object, and the two top-level attributes can be seen right under it. We also get a hint that our <strong class="bold">data</strong> attribute contains two items (these are the two traces we added). The triangles and their directions indicate whether the respective attribute has been expanded or collapsed.</p>
			<p>In the bottom-left corner, you can see the search functionality in action. This is useful for when you want to access or modify a certain attribute but are not entirely sure what its exact name is, or to what attribute it belongs. On the right-hand side, I have expanded a few of<a id="_idIndexMarker107"/> the items, and you can see that they correspond to the figure we created.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This chapter, and the whole book really, is about how to create the charts and dashboards that you want. It's not about data visualization's best practices or statistical inference. In other words, it's about how to create the things you <em class="italic">want</em> to create, and not about what you <em class="italic">should</em> create. I'll still try to share good practices, and hopefully, make reasonable choices for the charts and their details, but it's important to keep this distinction in mind.</p>
			<p>I'm sure you have noticed the "mode bar" containing interactive buttons and controls in the top-right corner of the figures we created. There are several ways to control which buttons to show or hide and a few other options. This is available through the <strong class="source-inline">config</strong> parameter of the <strong class="source-inline">show</strong> method.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Configuration options for the Figure object</h2>
			<p>The <strong class="source-inline">config</strong> parameter<a id="_idIndexMarker108"/> takes a dictionary and controls several interesting options. The keys control which aspect to modify. Additionally, the values can be given as strings or lists, depending on which one you are modifying. For example, consider the following code snippet: </p>
			<p class="source-code">fig.show(config={'displaylogo': False,</p>
			<p class="source-code">                 'modeBarButtonsToAdd': ['drawrect',</p>
			<p class="source-code">                                         'drawcircle',</p>
			<p class="source-code">                                         'eraseshape']})</p>
			<p>Here are some of the most important ones:</p>
			<ul>
				<li><strong class="source-inline">displayModeBar</strong>: This defaults to <strong class="source-inline">True</strong>. It controls whether or not to display the whole mode bar.</li>
				<li><strong class="source-inline">responsive</strong>: This defaults to <strong class="source-inline">True</strong>. It controls whether or not to change the dimensions of the figure based on the browser window's size. Sometimes, you might want to keep the figure dimensions fixed.</li>
				<li><strong class="source-inline">toImageButtonOptions</strong>: The camera icon in the mode bar allows users to download the figure as an image. This option controls the default formats of downloading those<a id="_idIndexMarker109"/> images. It takes a dictionary in which you can set the default format (that is, SVG, PNG, JPG, or WebP). You can also set default values for the height, width, filename, and scale. </li>
				<li><strong class="source-inline">modeBarButtonsToRemove</strong>: This is a list of buttons you don't want in the mode bar.</li>
			</ul>
			<p>Now that we have learned how to create, examine, and configure basic charts, let's explore what else we can do with them. How can we convert them into other formats? And what other formats are available?</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Exploring the different ways of converting figures</h1>
			<p>The methods<a id="_idIndexMarker110"/> that control converting figures start with either <strong class="source-inline">to_</strong> or <strong class="source-inline">write_</strong>. Let's explore some of the most interesting ones.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Converting figures into HTML</h2>
			<p>Plotly figures are <a id="_idIndexMarker111"/>actually HTML objects, together <a id="_idIndexMarker112"/>with the JavaScript that makes them interactive. We can easily capture that HTML file if we want to share it with others via email, for example. You might consider having this as a feature in your dashboards. Your users can create the chart or report they want, convert it into HTML, download it, and share it with their colleagues.</p>
			<p>All you have to do is provide a file path of where you want it to be saved. The method also takes several optional parameters for further customization. Let's convert our figure into HTML and add a <strong class="source-inline">config</strong> option to make it download the figure image in SVG format. The effect of this will be reflected in the HTML file when clicking on the camera icon. The code for this is straightforward:</p>
			<p class="source-code">fig.write_html('html_plot.html',</p>
			<p class="source-code">               config={'toImageButtonOptions':</p>
			<p class="source-code">                       {'format': 'svg'}})</p>
			<p>We can now open the file in a browser as a separate HTML file, filling the whole browser screen, as shown in <em class="italic">Figure 3.6</em>:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B16780_03_006.jpg" alt="Figure 3.6 – The Figure object is rendered as a separate HTML file in a browser window"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The Figure object is rendered as a separate HTML file in a browser window</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Converting figures into images</h2>
			<p>We have <a id="_idIndexMarker113"/>examined the option that allows users to <a id="_idIndexMarker114"/>manually download an image of the <strong class="source-inline">Figure</strong> object. There is another way of doing so programmatically, which can also be interesting. Just like the <strong class="source-inline">write_html</strong> method, we also have a <strong class="source-inline">write_image</strong> method. The format of the image can be explicitly provided or inferred from the file extension you provide. You can also set the <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> values.</p>
			<p>This might be interesting for mass image creation. For example, you might want to create many plots, one for each country, and save each in a file for a separate report on each country. It would be very tedious to do this manually. You might also include this in one of your callbacks for your users. You could allow your users to assemble certain reports, and click on a button that converts them into images and then downloads them, for example. This can be run just like the HTML converter:</p>
			<p class="source-code">fig.write_image('path/to/image_file.svg',</p>
			<p class="source-code">                height=600, width=850)</p>
			<p>With this information, we can now get practical and find out more about our dataset.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Plotting using a real dataset</h2>
			<p>In <a href="B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring the Structure of a Dash App</em>, we created a simple report that showed the <a id="_idIndexMarker115"/>user the population of the selected country in the year 2010. This type of report is used when the user knows what they want. That is, they have a specific question about a specific country, metric, and period of time in mind, and our functionality provides an answer to their question.</p>
			<p>We can think of dashboard functionality falling under two broad categories. The first, as we have done already, are visualizations or reports that answer a specific question. The second, which we will do now, guide the user in a more exploratory approach. In this case, users don't know much about a certain topic and they are looking for an overview.</p>
			<p>Your users can go back and forth between those types of charts. For example, first, they explore poverty in the last decade. A certain region stands out. They then ask a specific question about that region. When they realize that that region had an unusually high rate of another metric, they can go on to another exploratory chart in that metric to learn more about it.</p>
			<p>Now, we will let the user select a year, and the app will display the top 20 countries by population for the selected year.</p>
			<p>As a quick reminder, our poverty dataset contains columns for the countries and their codes, the indicators and their codes, and a column for each year from 1974 to 2019.</p>
			<p>As agreed, let's <a id="_idIndexMarker116"/>first do this in an isolated environment in JupyterLab:</p>
			<ol>
				<li value="1">Import <strong class="source-inline">pandas</strong>, use it to open the poverty dataset, and assign it to the <strong class="source-inline">poverty_data</strong> variable:<p class="source-code">import pandas as pd</p><p class="source-code">poverty_data =</p><p class="source-code">pd.read_csv('data/PovStats_csv/PovStatsData.csv')</p></li>
				<li>Although the column of interest is called <strong class="bold">Country Name</strong>, it actually contains regions as well, which can be really useful, but not in this case. We can extract all the regions so that we can exclude them from the dataset. I manually copied the regions and created the <strong class="source-inline">regions</strong> list:<p class="source-code">regions = ['East Asia &amp; Pacific', 'Europe &amp; Central</p><p class="source-code">Asia',           'Fragile and conflict affected</p><p class="source-code">situations', 'High income',</p><p class="source-code">'IDA countries classified as fragile situations', 'IDA</p><p class="source-code">total', 'Latin America &amp; Caribbean', 'Low &amp; middle</p><p class="source-code">income', 'Low income', 'Lower middle income', 'Middle</p><p class="source-code">East &amp; North Africa', 'Middle income', 'South Asia',</p><p class="source-code">'Sub-Saharan Africa', 'Upper middle income', 'World'] </p></li>
				<li>Create <strong class="source-inline">population_df</strong>, the subset DataFrame where the <strong class="bold">Country Name</strong> column is not in <strong class="source-inline">regions</strong>, and the <strong class="bold">Indicator Name</strong> column is equal to <strong class="bold">Population, total</strong>. The <strong class="source-inline">isin</strong> method for pandas <strong class="source-inline">Series</strong> checks whether values in the <strong class="source-inline">Series</strong> are in a certain list, and the <strong class="source-inline">~</strong> (tilde) is the logical negation operator:<p class="source-code">population_df = poverty_data[<strong class="bold">~</strong>poverty_data['Country</p><p class="source-code">Name'].<strong class="bold">isin</strong>(regions) &amp; (poverty_data['Indicator</p><p class="source-code">Name']== 'Population, total')]</p></li>
				<li>The first few<a id="_idIndexMarker117"/> rows of the resulting DataFrame can be displayed as follows:<p class="source-code">population_df.head()</p><p>It looks similar to the following screenshot:</p><div id="_idContainer036" class="IMG---Figure"><img src="image/B16780_03_007.jpg" alt="Figure 3.7 – The first few rows of population_df"/></div><p class="figure-caption">Figure 3.7 – The first few rows of population_df</p></li>
				<li>Create a dynamic <strong class="source-inline">year</strong> variable, and create a <strong class="source-inline">year_df</strong> variable containing the countries column along with the selected year's column. Then, sort those values in descending order and extract the first 20:<p class="source-code"><strong class="bold">year</strong> = '2010'</p><p class="source-code">year_df = population_df[['Country Name',</p><p class="source-code"><strong class="bold">year</strong>]].sort_values(<strong class="bold">year</strong>, ascending=False)[:20]</p></li>
				<li>With a <strong class="source-inline">year_df</strong> variable containing two sorted columns, we can very easily create a bar <a id="_idIndexMarker118"/>chart just as we did with the scatter plots earlier. We can also add a dynamic title, containing the year, as a variable:<p class="source-code">fig = go.Figure()</p><p class="source-code">fig.add_bar(x=year_df['Country Name'],</p><p class="source-code">y=year_df[<strong class="bold">year</strong>])</p><p class="source-code">fig.layout.title = f'Top twenty countries by</p><p class="source-code">population - {<strong class="bold">year</strong>}'</p><p class="source-code">fig.show()</p></li>
			</ol>
			<p>This results in the following output:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B16780_03_008.jpg" alt="Figure 3.8 – A bar chart showing the top 20 countries by population in 2010"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – A bar chart showing the top 20 countries by population in 2010</p>
			<p>As you can see, once<a id="_idIndexMarker119"/> we have a proper subset with the relevant columns sorted, we can produce the chart we want with a few lines of code. Additionally, note that the numbers on the <em class="italic">y</em> axis were formatted, by default, as billions (or fractions of billions) to make them easy to read.</p>
			<p>We didn't set axis titles. Here, the figure title implicitly tells us about both axes: "countries" and "population." With a numeric <em class="italic">y</em> axis and the country names listed on the <em class="italic">x</em> axis, it should be clear to users.</p>
			<p>2010 is an arbitrary year, and we actually want users to be able to select the year they want from the ones that are available in the dataset.</p>
			<p>The code that produced the figure only requires a <strong class="source-inline">def</strong> statement and some indentation to become a function:</p>
			<p class="source-code"><strong class="bold">def plot_countries_by_population(year):</strong></p>
			<p class="source-code">    year_df = …</p>
			<p class="source-code">    fig = go.Figure()</p>
			<p class="source-code">    …</p>
			<p class="source-code">    fig.show()    </p>
			<p>This function produces a similar chart to the one that we just produced, but for the given <strong class="source-inline">year</strong> argument. You might think that it's as easy to convert this function into a callback function, just by adding a line of code. This is exactly what we will be doing, but first, I'd like to <a id="_idIndexMarker120"/>highlight an observation about data manipulation and preparation, and how it relates to data visualization because this example illustrates it very well.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Data manipulation as an essential part of the data visualization process</h2>
			<p>The previous <a id="_idIndexMarker121"/>example contains six steps. The first five were for preparing the data and getting it in two arrays: one for countries and the other for population numbers. The sixth and final step alone was where we produced the chart. There was much more code for data preparation than there was for producing the figure.</p>
			<p>If you consider the mental effort and time required to produce the chart (that is, the final step only), you can easily see that it is the same as the mental effort required to produce the scatter plot that we created at the beginning of the chapter, featuring the toy dataset. We simply ran <strong class="source-inline">add_scatter(x=[1, 2, 3], y=[4, 2, 3])</strong>, and then we did the same for the bar chart, only with different values.</p>
			<p>However, if you consider the mental effort and time spent on preparing the data for the bar chart, you can clearly see that there is a huge difference, compared to the data preparation for the scatter plot. We needed to know that the <strong class="bold">Country Name</strong> column did not really refer to <em class="italic">all</em> countries. We had to explore and manually check that first to know this. We also had to extract the regions and exclude them. How did we know that "South Asia" was a region, while "South Africa" was a country? We had to know this beforehand, or we had to know how to get a list of countries to check against. Additionally, we had to know that the year columns were strings and not integers. I discovered that when I got <strong class="source-inline">KeyError</strong> after trying to access the data for a certain year. We typically spend more time and effort on these things, and once the data is in a suitable format, we can easily visualize it.</p>
			<p>In <a href="B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Manipulation and Preparation - Paving the Way to Plotly Express</em>, we will spend more time on this topic, and introduce some important techniques that might be useful in a variety of situations. However, keep in mind that your skills in manipulating data, reshaping it, merging datasets, regular expressions, and all the tedious parts of data preparation form a big part of where your contribution lies. It's where most opportunities are, and a lot of it is based on your judgment. Domain knowledge is also essential; for instance, knowing the difference between regions and countries. Once you have data in a <a id="_idIndexMarker122"/>certain format, there are numerous advanced techniques and algorithms that you can use to visualize, analyze, and run various machine learning pipelines that require comparatively little code.</p>
			<p>Now, let's use our newly created function and learn how to make it interactive with a <strong class="source-inline">Dropdown</strong> component and a callback function.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Making the chart interactive with a callback function</h2>
			<p>First, we will <a id="_idIndexMarker123"/>do this as a completely <a id="_idIndexMarker124"/>isolated app in JupyterLab, after which we will add it to our app. In the isolated environment, our <strong class="source-inline">app.layout</strong> attribute will contain two components:</p>
			<p><strong class="source-inline">Dropdown</strong>: This will display all the available years so that the user can select the one they want. </p>
			<p><strong class="source-inline">Graph</strong>: This is a new component that we haven't covered yet, and we will be working extensively with it. Adding a <strong class="source-inline">Graph</strong> component to the layout displays an empty chart. If you remember our discussion about callback functions, when modifying a component in a callback function, we need to provide its <strong class="source-inline">component_id</strong> and <strong class="source-inline">component_property</strong>. The property that we will be modifying, in this scenario, is the <strong class="source-inline">figure</strong> property, and it only belongs to the <strong class="source-inline">Graph</strong> component.</p>
			<p>You are now familiar with the imports and app instantiation, so I will mainly focus on the <strong class="source-inline">app.layout</strong> attribute of the app: </p>
			<p class="source-code">app.layout = html.Div([</p>
			<p class="source-code">    dcc.Dropdown(id='year_dropdown',</p>
			<p class="source-code">                 <strong class="bold">value='2010'</strong>,</p>
			<p class="source-code">                 options=[{'label': year, 'value':</p>
			<p class="source-code"><strong class="bold">str(year)</strong>}</p>
			<p class="source-code">                          for year in range(1974, 2019)]),</p>
			<p class="source-code">    <strong class="bold">dcc.Graph(id='population_chart')</strong>,</p>
			<p class="source-code">])</p>
			<p>For now, there is <a id="_idIndexMarker125"/>nothing special about <a id="_idIndexMarker126"/>the <strong class="source-inline">Graph</strong> component. We simply create one underneath the <strong class="source-inline">Dropdown</strong> component and give it a descriptive <strong class="source-inline">id</strong> argument.</p>
			<p>I'm sure you have also noticed that this time, we have slightly different values for the <strong class="source-inline">label</strong> and <strong class="source-inline">value</strong> keys in the list of <strong class="source-inline">options</strong> in the <strong class="source-inline">Dropdown</strong> component. The difference is that the <strong class="source-inline">value</strong> key is set to <strong class="source-inline">str(year)</strong>. Since <strong class="source-inline">options</strong> is a list of dictionaries generated by a list comprehension, it will produce a list of integers. The selected number will be used to select the column with that value. In this dataset, the columns are all strings, so using <strong class="source-inline">population_df[2010]</strong> will not work, because there is really no such column (as an integer). The actual column name is <strong class="bold">2010</strong>, as a string. So, we are specifying the label as an integer, but the actual value that will be used by the callback function is the string representation of that integer (the year).</p>
			<p>We have also added a new parameter that we haven't discussed yet. The <strong class="source-inline">value</strong> parameter of the <strong class="source-inline">Dropdown</strong> component serves as a default that will be shown to users the first time they see the app. This is better than showing an empty chart.</p>
			<p>In some cases, you might want to do the opposite of what we did in this example. You might want to keep <strong class="source-inline">value</strong> as it is but modify <strong class="source-inline">label</strong> somehow. For example, if your data was all in lowercase, you might want to display the options as capitalized. In our colors example, in the previous chapter, we could have done something like this:</p>
			<p class="source-code">dcc.Dropdown(options=[{'label': <strong class="bold">color.title()</strong>, 'value':</p>
			<p class="source-code">color} for color in ['blue', 'green', 'yellow']])</p>
			<p>From the callback function's perspective, the colors are still the same, because it mainly deals with the <strong class="source-inline">value</strong> attribute. But for the user, this would display the colors as capitalized: "Blue," "Green," and "Yellow."</p>
			<p>Running the app with the two components defined so far produces the app, as shown in <em class="italic">Figure 3.9</em>:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B16780_03_009.jpg" alt="Figure 3.9 – An app with a Dropdown component showing a default value and an empty graph"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – An app with a Dropdown component showing a default value and an empty graph</p>
			<p>We have already<a id="_idIndexMarker127"/> created a normal function<a id="_idIndexMarker128"/> that takes the data as a year and returns a bar chart showing the top 20 countries by population for that year. Converting it into a callback function requires one line of code:</p>
			<p class="source-code"><strong class="bold">@app.callback(Output('population_chart', 'figure'),</strong></p>
			<p class="source-code"><strong class="bold">              Input('year_dropdown', 'value'))</strong></p>
			<p class="source-code">def plot_countries_by_population(year):</p>
			<p class="source-code">    year_df = …</p>
			<p class="source-code">    fig = go.Figure()</p>
			<p class="source-code">    …</p>
			<p class="source-code">    <strong class="bold">return fig</strong></p>
			<p>In the previous function definition, the last line was <strong class="source-inline">fig.show()</strong>, and in the callback function, we return the figure instead. The reason is that, in the first case, we were running it interactively and there was no app or callback context. In this case, we have a component <a id="_idIndexMarker129"/>with<a id="_idIndexMarker130"/> the <strong class="source-inline">population_chart</strong> ID, and, most importantly, we want to change its <strong class="source-inline">figure</strong> property. Returning the figure will hand it to the <strong class="source-inline">Graph</strong> component and modify its <strong class="source-inline">figure</strong> attribute.</p>
			<p>Running this app will produce dynamic charts based on the user selection, as you can see in <em class="italic">Figure 3.10</em>:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B16780_03_010.jpg" alt="Figure 3.10 – An app displaying a bar chart based on the selected year"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – An app displaying a bar chart based on the selected year</p>
			<p>If you compare this to <em class="italic">Figure 3.8</em>, you will notice that the country names are displayed vertically here, while, previously, they were displayed at a certain angle. This is simply because the chart was displayed in a wider browser window. This is another convenient default that Plotly handles for us without us having to do anything. This means that our figures are <a id="_idIndexMarker131"/>responsive, which gives them great<a id="_idIndexMarker132"/> flexibility. This is the same with the apps and their components that we style with Dash Bootstrap Components.</p>
			<p>Now that we have created an isolated app that works independently, let's look at how to add this to our app.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Adding the new functionality to our app</h2>
			<p>So far, the latest<a id="_idIndexMarker133"/> version of the app contains a <strong class="source-inline">Dropdown</strong> component, and underneath that, the <strong class="source-inline">Div</strong> for the population report of 2010. Underneath that, we have the <strong class="source-inline">Tabs</strong> component. Let's now insert the new <strong class="source-inline">Dropdown</strong> and <strong class="source-inline">Graph</strong> components right underneath the report area, and above the <strong class="source-inline">Tabs</strong> component. Let's also add the new callback function:</p>
			<ol>
				<li value="1">Copy the two new components to where they belong in the <strong class="source-inline">app.layout</strong> attribute:<p class="source-code">…</p><p class="source-code">html.Br(),</p><p class="source-code">html.Div(id='report'),</p><p class="source-code">html.Br(),</p><p class="source-code"><strong class="bold">dcc.Dropdown(id='year_dropdown',</strong></p><p class="source-code"><strong class="bold">             value='2010',</strong></p><p class="source-code"><strong class="bold">             options=[{'label': year, 'value':</strong></p><p class="source-code"><strong class="bold">str(year)}</strong></p><p class="source-code"><strong class="bold">                      for year in range(1974, 2019)]),</strong></p><p class="source-code"><strong class="bold">dcc.Graph(id='population_chart'),</strong></p><p class="source-code">dbc.Tabs([</p><p class="source-code">…</p></li>
				<li>Copy the callback function definition and place it anywhere after the closing tag of the top-level <strong class="source-inline">Div</strong> of <strong class="source-inline">app.layout</strong>. You can place it under the previous callback function<a id="_idIndexMarker134"/> that we created for better organization, but it doesn't matter where you place it in terms of functionality:<p class="source-code">@app.callback(Output('population_chart', 'figure'),</p><p class="source-code">              Input('year_dropdown', 'value'))</p><p class="source-code">def plot_countries_by_population(year):</p><p class="source-code">    fig = go.Figure()</p><p class="source-code">    year_df = population_df[['Country Name',</p><p class="source-code">year]].sort_values(year, ascending=False)[:20]</p><p class="source-code">    fig.add_bar(x=year_df['Country Name'],</p><p class="source-code">                y=year_df[year])</p><p class="source-code">    fig.layout.title = f'Top twenty countries by</p><p class="source-code">population - {year}'</p><p class="source-code">    return fig</p></li>
				<li>Add the definition of the <strong class="source-inline">regions</strong> list and then <strong class="source-inline">population_df</strong> after the definition of <strong class="source-inline">poverty_data</strong>. The order is important because <strong class="source-inline">population_df</strong> depends on <strong class="source-inline">regions</strong> to be defined before it, and since it is a subset of <strong class="source-inline">poverty_data</strong>, it also needs to be defined after it. This is the order in which these variables need to be defined:<p class="source-code">poverty_data = … </p><p class="source-code">regions = …</p><p class="source-code">population_df = …</p></li>
			</ol>
			<p>Now, if we run the <a id="_idIndexMarker135"/>app, you can see what it looks like in <em class="italic">Figure 3.11</em>:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B16780_03_011.jpg" alt="Figure 3.11 – The app with the new components added (Dropdown and Graph)."/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – The app with the new components added (Dropdown and Graph).</p>
			<p>If you open the debugger and click on the <strong class="bold">Callbacks</strong> button, you can also see an updated view of the available callbacks, along with the names of the components that they link to (the component IDs and the component properties). <em class="italic">Figure 3.12</em> shows this:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B16780_03_012.jpg" alt="Figure 3.12 – The app callbacks in the visual debugger"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – The app callbacks in the visual debugger</p>
			<p>Our app now displays <a id="_idIndexMarker136"/>more information. It allows users to get information interactively from the dataset. We defined two callback functions and have a layout that contains several components of different types. We also have about 90 lines of code in total. Simply adding new components by inserting them somewhere works fine until you have a large enough number of them in the app. Then, we will need to learn how to better organize the code and refactor it. </p>
			<p>Let's close this chapter with a fun, easy-to-use aspect of the Plotly <strong class="source-inline">Figure</strong> object, which does not require much coding, and then recap the topics covered.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Theming your figures</h2>
			<p>Theming your<a id="_idIndexMarker137"/> figures (as opposed to your apps) can be interesting and saves a lot of time if you need to change themes. This can be accessed and modified through the <strong class="source-inline">template</strong> attribute under <strong class="source-inline">layout</strong>:</p>
			<p class="source-code">fig.layout.template = template_name</p>
			<p><em class="italic">Figure 3.13</em> shows four different templates and their names: </p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B16780_03_013.jpg" alt="Figure 3.13 – Four different Figure templates"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Four different Figure templates</p>
			<p>The full list of <a id="_idIndexMarker138"/>templates is available in <strong class="source-inline">plotly.io.templates</strong>.</p>
			<p>This is helpful when you want your figures to have a template that is compatible with the app's theme. It is also a good starting point to enable you to select one of the templates and then modify a few of its elements as you see fit.</p>
			<p>Let's now recap the topics that we have covered in this chapter.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Summary</h1>
			<p>We started by introducing the <strong class="source-inline">Figure</strong> object, its components, and subcomponents. We looked at how to create figures step by step, and how to modify various aspects of them. We also took an extensive look at the two main attributes of figures, the <strong class="source-inline">data</strong> and <strong class="source-inline">layout</strong> attributes. A few ways of converting figures were also explored, and we then created a chart based on our dataset and incorporated it into our app.</p>
			<p>With the chapters you have read so far, you now know how to create and structure apps, how to make them interactive by creating callbacks that link various page components together, and how to build charts that fit into the whole system.</p>
			<p>You now know how to build fully interactive apps, and with the understanding developed in this chapter, you also know how to manage the various aspects of your figures and make sure that they are easy to read, so your users can spend more time on analysis and less time on understanding the charts themselves.</p>
			<p>We briefly observed the importance of data preparation and manipulation, and we are now ready to take a more extensive look at it. In the next chapter, we will introduce <strong class="bold">Plotly Express</strong>, a powerful and higher-level interface that is used to create charts concisely.</p>
		</div>
	</body></html>