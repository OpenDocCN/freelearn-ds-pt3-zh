- en: '*Chapter 8*: Calculating Data Frequency and Building Interactive Tables'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the chart types that we've explored so far displayed our data as is. In
    other words, every marker, whether it was a circle, a bar, a map, or any other
    shape, corresponded to a single data point in our dataset. **Histograms**, on
    the other hand, display bars that correspond to a summary statistic about *groups*
    of data points. A histogram is mainly used to count values in a dataset. It does
    so by grouping, or "binning," the data into bins and displaying the count of observations
    in each bin. Other functions are possible, of course, such as working out the
    mean or maximum, but counting is the typical use case. The counts are represented
    like a bar chart, where the heights of the bars correspond to the counts (or other
    function) of each bin. Another important result is that we also see how data is
    distributed, and what shape/kind of distribution we have. Are the observations
    concentrated around a certain point or more than one point? Are they skewed to
    the left or the right? This can give us an overview of this aspect of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Probability distributions are fundamental in statistics and crucial in getting
    an overview of our data. It is important to know how data values are spread in
    our sample or dataset, and where they are concentrated. If a dataset looks normally
    distributed, we might make different assumptions and have different expectations
    than if it were exponentially distributed. Histograms help in revealing the shape
    of the distribution of our data.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explore Dash's **DataTable** component in this chapter. This is
    a flexible, powerful, and feature-rich component that helps us with, among other
    things, displaying, filtering, and exporting tables of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the histogram by modifying its bins and using multiple histograms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding interactivity to histograms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a 2D histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a DataTable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the look and feel of the table (cell width, height, text display,
    and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding histograms and tables to the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use similar tools to the ones we used in the previous chapter with one
    addition. We will be using Plotly Express as well as the `graph_objects` module
    for creating our charts. The packages to use are Plotly, Dash, Dash Core Component,
    Dash HTML Components, Dash Bootstrap Components, pandas, and the new `dash_table`
    package. You don't need to install this separately (although you can), as it is
    installed together with Dash when you install it.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_08](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_08).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3sGSCes](https://bit.ly/3sGSCes).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a histogram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to see how we can get the distribution of a sample of data and get an
    idea of where values are concentrated, as well as how much variability/spread
    it has. We will do this by creating a histogram.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we''ll start with the simplest possible example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We open the `poverty` DataFrame and create a subset of it, containing only
    countries and data from the year 2015:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import Plotly Express and run the `histogram` function with `df` as the argument
    to the `data_frame` parameter and the indicator of our choice for the `x` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a result, we get the histogram that you can see in *Figure 8.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A histogram of the Gini indicator](img/B16780_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – A histogram of the Gini indicator
  prefs: []
  type: TYPE_NORMAL
- en: The *x* axis was named using the indicator we chose, and the *y* axis was given
    the title `count`. This is the default function that the `histogram` function
    uses, and it is clear also from the hover box that we see when hovering over any
    of the bars. Here we learn that there are 18 countries whose Gini index was in
    the interval (**35, 39.9**) in the year 2015\. We have previously visualized this
    indicator by country (visualizing each and every country), but this time, we are
    getting an idea of how many values are available in each bin and how those values
    are distributed. We can see that the majority of countries have a Gini index between
    25 and 40 and that the numbers get progressively lower the higher the Gini index
    becomes. This is valid for this particular year only, of course.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the default number of bins, but we can modify it if we want. This
    is something that you typically want to interactively modify until you get a good
    view. In an interactive setting, such as in a dashboard, it's probably a good
    idea to allow users to modify the number of bins, especially if you don't know
    which metric they will choose and how the values are distributed for that metric.
    This is exactly our case in the dataset we are working with.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the effect of changing the number of bins, as well as other available
    modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the histogram by modifying its bins and using multiple histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can change the number of bins through the `nbins` parameter. We will first
    see the effect of using two extreme values for the number of bins. Setting `nbins=2`
    generates the chart in *Figure 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A histogram of the Gini indicator with two bins](img/B16780_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – A histogram of the Gini indicator with two bins
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the values were split into two equal bins, (`nbins=500` produces
    the chart in *Figure 8.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – A histogram of the Gini indicator with 500 bins](img/B16780_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – A histogram of the Gini indicator with 500 bins
  prefs: []
  type: TYPE_NORMAL
- en: It is now much more detailed, maybe more detailed than useful. When you set
    too many bins, it is almost like looking at the raw data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default number of bins resulted in the bin size being intervals of five.
    Now that we know that our values range between 25 and 60 (45), we might want to
    see how the data is distributed across 45 bins. This makes the size of each bin
    1\. *Figure 8.4* shows the result of setting `nbins=45`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – A histogram of the Gini indicator with 45 bins](img/B16780_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – A histogram of the Gini indicator with 45 bins
  prefs: []
  type: TYPE_NORMAL
- en: All the figures we created in this chapter so far were for the same dataset.
    You can see how different the distribution looks based on the selected number
    of bins. You can also think of it as looking at the distribution of the data with
    varying resolutions. There is usually an optimal resolution for your use case
    that can be manually tweaked until you find the most useful/insightful one for
    you. This is a major advantage of making histograms interactive, where you allow
    your users to explore as they see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we have a few categorical columns in our dataset and that we might
    use those columns to color our bars to get a more detailed view of the data. Let's
    see how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Using color to further split the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might have guessed, adding color to a Plotly Express chart is simply
    done by selecting a column from the DataFrame we are using. Setting `color=''Income
    Group''` generates the chart you can see in *Figure 8.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A histogram of the Gini indicator colored by Income Group](img/B16780_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A histogram of the Gini indicator colored by Income Group
  prefs: []
  type: TYPE_NORMAL
- en: This is the exact same histogram but enriched by another dimension of the dataset.
    Each bar is split by **Income Group** and colored accordingly. We can now see
    for each bin how many countries there are from each income group.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the effect of setting `color=''Region'', color_discrete_sequence=px.colors.qualitative.Set1`
    in *Figure 8.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – A histogram of the Gini indicator colored by Region](img/B16780_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – A histogram of the Gini indicator colored by Region
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have the same histogram, but colored using a different column, `barmode`
    parameter. Let's explore how this applies to histograms.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the bars in histograms are displayed in a connected
    manner, without any spaces between them as is the case in bar charts. This is
    a visual cue, to indicate the connected nature of histograms. The bins are arbitrary
    separation points that separate a group of observations from one another. As we
    saw, those can be selected differently, and result in quite different shapes.
    Bar charts are typically used for discrete or categorical variables and are typically
    displayed with some space between them to express this fact.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other ways of displaying multiple bars in histograms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two previous histograms displayed the sub-bars in each bin stacked on top
    of one another. This makes sense, as those sub-bars represent a grouping of the
    data under the respective bin. In other words, they show the distribution of groups
    of countries for each bin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some other cases, we might want to do the same thing but for two different
    years. In this case, having the bars stacked might give the false impression that
    the sub-bars correspond to portions of the same bin, whereas they correspond to
    the same bin but for different years. An example can show this more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subset of `poverty` that contains only countries and the range of
    years is `[2010, 2015]`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `histogram` function for the Gini index, coloring by `year` and setting
    `barmode=''group''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.7 – A histogram of the Gini indicator colored by year, with barmode
    set to "group"](img/B16780_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – A histogram of the Gini indicator colored by year, with barmode
    set to "group"
  prefs: []
  type: TYPE_NORMAL
- en: Because years represent a "before and after" view of the same metric and the
    same bin, I think it makes more sense to display them next to each other, so we
    can see how each bin value increased or decreased for the two, or more, selected
    years.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another approach to the same issue if we are more interested in highlighting
    the change in the distribution as a whole. We can run the same function we just
    ran, but use facets in addition to color to split the histogram in two. The code
    is also straightforward and contains one more argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – A histogram of the Gini indicator colored and split by year](img/B16780_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – A histogram of the Gini indicator colored and split by year
  prefs: []
  type: TYPE_NORMAL
- en: Again, the last two charts display the same information in two different ways.
    In *Figure 8.7*, it's very easy to compare how the count of countries for each
    bin changed from year to year. But it's a bit more difficult to see how the *distributions*
    have changed between the first and second years. The opposite is true for *Figure
    8.8*. Note that we could also use `facet_row` as well, and this would have displayed
    the charts on top of one another. But we chose to display them next to each other
    because we are interested in comparing the heights of the bars, and it's much
    easier to do so when they are next to each other. Had we set `orientation='h'`
    (for horizontal), then it would have been easier to use `facet_row` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we might be more interested in the percentage of the number of values
    in a certain bin, as opposed to the absolute count for each bin. Getting this
    is also very simple. We just need to set `histnorm=''percent''`. We start by creating
    a `fig` object and add the new option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also make it more explicit that we are displaying percentages by adding
    a tick suffix to the *y*-axis ticks. This can be achieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also want to set a more descriptive title for the *y* axis, which
    can also be easily achieved using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this modified code produces the chart in *Figure 8.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – A histogram of the Gini indicator colored and split by year,
    showing percentages](img/B16780_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – A histogram of the Gini indicator colored and split by year, showing
    percentages
  prefs: []
  type: TYPE_NORMAL
- en: This chart looks identical to the one in *Figure 8.8*. The main difference is
    that the height of the bars represents the percentage and not the absolute count.
    This was also made clearer with tick suffixes and a *y*-axis title.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored quite a few options with histograms. Let's now make our histograms
    interactive and add a few other options.
  prefs: []
  type: TYPE_NORMAL
- en: Adding interactivity to histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like we did in [*Chapter 7*](B16780_07_Final_NM_ePub.xhtml#_idTextAnchor106),
    *Exploring Map Plots and Enriching Your Dashboards with Markdown*, we can do the
    same with histograms. We can allow users to get a better idea about the distribution
    of a certain indicator in a certain year or more. The difference is that we want
    to allow them to customize the number of bins. Since we are now comfortable with
    handling multiple inputs and outputs, let''s also add some more options for our
    users. We can also allow users to select multiple years and display multiple years
    on multiple sub-plots using faceting. *Figure 8.10* shows what we will be working
    toward to make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – A histogram app allowing the selection of indicator, year(s),
    and bins](img/B16780_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – A histogram app allowing the selection of indicator, year(s),
    and bins
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building right away. We won''t be discussing the layout elements
    such as color and width, but you can always refer to the code repository for the
    exact solution. We will focus on building the interactivity for this. Later on,
    we will add it to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `app` object and its `layout` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `Label` and `Dropdown` components as the first elements to the div just
    created. The `Dropdown` component displays the available indicators, and is the
    exact same one we created in [*Chapter 7*](B16780_07_Final_NM_ePub.xhtml#_idTextAnchor106),
    *Exploring Map Plots and Enriching Your Dashboards with Markdown*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `dbc.Label` and a `dcc.Dropdown` component to the list in the div for
    indicating that the user can select a year and the actual years to be selected,
    allowing multiple selections. Note that since this dropdown allows multiple selection,
    its default value, if provided, needs to be provided as a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, to the same list in the div, we add another `dbc.Label` component and
    a `dcc.Slider` component that will allow users to modify the number of bins in
    the resulting histogram(s). Note that by not setting a default value, Plotly will
    provide the default number of bins based on the data being analyzed. It would
    show as **0** in the slider. Users are then free to modify it if they wish to
    do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add a `Graph` component, and this will complete our layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running these steps creates our app''s visible part (the layout) without any
    functionality. The default looks as in *Figure 8.11*, and I''ll leave it to you
    to modify the colors, alignment, and relative positioning, using the knowledge
    we built in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview
    of the Dash Ecosystem*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The default view of the histogram app with no functionality](img/B16780_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – The default view of the histogram app with no functionality
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now go on to build the interactivity. In this case, we need to build
    a function that takes three inputs (the indicator dropdown, the years dropdown,
    and the bins slider). It will return a `Figure` object, which will modify the
    chart at the bottom of the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the callback. There is nothing special here; we just make sure to have
    the IDs show that they are related to the histogram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the function that generates our histogram using the inputs just created.
    We first check that neither `year` nor `indicator` is provided, in which case
    we `raise PreventUpdate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a sub-set, `df`, by selecting countries only, as well as getting rows
    where the year is in the provided `years` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to create the figure, which is done by calling the `histogram`
    function. As we saw in this chapter, we provide `df` to the `data_frame` parameter,
    `indicator` for the `x` parameter, and `year` to `color`. The title of the figure
    will be set by concatenating the indicator with the `Histogram` string. The `nbins`
    parameter will take the `nbins` value selected by the user from the slider. For
    facets, we use the `year` column. Since we don''t know how many years users will
    select, and we don''t want them to end up creating a difficult-to-read chart,
    we set `facet_col_wrap=4`. This will ensure that each row of charts will contain
    no more than four, and the following one will be added to the next row of charts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A new and interesting option that we haven''t covered so far is the `for_each_xaxis`
    attribute. Note that this is only one of several `for_each_` attributes, which
    you can explore separately. This is useful in situations where the number of *x*-axis
    attributes is not known, such as in this case, or simply when multiple attributes
    exist. By default, every facet (or sub-plot) will have its own *x*-axis title.
    As you know, there are many indicator names that are very long and will overlap
    in this case. To eliminate this, we set all `xaxis` titles to an empty string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To replace the deleted *x*-axis titles, we can create an annotation instead.
    The annotation is a simple string that can easily be added with the `add_annotation`
    method. Because we want the `X` position of the annotation to be at the center
    of the figure, we set its `x` value to `0.5`. Also, because we want the `Y` position
    to be slightly below the plot area, we set the `y` value to `-0.12`. Now, it''s
    important to indicate to Plotly the meaning of those numbers we provide, or their
    reference. We can use the `xref` and `yref` parameters to indicate that these
    values should take `paper` as their reference. This means to take these points
    as fractions of the plot and not as data points, like in scatter plots, for example.
    This is useful because those annotations will serve as axis titles, and so we
    want their position to be fixed. By default, annotations come with arrows pointing
    to the point selected. We can remove that by setting `showarrow=False`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the full code of the function to make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have created an independent app that can run in JupyterLab. I
    encourage you to fully run it and see whether you come across issues, and to also
    customize and make some changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored how to visualize the counts and distributions of values
    for a single set of observations. There is also an interesting way to explore
    two sets of observations at the same time, which can be done using a 2D histogram.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 2D histogram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first case, we basically counted the observations in each bin of our
    dataset. In this case, we will do the same but for *combinations* of bins for
    both datasets. The bins for each variable will end up creating a matrix. A simple
    example can make this easy. Let''s create one and see:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subset of `poverty` containing only countries, where the year is equal
    to `2000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Figure` object and add a `histogram2d` trace (at the time of writing,
    this chart type is not available in Plotly Express). We simply select any two
    indicators that we would like to plot together and pass them to `x` and `y`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add titles for the *x* and *y* axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code generates the chart in *Figure 8.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – A 2D histogram](img/B16780_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – A 2D histogram
  prefs: []
  type: TYPE_NORMAL
- en: The frequency of values is expressed in a different way here. With a 1D histogram,
    the height of the bars represents the frequency of values in the respective bin.
    In a 2D histogram, the "height" is expressed using a continuous color scale. We
    can see from the color bar that the counts range from 0 to 10, and that the bin
    combination with the most values is the **x** interval (**22, 22.9**) and the
    **y** interval (**30, 39.9**), with a **z** value (height) of **10**. Generally,
    *z* is used to refer to the third dimension, and so this can also be thought of
    as the height of this rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is different from using a scatter plot for two variables. In
    that case, we would be interested in seeing a correlation between the two variables,
    or at least how they both vary. In this case, we are trying to identify where
    the most frequent observations are, across two variables, and under which combination
    of bins.
  prefs: []
  type: TYPE_NORMAL
- en: There are still many options that you can explore with histograms, or visualizing
    distributions and counts in general. We have explored many of those options, and
    now we'll turn to explore another interactive component that is available in Dash,
    the DataTable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DataTable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, `dash_table` is a separate package, as mentioned at the beginning
    of the chapter, and can be installed separately. It is installed automatically
    with Dash, the correct, up-to-date version, which is the recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, displaying tables, especially if they are interactive, can add a
    lot of value to users of our dashboards. Also, if our dashboards or data visualizations
    are not sufficient for users, or if they want to run their own analysis, it is
    probably a good idea to allow them to get the raw data for that. Finally, the
    `DataTable` component allows its own data visualization through custom coloring,
    fonts, sizes, and so on. So, we have another way to visualize and understand our
    data through tables. We will explore a few options in this chapter, but definitely
    not all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can create a simple DataTable in a simple app using a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subset of `poverty` containing only countries, from the year 2000,
    and containing columns that have `Country Name` or have the income share of the
    top and bottom 10% of the population. We use the `filter` method with a regular
    expression to achieve that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an app in JupyterLab with a `layout` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass a `DataTable` object to the div just created. As a minimum, a table requires
    values for the `data` parameter, as well as the `columns` parameter. One of the
    easiest ways to do this is by providing a dictionary converted from a DataFrame,
    using the `to_dict(''records'')` method. `columns` needs to be a list of dictionaries,
    where each dictionary contains the `name` and `id` keys. The name is what appears
    to users, and the ID is the value that will actually be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this simple app with `app.run_server()` produces a table as you can
    see in *Figure 8.13*, showing the first few rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – A simple DataTable](img/B16780_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – A simple DataTable
  prefs: []
  type: TYPE_NORMAL
- en: Many times, your tables or column headers might not fit neatly in the container
    they are placed in. For example, in our case, many indicator names are extremely
    long, and their columns contain numbers that don't take much horizontal space.
    Let's explore some of the available options to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the look and feel of the table (cell width, height, text display,
    and more)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous options available to modify how your tables look, and it's
    always good to consult the documentation for ideas and solutions. The potentially
    tricky part is when you have combinations of options. In some cases, these might
    modify each other and not be displayed exactly the way you want. So, it is always
    good to isolate the options as much as possible when debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 8.13*, we displayed only three columns and the first few rows. We
    will now see how to display more columns and enable users to explore more rows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `df` to include all columns that contain `Income share`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Place the DataTable in a `dbc.Col` component with the desired width, `7` in
    this case. The table automatically takes the width of the container it is in,
    so this would set its width implicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now want to determine how the column headers will behave, especially as
    they have quite long names. This can be achieved with the `style_header` parameter.
    Note that there are several `style_` parameters for headers, cells, and tables,
    and they also have `_conditional` variants, for example, `style_cell_conditional`,
    to conditionally set the style of cells. We now specify the header style with
    the following option, to allow text to overflow into multiple lines when/if needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now want to make sure that while scrolling, the headers remain fixed in
    place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to control the height of the table as a whole, we can simply do so
    with the following parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In cases where we have thousands of rows, it might be heavy and affect the
    performance of the page, so we can use `virtualization`. In our case, it is a
    very small table, but we can set `virtualization` to demonstrate its usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Putting the code together, here is the full code to generate the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this modified code produces the table in *Figure 8.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – A DataTable with custom options for width, height, scrolling,
    and virtualization](img/B16780_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – A DataTable with custom options for width, height, scrolling,
    and virtualization
  prefs: []
  type: TYPE_NORMAL
- en: The scroll bar is only visible if the cursor is pointing there. It was kept
    for demonstration, and to make it clear that scrolling is enabled. Now users can
    see all the available rows by scrolling as much as they want. We will now see
    how to incorporate some interactivity with tables and add this to our app. We'll
    also use this as an opportunity to demonstrate a few other options available to
    the DataTable component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding histograms and tables to the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now ready to incorporate the table functionality into our app and add
    it to the callback function that we already created. What we will do is display
    the data that is used to generate the histograms right under the histogram figure.
    Since the histograms don't show data points as we discussed (only aggregates),
    it might be interesting for users to see for themselves if they wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this functionality right away:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new div right underneath the histogram figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this as an `Output` to the callback function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right after we finish the definition of our `Figure` object, we add the definition
    of our DataTable. We will be using the same options as before and adding a few
    new ones. We first add the ability to sort columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we add the ability to filter columns. This will add an empty box right
    under each column header. Users can enter text and hit *Enter* to get a filtered
    table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the ability to export the table to CSV format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set a minimum width for cells to keep it consistent and avoid any formatting
    issues due to different columns'' headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the table to the `return` statement at the end of the function,
    so it returns two items instead of one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a result of adding this functionality, our updated app will contain the
    table that is being used to generate the histograms, and users can export it or
    interact with it if they want. *Figure 8.15* shows our app with the additional
    customized DataTable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – A DataTable showing the data used to generate the histograms](img/B16780_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – A DataTable showing the data used to generate the histograms
  prefs: []
  type: TYPE_NORMAL
- en: We now have an **Export** button, which is clear and immediately triggers the
    download functionality in the browser. Header names now have arrows that allow
    users to sort, in an ascending or descending manner. You can also see the filtering
    option, with the **filter data…** placeholder text, which users can filter by.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to incorporate this functionality into our app, we simply have
    to copy the components where we want them to appear. As this can be thought of
    as exploratory functionality (users are still not digging deep into an indicator),
    it's probably good to have it under the map chart.
  prefs: []
  type: TYPE_NORMAL
- en: To add the interactivity, we only have to add the callback function that we
    created, as we always do, after the layout of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We have already done this many times, and it should be straightforward for you
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Our app is now getting really rich. We have two main exploratory interactive
    charts at the top. The maps allow users to select a metric and see its variation
    across countries on the map. They can also select the year and/or allow it to
    play like a video. The selected indicator triggers the display of descriptive
    text about it, for more context to users. Under that, we have the option of selecting
    an indicator and one or more years, to see how this indicator is distributed with
    histograms. Users can modify the number of bins to get an optimal view. This also
    updates the table they can interact with and export.
  prefs: []
  type: TYPE_NORMAL
- en: After having explored the indicators of interest, users can go on to explore
    specific indicators using the three specialized charts that we created.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We have now completed *Part 2* of the book, so it's good to
    review what we have done in the chapter, as well as *Part 2*, and get ready for
    *Part 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first learned about the main difference between histograms
    and the other types of charts we have covered so far. We saw how easy it is to
    create them, and more importantly, we saw how customizable they can be with bins,
    `barmode`, colors, and facets. We then explored how to add interactivity to histograms
    by connecting them to other components with a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored the 2D histogram and saw how it can provide an even richer
    view of two columns visualized against each other.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced a new interactive component, the DataTable. We barely scratched
    the surface of what can be done with tables. We used them to make it easier for
    users to obtain, interact with, or simply view the raw data behind our histograms.
    We also explored the different ways to control the look and feel of our tables.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we incorporated the table functionality with the callback function
    we created and added the interactivity to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a quick look at what we have covered so far in the book and prepare
    for *Part 3*.
  prefs: []
  type: TYPE_NORMAL
- en: What we have covered so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of the book, we covered the basics of Dash apps. We first
    explored how they are structured and how to manage the visual elements. Then,
    we explored how interactivity is created, which is mainly by using callback functions.
    This allowed us to create fully interactive apps. We then explored the structure
    of the `Figure` object and learned how to modify and manipulate it to generate
    the charts we desire. After that, we saw how important data manipulation and preparation
    are for data visualization. We went through a reshaping of our dataset, to make
    things more intuitive to work with. This paved the way for easily learning and
    using Plotly Express.
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 2* was about getting thoroughly familiar with several types of charts,
    as well as interactive components. We implemented all the knowledge we built in
    *Part 1*, but most importantly, we did this in a practical setting. We gradually
    added more and more charts, components, and functionality to one app. At every
    step, we had to consider how it will affect the whole app and had to make sure
    we did so with a holistic view. You are now very familiar with making changes
    to many types of functionality. Although we didn''t cover every type of chart
    and component, the general principles are similar, and you can easily adapt the
    knowledge you have to new situations.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 3* will move on to more general topics about apps, URLs, advanced callbacks,
    and deployment. But the next chapter will explore a few **machine learning** options.
    Our dataset contains many countries, years, and indicators, and the number of
    possible combinations to explore is massive. So, we will explore a few techniques
    that can help uncover trends or correlations in our data.'
  prefs: []
  type: TYPE_NORMAL
