- en: Chapter 14. Graphs, Geometry, and Geographic Information Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating and visualizing graphs with NetworkX
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing a social network with NetworkX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving dependencies in a Directed Acyclic Graph with a topological sort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing connected components in an image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the Voronoi diagram of a set of points
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating geospatial data with Shapely and basemap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a route planner for a road network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover Python's capabilities in graph theory, geometry,
    and geography.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphs** are mathematical objects describing relations between items. They
    are ubiquitous in science and engineering, as they can represent many kinds of
    real-world relations: friends in a social network, atoms in a molecule, website
    links, cells in a neural network, neighboring pixels in an image, and so on. Graphs
    are also classical data structures in computer science. Finally, many domain-specific
    problems may be re-expressed as graph problems, and then solved with well-known
    algorithms.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We will also see a few recipes related to **geometry** and **Geographic Information
    Systems** (**GIS**), which refers to the processing and analysis of any kind of
    spatial, geographical, or topographical data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In this introduction, we will give a brief overview of these topics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Graphs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematically, a **graph** *G = (V, E)* is defined by a set *V* of **vertices**
    or **nodes**, and a set *E* of **edges** (two-element subsets of V). Two nodes
    *v* and *v*' are said to be **connected** if *(v, v')* is an edge (element of
    *E*).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: If the edges are *unordered* (meaning that *(v,v') = (v',v)*), the graph is
    said to be **undirected**
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the edges are *ordered* (meaning that *(v,v')* ≠ *(v',v)*), the graph is
    said to be **directed**
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An edge in an undirected graph is represented by a line segment between the
    two nodes. In a directed graph, it is represented by an arrow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphs](img/4818OS_14_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Undirected and directed graphs
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: A graph can be represented by different data structures, notably an **adjacency
    list** (for each vertex, a list of adjacent vertices) or an **adjacency matrix**
    (matrix of connections between vertices).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Problems in graph theory
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are a few examples of classical graph problems:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph traversal**: How to walk through a graph, discussed at [http://en.wikipedia.org/wiki/Graph_traversal](http://en.wikipedia.org/wiki/Graph_traversal)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph coloring**: How to color nodes in a graph such that no two adjacent
    vertices share the same color, discussed at [http://en.wikipedia.org/wiki/Graph_coloring](http://en.wikipedia.org/wiki/Graph_coloring)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connected components**: How to find connected components in a graph, explained
    at [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shortest paths**: What is the shortest path from one node to another in a
    given graph?, discussed at [http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hamiltonian paths**: Does a graph include a Hamiltonian path, visiting every
    vertex exactly once?, explained at [http://en.wikipedia.org/wiki/Hamiltonian_path](http://en.wikipedia.org/wiki/Hamiltonian_path)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eulerian paths**: Does a graph include an Eulerian path, visiting every *edge*
    exactly once?, discussed at [http://en.wikipedia.org/wiki/Eulerian_path](http://en.wikipedia.org/wiki/Eulerian_path)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traveling Salesman Problem**: What is the shortest route visiting every node
    exactly once (Hamiltonian path)?, explained at [http://en.wikipedia.org/wiki/Traveling_salesman_problem](http://en.wikipedia.org/wiki/Traveling_salesman_problem)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random graphs
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Random graphs** are particular kinds of graphs defined with probabilistic
    rules. They are useful for understanding the structure of large real-world graphs
    such as social graphs.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In particular, **small-world networks** have sparse connections, but most nodes
    can be reached from every other node in a small number of steps. This property
    is due to the existence of a small number of **hubs** that have a high number
    of connections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Graphs in Python
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although graphs can be manipulated with native Python structures, it is more
    convenient to use a dedicated library implementing specific data structures and
    manipulation routines. In this chapter, we will use **NetworkX**, a pure Python
    library. Alternative Python libraries include **python-graph** and **graph-tool**
    (largely written in C++).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX implements a flexible data structure for graphs, and it contains many
    algorithms. NetworkX also lets us draw graphs easily with matplotlib.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Geometry in Python
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Shapely** is a Python library used to manipulate 2D geometrical shapes such
    as points, lines, and polygons. It is most notably useful in Geographic Information
    Systems.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: It is not straightforward to combine Shapely with matplotlib. Fortunately, the
    **descartes** package makes this task much easier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Geographical Information Systems in Python
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several Python modules used to manipulate geographical data and plotting
    maps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use matplotlib's basemap, Shapely, descartes, and Fiona
    to handle GIS files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The ESRI **shapefile** is a popular geospatial vector data format. It can be
    read by basemap, NetworkX, and Fiona.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the **OpenStreetMap** service, a free, open source, collaborative
    service providing maps of the world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Other GIS/mapping systems in Python that we couldn't cover in this chapter include
    **GeoPandas**, **Kartograph**, **Vincent**, and **cartopy**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references about graphs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Graph theory on Wikipedia, available at [http://en.wikipedia.org/wiki/Graph_theory](http://en.wikipedia.org/wiki/Graph_theory)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures for graphs, described at [http://en.wikipedia.org/wiki/Graph_(abstract_data_type)](http://en.wikipedia.org/wiki/Graph_(abstract_data_type))
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述图的数据结构，请参考[http://en.wikipedia.org/wiki/Graph_(abstract_data_type)](http://en.wikipedia.org/wiki/Graph_(abstract_data_type))
- en: Random graphs on Wikipedia, available at [http://en.wikipedia.org/wiki/Random_graph](http://en.wikipedia.org/wiki/Random_graph)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在维基百科上查看随机图的页面，网址为[http://en.wikipedia.org/wiki/Random_graph](http://en.wikipedia.org/wiki/Random_graph)
- en: Small-world graphs on Wikipedia, available at [http://en.wikipedia.org/wiki/Small-world_network](http://en.wikipedia.org/wiki/Small-world_network)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可在维基百科上查看小世界图的页面，网址为[http://en.wikipedia.org/wiki/Small-world_network](http://en.wikipedia.org/wiki/Small-world_network)
- en: NetworkX package, available at [http://networkx.github.io](http://networkx.github.io)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetworkX 软件包的网址为[http://networkx.github.io](http://networkx.github.io)
- en: The python-graph package, available at [https://code.google.com/p/python-graph/](https://code.google.com/p/python-graph/)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: python-graph 软件包的网址为[https://code.google.com/p/python-graph/](https://code.google.com/p/python-graph/)
- en: The graph-tool package, available at [http://graph-tool.skewed.de](http://graph-tool.skewed.de)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[http://graph-tool.skewed.de](http://graph-tool.skewed.de)获取 graph-tool 软件包。
- en: 'Here are a few references about geometry and maps in Python:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于 Python 中几何和地图的一些参考资料：
- en: Basemap at [http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Basemap 的网址为[http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
- en: Shapely at [http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shapely 的网址为[http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
- en: Fiona at [http://toblerity.org/fiona/](http://toblerity.org/fiona/)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fiona 的网址为[http://toblerity.org/fiona/](http://toblerity.org/fiona/)
- en: descartes at [https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: descartes 的网址为[https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
- en: Shapefile at [http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shapefile 的网址为[http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile)
- en: OpenStreetMap at [www.openstreetmap.org](http://www.openstreetmap.org)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStreetMap 的网址为[www.openstreetmap.org](http://www.openstreetmap.org)
- en: Folium at [https://github.com/wrobstory/folium](https://github.com/wrobstory/folium)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Folium 的网址为[https://github.com/wrobstory/folium](https://github.com/wrobstory/folium)
- en: GeoPandas at [http://geopandas.org](http://geopandas.org)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeoPandas 的网址为[http://geopandas.org](http://geopandas.org)
- en: Kartograph at [http://kartograph.org](http://kartograph.org)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kartograph 的网址为[http://kartograph.org](http://kartograph.org)
- en: Cartopy at [http://scitools.org.uk/cartopy/](http://scitools.org.uk/cartopy/)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cartopy 的网址为[http://scitools.org.uk/cartopy/](http://scitools.org.uk/cartopy/)
- en: Vincent at [https://github.com/wrobstory/vincent](https://github.com/wrobstory/vincent)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vincent 的网址为[https://github.com/wrobstory/vincent](https://github.com/wrobstory/vincent)
- en: Manipulating and visualizing graphs with NetworkX
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NetworkX 操作和可视化图形
- en: In this recipe, we will show how to create, manipulate, and visualize graphs
    with NetworkX.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何使用 NetworkX 创建、操作和可视化图形。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can find the installation instructions for NetworkX in the official documentation
    at [http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到 NetworkX 的安装说明，网址为[http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html)。
- en: With Anaconda, you can type `conda install networkx` in a terminal. Alternatively,
    you can type `pip install networkx`. On Windows, you can also use Chris Gohlke's
    installer, available at [www.lfd.uci.edu/~gohlke/pythonlibs/#networkx](http://www.lfd.uci.edu/~gohlke/pythonlibs/#networkx).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Anaconda，您可以在终端中输入`conda install networkx`。或者，您也可以输入`pip install networkx`。在
    Windows 上，您还可以使用 Chris Gohlke 的安装程序，网址为[www.lfd.uci.edu/~gohlke/pythonlibs/#networkx](http://www.lfd.uci.edu/~gohlke/pythonlibs/#networkx)。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s import NumPy, NetworkX, and matplotlib:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入 NumPy、NetworkX 和 matplotlib：
- en: '[PRE0]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are many different ways of creating a graph. Here, we create a list of
    edges (pairs of node indices):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图形的方法有很多种。在这里，我们创建了一个边的列表（节点索引的对）：
- en: '[PRE1]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We instantiate a `Graph` object with our list of edges:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用边的列表实例化一个`Graph`对象：
- en: '[PRE2]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s check the list of nodes and edges of the graph, and its adjacency matrix:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查图的节点和边的列表，以及其邻接矩阵：
- en: '[PRE3]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s display this graph. NetworkX comes with a variety of drawing functions.
    We can either specify the nodes'' positions explicitly, or we can use an algorithm
    to automatically compute an interesting layout. Here, we use the `draw_circular()`
    function that simply positions nodes linearly on a circle:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示这个图。NetworkX 自带各种绘图函数。我们可以明确指定节点的位置，也可以使用算法自动计算一个有趣的布局。在这里，我们使用了`draw_circular()`函数，它会将节点线性地放置在一个圆上：
- en: '[PRE4]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it…](img/4818OS_14_02.jpg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/4818OS_14_02.jpg)'
- en: Graphs can be modified easily. Here, we add a new node connected to all existing
    nodes. We also specify a `color` attribute to this node. In NetworkX, every node
    and edge comes with a convenient Python dictionary containing arbitrary attributes.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图可以很容易地修改。在这里，我们添加一个连接到所有现有节点的新节点。我们还为此节点指定了一个`color`属性。在NetworkX中，每个节点和边都带有一个方便的Python字典，包含任意属性。
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s draw the modified graph again. This time, we specify the nodes''
    positions and colors explicitly:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次绘制修改后的图。这次，我们明确指定节点的位置和颜色：
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How to do it…](img/4818OS_14_03.jpg)'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作方法…](img/4818OS_14_03.jpg)'
- en: 'Let''s also use an automatic layout algorithm:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也使用自动布局算法：
- en: '[PRE7]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![How to do it…](img/4818OS_14_04.jpg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作方法…](img/4818OS_14_04.jpg)'
- en: There's more…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In NetworkX, nodes are not necessarily integers. They can be numbers, strings,
    tuples, and instances of any hashable Python class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetworkX中，节点不一定是整数。它们可以是数字、字符串、元组和任何可哈希的Python类的实例。
- en: In addition, every node and edge comes with optional attributes (which form
    a dictionary).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个节点和边都带有可选属性（形成一个字典）。
- en: A few layout algorithms are implemented in NetworkX. The `draw_spectral()` function
    uses the eigenvectors of the graph's **Laplacian matrix**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetworkX中实现了一些布局算法。`draw_spectral()`函数使用图的**拉普拉斯矩阵**的特征向量。
- en: The `draw_spring()` function implements the **Fruchterman-Reingold force-directed**
    algorithm. Nodes are considered as masses subject to edge-dependent forces. A
    force-directed graph drawing algorithm minimizes the system's energy so as to
    find an equilibrium configuration. This results in an aesthetically appealing
    layout with as few crossing edges as possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_spring()`函数实现了**Fruchterman-Reingold力导向**算法。节点被视为受边缘相关力的质点。力导向图绘制算法通过最小化系统的能量来找到平衡配置。这将导致一个美观的布局，尽可能少地交叉边。'
- en: 'Here are a few references:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Graph drawing, described at [http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图绘制，在[http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)有描述
- en: Laplacian matrix on Wikipedia, available at [http://en.wikipedia.org/wiki/Laplacian_matrix](http://en.wikipedia.org/wiki/Laplacian_matrix)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的拉普拉斯矩阵，网址为[http://en.wikipedia.org/wiki/Laplacian_matrix](http://en.wikipedia.org/wiki/Laplacian_matrix)
- en: Force-directed graph drawing, described at [http://en.wikipedia.org/wiki/Force-directed_graph_drawing](http://en.wikipedia.org/wiki/Force-directed_graph_drawing)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述在[http://en.wikipedia.org/wiki/Force-directed_graph_drawing](http://en.wikipedia.org/wiki/Force-directed_graph_drawing)的力导向图绘制
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Analyzing a social network with NetworkX* recipe
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用NetworkX分析社交网络*配方'
- en: Analyzing a social network with NetworkX
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NetworkX分析社交网络
- en: In this recipe, we will show how to analyze social data in Python. Social data
    is generated by people's activity on social networks such as Facebook, Twitter,
    Google+, GitHub, and others.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何在Python中分析社交数据。社交数据是由人们在社交网络上的活动生成的，如Facebook、Twitter、Google+、GitHub等。
- en: In this recipe, we will analyze and visualize a Twitter user's social network
    with NetworkX.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用NetworkX分析和可视化Twitter用户的社交网络。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, you need to install the **Twitter** Python package. You can install it
    with `pip install twitter`. You'll find more information at [https://pypi.python.org/pypi/twitter](https://pypi.python.org/pypi/twitter).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装**Twitter** Python包。您可以使用`pip install twitter`进行安装。您可以在[https://pypi.python.org/pypi/twitter](https://pypi.python.org/pypi/twitter)找到更多信息。
- en: Then, you need to obtain authentication codes in order to access your Twitter
    data. The procedure is free. In addition to a Twitter account, you also need to
    create an *Application* on the Twitter Developers website at [https://dev.twitter.com/apps](https://dev.twitter.com/apps).
    Then, you will be able to retrieve the **OAuth authentication codes** that are
    required for this recipe.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要获取认证代码以访问您的Twitter数据。该过程是免费的。除了Twitter账号外，您还需要在Twitter开发者网站上创建一个*应用程序*，网址为[https://dev.twitter.com/apps](https://dev.twitter.com/apps)。然后，您将能够检索到此配方所需的**OAuth认证代码**。
- en: 'You need to create a `twitter.txt` text file in the current folder with the
    four private authentication keys. There must be one key per line, in the following
    order:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在当前文件夹中创建一个`twitter.txt`文本文件，其中包含四个私有认证密钥。每行必须有一个密钥，顺序如下：
- en: API key
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API密钥
- en: API secret
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API秘钥
- en: Access token
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌
- en: Access token secret
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌密钥
- en: Note that access to the Twitter API is limited. Most methods can only be called
    a few times within a given time window. Unless you study small networks or look
    at small portions of large networks, you will need to *throttle* your requests.
    In this recipe, we only consider a small portion of the network, so that the API
    limit should not be reached. Otherwise, you will have to wait a few minutes before
    the next time window starts. The API limits are available at [https://dev.twitter.com/docs/rate-limiting/1.1/limits](https://dev.twitter.com/docs/rate-limiting/1.1/limits).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import a few packages:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We get the secret consumer and OAuth keys from our `twitter.txt` file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now create an instance of the `Twitter` class that will give us access to
    the Twitter API:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use the 1.1 version of the Twitter API in this recipe. The `twitter` library
    defines a direct mapping between the REST API and the attributes of the `Twitter`
    instance. Here, we execute the `account/verify_credentials` REST request to obtain
    the identifier of the authenticated user (me here, or you if you execute this
    notebook yourself!):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s define a simple function that returns the identifiers of all followers
    of a given user (the authenticated user by default):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we define a function that retrieves the full profile of Twitter users.
    As the `users/lookup` batch request is limited to 100 users per call, and only
    a small number of calls are allowed within a time window, we only look at a subset
    of all the followers:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also start to define the graph with the followers, using an adjacency list
    (technically, a dictionary of lists). This is called the **ego graph**. This graph
    represents all *following* connections between our followers:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we are going to take a look at the part of the ego graph related to Python.
    Specifically, we will consider the followers of the 10 most followed users whose
    descriptions contain "Python":'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The request for retrieving the followers of a given user is rate-limited. Let''s
    check how many remaining calls we have:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that our graph is defined as an adjacency list in a dictionary, we will
    load it in NetworkX:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at the graph''s statistics:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are now going to plot this graph. We will use different sizes and colors
    for the nodes, according to the number of followers and the number of tweets for
    each user. Most followed users will be bigger. Most active users will be redder.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we use the `draw()` function to display the graph. We need to specify
    the nodes'' sizes and colors as lists, and the labels as a dictionary:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it…](img/4818OS_14_05.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A great reference on social data analysis with Python is Matthew A. Russel''s
    book *Mining the Social Web*, *O''Reilly Media*. The code is available on GitHub
    as IPython notebooks at [https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition](https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition).
    The following networks are covered: Twitter, Facebook, LinkedIn, Google+, GitHub,
    mailboxes, websites, and others.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一本关于使用Python进行社交数据分析的重要参考资料是Matthew A. Russel的书籍*《Mining the Social Web》*，由*O'Reilly
    Media*出版。 代码可以在GitHub上的IPython笔记本中找到，网址为[https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition](https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition)。
    以下网络被涵盖：Twitter、Facebook、LinkedIn、Google+、GitHub、邮箱、网站等。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Manipulating and visualizing graphs with NetworkX* recipe
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用NetworkX操纵和可视化图形*示例'
- en: Resolving dependencies in a directed acyclic graph with a topological sort
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拓扑排序在有向无环图中解析依赖关系
- en: 'In this recipe, we will show an application of a well-known graph algorithm:
    **topological sorting**. Let''s consider a directed graph describing dependencies
    between items. For example, in a package manager, before we can install a given
    package *P*, we may need to install *dependent* packages.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示一个著名的图算法应用：**拓扑排序**。 让我们考虑描述项目之间依赖关系的有向图。 例如，在软件包管理器中，在安装给定软件包*P*之前，我们可能需要安装*依赖*软件包。
- en: The set of dependencies forms a directed graph. With topological sorting, the
    package manager can resolve the dependencies and find the right installation order
    of the packages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系集合形成一个有向图。 通过拓扑排序，软件包管理器可以解析依赖关系并找到软件包的正确安装顺序。
- en: Topological sorting has many other applications. Here, we will illustrate this
    notion on real data from the Debian package manager. We will find the installation
    order of the required packages for IPython.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序有许多其他应用。 在这里，我们将在Debian软件包管理器的真实数据上说明这个概念。 我们将找到IPython所需软件包的安装顺序。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need the `python-apt` package in order to build the package dependency graph.
    The package is available at [https://pypi.python.org/pypi/python-apt/](https://pypi.python.org/pypi/python-apt/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要`python-apt`软件包才能构建软件包依赖关系图。 该软件包可在[https://pypi.python.org/pypi/python-apt/](https://pypi.python.org/pypi/python-apt/)上找到。
- en: We also assume that this notebook is executed on a Debian system (such as Ubuntu).
    If you don't have such a system, you can download the *Debian* dataset directly
    from the book's GitHub repository at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
    Extract it in the current directory, and start directly from step 7 in this notebook.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设此笔记本在Debian系统（如Ubuntu）上执行。 如果您没有这样的系统，可以直接从书的GitHub存储库[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)下载*Debian*数据集。
    将其解压缩到当前目录，并直接从此笔记本的第7步开始。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We import the `apt` module and we build the list of packages:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`apt`模块并构建软件包列表：
- en: '[PRE21]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `graph` dictionary will contain the adjacency list of a small portion of
    the dependency graph:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`graph`字典将包含依赖关系图的一小部分的邻接表：'
- en: '[PRE22]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define a function that returns the list of dependencies of a package:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个返回软件包依赖关系列表的函数：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now define a *recursive* function that builds the dependency graph for a
    particular package. This function updates the `graph` variable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个*递归*函数，用于构建特定软件包的依赖关系图。 此函数更新`graph`变量：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s build the dependency graph for IPython:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为IPython构建依赖关系图：
- en: '[PRE25]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we save the adjacency list in JSON:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将邻接表保存为JSON：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Start here if you don't have a Debian operating system (you first need to download
    the *Debian* dataset from the book's repository).
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您没有Debian操作系统，请从书籍的存储库中下载*Debian*数据集。
- en: 'We import a few packages:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入一些包：
- en: '[PRE27]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s load the adjacency list from the JSON file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从JSON文件中加载邻接表：
- en: '[PRE28]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we create a directed graph (`DiGraph` in NetworkX) from our adjacency
    list. We reverse the graph to get a more natural ordering:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从邻接表创建一个有向图（NetworkX中的`DiGraph`）。 我们反转图以获得更自然的顺序：
- en: '[PRE29]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A topological sort only exists when the graph is a **directed acyclic graph**
    (**DAG**). This means that there is no cycle in the graph, that is, no circular
    dependency. Is our graph a DAG? Let''s see:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图形是**有向无环图**（**DAG**）时才存在拓扑排序。 这意味着图中没有循环，也就是说，没有循环依赖。 我们的图是DAG吗？ 让我们看看：
- en: '[PRE30]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What are the packages responsible for the cycles? We can find them with the
    `simple_cycles()` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些软件包负责循环？ 我们可以使用`simple_cycles()`函数找到它们：
- en: '[PRE31]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we can try to remove these packages. In an actual package manager, these
    cycles need to be carefully taken into account.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以尝试移除这些包。在实际的包管理器中，这些循环需要仔细考虑。
- en: '[PRE32]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The graph is now a DAG. Let''s display it first:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，图是一个DAG。让我们先展示它：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it…](img/4818OS_14_06.jpg)'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_06.jpg)'
- en: 'Finally, we can perform the topological sort, thereby obtaining a linear installation
    order satisfying all dependencies:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以执行拓扑排序，从而获得一个满足所有依赖关系的线性安装顺序：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's more…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: Directed acyclic graphs are found in many applications. They can represent causal
    relations, influence diagrams, dependencies, and other concepts. For example,
    the version history of a distributed revision control system such as Git is described
    with a DAG.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有向无环图在许多应用中都有出现。它们可以表示因果关系、影响图、依赖关系以及其他概念。例如，像 Git 这样的分布式版本控制系统的版本历史就是用DAG来描述的。
- en: Topological sorting is useful in any scheduling task in general (project management
    and instruction scheduling).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑排序在一般的调度任务中非常有用（项目管理和指令调度）。
- en: 'Here are a few references:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Topological sorting on Wikipedia, available at [http://en.wikipedia.org/wiki/Topological_sorting](http://en.wikipedia.org/wiki/Topological_sorting)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的拓扑排序，链接：[http://en.wikipedia.org/wiki/Topological_sorting](http://en.wikipedia.org/wiki/Topological_sorting)
- en: Directed acyclic graphs, described at [http://en.wikipedia.org/wiki/Directed_acyclic_graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有向无环图，详见：[http://en.wikipedia.org/wiki/Directed_acyclic_graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
- en: Computing connected components in an image
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算图像中的连通分量
- en: In this recipe, we will show an application of graph theory in image processing.
    We will compute **connected components** in an image. This method will allow us
    to label contiguous regions of an image, similar to the *bucket* fill tool of
    paint programs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将展示图论在图像处理中的应用。我们将计算图像中的**连通分量**。这种方法将允许我们标记图像中的连续区域，类似于绘图程序中的*桶形填充*工具。
- en: Finding connected components is also useful in many puzzle video games such
    as Minesweeper, bubble shooters, and others. In these games, contiguous sets of
    items with the same color need to be automatically detected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 找到连通分量在许多益智类视频游戏中也很有用，如扫雷、泡泡龙等。在这些游戏中，需要自动检测同一颜色的连续物品集。
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s import the packages:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入这些包：
- en: '[PRE35]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a *10 x 10* image where each pixel can take one of three possible
    labels (or colors):'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个*10 x 10*的图像，每个像素可以取三个可能的标签（或颜色）之一：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we create the underlying 2D grid graph encoding the structure of the image.
    Each node is a pixel, and a node is connected to its nearest neighbors. NetworkX
    defines a `grid_2d_graph` function to generate this graph:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个底层的二维网格图，编码图像的结构。每个节点是一个像素，且一个节点与其最近的邻居相连。NetworkX 定义了一个`grid_2d_graph`函数来生成这个图：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s create two functions to display the image and the corresponding graph:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建两个函数来显示图像和相应的图形：
- en: '[PRE38]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the original image superimposed with the underlying graph:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是原始图像与底层图叠加后的效果：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![How to do it…](img/4818OS_14_07.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_07.jpg)'
- en: 'Now, we are going to find all contiguous dark blue regions containing more
    than three pixels. First, we consider the *subgraph* corresponding to all dark
    blue pixels:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将找出所有包含超过三个像素的连续深蓝色区域。首先，我们考虑对应所有深蓝色像素的*子图*：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![How to do it…](img/4818OS_14_08.jpg)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_08.jpg)'
- en: 'We see that the requested contiguous regions correspond to the *connected components*
    containing more than three nodes in the subgraph. We can use the `connected_components`
    function of NetworkX to find those components:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到，所请求的连续区域对应于包含超过三个节点的*连通分量*。我们可以使用 NetworkX 的`connected_components`函数来找到这些分量：
- en: '[PRE41]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we assign a new color to each of these components, and we display
    the new image:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为每个分量分配一个新颜色，并显示新的图像：
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it…](img/4818OS_14_09.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/4818OS_14_09.jpg)'
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The problem we solved is called **connected-component labeling**. It is also
    closely related to the **flood-fill algorithm**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决的问题被称为**连通分量标记**。它也与**洪水填充算法**密切相关。
- en: The idea to associate a grid graph to an image is quite common in image processing.
    Here, contiguous color regions correspond to **connected components** of subgraphs.
    A connected component can be defined as an equivalence class of the **reachability**
    relation. Two nodes are connected in the graph if there is a path from one node
    to the other. An equivalence class contains nodes that can be reached from one
    another.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格图与图像关联的想法在图像处理领域非常常见。在这里，连续的颜色区域对应于**连通组件**的子图。一个连通组件可以定义为**可达性**关系的等价类。如果两个节点之间有一条路径，则它们在图中是连通的。一个等价类包含可以互相到达的节点。
- en: Finally, the simple approach described here is only adapted to basic tasks on
    small images. More advanced algorithms are covered in [Chapter 11](ch11.html "Chapter 11. Image
    and Audio Processing"), *Image and Audio Processing*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里描述的简单方法仅适用于小图像上的基本任务。更高级的算法将在[第11章](ch11.html "第11章. 图像与音频处理")，*图像与音频处理*中讲解。
- en: There's more…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Here are a few references:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些参考资料：
- en: Connected components on Wikipedia, available at [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的连通组件，访问[http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)
- en: Connected-component labeling on Wikipedia, at [http://en.wikipedia.org/wiki/Connected-component_labeling](http://en.wikipedia.org/wiki/Connected-component_labeling)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的连通组件标记算法，访问[http://en.wikipedia.org/wiki/Connected-component_labeling](http://en.wikipedia.org/wiki/Connected-component_labeling)
- en: Flood-fill algorithm on Wikipedia, available at [http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的Flood-fill算法，访问[http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)
- en: Computing the Voronoi diagram of a set of points
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算一组点的Voronoi图
- en: The **Voronoi diagram** of a set of *seed* points divides space into several
    regions. Each region contains all points closer to one seed point than to any
    other seed point.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一组*种子*点的**Voronoi图**将空间划分为多个区域。每个区域包含所有离某个种子点比任何其他种子点更近的点。
- en: The Voronoi diagram is a fundamental structure in computational geometry. It
    is widely used in computer science, robotics, geography, and other disciplines.
    For example, the Voronoi diagram of a set of metro stations gives us the closest
    station from any point in the city.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Voronoi图是计算几何中的基本结构。它广泛应用于计算机科学、机器人学、地理学和其他学科。例如，一组地铁站的Voronoi图可以告诉我们城市中任意一个点离哪个地铁站最近。
- en: In this recipe, we compute the Voronoi diagram of the set of metro stations
    in Paris using SciPy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用SciPy计算巴黎地铁站集的Voronoi图。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need the Smopy module to display the OpenStreetMap map of Paris. You can
    install this package with `pip install smopy`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要Smopy模块来显示巴黎的OpenStreetMap地图。你可以使用`pip install smopy`安装该包。
- en: You also need to download the *RATP* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)
    and extract it in the current directory. The data was obtained on RATP's open
    data website (Paris' public transport operator, [http://data.ratp.fr](http://data.ratp.fr)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从书籍的GitHub仓库下载*RATP*数据集，网址为[https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)，并将其解压到当前目录。数据来自RATP的开放数据网站（巴黎的公共交通运营商，[http://data.ratp.fr](http://data.ratp.fr)）。
- en: How to do it…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Let''s import NumPy, pandas, matplotlib, and SciPy:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入NumPy、pandas、matplotlib和SciPy：
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s load the dataset with pandas:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用pandas加载数据集：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `DataFrame` object contains the coordinates, name, city, district, and
    type of station. Let''s select all metro stations:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DataFrame`对象包含站点的坐标、名称、城市、区域和类型。让我们选择所有地铁站：'
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are going to extract the district number of Paris' stations. With pandas,
    we can use vectorized string operations using the `str` attribute of the corresponding
    column.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将提取巴黎各地铁站的区域编号。使用pandas时，我们可以通过相应列的`str`属性进行向量化的字符串操作。
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also extract the coordinates of all metro stations:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还提取所有地铁站的坐标：
- en: '[PRE47]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s retrieve Paris'' map with OpenStreetMap. We specify the map''s
    boundaries with the extreme latitude and longitude coordinates of all our metro
    stations. We use the lightweight Smopy module to generate the map:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用OpenStreetMap获取巴黎的地图。我们通过所有地铁站的极端纬度和经度坐标来指定地图的边界。我们使用轻量级的Smopy模块来生成地图：
- en: '[PRE48]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We now compute the Voronoi diagram of the stations using SciPy. A `Voronoi`
    object is created with the points coordinates. It contains several attributes
    we will use for display:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We create a generic function to display a Voronoi diagram. SciPy already implements
    such a function, but this function does not take infinite points into account.
    The implementation we will use has been obtained in Stack Overflow and is present
    at [http://stackoverflow.com/a/20678647/1595060](http://stackoverflow.com/a/20678647/1595060).
    This function is relatively long, and we won't copy it entirely here. The full
    version can be found in the book's GitHub repository.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `voronoi_finite_polygons_2d()` function returns a list of regions and a
    list of vertices. Every region is a list of vertex indices. The coordinates of
    all vertices are stored in `vertices`. From these structures, we can create a
    list of *cells*. Every cell represents a polygon as an array of vertex coordinates.
    We also use the `to_pixels()` method of the `smopy.Map` instance. This function
    converts latitude and longitude geographical coordinates to pixels in the image.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we compute the color of every polygon:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we display the map with the Voronoi diagram, using the `show_mpl()`
    method of the `Map` instance:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![How to do it…](img/4818OS_14_10.jpg)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s give the mathematical definition of the Voronoi diagram in a Euclidean
    space. If *(x[i])* is a set of points, the Voronoi diagram of this set of points
    is the collection of subsets *V[i]* (called **cells** or **regions**) defined
    by:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4818OS_14_11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: The dual graph of the Voronoi diagram is the **Delaunay triangulation**. This
    geometrical object covers the convex hull of the set of points with triangles.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: SciPy computes Voronoi diagrams with **Qhull**, a computational geometry library
    in C++.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are further references:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Voronoi diagram on Wikipedia, available at [http://en.wikipedia.org/wiki/Voronoi_diagram](http://en.wikipedia.org/wiki/Voronoi_diagram)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delaunay triangulation on Wikipedia, available at [http://en.wikipedia.org/wiki/Delaunay_triangulation](http://en.wikipedia.org/wiki/Delaunay_triangulation)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation of `scipy.spatial.voronoi` available at [http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html](http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qhull library available at [www.qhull.org](http://www.qhull.org)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Manipulating geospatial data with Shapely and basemap* recipe
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating geospatial data with Shapely and basemap
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to load and display geographical data in the
    Shapefile format. Specifically, we will use data from **Natural Earth** ([www.naturalearthdata.com](http://www.naturalearthdata.com))
    to display the countries of Africa, color coded with their population and **Gross
    Domestic Product** (**GDP**).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**Shapefile** ([http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile))
    is a popular geospatial vector data format for GIS software. It can be read by
    **Fiona**, a Python wrapper to **GDAL/OGR** (a C++ library supporting GIS file
    formats). We will also use **Shapely**, a Python package used to handle two-dimensional
    geometrical shapes, and **descartes**, used to render Shapely shapes in matplotlib.
    Finally, we will use **basemap** to plot maps.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need the following packages:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: GDAL/OGR available at [www.gdal.org/ogr/](http://www.gdal.org/ogr/)
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fiona available at [http://toblerity.org/fiona/README.html](http://toblerity.org/fiona/README.html)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapely available at [http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: descartes available at [https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basemap available at [http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With Anaconda, you can do:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Shapely and descartes can be installed with:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: On Windows, you can find binary installers for all of those packages except
    descartes on Chris Gohlke's webpage, [www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: On other systems, you can find installation instructions on the projects' websites.
    GDAL/OGR is a C++ library that is required by Fiona. The other packages are regular
    Python packages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to download the *Africa* dataset on the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
    The data was obtained on Natural Earth's website, [www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/](http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We load the *Shapefile* dataset with Fiona. This dataset notably contains the
    borders of all countries in the world.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We select the countries in Africa:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we create a basemap map showing the African continent:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s write a function converting the geographical coordinates of the countries''
    borders to map coordinates. This will allow us to display the borders in basemap:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next step is to create matplotlib `PatchCollection` objects from the *Shapefile*
    dataset loaded with Fiona. We use Shapely and descartes for this:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We also define a function to get countries'' colors depending on a specific
    field in the *Shapefile* dataset. Indeed, our dataset not only contains countries
    borders, but also a few administrative, economical, and geographical properties
    for each country. Here, we will choose the color according to the countries''
    population and GDP:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we display the maps. We display the coastlines with basemap, and the
    countries with our *Shapefile* dataset:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![How to do it…](img/4818OS_14_12.jpg)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: See also
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a route planner for a road network* recipe
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a route planner for a road network
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we build upon several techniques described in the previous recipes
    in order to create a simple GPS-like route planner in Python. We will retrieve
    California's road network data from the United States Census Bureau in order to
    find shortest paths in the road network graph. This allows us to display road
    itineraries between any two locations in California.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need NetworkX and Smopy for this recipe. In order for NetworkX to read Shapefile
    datasets, you also need GDAL/OGR. You can find more information in the previous
    recipe.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You also need to download the *Road* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data),
    and extract it in the current directory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of this writing, NetworkX's support of Shapefile doesn't seem to
    be compatible with Python 3.x. For this reason, this recipe has only been successfully
    tested with Python 2.x.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We load the data (a Shapefile dataset) with NetworkX. This dataset contains
    detailed information about the primary roads in California. NetworkX's `read_shp()`
    function returns a graph, where each node is a geographical position, and each
    edge contains information about the road linking the two nodes. The data comes
    from the United States Census Bureau website at [www.census.gov/geo/maps-data/data/tiger.html](http://www.census.gov/geo/maps-data/data/tiger.html).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This graph is not necessarily connected, but we need a connected graph in order
    to compute shortest paths. Here, we take the largest connected subgraph using
    the `connected_component_subgraphs()` function:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We define two positions (with the latitude and longitude) and find the shortest
    path between these two positions:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Each edge in the graph contains information about the road, including a list
    of points along this road. We first create a function that returns this array
    of coordinates, for any edge in the graph:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can notably use the road path to compute its length. We first need to define
    a function that computes the distance between any two points in geographical coordinates.
    This function has been found in Stack Overflow ([http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance](http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance)):'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we define a function computing a path''s length:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we update our graph by computing the distance between any two connected
    nodes. We add this information in the `distance` attribute of the edges:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The last step before we can find the shortest path in the graph is to find
    the two nodes in the graph that are closest to the two requested positions:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we use NetworkX''s `shortest_path()` function to compute the shortest
    path between our two positions. We specify that the weight of every edge is the
    length of the road between them:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The itinerary has been computed. The `path` variable contains the list of edges
    that form the shortest path between our two positions. Now, we can get information
    about the itinerary with pandas. The dataset has a few fields of interest, including
    the name and type (State, Interstate, and so on) of the roads:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is the total length of this itinerary:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, let''s display the itinerary on the map. We first retrieve the map
    with Smopy:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our path contains connected nodes in the graph. Every edge between two nodes
    is characterized by a list of points (constituting a part of the road). Therefore,
    we need to define a function that concatenates the positions along every edge
    in the path. We have to concatenate the positions in the right order along our
    path. We choose the order based on the fact that the last point in an edge needs
    to be close to the first point in the next edge:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We convert the path in pixels in order to display it on the Smopy map:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, let''s display the map, with our two positions and the computed itinerary
    between them:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![How to do it…](img/4818OS_14_13.jpg)'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We computed the shortest path with NetworkX's `shortest_path()` function. Here,
    this function used **Dijkstra's algorithm**. This algorithm has a wide variety
    of applications, for example in network routing protocols.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to compute the geographical distance between two points.
    Here, we used a relatively precise formula: the **orthodromic distance** (also
    called **great-circle distance**), which assumes that the Earth is a perfect sphere.
    We could also have used a simpler formula since the distance between two successive
    points on a road is small.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find more information about shortest path problems and Dijkstra''s
    algorithm in the following references:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Shortest paths on Wikipedia, available at [http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra's algorithm, described at [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few references about geographical distances:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Geographical distance on Wikipedia, at [http://en.wikipedia.org/wiki/Geographical_distance](http://en.wikipedia.org/wiki/Geographical_distance)
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great circles on Wikipedia, at [http://en.wikipedia.org/wiki/Great_circle](http://en.wikipedia.org/wiki/Great_circle)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great-circle distance on Wikipedia, at [http://en.wikipedia.org/wiki/Great-circle_distance](http://en.wikipedia.org/wiki/Great-circle_distance)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
