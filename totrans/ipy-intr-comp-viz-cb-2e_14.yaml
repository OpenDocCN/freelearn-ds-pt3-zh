- en: Chapter 14. Graphs, Geometry, and Geographic Information Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating and visualizing graphs with NetworkX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing a social network with NetworkX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving dependencies in a Directed Acyclic Graph with a topological sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing connected components in an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the Voronoi diagram of a set of points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating geospatial data with Shapely and basemap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a route planner for a road network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover Python's capabilities in graph theory, geometry,
    and geography.
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphs** are mathematical objects describing relations between items. They
    are ubiquitous in science and engineering, as they can represent many kinds of
    real-world relations: friends in a social network, atoms in a molecule, website
    links, cells in a neural network, neighboring pixels in an image, and so on. Graphs
    are also classical data structures in computer science. Finally, many domain-specific
    problems may be re-expressed as graph problems, and then solved with well-known
    algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: We will also see a few recipes related to **geometry** and **Geographic Information
    Systems** (**GIS**), which refers to the processing and analysis of any kind of
    spatial, geographical, or topographical data.
  prefs: []
  type: TYPE_NORMAL
- en: In this introduction, we will give a brief overview of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematically, a **graph** *G = (V, E)* is defined by a set *V* of **vertices**
    or **nodes**, and a set *E* of **edges** (two-element subsets of V). Two nodes
    *v* and *v*' are said to be **connected** if *(v, v')* is an edge (element of
    *E*).
  prefs: []
  type: TYPE_NORMAL
- en: If the edges are *unordered* (meaning that *(v,v') = (v',v)*), the graph is
    said to be **undirected**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the edges are *ordered* (meaning that *(v,v')* ≠ *(v',v)*), the graph is
    said to be **directed**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An edge in an undirected graph is represented by a line segment between the
    two nodes. In a directed graph, it is represented by an arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphs](img/4818OS_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Undirected and directed graphs
  prefs: []
  type: TYPE_NORMAL
- en: A graph can be represented by different data structures, notably an **adjacency
    list** (for each vertex, a list of adjacent vertices) or an **adjacency matrix**
    (matrix of connections between vertices).
  prefs: []
  type: TYPE_NORMAL
- en: Problems in graph theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are a few examples of classical graph problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Graph traversal**: How to walk through a graph, discussed at [http://en.wikipedia.org/wiki/Graph_traversal](http://en.wikipedia.org/wiki/Graph_traversal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph coloring**: How to color nodes in a graph such that no two adjacent
    vertices share the same color, discussed at [http://en.wikipedia.org/wiki/Graph_coloring](http://en.wikipedia.org/wiki/Graph_coloring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connected components**: How to find connected components in a graph, explained
    at [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shortest paths**: What is the shortest path from one node to another in a
    given graph?, discussed at [http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hamiltonian paths**: Does a graph include a Hamiltonian path, visiting every
    vertex exactly once?, explained at [http://en.wikipedia.org/wiki/Hamiltonian_path](http://en.wikipedia.org/wiki/Hamiltonian_path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eulerian paths**: Does a graph include an Eulerian path, visiting every *edge*
    exactly once?, discussed at [http://en.wikipedia.org/wiki/Eulerian_path](http://en.wikipedia.org/wiki/Eulerian_path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traveling Salesman Problem**: What is the shortest route visiting every node
    exactly once (Hamiltonian path)?, explained at [http://en.wikipedia.org/wiki/Traveling_salesman_problem](http://en.wikipedia.org/wiki/Traveling_salesman_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Random graphs** are particular kinds of graphs defined with probabilistic
    rules. They are useful for understanding the structure of large real-world graphs
    such as social graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: In particular, **small-world networks** have sparse connections, but most nodes
    can be reached from every other node in a small number of steps. This property
    is due to the existence of a small number of **hubs** that have a high number
    of connections.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although graphs can be manipulated with native Python structures, it is more
    convenient to use a dedicated library implementing specific data structures and
    manipulation routines. In this chapter, we will use **NetworkX**, a pure Python
    library. Alternative Python libraries include **python-graph** and **graph-tool**
    (largely written in C++).
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX implements a flexible data structure for graphs, and it contains many
    algorithms. NetworkX also lets us draw graphs easily with matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Shapely** is a Python library used to manipulate 2D geometrical shapes such
    as points, lines, and polygons. It is most notably useful in Geographic Information
    Systems.'
  prefs: []
  type: TYPE_NORMAL
- en: It is not straightforward to combine Shapely with matplotlib. Fortunately, the
    **descartes** package makes this task much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Geographical Information Systems in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several Python modules used to manipulate geographical data and plotting
    maps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use matplotlib's basemap, Shapely, descartes, and Fiona
    to handle GIS files.
  prefs: []
  type: TYPE_NORMAL
- en: The ESRI **shapefile** is a popular geospatial vector data format. It can be
    read by basemap, NetworkX, and Fiona.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use the **OpenStreetMap** service, a free, open source, collaborative
    service providing maps of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Other GIS/mapping systems in Python that we couldn't cover in this chapter include
    **GeoPandas**, **Kartograph**, **Vincent**, and **cartopy**.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references about graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Graph theory on Wikipedia, available at [http://en.wikipedia.org/wiki/Graph_theory](http://en.wikipedia.org/wiki/Graph_theory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures for graphs, described at [http://en.wikipedia.org/wiki/Graph_(abstract_data_type)](http://en.wikipedia.org/wiki/Graph_(abstract_data_type))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random graphs on Wikipedia, available at [http://en.wikipedia.org/wiki/Random_graph](http://en.wikipedia.org/wiki/Random_graph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small-world graphs on Wikipedia, available at [http://en.wikipedia.org/wiki/Small-world_network](http://en.wikipedia.org/wiki/Small-world_network)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetworkX package, available at [http://networkx.github.io](http://networkx.github.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The python-graph package, available at [https://code.google.com/p/python-graph/](https://code.google.com/p/python-graph/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The graph-tool package, available at [http://graph-tool.skewed.de](http://graph-tool.skewed.de)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few references about geometry and maps in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Basemap at [http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapely at [http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fiona at [http://toblerity.org/fiona/](http://toblerity.org/fiona/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: descartes at [https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapefile at [http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenStreetMap at [www.openstreetmap.org](http://www.openstreetmap.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folium at [https://github.com/wrobstory/folium](https://github.com/wrobstory/folium)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoPandas at [http://geopandas.org](http://geopandas.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kartograph at [http://kartograph.org](http://kartograph.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cartopy at [http://scitools.org.uk/cartopy/](http://scitools.org.uk/cartopy/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vincent at [https://github.com/wrobstory/vincent](https://github.com/wrobstory/vincent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating and visualizing graphs with NetworkX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to create, manipulate, and visualize graphs
    with NetworkX.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the installation instructions for NetworkX in the official documentation
    at [http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: With Anaconda, you can type `conda install networkx` in a terminal. Alternatively,
    you can type `pip install networkx`. On Windows, you can also use Chris Gohlke's
    installer, available at [www.lfd.uci.edu/~gohlke/pythonlibs/#networkx](http://www.lfd.uci.edu/~gohlke/pythonlibs/#networkx).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy, NetworkX, and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are many different ways of creating a graph. Here, we create a list of
    edges (pairs of node indices):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We instantiate a `Graph` object with our list of edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check the list of nodes and edges of the graph, and its adjacency matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s display this graph. NetworkX comes with a variety of drawing functions.
    We can either specify the nodes'' positions explicitly, or we can use an algorithm
    to automatically compute an interesting layout. Here, we use the `draw_circular()`
    function that simply positions nodes linearly on a circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Graphs can be modified easily. Here, we add a new node connected to all existing
    nodes. We also specify a `color` attribute to this node. In NetworkX, every node
    and edge comes with a convenient Python dictionary containing arbitrary attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s draw the modified graph again. This time, we specify the nodes''
    positions and colors explicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s also use an automatic layout algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In NetworkX, nodes are not necessarily integers. They can be numbers, strings,
    tuples, and instances of any hashable Python class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, every node and edge comes with optional attributes (which form
    a dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: A few layout algorithms are implemented in NetworkX. The `draw_spectral()` function
    uses the eigenvectors of the graph's **Laplacian matrix**.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw_spring()` function implements the **Fruchterman-Reingold force-directed**
    algorithm. Nodes are considered as masses subject to edge-dependent forces. A
    force-directed graph drawing algorithm minimizes the system's energy so as to
    find an equilibrium configuration. This results in an aesthetically appealing
    layout with as few crossing edges as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Graph drawing, described at [http://en.wikipedia.org/wiki/Graph_drawing](http://en.wikipedia.org/wiki/Graph_drawing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laplacian matrix on Wikipedia, available at [http://en.wikipedia.org/wiki/Laplacian_matrix](http://en.wikipedia.org/wiki/Laplacian_matrix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force-directed graph drawing, described at [http://en.wikipedia.org/wiki/Force-directed_graph_drawing](http://en.wikipedia.org/wiki/Force-directed_graph_drawing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Analyzing a social network with NetworkX* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing a social network with NetworkX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to analyze social data in Python. Social data
    is generated by people's activity on social networks such as Facebook, Twitter,
    Google+, GitHub, and others.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will analyze and visualize a Twitter user's social network
    with NetworkX.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you need to install the **Twitter** Python package. You can install it
    with `pip install twitter`. You'll find more information at [https://pypi.python.org/pypi/twitter](https://pypi.python.org/pypi/twitter).
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to obtain authentication codes in order to access your Twitter
    data. The procedure is free. In addition to a Twitter account, you also need to
    create an *Application* on the Twitter Developers website at [https://dev.twitter.com/apps](https://dev.twitter.com/apps).
    Then, you will be able to retrieve the **OAuth authentication codes** that are
    required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to create a `twitter.txt` text file in the current folder with the
    four private authentication keys. There must be one key per line, in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: API key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access token secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that access to the Twitter API is limited. Most methods can only be called
    a few times within a given time window. Unless you study small networks or look
    at small portions of large networks, you will need to *throttle* your requests.
    In this recipe, we only consider a small portion of the network, so that the API
    limit should not be reached. Otherwise, you will have to wait a few minutes before
    the next time window starts. The API limits are available at [https://dev.twitter.com/docs/rate-limiting/1.1/limits](https://dev.twitter.com/docs/rate-limiting/1.1/limits).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import a few packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get the secret consumer and OAuth keys from our `twitter.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now create an instance of the `Twitter` class that will give us access to
    the Twitter API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the 1.1 version of the Twitter API in this recipe. The `twitter` library
    defines a direct mapping between the REST API and the attributes of the `Twitter`
    instance. Here, we execute the `account/verify_credentials` REST request to obtain
    the identifier of the authenticated user (me here, or you if you execute this
    notebook yourself!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s define a simple function that returns the identifiers of all followers
    of a given user (the authenticated user by default):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define a function that retrieves the full profile of Twitter users.
    As the `users/lookup` batch request is limited to 100 users per call, and only
    a small number of calls are allowed within a time window, we only look at a subset
    of all the followers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also start to define the graph with the followers, using an adjacency list
    (technically, a dictionary of lists). This is called the **ego graph**. This graph
    represents all *following* connections between our followers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to take a look at the part of the ego graph related to Python.
    Specifically, we will consider the followers of the 10 most followed users whose
    descriptions contain "Python":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The request for retrieving the followers of a given user is rate-limited. Let''s
    check how many remaining calls we have:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that our graph is defined as an adjacency list in a dictionary, we will
    load it in NetworkX:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at the graph''s statistics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now going to plot this graph. We will use different sizes and colors
    for the nodes, according to the number of followers and the number of tweets for
    each user. Most followed users will be bigger. Most active users will be redder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we use the `draw()` function to display the graph. We need to specify
    the nodes'' sizes and colors as lists, and the labels as a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A great reference on social data analysis with Python is Matthew A. Russel''s
    book *Mining the Social Web*, *O''Reilly Media*. The code is available on GitHub
    as IPython notebooks at [https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition](https://github.com/ptwobrussell/Mining-the-Social-Web-2nd-Edition).
    The following networks are covered: Twitter, Facebook, LinkedIn, Google+, GitHub,
    mailboxes, websites, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Manipulating and visualizing graphs with NetworkX* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving dependencies in a directed acyclic graph with a topological sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will show an application of a well-known graph algorithm:
    **topological sorting**. Let''s consider a directed graph describing dependencies
    between items. For example, in a package manager, before we can install a given
    package *P*, we may need to install *dependent* packages.'
  prefs: []
  type: TYPE_NORMAL
- en: The set of dependencies forms a directed graph. With topological sorting, the
    package manager can resolve the dependencies and find the right installation order
    of the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Topological sorting has many other applications. Here, we will illustrate this
    notion on real data from the Debian package manager. We will find the installation
    order of the required packages for IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need the `python-apt` package in order to build the package dependency graph.
    The package is available at [https://pypi.python.org/pypi/python-apt/](https://pypi.python.org/pypi/python-apt/).
  prefs: []
  type: TYPE_NORMAL
- en: We also assume that this notebook is executed on a Debian system (such as Ubuntu).
    If you don't have such a system, you can download the *Debian* dataset directly
    from the book's GitHub repository at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
    Extract it in the current directory, and start directly from step 7 in this notebook.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import the `apt` module and we build the list of packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `graph` dictionary will contain the adjacency list of a small portion of
    the dependency graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a function that returns the list of dependencies of a package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now define a *recursive* function that builds the dependency graph for a
    particular package. This function updates the `graph` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s build the dependency graph for IPython:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we save the adjacency list in JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Start here if you don't have a Debian operating system (you first need to download
    the *Debian* dataset from the book's repository).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We import a few packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s load the adjacency list from the JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a directed graph (`DiGraph` in NetworkX) from our adjacency
    list. We reverse the graph to get a more natural ordering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A topological sort only exists when the graph is a **directed acyclic graph**
    (**DAG**). This means that there is no cycle in the graph, that is, no circular
    dependency. Is our graph a DAG? Let''s see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What are the packages responsible for the cycles? We can find them with the
    `simple_cycles()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can try to remove these packages. In an actual package manager, these
    cycles need to be carefully taken into account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The graph is now a DAG. Let''s display it first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, we can perform the topological sort, thereby obtaining a linear installation
    order satisfying all dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Directed acyclic graphs are found in many applications. They can represent causal
    relations, influence diagrams, dependencies, and other concepts. For example,
    the version history of a distributed revision control system such as Git is described
    with a DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Topological sorting is useful in any scheduling task in general (project management
    and instruction scheduling).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Topological sorting on Wikipedia, available at [http://en.wikipedia.org/wiki/Topological_sorting](http://en.wikipedia.org/wiki/Topological_sorting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directed acyclic graphs, described at [http://en.wikipedia.org/wiki/Directed_acyclic_graph](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing connected components in an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show an application of graph theory in image processing.
    We will compute **connected components** in an image. This method will allow us
    to label contiguous regions of an image, similar to the *bucket* fill tool of
    paint programs.
  prefs: []
  type: TYPE_NORMAL
- en: Finding connected components is also useful in many puzzle video games such
    as Minesweeper, bubble shooters, and others. In these games, contiguous sets of
    items with the same color need to be automatically detected.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a *10 x 10* image where each pixel can take one of three possible
    labels (or colors):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create the underlying 2D grid graph encoding the structure of the image.
    Each node is a pixel, and a node is connected to its nearest neighbors. NetworkX
    defines a `grid_2d_graph` function to generate this graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create two functions to display the image and the corresponding graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the original image superimposed with the underlying graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, we are going to find all contiguous dark blue regions containing more
    than three pixels. First, we consider the *subgraph* corresponding to all dark
    blue pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We see that the requested contiguous regions correspond to the *connected components*
    containing more than three nodes in the subgraph. We can use the `connected_components`
    function of NetworkX to find those components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we assign a new color to each of these components, and we display
    the new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem we solved is called **connected-component labeling**. It is also
    closely related to the **flood-fill algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: The idea to associate a grid graph to an image is quite common in image processing.
    Here, contiguous color regions correspond to **connected components** of subgraphs.
    A connected component can be defined as an equivalence class of the **reachability**
    relation. Two nodes are connected in the graph if there is a path from one node
    to the other. An equivalence class contains nodes that can be reached from one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the simple approach described here is only adapted to basic tasks on
    small images. More advanced algorithms are covered in [Chapter 11](ch11.html "Chapter 11. Image
    and Audio Processing"), *Image and Audio Processing*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Connected components on Wikipedia, available at [http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29](http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connected-component labeling on Wikipedia, at [http://en.wikipedia.org/wiki/Connected-component_labeling](http://en.wikipedia.org/wiki/Connected-component_labeling)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flood-fill algorithm on Wikipedia, available at [http://en.wikipedia.org/wiki/Flood_fill](http://en.wikipedia.org/wiki/Flood_fill)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the Voronoi diagram of a set of points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Voronoi diagram** of a set of *seed* points divides space into several
    regions. Each region contains all points closer to one seed point than to any
    other seed point.
  prefs: []
  type: TYPE_NORMAL
- en: The Voronoi diagram is a fundamental structure in computational geometry. It
    is widely used in computer science, robotics, geography, and other disciplines.
    For example, the Voronoi diagram of a set of metro stations gives us the closest
    station from any point in the city.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we compute the Voronoi diagram of the set of metro stations
    in Paris using SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need the Smopy module to display the OpenStreetMap map of Paris. You can
    install this package with `pip install smopy`.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to download the *RATP* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)
    and extract it in the current directory. The data was obtained on RATP's open
    data website (Paris' public transport operator, [http://data.ratp.fr](http://data.ratp.fr)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy, pandas, matplotlib, and SciPy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s load the dataset with pandas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DataFrame` object contains the coordinates, name, city, district, and
    type of station. Let''s select all metro stations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are going to extract the district number of Paris' stations. With pandas,
    we can use vectorized string operations using the `str` attribute of the corresponding
    column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also extract the coordinates of all metro stations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s retrieve Paris'' map with OpenStreetMap. We specify the map''s
    boundaries with the extreme latitude and longitude coordinates of all our metro
    stations. We use the lightweight Smopy module to generate the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now compute the Voronoi diagram of the stations using SciPy. A `Voronoi`
    object is created with the points coordinates. It contains several attributes
    we will use for display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create a generic function to display a Voronoi diagram. SciPy already implements
    such a function, but this function does not take infinite points into account.
    The implementation we will use has been obtained in Stack Overflow and is present
    at [http://stackoverflow.com/a/20678647/1595060](http://stackoverflow.com/a/20678647/1595060).
    This function is relatively long, and we won't copy it entirely here. The full
    version can be found in the book's GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `voronoi_finite_polygons_2d()` function returns a list of regions and a
    list of vertices. Every region is a list of vertex indices. The coordinates of
    all vertices are stored in `vertices`. From these structures, we can create a
    list of *cells*. Every cell represents a polygon as an array of vertex coordinates.
    We also use the `to_pixels()` method of the `smopy.Map` instance. This function
    converts latitude and longitude geographical coordinates to pixels in the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we compute the color of every polygon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we display the map with the Voronoi diagram, using the `show_mpl()`
    method of the `Map` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s give the mathematical definition of the Voronoi diagram in a Euclidean
    space. If *(x[i])* is a set of points, the Voronoi diagram of this set of points
    is the collection of subsets *V[i]* (called **cells** or **regions**) defined
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4818OS_14_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dual graph of the Voronoi diagram is the **Delaunay triangulation**. This
    geometrical object covers the convex hull of the set of points with triangles.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy computes Voronoi diagrams with **Qhull**, a computational geometry library
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are further references:'
  prefs: []
  type: TYPE_NORMAL
- en: Voronoi diagram on Wikipedia, available at [http://en.wikipedia.org/wiki/Voronoi_diagram](http://en.wikipedia.org/wiki/Voronoi_diagram)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delaunay triangulation on Wikipedia, available at [http://en.wikipedia.org/wiki/Delaunay_triangulation](http://en.wikipedia.org/wiki/Delaunay_triangulation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation of `scipy.spatial.voronoi` available at [http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html](http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.spatial.Voronoi.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qhull library available at [www.qhull.org](http://www.qhull.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Manipulating geospatial data with Shapely and basemap* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating geospatial data with Shapely and basemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to load and display geographical data in the
    Shapefile format. Specifically, we will use data from **Natural Earth** ([www.naturalearthdata.com](http://www.naturalearthdata.com))
    to display the countries of Africa, color coded with their population and **Gross
    Domestic Product** (**GDP**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Shapefile** ([http://en.wikipedia.org/wiki/Shapefile](http://en.wikipedia.org/wiki/Shapefile))
    is a popular geospatial vector data format for GIS software. It can be read by
    **Fiona**, a Python wrapper to **GDAL/OGR** (a C++ library supporting GIS file
    formats). We will also use **Shapely**, a Python package used to handle two-dimensional
    geometrical shapes, and **descartes**, used to render Shapely shapes in matplotlib.
    Finally, we will use **basemap** to plot maps.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: GDAL/OGR available at [www.gdal.org/ogr/](http://www.gdal.org/ogr/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fiona available at [http://toblerity.org/fiona/README.html](http://toblerity.org/fiona/README.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapely available at [http://toblerity.org/shapely/project.html](http://toblerity.org/shapely/project.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: descartes available at [https://pypi.python.org/pypi/descartes](https://pypi.python.org/pypi/descartes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basemap available at [http://matplotlib.org/basemap/](http://matplotlib.org/basemap/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With Anaconda, you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Shapely and descartes can be installed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, you can find binary installers for all of those packages except
    descartes on Chris Gohlke's webpage, [www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
  prefs: []
  type: TYPE_NORMAL
- en: On other systems, you can find installation instructions on the projects' websites.
    GDAL/OGR is a C++ library that is required by Fiona. The other packages are regular
    Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need to download the *Africa* dataset on the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data).
    The data was obtained on Natural Earth's website, [www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/](http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We load the *Shapefile* dataset with Fiona. This dataset notably contains the
    borders of all countries in the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We select the countries in Africa:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a basemap map showing the African continent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s write a function converting the geographical coordinates of the countries''
    borders to map coordinates. This will allow us to display the borders in basemap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create matplotlib `PatchCollection` objects from the *Shapefile*
    dataset loaded with Fiona. We use Shapely and descartes for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also define a function to get countries'' colors depending on a specific
    field in the *Shapefile* dataset. Indeed, our dataset not only contains countries
    borders, but also a few administrative, economical, and geographical properties
    for each country. Here, we will choose the color according to the countries''
    population and GDP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we display the maps. We display the coastlines with basemap, and the
    countries with our *Shapefile* dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a route planner for a road network* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a route planner for a road network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we build upon several techniques described in the previous recipes
    in order to create a simple GPS-like route planner in Python. We will retrieve
    California's road network data from the United States Census Bureau in order to
    find shortest paths in the road network graph. This allows us to display road
    itineraries between any two locations in California.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need NetworkX and Smopy for this recipe. In order for NetworkX to read Shapefile
    datasets, you also need GDAL/OGR. You can find more information in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to download the *Road* dataset from the book's GitHub repository
    at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data),
    and extract it in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of this writing, NetworkX's support of Shapefile doesn't seem to
    be compatible with Python 3.x. For this reason, this recipe has only been successfully
    tested with Python 2.x.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We load the data (a Shapefile dataset) with NetworkX. This dataset contains
    detailed information about the primary roads in California. NetworkX's `read_shp()`
    function returns a graph, where each node is a geographical position, and each
    edge contains information about the road linking the two nodes. The data comes
    from the United States Census Bureau website at [www.census.gov/geo/maps-data/data/tiger.html](http://www.census.gov/geo/maps-data/data/tiger.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This graph is not necessarily connected, but we need a connected graph in order
    to compute shortest paths. Here, we take the largest connected subgraph using
    the `connected_component_subgraphs()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define two positions (with the latitude and longitude) and find the shortest
    path between these two positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each edge in the graph contains information about the road, including a list
    of points along this road. We first create a function that returns this array
    of coordinates, for any edge in the graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can notably use the road path to compute its length. We first need to define
    a function that computes the distance between any two points in geographical coordinates.
    This function has been found in Stack Overflow ([http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance](http://stackoverflow.com/questions/8858838/need-help-calculating-geographical-distance)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we define a function computing a path''s length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we update our graph by computing the distance between any two connected
    nodes. We add this information in the `distance` attribute of the edges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step before we can find the shortest path in the graph is to find
    the two nodes in the graph that are closest to the two requested positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we use NetworkX''s `shortest_path()` function to compute the shortest
    path between our two positions. We specify that the weight of every edge is the
    length of the road between them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The itinerary has been computed. The `path` variable contains the list of edges
    that form the shortest path between our two positions. Now, we can get information
    about the itinerary with pandas. The dataset has a few fields of interest, including
    the name and type (State, Interstate, and so on) of the roads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the total length of this itinerary:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s display the itinerary on the map. We first retrieve the map
    with Smopy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our path contains connected nodes in the graph. Every edge between two nodes
    is characterized by a list of points (constituting a part of the road). Therefore,
    we need to define a function that concatenates the positions along every edge
    in the path. We have to concatenate the positions in the right order along our
    path. We choose the order based on the fact that the last point in an edge needs
    to be close to the first point in the next edge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We convert the path in pixels in order to display it on the Smopy map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s display the map, with our two positions and the computed itinerary
    between them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_14_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We computed the shortest path with NetworkX's `shortest_path()` function. Here,
    this function used **Dijkstra's algorithm**. This algorithm has a wide variety
    of applications, for example in network routing protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to compute the geographical distance between two points.
    Here, we used a relatively precise formula: the **orthodromic distance** (also
    called **great-circle distance**), which assumes that the Earth is a perfect sphere.
    We could also have used a simpler formula since the distance between two successive
    points on a road is small.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find more information about shortest path problems and Dijkstra''s
    algorithm in the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Shortest paths on Wikipedia, available at [http://en.wikipedia.org/wiki/Shortest_path_problem](http://en.wikipedia.org/wiki/Shortest_path_problem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra's algorithm, described at [http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few references about geographical distances:'
  prefs: []
  type: TYPE_NORMAL
- en: Geographical distance on Wikipedia, at [http://en.wikipedia.org/wiki/Geographical_distance](http://en.wikipedia.org/wiki/Geographical_distance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great circles on Wikipedia, at [http://en.wikipedia.org/wiki/Great_circle](http://en.wikipedia.org/wiki/Great_circle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great-circle distance on Wikipedia, at [http://en.wikipedia.org/wiki/Great-circle_distance](http://en.wikipedia.org/wiki/Great-circle_distance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
