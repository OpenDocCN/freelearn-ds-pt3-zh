<html><head></head><body>
		<div id="_idContainer043">
			<h1 id="_idParaDest-79" class="chapter-number"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.2.1">Cleaning Messy Data and Data Manipulation</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">In this chapter, we’ll dive into the </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.4.1">strategies of </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">data manipulation</span></strong><span class="koboSpan" id="kobo.6.1">, focusing on efficient techniques to clean and fix messy datasets. </span><span class="koboSpan" id="kobo.6.2">We’ll remove irrelevant columns, systematically address inconsistent data types, and fix dates </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">and times.</span></span></p>
			<p><span class="koboSpan" id="kobo.8.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">following topics:</span></span></p>
			<ul>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Renaming columns</span></span></li>
				<li><span class="koboSpan" id="kobo.11.1">Removing irrelevant or </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">redundant columns</span></span></li>
				<li><span class="koboSpan" id="kobo.13.1">Fixing </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">data types</span></span></li>
				<li><span class="koboSpan" id="kobo.15.1">Working with dates </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and times</span></span></li>
			</ul>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.18.1">You can find all the code for this chapter in the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">link: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/tree/main/chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/tree/main/chapter04</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.22.1">Each file is named according to the respective sections covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">this chapter.</span></span></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.24.1">Renaming columns</span></h1>
			<p><span class="koboSpan" id="kobo.25.1">Renaming columns </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.26.1">with more descriptive and meaningful names makes it easier to understand the content and purpose of each column. </span><span class="koboSpan" id="kobo.26.2">Clear and intuitive column names enhance the interpretability of the dataset, especially when sharing or collaborating </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">with others.</span></span></p>
			<p><span class="koboSpan" id="kobo.28.1">To better understand all the concepts introduced in this chapter, we will use a scenario across the chapter. </span><span class="koboSpan" id="kobo.28.2">Let’s consider an e-commerce company that wants to analyze customer </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.29.1">purchase data to optimize its marketing strategies. </span><span class="koboSpan" id="kobo.29.2">The dataset includes information about customer transactions, such as purchase amount, payment method, and timestamp of the transactions. </span><span class="koboSpan" id="kobo.29.3">However, the dataset is messy and requires cleaning and manipulation to derive </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">meaningful insights.</span></span></p>
			<p><span class="koboSpan" id="kobo.31.1">The distribution of the features is presented in the following figure. </span><span class="koboSpan" id="kobo.31.2">To build the following statistic charts, execute the file at </span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/1.descriptive_stats.py"><span class="koboSpan" id="kobo.32.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/1.descriptive_stats.py</span></a><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">The data and the following charts are created automatically once you run </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">this script.</span></span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<span class="koboSpan" id="kobo.35.1"><img src="image/B19801_04_1.jpg" alt="Figure 4.1 – Distribution of features before any data transformation"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.36.1">Figure 4.1 – Distribution of features before any data transformation</span></p>
			<p><span class="koboSpan" id="kobo.37.1">We have five columns in </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">the dataset:</span></span></p>
			<ul>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">CustomerID</span></strong><span class="koboSpan" id="kobo.40.1">: A unique identifier for each customer. </span><span class="koboSpan" id="kobo.40.2">In this example, customer IDs range from </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.42.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">11</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">ProductName</span></strong><span class="koboSpan" id="kobo.46.1">: This represents the name of the purchased product. </span><span class="koboSpan" id="kobo.46.2">In the dataset, three products are considered: </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">Product_A</span></strong><span class="koboSpan" id="kobo.48.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">Product_B</span></strong><span class="koboSpan" id="kobo.50.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">Product_C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">PurchaseAmount</span></strong><span class="koboSpan" id="kobo.55.1">: This indicates the amount spent by the customer on a particular product. </span><span class="koboSpan" id="kobo.55.2">The amounts are in an </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">arbitrary currency.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">PaymentMethod</span></strong><span class="koboSpan" id="kobo.58.1">: This describes the method used by the customer to make the purchase. </span><span class="koboSpan" id="kobo.58.2">Payment methods include </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">Card</span></strong><span class="koboSpan" id="kobo.60.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">PayPal</span></strong><span class="koboSpan" id="kobo.62.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">Cash</span></strong><span class="koboSpan" id="kobo.64.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">Bank Transfer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">.</span></span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Timestamp</span></strong><span class="koboSpan" id="kobo.68.1">: This </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.69.1">represents the date and time when the purchase occurred. </span><span class="koboSpan" id="kobo.69.2">It is formatted as a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">datetime</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.71.1"> object.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.72.1">The first thing we are going to check and update are the column names. </span><span class="koboSpan" id="kobo.72.2">Let’s start with this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">following section.</span></span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.74.1">Renaming a single column</span></h2>
			<p><span class="koboSpan" id="kobo.75.1">Now, the </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.76.1">e-commerce company has decided to rebrand its products, necessitating a change in the column names related to product information. </span><span class="koboSpan" id="kobo.76.2">We’ll start by renaming a single column, and then we’ll further rename multiple columns to align with the rebranding initiative. </span><span class="koboSpan" id="kobo.76.3">For the renaming example, go to the file </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">at </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/2.rename_columns.py"><span class="No-Break"><span class="koboSpan" id="kobo.78.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/2.rename_columns.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.79.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.80.1">Let’s have a look at how we can rename one column in </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the dataset:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
df.rename(columns={'ProductName': 'OldProductName'}, inplace=True)</span></pre>			<p><span class="koboSpan" id="kobo.83.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">inplace=True</span></strong><span class="koboSpan" id="kobo.85.1"> argument is an optional parameter in pandas DataFrame methods that allows you to modify the DataFrame directly without creating a new </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">DataFrame object.</span></span></p>
			<p><span class="koboSpan" id="kobo.87.1">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">inplace</span></strong><span class="koboSpan" id="kobo.89.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">True</span></strong><span class="koboSpan" id="kobo.91.1">, the DataFrame is modified in place, meaning the changes are applied to the original DataFrame object. </span><span class="koboSpan" id="kobo.91.2">This can be useful when you want to update or modify the DataFrame without assigning the modified DataFrame to a </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">new variable.</span></span></p>
			<p><span class="koboSpan" id="kobo.93.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">inplace=True</span></strong><span class="koboSpan" id="kobo.95.1"> is not specified or set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">False</span></strong><span class="koboSpan" id="kobo.97.1"> (which is the default behavior), the DataFrame methods return a new modified DataFrame object, leaving the original DataFrame unchanged. </span><span class="koboSpan" id="kobo.97.2">In such cases, you need to assign the modified DataFrame to a new variable to store </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">the changes.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.99.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.100.1">It’s important to note that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">inplace=True</span></strong><span class="koboSpan" id="kobo.102.1"> can be a destructive operation since it modifies the original DataFrame directly. </span><span class="koboSpan" id="kobo.102.2">Therefore, it’s recommended to use it with caution and ensure that you have a backup of the original DataFrame if needed. </span><span class="koboSpan" id="kobo.102.3">If you have a large dataset, modifying it in place can help </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">conserve memory.</span></span></p>
			<p><span class="koboSpan" id="kobo.104.1">In the next section, we </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.105.1">will rename multiple columns to align with the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">rebranding initiative.</span></span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.107.1">Renaming all columns</span></h2>
			<p><span class="koboSpan" id="kobo.108.1">Following a </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.109.1">rebranding initiative, the company decided to rename </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">OldProductName</span></strong><span class="koboSpan" id="kobo.111.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">NewProductName</span></strong><span class="koboSpan" id="kobo.113.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">PurchaseAmount</span></strong><span class="koboSpan" id="kobo.115.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">NewPurchaseAmount</span></strong><span class="koboSpan" id="kobo.117.1"> to align with the updated product names. </span><span class="koboSpan" id="kobo.117.2">This code demonstrates how to rename multiple columns </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">at once:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
df.rename(columns={'OldProductName': 'NewProductName', 'PurchaseAmount': 'NewPurchaseAmount'}, inplace=True)</span></pre>			<p><span class="koboSpan" id="kobo.120.1">If you want to rename columns in a DataFrame and need to ensure a smooth and error-free process, we can add error handling. </span><span class="koboSpan" id="kobo.120.2">For example, ensure that the columns you intend to rename actually exist in the DataFrame. </span><span class="koboSpan" id="kobo.120.3">If a column is misspelled or does not exist, the renaming operation will raise </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">an error:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
if 'OldProductName' in df.columns:
try:
# Attempt to rename multiple columns
  df.rename(columns={'OldProductName': 'NewProductName', 'PurchaseAmount': 'NewPurchaseAmount'}, inplace=True)
except ValueError as ve:
  print(f"Error: {ve}")
else:
  print("Error: Column 'OldProductName' does not exist in the DataFrame.")</span></pre>			<p class="callout-heading"><span class="koboSpan" id="kobo.123.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.124.1">Ensure that the new column names do not already exist in the DataFrame to avoid overwriting </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">existing columns.</span></span></p>
			<p><span class="koboSpan" id="kobo.126.1">Renaming a</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.127.1"> column is one of the simplest things we can do to make our data cleaner and easier to understand. </span><span class="koboSpan" id="kobo.127.2">The next thing we usually do is keep only the columns we need or care about, as we will discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">next section.</span></span></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.129.1">Removing irrelevant or redundant columns</span></h1>
			<p><span class="koboSpan" id="kobo.130.1">Large</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.131.1"> datasets often contain numerous columns, some of which may be irrelevant to the specific analyses or tasks at hand. </span><span class="koboSpan" id="kobo.131.2">By eliminating these columns, we can get some significant benefits. </span><span class="koboSpan" id="kobo.131.3">Firstly, storage requirements are dramatically reduced, leading to cost savings and more efficient use of resources. </span><span class="koboSpan" id="kobo.131.4">Additionally, the streamlined dataset results in faster query performance, optimized memory usage, and expedited processing times for complex analyses. </span><span class="koboSpan" id="kobo.131.5">This not only improves the overall efficiency of data processing tasks but also facilitates easier management and maintenance of large datasets. </span><span class="koboSpan" id="kobo.131.6">Furthermore, in cloud-based environments, where storage costs are a factor, the removal of unnecessary columns directly contributes to cost efficiency. </span><span class="koboSpan" id="kobo.131.7">So, let’s have a look at how we can drop columns in an </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">efficient way.</span></span></p>
			<p><span class="koboSpan" id="kobo.133.1">In the e-commerce dataset we presented earlier, we have collected information about customer purchases. </span><span class="koboSpan" id="kobo.133.2">However, as your analysis focuses on product-related metrics and customer behavior, certain columns, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">CustomerID</span></strong><span class="koboSpan" id="kobo.135.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Timestamp</span></strong><span class="koboSpan" id="kobo.137.1">, may be considered irrelevant to the current analysis. </span><span class="koboSpan" id="kobo.137.2">The goal is to streamline the dataset by dropping these columns. </span><span class="koboSpan" id="kobo.137.3">You can follow along with this example using this Python </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">script </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/3.dropping_columns.py"><span class="No-Break"><span class="koboSpan" id="kobo.139.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/3.dropping_columns.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.140.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
columns_to_drop = ['CustomerID', 'Timestamp'] # Replace with the names of the columns you want to drop
try:
# Drop columns considered irrelevant for the current analysis
    df.drop(columns=columns_to_drop, inplace=True)
except KeyError as ke:
    print(f"Error: {ke}")</span></pre>			<p><span class="koboSpan" id="kobo.142.1">Now, if </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.143.1">you have a look at the dataset, the column before the deletion </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">was this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
Index(['CustomerID', 'NewProductName', 'NewPurchaseAmount', 'PaymentMethod','Timestamp'],dtype='object')</span></pre>			<p><span class="koboSpan" id="kobo.146.1">After dropping the two columns, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">the following:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
Index(['NewProductName', 'NewPurchaseAmount', 'PaymentMethod'], dtype='object')</span></pre>			<p class="callout-heading"><span class="koboSpan" id="kobo.149.1">Note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.150.1">Python, by default, is case-sensitive. </span><span class="koboSpan" id="kobo.150.2">This means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">ColumnName</span></strong><span class="koboSpan" id="kobo.152.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">columnname</span></strong><span class="koboSpan" id="kobo.154.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">considered different.</span></span></p>
			<p><span class="koboSpan" id="kobo.156.1">We successfully removed the unnecessary columns, as demonstrated earlier. </span><span class="koboSpan" id="kobo.156.2">To further assess memory efficiency, we can calculate the memory consumption of the DataFrame both before and after the column deletion. </span><span class="koboSpan" id="kobo.156.3">The following code provides a Python example of how to calculate the memory used by the DataFrame before and after the drop </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">of columns:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
print("Initial Memory Usage:")
print(df.memory_usage().sum() / (1024 ** 2), "MB") # Convert bytes to megabytes
print("\nMemory Usage After Dropping Columns:")
print(df.memory_usage().sum() / (1024 ** 2), "MB") # Convert bytes to megabytes</span></pre>			<p><span class="koboSpan" id="kobo.159.1">The initial memory usage of the DataFrame was approximately 0.00054 megabytes, and after dropping columns, it reduced to around 0.00037 megabytes. </span><span class="koboSpan" id="kobo.159.2">The achieved reduction in memory usage showcases an optimization of </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">nearly 31%.</span></span></p>
			<p><span class="koboSpan" id="kobo.161.1">While</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.162.1"> this example involves a small dataset, the principles of memory efficiency hold significant implications when extrapolated to big data scenarios. </span><span class="koboSpan" id="kobo.162.2">In large-scale datasets, the impact of removing unnecessary columns becomes even </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">more pronounced.</span></span></p>
			<p><span class="koboSpan" id="kobo.164.1">To underline the significance of the operation, consider a scenario with a substantial dataset. </span><span class="koboSpan" id="kobo.164.2">Initially, the dataset size was 100,000 megabytes, and after the removal of unnecessary columns, it was reduced to 69,000 megabytes. </span><span class="koboSpan" id="kobo.164.3">To execute the same workload, the initial option would be utilizing an AWS EC2 instance of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">r7g.4xlarge</span></strong><span class="koboSpan" id="kobo.166.1"> with an hourly rate of $1.0064 and memory of 128 GiB, as we need 100 gigabytes of memory to load just the dataset. </span><span class="koboSpan" id="kobo.166.2">However, by reducing the dataset size to 61 gigabytes, an alternative, more cost-effective option is available, employing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">r7g.2xlarge</span></strong><span class="koboSpan" id="kobo.168.1"> instance at $0.5032 per hour and memory of 64 GiB. </span><span class="koboSpan" id="kobo.168.2">In the context of a five-minute workload runtime, the cost associated with the operation before dropping the data was </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
Cost_before = (Hourly Rate/60) * Runtime(in minutes) = (1.0064/60) * 5 = 0.0838$
Cost_after = (Hourly Rate/60) * Runtime(in minutes) = (0.5032/60) * 5 = 0.041$</span></pre>			<p><span class="koboSpan" id="kobo.171.1">The solution became approximately 50% more cost-effective after dropping unnecessary columns. </span><span class="koboSpan" id="kobo.171.2">This represents the cost savings achieved by optimizing the dataset and utilizing a more suitable AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">instance type.</span></span></p>
			<p><span class="koboSpan" id="kobo.173.1">The simplicity of this example underscores a </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">crucial message:</span></span></p>
			<p><em class="italic"><span class="koboSpan" id="kobo.175.1">Streamline your data operations by focusing on what is truly essential and let this simplicity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">drive cost-effectiveness.</span></em></span></p>
			<p><span class="koboSpan" id="kobo.177.1">Transitioning from dropping columns to fixing inconsistent data types involves addressing the quality and integrity of the remaining columns in </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">your dataset.</span></span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.179.1">Dealing with inconsistent and incorrect data types</span></h1>
			<p><span class="koboSpan" id="kobo.180.1">When working with a DataFrame, it’s important to ensure that each column has the correct data type. </span><span class="koboSpan" id="kobo.180.2">Inconsistent or incorrect data types </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.181.1">can lead to errors in analysis, unexpected behavior, and difficulties in performing operations. </span><span class="koboSpan" id="kobo.181.2">Let’s review how you can handle such situations. </span><span class="koboSpan" id="kobo.181.3">You can find the code for this example </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/4.data_types.py"><span class="No-Break"><span class="koboSpan" id="kobo.183.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/4.data_types.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.184.1">.</span></span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.185.1">Inspecting columns</span></h2>
			<p><span class="koboSpan" id="kobo.186.1">Inspecting</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.187.1"> the data types of each column in the data is an essential step in identifying any inconsistencies or incorrect data types. </span><span class="koboSpan" id="kobo.187.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">dtypes</span></strong><span class="koboSpan" id="kobo.189.1"> attribute of a DataFrame provides information about the data types of each column. </span><span class="koboSpan" id="kobo.189.2">Let’s check the data types of the columns in </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">our dataset:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
print("\nUpdated Data Types of Columns:")
print(df.dtypes)</span></pre>			<p><span class="koboSpan" id="kobo.192.1">The types are </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">presented here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
CustomerID         int64
ProductName       object
PurchaseAmount     int64
PaymentMethod     object
Timestamp         object</span></pre>			<p><span class="koboSpan" id="kobo.195.1">Inspecting the data types allows you to understand the current representation of the data and determine if any data type conversions or transformations are needed for further analysis or data cleaning tasks. </span><span class="koboSpan" id="kobo.195.2">In the following sections, we will perform different </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">type transformations.</span></span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.197.1">Columnar type transformations</span></h2>
			<p><span class="koboSpan" id="kobo.198.1">In the </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.199.1">data world, various </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">type transformations</span></strong><span class="koboSpan" id="kobo.201.1"> can be applied to manipulate and convert data </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.202.1">into different formats. </span><span class="koboSpan" id="kobo.202.2">In those situations, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">astype</span></strong><span class="koboSpan" id="kobo.204.1"> method is your friend. </span><span class="koboSpan" id="kobo.204.2">The most common type transformations that you should be comfortable with are presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">next sections.</span></span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.206.1">Converting to numeric types</span></h2>
			<p><span class="koboSpan" id="kobo.207.1">In </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.208.1">pandas, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">astype()</span></strong><span class="koboSpan" id="kobo.210.1"> function is used to convert a column to a specified numeric data type. </span><span class="koboSpan" id="kobo.210.2">For example, to convert a column named </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">PurchaseAmount</span></strong><span class="koboSpan" id="kobo.212.1"> to an integer type, you can use </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the following:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
df['PurchaseAmount'] = pd.to_numeric(df['PurchaseAmount'], errors='coerce')</span></pre>			<p><span class="koboSpan" id="kobo.215.1">Now, let’s see how we can turn columns </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">into strings.</span></span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.217.1">Converting to string types</span></h2>
			<p><span class="koboSpan" id="kobo.218.1">You</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.219.1"> can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">astype()</span></strong><span class="koboSpan" id="kobo.221.1"> function to convert a column into a </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">string type:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
df['ProductName'] = df['ProductName'].astype('str')</span></pre>			<p><span class="koboSpan" id="kobo.224.1">Now, let’s see how we can turn columns into </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">categorical types.</span></span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.226.1">Converting to categorical types</span></h2>
			<p><span class="koboSpan" id="kobo.227.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">categorical type</span></strong><span class="koboSpan" id="kobo.229.1"> refers </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.230.1">to a </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.231.1">data type that represents categorical or discrete variables. </span><span class="koboSpan" id="kobo.231.2">Categorical variables can take on a limited, and usually fixed, number of distinct categories or levels. </span><span class="koboSpan" id="kobo.231.3">These variables often represent qualitative data or attributes with no </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">inherent order:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
df['PaymentMethod'] = df['PaymentMethod'].astype('category')</span></pre>			<p><span class="koboSpan" id="kobo.234.1">The last transformation we will discuss is </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">the Boolean.</span></span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.236.1">Converting to Boolean types</span></h2>
			<p><span class="koboSpan" id="kobo.237.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">Boolean transformation</span></strong><span class="koboSpan" id="kobo.239.1"> refers</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.240.1"> to converting values in a dataset or a specific column to Boolean (</span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">True</span></strong><span class="koboSpan" id="kobo.242.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">False</span></strong><span class="koboSpan" id="kobo.244.1">) values</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.245.1"> based on certain conditions or criteria. </span><span class="koboSpan" id="kobo.245.2">This transformation is often used to create binary indicators or flags, making it easier to work with and </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">analyze data:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
df['HasDive'] = df['ProductName'].str.contains('Dive', case=False)</span></pre>			<p><span class="koboSpan" id="kobo.248.1">The preceding code part checks whether each element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">ProductName</span></strong><span class="koboSpan" id="kobo.250.1"> column contains the substring </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Dive</span></strong><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">It returns a Boolean Series where each element is </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">True</span></strong><span class="koboSpan" id="kobo.254.1"> if the condition is met and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">False</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1"> otherwise:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
df['HasDive'] = df['HasDive'].astype('bool')</span></pre>			<p><span class="koboSpan" id="kobo.258.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">astype('bool')</span></strong><span class="koboSpan" id="kobo.260.1"> method is used to explicitly cast the data type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">HasDive</span></strong><span class="koboSpan" id="kobo.262.1"> column </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">to Boolean.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.264.1">Things to be aware of when using astype(bool)</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.265.1">If you’re experiencing a situation where all values are being converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">True</span></strong><span class="koboSpan" id="kobo.267.1">, it could be due to one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">following reasons:</span></span></p>
			<p class="callout"><span class="koboSpan" id="kobo.269.1">1. </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">Non-zero values</span></strong><span class="koboSpan" id="kobo.271.1">: Since non-zero values are considered </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">True</span></strong><span class="koboSpan" id="kobo.273.1"> in a Boolean context, </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">.astype(bool)</span></strong><span class="koboSpan" id="kobo.275.1"> will convert all non-zero values to </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">True</span></strong><span class="koboSpan" id="kobo.277.1">. </span><span class="koboSpan" id="kobo.277.2">In such cases, consider if the column contains unexpected or unintended </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">non-zero values.</span></span></p>
			<p class="callout"><span class="koboSpan" id="kobo.279.1">2. </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">Non-missing values</span></strong><span class="koboSpan" id="kobo.281.1">: If your column has missing values represented as </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Not a Number</span></strong><span class="koboSpan" id="kobo.283.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.284.1">NaN</span></strong><span class="koboSpan" id="kobo.285.1">), they are treated as non-zero and are converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">True</span></strong><span class="koboSpan" id="kobo.287.1"> when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">.astype(bool)</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">Check if there are missing values present in the column and consider how you want to handle them. </span><span class="koboSpan" id="kobo.289.3">You may need to fill in or drop missing values before </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">the conversion.</span></span></p>
			<p><span class="koboSpan" id="kobo.291.1">In the last section of this chapter, we’ll discuss how to handle dates </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">and times.</span></span></p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.293.1">Working with dates and times</span></h1>
			<p><span class="koboSpan" id="kobo.294.1">Imagine </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.295.1">you have data that includes information about when things happened – being able to understand and handle that time-related data is key for making sense of patterns and trends. </span><span class="koboSpan" id="kobo.295.2">It’s not just about understanding when things happened, but also about making it easier to visualize and tell stories with your data. </span><span class="koboSpan" id="kobo.295.3">Whether you’re diving into trends over time, filtering data for specific periods, or making predictions with machine learning, being good with dates and times is key to unlocking valuable insights from datasets that involve the dimension </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">of time.</span></span></p>
			<p><span class="koboSpan" id="kobo.297.1">Now that we understand why dealing with dates and time is so important, the next step is learning how to grab that time-related info and make it work </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">for us.</span></span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.299.1">Importing and parsing date and time data</span></h2>
			<p><span class="koboSpan" id="kobo.300.1">Python </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.301.1">provides several main functions to parse dates, depending on the format of the input date string and the desired output. </span><span class="koboSpan" id="kobo.301.2">Let’s discuss the commonly used functions for </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">parsing dates.</span></span></p>
			<h3><span class="koboSpan" id="kobo.303.1">pd.to_datetime() from the pandas library</span></h3>
			<p><span class="koboSpan" id="kobo.304.1">This function is</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.305.1"> specifically designed for parsing date strings within pandas DataFrames or Series, but it can also be used independently. </span><span class="koboSpan" id="kobo.305.2">It is suitable when working with tabular data and allows handling multiple date </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">formats simultaneously:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.307.1">
df['Timestamp3'] = pd.to_datetime(df['Timestamp'], format='%Y-%m-%d %H:%M:%S')</span></pre>			<p><span class="koboSpan" id="kobo.308.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">format</span></strong><span class="koboSpan" id="kobo.310.1"> parameter specifies the expected format of the input string. </span><span class="koboSpan" id="kobo.310.2">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">%Y</span></strong><span class="koboSpan" id="kobo.312.1"> represents the four-digit year, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">%m</span></strong><span class="koboSpan" id="kobo.314.1"> represents the month, </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">%d</span></strong><span class="koboSpan" id="kobo.316.1"> represents the day, </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">%H</span></strong><span class="koboSpan" id="kobo.318.1"> represents the hour, </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">%M</span></strong><span class="koboSpan" id="kobo.320.1"> represents the minute, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">%S</span></strong><span class="koboSpan" id="kobo.322.1"> represents </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the second.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.324.1">Considerations</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.325.1">If your dataset contains missing or inconsistent timestamp values, consider using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">errors</span></strong><span class="koboSpan" id="kobo.327.1"> parameter. </span><span class="koboSpan" id="kobo.327.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">errors='coerce'</span></strong><span class="koboSpan" id="kobo.329.1"> will replace parsing </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.330.1">errors with </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Not a Time</span></strong><span class="koboSpan" id="kobo.332.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.333.1">NaT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">) values.</span></span></p>
			<p class="callout"><span class="koboSpan" id="kobo.335.1">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">pd.to_datetime</span></strong><span class="koboSpan" id="kobo.337.1"> is efficient, it may have performance implications for large datasets. </span><span class="koboSpan" id="kobo.337.2">For improved performance, consider using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">infer_datetime_format=True</span></strong><span class="koboSpan" id="kobo.339.1"> parameter to automatically infer the format (works well for standard formats). </span><span class="koboSpan" id="kobo.339.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">infer_datetime_format</span></strong><span class="koboSpan" id="kobo.341.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">True</span></strong><span class="koboSpan" id="kobo.343.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">parse_dates</span></strong><span class="koboSpan" id="kobo.345.1"> is enabled, Pandas will try to automatically deduce the format of datetime strings in the columns. </span><span class="koboSpan" id="kobo.345.2">If successful, it switches to a more efficient parsing method, potentially boosting parsing speed by 5-10 times in </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">certain scenarios.</span></span></p>
			<p class="callout"><span class="koboSpan" id="kobo.347.1">If your data involves different</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.348.1"> time zones, consider using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">utc</span></strong><span class="koboSpan" id="kobo.350.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">tz</span></strong><span class="koboSpan" id="kobo.352.1"> parameters to handle </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Coordinated Universal Time</span></strong><span class="koboSpan" id="kobo.354.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.355.1">UTC</span></strong><span class="koboSpan" id="kobo.356.1">) conversion and time </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">zone localization.</span></span></p>
			<p><span class="koboSpan" id="kobo.358.1">In the next section, we will introduce another method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">strftime</span></strong><span class="koboSpan" id="kobo.360.1">. </span><span class="koboSpan" id="kobo.360.2">This method allows for the customization of datetime values, enabling the creation of specific and readable representations </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">of time.</span></span></p>
			<h3><span class="koboSpan" id="kobo.362.1">strftime() from the datetime module</span></h3>
			<p><span class="koboSpan" id="kobo.363.1">This function</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.364.1"> is used to parse a date string into a datetime object based on </span><em class="italic"><span class="koboSpan" id="kobo.365.1">a specified format string</span></em><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">It is suitable when you have a known date format and want precise control over the </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">parsing process:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
df['FormattedTimestamp'] = df['Timestamp'].dt.strftime('%b %d, %Y %I:%M %p')</span></pre>			<p><span class="koboSpan" id="kobo.369.1">The resulting DataFrame is </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">as follows:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
             Timestamp     FormattedTimestamp
0  2022-01-01 08:30:45  Jan 01, 2022 08:30 AM
1  2022-01-02 14:20:30  Jan 02, 2022 02:20 PM</span></pre>			<p><span class="koboSpan" id="kobo.372.1">The format is controlled by format specifiers, each starting with a percent (</span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">%</span></strong><span class="koboSpan" id="kobo.374.1">) character, representing different components of the date and time (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">%Y</span></strong><span class="koboSpan" id="kobo.376.1"> for the year, </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">%m</span></strong><span class="koboSpan" id="kobo.378.1"> for the month, </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">%d</span></strong><span class="koboSpan" id="kobo.380.1"> for the day, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">%H</span></strong><span class="koboSpan" id="kobo.382.1"> for the hour, </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">%M</span></strong><span class="koboSpan" id="kobo.384.1"> for the minute, </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">%S</span></strong><span class="koboSpan" id="kobo.386.1"> for the second, etc.). </span><span class="koboSpan" id="kobo.386.2">A full list of format specifiers can be found in the Python </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">documentation: </span></span><a href="https://strftime.org/"><span class="No-Break"><span class="koboSpan" id="kobo.388.1">https://strftime.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.389.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.390.1">Unlike the rigid structure required by </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">strftime</span></strong><span class="koboSpan" id="kobo.392.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">dateutil.parser.parse()</span></strong><span class="koboSpan" id="kobo.394.1"> excels in interpreting a wide range of date and time representations, offering a dynamic solution for parsing diverse datetime strings, as we will see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">next section.</span></span></p>
			<h3><span class="koboSpan" id="kobo.396.1">dateutil.parser.parse() from the dateutil library</span></h3>
			<p><span class="koboSpan" id="kobo.397.1">This function</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.398.1"> provides a flexible approach to parse date strings, </span><em class="italic"><span class="koboSpan" id="kobo.399.1">automatically inferring</span></em><span class="koboSpan" id="kobo.400.1"> the format based on the input. </span><span class="koboSpan" id="kobo.400.2">It is useful when dealing with a variety of date formats or when the format </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">is unknown:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
df['Timestamp2'] = df['Timestamp'].apply(parser.parse)</span></pre>			<p><span class="koboSpan" id="kobo.403.1">One thing to note about this method is that the parser can infer and </span><em class="italic"><span class="koboSpan" id="kobo.404.1">handle time zone information</span></em><span class="koboSpan" id="kobo.405.1">, making it convenient for working with data originating from different </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">time zones.</span></span></p>
			<p><span class="koboSpan" id="kobo.407.1">In the next section, instead of treating dates and times, we shift our approach to splitting them into individual parts, such as days, months, </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">and years.</span></span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.409.1">Extracting components from dates and times</span></h2>
			<p><span class="koboSpan" id="kobo.410.1">You can</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.411.1"> extract specific components of a datetime object, such as year, month, day, hour, minute, or second, using the attributes provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">datetime module:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
df['Day'] = df['Timestamp'].dt.day
df['Month'] = df['Timestamp'].dt.month
df['Year'] = df['Timestamp'].dt.year</span></pre>			<p><span class="koboSpan" id="kobo.414.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">.dt</span></strong><span class="koboSpan" id="kobo.416.1"> accessor, we can extract the day, month, and year components from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">Timestamp</span></strong><span class="koboSpan" id="kobo.418.1"> column and create new columns, </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Day</span></strong><span class="koboSpan" id="kobo.420.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">Month</span></strong><span class="koboSpan" id="kobo.422.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Year</span></strong><span class="koboSpan" id="kobo.424.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">presented here:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
             Timestamp  Day  Month  Year
0  2022-01-01 08:30:45    1      1  2022
1  2022-01-02 14:20:30    2      1  2022</span></pre>			<p><span class="koboSpan" id="kobo.427.1">Extracting components is useful in the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">following cases:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.429.1">Temporal analysis</span></strong><span class="koboSpan" id="kobo.430.1">: If your </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.431.1">analysis involves patterns or trends that vary across days, months, or years, extracting these components facilitates a more </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">focused exploration.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.433.1">Grouping and aggregation</span></strong><span class="koboSpan" id="kobo.434.1">: When</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.435.1"> grouping data based on temporal patterns, extracting</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.436.1"> components allows for easy aggregation </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">and summarization.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.438.1">Time series analysis</span></strong><span class="koboSpan" id="kobo.439.1">: For</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.440.1"> time series analysis, breaking down datetime values into components is essential for understanding seasonality </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">and trends.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.442.1">Moving on to</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.443.1"> calculate time differences and durations elevates our exploration of temporal data by introducing a </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">dynamic dimension.</span></span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.445.1">Calculating time differences and durations</span></h2>
			<p><span class="koboSpan" id="kobo.446.1">When calculating</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.447.1"> the time difference between two datetime objects using subtraction, you harness the inherent capability of Python’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">datetime</span></strong><span class="koboSpan" id="kobo.449.1"> library to produce a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">timedelta</span></strong><span class="koboSpan" id="kobo.451.1"> object. </span><span class="koboSpan" id="kobo.451.2">This object </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.452.1">encapsulates the duration between the two timestamps, providing a comprehensive representation of the temporal gap in terms of days, hours, minutes, and seconds. </span><span class="koboSpan" id="kobo.452.2">The code for this section can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">here: </span></span><a href="https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/8.time_deltas.py"><span class="No-Break"><span class="koboSpan" id="kobo.454.1">https://github.com/PacktPublishing/Python-Data-Cleaning-and-Preparation-Best-Practices/blob/main/chapter04/8.time_deltas.py</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.455.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
df['TimeSincePreviousPurchase'] = df['Timestamp'].diff()</span></pre>			<p><span class="koboSpan" id="kobo.457.1">This pandas function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">.diff()</span></strong><span class="koboSpan" id="kobo.459.1">, calculates the difference between each element and the previous element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">Timestamp</span></strong><span class="koboSpan" id="kobo.461.1"> column. </span><span class="koboSpan" id="kobo.461.2">It effectively computes the time elapsed since the previous timestamp for </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">each row.</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
df['TimeUntilNextPurchase'] = -df['Timestamp'].diff(-1)</span></pre>			<p><span class="koboSpan" id="kobo.464.1">Similar to the first line, this computes the difference between each element and the following element in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Timestamp</span></strong><span class="koboSpan" id="kobo.466.1"> column. </span><span class="koboSpan" id="kobo.466.2">It calculates the time duration until the next timestamp. </span><span class="koboSpan" id="kobo.466.3">The negative sign is applied to reverse the sign of the time differences. </span><span class="koboSpan" id="kobo.466.4">This is done to get a positive representation of the time until the </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">next purchase.</span></span></p>
			<p><span class="koboSpan" id="kobo.468.1">Let’s see how the time delta is depicted in </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">the data:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
             Timestamp TimeSincePreviousPurchase TimeUntilNextPurchase
0  2022-01-01 08:30:45                       NaT       1 days 05:49:45
1  2022-01-02 14:20:30           1 days 05:49:45       1 days 05:54:40</span></pre>			<p><span class="koboSpan" id="kobo.471.1">If you are </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.472.1">wondering when it is a </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.473.1">good idea to consider adding some time differences in your data workflow, then read </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the following:</span></span></p>
			<ul>
				<li><strong class="bold"><span class="koboSpan" id="kobo.475.1">Time-based analysis</span></strong><span class="koboSpan" id="kobo.476.1">: Calculating</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.477.1"> time differences allows for analyzing the duration between events or timestamps. </span><span class="koboSpan" id="kobo.477.2">It helps quantify the time taken for different processes, activities, </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">or intervals.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.479.1">Performance measurement</span></strong><span class="koboSpan" id="kobo.480.1">: By </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.481.1">measuring the duration of tasks or events, you can evaluate performance metrics, such as response time, processing time, or time taken to complete an operation. </span><span class="koboSpan" id="kobo.481.2">This information can guide optimization efforts and identify areas </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">for improvement.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.483.1">Event sequencing</span></strong><span class="koboSpan" id="kobo.484.1">: By </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.485.1">comparing timestamps, you can determine the chronological order in which events occurred. </span><span class="koboSpan" id="kobo.485.2">This sequencing helps you understand the relationships between events and </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">their dependencies.</span></span></li>
				<li><strong class="bold"><span class="koboSpan" id="kobo.487.1">Service-level agreement (SLA) monitoring</span></strong><span class="koboSpan" id="kobo.488.1">: Time differences are useful for SLA monitoring. </span><span class="koboSpan" id="kobo.488.2">By</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.489.1"> comparing timestamps related to SLA metrics, such as response time or resolution time, you can ensure compliance with agreed-upon service levels. </span><span class="koboSpan" id="kobo.489.2">Monitoring time differences helps identify SLA breaches and take </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">appropriate actions.</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.491.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">.diff()</span></strong><span class="koboSpan" id="kobo.493.1"> method in pandas is primarily used to compute the difference between </span><em class="italic"><span class="koboSpan" id="kobo.494.1">consecutive</span></em><span class="koboSpan" id="kobo.495.1"> elements in a Series or DataFrame. </span><span class="koboSpan" id="kobo.495.2">While it’s straightforward to compute first-order differences (i.e., differences between adjacent elements), there are additional considerations and variations </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">to explore.</span></span></p>
			<h3><span class="koboSpan" id="kobo.497.1">Specifying time intervals</span></h3>
			<p><span class="koboSpan" id="kobo.498.1">You can </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.499.1">customize </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">.diff()</span></strong><span class="koboSpan" id="kobo.501.1"> to compute the difference between elements at a specific </span><em class="italic"><span class="koboSpan" id="kobo.502.1">time interval</span></em><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">This is achieved by passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">periods</span></strong><span class="koboSpan" id="kobo.505.1"> parameter to specify the number of elements </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">to shift:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
df['TimeDifference'] = df['Timestamp'].diff(periods=2)</span></pre>			<p><span class="koboSpan" id="kobo.508.1">Let’s observe the </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">following results:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
           Timestamp TimeSincePreviousPurchase TimeDifference2periods
0  2022-01-01 08:30:45                      NaT                   NaT
1  2022-01-02 14:20:30          1 days 05:49:45                   NaT
2  2022-01-03 20:15:10          1 days 05:54:40       2 days 11:44:25
3  2022-01-04 12:45:30          0 days 16:30:20       1 days 22:25:00</span></pre>			<p><span class="koboSpan" id="kobo.511.1">As you can see,</span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">.diff(periods=2)</span></strong><span class="koboSpan" id="kobo.513.1"> calculated the difference between each timestamp and the two positions before it. </span><span class="koboSpan" id="kobo.513.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">periods</span></strong><span class="koboSpan" id="kobo.515.1"> parameter allows you to specify the number of elements to shift when computing the difference. </span><span class="koboSpan" id="kobo.515.2">In this case, it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">periods=2</span></strong><span class="koboSpan" id="kobo.517.1">, but you can assign to it any value that makes sense for your </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">use case.</span></span></p>
			<h3><span class="koboSpan" id="kobo.519.1">Handling missing values</span></h3>
			<p><span class="koboSpan" id="kobo.520.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">.diff()</span></strong><span class="koboSpan" id="kobo.522.1"> method</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.523.1"> introduces a NaN for the first 2 elements when used with </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">diff(periods=2)</span></strong><span class="koboSpan" id="kobo.525.1"> since there are no previous elements to calculate the difference from. </span><span class="koboSpan" id="kobo.525.2">You can handle or fill in these missing values based on your specific </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">use case:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
df['TimeDifference'] = df['Timestamp']. </span><span class="koboSpan" id="kobo.527.2">diff(periods=2).fillna(0)</span></pre>			<p><span class="koboSpan" id="kobo.528.1">Let’s observe </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">the results:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.530.1">
             Timestamp TimeDiff2periods_nonulls TimeDifference2periods
0  2022-01-01 08:30:45                        0                    NaT
1  2022-01-02 14:20:30                        0                    NaT
2  2022-01-03 20:15:10          2 days 11:44:25        2 days 11:44:25
3  2022-01-04 12:45:30          1 days 22:25:00        1 days 22:25:00</span></pre>			<p><span class="koboSpan" id="kobo.531.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">fillna(0)</span></strong><span class="koboSpan" id="kobo.533.1"> replaced the NaN values </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.537.1">Moving </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.538.1">on from time differences and durations to time zones and daylight saving time, we’ll now address the nuances of handling temporal data across </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">different regions.</span></span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.540.1">Handling time zones and daylight saving time</span></h2>
			<p><span class="koboSpan" id="kobo.541.1">Handling time zones</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.542.1"> is key when dealing with data that spans multiple geographical regions or when accurate time representation is crucial. </span><span class="koboSpan" id="kobo.542.2">Time zones help standardize time across different locations, considering the offset from UTC due to geographic boundaries and daylight-saving time adjustments. </span><span class="koboSpan" id="kobo.542.3">In our example dataset, we’ll demonstrate how to handle time zones </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">using pandas:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
df['Timestamp_UTC'] = df['Timestamp'].dt.tz_localize('UTC')</span></pre>			<p><span class="koboSpan" id="kobo.545.1">We localized the timestamps to a specific time zone, in this </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">case, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">'UTC'</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">.</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.549.1">
df['Timestamp_NY'] = df['Timestamp_UTC'].dt.tz_convert('America/New_York')</span></pre>			<p><span class="koboSpan" id="kobo.550.1">We then converted the localized timestamps to a different time zone, in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">'America/New_York'</span></strong><span class="koboSpan" id="kobo.552.1">. </span><span class="koboSpan" id="kobo.552.2">Let’s observe the </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">following results:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
             Timestamp             Timestamp_UTC              Timestamp_NY
0  2022-01-01 08:30:45 2022-01-01 08:30:45+00:00 2022-01-01 03:30:45-05:00
1  2022-01-02 14:20:30 2022-01-02 14:20:30+00:00 2022-01-02 09:20:30-05:00</span></pre>			<p><span class="koboSpan" id="kobo.555.1">Curious about the significance of managing time zones? </span><span class="koboSpan" id="kobo.555.2">Let’s understand why </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">it matters:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.557.1">When working with data collected from different time zones, it is essential to handle time zones to ensure accurate analysis and interpretation. </span><span class="koboSpan" id="kobo.557.2">Without proper time zone handling, the analysis might be skewed due to inconsistencies in </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">time representation.</span></span></li>
				<li><span class="koboSpan" id="kobo.559.1">For applications that require precise time representation, such as financial transactions, log entries, or event tracking, handling time zones </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">becomes crucial.</span></span></li>
				<li><span class="koboSpan" id="kobo.561.1">When</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.562.1"> integrating data from various sources or merging datasets, handling time zones becomes necessary to align timestamps accurately. </span><span class="koboSpan" id="kobo.562.2">This ensures the correct chronological ordering of events and prevents inconsistencies in </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">time-based analysis.</span></span></li>
				<li><span class="koboSpan" id="kobo.564.1">If you are developing applications or services that serve users across different time zones, handling time zones is crucial for providing accurate and relevant information to users based on their </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">local time.</span></span></li>
			</ul>
			<p class="callout-heading"><span class="koboSpan" id="kobo.566.1">Considerations</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.567.1">Time zone handling should be implemented consistently throughout the data processing pipeline to avoid inconsistencies </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">or errors.</span></span></p>
			<p><span class="koboSpan" id="kobo.569.1">Let’s summarize the learnings from </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">this chapter.</span></span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.571.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.572.1">This chapter was about the techniques for cleaning and manipulating data. </span><span class="koboSpan" id="kobo.572.2">Beginning with the challenges of messy data, we covered the removal of irrelevant columns and the handling of inconsistent data types. </span><span class="koboSpan" id="kobo.572.3">Practical use cases were demonstrated with an e-commerce dataset, showcasing Python code for effective data transformations. </span><span class="koboSpan" id="kobo.572.4">The importance of dropping unnecessary columns was emphasized, highlighting potential cost reductions and memory efficiency gains, particularly for big data. </span><span class="koboSpan" id="kobo.572.5">Data type transformations, including numeric, string, categorical, and Boolean conversions, were illustrated with practical examples. </span><span class="koboSpan" id="kobo.572.6">The chapter then explored intricate aspects of working with dates and times, showcasing methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">pd.to_datetime()</span></strong><span class="koboSpan" id="kobo.574.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">strftime</span></strong><span class="koboSpan" id="kobo.576.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">dateutil.parser.parse()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.580.1">As we wrap up this chapter, it lays a solid foundation for the upcoming one in which data merging and transformations will </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">be discussed.</span></span></p>
		</div>
	</body></html>