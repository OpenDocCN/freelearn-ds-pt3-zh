- en: '*Chapter 3*: Data Visualization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization is fundamental to the modern data scientist. It is often the central
    lens used to understand items such as statistical models (for example, via an
    AUC chart), the distribution of a crucial variable (via a histogram), or even
    important business metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two chapters, we used the most popular Python graphing libraries
    (**Matplotlib** and **Seaborn**) in our examples. This chapter will focus on extending
    that ability to a broad range of Python graphing libraries, along with including
    some graphing functions native to Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should feel comfortable with using Streamlit's
    native graphing functions, and also using Streamlit's visualization functions
    to place graphs made from major Python visualization libraries in your own Streamlit
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: San Francisco Trees – A new dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit's built-in graphing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit's built-in visualization options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Importing Python visualization libraries into Streamlit. In this section, we
    will cover the following libraries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (a) **Plotly** (for interactive visualizations)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (b) **Seaborn+Matplotlib** (for classic statistical visualizations)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (c) **Bokeh** (for interactive visualization in web browsers)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (d) **Altair** (for declarative, interactive visualizations)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (e) **PyDeck** (for interactive map-based visualizations)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will be working with a new dataset that can be found at
    [https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/trees_app/trees.csv).
    A further explanation of the dataset can be found in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: San Francisco Trees – A new dataset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to be working with all sorts of graphs in this chapter, so we''re
    going to need a new dataset that has much more info, especially dates and locations.
    Enter *SF Trees*. The department of public works in San Francisco has a dataset
    (cleaned by the wonderful folks in the R community who run Tidy Tuesday, a weekly
    event where people publish interesting visualizations of new data each week) of
    every tree planted and maintained in the city of San Francisco. They cleverly
    call this dataset *EveryTreeSF – Urban Forest map*, and update this dataset every
    day. I have selected a random 10,000 trees with complete info and placed this
    data in the main GitHub repository under the `trees` folder (I''m not as clever
    as the data engineer in SF''s DPW, I know). The GitHub repo can be found at [https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps). If
    you would like to download the full dataset, the link is here: [https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq](https://data.sfgov.org/City-Infrastructure/Street-Tree-List/tkzw-k3nq).'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the main `streamlit_apps` folder we''ve been using throughout this book,
    start by making a new folder, making a new Python file, and then downloading our
    data into the folder, the same thing as we did in [*Chapter 2*](B16864_02_Final_VK_ePub.xhtml#_idTextAnchor024),
    *Uploading, Downloading, and Manipulating Data*, but just adding some new data!
    You can run the following code in your terminal to set this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I'll note here that if this does not work, or if you are on an operating system
    without these commands (such as Windows, for example), you can always go and download
    the CSV file directly by going to the GitHub repo mentioned in the preceding paragraph
    ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our setup, our next step is to open our `trees.py` file in
    our favorite editor and get to making our Streamlit app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will follow these exact same steps at the beginning of the rest of the chapters,
    so in the future, we will not cover these explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by titling our app and printing out some example rows using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the following command in our terminal and see the resulting
    Streamlit app in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is neither the easiest nor the best way to see the first few
    rows of a dataset, but we can do this purely because we already know that we''re
    going to build a Streamlit app using this data. The general workflow usually begins
    with some data exploration outside of Streamlit (in Jupyter notebooks, through
    SQL queries, or whatever the preferred workflow is for you as a data scientist
    or analyst). That said, let''s continue looking at our dataset by looking at the
    output of the preceding code in the new Streamlit app in our browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The first few rows of trees'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The first few rows of trees
  prefs: []
  type: TYPE_NORMAL
- en: This dataset contains a huge amount of info about the trees in SF, from their
    width (`dbh`) to the longitude and latitude points, the species, their address,
    and even the date they were planted. Before we get started with graphing, let's
    talk a bit about the visualization options in front of us.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit visualization use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Streamlit users are relatively experienced Python developers with well-tested
    workflows in visualization libraries of their choice. For these users, the best
    path forward is the one we've taken so far, which is to create our graphs in our
    library of choice (Seaborn, Matplotlib, Bokeh, and so on) and then use the appropriate
    Streamlit function to write this to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Other Streamlit users will have less experience in Pythonic graphing, and especially
    for these users, Streamlit offers a few built-in functions. We'll start with built-in
    libraries and move on to learning how to import the most popular and powerful
    libraries for our Streamlit apps.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit's built-in graphing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three built-in functions for graphing – `st.line_chart()`, `st.bar_chart()`,
    and `st.area_chart()`. They all work similarly by trying to figure out what variables
    you''re already trying to graph, and then put them into a line, bar, or area chart,
    respectively. In our dataset, we have a variable called `dbh`, which is the width
    of the tree at chest height. First, we can group our DataFrame by `dbh`, and then
    push that directly to the line chart, bar chart, and area chart. The following
    code should group our dataset by width, count the unique trees of each width,
    and then make a line, bar, and area chart of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should show our three graphs right after one another, as
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Lines, bars, area, and tree height'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Lines, bars, area, and tree height
  prefs: []
  type: TYPE_NORMAL
- en: We gave the function nothing except for the DataFrame, and it was able to guess
    correctly which items should be on the *x* and *y* axes and plot those to our
    Streamlit chart. Each of these charts is interactive by default! We can zoom in
    or out, roll out the mouse over points/bars/lines to see each data point, and
    even view fullscreen out of the box. These Streamlit functions are actually calling
    another popular graphing library called **Altair**, which we will learn how to
    use in more depth later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we see the basics of the built-in (it''s clear that the term *built-in*
    is fairly loose here, as Streamlit is built to be a great and convenient web application
    library, not a great visualization library) functions, let''s push these functions
    to see how they handle more data. First, we''re going to make a new column of
    random numbers between -500 and 500 in our `df_dbh_grouped` DataFrame using the
    `numpy` library and use the same plotting code that we used before. The following
    code plots two line charts, one before we added the new column, and one after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should produce an app that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Two sequential line charts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Two sequential line charts
  prefs: []
  type: TYPE_NORMAL
- en: Again, these functions put whatever is on the index as the *x* axis and use
    all the columns they can as variables on the *y* axis. These built-in functions
    are very useful if we have an incredibly straightforward graphing problem in front
    of us (as in the example). However, these visualization functions are, overall,
    less flexible in comparison to libraries with the sole purpose of visualization
    and it may be difficult to debug the behavior behind these functions. The recommendation
    here is that if you are working with data that is easy to massage into a format
    where the index of the DataFrame belongs on the *x* axis, and the rest of the
    columns are plotted on the *y* axis, these functions will work well. For more
    complicated tasks, we should use other graphing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more built-in Streamlit graphing function that we should discuss
    here, `st.map()`. Just like the preceding functions, this wraps around another
    Python graphing library, this time `st.map()` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This works perfectly well, right out of the box! We get a beautiful interactive
    map of the trees in San Francisco, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Default SF map of trees'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Default SF map of trees
  prefs: []
  type: TYPE_NORMAL
- en: As with the other functions, we don't have many options for customization here
    other than an optional zoom parameter, but this works very well for a quick visualization.
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen, these built-in functions can be useful for making Streamlit apps
    quickly, but we trade off speed for customizability. In practice, I rarely use
    these functions when I produce Streamlit apps, but often use these when doing
    quick visualizations of data already in Streamlit. In production, more powerful
    libraries, such as **Matplotlib**, **Seaborn**, and **PyDdeck**, give us the flexibility
    and customizability we want. The rest of this chapter will walk through six different
    popular Python visualization libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit's built-in visualization options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the rest of this chapter, we're going to run through the rest of the Streamlit
    visualization options, which are **Plotly**, **Matplotlib**, **Seaborn**, **Bokeh**,
    **Altair**, and **PyDeck**.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plotly is an interactive visualization library that many data scientists use
    for visualizing data in Jupyter, in the browser locally, or even hosting these
    graphs to be viewed on a platform for visualizations and dashboards created by
    the Plotly team called **Dash**. This library is very similar to Streamlit in
    its intent and is primarily used for internal or external dashboards (hence, the
    name Dash).
  prefs: []
  type: TYPE_NORMAL
- en: 'Streamlit allows us to call `plotly` graphs from within Streamlit apps using
    the `st.plotly_chart()` function, which makes it a breeze to port any Plotly or
    Dash dashboards. We''ll test this out by making a histogram of the height of the
    trees in SF, essentially the same graph that we''ve made before. The following
    code makes our Plotly histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ll notice, all the interactivity native to Plotly works by default in
    Streamlit. The user can scroll over the histogram bars and get the exact info
    about each one. There are a few other useful built-in features to Plotly that
    port over to Streamlit, such as the ability to zoom in and out, download the plot
    as a `png`, and select a group of data points/bars/lines. The full features can
    be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – First Plotly chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – First Plotly chart
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're comfortable with Plotly, we can move on to other popular visualization
    libraries, **Matplotlib** and **Seaborn**.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib and Seaborn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this book, we learned how to use the Matplotlib and Seaborn visualization
    libraries inside Streamlit, so we will just go over them briefly here. There is
    a column called **date** in the trees dataset that corresponds to the date that
    the tree was planted. We can use the datetime library to figure out the age of
    each tree in days, and plot that histogram using Seaborn and Matplotlib, respectively.
    The following code creates a new column called age, which is the difference in
    days between the tree planting date and today, and then graphs the histogram of
    the age using both Seaborn and Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we defined unique subplots for each graph, created a
    Seaborn or Matplotlib graph for each, and then used the `st.pyplot()` function
    to insert each graph in order onto our Streamlit app. The preceding code should
    show an app similar to the following screenshot (I say similar because, depending
    on when you run this, the age of the trees will be different as `pd.to_datetime`
    (''today'') will return your current date:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Seaborn and Matplotlib histograms'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Seaborn and Matplotlib histograms
  prefs: []
  type: TYPE_NORMAL
- en: Whether you use Seaborn or Matplotlib, you'll use the `st.pyplot()` function
    in the same way. Now that we're more comfortable with these libraries, we should
    learn about another interactive visualization library – **Bokeh**.
  prefs: []
  type: TYPE_NORMAL
- en: Bokeh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bokeh is another web-based interactive visualization library that also has dashboarding
    products built on top of it. It is a direct competitor to Plotly, but is more
    focused on the Python ecosystem, whereas Plotly is built on top of `Plotly.js`.
    Either way, Bokeh is an extremely popular Python visualization package that Python
    users may be very comfortable using.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call Bokeh graphs using the same format as Plotly. First, we create
    the Bokeh graph, and then we use the `st.bokeh_chart()` function to write the
    app to Streamlit. In Bokeh, we have to first instantiate a Bokeh figure object,
    and then change aspects of that figure before we plot it out. The important lesson
    here is that if we change an aspect of the Bokeh figure object after we call the
    `st.bokeh_chart()` function, we will not change the graph shown on the Streamlit
    app. For example, when we run the following code, we will not see a new *x* axis
    title at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead, we'll have to switch the order of the last two lines, which will now
    show up on our app. We'll add a *y* axis for good measure as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a Bokeh chart of `dbh` versus `site_order`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Bokeh scatterplot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Bokeh scatterplot
  prefs: []
  type: TYPE_NORMAL
- en: Now, onto our next visualization library – Altair!
  prefs: []
  type: TYPE_NORMAL
- en: Altair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already used `st.line_chart()` or `st.map()`, but now we'll explore how
    to use Altair directly. Altair is a declarative visualization library, which loosely
    means that instead of explicitly writing out each feature in a graph (such as
    naming *x* axes), we pass the relationships between the columns as desired, and
    Altair takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: We've made quite a few graphs with this dataset already, but why don't we explore
    a new column, the caretaker column? This bit of data defines who is in charge
    of the tree (public or private) and if public, what government organization is
    responsible for upkeep. Thrilling!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code groups our DataFrame by caretaker, and then uses that grouped
    DataFrame within Altair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Altair also allows us to summarize our data directly within the `y` value of
    `mark_bar()`, so we can simplify this by instead using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will create a Streamlit app showing the count of trees by
    caretaker in SF, shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Altair bar chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Altair bar chart
  prefs: []
  type: TYPE_NORMAL
- en: This should be it for traditional visualization libraries, but Streamlit also
    allows us to use more complex visualization libraries such as `st.map()` function
    and will explore this in more depth in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: PyDeck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyDeck is a visualization library that plots visualizations as layers on top
    of **Mapbox** (a mapping company with a truly exceptional free tier) maps. Both
    Streamlit and PyDeck have a base set of limited features available without signing
    up for a Mapbox account, but greatly expand their free features when we get a
    **Mapbox** token, which we will do in this next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to set up your own `config.toml`. To view our current settings, we
    can run the following command anywhere in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are four methods that Streamlit offers for changing our default configuration
    settings, I'll show you my recommended option and one of the other options, which
    should provide you with the majority of the use cases. If you find these options
    insufficient, the Streamlit documentation ([https://docs.streamlit.io/](https://docs.streamlit.io/))
    goes over all four options in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is to set global configuration options by directly editing
    the `config.toml` file. We can edit the file directly by opening it in our text
    editor. The following command will open the file in `sublime`. For other text
    editors (such as Vim and Atom), replace `''sublime''` with the appropriate command
    or open the file directly from the text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If this fails, it likely means that we do not have the file generated already.
    We can either copy and paste the output of `~/.streamlit/config.toml`, or we can
    run the following shortcut for Mac/Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the file opened in `sublime`, we can view and edit any of the
    options directly. This option is great for a config option such as a `8501 serverPort`.
    It would not make sense to change a global option for a project-specific change,
    which leads us to the second option.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to create and edit a project-specific `config.toml` file.
    Our previous config sets our default config options, while this option is specific
    per Streamlit app. Here is where our individual project folders within the `streamlit_apps`
    folder come in handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check our current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a config file for our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the config file within PyDeck.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our first step is to make sure our current working directory is the `trees_app`
    folder by running the `pwd` command in your terminal, which will show our current
    working directory and should end with `trees_app`' (for example, mine looks like
    `Users/tyler/Documents/streamlit_apps/trees_app`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make a config file just for our project. First, we will make
    a folder called `.streamlit`, and then we will repeat the Mac/Linux shortcut we
    used above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can then edit our config options just as we did before, but this will only
    be applicable to our Streamlit apps when we run Streamlit from that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, finally, we can go back to `37.77, -122.4`. We can do this using the following
    code, which first defines the initial state (where we want to start viewing the
    map), and then calls `st.pydeck_chart()` using that initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce a map of San Francisco, which we can use to layer on
    data points. We notice a couple of things here. First, that the black default
    map may be difficult to see, and second, that we need to spend time zooming in
    to San Francisco to get the view that we need. We can fix both these items by
    using the defaults suggested in the Streamlit documentation ([https://docs.streamlit.io/](https://docs.streamlit.io/)),
    as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should create a map that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – PyDeck mapping: SF base map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9 – PyDeck mapping: SF base map'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly what we want! We can see the entire `11` so we can see each
    point better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The best values for both the zoom and radius parameters are dependent on your
    visualization preferences. Try a few options out to see what looks the best. The
    preceding code will make the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Mapping SF trees'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_10.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Mapping SF trees
  prefs: []
  type: TYPE_NORMAL
- en: As with previous maps, this is interactive by default, so we can zoom into different
    parts of San Francisco to see where the places with the highest tree density are.
    For our next change to this map, we are going to add another layer, this time
    of hexagons, which will be colored based on the density of the trees in SF. We
    can use the same code as above, but change the scatterplot layer to a hexagon
    layer. We also will include the option to have the hexagon extrude vertically,
    which isn't necessary, but it is certainly a fun visualization style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last change is to change the pitch or the angle at which we are viewing
    the map. The default pitch, as we can see, is nearly directly down at the city,
    which will not work if we are trying to view vertical hexagons on our map. The
    following code implements each one of these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the previous map, the optimal radius and pitch parameters will change
    based on your visualizations. Try changing each one of these around a few times
    to see whether you can get the hang of it! The preceding code will produce the
    following app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Final San Francisco Trees map'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Final San Francisco Trees map
  prefs: []
  type: TYPE_NORMAL
- en: From this screenshot, we can see that **PyDeck** creates darker circles where
    there exists a higher density of trees in SF. We can observe from this many interesting
    details, such as the fact that the dataset seems to be missing trees from the
    famous Golden Gate Park on the west side of the city, and that the area around
    the Golden Gate Bridge also seems to have very few trees in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this chapter, you hopefully have a solid understanding of how to leverage
    the incredible open source Python visualization libraries to make web apps in
    Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned how to use the default visualization options, such as `st.line_chart()`
    and `st.map()`, and then we dove into interactive libraries such as Plotly, mapping
    libraries such as PyDeck, and everything in between.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will cover how to use machine learning in Streamlit.
  prefs: []
  type: TYPE_NORMAL
