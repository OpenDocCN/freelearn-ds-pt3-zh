<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Functions
                </header>
            
            <article>
                
<p>This chapter introduces functions, a fundamental building block in programming. We show how to define them, how to handle input and output, how to properly use them, and how to treat them as objects.</p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>Functions in mathematics and functions in Python</li>
<li>Parameters and arguments</li>
<li>Return values</li>
<li>Recursive functions</li>
<li>Function documentation</li>
<li>Functions are objects</li>
<li>Anonymous functions <span>–</span> the keyword <kbd>lambda</kbd></li>
<li>Functions as decorators</li>
</ul>
<h1 id="uuid-e6781b6f-1fa9-484e-a13d-5ca49f5e36c7">7.1 Functions in mathematics and functions in Python</h1>
<p>In mathematics, a function is written as a map that uniquely assigns to every element <span><img class="fm-editor-equation" src="assets/89f426e0-adb7-4ef9-b912-278993b26f35.png" style="width:0.83em;height:0.83em;"/></span> from the domain <em><img class="fm-editor-equation" src="assets/15cf5f8d-54c0-4464-8e43-130804048db7.png" style="width:0.92em;height:0.92em;"/></em> <span>a corresponding element</span> <span><img class="fm-editor-equation" src="assets/d900968b-92f1-4fdb-9c1c-438c64794e2b.png" style="width:0.58em;height:1.08em;"/></span> <span>from the range</span> <span><img class="fm-editor-equation" src="assets/196ecfe6-b8c8-4550-9f29-9b136a555cc7.png" style="width:0.75em;height:0.92em;"/>.</span></p>
<p>This is expressed by <em><img class="fm-editor-equation" src="assets/89d0dd79-9ade-4d44-b0eb-0626c808e581.png" style="width:4.50em;height:1.08em;"/>.</em></p>
<p>Alternatively, when considering particular elements <img class="fm-editor-equation" src="assets/e2fc557d-295f-4e14-88df-711e26a8f84f.png" style="width:0.67em;height:0.75em;"/> and <img class="fm-editor-equation" src="assets/632e9af1-ad40-45a1-ab58-0e09997f0262.png" style="width:0.50em;height:0.92em;"/>, you write <img class="fm-editor-equation" src="assets/5f74a00c-0ba1-4bf4-9ea2-6ba4bc30ac39.png" style="width:4.83em;height:1.33em;"/>.</p>
<p>Here, <span><img class="fm-editor-equation" src="assets/56d5d832-f148-4f4b-a6e1-e1f0fcc2652a.png" style="width:0.67em;height:1.33em;"/></span> is called the name of the function and <img class="fm-editor-equation" src="assets/3588ed47-5f38-428e-acf2-876c76dd8d16.png" style="width:2.17em;height:1.25em;"/> is its value when applied to <img class="fm-editor-equation" src="assets/a5117bc4-e31a-4d05-9465-f5b747caea99.png" style="width:0.83em;height:0.83em;"/>. Here, <em><img class="fm-editor-equation" src="assets/3435f1a2-4591-43ed-b9af-99edeb63de74.png" style="width:0.75em;height:0.92em;"/></em> is sometimes called the argument of <img class="fm-editor-equation" src="assets/ab2f2260-ab84-4410-9a3e-8902931eb19a.png" style="width:0.58em;height:1.00em;"/>. Let's first look at an example before considering functions in Python.</p>
<p>For example, <img class="fm-editor-equation" src="assets/31802895-c824-49de-9a09-bf24daaa65fb.png" style="width:4.67em;height:0.83em;"/> and <img class="fm-editor-equation" src="assets/f7efefb7-81ad-4118-9f5d-30133e021096.png" style="width:10.75em;height:1.25em;"/>. This function maps two real numbers to their difference.</p>
<p>In mathematics, functions can have numbers, vectors, matrices, and even other functions as arguments. Here is an example of a function with mixed arguments:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f736ebec-686e-4796-b4a9-f0d3d54ac072.png" style="width:12.33em;height:3.42em;"/></p>
<p>In this case, a real number is returned. When working with functions, we have to distinguish between two different steps:</p>
<ul>
<li>The definition of the function</li>
<li>The evaluation of the function, that is, the computation of <em><img class="fm-editor-equation" src="assets/c1ac1058-17b6-4c2d-ba2f-f8ce7303bde3.png" style="width:2.08em;height:1.33em;"/></em> for a given value of <span><em><img class="fm-editor-equation" src="assets/7bbf122b-e48d-4395-96df-d601e8dee3dc.png" style="width:0.75em;height:0.92em;"/></em></span></li>
</ul>
<p>The first step is done once, while the second can be performed many times for various arguments.</p>
<p>Functions in programming languages follow mainly the same concept and apply it to a wide range of types of input arguments, for example, strings, lists, floats, or simply any object. We demonstrate a definition of a function by considering the given example again:</p>
<pre>def subtract(x1, x2):
    return x1 - x2</pre>
<p>The keyword <kbd>def</kbd> indicates that we are going to define a function. <kbd>subtract</kbd> is the function’s name and <kbd>x1</kbd> and <kbd>x2</kbd> are its parameters. The colon indicates that we are using a block command. The value that is returned by the function follows the <span>keyword</span> <kbd>return</kbd><span>.</span></p>
<p>Now, we can evaluate this function. The function is called with its parameters replaced by input arguments:</p>
<pre>r = subtract(5.0, 4.3)</pre>
<p>The result <kbd>0.7</kbd> is computed and assigned to the variable <kbd>r</kbd>.</p>
<h1 id="uuid-4b5d3587-86a7-4c71-b9f6-f62a2c253eeb">7.2 Parameters and arguments</h1>
<p>When defining a function, its input variables are called the <em>parameters</em> of the function. The input used when executing the function is called its <em>argument</em>.</p>
<h2 id="uuid-7ec3f099-5d51-4743-bc73-dd977e18bb93">7.2.1 Passing arguments <span>–</span> by position and by keyword</h2>
<p>We will consider the previous example again, where the function takes two parameters, namely <kbd>x1</kbd> and <kbd>x2</kbd>.</p>
<p>Their names serve to distinguish the two numbers, which in this case cannot be interchanged without altering the result. The first parameter defines the number from which the second parameter is subtracted. When <kbd>subtract</kbd> is called, every parameter is replaced by an argument. Only the order of the arguments matters; the arguments can be any object. For instance, we may call the following:</p>
<pre>z = 3 
e = subtract(5,z)</pre>
<p>Besides this standard way of calling a function, which is bypassing the arguments by position, it might sometimes be convenient to pass arguments using keywords. The names of the parameters are the keywords; consider the following instance:</p>
<pre>z = 3 
e = subtract(x2 = z, x1 = 5)</pre>
<p>Here, the arguments are assigned to the parameters by name and not by position in the call. Both ways of calling a function can be combined so that the arguments given by position come first and the arguments given by keyword follow last. We show this by using the function <kbd>plot</kbd>, which was described in <a href="86c61820-e645-486c-9418-10079ffac7f8.xhtml"><span>Section 6.1</span></a>: <em>Basic plotting</em>:</p>
<pre>plot(xp, yp, linewidth = 2, label = 'y-values')</pre>
<h2 id="uuid-ce2e6785-7e38-4dae-aa8d-b7886d0e9b96">7.2.2 Changing arguments</h2>
<p>The purpose of parameters is to provide the function with the necessary input data. Changing the value of the parameter inside the function normally has no effect on its value outside the function:</p>
<pre>def subtract(x1, x2):
    z = x1 - x2
    x2 = 50.
    return z
a = 20.
b = subtract(10, a)    # returns -10
a    # still has the value 20</pre>
<p>This applies to all immutable arguments, such as strings, numbers, and tuples. The situation is different if mutable arguments, such as lists or dictionaries, are changed.</p>
<p>For example, passing mutable input arguments to a function and changing them inside the function can change them outside the function too:</p>
<pre>def subtract(x):
    z = x[0] - x[1]
    x[1] = 50.
    return z
a = [10,20]
b = subtract(a)    # returns -10
a    # is now [10, 50.0]</pre>
<p>Such a function misuses its arguments to return results. We strongly dissuade you from such constructions and recommend that you do not change input arguments inside the function (for more information, see <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.2.4</a>: <em>Default arguments</em>).</p>
<h2 id="uuid-a4114e42-8fba-4876-8112-4064b0906a10">7.2.3 Access to variables defined outside the local namespace</h2>
<p>Python allows functions to access variables defined in any of its enclosing program units. These are called global variables, in contrast to local variables. The latter is only accessible within the function. For example, consider the following code:</p>
<pre>import numpy as np # here the variable np is defined
def sqrt(x):
    return np.sqrt(x) # we use np inside the function</pre>
<p>This feature should not be abused. The following code is an example of what not to do:</p>
<pre>a = 3
def multiply(x):
    return a * x # bad style: access to the variable a defined outside</pre>
<p>When changing the variable <kbd>a</kbd><span>,</span> the function <kbd>multiply</kbd> tacitly changes its behavior:</p>
<pre>a=3
multiply(4)  # returns 12
a=4  
multiply(4)  # returns 16</pre>
<p>It is much better, in that case, to provide the variable as a parameter through the argument list:</p>
<pre>def multiply(x, a):
    return a * x</pre>
<p>Global variables can be useful when working with closures; see also the related example in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.7</a>: <em>Anonymous functions <span>– the</span></em> <em>keyword</em> <em>lambda</em><em>.</em></p>
<h2 id="uuid-b79093a4-a804-404a-9f51-b6eca76f2777">7.2.4 Default arguments</h2>
<p>Some functions can have many parameters, and among them, some might only be of interest in nonstandard situations. It would be practical if arguments could automatically be set to standard (default) values.</p>
<p>We demonstrate the use of default arguments by looking at the command <kbd>norm</kbd> in the <span>module</span> <kbd>scipy.linalg</kbd><span>. It computes various norms of matrices and vectors. More on matrix norms can be found in <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[10 ,§2.3]</a>.</span></p>
<p>The following calls for computing the Frobenius <strong>norm</strong> of the <span><img class="fm-editor-equation" src="assets/3966daf2-2ea1-4563-9c44-061c1042b7b3.png" style="width:2.25em;height:0.83em;"/></span> identity matrix are equivalent:</p>
<pre>import scipy.linalg as sl
sl.norm(identity(3))
sl.norm(identity(3), ord = 'fro')
sl.norm(identity(3), 'fro')</pre>
<p>Note that in the first call, no information about the <span>keyword</span> <kbd>ord</kbd> <span>is given. How does Python know that it should compute the Frobenius norm and not another norm,</span> <span>for example, the Euclidean 2-norm?</span></p>
<p>The answer to the previous question is the use of default values. A default value is a value already given by the function definition. If the function is called without providing this argument, Python uses the value that the programmer provided when the function was defined.</p>
<p>Suppose we call the function <kbd>subtract</kbd> <span>and provide it with</span> only one argument; we would get an error message:</p>
<pre>TypeError: subtract() takes exactly 2 arguments (1 given)</pre>
<p>To allow the omission of the argument <kbd>x2</kbd>, the definition of the function has to provide a <em>default value</em>, for example:</p>
<pre>def subtract(x1, x2 = 0): 
    return x1 - x2</pre>
<p>Default arguments are given in the definition of the function by assigning a value to one of the parameters.</p>
<p>To summarize, arguments can be given as positional arguments and keyword arguments. All positional arguments have to be given first. You do not need to provide all keyword arguments as long as those omitted arguments have default values in the function definition.</p>
<h3 id="uuid-4faf67dd-9008-4acc-8871-11301d50adca">Beware of mutable default arguments</h3>
<p>The default arguments are set upon function definition. Changing mutable arguments inside a function has a side effect when working with default values, for example:</p>
<pre>def my_list(x1, x2 = []):
    x2.append(x1)
    return x2
my_list(1)  # returns [1]
my_list(2)  # returns [1,2]</pre>
<p>Recall, lists are mutable objects.</p>
<h2 id="uuid-63eafe70-6bd1-46c1-bb3b-5bb0386db73a">7.2.5 Variable number of arguments</h2>
<p>Lists and dictionaries may be used to define or call functions with a variable number of arguments. Let's define a list and a dictionary as follows:</p>
<pre>data = [[1,2],[3,4]]    
style = dict({'linewidth':3,'marker':'o','color':'green'})</pre>
<p>Then we can call the <kbd>plot</kbd> function using starred (<kbd>*</kbd>) arguments:</p>
<pre>plot(*data,**style)</pre>
<p>A variable name prefixed by <kbd>*</kbd>, such as <kbd>*data</kbd> in the preceding example, means that a list that gets unpacked to provide the function with its arguments. In this way, a list generates positional arguments. Similarly, a variable name prefixed by <kbd>**</kbd>, such as <kbd>**style</kbd> in the example, unpacks a dictionary to keyword arguments; see <em>Figure 7.1</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/af27c774-d30e-4912-82c4-83562b036b9d.png" style="width:11.00em;height:7.58em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7.1: Starred arguments in function calls</div>
<p>You might also want to use the reverse process, where all given positional arguments are packed into a list and all keyword arguments are packed into a dictionary when passed to a function. In the function definition, this is indicated by parameters prefixed by <kbd>*</kbd> and <kbd>**</kbd>, respectively. You will often find the <span>parameters</span> <kbd>*args</kbd> <span>and</span> <kbd>**kwargs</kbd> <span>in code documentation; see</span> <em>Figure 7.2.</em></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/351df170-0fda-4879-a49e-9bf80d2526e8.png" style="width:21.25em;height:18.33em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 7.2: Starred arguments in function definitions</div>
<h1 id="uuid-371e0fe4-044b-4f9c-a2ce-0532c0c699d0">7.3 Return values</h1>
<p>A function in Python always returns a single object. If a function has to return more than one object, these are packed and returned as a single tuple object.</p>
<p>For instance, the following function takes a complex number <span><img class="fm-editor-equation" src="assets/0bac0f3d-d6ac-4268-a99e-0f971194689b.png" style="width:0.67em;height:0.83em;"/></span> and returns its polar coordinate representation as magnitude <span><img class="fm-editor-equation" src="assets/5530f0e2-5dac-46e6-9980-2221beb32362.png" style="width:0.50em;height:0.75em;"/></span> and angle <span><img class="fm-editor-equation" src="assets/7414aca2-5855-4e3b-9c08-d2f13de7acc3.png" style="width:0.75em;height:1.00em;"/></span>:</p>
<pre>def complex_to_polar(z):
    r = sqrt(z.real ** 2 + z.imag ** 2)
    phi = arctan2(z.imag, z.real)
    return (r,phi)  # here the return object is formedcite</pre>
<p>(See also Euler’s formula, <img class="fm-editor-equation" src="assets/de874ce0-e2fa-4001-9103-6dd2ec877c4a.png" style="width:3.83em;height:1.25em;"/>.)</p>
<p>Here, we used the <span>NumPy function</span> <kbd>sqrt(x)</kbd> <span>for the square root of a number</span> <kbd>x</kbd> <span>and</span> <kbd>arctan2(x,y)</kbd> <span>for the expression</span> <img style="font-size: 1em;width:5.67em;height:1.58em;" class="fm-editor-equation" src="assets/b3c0157c-8a54-45ae-99c2-05f5c7ef11d5.png"/><span>.</span></p>
<p>Let's try our function:</p>
<pre>z = 3 + 5j  # here we define a complex number
a = complex_to_polar(z)
r = a[0]
phi = a[1]</pre>
<p>The last three statements can be written more elegantly in a single line:</p>
<pre>r,phi = complex_to_polar(z)</pre>
<p>We can test our function by calling <kbd>polar_to_comp</kbd> defined in <em>Exercise 1</em> in the <em>Exercises</em> section.</p>
<p>If a function has no <kbd>return</kbd> statement, it returns the value <kbd>None</kbd>. There are many cases where a function does not need to return any value. This could be because the variables passed to a function may be subject to modification. Consider, for instance, the following function:</p>
<pre>def append_to_list(L, x):
    L.append(x)</pre>
<p>The preceding function does not return anything because it modifies one of the objects that is given as a mutable argument. There are many methods that behave in the same way. To mention the list methods only, the <span>methods</span> <kbd>append</kbd><span>,</span> <kbd>extend</kbd><span>,</span> <kbd>reverse</kbd><span>, and</span> <kbd>sort</kbd> <span>do not return anything (that is, they return</span> <kbd>None</kbd> <span>). When an object is modified by a method in this way, the modification is called</span> <em>in place</em><span>. It is difficult to know whether a method changes an object, except by looking at the code or the documentation.</span></p>
<p>Another reason for a function, or a method, not to return anything is when it prints out a message or writes to a file.</p>
<p>The execution stops at the first occurring <kbd>return</kbd> statement. Lines after that statement are dead code that will never be executed:</p>
<pre>def function_with_dead_code(x):
    return 2 * x
    y = x ** 2 # these two lines ...
    return y   # ... are never executed!</pre>
<h1 id="uuid-135f9e7f-660d-407f-972a-3429e473ba59">7.4 Recursive functions</h1>
<p>In mathematics, many functions are defined recursively. In this section, we will show how this concept can be used even when programming a function. This makes the relation of the program to its mathematical counterpart very clear, which may ease the readability of the program.</p>
<p>Nevertheless, we recommend using this programming technique with care, especially within scientific computing. In most applications, the more straightforward iterative approach is more efficient. This will become immediately clear from the following example.</p>
<p>Chebyshev polynomials are defined by a three-term recursion:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/599c7304-96a1-4b1c-8d58-e91f7d52874b.png" style="width:10.75em;height:1.00em;"/></p>
<p>Such a recursion needs to be initialized, that is, <em><sub><img class="fm-editor-equation" src="assets/a68a459e-835f-492b-84de-87e405fd258f.png" style="width:8.42em;height:1.00em;"/></sub>.</em></p>
<p>In Python, this <em>three-term recursion</em> can be realized by the following function definition:</p>
<pre>def chebyshev(n, x):
    if n == 0:
        return 1.
    elif n == 1:
        return x</pre>
<pre>    else:
        return 2. * x * chebyshev(n - 1, x) \
                      - chebyshev(n - 2 ,x)</pre>
<p>To compute <img class="fm-editor-equation" src="assets/30b7eadf-af02-468d-84cb-081ad13a56cb.png" style="width:3.25em;height:1.08em;"/>, the function is then called like this:</p>
<pre>chebyshev(5, 0.52) # returns 0.39616645119999994</pre>
<p>This example also illustrates the risk of dramatically wasting computation time. The number of function evaluations increases exponentially with the recursion level and most of these evaluations are just duplicates of previous computations. While it might be tempting to use recursive programs for demonstrating the strong relation between code and mathematical definition, production code will avoid this programming technique (see also <em>Exercise</em> <em>6 </em>in the <em>Exercises </em>section). We also refer to a technique called memoization that combines recursive programming with a caching technique to save replicated function evaluations, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[22]</a>.</p>
<p>A recursive function usually has a level parameter. In the previous example, it is <kbd>n</kbd><em>.</em> It is used to control the function's two main parts:</p>
<ul>
<li>The base case; here, the first two <kbd>if</kbd> branches</li>
<li>The recursive body, in which the function itself is called once or several times with smaller-level parameters</li>
</ul>
<p>The number of levels passed by the execution of a recursive function is called the recursion depth. This quantity should not be too large; otherwise, the computation might no longer be efficient and, in the ultimate case, the following error will be raised:</p>
<pre>RuntimeError: maximum recursion depth exceeded</pre>
<p>The maximal recursion depth depends on the memory of the computer you use. This error also occurs when the initialization step is missing in the function definition. We encourage the use of recursive programs for very small recursion depths only (for more information, see <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.7.2</a>: <em>Recursion</em>).</p>
<h1 id="uuid-55bdd69d-6e8f-4494-8d6e-4fe625bc12b9">7.5 Function documentation</h1>
<p>You should document your functions using a string at the beginning. This string is called a <em>docstring</em>:</p>
<pre>def newton(f, x0):
    """
    Newton's method for computing a zero of a function
    on input:
    f  (function) given function f(x)
    x0 (float) initial guess 
    on return:
    y  (float) the approximated zero of f
    """
    ...</pre>
<p>When calling <kbd>help(newton)</kbd>, you get this docstring displayed together with the call of this function:</p>
<pre>Help on function newton in module __main__:

newton(f, x0)
     Newton's method for computing a zero of a function
     on input:
     f  (function) given function f(x)
     x0 (float) initial guess
     on return:
     y  (float) the approximated zero of f</pre>
<p>The docstring is internally saved as an attribute, <kbd>__doc__</kbd>, of the given function. In the example, it is <kbd>newton.__doc__</kbd>. The minimal information you should provide in a docstring is the purpose of the function and the description of the input and output objects. There are tools to automatically generate full code documentation by collecting all docstrings in your program (for more information, see the documentation of Sphinx, <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[32]</a>).</p>
<h1 id="uuid-b8597a1a-b1cf-4f26-82d8-d3f2198d25cb">7.6 Functions are objects</h1>
<p>Functions are objects, like everything else in Python. You may pass functions as arguments, change their names, or delete them. For example:</p>
<pre>def square(x):
    """
    Return the square of x
    """
    return x ** 2
square(4) # 16
sq = square # now sq is the same as square
sq(4) # 16
del square # square doesn't exist anymore
print(newton(sq, .2)) # passing as argument</pre>
<p>Passing functions as arguments is very common when applying algorithms in scientific computing. The function <kbd>fsolve</kbd> in <kbd>scipy.optimize</kbd> for computing a zero of a given function or <kbd>quad</kbd> in <kbd>scipy.integrate</kbd> for computing integrals are typical examples.</p>
<p>A function itself can have a different number of arguments with differing types. So, when passing your function <kbd>f</kbd> to another function <kbd>g</kbd> as an argument, make sure that <kbd>f</kbd> has exactly the form described in the docstring of <kbd>g</kbd>.</p>
<p>The docstring of <kbd>fsolve</kbd> gives information about its parameter <kbd>func</kbd>:</p>
<pre> fun c -- A Python function or method which takes at least one
               (possibly vector) argument.</pre>
<h2 id="uuid-309e4518-8d9b-4dc0-a359-5454a2955758">7.6.1 Partial application</h2>
<p>Let's start with an example of a function with two variables.</p>
<p>The function <img class="fm-editor-equation" src="assets/9502da7b-86bf-48e3-8564-7821236cc621.png" style="width:14.17em;height:1.42em;"/> can be viewed as a function in two variables. Often you consider <img class="fm-editor-equation" src="assets/338903f2-95ad-4f1e-a84c-eafbfeb69218.png" style="width:0.83em;height:0.75em;"/> not as a free variable but as a fixed parameter of a family of functions <em><img class="fm-editor-equation" src="assets/eeaff405-ef7d-405b-8f02-e3bff86d22fb.png" style="width:1.08em;height:1.17em;"/></em>:</p>
<p class="CDPAlignCenter CDPAlign"><em><img class="fm-editor-equation" src="assets/61ae8234-2d80-4209-af59-a3d132be42cb.png" style="width:9.92em;height:1.25em;"/></em></p>
<p class="mce-root">This interpretation reduces a function in two variables to a function in one variable <img class="fm-editor-equation" src="assets/3be52ca7-be0d-413c-990e-475b16061773.png" style="width:0.50em;height:1.17em;"/> given a fixed parameter value <span><em><img class="fm-editor-equation" src="assets/49a1eac7-3ffe-48ef-9a3d-3f4b0cca152d.png" style="width:1.00em;height:0.92em;"/></em></span>. The process of defining a new function by fixing (freezing) one or several parameters of a function is called partial application.</p>
<p>Partial applications are easily created using the Python module <kbd>functools</kbd>, which provides a function called <kbd>partial</kbd> for precisely this purpose. We illustrate this by constructing a function that returns a sine for a given frequency:</p>
<pre>import functools <br/>def sin_omega(t, freq):<br/>    return sin(2 * pi * freq * t)<br/><br/>def make_sine(frequency):<br/>    return functools.partial(sin_omega, freq = frequency)<br/><br/>fomega=make_sine(0.25)<br/>fomega(3) # returns -1.0</pre>
<p>In the last line, the newly created function is evaluated at <img class="fm-editor-equation" src="assets/7dab2cdb-e183-49f4-a87d-9369f0a1240f.png" style="width:2.25em;height:0.83em;"/>.</p>
<h2 id="uuid-be9f256f-d952-4a80-a6b7-cb5ed9ecb7e6">7.6.2 Using closures</h2>
<p>Using the view that functions are objects, partial applications can be realized by writing a function, which itself returns a new function, with a reduced number of input arguments. For instance, the function <kbd>make_sine</kbd> could be defined as follows:</p>
<pre>def make_sine(freq):
    "Make a sine function with frequency freq"
    def mysine(t):
        return sin_omega(t, freq)
    return mysine</pre>
<p>In this example, the inner function <kbd>mysine</kbd> has access to the variable <kbd>freq</kbd>; it is neither a local variable of this function nor is it passed to it via the argument list. Python allows such a construction, see <a href="919d9596-6c84-492d-8b65-8f1045866d8e.xhtml"><span>S</span><span>ection</span></a> <span>13.1,</span> <em>Namespaces</em><span>.</span></p>
<h1 id="uuid-02844e20-812e-4b73-a0c6-b038530f1327">7.7 Anonymous functions <span>–</span> the keyword lambda</h1>
<p>The keyword <kbd>lambda</kbd> is used in Python to define anonymous functions, that is, functions without a name and described by a single expression. You might just want to perform an operation on a function that can be expressed by a simple expression without naming this function and without defining this function by a lengthy <kbd>def</kbd> block.</p>
<p class="mce-root">The name <em>lambda</em> originates from a special branch of calculus and mathematical logic, the <span><img class="fm-editor-equation" src="assets/8acb12a5-c98d-4653-ac41-9e4fba93f10a.png" style="width:0.67em;height:1.00em;"/></span>-calculus.</p>
<p>We demonstrate the use of <kbd>lambda</kbd>-functions by numerically evaluating the following integral:</p>
<p class="CDPAlignCenter CDPAlign"><img style="font-size: 1em;text-align: center;width:7.17em;height:3.33em;" class="fm-editor-equation" src="assets/f7b1ca59-f9c8-4ae1-965b-1fe67f6f9331.png"/></p>
<p>We use SciPy’s function <kbd>quad</kbd>, which requires as <span>its first argument</span> the function to be integrated and the integration bounds as the next two arguments. Here, the function to be integrated is just a simple one-liner and we use the <span>keyword</span> <kbd>lambda</kbd> <span>to define it:</span></p>
<pre>import scipy.integrate as si
si.quad(lambda x: x ** 2 + 5, 0, 1)</pre>
<p>The syntax is as follows:</p>
<pre>lambda parameter_list: expression</pre>
<p>The definition of the <span>function</span> <kbd>lambda</kbd> <span>can only consist of a single expression and, in particular, cannot contain loops.</span> <kbd>lambda</kbd> <span>functions are, just like other functions, objects and can be assigned to variables:</span></p>
<pre>parabola = lambda x: x ** 2 + 5
parabola(3) # gives 14</pre>
<h2 id="uuid-b89bb0e6-afa1-4a08-857c-5debc2cf64cd">7.7.1 The lambda construction is always replaceable</h2>
<p>It is important to note that the <kbd>lambda</kbd> construction is only syntactic sugar in Python. Any <kbd>lambda</kbd> construction may be replaced by an explicit function definition:</p>
<pre>parabola = lambda x: x**2+5 
# the following code is equivalent
def parabola(x):
    return x ** 2 + 5</pre>
<p>The main reason to use this construction is for very simple functions when a full function definition would be too cumbersome.</p>
<p><kbd>lambda</kbd> functions provide a third way to make closures as we demonstrate by continuing with the previous example, <sub><img class="fm-editor-equation" src="assets/c651f3a5-f426-4197-8b0c-52b7da0dfa85.png" style="width:7.75em;height:1.25em;"/></sub>.</p>
<p>We use the <span>function</span> <kbd>sin_omega</kbd> <span>from <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.6.1</a>, <em>Partial Application</em></span>, <span>to compute the integral of the sine function for various frequencies:</span></p>
<pre>import scipy.integrate as si
for iteration in range(3):
    print(si.quad(lambda x: sin_omega(x, iteration*pi), 0, pi/2.) )</pre>
<h1 id="uuid-92afd6b6-d0ef-47f7-9446-ca29aa6762eb">7.8 Functions as decorators</h1>
<p>In <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.6.1</a>: <em>Partial application</em>, we saw how a function can be used to modify another function. A <em>decorator</em> is a syntax element in Python that conveniently allows us to alter the behavior of a function without changing the definition of the function itself. Let's start with the following situation.</p>
<p>Assume that we have a function that determines tcitehe degree of sparsity of a matrix:</p>
<pre>def how_sparse(A):
    return len(A.reshape(-1).nonzero()[0])</pre>
<p>This function returns an error if it is not called with an array object as input. More precisely, it will not work with an object that does not implement the <span>method</span> <kbd>reshape</kbd><span>. For instance, the</span> <span>function</span> <kbd>how_sparse</kbd> <span>will not work with a list, because lists have no method</span> <kbd>reshape</kbd><span>. The following helper function modifies any function with one input parameter so that it tries to make a type conversion to an array:</span></p>
<pre>def cast2array(f):
    def new_function(obj):
        fA = f(array(obj))
        return fA
    return new_function</pre>
<p>Thus, the modified function <kbd>how_sparse = cast2array(how_sparse)</kbd> can be applied to any object that can be cast to an array. The same functionality is achieved if the definition of <kbd>how_sparse</kbd> is decorated with this type conversion function:</p>
<pre>@cast2array def how_sparse(A): return len(A.reshape(-1).nonzero()[0])</pre>
<p>To define a decorator, you need a callable object such as a function that modifies the definition of the function to be decorated. The main purposes are:</p>
<ul>
<li>To increase code readability by separating parts from a function that do not directly serve its functionality (<span>for example</span>, memoizing)</li>
<li>To put common preamble and epilogue parts of a family of similar functions in a common place (for example, type checking)</li>
<li>To be able to easily switch off and on additional functionalities of a function (<span>for example</span>, test prints or tracing)</li>
</ul>
<p>It is recommended also to consider <kbd>functools.wraps</kbd>,  see also <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[8]</a>.</p>
<h1 id="uuid-660d20ae-38e0-4bde-9199-511b2fbd200e">7.9 Summary</h1>
<p>Functions are not only the ideal tools for making your program modular, but they also reflect mathematical thinking. You learned the syntax of function definitions and how to distinguish between defining and calling a function.</p>
<p>We considered functions as objects that can be modified by other functions. When working with functions, it is important to be familiar with the notion of the scope of a variable and how information is passed into a function by parameters.</p>
<p>Sometimes, it is convenient to define functions on the fly with so-called anonymous functions. For this, we introduced the keyword <kbd>lambda</kbd>.</p>
<h1 id="uuid-06216acf-3f6c-45c9-8f41-046d0bb39850">7.10 Exercises</h1>
<p><strong>Ex 1:</strong> Write a function <kbd>polar_to_comp</kbd>, which takes two arguments <span><img class="fm-editor-equation" src="assets/e834ef4c-2926-4ad9-9504-de4b2234bc13.png" style="width:0.58em;height:0.83em;"/></span> and <img class="fm-editor-equation" src="assets/4f3160df-59d2-427a-b19a-51eb90212f65.png" style="width:0.58em;height:0.75em;"/> and returns the complex number <img class="fm-editor-equation" src="assets/6e1ade86-768c-4fe4-9963-7bde1348f589.png" style="width:4.50em;height:1.42em;"/>. Use the NumPy function <kbd>exp</kbd> for the exponential function.</p>
<p><strong>Ex 2</strong>: In the description of the Python module <kbd>functools</kbd>, <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[8]</a>, you find the following Python function:</p>
<pre>def partial(func, *args, **keywords):
    def newfunc(*fargs, **fkeywords):
        newkeywords = keywords.copy()
        newkeywords.update(fkeywords)
        return func(*(args + fargs), **newkeywords)
    newfunc.func = func
    newfunc.args = args
    newfunc.keywords = keywords
    return newfunc</pre>
<p>Explain and test this function.</p>
<p><strong>Ex 3</strong>: Write a decorator for the function <kbd>how_sparse</kbd>, which cleans the input matrix <kbd>A</kbd> by setting the elements that are less than <kbd>1.e-16</kbd> to zero (consider the example in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.8</a>: <em>Functions as decorators</em>).</p>
<p><strong>Ex 4:</strong> A continuous function <img class="fm-editor-equation" src="assets/edafb426-3175-4e5d-af76-2d21dc0acd01.png" style="width:0.58em;height:1.08em;"/> with <img class="fm-editor-equation" src="assets/3c9e124d-b89a-4263-ab14-04b3293dfaea.png" style="width:5.75em;height:1.33em;"/> changes its sign in the interval <img class="fm-editor-equation" src="assets/bff068a9-97e1-48a0-a3f5-3f16aa97fd84.png" style="width:2.25em;height:1.42em;"/> and has at least one root (zero) in this interval. Such a root can be found with the <em>bisection method</em>. This method starts from the given interval. Then it investigates the sign changes in the subintervals</p>
<p><img class="fm-editor-equation" src="assets/40f2d3ed-3d13-44bd-b5a0-7fe826182297.png" style="width:5.17em;height:2.75em;"/> and <img class="fm-editor-equation" src="assets/a4aff68c-105a-4e2e-93e1-a93487e3f53e.png" style="width:4.92em;height:2.67em;"/>.</p>
<p>If the sign changes in the first subinterval, <img class="fm-editor-equation" src="assets/aeb1a071-16be-4a0e-8dc7-06b3fb165cb3.png" style="width:0.58em;height:1.00em;"/> is redefined to be:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/55964a4d-c0f2-4cac-9220-584b8c3f556f.png" style="width:5.67em;height:2.67em;"/></p>
<p>Otherwise, it is redefined in the same manner to:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/da78bd63-e2ee-44d6-a9e2-7ce4c207a3b2.png" style="width:5.08em;height:2.33em;"/></p>
<p>The process is repeated until the length of the interval, <img class="fm-editor-equation" src="assets/ac340bd1-abae-44ba-b90f-af0835bce7e6.png" style="width:2.50em;height:1.08em;"/>, is less than a given tolerance.</p>
<ul>
<li>Implement this method as a function that takes as arguments:</li>
<li style="padding-left: 30px">The function <img class="fm-editor-equation" src="assets/1b4d26a9-8021-47fc-86c0-d9eba66e8ae3.png" style="width:0.58em;height:1.00em;"/></li>
<li style="padding-left: 30px">The initial interval <img class="fm-editor-equation" src="assets/d1d3fe72-5545-44ef-9b0c-f9eafcc6b766.png" style="width:2.33em;height:1.42em;"/></li>
<li style="padding-left: 30px">The tolerance</li>
<li>This function <kbd>bisec</kbd> should return the final interval and its midpoint.</li>
<li>Test the method with the function <kbd>arctan</kbd> and also with the polynomial <sub><em><img class="fm-editor-equation" src="assets/a44ef6a3-4361-4334-a506-8ed64ba6ac2d.png" style="width:6.17em;height:1.25em;"/></em></sub> in the interval <sub><img class="fm-editor-equation" src="assets/cfac34a9-ed11-43cb-ad61-45b93d31b3ce.png" style="width:3.58em;height:1.17em;"/></sub>, and alternatively in <sub><img class="fm-editor-equation" src="assets/11738e6a-23a2-47bc-a263-9bd5d72fa98b.png" style="width:3.75em;height:1.25em;"/></sub>.</li>
</ul>
<p><strong>Ex. 5:</strong> The greatest common divisor of two integers can be computed with <em>Euclid’s algorithm</em> described by the following recursion:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4a74e62b-aed2-4ba1-8520-8a46208dac88.png" style="width:23.25em;height:3.42em;"/></p>
<p>Write a function that computes the greatest common divisor of two integers. Write another function that computes the least common multiple of these numbers using the relation:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/31b854bc-725e-4380-8491-1321cefce918.png" style="width:11.50em;height:3.25em;"/></p>
<p><strong>Ex. 6</strong>: Study the recursive implementation of Chebyshev polynomials. Consider the example in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.4</a>: <em>Recursive functions</em>. Rewrite the program in a non-recursive way and study computation time versus polynomial degree (see also the <span>module</span> <kbd>timeit</kbd><span>).</span></p>


            </article>

            
        </section>
    </body></html>