<html><head></head><body>
  <div id="_idContainer084" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-182" class="chapterTitle">Visualization</h1>
    <p class="normal">Visualization is a critical component in exploratory data analysis, as well as presentations and applications. During exploratory data analysis, you are usually working alone or in small groups and need to create plots quickly to help you better understand your data. Visualizations can help you identify outliers and missing data, or they can spark other questions of interest that will lead to further analysis and more visualizations. This type of visualization is usually not done with the end user in mind. It is strictly to help you better your current understanding. The plots do not have to be perfect.</p>
    <p class="normal">When preparing visualizations for a report or application, a different approach must be used. You should pay attention to small details. Also, you usually will have to narrow down all possible visualizations to only the select few that best represent your data. Good data visualizations have the viewer enjoying the experience of extracting information. Almost like movies that viewers can get lost in, good visualizations will have lots of information that really sparks interest.</p>
    <p class="normal">Out of the box, pandas has the <code class="inlineCode">pd.Series.plot</code> and <code class="inlineCode">pd.DataFrame.plot</code> methods to help you quickly generate plots. These methods dispatch to a <em class="italic">plotting backend</em>, which by default is Matplotlib (<a href="https://matplotlib.org/"><span class="url">https://matplotlib.org/</span></a>).</p>
    <p class="normal">We will discuss different backends later in this chapter, but for now, let’s start by installing Matplotlib and PyQt5, which Matplotlib uses to draw plots:</p>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">python -m pip install matplotlib pyqt5
</code></code></pre>
    <p class="normal">All code samples in this chapter are assumed to be preceded by the following import:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
plt.ion()
</code></code></pre>
    <p class="normal">The previous command enables Matplotlib’s <em class="italic">interactive mode</em>, which will create and update your plots automatically every time a plotting command is executed. If, for whatever reason, you run a plotting command but no plot appears, you likely are in non-interactive mode (you can check this with <code class="inlineCode">matplotlib.pyplot.isinteractive()</code>), and you will need to explicitly call <code class="inlineCode">matplotlib.pyplot.show()</code> to make your plots appear.</p>
    <p class="normal">We are going to cover the following recipes in this chapter:</p>
    <ul>
      <li class="bulletList">Creating charts from aggregated data</li>
      <li class="bulletList">Plotting distributions of non-aggregated data</li>
      <li class="bulletList">Further plot customization with Matplotlib</li>
      <li class="bulletList">Exploring scatter plots</li>
      <li class="bulletList">Exploring categorical data</li>
      <li class="bulletList">Exploring continuous data</li>
      <li class="bulletList">Using seaborn for advanced plots</li>
    </ul>
    <h1 id="_idParaDest-183" class="heading-1">Creating charts from aggregated data</h1>
    <p class="normal">The pandas library makes it easy to visualize data in <code class="inlineCode">pd.Series</code> and <code class="inlineCode">pd.DataFrame</code> objects, using the <code class="inlineCode">pd.Series.plot</code> and <code class="inlineCode">pd.DataFrame.plot</code> methods, respectively. In this recipe we are going to start with relatively basic line, bar, area, and pie charts, while also seeing the high-level customization options pandas offers. While, these chart types are simple, using them effectively can be immensely helpful to explore your data, identify trends, and share your research with non-technical associates.</p>
    <p class="normal">It is important to note that these chart types expect your data to already be aggregated, which our sample data in this recipe will reflect. If you are working with data that is not yet aggregated, you will need to use techniques that you will encounter in <em class="chapterRef">Chapter 7</em>, <em class="italic">Reshaping DataFrames</em>, and <em class="chapterRef">Chapter 8</em>, <em class="italic">Group By</em>, or use the techniques shown in the <em class="italic">Using Seaborn for advanced plots</em> recipe later in this chapter.</p>
    <h2 id="_idParaDest-184" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a simple <code class="inlineCode">pd.Series</code> showing book sales over the course of a 7-day period. We are intentionally going to use row index labels of the form <em class="italic">Day n</em>, which will provide a good visual clue on the different chart types we create:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(
    (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)),
    name="book_sales",
    index=(f"Day {x + <span class="hljs-number">1</span>}" <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)),
    dtype=pd.Int64Dtype(),
)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Day 1     0
Day 2     1
Day 3     4
Day 4     9
Day 5    16
Day 6    25
Day 7    36
Name: book_sales, dtype: Int64
</code></code></pre>
    <p class="normal">A call to <code class="inlineCode">pd.Series.plot</code> without <a id="_idIndexMarker282"/>any arguments will produce a line chart, where the labels used on the <em class="italic">x</em>-axis come from the row index and the values on the <em class="italic">Y</em>-axis correspond to the data within the <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot()
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_01.png" alt=""/></figure>
    <p class="normal">A line chart treats our<a id="_idIndexMarker283"/> data as if it is completely continuous, yielding a visualization that appears to show values in between each day, even though that does not exist in our data. A better visualization for our <code class="inlineCode">pd.Series</code> would be a bar chart that displays each day discretely, which we can get just by passing the <code class="inlineCode">kind="bar"</code> argument to the <code class="inlineCode">pd.Series.plot</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="bar")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_02.png" alt=""/></figure>
    <p class="normal">Once again, the row index labels appear on the <em class="italic">X</em>-axis and the values appear on the <em class="italic">Y</em>-axis. This helps you read the visualization from left to right, but in some circumstances, you may find it easier<a id="_idIndexMarker284"/> to read values from top to bottom. In pandas, such a visualization would be considered a <em class="italic">horizontal bar chart</em>, which can be rendered by using the <code class="inlineCode">kind="barh"</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="barh")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_03.png" alt="A graph with blue bars"/></figure>
    <p class="normal">A <code class="inlineCode">kind="area"</code> argument will produce an area chart, which is like a line chart but fills in the area underneath the line:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="area")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_04.png" alt="A blue line graph with numbers"/></figure>
    <p class="normal">Last but not least, we have pie charts. Unlike all of the visualizations introduced so far, a pie chart does not <a id="_idIndexMarker285"/>have both an x- and a y-axis. Instead, each label from the row index represents a different slice of the pie, whose size is dictated by the associated value in our <code class="inlineCode">pd.Series</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="pie")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_05.png" alt="A pie chart with numbers and a number of days"/></figure>
    <p class="normal">When working with a <code class="inlineCode">pd.DataFrame</code>, the API through which you generate charts stays consistent, although you may find that you need to provide more keyword arguments to get the desired visualization.</p>
    <p class="normal">To see this in action, let’s extend our data to show both <code class="inlineCode">book_sales</code> and <code class="inlineCode">book_returns</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame({
    <span class="hljs-string">"book_sales"</span>: (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)),
    <span class="hljs-string">"book_returns"</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
}, index=(<span class="hljs-string">f"Day </span><span class="hljs-subst">{x + </span><span class="hljs-number">1</span><span class="hljs-subst">}</span><span class="hljs-string">"</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)))
df = df.convert_dtypes(dtype_backend=<span class="hljs-string">"numpy_nullable"</span>)
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">        book_sales   book_returns
Day 1   0            3
Day 2   1            2
Day 3   4            1
Day 4   9            0
Day 5   16           1
Day 6   25           2
Day 7   36           3
</code></code></pre>
    <p class="normal">Just like we saw with <code class="inlineCode">pd.Series.plot</code>, the default call to <code class="inlineCode">pd.DataFrame.plot</code> will give us a line plot, with each column represented by its own line:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot()
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_06.png" alt=""/></figure>
    <p class="normal">Once again, to turn this into a bar chart, you would just need to pass <code class="inlineCode">kind="bar"</code> to the plotting method:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"bar"</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_07.png" alt=""/></figure>
    <p class="normal">By default, pandas will present each column as a separate bar on the chart. If you wanted instead to stack the columns on top of one another, pass <code class="inlineCode">stacked=True</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"bar"</span>, stacked=<span class="hljs-literal">True</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_08.png" alt=""/></figure>
    <p class="normal">The same behavior can be seen with a horizontal bar chart. By default, the columns will not be stacked:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"barh"</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_09.png" alt=""/></figure>
    <p class="normal">But passing <code class="inlineCode">stacked=True</code> will place the bars on top of one another:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"barh"</span>, stacked=<span class="hljs-literal">True</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_10.png" alt=""/></figure>
    <p class="normal">When using a <code class="inlineCode">pd.DataFrame</code> with an area chart, the default behavior is to stack the columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"area"</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_11.png" alt=""/></figure>
    <p class="normal">To unstack, pass <code class="inlineCode">stacked=False</code> and include an <code class="inlineCode">alpha=</code> argument to introduce transparency. The value of this argument should be between 0 and 1, with values closer to 0 making the chart more transparent:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"area"</span>, stacked=<span class="hljs-literal">False</span>, alpha=<span class="hljs-number">0.5</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_12.png" alt=""/></figure>
    <h2 id="_idParaDest-185" class="heading-2">There’s more…</h2>
    <p class="normal">The examples in this recipe used the minimum amount of arguments to produce visuals. However, the plotting methods accept many more arguments to control things like titles, labels, colors, etc.</p>
    <p class="normal">If you want to add a title to your visualization, simply pass it as the <code class="inlineCode">title=</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Sales by Day"</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_13.png" alt=""/></figure>
    <p class="normal">The <code class="inlineCode">color=</code> argument can be used to change the color of the lines, bars, and markers in your chart. Color can be expressed using RGB hex codes (like <code class="inlineCode">#00008B</code> for dark blue) or by using a Matplotlib named color like <code class="inlineCode">seagreen</code> (<a href="https://matplotlib.org/stable/gallery/color/named_colors.html"><span class="url">https://matplotlib.org/stable/gallery/color/named_colors.html</span></a>):</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Sales by Day"</span>,
    color=<span class="hljs-string">"seagreen"</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_14.png" alt=""/></figure>
    <p class="normal">When working with a <code class="inlineCode">pd.DataFrame</code>, you can pass a dictionary to <code class="inlineCode">pd.DataFrame.plot</code> to control which columns should use which colors:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind=<span class="hljs-string">"</span><span class="hljs-string">bar"</span>,
    title=<span class="hljs-string">"Book Metrics"</span>,
    color={
        <span class="hljs-string">"book_sales"</span>: <span class="hljs-string">"slateblue"</span>,
        <span class="hljs-string">"book_returns"</span>: <span class="hljs-string">"#7D5260"</span>,
    }
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_15.png" alt=""/></figure>
    <p class="normal">The <code class="inlineCode">grid=</code> argument controls whether gridlines are shown or not:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Sales by Day"</span>,
    color=<span class="hljs-string">"teal"</span>,
    grid=<span class="hljs-literal">False</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_16.png" alt=""/></figure>
    <p class="normal">You can control how your <em class="italic">x</em> and <em class="italic">y</em> axes are labeled with the <code class="inlineCode">xlabel=</code> and <code class="inlineCode">ylabel=</code> arguments:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Sales by Day"</span>,
    color=<span class="hljs-string">"</span><span class="hljs-string">darkgoldenrod"</span>,
    grid=<span class="hljs-literal">False</span>,
    xlabel=<span class="hljs-string">"Day Number"</span>,
    ylabel=<span class="hljs-string">"Book Sales"</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_17.png" alt=""/></figure>
    <p class="normal">When working with a <code class="inlineCode">pd.DataFrame</code>, pandas will default to placing each column’s data on the same chart. However, you can easily generate separate charts with <code class="inlineCode">subplots=True</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Performance"</span>,
    grid=<span class="hljs-literal">False</span>,
    subplots=<span class="hljs-literal">True</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_18.png" alt=""/></figure>
    <p class="normal">With separate charts, the legend becomes superfluous. To toggle that off, simply pass <code class="inlineCode">legend=False</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Performance"</span>,
    grid=<span class="hljs-literal">False</span>,
    subplots=<span class="hljs-literal">True</span>,
    legend=<span class="hljs-literal">False</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_19.png" alt=""/></figure>
    <p class="normal">When using subplots, it is also worth noting that by default, the <em class="italic">x</em>-axis labels are shared, but the <em class="italic">y</em>-axis value ranges may differ. If you want the <em class="italic">y</em> axis to be shared, simply add <code class="inlineCode">sharey=True</code> to your method invocation:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind=<span class="hljs-string">"bar"</span>,
    title=<span class="hljs-string">"Book Performance"</span>,
    grid=<span class="hljs-literal">False</span>,
    subplots=<span class="hljs-literal">True</span>,
    legend=<span class="hljs-literal">False</span>,
    sharey=<span class="hljs-literal">True</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_20.png" alt=""/></figure>
    <p class="normal">When working with <code class="inlineCode">pd.DataFrame.plot</code>, the <code class="inlineCode">y=</code> argument can control which columns should be visualized, which can be helpful when you don’t want all of the columns to appear:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind=<span class="hljs-string">"barh"</span>,
    y=[<span class="hljs-string">"book_returns"</span>],
    title=<span class="hljs-string">"Book Returns"</span>,
    legend=<span class="hljs-literal">False</span>,
    grid=<span class="hljs-literal">False</span>,
    color=<span class="hljs-string">"</span><span class="hljs-string">seagreen"</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_21.png" alt=""/></figure>
    <p class="normal">As you can see, pandas has a wealth of options to control what is being displayed and how. While pandas makes a best effort at figuring out where and how to place all of these elements on your visual, it may not always get it right. Later in this chapter, the <em class="italic">Further plot customization with Matplotlib</em> recipe will show you how to more finely control the layout of your visualization.</p>
    <h1 id="_idParaDest-186" class="heading-1">Plotting distributions of non-aggregated data</h1>
    <p class="normal">Visualizations can be of immense help in recognizing patterns and trends in your data. Is your data normally distributed? Does it skew left? Does it skew right? Is it multimodal? While you may be able to work out the answers to these questions, a visualization can very easily highlight these patterns for you, yielding deeper insight into your data.</p>
    <p class="normal">In this recipe, we are going to see how easy pandas makes it to visualize the distribution of your data. Histograms are a very popular choice for plotting distributions, so we will start with them before showcasing the even more powerful <strong class="keyWord">Kernel Density Estimate</strong> (<strong class="keyWord">KDE</strong>) plot.</p>
    <h2 id="_idParaDest-187" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <code class="inlineCode">pd.Series</code> using 10,000 random records that are known to follow a normal distribution. NumPy can be used to easily generate this data:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">np.random.seed(<span class="hljs-number">42</span>)
ser = pd.Series(
    np.random.default_rng().normal(size=<span class="hljs-number">10_000</span>),
    dtype=pd.Float64Dtype(),
)
ser
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">0       0.049174
1      -1.577584
2      -0.597247
3        -0.0198
4       0.938997
         ...   
9995   -0.141285
9996    1.363863
9997   -0.738816
9998   -0.373873
9999   -0.070183
Length: 10000, dtype: Float64
</code></code></pre>
    <p class="normal">A histogram can be <a id="_idIndexMarker286"/>used to plot this data with the <code class="inlineCode">kind="hist"</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="hist")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_22.png" alt="A blue graph with numbers"/></figure>
    <p class="normal">Rather than attempting to plot every single point, the histogram places our values into an automatically generated number of “bins.” The range of each bin is plotted along the <em class="italic">X</em>-axis of the visualization, with the count of occurrences within each bin appearing on the y-axis of the histogram.</p>
    <p class="normal">Since we have created the data we are visualizing, we already know that we have a normally distributed set of numbers, and the preceding histogram hints at that as well. However, we can elect to visualize a different number of bins by providing a <code class="inlineCode">bins=</code> argument to <code class="inlineCode">pd.Series.plot</code>, which can have a significant impact on the visualization and how it is interpreted.</p>
    <p class="normal">To illustrate, if we<a id="_idIndexMarker287"/> were to pass <code class="inlineCode">bins=2</code>, we would have so few bins that our normal distribution would not be obvious:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="hist", bins=<span class="hljs-number">2</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_23.png" alt=""/></figure>
    <p class="normal">On the flip side, passing <code class="inlineCode">bins=100</code> makes it clear that we generally have a normal distribution:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="hist", bins=<span class="hljs-number">100</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_24.png" alt="A blue graph with numbers  Description automatically generated"/></figure>
    <p class="normal">This same issue is apparent when making a histogram from a <code class="inlineCode">pd.DataFrame</code>. To illustrate, let’s create a <code class="inlineCode">pd.DataFrame</code> with two columns, where one column is normally distributed and the other uses a triangular distribution:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">np.random.seed(<span class="hljs-number">42</span>)
df = pd.DataFrame({
    <span class="hljs-string">"normal"</span>: np.random.default_rng().normal(size=<span class="hljs-number">10_000</span>),
    <span class="hljs-string">"triangular"</span>: np.random.default_rng().triangular(-<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, size=<span class="hljs-number">10_000</span>),
})
df = df.convert_dtypes(dtype_backend=<span class="hljs-string">"numpy_nullable"</span>)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    normal     triangular
0  -0.265525   -0.577042
1   0.327898   -0.391538
2  -1.356997   -0.110605
3   0.004558    0.71449
4   1.03956     0.676207
</code></code></pre>
    <p class="normal">The basic plotting call to <code class="inlineCode">pd.DataFrame.plot</code> will produce a chart that looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"</span><span class="hljs-string">hist"</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_25.png" alt=""/></figure>
    <p class="normal">Unfortunately, the bins from one distribution overlap with the bins of the other. You can solve this by either introducing some transparency:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"hist"</span>, alpha=<span class="hljs-number">0.5</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_26.png" alt=""/></figure>
    <p class="normal">Or generating subplots:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"hist"</span>, subplots=<span class="hljs-literal">True</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_27.png" alt=""/></figure>
    <p class="normal">At first glance, these distributions look pretty much the same, but using more bins reveals that they are not:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"hist"</span>, alpha=<span class="hljs-number">0.5</span>, bins=<span class="hljs-number">100</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_28.png" alt=""/></figure>
    <p class="normal">While the histogram<a id="_idIndexMarker288"/> is commonly used, the fact that the choice of binning can have an impact on the interpretation of the data is rather unfortunate; you would not want your interpretation of the data to change just from picking the “wrong” number of bins!</p>
    <p class="normal">Fortunately, there is a similar but arguably more powerful visualization you can use that does not require you to choose any type of binning strategy, known as the <strong class="keyWord">Kernel Density Estimate</strong> (or <strong class="keyWord">KDE</strong>) plot. To use this plot, you will need to have SciPy installed:</p>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">python -m pip install scipy
</code></code></pre>
    <p class="normal">After installing SciPy, you can simply pass <code class="inlineCode">kind="kde"</code> to <code class="inlineCode">pd.Series.plot</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser.plot(kind="kde")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_29.png" alt="A blue line graph with numbers  Description automatically generated"/></figure>
    <p class="normal">With our <code class="inlineCode">pd.DataFrame</code>, the KDE plot makes it clear that we have two distinct distributions:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(kind=<span class="hljs-string">"kde"</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_30.png" alt=""/></figure>
    <h1 id="_idParaDest-188" class="heading-1">Further plot customization with Matplotlib</h1>
    <p class="normal">For very simple <a id="_idIndexMarker289"/>plots, the default layouts may suffice, but you<a id="_idIndexMarker290"/> will inevitably run into cases where you need to further tweak the generated visualization. To go beyond the out-of-the-box features in pandas, it is helpful to understand some Matplotlib terminology. In Matplotlib, the <em class="italic">figure</em> refers to the drawing area, and an <em class="italic">axes</em> or <em class="italic">subplot</em> is the region on that figure that you can draw upon. Be careful not to confuse an <strong class="keyWord">axes</strong>, which is an area for plotting data, with an <strong class="keyWord">axis</strong>, which refers to the <em class="italic">X</em>- or <em class="italic">Y</em>-axis.</p>
    <h2 id="_idParaDest-189" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start with a <code class="inlineCode">pd.Series</code> of our book sales data and try to plot it three different ways on the same figure – once as a line chart, once as a bar chart, and once as a pie chart. To set up our drawing area, we will make a call to <code class="inlineCode">plt.subplots(nrows=1, ncols=3)</code>, essentially telling matplotlib how many rows and columns of visualizations we want in our drawing area. This will return a two-tuple containing the figure itself and a sequence of the individual Axes objects that we can plot against. We will unpack this into two variables, <code class="inlineCode">fig</code> and <code class="inlineCode">axes</code>, respectively.</p>
    <p class="normal">Because we asked for one row and three columns, the length of the returned <code class="inlineCode">axes</code> sequence will be three. We can pass the individual Axes we want pandas to plot on to the <code class="inlineCode">ax=</code> argument of <code class="inlineCode">pd.DataFrame.plot</code>. Our first attempt at drawing all of these plots should look as <a id="_idIndexMarker291"/>follows, generating <a id="_idIndexMarker292"/>a result that is, well, hideous:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ser = pd.Series(
    (x ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)),
    name="book_sales",
    index=(f"Day {x + <span class="hljs-number">1</span>}" <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>)),
    dtype=pd.Int64Dtype(),
)
fig, axes = plt.subplots(nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">3</span>)
ser.plot(ax=axes[<span class="hljs-number">0</span>])
ser.plot(kind="bar", ax=axes[<span class="hljs-number">1</span>])
ser.plot(kind="pie", ax=axes[<span class="hljs-number">2</span>])
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_31.png" alt=""/></figure>
    <p class="normal">Because we did not tell it any different, Matplotlib gives us three equally sized axes objects to draw upon. However, this makes the line/bar charts above very tall and skinny, and we end<a id="_idIndexMarker293"/> up <a id="_idIndexMarker294"/>producing a ton of wasted space above and below the pie chart.</p>
    <p class="normal">To control this more finely, we can use the Matplotlib <code class="inlineCode">GridSpec</code> to create a 2x2 grid. With that, we can place our bar and line charts side by side in the first row, and then we can make the pie chart take up the entire second row:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">from</span> matplotlib.gridspec <span class="hljs-keyword">import</span> GridSpec
 
fig = plt.figure()
gs = GridSpec(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figure=fig)
ax0 = fig.add_subplot(gs[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])
ax1 = fig.add_subplot(gs[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])
ax2 = fig.add_subplot(gs[<span class="hljs-number">1</span>, :])
ser.plot(ax=ax0)
ser.plot(kind="bar", ax=ax1)
ser.plot(kind="pie", ax=ax2)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_32.png" alt="A graph and pie chart  Description automatically generated"/></figure>
    <p class="normal">That looks a little <a id="_idIndexMarker295"/>better, but<a id="_idIndexMarker296"/> now, we still have an issue with the labels of the pie chart overlapping the <em class="italic">X</em>-axis labels of our bar chart. Fortunately, we can still modify each axes object individually to rotate labels, remove labels, change titles, etc.</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">from</span> matplotlib.gridspec <span class="hljs-keyword">import</span> GridSpec
fig = plt.figure()
fig.suptitle("Book Sales Visualized <span class="hljs-keyword">in</span> Different Ways")
gs = GridSpec(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figure=fig, hspace=<span class="hljs-number">.5</span>)
ax0 = fig.add_subplot(gs[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>])
ax1 = fig.add_subplot(gs[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])
ax2 = fig.add_subplot(gs[<span class="hljs-number">1</span>, :])
ax0 = ser.plot(ax=ax0)
ax0.set_title("Line chart")
ax1 = ser.plot(kind="bar", ax=ax1)
ax1.set_title("Bar chart")
ax1.set_xticklabels(ax1.get_xticklabels(), rotation=<span class="hljs-number">45</span>)
<span class="hljs-comment"># Remove labels from chart and show in custom legend instead</span>
ax2 = ser.plot(kind="pie", ax=ax2, labels=<span class="hljs-literal">None</span>)
ax2.legend(
    ser.index,
    bbox_to_anchor=(<span class="hljs-number">1</span>, -<span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>),  <span class="hljs-comment"># put legend to right of chart</span>
    prop={"size": <span class="hljs-number">6</span>}, <span class="hljs-comment"># set font size for legend</span>
)
ax2.set_title("Pie Chart")
ax2.set_ylabel(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># remove book_sales label</span>
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_33.png" alt="A graph and pie chart  Description automatically generated"/></figure>
    <p class="normal">There is no limit to the <a id="_idIndexMarker297"/>amount <a id="_idIndexMarker298"/>of customization that can be done to charts via Matplotlib, and unfortunately, we cannot hope to even scratch the surface in this book. If you have a keen interest in visualizations, I highly encourage you to read the Matplotlib documentation or find a dedicated book on the topic. However, many users who just want to see their data may find the amount of customizations burdensome to handle. For those users (myself included), there are, thankfully, higher-level plotting packages like seaborn, which can produce better-looking charts with minimal extra effort. The <em class="italic">Using seaborn for advanced plots</em> recipe later in this chapter will give you an idea of just how useful that package can be.</p>
    <h1 id="_idParaDest-190" class="heading-1">Exploring scatter plots</h1>
    <p class="normal">Scatter plots are<a id="_idIndexMarker299"/> one of the most powerful types of visualizations that you can create. In a very compact area, a scatter plot can help you visualize the relationship between two variables, measure the scale of individual data points, and even see how these relationships and scales may vary within different categories. Being able to effectively visualize data in a scatter plot represents a significant leap in analytical capabilities when lined up against some of the more commonplace visualizations we have seen so far.</p>
    <p class="normal">In this recipe, we will explore how we can measure all of these things at once just on one scatter plot.</p>
    <h2 id="_idParaDest-191" class="heading-2">How to do it</h2>
    <p class="normal">Scatter plots by definition measure the relationship of at least two variables. As such, the scatter plot can only be created with a <code class="inlineCode">pd.DataFrame</code>. A <code class="inlineCode">pd.Series</code> simply does not have enough variables.</p>
    <p class="normal">With that said, let’s create a sample <code class="inlineCode">pd.DataFrame</code> that contains four different columns of data. Three of these columns are continuous variables, and the fourth is a color that we will eventually use to categorize different data points:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame({
    "var_a": [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
    "var_b": [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>],
    "var_c": [<span class="hljs-number">500</span>, <span class="hljs-number">200</span>, <span class="hljs-number">600</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>],
    "var_d": ["blue", "orange", "gray", "blue", "gray"],
})
df = df.convert_dtypes(dtype_backend="numpy_nullable")
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    var_a  var_b  var_c  var_d
0   1      1      500    blue
1   2      2      200    orange
2   3      4      600    gray
3   4      8      100    blue
4   5      16     400    gray
</code></code></pre>
    <p class="normal">Alongside <code class="inlineCode">kind="scatter"</code>, we will want to explicitly control what gets plotted on the <em class="italic">X</em>-axis, what gets plotted on the <em class="italic">Y</em>-axis, how big a given data point should be, and what color a given data point should appear as. These are controlled via the <code class="inlineCode">x=</code>, <code class="inlineCode">y=</code>, <code class="inlineCode">s=</code>, and <code class="inlineCode">c=</code> arguments, respectively:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind="scatter",
    x="var_a",
    y="var_b",
    s="var_c",
    c="var_d",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_34.png" alt=""/></figure>
    <p class="normal">A simple scatter <a id="_idIndexMarker300"/>plot like this is not very interesting, but now that we have the basics down, let’s try out a more realistic dataset. The United States Department of Energy releases annual reports (<a href="https://www.fueleconomy.gov/feg/download.shtml"><span class="url">https://www.fueleconomy.gov/feg/download.shtml</span></a>) that summarize the results of detailed fuel economy testing for vehicles sold in the United States. This book includes a local copy of that dataset covering the model years 1985–2025.</p>
    <p class="normal">For now, let’s just read in a select few columns that are of interest to us, namely <code class="inlineCode">city08</code> (city miles-per-gallon), <code class="inlineCode">highway08</code> (highway miles-per-gallon), <code class="inlineCode">VClass</code> (compact car, SUV, etc). <code class="inlineCode">fuelCost08</code> (annual fuel cost), and the model <code class="inlineCode">year</code> of each vehicle (for a full definition of terms included with this dataset, refer to <a href="https://www.fueleconomy.gov"><span class="url">www.fueleconomy.gov</span></a>):</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.read_csv(
    "data/vehicles.csv.<span class="hljs-built_in">zip</span>",
    dtype_backend="numpy_nullable",
    usecols=["city08", "highway08", "VClass", "fuelCost08", "year"],
)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">   city08    fuelCost08   highway08    VClass           year
0      19         2,450          25    Two Seaters      1985
1       9         4,700          14    Two Seaters      1985
2      23         1,900          33    Subcompact Cars  1985
3      10         4,700          12    Vans             1985
4      17         3,400          23    Compact Cars     1993
</code></code></pre>
    <p class="normal">This dataset<a id="_idIndexMarker301"/> includes many different vehicle classes, so to keep our analysis focused, for now, we are just going to look at different classes of cars from 2015 onwards. Trucks, SUVs, and vans can be saved for another analysis:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">car_classes = (
    "Subcompact Cars",
    "Compact Cars",
    "Midsize Cars",
    "Large Cars",
    "Two Seaters",
)
mask = (df["year"] &gt;= <span class="hljs-number">2015</span>) &amp; df["VClass"].isin(car_classes)
df = df[mask]
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       city08   fuelCost08   highway08    VClass             year
27058      16        3,400          23    Subcompact Cars    2015
27059      20        2,250          28    Compact Cars       2015
27060      26        1,700          37    Midsize Cars       2015
27061      28        1,600          39    Midsize Cars       2015
27062      25        1,800          35    Midsize Cars       2015
</code></code></pre>
    <p class="normal">A scatter plot can be used to help us answer a question like, <em class="italic">What is the relationship between city miles-per-gallon and highway miles-per-gallon?</em> by plotting these columns on the <em class="italic">X</em>- and <em class="italic">Y</em>-axis:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind="scatter",
    x="city08",
    y="highway08",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_35.png" alt=""/></figure>
    <p class="normal">Perhaps not<a id="_idIndexMarker302"/> surprisingly, there is a strong linear trend. Chances are that the better mileage a vehicle gets on city roads, the better mileage it will get on highways.</p>
    <p class="normal">Of course, we still see a rather large spread in values; many vehicles are clustered down in the range of 10–35 MPG, but some exceed 100. To dive in a little further, we can assign colors to each of our vehicle classes and add them to the visualization.</p>
    <p class="normal">There are quite a few ways to do this, but one of the generally best approaches is to ensure that the value you would like to use for a color is a categorical data type:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">classes_ser = pd.Series(car_classes, dtype=pd.StringDtype())
cat = pd.CategoricalDtype(classes_ser)
df["VClass"] = df["VClass"].astype(cat)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">       city08  fuelCost08  highway08  VClass           year
27058  16      3,400       23         Subcompact Cars  2015
27059  20      2,250       28         Compact Cars     2015
27060  26      1,700       37         Midsize Cars     2015
27061  28      1,600       39         Midsize Cars     2015
27062  25      1,800       35         Midsize Cars     2015
</code></code></pre>
    <p class="normal">With that out of the<a id="_idIndexMarker303"/> way, you can pass the categorical column to the <code class="inlineCode">c=</code> argument of <code class="inlineCode">pd.DataFrame.plot</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind="scatter",
    x="city08",
    y="highway08",
    c="VClass",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_36.png" alt="A graph of different sizes and colors  Description automatically generated with medium confidence"/></figure>
    <p class="normal">Adding a <code class="inlineCode">colormap=</code> argument<a id="_idIndexMarker304"/> may help to visually discern data points. For a list of acceptable values for this argument, please refer to the Matplotlib documentation (<a href="https://matplotlib.org/stable/users/explain/colors/colormaps.html"><span class="url">https://matplotlib.org/stable/users/explain/colors/colormaps.html</span></a>):</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind="scatter",
    x="city08",
    y="highway08",
    c="VClass",
    colormap="Dark2",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_37.png" alt=""/></figure>
    <p class="normal">From these graphs alone, we can theorize a few things. There are not that many “Two Seaters,” but when <a id="_idIndexMarker305"/>there are, they tend to do poorly on both city and highway mileage. “Midsize Cars” appear to dominate the 40–60 MPG ranges, but as you look at the vehicles that produce 100 MPG or better on both highways or cities, “Large Cars” and “Midsize Cars” both appear to be reasonably represented.</p>
    <p class="normal">So far, we have used the <em class="italic">X</em>-axis, <em class="italic">Y</em>-axis, and color of our scatter plot to dive into data, but we can take this one step further and size each data point by fuel cost, passing <code class="inlineCode">fuelCost08</code> as the <code class="inlineCode">s=</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.plot(
    kind="scatter",
    x="city08",
    y="highway08",
    c="VClass",
    colormap="Dark2",
    s="fuelCost08",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_38.png" alt="A graph of a line of colorful circles  Description automatically generated with medium confidence"/></figure>
    <p class="normal">The size of the individual bubbles here is likely too large to be useful. Our fuel economy column has values that are <a id="_idIndexMarker306"/>in the range of thousands, which creates too large of a plot area to be useful. Simply scaling those values can quickly get us to a more reasonable-looking visualization; here, I have chosen to divide by 25 and introduce some transparency with the <code class="inlineCode">alpha=</code> argument to get a more pleasing graph:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.assign(
    scaled_fuel_cost=<span class="hljs-keyword">lambda</span> x: x["fuelCost08"] / <span class="hljs-number">25</span>,
).plot(
    kind="scatter",
    x="city08",
    y="highway08",
    c="VClass",
    colormap="Dark2",
    s="scaled_fuel_cost",
    alpha=<span class="hljs-number">0.4</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_39.png" alt=""/></figure>
    <p class="normal">The general trend of larger circles appearing toward the origin confirms that, generally, vehicles with worse mileage have a higher annual fuel cost. You may find individual points on this scatter <a id="_idIndexMarker307"/>plot where a relatively higher mileage still has a higher fuel cost compared to other vehicles with a similar range, likely due to different fuel type requirements.</p>
    <h2 id="_idParaDest-192" class="heading-2">There’s more…</h2>
    <p class="normal">A nice complement to the scatter plot is the scatter matrix, which generates pairwise relationships between all of the continuous columns of data within your <code class="inlineCode">pd.DataFrame</code>. Let’s see what that looks like with our vehicle data:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">from</span> pandas.plotting <span class="hljs-keyword">import</span> scatter_matrix
scatter_matrix(df)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_40.png" alt="A graph of a graph  Description automatically generated with medium confidence"/></figure>
    <p class="normal">This is a lot of information in one chart, so let’s start by digesting just the first column of visualizations. If you look at the bottom of the chart, the label is <code class="inlineCode">city08</code>, which means that <code class="inlineCode">city08</code> is the <em class="italic">Y</em>-axis for each chart in that column.</p>
    <p class="normal">The visualization in<a id="_idIndexMarker308"/> the first row of the first column would give you the combination of <code class="inlineCode">city08</code> on the y-axis with <code class="inlineCode">city08</code> on the <em class="italic">X</em>-axis. Rather than a scatter plot that graphs the same column against itself, the scatter matrix shows you the distribution of <code class="inlineCode">city08</code> values in this visual. As you can see, the majority of vehicles get less than 50 MPG in the city.</p>
    <p class="normal">If you look one visual beneath that in the second row of the first column, you will see the relationship between fuel cost and city mileage. This would suggest that there is an exponential decrease in the amount you spend on fuel annually as you opt for cars that get better city mileage.</p>
    <p class="normal">The visualization in the third row of the first column shows <code class="inlineCode">highway08</code> on the <em class="italic">Y</em>-axis, which is the same visual that we displayed throughout this recipe. Once again, there is a linear relationship between city and highway mileage.</p>
    <p class="normal">The visualization in the last row of the first column plots the year on the <em class="italic">Y</em>-axis. From this, it appears that<a id="_idIndexMarker309"/> there were more vehicles introduced in the model years 2023 and 2024 that achieved city mileage of 75 MPG and above.</p>
    <h1 id="_idParaDest-193" class="heading-1">Exploring categorical data</h1>
    <p class="normal">The adjective <em class="italic">categorical</em> is<a id="_idIndexMarker310"/> applied to data that, in a broad sense, is used to classify and help navigate your data, but whose values serve little to no purpose when aggregated. For example, if you were working with a dataset that contained a field called <em class="italic">eye color</em> with values of <code class="inlineCode">Brown</code>, <code class="inlineCode">Green</code>, <code class="inlineCode">Hazel</code>, <code class="inlineCode">Blue</code>, etc., you could use this field to navigate your dataset and answer questions like, <em class="italic">For rows where the eye color is X, what is the average pupil diameter?</em> However, you would not ask a question like, <em class="italic">What is the summation of eye color?</em>, as a formula like <code class="inlineCode">"Hazel" + "Blue</code> would not make sense in this context.</p>
    <p class="normal">By contrast, the adjective <em class="italic">continuous</em> is applied to data that you typically aggregate. With a question like, <em class="italic">What is the average pupil diamenter?</em>, the <em class="italic">pupil diameter</em> column would be considered continuous. There is value to knowing what it aggregates to (i.e., minimum, maximum, average, standard deviation, etc.), and there are a theoretically infinite amount of values that can be represented.</p>
    <p class="normal">At times, it can be ambiguous whether your data is categorical or continuous. Using a person’s <em class="italic">age</em> as an example, if you were measuring things like the <em class="italic">average age of subjects</em>, that column would be continuous, although in the context of a question like, <em class="italic">How many users do we have between the ages of 20–30?</em>, that same data becomes categorical. Ultimately, whether or not data like <em class="italic">age</em> is continuous or categorical will come down to how you use it in your analysis.</p>
    <p class="normal">In this recipe, we are going to generate visualizations that help quickly identify the distribution of categorical data. Our next recipe, <em class="italic">Exploring continuous data</em>, will give you some ideas on how to work with continuous data instead.</p>
    <h2 id="_idParaDest-194" class="heading-2">How to do it</h2>
    <p class="normal">Back in the <em class="italic">Scatter plots</em> recipe, we were introduced to the <code class="inlineCode">vehicles</code> dataset distributed by the United States Department of Energy. This dataset has a good mix of categorical and continuous data, so let’s once again start by loading it into a <code class="inlineCode">pd.DataFrame</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.read_csv(
    "data/vehicles.csv.<span class="hljs-built_in">zip</span>",
    dtype_backend="numpy_nullable",
)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">/tmp/ipykernel_834707/1427318601.py:1: DtypeWarning: Columns (72,74,75,77) have mixed types. Specify dtype option on import or set low_memory=False.
 df = pd.read_csv(
    barrels08   bar-relsA08   charge120   …   phevCity   phevHwy   phevComb
0   14.167143   0.0           0.0         …   0          0         0
1   27.046364   0.0           0.0         …   0          0         0
2   11.018889   0.0           0.0         …   0          0         0
3   27.046364   0.0           0.0         …   0          0         0
4   15.658421   0.0           0.0         …   0          0         0
5 rows × 84 columns
</code></code></pre>
    <p class="normal">You may have noticed<a id="_idIndexMarker311"/> that we received a warning that <code class="inlineCode">Columns (72,74,75,77) have mixed types</code>. Before we jump into visualization, let’s take a quick look at these columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[:, [<span class="hljs-number">72</span>, <span class="hljs-number">74</span>, <span class="hljs-number">75</span>, <span class="hljs-number">77</span>]]
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">        rangeA  mfrCode c240Dscr  c240bDscr
0       &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
1       &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
2       &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
3       &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
4       &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
…       …       …       …         …
47,518  &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
47,519  &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
47,520  &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
47,521  &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
47,522  &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;      &lt;NA&gt;
47,523 rows × 4 columns
</code></code></pre>
    <p class="normal">While we can see the column names, our <code class="inlineCode">pd.DataFrame</code> preview does not show us any actual values, so to inspect this a bit further, we can use <code class="inlineCode">pd.Series.value_counts</code> on each column.</p>
    <p class="normal">Here is what we can<a id="_idIndexMarker312"/> see for the <code class="inlineCode">rangeA</code> column:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["rangeA"].value_counts()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">rangeA
290            74
270            58
280            56
310            41
277            38
              ..
240/290/290     1
395             1
258             1
256             1
230/350         1
Name: count, Length: 264, dtype: int64
</code></code></pre>
    <p class="normal">The values here are… interesting. Without yet knowing what we are looking at, the column name <code class="inlineCode">rangeA</code> and most of the values suggest there is some value to treating this as continuous. By doing so, we could answer questions like, <em class="italic">What is the average rangeA of vehicles that…?</em>, but the presence of values like <code class="inlineCode">240/290/290</code> and <code class="inlineCode">230/350</code> that we see will prevent us from being able to do that. For now, we are just going to treat this data as a string.</p>
    <p class="normal">To bring us full circle on the warning issued by <code class="inlineCode">pd.read_csv</code>, pandas tries to infer the data type while reading the CSV file. If much of the data at the beginning of the file shows one type but later in the file you see another type, pandas will intentionally throw this warning so that you are aware of any potential issues with your data. For this column, we can use <code class="inlineCode">pd.Series.str.isnumeric</code> alongside <code class="inlineCode">pd.Series.idxmax</code> to quickly determine the first row where a non-integral value was encountered in the CSV file:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["rangeA"].<span class="hljs-built_in">str</span>.isnumeric().idxmax()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">7116
</code></code></pre>
    <p class="normal">If you were to inspect the other columns that <code class="inlineCode">pd.read_csv</code> warned about, you would not see a mix of integral and string data, but you would see that much of the data at the beginning of the file is missing, which makes it difficult for pandas to infer the data type:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.iloc[:, [<span class="hljs-number">74</span>, <span class="hljs-number">75</span>, <span class="hljs-number">77</span>]].pipe(pd.isna).idxmin()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">mfrCode      23147
c240Dscr     25661
c240bDscr    25661
dtype: int64
</code></code></pre>
    <p class="normal">Of course, the best solution here would have been to avoid the use of CSV files in the first place, opting instead for a data storage format that maintains type metadata, like Apache Parquet. However, we have no control over how this data is generated, so the best we can do for now is <a id="_idIndexMarker313"/>explicitly tell <code class="inlineCode">pd.read_csv</code> to treat all of these columns as strings and suppress any warnings:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.read_csv(
    "data/vehicles.csv.<span class="hljs-built_in">zip</span>",
    dtype_backend="numpy_nullable",
    dtype={
        "rangeA": pd.StringDtype(),
        "mfrCode": pd.StringDtype(),
        "c240Dscr": pd.StringDtype(),
        "c240bDscr": pd.StringDtype()
    }
)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    barrels08  bar-relsA08  charge120  …  phevCity  phevHwy  phevComb
0   14.167143  0.0          0.0        …  0         0        0
1   27.046364  0.0          0.0        …  0         0        0
2   11.018889  0.0          0.0        …  0         0        0
3   27.046364  0.0          0.0        …  0         0        0
4   15.658421  0.0          0.0        …  0         0        0
5 rows × 84 columns
</code></code></pre>
    <p class="normal">Now that we have loaded the data cleanly, let’s try and identify columns that are categorical in nature. Since we know nothing about this dataset, we can make the directionally correct assumption that all columns read in as strings by <code class="inlineCode">pd.read_csv</code> are categorical in nature:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(include=["string"]).columns
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Index(['drive', 'eng_dscr', 'fuelType', 'fuelType1', 'make', 'model',
      'mpgData', 'trany', 'VClass', 'baseModel', 'guzzler', 'trans_dscr',
      'tCharger', 'sCharger', 'atvType', 'fuelType2', 'rangeA', 'evMotor',
      'mfrCode', 'c240Dscr', 'c240bDscr', 'createdOn', 'modifiedOn',
      'startStop'],
     dtype='object')
</code></code></pre>
    <p class="normal">We could loop over all of these columns and call <code class="inlineCode">pd.Series.value_counts</code> to understand what each column contains, but a more effective way to explore this data would be to first understand how many unique values are in each column with <code class="inlineCode">pd.Series.nunique</code>, ordering from low to high. A lower number indicates a <em class="italic">low cardinality</em> (i.e., the number of <a id="_idIndexMarker314"/>unique values compared to the value count of the <code class="inlineCode">pd.DataFrame</code> is relatively low). Fields with a higher number would inversely be considered to have a <em class="italic">high cardinality</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(include=["string"]).nunique().sort_values()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">sCharger         1
tCharger         1
startStop        2
mpgData          2
guzzler          3
fuelType2        4
c240Dscr         5
c240bDscr        7
drive            7
fuelType1        7
atvType          9
fuelType        15
VClass          34
trany           40
trans_dscr      52
mfrCode         56
make           144
rangeA         245
modifiedOn     298
evMotor        400
createdOn      455
eng_dscr       608
baseModel     1451
model         5064
dtype: int64
</code></code></pre>
    <p class="normal">For an easy visualization, we are just going to take the nine columns with the lowest cardinality. This is by no means an absolute rule for choosing what to visualize or not – ultimately, that decision is up to you. For our particular dataset, the nine columns with the lowest cardinality have up to seven unique values, which can be reasonably plotted on the <em class="italic">X</em>-axis of bar charts to help visualize value distribution.</p>
    <p class="normal">Building on what we learned back in the <em class="italic">Further plot customization with Matplotlib</em> recipe in this chapter, we can use <code class="inlineCode">plt.subplots</code> to create a simple 3x3 grid and, with that, plot each visual to its <a id="_idIndexMarker315"/>own space in the grid:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">low_card = df.select_dtypes(include=["string"]).nunique().sort_values().iloc[:<span class="hljs-number">9</span>].index
fig, axes = plt.subplots(nrows=<span class="hljs-number">3</span>, ncols=<span class="hljs-number">3</span>)
<span class="hljs-keyword">for</span> index, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(low_card):
    row = index % <span class="hljs-number">3</span>
    col = index // <span class="hljs-number">3</span>
    ax = axes[row][col]
    df[column].value_counts().plot(kind="bar", ax=ax)
plt.tight_layout()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">/tmp/ipykernel_834707/4000549653.py:10: UserWarning: Tight layout not applied. tight_layout cannot make axes height small enough to accommodate all axes decorations.
 plt.tight_layout()
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_41.png" alt=""/></figure>
    <p class="normal">That chart is… very <a id="_idIndexMarker316"/>difficult to read. Many of the <em class="italic">X</em>-axis labels overrun the chart area, given their length. One way to fix this would be to assign shorter labels to our row index values, using a combination of <code class="inlineCode">pd.Index.str[]</code> along with <code class="inlineCode">pd.Index.set_axis</code> to use those values in a new <code class="inlineCode">pd.Index</code>. We can also use Matplotlib to rotate and resize our <em class="italic">X</em>-axis labels:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">low_card = df.select_dtypes(include=["string"]).nunique().sort_values().iloc[:<span class="hljs-number">9</span>].index
fig, axes = plt.subplots(nrows=<span class="hljs-number">3</span>, ncols=<span class="hljs-number">3</span>)
<span class="hljs-keyword">for</span> index, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(low_card):
    row = index % <span class="hljs-number">3</span>
    col = index // <span class="hljs-number">3</span>
    ax = axes[row][col]
    counts = df[column].value_counts()
    counts.set_axis(counts.index.<span class="hljs-built_in">str</span>[:<span class="hljs-number">8</span>]).plot(kind="bar", ax=ax)
    ax.set_xticklabels(ax.get_xticklabels(), rotation=<span class="hljs-number">45</span>, fontsize=<span class="hljs-number">6</span>)
plt.tight_layout()
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_42.png" alt=""/></figure>
    <p class="normal">From this visualization, we can more easily understand our dataset at a high level. The <code class="inlineCode">mpgData</code> column appears to be <code class="inlineCode">N</code> at a much higher frequency than <code class="inlineCode">Y</code>. For the <code class="inlineCode">guzzler</code> column, we see roughly twice as many <code class="inlineCode">G</code> values as <code class="inlineCode">T</code>. For the <code class="inlineCode">c240Dscr</code> column, we can see that the vast majority of entries are <code class="inlineCode">standard</code>, although overall, there are only slightly more than 100 rows in our entire dataset that even bother to assign this value, so we may<a id="_idIndexMarker317"/> decide that there aren’t enough measurements to reliably use it.</p>
    <h1 id="_idParaDest-195" class="heading-1">Exploring continuous data</h1>
    <p class="normal">In the <em class="italic">Exploring categorical </em><em class="italic"><a id="_idIndexMarker318"/></em><em class="italic">data</em> recipe, we provided a definition for <em class="italic">categorical</em> and <em class="italic">continuous</em> data, while exploring only the former. The same <code class="inlineCode">vehicles</code> dataset we used in that recipe has a good mix of both types of data (most datasets will), so we will reuse that same dataset but shift our focus to continuous data for this recipe.</p>
    <p class="normal">Before going through this recipe, I advise you to get familiar with the techniques shown in the <em class="italic">Plotting distributions of non-aggregated data</em> recipe first. The actual plotting calls made will be the same, but this recipe will apply them to more of a “real-world” dataset instead of artificially created data.</p>
    <h2 id="_idParaDest-196" class="heading-2">How to do it</h2>
    <p class="normal">Let’s start by loading the <code class="inlineCode">vehicles</code> dataset:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.read_csv(
    "data/vehicles.csv.<span class="hljs-built_in">zip</span>",
    dtype_backend="numpy_nullable",
    dtype={
        "rangeA": pd.StringDtype(),
        "mfrCode": pd.StringDtype(),
        "c240Dscr": pd.StringDtype(),
        "c240bDscr": pd.StringDtype()
    }
)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">   barrels08  bar-relsA08  charge120  …  phevCity  phevHwy  phevComb
0  14.167143  0.0          0.0        …  0         0        0
1  27.046364  0.0          0.0        …  0         0        0
2  11.018889  0.0          0.0        …  0         0        0
3  27.046364  0.0          0.0        …  0         0        0
4  15.658421  0.0          0.0        …  0         0        0
5 rows × 84 columns
</code></code></pre>
    <p class="normal">In the previous recipe, we used <code class="inlineCode">pd.DataFrame.select_dtypes</code> with an <code class="inlineCode">include=</code> argument that kept only string columns, which we used as a proxy for categorical data. By passing that same argument to <code class="inlineCode">exclude=</code> instead, we can get a reasonable overview of the continuous columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(exclude=["string"]).columns
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">Index(['barrels08', 'barrelsA08', 'charge120', 'charge240', 'city08',
      'city08U', 'cityA08', 'cityA08U', 'cityCD', 'cityE', 'cityUF', 'co2',
      'co2A', 'co2TailpipeAGpm', 'co2TailpipeGpm', 'comb08', 'comb08U',
      'combA08', 'combA08U', 'combE', 'combinedCD', 'combinedUF', 'cylinders',
      'displ', 'engId', 'feScore', 'fuelCost08', 'fuelCostA08', 'ghgScore',
      'ghgScoreA', 'highway08', 'highway08U', 'highwayA08', 'highwayA08U',
      'highwayCD', 'highwayE', 'highwayUF', 'hlv', 'hpv', 'id', 'lv2', 'lv4',
      'phevBlended', 'pv2', 'pv4', 'range', 'rangeCity', 'rangeCityA',
      'rangeHwy', 'rangeHwyA', 'UCity', 'UCityA', 'UHighway', 'UHighwayA',
      'year', 'youSaveSpend', 'charge240b', 'phevCity', 'phevHwy',
      'phevComb'],
     dtype='object')
</code></code></pre>
    <p class="normal">Using <code class="inlineCode">pd.Series.nunique</code> does<a id="_idIndexMarker319"/> not make as much sense with continuous data, as values may take on a theoretically infinite amount of values. Instead, to identify good plotting candidates, we may just want to understand which columns have a sufficient amount of non-missing data by using <code class="inlineCode">pd.isna</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.select_dtypes(
    exclude=["string"]
).pipe(pd.isna).<span class="hljs-built_in">sum</span>().sort_values(ascending=<span class="hljs-literal">False</span>).head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">cylinders      801
displ          799
barrels08        0
pv4              0
highwayA08U      0
dtype: int64
</code></code></pre>
    <p class="normal">Generally, most of our continuous data is complete, but let’s take a look at <code class="inlineCode">cylinders</code> to see what the missing values are:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[df["cylinders"].isna(), ["make", "model"]].value_counts()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">make      model                          
Fiat      500e                               8
smart     fortwo electric drive coupe        7
Toyota    RAV4 EV                            7
Nissan    Leaf                               7
Ford      Focus Electric                     7
                                           ..
Polestar  2 Single Motor (19 Inch Wheels)    1
Ford      Mustang Mach-E RWD LFP             1
Polestar  2 Dual Motor Performance Pack      1
          2 Dual Motor Perf Pack             1
Acura     ZDX AWD                            1
Name: count, Length: 450, dtype: int64
</code></code></pre>
    <p class="normal">These appear to be<a id="_idIndexMarker320"/> electric vehicles, so we could reasonably choose to fill these missing values with a <code class="inlineCode">0</code> instead:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["cylinders"] = df["cylinders"].fillna(<span class="hljs-number">0</span>)
</code></code></pre>
    <p class="normal">We see the same pattern with the <code class="inlineCode">displ</code> column:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df.loc[df["displ"].isna(), ["make", "model"]].value_counts()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">make     model                             
Fiat     500e                                  8
smart    fortwo electric drive coupe           7
Toyota   RAV4 EV                               7
Nissan   Leaf                                  7
Ford     Focus Electric                        7
                                             ..
Porsche  Taycan 4S Performance Battery Plus    1
         Taycan GTS ST                         1
Fisker   Ocean Extreme One                     1
Fiat     500e All Season                       1
Acura    ZDX AWD                               1
Name: count, Length: 449, dtype: int64
</code></code></pre>
    <p class="normal">Whether or not we should fill this data with <code class="inlineCode">0</code> is up for debate. In the case of <code class="inlineCode">cylinder</code>, filling missing values with <code class="inlineCode">0</code> made sense because our data was actually categorical (i.e., there are only so many <code class="inlineCode">cylinder</code> values that can appear, and you cannot simply aggregate those values). If you have one vehicle with 2 cylinders and another with 3, it would not make sense to say, “The average number of cylinders is 2.5” because a vehicle may not have 2.5 cylinders.</p>
    <p class="normal">However, with a column like <code class="inlineCode">displacement</code>, it may make more sense to measure something like the “average displacement.” In such a case, providing many <code class="inlineCode">0</code> values to an average will skew it downwards, whereas missing values would be ignored. There are also many more unique values than what we see with <code class="inlineCode">cylinders</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["displ"].nunique()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">66
</code></code></pre>
    <p class="normal">Ultimately, filling <a id="_idIndexMarker321"/>missing values in this field is a judgment call; for our analysis, we will leave them as missing.</p>
    <p class="normal">Now that we have validated the missing values in our dataset and feel comfortable with our completeness, it is time to start exploring individual fields in more detail. When exploring continuous data, a histogram is often the first visualization that users reach for. Let’s see what that looks like with our <code class="inlineCode">city08</code> column:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["city08"].plot(kind="hist")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_43.png" alt=""/></figure>
    <p class="normal">The plot looks very <a id="_idIndexMarker322"/>skewed, so we will increase the number of bins in the histogram to see if the skew is hiding behaviors (as skew makes bins wider):</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["city08"].plot(kind="hist", bins=<span class="hljs-number">30</span>)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_44.png" alt="A graph with numbers and a blue column  Description automatically generated with medium confidence"/></figure>
    <p class="normal">As we discussed <a id="_idIndexMarker323"/>back in the <em class="italic">Plotting distributions of non-aggregated data</em> recipe, you can forgo having to find the optimal number of bins if you have SciPy installed. With SciPy, a KDE plot will give you an even better view of the distribution.</p>
    <p class="normal">Knowing that, and building from what we saw back in the <em class="italic">Further plot customization with Matplotlib</em> recipe, we can use <code class="inlineCode">plt.subplots</code> to visualize the KDE plots for multiple variables at once, like city and highway mileage:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">fig, axes = plt.subplots(nrows=<span class="hljs-number">2</span>, ncols=<span class="hljs-number">1</span>)
axes[<span class="hljs-number">0</span>].set_xlim(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)
axes[<span class="hljs-number">1</span>].set_xlim(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)
axes[<span class="hljs-number">0</span>].set_ylabel("city")
axes[<span class="hljs-number">1</span>].set_ylabel("highway")
df["city08"].plot(kind="kde", ax=axes[<span class="hljs-number">0</span>])
df["highway08"].plot(kind="kde", ax=axes[<span class="hljs-number">1</span>])
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_45.png" alt="A graph of a normal distribution  Description automatically generated with medium confidence"/></figure>
    <p class="normal">As you can see, the city mileage tends to skew slightly left, with the peak of the distribution occurring <a id="_idIndexMarker324"/>around 16 or 17 mpg. Highway mileage peaks closer to 23 or 24, with more values than you would expect for a perfectly normal distribution appearing around 17 or 18 mpg.</p>
    <h1 id="_idParaDest-197" class="heading-1">Using seaborn for advanced plots</h1>
    <p class="normal">The seaborn library is<a id="_idIndexMarker325"/> a popular Python library for creating <a id="_idIndexMarker326"/>visualizations. It does not do any drawing itself, instead deferring the heavy lifting to Matplotlib. However, for users working with a <code class="inlineCode">pd.DataFrame</code>, seaborn offers beautiful visualizations out of the box and an API that abstracts a lot of things you would have to do when working more directly with Matplotlib.</p>
    <p class="normal">Rather than using <code class="inlineCode">pd.Series.plot</code> and <code class="inlineCode">pd.DataFrame.plot</code>, we will use seaborn’s own API. All examples in this section assume the following code to import seaborn and use its default theme:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns
sns.set_theme()
sns.set_style(<span class="hljs-string">"white"</span>)
</code></code></pre>
    <h2 id="_idParaDest-198" class="heading-2">How to do it</h2>
    <p class="normal">Let’s create a <a id="_idIndexMarker327"/>small <code class="inlineCode">pd.DataFrame</code> that shows how many stars two<a id="_idIndexMarker328"/> GitHub projects have received over time:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame([
    ["Q1-<span class="hljs-number">2024</span>", "project_a", <span class="hljs-number">1</span>],
    ["Q1-<span class="hljs-number">2024</span>", "project_b", <span class="hljs-number">1</span>],
    ["Q2-<span class="hljs-number">2024</span>", "project_a", <span class="hljs-number">2</span>],
    ["Q2-<span class="hljs-number">2024</span>", "project_b", <span class="hljs-number">2</span>],
    ["Q3-<span class="hljs-number">2024</span>", "project_a", <span class="hljs-number">4</span>],
    ["Q3-<span class="hljs-number">2024</span>", "project_b", <span class="hljs-number">3</span>],
    ["Q4-<span class="hljs-number">2024</span>", "project_a", <span class="hljs-number">8</span>],
    ["Q4-<span class="hljs-number">2024</span>", "project_b", <span class="hljs-number">4</span>],
    ["Q5-<span class="hljs-number">2025</span>", "project_a", <span class="hljs-number">16</span>],
    ["Q5-<span class="hljs-number">2025</span>", "project_b", <span class="hljs-number">5</span>],
], columns=["quarter", "project", "github_stars"])
df = df.convert_dtypes(dtype_backend="numpy_nullable")
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    quarter   project     github_stars
0   Q1-2024   project_a   1
1   Q1-2024   project_b   1
2   Q2-2024   project_a   2
3   Q2-2024   project_b   2
4   Q3-2024   project_a   4
5   Q3-2024   project_b   3
6   Q4-2024   project_a   8
7   Q4-2024   project_b   4
8   Q5-2025   project_a   16
9   Q5-2025   project_b   5
</code></code></pre>
    <p class="normal">This simple data makes for a good bar chart, which we can produce with <code class="inlineCode">sns.barplot</code>. Note the difference in the call signature when using seaborn’s API – with seaborn, you will provide the <code class="inlineCode">pd.DataFrame</code> as an argument and explicitly choose the <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">hue</code> arguments. You will also notice that the seaborn theme uses a different color theme than Matplotlib, which<a id="_idIndexMarker329"/> you may find more visually <a id="_idIndexMarker330"/>appealing:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.barplot(df, x="quarter", y="github_stars", hue="project")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_46.png" alt=""/></figure>
    <p class="normal"><code class="inlineCode">sns.lineplot</code> can be<a id="_idIndexMarker331"/> used to produce this same visualization<a id="_idIndexMarker332"/> as a line chart:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.lineplot(df, x="quarter", y="github_stars", hue="project")
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_47.png" alt="A graph with a line and a line  Description automatically generated"/></figure>
    <p class="normal">An important thing to note <a id="_idIndexMarker333"/>when using seaborn is that you will provide your data in <em class="italic">long form</em> instead of wide form. To illustrate the difference, look closely at the raw <code class="inlineCode">pd.DataFrame</code> we just plotted:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    quarter   project     github_stars
0   Q1-2024   project_a   1
1   Q1-2024   project_b   1
2   Q2-2024   project_a   2
3   Q2-2024   project_b   2
4   Q3-2024   project_a   4
5   Q3-2024   project_b   3
6   Q4-2024   project_a   8
7   Q4-2024   project_b   4
8   Q5-2025   project_a   16
9   Q5-2025   project_b   5
</code></code></pre>
    <p class="normal">If we wanted to make the equivalent line and bar charts with pandas, we would have had to structure our data differently before calling <code class="inlineCode">pd.DataFrame.plot</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.DataFrame({
    "project_a": [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>],
    "project_b": [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
}, index=["Q1-<span class="hljs-number">2024</span>", "Q2-<span class="hljs-number">2024</span>", "Q3-<span class="hljs-number">2024</span>", "Q4-<span class="hljs-number">2024</span>", "Q5-<span class="hljs-number">2024</span>"])
df = df.convert_dtypes(dtype_backend="numpy_nullable")
df
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">          project_a   project_b
Q1-2024   1           1
Q2-2024   2           2
Q3-2024   4           3
Q4-2024   8           4
Q5-2024   16          5
</code></code></pre>
    <p class="normal">While the default styling that seaborn provides is helpful to make nice-looking charts, there are way more <a id="_idIndexMarker334"/>powerful visualizations that the library can<a id="_idIndexMarker335"/> help you build, with no equivalent when using pandas directly.</p>
    <p class="normal">To see these types of charts in action, let’s once again work with the <code class="inlineCode">movie</code> dataset we explored back in <em class="chapterRef">Chapter 5</em>, <em class="italic">Algorithms and How to Apply Them</em>:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.read_csv(
    "data/movie.csv",
    usecols=["movie_title", "title_year", "imdb_score", "content_rating"],
    dtype_backend="numpy_nullable",
)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    movie_title  content_rating  title_year  imdb_score
0   Avatar       PG-13           2009.0      7.9
1   Pirates of the Caribbean: At World's End   PG-13   2007.0   7.1
2   Spectre      PG-13           2015.0      6.8
3   The Dark Knight Rises   PG-13   2012.0   8.5
4   Star Wars: Episode VII – The Force Awakens   &lt;NA&gt;   &lt;NA&gt;   7.1
</code></code></pre>
    <p class="normal">We need to do some data cleansing before we jump into this dataset. For starters, it looks like <code class="inlineCode">title_year</code> is being read as a floating-point value. An integral value would have been much more appropriate, so we are going to reread our data while passing that explicitly to the <code class="inlineCode">dtype=</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = pd.read_csv(
    "data/movie.csv",
    usecols=["movie_title", "title_year", "imdb_score", "content_rating"],
    dtype_backend="numpy_nullable",
    dtype={"title_year": pd.Int16Dtype()},
)
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    movie_title   content_rating   title_year   imdb_score
0   Avatar        PG-13            2009         7.9
1   Pirates of the Caribbean: At World's End    PG-13   2007   7.1
2   Spectre       PG-13            2015         6.8
3   The Dark Knight Rises   PG-13  2012         8.5
4   Star Wars: Episode VII - The Force Awakens   &lt;NA&gt;   &lt;NA&gt;   7.1
</code></code></pre>
    <p class="normal">With that out <a id="_idIndexMarker336"/>of the <a id="_idIndexMarker337"/>way, let’s see when the oldest movie in our dataset was released:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["title_year"].<span class="hljs-built_in">min</span>()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">1916
</code></code></pre>
    <p class="normal">And compare that to the last movie:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df["title_year"].<span class="hljs-built_in">max</span>()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">2016
</code></code></pre>
    <p class="normal">As we think ahead toward visualizing this data, we may not always be so detailed as caring about the exact year that a movie was released. Instead, we could place each movie into a <code class="inlineCode">decade</code> bucket by using the <code class="inlineCode">pd.cut</code> function we covered back in <em class="chapterRef">Chapter 5</em>, <em class="italic">Algorithms and How to Apply Them</em>, providing a range that will start before and extend after the first and last titles in our dataset were released:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">df = df.assign(
    title_decade=<span class="hljs-keyword">lambda</span> x: pd.cut(x["title_year"],
                                  bins=<span class="hljs-built_in">range</span>(<span class="hljs-number">1910</span>, <span class="hljs-number">2021</span>, <span class="hljs-number">10</span>)))
df.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    movie_title   content_rating   title_year   imdb_score   title_decade
0   Avatar        PG-13            2009         7.9          (2000.0, 2010.0]
1   Pirates of the Caribbean: At World's End   PG-13   2007   7.1   (2000.0, 2010.0]
2   Spectre       PG-13            2015         6.8          (2010.0, 2020.0]
3   The Dark Knight Rises   PG-13  2012         8.5          (2010.0, 2020.0]
4   Star Wars: Epi-sode VII - The Force Awakens   &lt;NA&gt;   &lt;NA&gt;   7.1   NaN
</code></code></pre>
    <p class="normal">If we wanted to understand how the distribution of movie ratings has changed over the decades, a boxplot would <a id="_idIndexMarker338"/>be a great first step toward visualizing those trends. Seaborn exposes an <code class="inlineCode">sns.boxplot</code> method<a id="_idIndexMarker339"/> that makes this trivial to draw:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.boxplot(
    data=df,
    x="imdb_score",
    y="title_decade",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_48.png" alt=""/></figure>
    <p class="normal">If you look at the median movie rating (i.e., the black vertical line toward the middle of each box), you can see that movie ratings have generally trended downward over time. At the same time, the<a id="_idIndexMarker340"/> lines extending from each box (which represent<a id="_idIndexMarker341"/> the lowest and highest quartiles of ratings) appear to have a wider spread over time, which may suggest that the worst movies each decade are getting worse, while the best movies may be getting better, at least since the 1980s.</p>
    <p class="normal">While the boxplot chart provides a decent high-level view into the distribution of data by decade, there are other plots that seaborn offers that may be even more insightful. One example is the violin plot, which is essentially a KDE plot (covered back in the <em class="italic">Plotting distributions of non-aggregated data</em> recipe) overlaid on top of a boxplot. Seaborn allows this via the <code class="inlineCode">sns.violinplot</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.violinplot(
    data=df,
    x="imdb_score",
    y="title_decade",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_49.png" alt="A graph of a number of numbers  Description automatically generated with medium confidence"/></figure>
    <p class="normal">Many of the decades show a distribution with a single mode, but if you look closely at the 1950s, you <a id="_idIndexMarker342"/>will<a id="_idIndexMarker343"/> notice that the KDE plot has two peaks (one around a score of 7 and the other peak slightly north of 8). The 1960s exhibit a similar phenomenon, although the peak around a score of 7 is slightly less pronounced. For both of these decades, the KDE overlay suggests that a relatively high volume of reviews are distributed toward the 25th and 75th percentiles for ratings, whereas other decades tend to regress more toward the median.</p>
    <p class="normal">However, the violin plot still makes it difficult to discern how many ratings there were per decade. While the distribution in each decade is, of course, important, the volume may tell another story. Perhaps movie ratings are higher for older decades because of survivorship bias, with only the movies that are deemed good for those decades actually getting reviewed, or perhaps newer decades have valued quality over quantity.</p>
    <p class="normal">Whatever the root cause may be, seaborn can at least help us visually confirm the volume alongside our distribution through the use of a swarm plot, which takes the KDE portion of the violin plot and <a id="_idIndexMarker344"/>scales it vertically, depending on the<a id="_idIndexMarker345"/> volume of records:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.swarmplot(
    data=df,
    x="imdb_score",
    y="title_decade",
    size=<span class="hljs-number">.25</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_50.png" alt="A graph with numbers and lines  Description automatically generated"/></figure>
    <p class="normal">As you can see in the visual, much of the volume of reviews happened on reviews from the 1990s or later, with most of the reviews coming from the years 2000–2010 (remember that our dataset only contains movies up until 2016). Decades before 1990 have a relatively small amount of reviews, to the point of making them almost indiscernible on the graph.</p>
    <p class="normal">With a swarm plot, you can go even further into this data by adding more dimensions to the visual. So far, we have already discovered that movie ratings have trended downward over time, whether it is due to survivorship bias with ratings or a focus on quantity over quality. But what if we wanted to know more about different types of movies? Are PG-13 movies faring better than R-rated?</p>
    <p class="normal">By controlling the color of each point on a swarm plot, you can add that extra dimension to your visuals. To see this in action, let’s drill into just a few years of data, as our current plots are getting tough to read. We can also just look at movies with ratings, as unrated entries or TV shows are not something we care to drill into. As a final data cleansing step, we are going<a id="_idIndexMarker346"/> to convert our <code class="inlineCode">title_year</code> column to a categorical <a id="_idIndexMarker347"/>data type so that the plotting library knows that years like 2013, 2014, 2015, etc. should be treated as discrete values, rather than as a continuous range of values from 2013 to 2015:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">ratings_of_interest = {"G", "PG", "PG-<span class="hljs-number">13</span>", "R"}
mask = (
    (df["title_year"] &gt;= <span class="hljs-number">2013</span>)
    &amp; (df["title_year"] &lt;= <span class="hljs-number">2015</span>)
    &amp; (df["content_rating"].isin(ratings_of_interest))
)
data = df[mask].assign(
    title_year=<span class="hljs-keyword">lambda</span> x: x["title_year"].astype(pd.CategoricalDtype())
)
data.head()
</code></code></pre>
    <pre class="programlisting con"><code class="hljs-con"><code class="hljs-con">    movie_title   content_rating   title_year   imdb_score   title_decade
2   Spectre       PG-13            2015         6.8          (2010, 2020]
8   Avengers: Age of Ultron   PG-13   2015      7.5          (2010, 2020]
14  The Lone Ranger   PG-13        2013         6.5          (2010, 2020]
15  Man of Steel  PG-13            2013         7.2          (2010, 2020]
20  The Hobbit: The Battle of the Five Ar-mies   PG-13   2014   7.5   (2010, 2020]
</code></code></pre>
    <p class="normal">With the data cleansing out of the way, we can go ahead and add the <code class="inlineCode">content_rating</code> to our chart and have <a id="_idIndexMarker348"/>seaborn<a id="_idIndexMarker349"/> assign each a unique color, via the <code class="inlineCode">hue=</code> argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.swarmplot(
    data=data,
    x="imdb_score",
    y="title_year",
    hue="content_rating",
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_51.png" alt="A graph of data analysis  Description automatically generated with medium confidence"/></figure>
    <p class="normal">Adding colors adds another dimension of information to our chart, although an alternative approach to use a separate chart for each <code class="inlineCode">content_rating</code> might make this even more readable.</p>
    <p class="normal">To achieve that, we are going to use the <code class="inlineCode">sns.catplot</code> function with some extra arguments. The first argument of note is <code class="inlineCode">kind=</code>, through which we will tell seaborn to draw “swarm” plots for us. The <code class="inlineCode">col=</code> argument dictates the field used to generate individual charts, and the <code class="inlineCode">col_wrap=</code> argument tells us how many charts can be put together in a row, assuming <a id="_idIndexMarker350"/>a<a id="_idIndexMarker351"/> grid-like layout for our charts:</p>
    <pre class="programlisting code"><code class="hljs-code"><code class="hljs-code">sns.catplot(
    kind="swarm",
    data=data,
    x="imdb_score",
    y="title_year",
    col="content_rating",
    col_wrap=<span class="hljs-number">2</span>,
)
</code></code></pre>
    <figure class="mediaobject"><img src="../Images/B31091_06_52.png" alt="A group of blue dots  Description automatically generated"/></figure>
    <p class="normal">This visualization would <a id="_idIndexMarker352"/>appear to suggest that 2013 was a good <a id="_idIndexMarker353"/>year for movies, at least relative to 2014 and 2015. Within the PG-13 content rating, it appears that there were relatively more movies falling in the 7–8 range than any other year. For R-rated movies, it appears that the vast majority of movies were given a rating of 5 and above in 2013, with more movies falling below that line as the years went on.</p>
    <h1 id="_idParaDest-199" class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the authors and other readers:</p>
    <p class="normal"><a href="https://packt.link/pandas"><span class="url">https://packt.link/pandas</span></a></p>
    <p class="normal"><img src="../Images/QR_Code5040900042138312.png" alt=""/></p>
    <h1 id="_idParaDest-200" class="heading-1">Leave a Review! </h1>
    <p class="normal">Thank you for purchasing this book from Packt Publishing—we hope you enjoy it! Your feedback is invaluable and helps us improve and grow. Once you’ve completed reading it, please take a moment to leave an Amazon review; it will only take a minute, but it makes a big difference for readers like you.</p>
    <p class="normal">Scan the QR code below to receive a free ebook of your choice.</p>
    <p class="normal"><a href="Chapter_6.xhtml"><span class="url">https://packt.link/NzOWQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1474021820358918656.png" alt=""/></p>
  </div>
</body></html>