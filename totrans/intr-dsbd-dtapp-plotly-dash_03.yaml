- en: '*Chapter 2*: Exploring the Structure of a Dash App'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to tackle the mechanism through which Dash creates interactivity
    – the heart of Dash, if you will. Once you are comfortable with creating **callback
    functions** that link different elements of the layout, combined with what you
    learned in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview
    of the Dash Ecosystem*, you should be well equipped to be able to convert datasets
    into interactive apps in a very short period of time. The remainder of this book
    will go into much more detail and offer many more options of how to do this. However,
    these two chapters should be sufficient for creating visual layouts, as well as
    connecting them and making them interactive. We will mainly explore callback functions
    in this chapter; the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jupyter Notebooks to run Dash apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a standalone pure Python function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the ID parameter of Dash components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Dash inputs and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating the function into the app – creating your first reactive program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first interactive app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the packages that we used in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem* (for example, Dash, Dash HTML Components, and
    Dash Bootstrap Components), we will be, most importantly, working with `jupyter_dash`
    package along with `pandas` for data manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_02).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3tC0ZsW](https://bit.ly/3tC0ZsW).
  prefs: []
  type: TYPE_NORMAL
- en: Using Jupyter Notebooks to run Dash apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a change to imports and a minor change to app instantiation, we can easily
    start to run our apps within Jupyter Notebook environments. The package that makes
    this possible is `jupyter_dash`. Essentially, the difference is that we import
    the **JupyterDash** object (instead of importing Dash), and app instantiation
    occurs by calling this object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One of the advantages of running apps in a notebook environment is that it is
    less tedious to make small changes, iterate them, and see results. Working with
    an IDE, the command line, and the browser, you need to constantly shift between
    them, while in a notebook environment, everything is in one place. This makes
    introducing simple changes and testing them easier. It can make your notebooks
    far more powerful and interesting as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jupyter_dash` package also provides an additional option while running
    the app, where you can determine whether you want to run the app in one of three
    modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`external`: In a separate browser window, exactly as we have done so far'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inline`: In the code output area of the notebook, right underneath the code
    cell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jupyterlab`: In a separate tab while/if running in JupyterLab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also set your desired width and height if you wish to. Running the
    app takes additional optional parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, setting the height and width can be done either by specifying
    an integer, that is, the number of pixels, or, for `width`, a percentage of the
    screen size as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there is another important benefit of running apps in a Jupyter Notebook
    environment, other than keeping the code and narrative in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating functionality for better management and debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running and developing apps, you inevitably come across bugs and issues.
    In order to handle them, you need to isolate the cause and create the simplest
    reproducible example that causes the bug to happen. Only then can you properly
    troubleshoot the problem. And only then can you ask others for help. We won't
    wait for bugs to happen to isolate issues and figure them out. We will preemptively
    isolate all new features before incorporating them, so we can better handle and
    manage them.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, introducing new features will be done by, first, creating them
    in an isolated environment, where we create a minimal app containing only this
    functionality. Once we are comfortable that we understand how it works, and that
    it functions as expected, we will keep a copy for reference, and see how to incorporate
    it into the existing app. This will also help us if we want to make changes to
    that specific functionality in the future, in which case we go through the same
    process again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our first example, which will be a drop-down menu with three
    values. The user selects one, and right underneath it, they see a message showing
    the value they chose. *Figure 2.1* shows an example of what this might look like
    in its simplest form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The user''s selection is displayed based on the value selected](img/B16780_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The user's selection is displayed based on the value selected
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will create this, except for the function that shows the
    user''s selection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required packages with their aliases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the layout of the app. We will now introduce a new component, the Dash
    Core Components `options` attribute to set the options that the user can select
    from. This parameter is set by using a list of dictionaries, one for each option,
    where `label` is what the user will see, and `value` is the actual value that
    we will be dealing with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the app as usual, with the minor change of running this in the `inline`
    mode for easier interactive work in JupyterLab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 2.2* shows an example of what this would look like in a notebook environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Dash app running in JupyterLab](img/B16780_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The Dash app running in JupyterLab
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you have noticed the empty `html.Div` file that was added right underneath
    the drop-down list. Let's examine how that fits into the structure of the app
    and how to implement the remaining functionality. We will now look at how to create
    the function that will link the dropdown to the empty div tag.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a standalone pure Python function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function is what we will be using to take the selected value from the dropdown,
    process it somehow, and use its return value to do something that is visible to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is so simple that it doesn''t require much explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the user doesn't input anything (or deselects the current option), then the
    `color` variable is set to `'nothing'`, and the function returns `'You selected
    ' + <color>`, with whatever value `color` takes. Later in the chapter, we will
    create a more involved function to get some information on countries.
  prefs: []
  type: TYPE_NORMAL
- en: A function is essentially a procedure. It takes in one or more arguments (inputs),
    does something to them, and returns one or more outputs. So, for this function,
    what will `Input` be, and what happens to its `Output`? You decide by selecting
    from the available components from the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this function, the dropdown will provide `Input`. Then, after processing
    it, the return value of the function, that is, its `Output`, will influence what
    to display in the currently empty `html.Div` right underneath the dropdown. Building
    on the diagram in *Figure 2.1*, *Figure 2.3* shows what we are trying to achieve.
    We will build a way to connect the dropdown (`Input`) to the div that shows the
    text (`Output`) by using the function we just defined as an intermediary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Input, Output, and a standalone function](img/B16780_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Input, Output, and a standalone function
  prefs: []
  type: TYPE_NORMAL
- en: In order for it to work in the context of this app, the function needs to know
    what its inputs and outputs are.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at how to identify components by setting their `id` values. After
    that, we will learn how to declare a component as `Input` or `Output`.
  prefs: []
  type: TYPE_NORMAL
- en: The id parameter of Dash components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As briefly mentioned in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*, every Dash component has an `id` parameter that
    you can easily set in order to uniquely identify it. There is actually nothing
    more to this parameter than making sure that your components have unique and descriptive
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are more advanced ways of using the **id** parameter, and they will be
    tackled in a later, more advanced chapter. However, for now, we will just focus
    on it being a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using descriptive and explicit names for the `id` parameter becomes more important
    as the app grows in complexity. This parameter is optional when there is no interactivity,
    but it becomes mandatory when there is. The following example snippet shows how
    easy it is to set the `id` parameter for a basic use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying this to our current isolated app, we set a descriptive name to each
    `id` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app is now complete from a layout perspective, exactly as we did in [*Chapter
    1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview of the Dash Ecosystem*.
    The difference here is that we set values for the `id` parameter, and we are running
    it in a Jupyter Notebook environment. Once we can identify components using their
    `id` parameter, we can determine which become `Input` and which become `Output`.
    By updating our conceptual diagram with the ID values that we set, we can view
    the labels, as shown in *Figure 2.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Visible app elements are given names (IDs)](img/B16780_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Visible app elements are given names (IDs)
  prefs: []
  type: TYPE_NORMAL
- en: Having given our components descriptive names, we are now ready to use them
    beyond simply displaying them.
  prefs: []
  type: TYPE_NORMAL
- en: Dash inputs and outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to determine which component is going to become an input (to
    our pure Python function) and which component will get the return value of the
    function (as an output) to be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Determining your inputs and outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dash.dependencies` module has several classes, two of which we will be
    using here: `Output` and `Input`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These classes can be imported by adding the following line to the `imports`
    section of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly recap what we did earlier before adding the final element that
    will make this functionality work:'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiated an app in the Jupyter Notebook environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a dropdown containing three colors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We created a regular function that returns a string, together with the value
    provided to it: `''Your selected'' + <color>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The components were identified with descriptive names through their `id` parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Input` and `Output` were imported from `dash.dependencies`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now define our callback function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Callback functions are decorators, and in the most basic use case, they require
    three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`children` property of the empty div. In this case, it can be specified like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`value` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Input` and `Output` that we have chosen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 2.5* shows an updated view of how things are coming together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Visible app elements connected through certain properties](img/B16780_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Visible app elements connected through certain properties
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between the frontend and the backend in Dash is massively simplified
    for us. They both exist in the same module, and we don't need to worry about many
    of the conventional details. For now, anything in `app.layout` can be considered
    the frontend, and any callback functions that we define outside it can be collectively
    thought of as the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying your callback function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general format to specify a callback function is to define it as an attribute
    of the `app` variable, using the Python classes'' dot notation, and then set the
    output and input, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created a callback as an attribute of our app and determined
    which components'' IDs and properties we want to influence each other, we bring
    our Python function and simply place it underneath the callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now our callback is complete and ready to be incorporated into our app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take this abstract structure and implement it using the details of our
    standalone app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Please keep in mind that the order is important. `Output` has to be provided
    before `Input`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a complete callback function that belongs to our `app`. It knows
    which property of which `Output` it will modify, as well as which property of
    which `Input` it will be using for this. It then uses the `display_selected_color`
    function for processing, taking the output value and sending it to the component
    where `id='color_output'`. This will, in turn, modify the specified property (`children`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For running it in JupyterLab, you can see the full code in *Figure 2.6*, as
    well as several possible outputs based on the selected value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – An interactive Dash app in a Jupyter Notebook](img/B16780_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – An interactive Dash app in a Jupyter Notebook
  prefs: []
  type: TYPE_NORMAL
- en: I also introduced a simple new component, `html.Br`, which simply provides a
    regular HTML `<br>` element, for better readability of the output.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have completed our first isolated and interactive app. We ran
    it in JupyterLab, and we did so step by step, analyzing every tiny detail. The
    app that we have just built uses a toy dataset and implements extremely simple
    functionality. We did this so that we could focus on the mechanism that creates
    interactivity. There's not much practical value in telling the user what color
    they know they just selected.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we will now add functionality to answer a real question
    for the user – a question that might be tedious to answer if they were to skim
    through the whole dataset.
  prefs: []
  type: TYPE_NORMAL
- en: We will also incorporate this new feature into our app and examine how it fits
    with the other content and functionality that we created already.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the function into the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the plan for the functionality that we are going to introduce:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a drop-down list using the countries and regions available in our dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a callback function that takes the selected country, filters the dataset,
    and finds the population of that country in the year 2010.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return a small report about the found data. *Figure 2.7* shows the desired end
    result:![Figure 2.7 – A drop-down list used to display the selected country's
    population](img/B16780_02_007.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 2.7 – A drop-down list used to display the selected country's population
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are beginning to use our dataset, we will start opening files from
    the `data` folder. This assumes that the app you are running is in the same folder.
    The code for each chapter in the GitHub repository is placed in its own folder
    for easy access; however, the code only works if the `data` folder and `app.py`
    are both in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.8* shows what this folder structure might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The assumed folder structure for the app](img/B16780_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The assumed folder structure for the app
  prefs: []
  type: TYPE_NORMAL
- en: As agreed, we will run a minimal app in JupyterLab, make sure it is running
    properly, keep a copy, and then add it to the app.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to take a look at the dataset, explore it a little bit, and learn
    how to implement the new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view what files we have in the dataset, we can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to check out the files and their contents if you wish to. For now,
    we will be working with the `PovStatsData.csv` file. For a quick overview of its
    structure, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code snippet in JupyterLab displays the first three rows of the
    dataset, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The first few rows and columns of the poverty dataset](img/B16780_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The first few rows and columns of the poverty dataset
  prefs: []
  type: TYPE_NORMAL
- en: It seems that we have two fixed variable columns (`NaN`) values are available
    under their respective year column. Here, the years span from 1974 to 2019 (note
    that not all of the years are shown for better readability). The countries and
    indicators also have codes, which can be useful later when we want to merge different
    DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Fixed variables refers to variables that are known in advance and don't change;
    in this case, they are the countries and the indicators. The measured variables
    are the values that we are interested in knowing, for example, the population
    of country A in year B. Fixed variables are also known as "dimensions." Technically,
    they are all columns in the dataset, and this is a conceptual distinction that
    is useful for analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060), *Data Manipulation
    and Preparation - Paving the Way to Plotly Express*, we will explore data formats
    and how they might affect our analysis and visualization. The current structure
    can be improved by having a column for "year," and another column for "values,"
    which makes it standardized and more intuitive for analysis. For now, since we
    are focusing on callback functions, we will keep the data format as it is so that
    we don't get distracted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement the plan with code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a drop-down list. Here, we use the pandas `Series.unique`
    method to deduplicate countries and regions. Right underneath that, we create
    an empty div with `id=''report''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we create a callback function that takes the selected country, filters
    the dataset, and finds the population of that country in the year 2010\. The filtering
    will take two steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether no country has been provided to the function, which happens when
    the user first accesses the page or when the user deselects values from the dropdown.
    Here, we simply return the empty string:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s focus on the filtering part. First, we take the selected country
    and filter the `poverty_data` DataFrame to get the population value. We then define
    the `filtered_df` variable. This takes the selected country and gives the rows
    where the `population` variable. We do this by using the pandas `loc` method,
    where we take all of the `:` rows and the column name `values` attribute and get
    the number at index zero:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s return a small report about the data that has been found. Now
    that we have the population number that we are interested in, we return a list
    that contains two elements. The first is an <h3> element, showing the `country`
    variable using a large font. The second is a sentence that takes two dynamic values,
    which are inserted where they belong, as you can see in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that since we already have a div element in the layout, and we have indicated
    that we are modifying its `children` property (which takes a single value or a
    list), the return value of the function can simply be a list (or a single value).
  prefs: []
  type: TYPE_NORMAL
- en: I have formatted the `population` value in the report to make it easier to read.
    The colon indicates that the following string is how we want to format it. The
    comma indicates that we want thousands to be separated by a comma. The dot indicates
    how to format decimal places. A zero after the dot indicates the number of decimal
    places, and the `f` indicates that we are dealing with floats.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to refactor our code to include the new visual elements, as
    well as the new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picking up where we left off in the last version of our app in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*, the dropdown and report div should go between
    the `H2` and `Tabs` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function should come after the closing parentheses of the top-level
    `html.Div` of the app. Here is the full code of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the app again, you should get this updated view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The updated app with the dropdown and simple population report](img/B16780_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – The updated app with the dropdown and simple population report
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `app.run_server` method takes an optional `port` argument, which defaults
    to `app.run_server(port=1234)`. This also applies to `jupyter_dash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our callbacks enabled and working, we can finally start using
    that blue button in the bottom-right corner! Clicking on it and then selecting
    **Callbacks** shows an interactive diagram displaying the components exactly as
    we specified them. The **country** and its **value**, and the **report** and its
    **children**. *Figure 2.11* shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The Dash visual debugger in action](img/B16780_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The Dash visual debugger in action
  prefs: []
  type: TYPE_NORMAL
- en: The **Server** button is green, which means it's running fine. We also see that
    we have "0 Errors." When you have this debugger opened in a running app, and while
    modifying the components, you can also see the path of the callbacks and what
    is triggering what. The components that are involved in triggering a callback
    light up, so you can "see" what is going on. This becomes much more useful in
    complex situations. The nodes of the graph are also interactive, and you can move
    them around by increasing/decreasing the size of the overall graph so that you
    can zoom in and out wherever you want. And yes, this graph is a Dash app, using
    another one of Dash's packages.
  prefs: []
  type: TYPE_NORMAL
- en: The green rectangle in the middle shows two interesting numbers. The one on
    top, showing **1**, tells us how many times this callback has been fired so far.
    The one at the bottom shows how long it took to run this callback function. This
    is very helpful in tracking and analyzing performance.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used a single-value input (not a list, for example) to modify
    an output. But what if we wanted to get multiple values and do something with
    them? What if we wanted to process values from multiple sources, for example,
    drop-down values and a date? All this and more is possible with Dash's callback
    functions. Did I mention that they were the heart of Dash?
  prefs: []
  type: TYPE_NORMAL
- en: I believe we've done enough coding in this chapter, and I think it's a good
    idea to have an overview of what lies ahead in terms of the power of callback
    functions, what they can do, and some of their interesting attributes. These are
    just things to keep in mind and know for now; we will be exploring how each feature
    works as we progress through the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of Dash's callback functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s recap the properties of Dash''s callback function and introduce a few
    others that will be explored in more detail later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple inputs**: As I just mentioned, we can give callbacks to more than
    one input, and create more complex functionality. Using our dataset as an example,
    we can easily imagine a dropdown to select countries, another to select dates,
    and yet another to specify the economic indicator that you want to analyze. Those
    inputs could be used to filter a subset of the DataFrame and return the values
    that you want, based on multiple criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input`): The country selector can be made to accept multiple values, so we
    can loop over them and visualize the same trend for the same indicator for multiple
    countries in one chart (or a chart per country).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple outputs**: As with multiple inputs, multiple outputs can be modified
    using one callback function. In our example, we might imagine producing two outputs
    – one that is a chart visualizing the filtered data and another that is a table
    – providing the user with the raw data if they want to export and further analyze
    this particular subset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**They can do other things before returning**: We have mainly focused on callbacks
    being simple processors of data, but they can really do anything before returning.
    For example, you can imagine a function sending an email under certain conditions.
    Logging is another interesting thing to explore. All you have to do is simply
    log the arguments given to each function. This can give you insights into what
    people are interested in, which functionality is being used, and more. You can
    even parse those logs and develop your own separate analytics app based on that!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input` in the decorator should correspond to the first parameter of `my_function`.
    I used the same names in the preceding snippet to make it explicit and clear (`dropdown`
    and `date`). The same applies to outputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State`. In the examples we have discussed so far, the callbacks immediately
    fire when the values change. Sometimes, you don''t want that. For example, if
    you have multiple inputs, it might be annoying for the user to have the outputs
    change while they are configuring their options. Imagine having a textbox that
    modifies another element on the page. Every letter the user enters would modify
    it, which is not the best user experience. The typical scenario for using `State`
    is to have buttons. The user selects or enters values, and once they are ready,
    they can click on a button, which only then triggers the callback function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 2.12* presents a conceptual diagram of a more complex callback function
    and what it might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – A callback function handling multiple inputs and outputs, as
    well as running other tasks](img/B16780_02_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – A callback function handling multiple inputs and outputs, as well
    as running other tasks
  prefs: []
  type: TYPE_NORMAL
- en: We have now created and run two callback functions in two different contexts.
    We also incorporated one of them and built on the work we did in [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015),
    *Overview of the Dash Ecosystem*. With a few more examples, you will have mastered
    callback functions. The next skills you need to conquer are managing complexity
    and being comfortable with refactoring code while keeping things organized and
    under control.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly recap what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we introduced a new way to run Dash apps, which is by running them in
    a Jupyter Notebook environment. We saw how familiar the process is, and we created
    our first interactive app in a notebook. We went through every detail in the process
    from creating layout components, giving them IDs, and selecting which of their
    properties will be used, to connecting all of this with the callback function.
    We ran another example and familiarized ourselves with our dataset. Most importantly,
    we learned how to incorporate the new work into the app, and we ran an updated
    version that produced simple population reports. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deep dive into Plotly's data visualization
    capabilities. We will mainly focus on the **Figure** object, its components, how
    to query them, and how to modify them. This will give us fine-grained control
    over the visualizations that we will make.
  prefs: []
  type: TYPE_NORMAL
