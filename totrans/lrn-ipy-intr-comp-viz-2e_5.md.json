["```py\nIn [1]: from IPython.parallel import Client\n\n```", "```py\nIn [2]: rc = Client()\n\n```", "```py\nIn [3]: rc.ids\nOut[3]: [0, 1]\n\n```", "```py\nIn [4]: import os\nIn [5]: %px print(os.getpid())\n[stdout:0] 6224\n[stdout:1] 3736\n\n```", "```py\nIn [6]: %pxconfig --targets 1\nIn [7]: %px print(os.getpid())\n3736\n\n```", "```py\nIn [8]: %%px --targets :-1\n print(os.getpid())\n[stdout:0] 6224\n\n```", "```py\nIn [9]: %%px --noblock\n import time\n time.sleep(1)\n os.getpid()\nOut[9]: <AsyncResult: execute>\n\n```", "```py\nIn [10]: %pxresult\nOut[1:12]: 3736\n\n```", "```py\nIn [11]: v = rc[:]\n\n```", "```py\nIn [12]: with v.sync_imports():\n import time\nimporting time on engine(s)\n\n```", "```py\nIn [13]: def f(x):\n time.sleep(1)\n return x * x\n\n```", "```py\nIn [14]: v.map_sync(f, range(10))\nOut[14]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n```", "```py\nIn [15]: %timeit -n 1 -r 1 v.map_sync(f, range(10))\n1 loops, best of 1: 5.02 s per loop\nIn [16]: %timeit -n 1 -r 1 map(f, range(10))\n1 loops, best of 1: 10 s per loop\n\n```", "```py\nIn [17]: r = v.map(f, range(10))\nIn [18]: r.ready(), r.elapsed\nOut[18]: False, 2.135\nIn [19]: r.get()\nOut[19]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nIn [20]: r.elapsed, r.serial_time\nOut[20]: (5.023, 10.008)\n\n```", "```py\nIn [1]: def sample(n):\n return (rand(n) ** 2 + rand(n) ** 2 <= 1).sum()\n\n```", "```py\nIn [2]: n = 1000000.\nIn [3]: 4 * sample(n) / n\nOut[3]: 3.142184\n\n```", "```py\nIn [4]: from IPython.parallel import Client\n rc = Client()\n v = rc[:]\n with v.sync_imports():\n from numpy.random import rand\nIn [5]: 4 * sum(v.map_sync(sample, [n] * len(v))) / (n * len(v))\nOut[5]: 3.141353\n\n```", "```py\nipython profile create --parallel --profile=mpi\n\n```", "```py\nc.IPClusterEngines.engine_launcher_class = 'MPIEngineSetLauncher'\n\n```", "```py\nipcluster start -n 4 --profile=mpi\n\n```", "```py\nfrom mpi4py import MPI\nimport numpy as np\n\n# This function will be executed on all processes.\ndef psum(a):\n    # \"a\" only contains a subset of all integers.\n    # They are summed locally on this process. \n    locsum = np.sum(a)\n\n    # We allocate a variable that will contain the final result, that \n# is the sum of all our integers.\n    rcvBuf = np.array(0.0,'d')\n\n    # We use a MPI reduce operation:\n    #   * locsum is combined from all processes\n    #   * these local sums are summed with the MPI.SUM operation\n    #   * the result (total sum) is distributed back to all processes in\n    #     the rcvBuf variable\n    MPI.COMM_WORLD.Allreduce([locsum, MPI.DOUBLE],\n        [rcvBuf, MPI.DOUBLE],\n        op=MPI.SUM)\n    return rcvBuf\n```", "```py\nIn [1]: from IPython.parallel import Client\nIn [2]: c = Client(profile='mpi')\nIn [3]: view = c[:]\nIn [4]: view.activate() # enable magics\nIn [5]: view.run('psum.py') # the script is run on all processes\nIn [6]: view.scatter('a', np.arange(16)) # this array is scattered across processes\nIn [7]: %px totalsum = psum(a) # psum is executed on all processes\nParallel execution on engines: [0, 1, 2, 3]\nIn [8]: view['totalsum']\nOut[8]: [120.0, 120.0, 120.0, 120.0]\n\n```", "```py\n[build]\ncompiler = mingw32\n```", "```py\nIn [1]: %load_ext cythonmagic\n\n```", "```py\nIn [2]: %%cython\n def square(x):\n return x * x\nIn [3]: square(10)\nOut[3]: 100\n\n```", "```py\nIn [1]: def primes1(n):\n            primes = [False, False] + [True] * (n - 2)\n            i = 2\n            # The exact code from here to the end of the function\n            # will be referred as #SIEVE# in the next examples.\n            while i < n:\n                # we do not deal with composite numbers\n                if not primes[i]:\n                    i += 1\n                    continue\n                k = i * i\n                # mark multiples of i as composite numbers\n                while k < n:\n                    primes[k] = False\n                    k += i\n                i += 1\n            return [i for i in xrange(2, n) if primes[i]]\nIn [2]: primes(20)\nOut[2]: [2, 3, 5, 7, 11, 13, 17, 19]\n```", "```py\nIn [3]: n = 10000\nIn [4]: %timeit primes1(n)\n100 loops, best of 3: 5.54 ms per loop\n\n```", "```py\nIn [5]: %load_ext cythonmagic\nIn [6]: %%cython\n        def primes2(n):\n            primes = [False, False] + [True] * (n - 2)\n            i = 2\n            #SIEVE#: see full code above\nIn [7]: timeit primes2(n)\n100 loops, best of 3: 3.25 ms per loop\n```", "```py\nIn [8]: %%cython\n        def primes3(int n):\n            primes = [False, False] + [True] * (n - 2)\n            cdef int i = 2\n            cdef int k = 0\n            #SIEVE#: see full code above\n```", "```py\nIn [9]: timeit primes3(n)\n1000 loops, best of 3: 538 us per loop\n\n```", "```py\nIn [1]: def step():\n            return sign(rand(1) - .5)\n\n        def sim1(n):\n            x = zeros(n)\n            dx = 1./n\n            for i in xrange(n - 1):\n                x[i+1] = x[i] + dx * step()\n            return x\n```", "```py\nIn [2]: plot(sim1(10000))\n\n```", "```py\nIn [3]: n = 10000\nIn [4]: timeit sim1(n)\n1 loops, best of 3: 249 ms per loop\n\n```", "```py\nIn [4]: %%cython\n        import numpy as np\n        cimport numpy as np\n        DTYPE = np.double\n        ctypedef np.double_t DTYPE_t\n\n        # We redefine step() as a pure C function, using only\n        # the C standard library.\n        from libc.stdlib cimport rand, RAND_MAX\n        from libc.math cimport round\n\n        cdef double step():\n            return 2 * round(float(rand()) / RAND_MAX) - 1\n\n        def sim2(int n):\n            # Local variables should be defined as C variables.\n            cdef int i\n            cdef double dx = 1\\. / n\n            cdef np.ndarray[DTYPE_t, ndim=1] x = np.zeros(n,        dtype=DTYPE)\n            for i in range(n - 1):\n                x[i+1] = x[i] + dx * step()\n            return x\n```", "```py\nIn [5]: timeit sim2(n)\n1000 loops, best of 3: 670 us per loop\n\n```"]