- en: '*Chapter 7*: Exploring Map Plots and Enriching Your Dashboards with Markdown'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to explore how to handle maps, one of the most
    engaging types of charts. There are many ways of creating and handling maps, as
    well as many types of map plots. There are also many specialized geographic and
    scientific applications for maps. We will mainly be focusing on two of the most
    common types of map plots: **choropleth map plots** and **scatter map plots**.
    Choropleth maps are the type of maps we are most familiar with. These are the
    types of maps where geographical areas are colored to indicate a country, state,
    district, or any arbitrary polygon on a map, and express variations in quantity
    among them. Most of the knowledge we established in the previous chapter can easily
    be adapted to scatter map plots, as they are essentially the same, with a few
    differences. Similar to the *x* and *y* axes, we have longitude and latitude instead,
    and we also have different map projections. We will also learn about a new component,
    **Markdown**, from Dash Core Component.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will explore how to use **Mapbox**, which provides a rich interface
    with different layers, themes, and zoom levels. It also allows us to create choropleth
    and scatter map plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will mainly cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring choropleth maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing animation frames to add a new layer to your plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using callback functions with maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `Markdown` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding map projections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using scatter map plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Mapbox maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other map options and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating an interactive map into our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use similar tools to the ones we used in the previous chapter. We will
    mainly be using Plotly Express for creating our charts. The packages to use are
    Plotly, Dash, Dash Core Components, Dash HTML Components, Dash Bootstrap Components,
    pandas, and JupyterLab.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_07](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_07).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3sAY8z8](https://bit.ly/3sAY8z8).
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by exploring how easy it is to create choropleth maps for countries.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring choropleth maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choropleth maps are basically colored polygons representing a certain area
    on a map. Plotly ships with country maps included (as well as US states), and
    so it is very easy to plot maps if we have information about countries. We already
    have such information in our dataset. We have country names, as well as country
    codes, in every row. We also have the year, some metadata about the countries
    (region, income group, and so on), and all the indicator data. In other words,
    every data point is connected to a geographical location. So, let''s start by
    choosing a year and an indicator, and see how the values of our chosen indicator
    vary across countries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `poverty` file into a DataFrame and create the `year` and `indicator`
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subset of `poverty` with values from the selected year and containing
    countries only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a choropleth map using the `choropleth` function from Plotly Express,
    by choosing the column that identifies the countries and the column that will
    be used for the colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the result of the preceding code in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A choropleth map of countries](img/B16780_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A choropleth map of countries
  prefs: []
  type: TYPE_NORMAL
- en: 'The country codes we provided were already included in Plotly, and are in the
    three-letter ISO format. As with scatter plots, you can see that since we provided
    a numeric column for the color, a continuous color scale was chosen. Otherwise,
    we would have gotten a discrete color sequence. For example, setting `color=''Income
    Group''` would produce the chart in *Figure 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A choropleth map of countries with a discrete color sequence](img/B16780_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A choropleth map of countries with a discrete color sequence
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, and similar to what we saw in [*Chapter 6*](B16780_06_Final_NM_ePub.xhtml#_idTextAnchor090),
    *Exploring Variables with Scatter Plots and Filtering Subsets with Sliders*, the
    color system works in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use normal country names to plot them. To do that, we only need
    to set `locationmode=''country names''` and the rest works the same. Here is an
    example with country names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the chart in *Figure 7.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A choropleth map of countries using country names](img/B16780_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – A choropleth map of countries using country names
  prefs: []
  type: TYPE_NORMAL
- en: 'The title of the color bar is `color` because it is not clear what it is, and
    it is not a name of a column in a DataFrame. We can rename it by setting `labels={''color'':
    <metric_name>}` to indicate what the metric is in our case. Let''s now see how
    we can make the chart interactive (without using a callback).'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing animation frames to add a new layer to your plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last examples, we set the year as a variable and got a snapshot of the
    desired indicator for that year. Since the years represent sequential values,
    and can also be used as a grouping variable, we can use the years in the `animation_frame`
    parameter and make the chart interactive. This would introduce a new handle underneath
    the chart, where users can either drag to the desired year or press the play button
    to watch how the respective indicator progresses throughout the years. It would
    be a sequence of frames, like watching a video. What this does is that for a selected
    year, we will get a subset of the DataFrame where the rows in the `year` column
    are equal to the selected year. The chart automatically updates with colors corresponding
    to the values of the year that was chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated code to produce an animated chart (by year):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the updated chart in *Figure 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A choropleth map of countries with an animation frame](img/B16780_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A choropleth map of countries with an animation frame
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all we had to do is select a column name to use for `animation_frame`,
    and everything is handled for us. We used a DataFrame where we only have countries,
    which includes all years. The further sub-setting is done automatically by the
    argument given to `animation_frame`. We can drag the handle to a specific year
    or press the play button and watch how it changes over time. Note that we also
    changed the color scale to experiment with a different one. Both color scales
    used so far should also be readable on a grayscale version of the map.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic map in place, let's explore what options we have to
    control several aspects of the map. The `layout` attribute of map charts has a
    sub-attribute called `geo`, under which there are several useful geographic attributes
    that allow us to control many aspects of our maps. These attributes work the same
    way as other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We basically set them by running `fig.layout.geo.<attribute> = value` to set
    the desired value. Let''s explore some of these attributes and their effects on
    the previous chart:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the rectangular frame around the map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Show the country borders, even if/when we don''t have data for some countries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a different projection of the Earth. Select the `natural earth` projection
    type (more on this later):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Limit the vertical range of the chart to focus more on countries, by setting
    the minimum and maximum latitude values that the map should show:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Limit the horizontal range of the chart using the same technique:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the color of the land to `''white''` to make it clear which countries
    have missing data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the background color of the map (the color of the oceans), as well as the
    "paper" background color of the figure as a whole. Use the same color that we
    are using for the app to have a consistent theme:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the colors of the country borders as well as the coastlines to `''gray''`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the title of the color bar is taking up a lot of horizontal space, replace
    spaces with the `<br>` character, to split it to multiple lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As a result, we get the updated chart in *Figure 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – A choropleth map of countries with custom geo options](img/B16780_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – A choropleth map of countries with custom geo options
  prefs: []
  type: TYPE_NORMAL
- en: With a few commands, we have transformed how our chart looks. We restricted
    the ranges to focus mainly on countries and land, as much as possible. We also
    set consistent background colors and displayed country borders. There are several
    other options that can easily be explored under the `fig.layout.geo` attribute.
    We are now ready to make the indicator selection dynamic; let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Using callback functions with maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we have done so far was done with one indicator, and we used this indicator
    to select the desired column from the dataset. We can easily create a dropdown
    to allow users to choose any of the available indicators and let them explore
    the whole dataset. The `year` variable is already interactive and part of the
    chart, as used by the `animation_frame` parameter. So, this can become the first
    exploratory interactive chart that users start with on our app, to help them get
    an overview of the available metrics and how they are changing in time.
  prefs: []
  type: TYPE_NORMAL
- en: Setting this up is straightforward, as we did several times. We will implement
    it, and after that, we will see how to use the `Markdown` component to add context
    around/about the map chart and the chosen indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the necessary steps to implement this functionality independently
    in JupyterLab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Dropdown` component, where the available options are the column names
    of `poverty`, using the columns between the third and 54th columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an empty `Graph` component, right under the dropdown we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The indicator names vary in length, and some of them are so long that they
    take up almost half the screen size. We can handle this in a similar way to what
    we did previously, by creating a simple function. The function takes a string,
    splits it into words, groups every three words together, and then joins them with
    the `<br>` character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a callback that links the dropdown with the map chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function that takes the selected indicator and returns the desired
    map chart. Note that we set the title of the figure by using the indicator as
    its value. We also used the `Country Name` column to set the hover name, which
    is the title of the box that appears when users hover over a certain country.
    The height was also set to `650` pixels. The remaining geo properties were omitted
    here to avoid repetition, but they are the same as we set them previously. We
    also modify the color bar title, using the `multiline_indicator` function we just
    created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the app in JupyterLab, you can explore the different metrics. *Figure
    7.6* shows a few examples of charts produced by selecting different indicators
    and years:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Examples of map charts produced interactively](img/B16780_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Examples of map charts produced interactively
  prefs: []
  type: TYPE_NORMAL
- en: Once given the option, users can search the dropdown for various keywords and
    select what they find interesting. It is still not very clear what exactly many
    of these indicators refer to and what their limitations might be. This is a good
    opportunity for us to display those details to users, to make it clear what they
    are looking at. As mentioned previously, the limitations in measurement are crucial
    to highlight, so users are aware of them. Let's see how we can add formatted text
    using the `Markdown` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Markdown component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Markdown is a way to produce HTML in a manner that is easy to write and also
    easy to read. The output would be displayed as any HTML document would, but the
    process of writing it and reading it is much easier. Compare the following two
    snippets, which result in the same HTML output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using pure HTML, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code can be written with Markdown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I think it's clear that Markdown is much easier to write, as well as to read,
    especially when you have nested items such as the `<ul>` unordered list we have
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Markdown` component works the same way. The preceding code simply has
    to be passed to the `children` argument, which would render it as the HTML shown
    previously. Let''s create a minimal app in JupyterLab to see how the `Markdown`
    component works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the necessary imports and instantiate an app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the layout attribute of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass the `Markdown` component with the preceding text to the `div` just created.
    Note that it is easier to use triple quotes especially when using multiline text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code creates a mini-app with its output shown in *Figure 7.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A sample output of the Markdown component](img/B16780_07_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – A sample output of the Markdown component
  prefs: []
  type: TYPE_NORMAL
- en: Markdown has several other ways of displaying text, such as numbered lists,
    tables, links, bold and italic text, and more. We will be covering some of these
    features, but they are easy to pick up in case you are not familiar with them.
    Keep in mind that there are various "flavors" of Markdown used by different platforms.
    You might come across slightly different markup/syntax rules but in general, there
    is a lot of overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add some information to the map that the user generates after selecting
    the metric of their choice. Basically, we will add the important information right
    underneath the map and slider. *Figure 7.8* shows how this will look, in order
    to give you an idea of what we are working toward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – A sample of the Markdown component](img/B16780_07_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – A sample of the Markdown component
  prefs: []
  type: TYPE_NORMAL
- en: All the text and formatting you see in the figure are produced by the `Markdown`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a special area for it on the app, we simply add a `Markdown`
    component under the map, giving it a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Producing this component will happen in the same callback we created to generate
    the map. The callback should now take two `Output` elements instead of one, and
    when returning, it should return two elements as well (the figure, as well as
    the Markdown generated). To get the required content for this component, we need
    to open the file that contains all the details about the indicators. This has
    been done previously, but as a reminder, we can get it by running `series = pd.read_csv(''data/PovStatsSeries.csv'')`.
    Let''s now implement these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right under the `Graph` component, add the new `Markdown` component (note that
    we also set its background color to be consistent with the map, as well as the
    whole app). The `_md` suffix is for `Markdown`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the callback function by including the new component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After finishing the definition of the `fig` variable in the callback function,
    we now run the necessary steps for creating the `Markdown` output. Create the
    appropriate subset of `series`, by getting the row where the `Indicator Name`
    column is equal to the selected indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the value of the `Limitations and exceptions` columns from `series_df`.
    Note that since some values are missing and since missing values are not strings,
    we fill them with the string `N/A`, and we also replace any instances of two newline
    characters, `\n\n`, with a single space, if any. We then extract the first element
    under its `values` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have defined two variables, `series_df` and `limitations`, we will
    use Python''s f-string formatting to insert variables where they belong using
    curly braces: f''`{<variable_name>}''`. We first insert the indicator name using
    an `<h2>` element. Headings in Markdown correspond to their HTML equivalents,
    where the number of hash signs corresponds to the heading level. Here we use two
    signs for `<h2>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we add the long description in regular text, without any hash signs before
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add the bullet points for `Unit of measure`, `Periodicity`, and `Source`.
    Bullet points can be created by adding a star at the beginning of the line for
    each bullet point. This is a simple process of getting the right element from
    the right column. Note that we fill missing values for `Unit of measure` by using
    the word `count`, which will replace the missing values where the indicator is
    a simple count and not a percentage. Population is one such example. In the case
    of `Periodicity`, we simply replace it with `N/A` wherever the respective value
    is missing. The stars before and after any text make it bold, similar to running
    `<b>text</b>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Limitations and exceptions` subtitle in `<h3>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we add the already created `limitations` variable in regular text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Putting the preceding code together, here is the full code that creates our
    `Markdown` component, with its relative position in the callback function. Note
    that in some cases, there are a few indicators that don''t have details in the
    `series` DataFrame. In this case, we set the `Markdown` variable to a string,
    indicating the lack of such details. This condition can be seen in the following
    code as well, in the check to `series_df.empty`; otherwise, everything runs as
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We finally return a tuple of `fig, markdown` instead of only `fig` as we did
    in the previous version. Adding this code to the app would add the respective
    Markdown to the map and give it much better context, as well as pointing out the
    limitations that our users need to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: We will now turn to see the different projections that maps can be displayed
    in, and how we can change them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding map projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used an example of one projection type in our map, and now we'll explore
    this topic in more detail. When we try to draw the Earth (or part of it) on a
    flat rectangle, the shape is inevitably distorted somehow. So, there are different
    ways, or projections, available that can be used. No projection is perfect, and
    there are trade-offs between accuracy in shape, area, relative position, and so
    on. The details of which projection is more appropriate depends on the application
    and is beyond the scope of this book. We will, however, explore how to change
    the projection being used and see how to get the available projections.
  prefs: []
  type: TYPE_NORMAL
- en: With Plotly Express, we have a `projection` parameter in the map functions,
    which takes a string and can be used to set the desired projection type. Alternatively,
    we can also set it by assigning a value to `fig.layout.geo.projection.type` as
    we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.9* shows a few of the available options together with their respective
    names in the titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – A sample of the available map projections](img/B16780_07_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – A sample of the available map projections
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are different ways of displaying the Earth. While **orthographic**
    might seem more realistic in its shape, its problem is that we can only see part
    of the Earth, so we lose perspective. The **azimuthal equal area** projection
    is actually quite realistic when you use it interactively and zoom into certain
    areas. Feel free to experiment with different projections and select what works
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have experimented with polygon or choropleth maps so far, and now we will
    be exploring another type of map, with which we are already generally familiar:
    the scatter map.'
  prefs: []
  type: TYPE_NORMAL
- en: Using scatter map plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main difference between the *x* and *y* axes and longitude and latitude
    is due to the shape of the Earth. As we approach the equator, the vertical meridians
    are as far away from each other as possible, and as we approach the North and
    South poles, they are as close as possible to each other. *Figure 7.10* shows
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – A map of the Earth, showing longitude and latitude lines](img/B16780_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – A map of the Earth, showing longitude and latitude lines
  prefs: []
  type: TYPE_NORMAL
- en: In other words, as we approach the equator, we have a more rectangular shape,
    because a unit of longitude is close to a unit of latitude. Close to the poles,
    the proportions are completely different, and the rectangles start to approximate
    triangles. This is in contrast to a rectangular plane, where a vertical unit of
    distance corresponds to the same horizontal unit of distance, regardless of where
    you are on the plane. This assumes a linear scale on both axes, of course. An
    exception to this is the logarithmic axis, which we covered in [*Chapter 6*](B16780_06_Final_NM_ePub.xhtml#_idTextAnchor090),
    *Exploring Variables with Scatter Plots and Filtering Subsets with Sliders*. Map
    projections handle this for us, and we don't have to worry about this issue. So,
    we can simply think of them as we think about the *x* and *y* axes and select
    the projection that we want.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can make a scatter map plot with Plotly Express using the `scatter_geo`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we created `df`, where the year is equal to 2010, and we filtered out
    non-countries. Then, just like we did with choropleth maps, we selected the column
    to use for the `locations` parameter. This generates the simple chart in *Figure
    7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – A scatter map using the scatter_geo function](img/B16780_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – A scatter map using the scatter_geo function
  prefs: []
  type: TYPE_NORMAL
- en: You can see how easy it is to do so. There is not much information in this chart,
    other than markers on countries, showing the **Country Code** value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The country names are supported by default by Plotly. Another interesting application
    might be to use the `lat` and `lon` parameters to plot arbitrary locations on
    the map, as you can see in the following code and *Figure 7.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – A scatter map using latitude and longitude data](img/B16780_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – A scatter map using latitude and longitude data
  prefs: []
  type: TYPE_NORMAL
- en: You can easily apply the concepts we covered in [*Chapter 6*](B16780_06_Final_NM_ePub.xhtml#_idTextAnchor090),
    *Explore Exploring Variables with Scatter Plots and Filtering Subsets with Sliders*,
    to modify the size and map colors, set the opacity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will now explore these options by introducing another richer way of producing
    maps, using Mapbox.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Mapbox maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mapbox is an open source library for maps. It is backed by a company with the
    same name that also provides additional services, layers, and themes to produce
    rich mapping applications. The options we will be using here can be used immediately
    with Plotly, but there are some other styles and services that require you to
    register for an account and use a token every time you generate a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example should make it easy to start with, as we are already very familiar
    with scatter plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should be straightforward. The `lon` and `lat` parameters
    are the equivalents of the `x` and `y` parameters for scatter plots. The `size`
    and `color_discrete_sequence` parameters have already been covered. An interesting
    new parameter is the `zoom` parameter, which we set to `2` here. This can take
    an integer value from `0` (the whole world) to `22` (building-level zoom), inclusive.
    We can also see how easy it is to set the center of a map, which we did using
    the first point''s coordinates (5, 10). Finally, the `mapbox_style` parameter
    provides a set of interesting options to display maps in different styles. The
    `stamen-watercolor` style gives it an artistic look and can be seen in *Figure
    7.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – A scatter map using Mapbox and a custom style](img/B16780_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – A scatter map using Mapbox and a custom style
  prefs: []
  type: TYPE_NORMAL
- en: Hovering over the **i** on the map displays the sources of the tiles and data.
    As you can see, there are so many layers and work condensed into this simple function.
    Let's now use the same approach to plot some data from our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Because `scatter_mapbox` mainly works with latitude and longitude data, and
    our dataset does not include any such data about the countries, we will obtain
    the data, merge it, and then plot the markers where they belong.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many sources for such data, and a quick online search will lead to
    some good sources. We can use the pandas `read_html` function for that. It takes
    a URL, downloads all the `<table>` elements at that URL, and returns a list of
    DataFrame objects. We simply have to take the one that we want. In this case,
    it is the first one. The following code achieves this, and creates the `lat_long`
    variable, which is a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you remember our discussion in [*Chapter 4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060),
    *Data Manipulation and Preparation - Paving the Way to Plotly Express*, where
    we went through several data manipulation operations, we will utilize the `merge`
    function from `pandas` to merge `lat_long` into `poverty` using a left merge operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first take a look at the structure of the `lat_long` DataFrame by simply
    printing it in JupyterLab, and you can see the top and bottom five rows in *Figure
    7.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – The lat_long DataFrame containing latitude and longitude data
    for countries](img/B16780_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – The lat_long DataFrame containing latitude and longitude data
    for countries
  prefs: []
  type: TYPE_NORMAL
- en: 'The `poverty` DataFrame also has a column called `2-alpha code`, which contains
    country codes using the same two-letter standard, so we merge using those columns
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the columns of `lat_long` to `poverty`, aligning the rows where
    they belong, as well as duplicating them where necessary. Remember, we are merging
    using the `left` method, which means the `left` argument is the basis for the
    merge. You can see a random sample of rows together with the important columns
    after merging in *Figure 7.15* to make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – A subset of the poverty DataFrame merged with lat_long](img/B16780_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – A subset of the poverty DataFrame merged with lat_long
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the case where we didn't have values for the longitude and latitude,
    we have **NaN**. In the cases where the same country name exists, for example,
    **Tajikistan**, the longitude and latitude values are simply duplicated, to keep
    the mapping of those values to their respective country, regardless of which rows
    we choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to create a bubble chart (a scatter plot with the marker sizes
    reflecting a certain quantity). We just have to create a subset of `poverty` that
    contains only countries and removes any missing values for the required indicator,
    `Population, total`, in this case. This can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a bubble chart requires you call to the `scatter_mapbox` function,
    but we will go through the given arguments one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the function with the subset just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the columns that will be used for the longitude and latitude values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the desired zoom level, to show the whole Earth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Map the value of the indicator to the size of the markers and set a suitable
    maximum size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Map the income group that the respective country belongs to, to the color of
    the marker (discrete variables in this case):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Choose the `year` column as the one used to animate the chart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a suitable opacity level, because we will definitely have overlapping markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a suitable height for the figure as a whole, in pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add more information to the hover box, by including two more columns'' data
    to appear when users hover over markers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select a custom color sequence to differentiate the income groups that the
    countries belong to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a custom style for the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a title for the hover box, using the country name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set a title for the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the interactive chart in *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – A scatter_mapbox bubble chart for population by country using
    years as animation frames](img/B16780_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – A scatter_mapbox bubble chart for population by country using
    years as animation frames
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full code that we just discussed to make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can see how straightforward it is to set all the options, and how little
    code is involved. We only have to know the options and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this is an interactive chart, and users can zoom in and out, it is
    easy to handle the overlaps that we have, simply by zooming in one level. *Figure
    7.17* shows the same chart after zooming (by the user):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – A scatter_mapbox chart zoomed in for a better view](img/B16780_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – A scatter_mapbox chart zoomed in for a better view
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of bubble charts over choropleth charts is that they show how
    the value relates to the geographic area of the country (or any location) visualized.
    For example, *Figure 7.16* shows three interesting cases of Canada, Russia, and
    Australia, which seem to have a population that is relatively small compared to
    their area. In other words, their population density is low. This gives more perspective
    on this metric.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are so many options and ways to display and interact with
    maps, and we have barely scratched the surface of what can be done. We will now
    take a look at a few other options that are available, in case you are interested
    in learning more.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other map options and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are a few pointers on what you can explore further with mapping,
    without getting into too much detail.
  prefs: []
  type: TYPE_NORMAL
- en: You've probably thought about having custom polygons or areas to visualize as
    choropleth maps. What we have covered so far are standard countries only. Of course,
    you have the option of visualizing a custom area with arbitrary points.
  prefs: []
  type: TYPE_NORMAL
- en: There is a standard GeoJSON format for representing such information. It mainly
    consists of points, lines, and polygons. Points are simply locations on the map,
    similar to what we used for scatter map plots. Lines are groups of connected points,
    in a certain sequence, where the first and last points are not the same. And as
    you can guess, a polygon is similar to a line, but with the condition that the
    first and last points are the same. Note that many countries consist of more than
    one polygon. Most Plotly map functions support GeoJSON, and you can use it for
    custom map plotting.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful when you have custom data for custom locations and you need
    to obtain the relevant data.
  prefs: []
  type: TYPE_NORMAL
- en: Another important and useful project to consider learning about is `geopandas`.
    As the name clearly suggests, it is a specialized library that works like `pandas`,
    and provides special data structures and techniques for geographic data, most
    notably `GeoDataFrame`. It is worth learning if you have more specialized mapping
    requirements, or if you frequently need to customize maps further.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add the functionality we created to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating an interactive map into our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The map that we created, together with the `Dropdown` and `Markdown` components,
    can become the first exploratory tool in our app. We can remove the population
    bar chart now, and in its place, we can place the components we just created,
    for users to explore all the indicators, see them on the map, and scroll through
    the years, and for each indicator, get the full details, as well as seeing the
    limitations and potential issues. Once something catches the user's eye, they
    can then find another chart that gives more detail about the indicator they want
    if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fully incorporate the new functionality into our app, we need to
    go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the definition of `series` at the top of the `app.py` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the definition of the `multiline_indicator` function, anywhere before `app.layout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `Dropdown`, `Graph`, and `Markdown` components at the top of the app,
    right under the top headings, where we previously had the population bar chart.
    The following code shows how, including the component IDs to make it clear, but
    the full definitions have been omitted. Note also the addition of a `Col` component
    as well as setting the width of another `Col` component, both using the `lg` (large)
    parameter. The first one introduces an empty column before displaying the content,
    and the second controls the width of the content in this column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have explored several new options in this chapter, so let's summarize what
    we did.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started by exploring how to create choropleth maps, which are a type of map
    that we are all used to seeing. We also saw how to animate those maps if we have
    a sequential value, which in our case was viewing a certain indicator as it progressed
    throughout the available years. We then created a callback function and made the
    maps work with all the possible indicators that we have, so users could explore
    them all and then decide what they wanted to explore next.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we learned how to use Markdown to generate HTML content, and how
    to add it to a Dash app. We then explored the different ways of displaying maps,
    or projections, and saw how to select the projection that we want.
  prefs: []
  type: TYPE_NORMAL
- en: We went through another type of map, which is a scatter map plot. Building on
    the knowledge we established in the previous chapter, it was fairly straightforward
    to adapt that knowledge to scatter maps. We also learned about the rich options
    that Mapbox provides and explored a few other topics for further exploration with
    maps. Finally, we integrated the new functionality into our app, which now contains
    a lot of explanatory text about almost all of the indicators, so users have a
    much better view of what they are analyzing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle a different type of chart, one that helps
    in counting values and showing how they are distributed in our dataset, the **histogram**.
    We will also explore a new component, the Dash **DataTable**, which allows us
    to display tabular data in a rich way, with many options to filter, visualize,
    download, and more.
  prefs: []
  type: TYPE_NORMAL
