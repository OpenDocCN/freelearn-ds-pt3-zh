<html><head></head><body>
		<div id="_idContainer114">
			<h1 id="_idParaDest-103"><em class="italic"><a id="_idTextAnchor105"/>Chapter 10</em>: The Data Project – Prototyping Projects in Streamlit</h1>
			<p>In the previous chapter, we discussed how to create Streamlit applications that are specific to job applications. Another fun application of Streamlit is to try out new and interesting data science ideas and create interactive apps for others. Some examples of this include applying a new machine learning model to an existing dataset, carrying out an analysis on some data uploaded by users, or creating an interactive analysis on a private dataset. There are numerous reasons for making a project like this, such as personal education or community contribution. </p>
			<p>In terms of personal education, often, the best way to learn a new topic is to observe how it actually works by applying it to the world around you or a dataset that you know closely. For instance, if you are trying to learn how <em class="italic">Principal Component Analysis</em> works, you can always learn about it in a textbook or watch someone else apply it to a dataset. However, I have found that my comprehension of a topic goes through the roof when I actually apply it myself in practice. Streamlit is perfect for this. It allows you to give new ideas a shot in a responsive, fun environment that can be easily shared with others. Learning data science can be collaborative, which leads me to the next reason for creating data projects in Streamlit.</p>
			<p>In terms of community contribution, one of the best parts of Streamlit – and, frankly, data science – is the growing community around the tools and toys we routinely play with. By learning with others and sharing Streamlit apps on Twitter (<a href="https://twitter.com/tylerjrichards">https://twitter.com/tylerjrichards</a>), LinkedIn, and the Streamlit forums (<a href="https://discuss.streamlit.io/">https://discuss.streamlit.io/</a>), we can turn away from the zero-sum experience that is taught in most schools and universities (where if your classmate gets a good grade, that usually comparatively hurts you) and toward a positive-sum experience, where you directly benefit from the lessons learned by others. To use the previous example, if you create an app that helped you understand the statistics behind principal component analysis, sharing that with others will probably teach them something, too. </p>
			<p>In this chapter, we will run through one thorough data project from end to end, starting with an idea and ending with the final product. Specifically, we will cover the following topics:</p>
			<ul>
				<li>Data science ideation</li>
				<li>Collecting and cleaning data</li>
				<li>Making a <strong class="bold">Minimum Viable Product</strong> (<strong class="bold">MVP</strong>)</li>
				<li>Iterative improvement</li>
				<li>Hosting and promotion</li>
			</ul>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>In this section, we will utilize the website <em class="italic">Goodreads.com</em>, which is a popular website owned by Amazon, that is used to track everything about a user's reading habits, from when they started and finished books to what they would like to read next. It is recommended that you first head over to <a href="https://www.goodreads.com/">https://www.goodreads.com/</a>, sign up for an account, and explore around a little (perhaps you can even add your own book lists!). </p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/>Data science ideation</h1>
			<p>Often, coming <a id="_idIndexMarker375"/>up with a new idea for a data science project is the most daunting part. You might have numerous doubts. What if I start a project that no one likes? What if my data actually doesn't work out well? What if I can't think of anything? The good news is that if you are creating projects that you actually do care about and would use, then the worst-case scenario is that you have an audience of one! And if you send me (<em class="italic">tylerjrichards@gmail.com</em>)your project, I promise to read it. So that makes it an audience of two at the very least. </p>
			<p>Some examples I have either created or observed in the wild include the following:</p>
			<ul>
				<li>Recording ping-pong games for a semester to determine the best player with an Elo model (<a href="http://www.tylerjrichards.com/Ping_pong.html">http://www.tylerjrichards.com/Ping_pong.html</a>)</li>
				<li>Using natural language processing to determine the quality of Wi-Fi in hostels (<a href="https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/">https://www.racketracer.com/2015/11/18/practical-natural-language-processing-for-determing-wifi-quality-in-hostels/</a>)</li>
				<li>Analyzing thousands of pizza reviews to find the best NYC pizza near you (<a href="https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1">https://towardsdatascience.com/adventures-in-barstools-pizza-data-9b8ae6bb6cd1</a>)</li>
				<li>Analyzing your reading habits with Goodreads data (<a href="http://www.tylerjrichards.com/books_reco.html">http://www.tylerjrichards.com/books_reco.html</a>)</li>
			</ul>
			<p>Only one of these data projects uses Streamlit, as the rest came out before the library was released. However, all of these could have been improved by deploying them on Streamlit rather<a id="_idIndexMarker376"/> than just uploading them to a Jupyter Notebook (<em class="italic">project #1</em>) or a Word document/HTML file (<em class="italic">projects #2 and #3</em>). </p>
			<p>There are many different methods that you can use to come up with your own idea for a data project, but the most popular methods generally fall into three categories:</p>
			<ul>
				<li>Finding data that only you could gather (for example, your friend's ping-pong games)</li>
				<li>Finding data that you care about (for example, Goodreads' reading data)</li>
				<li>Thinking of an analysis/app you wish existed to solve a problem you have and executing it (for example, hostel Wi-Fi analysis or finding the best pizza near you in NYC). </li>
			</ul>
			<p>You can try one of these or start with another idea that you have already. The best method is the one that works best for you! For this chapter, we will walk through and recreate the Goodreads Streamlit app, in depth, as an example of a data project. You can access it again at <a href="http://www.tylerjrichards.com/books_reco.html">http://www.tylerjrichards.com/books_reco.html</a>. </p>
			<p><a id="_idTextAnchor108"/>This app is designed to scrape a user's Goodreads history and create a set of graphs to inform them about their reading habits since they started using Goodreads. The sets of graphs should be similar to the following screenshot:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B16864_10_1.jpg" alt=" Figure 10.1 – Examples of Goodreads' graphs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 10.1 – Examples of Goodreads' graphs</p>
			<p>I came up with this idea by doing a personal analysis of my book history, and then thinking to myself that others might also be interested in this analysis! There really was no better reason than that, and often, the most fun projects start out that way. To begin, we will work on collecting and cleaning the user data that exists on Goodreads. </p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor109"/>Collecting and cleaning data</h1>
			<p>There are two ways in which to get data from Goodreads: through their <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>), which allows developers to programmatically access data about books, and through their manual exporting function. Sadly, Goodreads is deprecating their API in the near future and, as of December 2020, are not giving access to more developers. </p>
			<p>The original Goodreads app uses the API, but our version will rely on the manual exporting function that the Goodreads website has instead. To get your data, head over to <a href="https://www.goodreads.com/review/import">https://www.goodreads.com/review/import</a> and download your own data. If you do not have a Goodreads account, feel free to use my personal data for this, which can be found at <a href="https://github.com/tylerjrichards/goodreads_book_demo">https://github.com/tylerjrichards/goodreads_book_demo</a>. I have saved my Goodreads data in a file, called <strong class="source-inline">goodreads_history.csv</strong>, in a new folder, called <strong class="source-inline">streamlit_goodreads_book</strong>. To make your own folder with the appropriate setup, run the following in your Terminal:</p>
			<p class="source-code">mkdir streamlit_goodreads_book</p>
			<p class="source-code">cd streamlit_goodreads_book</p>
			<p class="source-code">touch goodreads_app.py</p>
			<p>Now we are ready to get started. We really have no idea what this data looks like or what is in this dataset, so our first steps are to do the following:</p>
			<ul>
				<li>Put titles and <a id="_idIndexMarker377"/>an explanation at the top of our app.</li>
				<li>Allow the user to <a id="_idIndexMarker378"/>upload their own data with ours as the default if they have no data of their own.</li>
				<li>Write the first few rows of data to the app so that we can take a look at it.</li>
			</ul>
			<p>The following code block does all of this. Feel free to change the text so that your app has your name, and also add links to a profile of you that people can view! As of now, around 10 percent of the traffic to my personal website comes from the Streamlit apps I have produced:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">st.title('Analyzing Your Goodreads Reading Habits')</p>
			<p class="source-code">st.subheader('A Web App by [Tyler Richards](http://www.tylerjrichards.com)')</p>
			<p class="source-code">'''</p>
			<p class="source-code">Hey there! Welcome to Tyler's Goodreads Analysis App. This app analyzes (and never stores!) </p>
			<p class="source-code">the books you've read using the popular service Goodreads, including looking at the distribution </p>
			<p class="source-code">of the age and length of books you've read. Give it a go by uploading your data below!</p>
			<p class="source-code">'''</p>
			<p class="source-code">goodreads_file = st.file_uploader('Please Import Your Goodreads Data')</p>
			<p class="source-code">if goodreads_file is None:</p>
			<p class="source-code">     books_df = pd.read_csv('goodreads_history.csv')</p>
			<p class="source-code">     st.write("Analyzing Tyler's Goodreads history")</p>
			<p class="source-code">else:</p>
			<p class="source-code">     books_df = pd.read_csv(goodreads_file)</p>
			<p class="source-code">     st.write('Analyzing your Goodreads history')</p>
			<p class="source-code">st.write(books_df.head())</p>
			<p>Now, when we run this <a id="_idIndexMarker379"/>Streamlit app, we should get an app that looks similar to the following screenshot:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B16864_10_2.jpg" alt="Figure 10.2 – The first five rows&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – The first five rows</p>
			<p>As you can see, we get a<a id="_idIndexMarker380"/> dataset where each book is a unique row. Additionally, we get a ton of<a id="_idIndexMarker381"/> data about each book, including the title and author, the average rating of the book, your rating of the book, the number of pages, and even if you have read the book, are planning to read the book, or are in the middle of reading the book. The data looks mostly clean but with some weirdness; for instance, the data having both a publication year and an original publication year, and the fact that the ISBN (International Standard Book Number) comes in the format of <em class="italic">="1400067820"</em>, which is just odd. Now that we know more about the data at hand, we can switch over to try to build some interesting graphs for users. </p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor110"/>Making an MVP</h1>
			<p>Looking at our data, we <a id="_idIndexMarker382"/>can start by asking a basic question: what are the most interesting questions I can answer with this data? After looking at the data and thinking about what information I would want from my Goodreads reading history, here are a few questions that I have thought of:</p>
			<ul>
				<li>How many books do I read each year?</li>
				<li>How long does it take for me to finish a book that I have started?</li>
				<li>How long are the books that I have read?</li>
				<li>How old are the books that I have read? </li>
				<li>How do I rate books compared to other Goodreads users?</li>
			</ul>
			<p>We can take these questions, figure out how to modify our data to visualize them well, and then make the first go at our product by printing out all of the graphs. </p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>How many books do I read each year?</h2>
			<p>For the first <a id="_idIndexMarker383"/>question about books read per year, we have the <strong class="source-inline">Date Read</strong> column with the data presented in the format of <em class="italic">yyyy/mm/dd</em>. The following code block will do the following:</p>
			<ul>
				<li>Convert our column into datetime format.</li>
				<li>Extract the year from the <strong class="source-inline">Date Read</strong> column.</li>
				<li>Group the books by this column and make a count for books per year.</li>
				<li>Graph this using Plotly.</li>
			</ul>
			<p>The following code block does this, starting with the datetime conversion. It is important to note here that as with all things, I didn't get this right on the very first try. In fact, it took me some time to figure out exactly how I needed to manage and convert this data. When you are creating projects of your own, do not feel bad if you find that data cleaning and converting are taking a long time! Very often, it is the hardest step:</p>
			<p class="source-code">     goodreads_file = st.file_uploader('Please Import Your Goodreads Data')</p>
			<p class="source-code">if goodreads_file is None:</p>
			<p class="source-code">     books_df = pd.read_csv('goodreads_history.csv')</p>
			<p class="source-code">     st.write("Analyzing Tyler's Goodreads history")</p>
			<p class="source-code">else:</p>
			<p class="source-code">     books_df = pd.read_csv(goodreads_file)</p>
			<p class="source-code">     st.write('Analyzing your Goodreads history')</p>
			<p class="source-code">books_df['Year Finished'] = pd.to_datetime(books_df['Date Read']).dt.year </p>
			<p class="source-code">books_per_year = books_df.groupby('Year Finished')['Book Id'].count().reset_index()</p>
			<p class="source-code">books_per_year.columns = ['Year Finished', 'Count']</p>
			<p class="source-code">fig_year_finished = px.bar(books_per_year, x='Year Finished', y='Count', title='Books Finished per Year')</p>
			<p class="source-code">st.plotly_chart(fig_year_finished)</p>
			<p>The preceding code block will create the following graph:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B16864_10_3.jpg" alt="Figure 10.3 – Year Finished bar plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Year Finished bar plot</p>
			<p>We actually made an assumption here, that is, we assumed the year in the <strong class="source-inline">Date Read</strong> column represents when we read the book. But what if we start a book in the middle of December and finish it on January 2? Or, what if we start a book in 2019 but only get a few pages into it, and then pick it back up during 2021? We know this will not be a perfect approximation of the number of books read per year, but it will be better to express this as the number of books finished per year. </p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>How long does it take for me to finish a book that I have started?</h2>
			<p>Our next question <a id="_idIndexMarker384"/>is about the time it takes for us to finish a book once we have started it. To answer this, we need to find the difference between two columns: the <strong class="source-inline">Date Read</strong> column and the <strong class="source-inline">Date Added</strong> column. Again, this is going to be an approximation, as we do not have the date of when the user started reading the book but only when they added the book to Goodreads. Given this, our next steps include the following:</p>
			<ul>
				<li>Convert the two columns into datetime format.</li>
				<li>Find the difference between the two columns in days.</li>
				<li>Plot this difference in a histogram.</li>
			</ul>
			<p>The following code block starts with the conversion, as we have done previously, and then moves through our list of tasks:</p>
			<p class="source-code">books_df['days_to_finish'] = (pd.to_datetime(</p>
			<p class="source-code">            books_df['Date Read']) - pd.to_datetime(books_df['Date Added'])).dt.days</p>
			<p class="source-code">fig_days_finished = px.histogram(books_df, x='days_to_finish')</p>
			<p class="source-code">st.plotly_chart(fig_days_finished)</p>
			<p>The previous code block can be added to the bottom of your current Streamlit app, which, when run, should show a new graph: </p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B16864_10_4.jpg" alt="Figure 10.4 – The days to finish graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – The days to finish graph</p>
			<p>This is not the<a id="_idIndexMarker385"/> most helpful graph for my data. It looks as though, at some point, I added books that I had read in the past to Goodreads, which show up in this chart. We also have a set of books that have not been finished yet or are on the to-read bookshelf, which exist as null values in this dataset. We can do a few things here, such as filtering the dataset to just include books where the number of days is positive and filtering the data to only finished books, which the following code block does:</p>
			<p class="source-code">books_df['days_to_finish'] = (pd.to_datetime(</p>
			<p class="source-code">            books_df['Date Read']) - pd.to_datetime(books_df['Date Added'])).dt.days</p>
			<p class="source-code">books_finished_filtered = books_df[(books_df['Exclusive Shelf'] == 'read') &amp; (books_df['days_to_finish'] &gt;= 0)]</p>
			<p class="source-code">fig_days_finished = px.histogram(books_finished_filtered, </p>
			<p class="source-code"> x='days_to_finish', title='Time Between Date Added And Date Finished',</p>
			<p class="source-code">     labels={'days_to_finish':'days'})</p>
			<p class="source-code">st.plotly_chart(fig_days_finished)</p>
			<p>This change in our code makes the graph significantly better. It makes some assumptions, but it also provides a more accurate analysis. The finished graph can be viewed in the following screenshot: </p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B16864_10_5.jpg" alt="Figure 10.5 – The improved days to finish graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – The improved days to finish graph</p>
			<p>This looks much better! Now, let's move on to the next question. </p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor113"/>How long are the books that I have read?</h2>
			<p>The data for this <a id="_idIndexMarker386"/>question is already in a fairly good state. We have a single column called <strong class="source-inline">Number of Pages</strong>, which, you guessed it, has the number of pages in each book. We just need to pass that column to another histogram, and we will be good to go:</p>
			<p class="source-code">fig_num_pages = px.histogram(books_df, x='Number of Pages', title='Book Length Histogram')</p>
			<p class="source-code">st.plotly_chart(fig_num_pages)</p>
			<p>This code will produce something similar to the following screenshot, showing a histogram of book length as measured in pages:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B16864_10_6.jpg" alt="Figure 10.6 – The Number of Pages histogram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.6 – The Number of Pages histogram</p>
			<p>This makes sense to me; a ton of books are in the 300–400 page range, with a few giant books that have 1,000+ pages. Now, let's move on to the age of these books! </p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor114"/>How old are the books that I have read? </h2>
			<p>Our next graph<a id="_idIndexMarker387"/> should be straightforward. How do we figure out how old the books that we read are? Are our tendencies to go for the newest set of books that are published or to shoot toward reading classics? There are two columns that we can get this information from, the publication year and the original publication year. There is very little documentation on this dataset, but I think we can safely assume that the original publication year is what we are looking for, and the publication year exists for when a publisher republishes a book. The following code block checks this assumption by printing out all the books where the original publication year is later than the publication year:</p>
			<p class="source-code">st.write('Assumption check')</p>
			<p class="source-code">st.write(len(books_df[books_df['Original Publication Year'] &gt; books_df['Year Published']]))</p>
			<p>When we run this, the app should return zero books with the original publication year as greater than the year published. Now that we have checked this assumption, we can do the following:</p>
			<ol>
				<li>Group the books by the original publication year.</li>
				<li>Plot this on a bar chart.</li>
			</ol>
			<p>The following code block takes two steps:</p>
			<p class="source-code">books_publication_year = books_df.groupby('Original Publication Year')['Book Id'].count().reset_index()</p>
			<p class="source-code">books_publication_year.columns = ['Year Published', 'Count']</p>
			<p class="source-code">fig_year_published = px.bar(books_publication_year, x='Year Published', y='Count', title='Book Age Plot')</p>
			<p class="source-code">st.plotly_chart(fig_year_published)</p>
			<p>When we run this app, we should get the following graph:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B16864_10_7.jpg" alt="Figure 10.7 – Book Age Plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.7 – Book Age Plot</p>
			<p>At first glance, this graph does not appear to be incredibly useful, as there are quite a few books written so far back in history (for example, Plato's writings in -375 BCE) that the entire graph is hard to read. However, Plotly is interactive by default, and it allows us to zoom into sections of history that we care about more than others. For example, the following screenshot shows us what happens when we zoom into the period of 1850 to the present, where most of the books that I've read happen to be in:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B16864_10_8.jpg" alt="Figure 10.8 – Zooming in on Year Published&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8 – Zooming in on Year Published</p>
			<p>This is a much <a id="_idIndexMarker388"/>better graph! There are a couple of options going forward. We can start with the graph that is not as useful and tell users to zoom in, we can filter our dataset for only younger books (which would defeat the main purpose of the graph), or we can set a default zoom state for the graph and also alert users at the bottom that they can zoom in as they'd like. I think the third option is the best one. The following code implements this option:</p>
			<p class="source-code">Books_publication_year = books_df.groupby('Original Publication Year')['Book Id'].count().reset_index()</p>
			<p class="source-code">books_publication_year.columns = ['Year Published', 'Count']</p>
			<p class="source-code">st.write(books_df.sort_values(by='Original Publication Year').head())</p>
			<p class="source-code">fig_year_published = px.bar(books_publication_year, x='Year Published', y='Count', title='Book Age Plot')</p>
			<p class="source-code">fig_year_published.update_xaxes(range=[1850, 2021])</p>
			<p class="source-code">st.plotly_chart(fig_year_published)</p>
			<p class="source-code">st.write('This chart is zoomed into the period of 1850-2021, but is interactive so try zooming in/out on interesting periods!')</p>
			<p>When we run this code, we should get our final plot:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B16864_10_9.jpg" alt="Figure 10.9 – A default zoom with helpful text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.9 – A default zoom with helpful text</p>
			<p>Four questions down, we have one to go!</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor115"/>How do I rate books compared to other Goodreads users?</h2>
			<p>For this final question, we really need two separate graphs. First, we need to plot how we have rated the books. Then, second, we need to plot how other users have rated the books that we also rated. This isn't a perfect analysis, because Goodreads just shows us the average rating of the books – we have not read the distribution. For example, if we had read <em class="italic">The Snowball</em>, a biography of Warren Buffett, and rated it 3 stars, and half of Goodreads' readers rated it a 1 star while the other half rated it 5 stars, we would have rated it exactly the same as the average rating, but we would not have rated it the same as any individual rater! However, we do what we can with the data we have. So, we can do the following:</p>
			<ul>
				<li>Filter the books according to the ones we have rated (and, therefore, read).</li>
				<li>Create a histogram of the average rating per book for our first graph.</li>
				<li>Create another histogram for your own ratings.</li>
			</ul>
			<p>This next <a id="_idIndexMarker389"/>code block does exactly that:</p>
			<p class="source-code">books_rated = books_df[books_df['My Rating'] != 0]</p>
			<p class="source-code">fig_my_rating = px.histogram(books_rated, x='My Rating', title='User Rating')</p>
			<p class="source-code">st.plotly_chart(fig_my_rating)</p>
			<p class="source-code">fig_avg_rating = px.histogram(books_rated, x='Average Rating', title='Average Goodreads Rating')</p>
			<p class="source-code">st.plotly_chart(fig_avg_rating)</p>
			<p>As you can see in the following screenshot, the first graph with the user rating distribution looks great. It looks as though I mainly rate books either 4 or 5 stars, which are, overall, pretty lenient ratings:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B16864_10_10.jpg" alt="Figure 10.10 – The User Rating distribution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.10 – The User Rating distribution</p>
			<p>When we<a id="_idIndexMarker390"/> also look at the second graph, we see a fairly clean distribution. However, we run into the problem that we have addressed before – all the rating averages are more tightly bundled than the user ratings:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B16864_10_11.jpg" alt="Figure 10.11 – Average Goodreads Ratings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.11 – Average Goodreads Ratings</p>
			<p>We can always set the <em class="italic">x</em>-axis range to 1–5 for both graphs, but this will not help our actual problem. Instead, we can leave both of the graphs but also calculate whether, on average, we rate books higher or lower than the Goodreads average. The following code block will calculate this and add it underneath the average Goodreads rating graph:</p>
			<p class="source-code">Fig_avg_rating = px.histogram(books_rated, x='Average Rating', title='Average Goodreads Rating')</p>
			<p class="source-code">st.plotly_chart(fig_avg_rating)</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">avg_difference = np.round(np.mean(books_rated['My Rating'] – books_rated['Average Rating']), 2)</p>
			<p class="source-code">if avg_difference &gt;= 0:</p>
			<p class="source-code">     sign = 'higher'</p>
			<p class="source-code">else:</p>
			<p class="source-code">     sign = 'lower'</p>
			<p class="source-code">st.write(f"You rate books {sign} than the average Goodreads user by {abs(avg_difference)}!")</p>
			<p>This code<a id="_idIndexMarker391"/> block makes our average and creates a dynamic string that will either say that the Goodreads user rates books higher or lower than the average Goodreads user. The result for my data is as follows:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B16864_10_12.jpg" alt="Figure 10.12 – Adding an average difference&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12 – Adding an average difference</p>
			<p>This is <a id="_idIndexMarker392"/>better and completes our MVP. Our app is in a decent state, and the difficult manipulation and visualization steps are pretty much complete. However, our app certainly doesn't look great and is just a bunch of graphs that appear in a row. This might be good for an MVP, but we need to add some styling to really improve our state. That leads us to our next section: iterating on this idea to make it even better. </p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor116"/>Iterative improvement</h1>
			<p>So far, we have been almost<a id="_idIndexMarker393"/> purely in production mode with this app. Iterative improvement is all about editing the work we have already done and organizing it in a way that makes the app more usable and, frankly, nicer to look at. There are a few improvements that we can shoot for here:</p>
			<ul>
				<li>Beautification via animation</li>
				<li>Organization using columns and width</li>
				<li>Narrative building through text and additional statistics</li>
			</ul>
			<p>Let's start by using animations to make our apps a bit prettier!</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor117"/>Beautification via animation</h2>
			<p>In <a href="B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074"><em class="italic">Chapter 7</em></a>, <em class="italic">Exploring </em><em class="italic">Streamlit Components</em>, we explored the use of various Streamlit components: one of these was a component called <strong class="source-inline">streamlit-lottie</strong>, which gives us the ability to <a id="_idIndexMarker394"/>add animation to our Streamlit applications. We can improve our current app by adding an animation to the top of our current Streamlit app using the following code. If you want to learn more about Streamlit components, please head back over to <a href="B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074"><em class="italic">Chapter 7</em></a><em class="italic">, Exploring Streamlit Components</em>:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import plotly.express as px</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">from streamlit_lottie import st_lottie</p>
			<p class="source-code">import requests</p>
			<p class="source-code">def load_lottieurl(url: str):</p>
			<p class="source-code">    r = requests.get(url)</p>
			<p class="source-code">    if r.status_code != 200:</p>
			<p class="source-code">        return None</p>
			<p class="source-code">    return r.json()</p>
			<p class="source-code">file_url = 'https://assets4.lottiefiles.com/temp/lf20_aKAfIn.json'</p>
			<p class="source-code">lottie_book = load_lottieurl(file_url)</p>
			<p class="source-code">st_lottie(lottie_book, speed=1, height=200, key="initial")</p>
			<p>This Lottie file is an animation of a book flipping its pages, as shown in the following screenshot. These animations are always a nice touch for longer Streamlit apps:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B16864_10_13.jpg" alt="Figure 12.13 – Goodreads animation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13 – Goodreads animation</p>
			<p>Now that we <a id="_idIndexMarker395"/>have added our animation, we can move on to how to organize our app a bit better.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor118"/>Organization using columns and width</h2>
			<p>As we <a id="_idIndexMarker396"/>discussed earlier, our app<a id="_idIndexMarker397"/> does not look very good with each graph appearing one after the other. Another improvement we can make is to allow our app to be in wide, rather than narrow, format, and then put our apps side by side in each column. </p>
			<p>To begin, at the top of our app, we need the first Streamlit call to be the one that sets the configuration of our Streamlit app to wide rather than narrow, as shown in the following code block:</p>
			<p class="source-code">import requests</p>
			<p class="source-code">st.set_page_config(layout="wide")</p>
			<p class="source-code">def load_lottieurl(url: str):</p>
			<p class="source-code">    r = requests.get(url)</p>
			<p class="source-code">    if r.status_code != 200:</p>
			<p class="source-code">        return None</p>
			<p class="source-code">    return r.json()</p>
			<p>This will set our Streamlit to our wide format. So far, in our app, we have called each graph a unique name (such as <strong class="source-inline">fig_year_finished</strong>) to make this next step easier. We can now <a id="_idIndexMarker398"/>remove all of our <strong class="source-inline">st.plotly_chart()</strong> calls, and <a id="_idIndexMarker399"/>create a set of two columns and three rows where we can place our six graphs. The following code creates each of these. We name each space first, and then fill them with one of our graphs:</p>
			<p class="source-code">row1_col1, row1_col2 = st.beta_columns(2)</p>
			<p class="source-code">row2_col1, row2_col2 = st.beta_columns(2)</p>
			<p class="source-code">row3_col1, row3_col2 = st.beta_columns(2)</p>
			<p class="source-code">with row1_col1:</p>
			<p class="source-code">     st.plotly_chart(fig_year_finished)</p>
			<p class="source-code">with row1_col2:</p>
			<p class="source-code">     st.plotly_chart(fig_days_finished)</p>
			<p class="source-code">with row2_col1:</p>
			<p class="source-code">     st.plotly_chart(fig_num_pages)</p>
			<p class="source-code">with row2_col2:</p>
			<p class="source-code">     st.plotly_chart(fig_year_published)</p>
			<p class="source-code">     st.write('This chart is zoomed into the period of 1850-2021, but is interactive so try zooming in/out on interesting periods!')</p>
			<p class="source-code">with row3_col1:</p>
			<p class="source-code">     st.plotly_chart(fig_my_rating)</p>
			<p class="source-code">with row3_col2:</p>
			<p class="source-code">     st.plotly_chart(fig_avg_rating)</p>
			<p class="source-code">     st.write(f"You rate books {sign} than the average Goodreads user by {abs(avg_difference)}!")</p>
			<p>This code will create<a id="_idIndexMarker400"/> the app that appears in the<a id="_idIndexMarker401"/> following screenshot, which has been cropped to the top two graphs for brevity:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B16864_10_14.jpg" alt="Figure 12.14 – The wide format example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14 – The wide format example</p>
			<p>This makes our graphs much easier to read and easily allows us to compare them. We have intentionally paired our two graphs according to ratings, and the rest also appear to fit quite well next to each other. Our final step is to add a bit more text to make the entire app easier to read. </p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor119"/>Narrative building through text and additional statistics</h2>
			<p>These graphs are <a id="_idIndexMarker402"/>already quite helpful for understanding how the user reads, but we can bolster the readability of this app by adding some useful statistics and text underneath each graph and at the beginning of the app. </p>
			<p>Right above where we start to define our columns, we can add an initial section that shows the unique number of books that we have read, the unique authors, and our favorite author, all in one. We can use these basic statistics to kick off the app and tell the user that each graph is also interactive:</p>
			<p class="source-code">if goodreads_file is None:</p>
			<p class="source-code">     st.subheader("Tyler's Analysis Results:")</p>
			<p class="source-code">else:</p>
			<p class="source-code">     st.subheader('Your Analysis Results:')</p>
			<p class="source-code">books_finished = books_df[books_df['Exclusive Shelf'] == 'read']</p>
			<p class="source-code">u_books = len(books_finished['Book Id'].unique())</p>
			<p class="source-code">u_authors = len(books_finished['Author'].unique())</p>
			<p class="source-code">mode_author = books_finished['Author'].mode()[0] </p>
			<p class="source-code">st.write(f'It looks like you have finished {u_books} books with a total of {u_authors} unique authors. Your most read author is {mode_author}!')</p>
			<p class="source-code">st.write(f'Your app results can be found below, we have analyzed everything from your book length distribution to how you rate books. Take a look around, all the graphs are interactive!')</p>
			<p class="source-code">row1_col1, row1_col2 = st.beta_columns(2)</p>
			<p>Now we need to add four new text sections below the four graphs that do not have any annotated text as of <a id="_idIndexMarker403"/>yet. For the first three graphs, the following code will add some statistics and text to each:</p>
			<p class="source-code">row1_col1, row1_col2 = st.beta_columns(2)</p>
			<p class="source-code">row2_col1, row2_col2 = st.beta_columns(2)</p>
			<p class="source-code">row3_col1, row3_col2 = st.beta_columns(2)</p>
			<p class="source-code">with row1_col1:</p>
			<p class="source-code">     mode_year_finished = int(books_df['Year Finished'].mode()[0])</p>
			<p class="source-code">     st.plotly_chart(fig_year_finished)</p>
			<p class="source-code">     st.write(f'You finished the most books in {mode_year_finished}. Awesome job!')</p>
			<p class="source-code">with row1_col2:</p>
			<p class="source-code">     st.plotly_chart(fig_days_finished)</p>
			<p class="source-code">     mean_days_to_finish = int(books_finished_filtered['days_to_finish'].mean())</p>
			<p class="source-code">     st.write(f'It took you an average of {mean_days_to_finish} days between when the book was added to Goodreads and when you finished the book. This is not a perfect metric, as you may have added this book to a to-read list!')</p>
			<p class="source-code">with row2_col1:</p>
			<p class="source-code">     st.plotly_chart(fig_num_pages)</p>
			<p class="source-code">     avg_pages = int(books_df['Number of Pages'].mean())</p>
			<p class="source-code">     st.write(f'Your books are an average of {avg_pages} pages long, check out the distribution above!')</p>
			<p>One example graph here is the histogram on book length. The preceding code adds an average length and some text below the graph, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B16864_10_15.jpg" alt="Figure 10.15 – The average number of pages text&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.15 – The average number of pages text</p>
			<p>For the final set<a id="_idIndexMarker404"/> of graphs, we can add text to the ones without context:</p>
			<p class="source-code">with row2_col2:</p>
			<p class="source-code">     st.plotly_chart(fig_year_published)</p>
			<p class="source-code">     st.write('This chart is zoomed into the period of 1850-2021, but is interactive so try zooming in/out on interesting periods!')</p>
			<p class="source-code">with row3_col1:</p>
			<p class="source-code">     st.plotly_chart(fig_my_rating)</p>
			<p class="source-code">     avg_my_rating = round(books_rated['My Rating'].mean(), 2)</p>
			<p class="source-code">     st.write(f'You rate books an average of {avg_my_rating} stars on Goodreads.')</p>
			<p class="source-code">with row3_col2:</p>
			<p class="source-code">     st.plotly_chart(fig_avg_rating)</p>
			<p class="source-code">     st.write(f"You rate books {sign} than the average Goodreads user by {abs(avg_difference)}!")</p>
			<p>This completes <a id="_idIndexMarker405"/>our section on adding text and additional statistics! Now, our final step is to deploy this on Streamlit Sharing. </p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor120"/>Hosting and promotion</h1>
			<p>Our final step is to host this <a id="_idIndexMarker406"/>app on Streamlit Sharing. To do this, we need to perform the following steps:</p>
			<ol>
				<li value="1">Create a GitHub repository for this work.</li>
				<li>Add a <strong class="source-inline">requirements.txt</strong> file.</li>
				<li>Use 1-click<a id="_idIndexMarker407"/> deployment on Streamlit Sharing to deploy.</li>
			</ol>
			<p>We already covered this extensively in <a href="B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying Streamlit with Streamlit Sharing</em>, so give it a shot now without instruction. If you get stuck, head over to <a href="B16864_05_Final_VK_ePub.xhtml#_idTextAnchor056"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying Streamlit with Streamlit Sharing</em>, to find the exact instructions.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor121"/>Summary</h1>
			<p>What a fun chapter! We have learned so much here – from how to come up with data science projects of our own to how to create initial MVPs, to the iterative improvement of our apps. We have done this all through the lens of our Goodreads dataset, and we have taken this app from just an idea to a fully functioning app hosted on Streamlit Sharing. I look forward to seeing all the different types of Streamlit apps that you create. Please create something fun and send it to me on Twitter at <em class="italic">@tylerjrichards</em>. In the next chapter, we will focus on learning how to use Streamlit at work with the new Streamlit product, <em class="italic">Streamlit for Teams</em>. See you there!</p>
		</div>
	</body></html>