- en: '*Chapter 3*: Working with Plotly''s Figure Objects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you have published an article that contains a chart. Assume that
    your readers will, on average, spend 1 minute looking at the chart. If your chart
    is easy to understand, then they will probably spend 10 seconds understanding
    it and 50 seconds thinking, analyzing, and pondering its implications. On the
    other hand, if the chart is difficult to understand, they will spend 50 seconds
    "reading" it, and very little time thinking about its implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter aims to equip you with tools that will help you to minimize the
    time an audience spends understanding your charts, and to maximize their analysis
    and thinking time. The two previous chapters were about structuring apps and making
    them interactive. In this chapter, we will discuss how to create and control the
    very charts around which your apps are built. Plotly''s **Figure** object is what
    we will primarily explore. In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Figure object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the data attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the layout attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about figure traces and how to add them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the different ways of converting figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will focus on using the `Figure` object from the `graph_objects` module of
    the `plotly` package. Later in the chapter, we will utilize the other packages
    that we have been using to improve our app and add an interactive chart to it.
    As a reminder, the packages that we will use are Dash, Dash HTML Components, Dash
    Core Components, Dash Bootstrap Components, JupyterLab, Jupyter Dash, and pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The packages can be individually installed by running `pip install <package-name>`,
    but it would be better to install the exact same versions that we use here, to
    reproduce the same results. You can install them all by running one command, `pip
    install –r requirements.txt`, from the root folder of the repository. The latest
    version of the poverty dataset can be downloaded from this link: [https://datacatalog.worldbank.org/dataset/poverty-and-equity-database](https://datacatalog.worldbank.org/dataset/poverty-and-equity-database).
    However, as with the packages, if you want to reproduce the same results, you
    can access the dataset from the `data` folder in the root of the Git repository,
    along with the rest of the code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_03).'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3x9VhAA](https://bit.ly/3x9VhAA).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Figure object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plotly is a fully fledged data visualization system, which ships with more than
    50 types of charts out of the box (for example, bar charts, scatter plots, and
    histograms). It supports 2D and 3D visualizations, ternary plots, maps, and more.
    The available options for customizing almost any aspect of your charts are very
    detailed and can be overwhelming. This, as they say, is a good problem to have!
  prefs: []
  type: TYPE_NORMAL
- en: We use charts to uncover certain characteristics of our data or the relationships
    between different datasets. However, pure data visualization would be meaningless
    if we didn't know what is being visualized. Imagine a rectangle that has a bunch
    of dots on it with clear patterns. It would still be meaningless if you didn't
    know what the *x* axis represented, for example. If you have different shapes
    and colors in a plot, then they would mean nothing without a legend. Usually,
    titles and annotations are also needed to give us context around the data we are
    trying to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Those two groups, `data` and other supporting elements, which are collectively
    called `layout`, are two top-level attributes of Plotly's `Figure` object. Each
    attribute has several subattributes, at multiple levels, forming a tree-like structure.
    There is also the `frames` attribute, which is mainly used with animations, and
    it is not as common as the other two that are always present in every chart. We
    will not cover it in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explore these attributes and start plotting to get a better understanding
    of how they fit together within the `Figure` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`: The different attributes of data, and the relationships between them,
    are expressed using graphical/geometrical shapes, for example, circles, rectangles,
    lines, and more. The graphical attributes of those shapes are used to express
    various attributes of the data. The relative size, length, and distance between
    those shapes are how we understand this. Due to their visual and, therefore, intuitive
    nature, those attributes are easy to understand and don''t require much explanation.
    The `data` attribute corresponds to the essence of what we are trying to understand.
    The values you need to provide for the `data` attribute depend on the chart type.
    For a scatter plot, for example, you need to provide `x` and `y` values. For maps,
    you need to have `lat` and `lon`. You can overlay several sets of data on top
    of each other on the same chart; each one is referred to as a **trace**. Each
    chart type can take many other optional values, and many of them will be covered
    in more detail later on in the book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout`: Everything else around the data belongs to this attribute. Elements
    of the `layout` attribute are more abstract in nature. They typically use text
    to inform the user what they are looking at. Many of them are also styling elements,
    which might not add as much information, but they make the charts easier to understand
    or conform to certain branding guidelines. There are many attributes that we will
    explore, but the most prominent ones are the title, axis titles, ticks, and legend.
    These, in turn, have subattributes, such as the font size, location, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s much easier to learn by doing, and we can now start by creating our first
    figure. The `graph_objects` module is usually imported as `go`, and we instantiate
    a figure by calling `go.Figure`! *Figure 3.1* shows an empty `Figure` object and
    how it is created and displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The default empty Figure object displayed in JupyterLab](img/B16780_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The default empty Figure object displayed in JupyterLab
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we don't get anything from this empty figure, but it is the first
    step before adding the elements we want to it. Although we can create and display
    `Figure` objects by defining everything in the `go.Figure` call, we will use a
    slightly easier and more convenient approach. We will assign the created object
    to a variable, and then iteratively add and/or modify the elements that we want.
    An important benefit of this approach is that we can make changes to our charts
    after creating them.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Once you assign a `Figure` object to a variable, this variable becomes available
    in the global scope. Since it is mutable, you can make changes to it in other
    places in your code. Displaying the figure after making such changes will show
    it with the changes you have made. We will be utilizing this important feature
    in order to manage our charts.
  prefs: []
  type: TYPE_NORMAL
- en: Having created the basic object, we are now ready to start adding our first
    data traces to our first chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the data attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we start by adding a scatter plot using a very small and simple dataset.
    Later in the chapter, we will use our poverty dataset to create other plots. Once
    you have created your `Figure` object and assigned it to a variable, you have
    access to a large number of convenient methods for manipulating that object. The
    methods related to adding data traces all start with `add_`, followed by the type
    of chart we are adding, for example, `add_scatter` or `add_bar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the full process of creating a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `graph_objects` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an instance of a `Figure` object and assign it to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a scatter trace. The minimum parameters required for this type of chart
    are two arrays for the `x` and `y` values. These can be provided as lists, tuples,
    NumPy arrays, or pandas `Series`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the resulting figure. You can simply have the variable on the last
    line in your code cell, and it will also be displayed in JupyterLab once you run
    it. You can also explicitly call the `show` method, which gives you a few more
    options to customize the display of the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see the full code, as well as the final output, in *Figure 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A scatter plot displayed in JupyterLab](img/B16780_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A scatter plot displayed in JupyterLab
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add another similar scatter plot, overlaid on top of this one.
    We simply repeat *step 3*, but with different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will add the new scatter plot to the same figure. If we call `fig.show()`
    after running this code, we will be able to see the updated figure. Note that
    this trace has four data points, whereas the previous trace had three. We don't
    need to worry about this, as this is handled for us using certain default values.
    We also have the option to modify those default values if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to modify any aspect of our `data` trace, we can do it through the
    `add_<chart_type>` method. The call to those methods provides a lot of options
    through many parameters, and they are specific to the type of chart you are producing.
    Part 2 of this book will go deeper into several chart types and the different
    options that they provide. On the other hand, if we want to modify anything related
    to the `layout` attribute, we can do so by accessing and then assigning the attributes
    and/or subattributes that we want in a simple, declarative way. This is generally
    done using Python's dot notation, for example, `figure.attribute.sub_attribute
    = value`. This guideline is not entirely correct, as there are a few exceptions,
    and in some cases, there is an overlap where an attribute belongs to the `data`
    attribute but is managed by the `layout` attribute, for example. In most cases,
    this is a helpful distinction to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at some of the things that we can change in our figure's
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the layout attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the current figure that we are working on, let''s add a title (for the
    whole figure), along with axis titles, to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are exploring the tree-like structure of our figure. There
    is a `title` attribute that falls directly under `fig.layout`, and there are also
    titles for `fig.layout.xaxis` and `fig.layout.yaxis`. To give you a sense of how
    detailed the available options are, *Figure 3.3* shows some of the `xaxis` attributes
    that start with `tick` only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Some of the Figure object''s layout.xaxis options](img/B16780_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Some of the Figure object's layout.xaxis options
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the effect of the four lines of code we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The updated figure containing two traces, a legend, and titles](img/B16780_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The updated figure containing two traces, a legend, and titles
  prefs: []
  type: TYPE_NORMAL
- en: The three titles we have added are self-explanatory. New traces take on new
    default colors to differentiate them. Another interesting thing is the legend,
    which was added automatically. When you just have one trace, there is usually
    no need for a legend, but it becomes important when you have more than one. Descriptive
    names are crucial, of course, and **trace 0** doesn't mean much, but I'm keeping
    it as a memory aid to remember the names of the figure elements.
  prefs: []
  type: TYPE_NORMAL
- en: The figure we just created and displayed is what your users will see. Let's
    now take an interactive peek at the components of this figure.
  prefs: []
  type: TYPE_NORMAL
- en: Interactively exploring the Figure object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, the `show` method provides a few handy options for
    customizing what and how your figures are displayed. A particularly helpful one
    is setting the `renderer` parameter to JSON. *Figure 3.5* shows how this can be
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Interactively exploring the Figure object in JupyterLab](img/B16780_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Interactively exploring the Figure object in JupyterLab
  prefs: []
  type: TYPE_NORMAL
- en: In the top-left corner, you can see the default view. The `Figure` object, and
    the two top-level attributes can be seen right under it. We also get a hint that
    our **data** attribute contains two items (these are the two traces we added).
    The triangles and their directions indicate whether the respective attribute has
    been expanded or collapsed.
  prefs: []
  type: TYPE_NORMAL
- en: In the bottom-left corner, you can see the search functionality in action. This
    is useful for when you want to access or modify a certain attribute but are not
    entirely sure what its exact name is, or to what attribute it belongs. On the
    right-hand side, I have expanded a few of the items, and you can see that they
    correspond to the figure we created.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, and the whole book really, is about how to create the charts and
    dashboards that you want. It's not about data visualization's best practices or
    statistical inference. In other words, it's about how to create the things you
    *want* to create, and not about what you *should* create. I'll still try to share
    good practices, and hopefully, make reasonable choices for the charts and their
    details, but it's important to keep this distinction in mind.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you have noticed the "mode bar" containing interactive buttons and
    controls in the top-right corner of the figures we created. There are several
    ways to control which buttons to show or hide and a few other options. This is
    available through the `config` parameter of the `show` method.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration options for the Figure object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `config` parameter takes a dictionary and controls several interesting
    options. The keys control which aspect to modify. Additionally, the values can
    be given as strings or lists, depending on which one you are modifying. For example,
    consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some of the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`displayModeBar`: This defaults to `True`. It controls whether or not to display
    the whole mode bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`responsive`: This defaults to `True`. It controls whether or not to change
    the dimensions of the figure based on the browser window''s size. Sometimes, you
    might want to keep the figure dimensions fixed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toImageButtonOptions`: The camera icon in the mode bar allows users to download
    the figure as an image. This option controls the default formats of downloading
    those images. It takes a dictionary in which you can set the default format (that
    is, SVG, PNG, JPG, or WebP). You can also set default values for the height, width,
    filename, and scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modeBarButtonsToRemove`: This is a list of buttons you don''t want in the
    mode bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned how to create, examine, and configure basic charts,
    let's explore what else we can do with them. How can we convert them into other
    formats? And what other formats are available?
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the different ways of converting figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The methods that control converting figures start with either `to_` or `write_`.
    Let's explore some of the most interesting ones.
  prefs: []
  type: TYPE_NORMAL
- en: Converting figures into HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Plotly figures are actually HTML objects, together with the JavaScript that
    makes them interactive. We can easily capture that HTML file if we want to share
    it with others via email, for example. You might consider having this as a feature
    in your dashboards. Your users can create the chart or report they want, convert
    it into HTML, download it, and share it with their colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you have to do is provide a file path of where you want it to be saved.
    The method also takes several optional parameters for further customization. Let''s
    convert our figure into HTML and add a `config` option to make it download the
    figure image in SVG format. The effect of this will be reflected in the HTML file
    when clicking on the camera icon. The code for this is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now open the file in a browser as a separate HTML file, filling the
    whole browser screen, as shown in *Figure 3.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The Figure object is rendered as a separate HTML file in a browser
    window](img/B16780_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The Figure object is rendered as a separate HTML file in a browser
    window
  prefs: []
  type: TYPE_NORMAL
- en: Converting figures into images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have examined the option that allows users to manually download an image
    of the `Figure` object. There is another way of doing so programmatically, which
    can also be interesting. Just like the `write_html` method, we also have a `write_image`
    method. The format of the image can be explicitly provided or inferred from the
    file extension you provide. You can also set the `height` and `width` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might be interesting for mass image creation. For example, you might want
    to create many plots, one for each country, and save each in a file for a separate
    report on each country. It would be very tedious to do this manually. You might
    also include this in one of your callbacks for your users. You could allow your
    users to assemble certain reports, and click on a button that converts them into
    images and then downloads them, for example. This can be run just like the HTML
    converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this information, we can now get practical and find out more about our
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting using a real dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031), *Exploring
    the Structure of a Dash App*, we created a simple report that showed the user
    the population of the selected country in the year 2010\. This type of report
    is used when the user knows what they want. That is, they have a specific question
    about a specific country, metric, and period of time in mind, and our functionality
    provides an answer to their question.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of dashboard functionality falling under two broad categories.
    The first, as we have done already, are visualizations or reports that answer
    a specific question. The second, which we will do now, guide the user in a more
    exploratory approach. In this case, users don't know much about a certain topic
    and they are looking for an overview.
  prefs: []
  type: TYPE_NORMAL
- en: Your users can go back and forth between those types of charts. For example,
    first, they explore poverty in the last decade. A certain region stands out. They
    then ask a specific question about that region. When they realize that that region
    had an unusually high rate of another metric, they can go on to another exploratory
    chart in that metric to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will let the user select a year, and the app will display the top 20
    countries by population for the selected year.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick reminder, our poverty dataset contains columns for the countries
    and their codes, the indicators and their codes, and a column for each year from
    1974 to 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'As agreed, let''s first do this in an isolated environment in JupyterLab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `pandas`, use it to open the poverty dataset, and assign it to the `poverty_data`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Although the column of interest is called `regions` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `population_df`, the subset DataFrame where the `regions`, and the `isin`
    method for pandas `Series` checks whether values in the `Series` are in a certain
    list, and the `~` (tilde) is the logical negation operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first few rows of the resulting DataFrame can be displayed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It looks similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The first few rows of population_df](img/B16780_03_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.7 – The first few rows of population_df
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a dynamic `year` variable, and create a `year_df` variable containing
    the countries column along with the selected year''s column. Then, sort those
    values in descending order and extract the first 20:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With a `year_df` variable containing two sorted columns, we can very easily
    create a bar chart just as we did with the scatter plots earlier. We can also
    add a dynamic title, containing the year, as a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A bar chart showing the top 20 countries by population in 2010](img/B16780_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – A bar chart showing the top 20 countries by population in 2010
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, once we have a proper subset with the relevant columns sorted,
    we can produce the chart we want with a few lines of code. Additionally, note
    that the numbers on the *y* axis were formatted, by default, as billions (or fractions
    of billions) to make them easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn''t set axis titles. Here, the figure title implicitly tells us about
    both axes: "countries" and "population." With a numeric *y* axis and the country
    names listed on the *x* axis, it should be clear to users.'
  prefs: []
  type: TYPE_NORMAL
- en: 2010 is an arbitrary year, and we actually want users to be able to select the
    year they want from the ones that are available in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that produced the figure only requires a `def` statement and some
    indentation to become a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function produces a similar chart to the one that we just produced, but
    for the given `year` argument. You might think that it's as easy to convert this
    function into a callback function, just by adding a line of code. This is exactly
    what we will be doing, but first, I'd like to highlight an observation about data
    manipulation and preparation, and how it relates to data visualization because
    this example illustrates it very well.
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation as an essential part of the data visualization process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example contains six steps. The first five were for preparing
    the data and getting it in two arrays: one for countries and the other for population
    numbers. The sixth and final step alone was where we produced the chart. There
    was much more code for data preparation than there was for producing the figure.'
  prefs: []
  type: TYPE_NORMAL
- en: If you consider the mental effort and time required to produce the chart (that
    is, the final step only), you can easily see that it is the same as the mental
    effort required to produce the scatter plot that we created at the beginning of
    the chapter, featuring the toy dataset. We simply ran `add_scatter(x=[1, 2, 3],
    y=[4, 2, 3])`, and then we did the same for the bar chart, only with different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you consider the mental effort and time spent on preparing the data
    for the bar chart, you can clearly see that there is a huge difference, compared
    to the data preparation for the scatter plot. We needed to know that the `KeyError`
    after trying to access the data for a certain year. We typically spend more time
    and effort on these things, and once the data is in a suitable format, we can
    easily visualize it.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060), *Data Manipulation
    and Preparation - Paving the Way to Plotly Express*, we will spend more time on
    this topic, and introduce some important techniques that might be useful in a
    variety of situations. However, keep in mind that your skills in manipulating
    data, reshaping it, merging datasets, regular expressions, and all the tedious
    parts of data preparation form a big part of where your contribution lies. It's
    where most opportunities are, and a lot of it is based on your judgment. Domain
    knowledge is also essential; for instance, knowing the difference between regions
    and countries. Once you have data in a certain format, there are numerous advanced
    techniques and algorithms that you can use to visualize, analyze, and run various
    machine learning pipelines that require comparatively little code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use our newly created function and learn how to make it interactive
    with a `Dropdown` component and a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Making the chart interactive with a callback function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will do this as a completely isolated app in JupyterLab, after which
    we will add it to our app. In the isolated environment, our `app.layout` attribute
    will contain two components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dropdown`: This will display all the available years so that the user can
    select the one they want.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Graph`: This is a new component that we haven''t covered yet, and we will
    be working extensively with it. Adding a `Graph` component to the layout displays
    an empty chart. If you remember our discussion about callback functions, when
    modifying a component in a callback function, we need to provide its `component_id`
    and `component_property`. The property that we will be modifying, in this scenario,
    is the `figure` property, and it only belongs to the `Graph` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now familiar with the imports and app instantiation, so I will mainly
    focus on the `app.layout` attribute of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For now, there is nothing special about the `Graph` component. We simply create
    one underneath the `Dropdown` component and give it a descriptive `id` argument.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you have also noticed that this time, we have slightly different values
    for the `label` and `value` keys in the list of `options` in the `Dropdown` component.
    The difference is that the `value` key is set to `str(year)`. Since `options`
    is a list of dictionaries generated by a list comprehension, it will produce a
    list of integers. The selected number will be used to select the column with that
    value. In this dataset, the columns are all strings, so using `population_df[2010]`
    will not work, because there is really no such column (as an integer). The actual
    column name is **2010**, as a string. So, we are specifying the label as an integer,
    but the actual value that will be used by the callback function is the string
    representation of that integer (the year).
  prefs: []
  type: TYPE_NORMAL
- en: We have also added a new parameter that we haven't discussed yet. The `value`
    parameter of the `Dropdown` component serves as a default that will be shown to
    users the first time they see the app. This is better than showing an empty chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you might want to do the opposite of what we did in this example.
    You might want to keep `value` as it is but modify `label` somehow. For example,
    if your data was all in lowercase, you might want to display the options as capitalized.
    In our colors example, in the previous chapter, we could have done something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the callback function''s perspective, the colors are still the same, because
    it mainly deals with the `value` attribute. But for the user, this would display
    the colors as capitalized: "Blue," "Green," and "Yellow."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the app with the two components defined so far produces the app, as
    shown in *Figure 3.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – An app with a Dropdown component showing a default value and
    an empty graph](img/B16780_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – An app with a Dropdown component showing a default value and an
    empty graph
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already created a normal function that takes the data as a year and
    returns a bar chart showing the top 20 countries by population for that year.
    Converting it into a callback function requires one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous function definition, the last line was `fig.show()`, and in
    the callback function, we return the figure instead. The reason is that, in the
    first case, we were running it interactively and there was no app or callback
    context. In this case, we have a component with the `population_chart` ID, and,
    most importantly, we want to change its `figure` property. Returning the figure
    will hand it to the `Graph` component and modify its `figure` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this app will produce dynamic charts based on the user selection, as
    you can see in *Figure 3.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – An app displaying a bar chart based on the selected year](img/B16780_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – An app displaying a bar chart based on the selected year
  prefs: []
  type: TYPE_NORMAL
- en: If you compare this to *Figure 3.8*, you will notice that the country names
    are displayed vertically here, while, previously, they were displayed at a certain
    angle. This is simply because the chart was displayed in a wider browser window.
    This is another convenient default that Plotly handles for us without us having
    to do anything. This means that our figures are responsive, which gives them great
    flexibility. This is the same with the apps and their components that we style
    with Dash Bootstrap Components.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created an isolated app that works independently, let's look
    at how to add this to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new functionality to our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the latest version of the app contains a `Dropdown` component, and
    underneath that, the `Div` for the population report of 2010\. Underneath that,
    we have the `Tabs` component. Let''s now insert the new `Dropdown` and `Graph`
    components right underneath the report area, and above the `Tabs` component. Let''s
    also add the new callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the two new components to where they belong in the `app.layout` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the callback function definition and place it anywhere after the closing
    tag of the top-level `Div` of `app.layout`. You can place it under the previous
    callback function that we created for better organization, but it doesn''t matter
    where you place it in terms of functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the definition of the `regions` list and then `population_df` after the
    definition of `poverty_data`. The order is important because `population_df` depends
    on `regions` to be defined before it, and since it is a subset of `poverty_data`,
    it also needs to be defined after it. This is the order in which these variables
    need to be defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run the app, you can see what it looks like in *Figure 3.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The app with the new components added (Dropdown and Graph).](img/B16780_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The app with the new components added (Dropdown and Graph).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the debugger and click on the **Callbacks** button, you can also
    see an updated view of the available callbacks, along with the names of the components
    that they link to (the component IDs and the component properties). *Figure 3.12*
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – The app callbacks in the visual debugger](img/B16780_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – The app callbacks in the visual debugger
  prefs: []
  type: TYPE_NORMAL
- en: Our app now displays more information. It allows users to get information interactively
    from the dataset. We defined two callback functions and have a layout that contains
    several components of different types. We also have about 90 lines of code in
    total. Simply adding new components by inserting them somewhere works fine until
    you have a large enough number of them in the app. Then, we will need to learn
    how to better organize the code and refactor it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's close this chapter with a fun, easy-to-use aspect of the Plotly `Figure`
    object, which does not require much coding, and then recap the topics covered.
  prefs: []
  type: TYPE_NORMAL
- en: Theming your figures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Theming your figures (as opposed to your apps) can be interesting and saves
    a lot of time if you need to change themes. This can be accessed and modified
    through the `template` attribute under `layout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 3.13* shows four different templates and their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Four different Figure templates](img/B16780_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Four different Figure templates
  prefs: []
  type: TYPE_NORMAL
- en: The full list of templates is available in `plotly.io.templates`.
  prefs: []
  type: TYPE_NORMAL
- en: This is helpful when you want your figures to have a template that is compatible
    with the app's theme. It is also a good starting point to enable you to select
    one of the templates and then modify a few of its elements as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now recap the topics that we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started by introducing the `Figure` object, its components, and subcomponents.
    We looked at how to create figures step by step, and how to modify various aspects
    of them. We also took an extensive look at the two main attributes of figures,
    the `data` and `layout` attributes. A few ways of converting figures were also
    explored, and we then created a chart based on our dataset and incorporated it
    into our app.
  prefs: []
  type: TYPE_NORMAL
- en: With the chapters you have read so far, you now know how to create and structure
    apps, how to make them interactive by creating callbacks that link various page
    components together, and how to build charts that fit into the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to build fully interactive apps, and with the understanding
    developed in this chapter, you also know how to manage the various aspects of
    your figures and make sure that they are easy to read, so your users can spend
    more time on analysis and less time on understanding the charts themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly observed the importance of data preparation and manipulation, and
    we are now ready to take a more extensive look at it. In the next chapter, we
    will introduce **Plotly Express**, a powerful and higher-level interface that
    is used to create charts concisely.
  prefs: []
  type: TYPE_NORMAL
