- en: Chapter 2. Best Practices in Interactive Computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing (or not) between Python 2 and Python 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient interactive computing workflows with IPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of the distributed version control system Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical workflow with Git branching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ten tips for conducting reproducible interactive computing experiments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing high-quality Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests with nose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your code with IPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a special chapter about good practices in interactive computing. If
    the rest of the book is about the content, then this chapter is about the form.
    It describes how to work efficiently and properly with the tools this book is
    about. We will cover the essentials of the version control system Git before tackling
    reproducible computing experiments (notably with the IPython notebook).
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover more general topics in software development, such as code
    quality, debugging, and testing. Attention to these subjects can greatly improve
    the quality of our end products (for example, software, research, and publications).
    We will only scratch the surface here, but you will find many references to learn
    more about these important topics.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing (or not) between Python 2 and Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this first recipe, we will briefly cover a transverse and kind of a prosaic
    subject: Python 2 or Python 3?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python 3** has been available since 2008, but many Python users are still
    stuck with Python 2\. By improving many aspects of Python 2, Python 3 has broken
    compatibility with the previous branch. Migrating to Python 3 may therefore require
    a significant investment.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if there aren't that many compatibility-breaking changes, a program that
    works perfectly fine in Python 2 may not work at all in Python 3\. For example,
    your very first `Hello World` Python 2 program doesn't work anymore in Python
    3; `print "Hello World!"` raises a `SyntaxError` in Python 3\. Indeed, `print`
    is now a function rather than a statement. You should write `print("Hello World!")`,
    which also works fine in Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you start a new project or need to maintain an old Python library, the
    question of choosing between Python 2 and Python 3 arises. Here, we give some
    arguments and pointers that should let you make an informed decision.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we refer to Python 2, we especially mean Python 2.6 or Python 2.7, as these
    last versions of the Python 2.*x* branch are closer to Python 3 than Python 2.5
    and earlier versions. It is more complicated to support Python 2.5+ and Python
    3.*x* at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we refer to Python 3 or Python 3.*x*, we especially mean Python
    3.3 or above.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, what are the differences between Python 2 and Python 3?
  prefs: []
  type: TYPE_NORMAL
- en: Main differences in Python 3 compared to Python 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a partial list of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a statement, `print` is a function (parentheses are compulsory).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Division of integers yields floating-point numbers and not integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several built-in functions return iterators or views instead of lists. For example,
    `range` behaves in Python 3 like `xrange` in Python 2, and the latter no longer
    exists in Python 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries do not have the `iterkeys()`, `iteritems()`, and `itervalues()`
    methods anymore. You should use the `keys()`, `items()`, and `values()` functions
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a quote from the official Python documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"Everything you thought you knew about binary data and Unicode has changed."*'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: String formatting with `%` is deprecated; use `str.format` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of a statement, `exec` is a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3 brings many other improvements and new features regarding syntax and
    standard library content. You will find more details in the references at the
    end of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have basically two options for your project: stick with a single branch
    (Python 2 or Python 3), or maintain compatibility with both branches.'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2 or Python 3?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is natural to have a preference for Python 3; it is the future, whereas
    Python 2 is the past. Why bother supporting a deprecated version of Python? Here
    are a few situations where you might want to keep compatibility with Python 2:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to maintain a large project written in Python 2, and it would be too
    costly to update it to Python 3 (even if semiautomatic updating tools exist).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your project has dependencies that do not work with Python 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Most libraries we will be using in this book support both Python 2 and Python
    3\. This book's code is also compatible with both branches.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your end users work on environments that do not support Python 3 well. For example,
    they may work in a large institution where deploying a new version of Python on
    many servers would be too costly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these situations, you may choose to stick with Python 2, with the risk that
    your code becomes obsolete in the near future. Otherwise, you could pick Python
    3 and its shiny new features, with the risk of leaving behind Python 2 users.
    You could also write your code in Python 2 and make it ready for Python 3\. Thus,
    you can reduce the number of changes that will be required during a subsequent
    port to Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you don't necessarily have to choose between Python 2 and Python
    3\. There are ways to support both versions at the same time. Even if this involves
    slightly more work than just sticking to a single branch, it can be quite interesting
    in certain cases. Note, however, that you may miss many Python 3-only features
    if you go down this road.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting both Python 2 and Python 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are basically two ways to support both branches in your code: use the
    **2to3** tool, or write code that *just works* in both branches.'
  prefs: []
  type: TYPE_NORMAL
- en: Using 2to3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 2to3 is a program in the standard library that automatically converts Python
    2 code to Python 3\. For example, run `2to3 -w example.py` to migrate a single
    Python 2 module to Python 3\. You can find more information on the 2to3 tool at
    [https://docs.python.org/2/library/2to3.html](https://docs.python.org/2/library/2to3.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can configure your installation script so that 2to3 runs automatically when
    users install your package. Python 3 users will get the automatically-converted
    Python 3 version of your package.
  prefs: []
  type: TYPE_NORMAL
- en: This solution requires your program to be well-covered by a solid testing suite
    and a continuous integration system that tests both Python 2 and Python 3 (see
    the recipes about unit testing later in this chapter). This is how you can ensure
    that your code works fine in both versions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code that works in Python 2 and Python 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also write code that works in Python 2 and Python 3\. This solution
    is simpler if you start a new project from scratch. A widely-used method is to
    rely on a lightweight and mature module called **six**, developed by Benjamin
    Petersons. This module is only a single file, so you can easily distribute it
    with your package. Wherever you would use a function or feature that is only supported
    in one Python branch, you need to use a specific function implemented in six.
    This function either wraps or emulates the corresponding functionality, thus it
    can work in both branches. You can find more information on six at [http://pythonhosted.org/six/](http://pythonhosted.org/six/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This method requires you to change some habits. For example, to iterate over
    all items of a dictionary in Python 2, you would write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of the preceding code, you write the following code with six:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `iteritems()` method of dictionaries in Python 2 is replaced by `items()`
    in Python 3\. The six module's `iteritems` function internally calls one method
    or the other, depending on the Python version.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, there are many options you can choose regarding the Python
    2 or Python 3 question. In brief, you should consider the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decide very carefully whether you absolutely need to support Python 2 or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, prepare your code for Python 3 by avoiding Python 2-only syntax or features.
    You can use six, 2to3, or similar tools.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, stick to Python 3.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, make sure your project has a solid testing suite, an excellent
    code coverage (approaching 100 percent), and a continuous integration system that
    tests your code against all versions of Python that you officially support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are several references on the subject:'
  prefs: []
  type: TYPE_NORMAL
- en: An excellent free book about porting code to Python 3, by Lennart Regebro, available
    at [http://python3porting.com/](http://python3porting.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official recommendations on porting code to Python 3, available at [https://docs.python.org/3/howto/pyporting.html](https://docs.python.org/3/howto/pyporting.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official wiki page about the Python 2/Python 3 question, available at [https://wiki.python.org/moin/Python2orPython3](https://wiki.python.org/moin/Python2orPython3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3 questions and answers, by Nick Coghlan, available at [http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html](http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What''s new in Python 3*, available at [https://docs.python.org/3.3/whatsnew/3.0.html](https://docs.python.org/3.3/whatsnew/3.0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ten awesome features of Python that you can''t use because you refuse to upgrade
    to Python 3*, a presentation by Aaron Meurer, available at [http://asmeurer.github.io/python3-presentation/slides.html](http://asmeurer.github.io/python3-presentation/slides.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `__future__` module when writing the compatibility code, available
    at [https://docs.python.org/2/library/__future__.html](https://docs.python.org/2/library/__future__.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key differences between Python 2 and Python 3, available at [https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html](https://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Writing high-quality Python code* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing unit tests with nose* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient interactive computing workflows with IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways of using IPython for interactive computing. Some of
    them are better in terms of flexibility, modularity, reusability, and reproducibility.
    We will review and discuss them in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any interactive computing workflow is based on the following cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: Write some code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpret the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This fundamental loop (also known as **Read-Eval-Print Loop** or **REPL**) is
    particularly useful when doing exploratory research on data or model simulations,
    or when building a complex algorithm step by step. A more classical workflow (the
    edit-compile-run-debug loop) would consist of writing a full-blown program, and
    then performing a complete analysis. This is generally more tedious. It is more
    common to build an algorithmic solution iteratively, by doing small-scale experiments
    and tweaking the parameters, and this is precisely what interactive computing
    is about.
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrated Development Environments** (**IDEs**), providing comprehensive
    facilities for software development (such as a source code editor, compiler, and
    debugger), are widely used for classical workflows. However, when it comes to
    interactive computing, alternatives to IDEs exist. We will review them here.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are a few possible workflows for interactive computing, by increasing order
    of complexity. Of course, IPython is at the core of all of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The IPython terminal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPython is the *de facto* standard for interactive computing in Python. The
    IPython terminal (the `ipython` command) offers a command-line interface specifically
    designed for REPLs. It is a much more powerful tool than the native Python interpreter
    (the `python` command). The IPython terminal is a convenient tool for quick experiments,
    simple shell interactions, and to find help. Forgot the input arguments of NumPy's
    `savetxt` function? Just type in `numpy.savetxt?` in IPython (you will first need
    to use `import numpy`, of course). Some people even use the IPython terminal as
    a (sophisticated) calculator!
  prefs: []
  type: TYPE_NORMAL
- en: Yet, the terminal quickly becomes limited when it is used alone. The main issue
    is that the terminal is not a code editor, and thus entering more than a few lines
    of code can be inconvenient. Fortunately, there are various ways of solving this
    problem, as detailed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: IPython and text editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest solution to the *not-a-text-editor* problem is, perhaps unsurprisingly,
    to use IPython along with a text editor. The `%run` magic command then becomes
    the central tool in this workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Write some code in your favorite text editor and save it in a `myscript.py`
    Python script file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In IPython, assuming you are in the right directory, type in `%run myscript.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script is executed. The standard output is displayed in real time in the
    IPython terminal along with possible errors. Top-level variables defined in the
    script are accessible in the IPython terminal at the end of the script's execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If code changes are required in the script, repeat the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The IPython-text editor workflow can be made yet more efficient with adequate
    keyboard shortcuts. You can, for instance, automate your text editor such that,
    when pressing *F8*, the following command is executed in the running IPython interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is described here (on Windows, with Notepad++ and AutoHotKey):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://cyrille.rossant.net/python-ide-windows/](http://cyrille.rossant.net/python-ide-windows/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a good text editor, this workflow can be quite efficient. As the script
    is reloaded when you execute `%run`, your changes will be taken into account automatically.
    Things become more complicated when your script imports other Python modules that
    you modify, as these won''t be reloaded with `%run`. You can use a deep reload
    to solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Modules imported in `myscript` will then be reloaded. A related IPython magic
    command is `%autoreload` (you first need to execute `%load_ext autoreload`). This
    command tries to automatically reload the modules imported in the interactive
    namespace, but it is not always successful. You may need to reload the changed
    modules explicitly with `reload(module)` (in Python 2) or `imp.reload(module)`
    (Python 3).
  prefs: []
  type: TYPE_NORMAL
- en: The IPython notebook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IPython notebook plays a central role in efficient interactive workflows.
    It is a well-designed mix between a code editor and a terminal, bringing the best
    of both worlds within a unified environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can start writing all your code in your notebook's cells. You write, execute,
    and test your code at the same place, thereby improving your productivity. You
    can put long comments in Markdown cells and structure your notebook with Markdown
    headers.
  prefs: []
  type: TYPE_NORMAL
- en: Once portions of your code become mature enough and do not require further changes,
    you can (and should) refactor them into reusable Python components (functions,
    classes, and modules). This will clean up your notebooks and facilitate future
    reuse of your code. Let's emphasize the fact that it is very important to refactor
    your code constantly into reusable components. IPython notebooks are currently
    not easily reusable by third-party code, and they are not designed for this. Notebooks
    are convenient for preliminary analyses and exploratory research, but they should
    not preclude you from regularly cleaning and refactoring your code into Python
    components.
  prefs: []
  type: TYPE_NORMAL
- en: A major advantage of notebooks is that they give you documents retracing everything
    you did with your code. They are extremely useful for reproducible research. Notebooks
    are saved in human-readable JSON documents, thus they work relatively well with
    version control systems such as Git.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IDEs are particularly well-adapted for classic software development, but they
    can also be used for interactive computing. A good Python IDE combines a powerful
    text editor (for example, one that includes features such as syntax highlighting
    and tab completion), an IPython terminal, and a debugger within a unified environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple commercial and open-source IDEs for most platforms. **Eclipse**/**PyDev**
    is a popular (although slightly heavy) open source cross-platform environment.
    **Spyder** is another open source IDE with good integration of IPython and matplotlib.
    **PyCharm** is one of many commercial environments that support IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's IDE for Windows, Visual Studio, has an open source plugin named
    **Python Tools for Visual Studio** (**PTVS**). This tool brings Python support
    to Visual Studio. PTVS natively supports IPython. You don't necessarily need a
    paid version of Visual Studio; you can download a free package bundling PTVS with
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few links to various IDEs for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pydev.org](http://pydev.org) for PyDev for Eclipse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://code.google.com/p/spyderlib/](http://code.google.com/p/spyderlib/)
    for Spyder, an open source IDE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[www.jetbrains.com/pycharm/](http://www.jetbrains.com/pycharm/) for PyCharm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://pytools.codeplex.com](http://pytools.codeplex.com) for PyTools for
    Microsoft Visual Studio on Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://code.google.com/p/pyscripter/](http://code.google.com/p/pyscripter/)
    for PyScripter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[www.iep-project.org](http://www.iep-project.org) for IEP, the Interactive
    Editor for Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Learning the basics of the distributed version control system Git* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Debugging your code with IPython* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of the distributed version control system Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a **distributed version control system** is so natural nowadays that if
    you are reading this book, you are probably already using one. However, if you
    aren't, read this recipe carefully. You should always use a version control system
    for your code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notable distributed version control systems include **Git**, **Mercurial**,
    and **Bazaar**. In this chapter, we chose the popular Git system. You can download
    the Git program and Git GUI clients from [http://git-scm.com](http://git-scm.com).
    On Windows, you can also install **msysGit** ([http://msysgit.github.io](http://msysgit.github.io))
    and **TortoiseGit** ([https://code.google.com/p/tortoisegit/](https://code.google.com/p/tortoisegit/)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Distributed systems tend to be more popular than centralized systems such as
    SVN or CVS. Distributed systems allow local (offline) changes and offer more flexible
    collaboration systems.
  prefs: []
  type: TYPE_NORMAL
- en: Online providers supporting Git include **GitHub** ([https://github.com](https://github.com)),
    **Bitbucket** ([https://bitbucket.org](https://bitbucket.org)), **Google code**
    ([https://code.google.com](https://code.google.com)), **Gitorious** ([https://gitorious.org](https://gitorious.org)),
    and **SourceForge** ([https://sourceforge.net](https://sourceforge.net)). At the
    time of writing this book, creating an account is free on all these websites.
    GitHub offers free unlimited public repositories, while Bitbucket offers free
    unlimited public and private repositories. GitHub offers special features and
    discounts to academics ([https://github.com/edu](https://github.com/edu)). Synchronizing
    your Git repositories on such a website is particularly convenient when you work
    on multiple computers.
  prefs: []
  type: TYPE_NORMAL
- en: You need to install Git (and possibly a GUI) for this recipe (see [http://git-scm.com/downloads](http://git-scm.com/downloads)).
    We also suggest that you create an account on one of these websites. GitHub is
    a popular choice, notably for its user-friendly web interface and its well-developed
    social features. GitHub also provides a very good GUI on Windows ([https://windows.github.com](https://windows.github.com))
    and Mac OS X ([https://mac.github.com](https://mac.github.com)). Most Python libraries
    we will be using in this book are being developed on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will show two methods to initialize a repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is best when starting to work locally. This can be with using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The very first thing to do when starting a new project or computing experiment
    is create a new folder locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We initialize a Git repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s set our name and e-mail address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a new file, and tell Git to track it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s create our first commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cloning a remote repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method is best when the repository is to be synchronized with an online
    provider such as GitHub. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new repository on the web interface of our online provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the main webpage of the newly created project, we click on the **Clone**
    button with the repository URL and we type in a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set our name and e-mail address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a new file and tell Git to track it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create our first commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We push our local changes to the remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we have a local repository (created with the first method), we can synchronize
    it with a remote server using a `git remote add` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start a new project or a new computing experiment, create a new folder
    on your computer. You will eventually add code, text files, datasets, and other
    resources in this folder. The distributed version control system keeps track of
    the changes you make to your files as your project evolves. It is more than a
    simple backup, as every change you make on any file can be saved along with the
    corresponding timestamp. You can even revert to a previous state at any time;
    never be afraid of breaking your code anymore!
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you can take a snapshot of your project at any time by doing a
    **commit**. The snapshot includes all staged (or tracked) files. You are in total
    control of which files and changes will be tracked. With Git, you specify a file
    as staged for your next commit with `git add`, before committing your changes
    with `git commit`. The `git commit -a` command allows you to commit all changes
    in the files that are already being tracked.
  prefs: []
  type: TYPE_NORMAL
- en: When committing, you need to provide a message describing the changes you made.
    This makes the repository's history considerably more informative.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How often should you commit?**'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is very often. Git only takes responsibility of your work when you
    commit changes. What happens between two commits may be lost, so you'd better
    commit very regularly. Besides, commits are quick and cheap as they are local;
    that is, they do not involve any remote communication with an external server.
  prefs: []
  type: TYPE_NORMAL
- en: Git is a distributed version control system; your local repository does not
    need to synchronize with an external server. However, you should synchronize if
    you need to work on several computers, or if you prefer to have a remote backup.
    Synchronization with a remote repository can be done with `git push` (send your
    local commits on the remote server), `git fetch` (download remote branches and
    objects), or `git pull` (synchronize the remote changes on your local repository).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplistic workflow shown in this recipe is linear. In practice though,
    workflows with Git are typically nonlinear; this is the concept of branching.
    We will describe this idea in the next recipe, *A typical workflow with Git branching*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some excellent references on Git:'
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on tutorial, available at [https://try.github.io](https://try.github.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Guided Tour, at [http://gitimmersion.com](http://gitimmersion.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atlassian Git tutorial, available at [www.atlassian.com/git](http://www.atlassian.com/git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online course, available at [www.codeschool.com/courses/try-git](http://www.codeschool.com/courses/try-git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git tutorial by Lars Vogel, available at [www.vogella.com/tutorials/Git/article.html](http://www.vogella.com/tutorials/Git/article.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Git tutorial, available at [http://git-lectures.github.io](http://git-lectures.github.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git tutorial for scientists, available at [http://nyuccl.org/pages/GitTutorial/](http://nyuccl.org/pages/GitTutorial/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub help, available at [https://help.github.com](https://help.github.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pro Git* by Scott Chacon, available at [http://git-scm.com](http://git-scm.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *A typical workflow with Git branching* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical workflow with Git branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A distributed version control system such as Git is designed for complex and
    nonlinear workflows typical in interactive computing and exploratory research.
    A central concept is **branching**, which we will discuss in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to work in a local Git repository for this recipe (see the previous
    recipe, *Learning the basics of the distributed version control system Git*).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create a new branch named `newidea`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We switch to this branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We make changes to the code, for instance, by creating a new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add this file and commit our changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we are happy with the changes, we merge the branch to the *master* branch
    (the default):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, we delete the branch:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Other commands of interest include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git status`: Find the current **status** of the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log`: Show the commit logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch`: Show the existing **branches** and highlight the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git diff`: Show the **differences** between commits or branches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stashing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may happen that while we are halfway through some work, we need to make
    some other change in another commit or another branch. We could commit our half-done
    work, but this is not ideal. A better idea is to **stash** our working copy in
    a secured location so that we can recover all of our uncommitted changes later.
    Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We save our uncommitted changes with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can do anything we want with the repository: checkout a branch, commit changes,
    pull or push from a remote repository, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we want to recover our uncommitted changes, we type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can have several stashed states in the repository. More information about
    stashing can be found with `git stash --help`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine that in order to test a new idea, you need to make non-trivial
    changes to your code in multiple files. You create a new branch, test your idea,
    and end up with a modified version of your code. If this idea was a dead end,
    you switch back to the original branch of your code. However, if you are happy
    with the changes, you **merge** it into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: The strength of this workflow is that the main branch can evolve independently
    from the branch with the new idea. This is particularly useful when multiple collaborators
    are working on the same repository. However, it is also a good habit to have,
    especially when there is a single contributor.
  prefs: []
  type: TYPE_NORMAL
- en: Merging is not always a trivial operation, as it can involve two divergent branches
    with potential conflicts. Git tries to resolve conflicts automatically, but it
    is not always successful. In this case, you need to resolve the conflicts manually.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to merging is **rebasing**, which is useful when the main branch
    has changed while you were working on your branch. Rebasing your branch on the
    main branch allows you to move your branching point to a more recent point. This
    process may require you to resolve conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Git branches are lightweight objects. Creating and manipulating them is cheap.
    They are meant to be used frequently. It is important to perfectly grasp all related
    notions and `git` commands (notably `checkout`, `merge`, and `rebase`). The previous
    recipe contains many excellent references.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people have thought about effective workflows. For example, a common but
    complex workflow, called git-flow, is described at [http://nvie.com/posts/a-successful-git-branching-model/](http://nvie.com/posts/a-successful-git-branching-model/).
    However, it may be preferable to use a simpler workflow in small and mid-size
    projects, such as the one described at [http://scottchacon.com/2011/08/31/github-flow.html](http://scottchacon.com/2011/08/31/github-flow.html).
    The latter workflow elaborates on the simplistic example shown in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: A related notion to branching is **forking**. There can be multiple copies of
    the same repository on different servers. Imagine that you want to contribute
    to IPython's code stored on GitHub. You probably don't have the permission to
    modify their repository, but you can make a copy into your personal account—this
    is called forking. In this copy, you can create a branch and propose a new feature
    or a bug fix. Then, you can propose the IPython developers to merge your branch
    into their master branch with a **pull request**. They can review your changes,
    propose suggestions, and eventually merge your work (or not). GitHub is built
    around this idea and thereby offers a clean, modern way to collaborate on open
    source projects.
  prefs: []
  type: TYPE_NORMAL
- en: Performing code reviews before merging pull requests leads to higher code quality
    in a collaborative project. When at least two people review any piece of code,
    the probability of merging bad or wrong code is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, much more to say about Git. Version control systems are
    complex and quite powerful in general, and Git is no exception. Mastering Git
    requires time and experimentation. The previous recipe contains many excellent
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few further references about branches and workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: Git workflows available at [www.atlassian.com/git/workflows](http://www.atlassian.com/git/workflows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn Git branching at [http://pcottle.github.io/learnGitBranching/](http://pcottle.github.io/learnGitBranching/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Git workflow recommended on the NumPy project (and others), described at
    [http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html](http://docs.scipy.org/doc/numpy/dev/gitwash/development_workflow.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post on the IPython mailing list about an efficient Git workflow, by Fernando
    Perez, available at [http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html](http://mail.scipy.org/pipermail/ipython-dev/2010-October/006746.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Learning the basics of the distributed version control system Git* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ten tips for conducting reproducible interactive computing experiments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we present ten tips that can help you conduct efficient and
    **reproducible** interactive computing experiments. These are more guidelines
    than absolute rules.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will show how you can improve your productivity by minimizing the
    time spent doing repetitive tasks and maximizing the time spent thinking about
    your core work.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we will demonstrate how you can achieve more reproducibility in your
    computing work. Notably, academic research requires experiments to be reproducible
    so that any result or conclusion can be verified independently by other researchers.
    It is not uncommon for errors or manipulations in methods to result in erroneous
    conclusions that can have damaging consequences. For example, in the 2010 research
    paper in economics *Growth in a Time of Debt*, by Carmen Reinhart and Kenneth
    Rogoff, computational errors were partly responsible for a flawed study with global
    ramifications for policy makers (see [http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt](http://en.wikipedia.org/wiki/Growth_in_a_Time_of_Debt)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Organize your directory structure carefully and coherently. The specific structure
    does not matter. What matters is to be consistent throughout your projects regarding
    file-naming conventions, folders, subfolders, and so on. Here is a simple example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`my_project/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data/`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code/`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`common.py`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idea1.ipynb`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idea2.ipynb`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`figures/`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notes/`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write notes in text files using a lightweight markup language such as **Markdown**
    ([http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/))
    or **reStructuredText** (**reST**). All meta-information related to your project,
    files, data sets, code, figures, lab notebooks, and so on, should be written down
    in text files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relatedly, document everything non-trivial in your code with comments, docstrings,
    and so on. You can use a documentation tool such as **Sphinx** ([http://sphinx-doc.org](http://sphinx-doc.org)).
    However, do not spend too much time documenting unstable and bleeding-edge code
    while you are working on it; it might change frequently and your documentation
    may soon be out of date. Write your code in such a way that it's easily understandable
    without comments (name your variables and functions well, use Pythonic patterns,
    and so on). See also the next recipe, *Write high-quality Python code*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a distributed version control system such as Git for all text-based files,
    but not binary files (except maybe for very small ones when you really need to).
    You should use one repository per project. Synchronize the repositories on a remote
    server, using a free or paid hosting provider (such as GitHub or Bitbucket) or
    your own server (your host institution might be able to set up one for you). Use
    a specific system to store and share binary data files, such as [figshare.com](http://figshare.com)
    or [datadryad.org](http://datadryad.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write all your interactive computing code in IPython notebooks first and refactor
    it into standalone Python components only when it is sufficiently mature and stable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For full reproducibility, make sure that you record the exact versions of all
    components in your entire software stack (operating system, Python distribution,
    modules, and so on). A possibility is to use virtual environments with **virtualenv**
    or **conda**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cache long-to-compute intermediary results using Python's native **pickle**
    module, **dill** ([https://pypi.python.org/pypi/dill](https://pypi.python.org/pypi/dill)),
    or **Joblib** ([http://pythonhosted.org/joblib/](http://pythonhosted.org/joblib/)).
    Joblib notably implements a NumPy-aware **memoize** pattern (not to be confused
    with memorize), which allows you to cache the results of computationally intensive
    functions. See also the **ipycache** IPython extension ([https://github.com/rossant/ipycache](https://github.com/rossant/ipycache));
    it implements a `%%cache` cell magic in the notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Saving persistent data in Python**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For purely internal purposes, you can use Joblib, NumPy's `save` and `savez`
    functions for arrays, and pickle for any other Python object (prefer native types
    such as lists and dictionaries rather than custom classes). For sharing purposes,
    prefer text files for small datasets (less than 10k points), for example, CSV
    for arrays, and JSON or YAML for highly structured data. For larger datasets,
    you can use HDF5 (see the *Manipulating large arrays with HDF5 and PyTables* and
    *Manipulating large heterogeneous tables with HDF5 and PyTables* recipes of [Chapter
    4](ch04.html "Chapter 4. Profiling and Optimization"), *Profiling and Optimization*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When developing and trying out algorithms on large data sets, run them and compare
    them on small portions of your data first, before moving to the full sets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running jobs in a batch, use parallel computing to take advantage of your
    multicore processing units, for example, with `IPython.parallel`, Joblib, Python's
    multiprocessing package, or any other parallel computing library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automate your work as much as possible with Python functions or scripts. Use
    command-line arguments for user-exposed scripts, but prefer Python functions over
    scripts when possible. On Unix systems, learn terminal commands to improve your
    productivity. For repetitive tasks on Windows or GUI-based systems, use automation
    tools such as AutoIt ([www.autoitscript.com/site/autoit/](http://www.autoitscript.com/site/autoit/))
    or AutoHotKey ([www.autohotkey.com](http://www.autohotkey.com)). Learn keyboard
    shortcuts in the programs you use a lot, or create your own shortcuts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, you can create a keyboard shortcut to launch an IPython notebook
    server in the current directory. The following link contains an AutoHotKey script,
    which does this in Windows Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/](http://cyrille.rossant.net/start-an-ipython-notebook-server-in-windows-explorer/)'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tips given in this recipe ultimately aim to optimize your workflows, in
    terms of human time, computer time, and quality. Using coherent conventions and
    structure for your code makes it easier for you to organize your work. Documenting
    everything saves everyone's time, including (eventually) yours! Should you be
    hit by a bus tomorrow, which I really hope you are not, you should ensure that
    your substitute can take over quickly, thanks to your conscientiously-written
    documentation. (You can find more information about the bus factor at [http://en.wikipedia.org/wiki/Bus_factor](http://en.wikipedia.org/wiki/Bus_factor).)
  prefs: []
  type: TYPE_NORMAL
- en: Using a distributed version control system with an online hosting service makes
    it easy for you to work on the same code base from multiple locations, without
    ever worrying about backups. As you can go back in time in your code, you have
    very little chance of unintentionally breaking it.
  prefs: []
  type: TYPE_NORMAL
- en: The IPython notebook is an excellent tool for reproducible interactive computing.
    It lets you keep a detailed record of your work. Also, the IPython notebook's
    ease of use means that you don't have to worry about reproducibility; just do
    all of your interactive work in notebooks, put them under version control, and
    commit regularly. Don't forget to refactor your code into independent reusable
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure to optimize the time you spend in front of your computer. When working
    on an algorithm, this cycle frequently happens: you do a slight modification,
    you launch the code, get the results, make another change, and so on and so forth.
    If you need to try out a lot of changes, you should ensure that the execution
    time is fast enough (no more than a few seconds). Using advanced optimization
    techniques is not necessarily the best option at this stage of experimentation.
    You should cache your results, try out your algorithms on data subsets, and run
    your simulations with shorter durations. You can also launch batch jobs in parallel
    when you want to test different parameter values.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, desperately try to avoid doing repetitive tasks. It is worth spending
    time automating such tasks when they occur frequently in your day-to-day work.
    It is more difficult to automate tasks that involve GUIs, but it is feasible thanks
    to free tools such as AutoIt or AutoHotKey.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references about reproducibility in computing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An efficient workflow for reproducible science*, a talk by Trevor Bekolay,
    available at [http://bekolay.org/scipy2013-workflow/](http://bekolay.org/scipy2013-workflow/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ten Simple Rules for Reproducible Computational Research*, *Sandve et al.*,
    *PLoS Computational Biology*, *2013*, available at [http://dx.doi.org/10.1371/journal.pcbi.1003285](http://dx.doi.org/10.1371/journal.pcbi.1003285).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Konrad Hinsen's blog at [http://khinsen.wordpress.com](http://khinsen.wordpress.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software Carpentry, a volunteer organization running workshops for scientists;
    the workshops cover scientific programming, interactive computing, version control,
    testing, reproducibility, and task automation. You can find more information at
    [http://software-carpentry.org](http://software-carpentry.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Efficient interactive computing workflows with IPython* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing high-quality Python code* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing high-quality Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing code is easy. Writing high-quality code is much harder. Quality is to
    be understood both in terms of actual code (variable names, comments, docstrings,
    and so on) and architecture (functions, modules, and classes). In general, coming
    up with a well-designed code architecture is much more challenging than the implementation
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will give a few tips about how to write high-quality code.
    This is a particularly important topic in academia, as more and more scientists
    without prior experience in software development need to program.
  prefs: []
  type: TYPE_NORMAL
- en: The references given at the end of this recipe contain much more details than
    what we could mention here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take the time to learn the Python language seriously. Review the list of all
    modules in the standard library—you may discover that functions you implemented
    already exist. Learn to write *Pythonic* code, and do not translate programming
    idioms from other languages such as Java or C++ to Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn common **design patterns**; these are general reusable solutions to commonly
    occurring problems in software engineering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use assertions throughout your code (the `assert` keyword) to prevent future
    bugs (**defensive programming**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start writing your code with a bottom-up approach; write independent Python
    functions that implement focused tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not hesitate to refactor your code regularly. If your code is becoming too
    complicated, think about how you can simplify it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid classes when you can. If you can use a function instead of a class, choose
    the function. A class is only useful when you need to store persistent state between
    function calls. Make your functions as *pure* as possible (no side effects).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In general, prefer Python native types (lists, tuples, dictionaries, and types
    from Python's collections module) over custom types (classes). Native types lead
    to more efficient, readable, and portable code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose keyword arguments over positional arguments in your functions. Argument
    names are easier to remember than argument ordering. They make your functions
    self-documenting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your variables carefully. Names of functions and methods should start with
    a verb. A variable name should describe what it is. A function name should describe
    what it does. The importance of naming things well cannot be overstated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Every function should have a docstring describing its purpose, arguments, and
    return values, as shown in the following example. You can also look at the conventions
    chosen in popular libraries such as NumPy. The important thing is to be consistent
    within your code. You can use a markup language such as Markdown or reST:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Follow (at least partly) Guido van Rossum's Style Guide for Python, also known
    as **Python Enhancement Proposal number 8** (**PEP8**), available at [www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/).
    It is a long read, but it will help you write well-readable Python code. It covers
    many little things such as spacing between operators, naming conventions, comments,
    and docstrings. For instance, you will learn that it is considered a good practice
    to limit any line of your code to 79 characters (or 99 exceptionally if that improves
    readability). This way, your code can be correctly displayed in most situations
    (such as in a command-line interface or on a mobile device) or side by side with
    another file. Alternatively, you can decide to ignore certain rules. In general,
    following common guidelines is beneficial on projects involving many developers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check your code automatically against most of the style conventions
    in PEP8 with the **pep8** Python package. Install it with `pip install pep8` and
    execute it with `pep8 myscript.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a tool for static code analysis such as Pylint ([www.pylint.org](http://www.pylint.org)).
    It lets you find potential errors or low-quality code *statically*, that is, without
    running your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use blank lines to avoid cluttering your code (see PEP8). You can also demarcate
    sections in a long Python module with salient comments like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A Python module should not contain more than a few hundreds lines of code. Having
    too many lines of code in a module may be a sign that you need to split it into
    several modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Organize important projects (with tens of modules) into subpackages, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`core/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utils/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__.py`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at how major Python projects are organized. For example, IPython's
    code is well-organized into a hierarchy of subpackages with focused roles. Reading
    the code itself is also quite instructive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Learn best practices to create and distribute a new Python package. Make sure
    that you know setuptools, pip, wheels, virtualenv, PyPI, and so on. Also, you
    are highly encouraged to take a serious look at conda ([http://conda.pydata.org](http://conda.pydata.org)),
    a powerful and generic packaging system created by Continuum Analytics. Packaging
    is a chaotic and rapidly evolving topic in Python, so read only the most recent
    references. There are a few references in the *There's more…* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing readable code means that other people (or you in a few months or years)
    will understand it quicker and will be more willing to use it. It also facilitates
    bug tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Modular code is also easier to understand and to reuse. Implementing your program's
    functionality in independent functions that are organized as a hierarchy of packages
    and modules is an excellent way of achieving high code quality.
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to keep your code loosely coupled when you use functions instead
    of classes. Spaghetti code is really hard to understand, debug, and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Iterate between bottom-up and top-down approaches while working on a new project.
    Starting with a bottom-up approach lets you gain experience with the code before
    you start thinking about the overall architecture of your program. Still, make
    sure you know where you're going by thinking about how your components will work
    together.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much has been written on how to write beautiful code—see the following references.
    You can find many books on the subject. In the next recipe, we will cover standard
    techniques to make sure that our code not only looks nice but also works as expected:
    unit testing, code coverage, and continuous integration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python Cookbook*, by David Beazley and Brian K. Jones, with many Python 3
    advanced recipes, available at [http://shop.oreilly.com/product/0636920027072.do](http://shop.oreilly.com/product/0636920027072.do)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Hitchhiker''s Guide to Python!*, available at [http://docs.python-guide.org/en/latest/](http://docs.python-guide.org/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns on Wikipedia, available at [http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns in Python, described at [https://github.com/faif/python-patterns](https://github.com/faif/python-patterns)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding standards of Tahoe-LAFS, available at [https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards](https://tahoe-lafs.org/trac/tahoe-lafs/wiki/CodingStandards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to be a great software developer*, by Peter Nixey, available at [http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer](http://peternixey.com/post/83510597580/how-to-be-a-great-software-developer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why you should write buggy software with as few features as possible*, a talk
    by Brian Granger, available at [www.youtube.com/watch?v=OrpPDkZef5I](http://www.youtube.com/watch?v=OrpPDkZef5I)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Hitchhiker''s Guide to Packaging*, available at [http://guide.python-distribute.org](http://guide.python-distribute.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Packaging User Guide*, available at [http://python-packaging-user-guide.readthedocs.org](http://python-packaging-user-guide.readthedocs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Ten tips for conducting reproducible interactive computing experiments*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing unit tests with nose* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests with nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manual testing is essential to ensuring that our software works as expected
    and does not contain critical bugs. However, manual testing is severely limited
    because bugs may be introduced every time a change is made in the code. We can't
    possibly expect to manually test our entire program at every commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, automated testing is a standard practice in software engineering.
    In this recipe, we will briefly cover important aspects of automated testing:
    unit tests, test-driven development, test coverage, and continuous integration.
    Following these practices is absolutely necessary in order to produce high-quality
    software.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a native unit-testing module that you can readily use (`unittest`).
    Other third-party unit testing packages exist, such as py.test or nose, which
    we have chosen here. nose makes it a bit easier to write a test suite, and it
    has a library of external plugins. Your users don't need that extra dependency
    unless they want to run the test suite themselves. You can install nose with `pip
    install nose`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will write a unit test for a function that downloads a file
    from a URL. A testing suite should run and successfully pass even in the absence
    of a network connection. We take care of that by fooling Python's `urllib` module
    with a mock HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code snippets used in this recipe have been written for Python 3\. A few
    changes are required to make them work with Python 2, and we have indicated these
    changes in the code. The versions for Python 2 and Python 3 are both available
    on the book's website.
  prefs: []
  type: TYPE_NORMAL
- en: You may also be interested in the `requests` module; it provides a much simpler
    API for HTTP requests ([http://docs.python-requests.org/en/latest/](http://docs.python-requests.org/en/latest/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a file named `datautils.py` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a file named `test_datautils.py` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to launch the tests, we execute the following command in a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first unit test passes! Now, let''s add a new test. We add some code at
    the end of `test_datautils.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We launch the tests again with the `nosetests` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second test fails. In a real-world scenario, we might need to debug the
    program. This should be easy because the bug is isolated in a single test function.
    Here, by inspecting the traceback error and the code, we find that the bug results
    from the requested URL not ending with a proper file name. Thus, the inferred
    file name, `os.path.basename(url)`, is empty. Let''s fix this by replacing the
    `download` function in `datautils.py` with the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s run the tests again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `nosetests` hides the standard output (unless errors occur). If
    you want the standard output to show up, use `nosetests --nocapture`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `test_xxx.py` module should accompany every Python module named `xxx.py`.
    This testing module contains functions (unit tests) that execute and test functionality
    implemented in the `xxx.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, a given unit test must focus on one very specific functionality.
    All unit tests should be completely independent. Writing a program as a collection
    of well-tested, mostly decoupled units forces you to write modular code that is
    more easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes your module's functions require preliminary work to run (for
    example, setting up the environment, creating data files, or setting up a web
    server). The unit testing framework can handle this; just write `setup()` and
    `teardown()` functions (called **fixtures**), and they will be called at the beginning
    and at the end of the test module, respectively. Note that the state of the system
    environment should be exactly the same before and after a testing module runs
    (for example, temporarily created files should be deleted in `teardown`).
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `datautils.py` module contains a single function, `download`, that
    accepts a URL as an argument, downloads the file, and saves it locally. This module
    comes with a testing module named `test_datautils.py`. You should choose the same
    convention in your program (`test_<modulename>` for the testing module of `modulename`).
    This testing module contains one or several functions prefixed with `test_`. This
    is how nose automatically discovers the unit tests across your project. nose also
    accepts other similar conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: nose runs all tests it can find in your project, but you can, of course, have
    more fine-grained control over the tests to run. Type `nosetests --help` to get
    the list of all options. You can also check out the documentation at [http://nose.readthedocs.org/en/latest/testing.html](http://nose.readthedocs.org/en/latest/testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: The testing module also contains the `setup` and `teardown` functions, which
    are automatically detected as fixtures by nose. A custom HTTP handler object is
    created within the `setup` function. This object captures all HTTP requests, even
    those with fictional URLs. The `setup` function then moves into a test folder
    (created with the `tempfile` module) to avoid potential conflicts between downloaded
    files and existing files. In general, unit tests should not leave any trace; this
    is how we ensure that they are fully reproducible. Likewise, the `teardown` function
    deletes the test folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python 3.2 and higher versions, you can also use `tempfile.TemporaryDirectory`
    to create a temporary directory.
  prefs: []
  type: TYPE_NORMAL
- en: The first unit test downloads a file from a mock URL and checks whether it contains
    the expected contents. By default, a unit test passes if it does not raise an
    exception. This is where `assert` statements, which raise exceptions if the statement
    is `False`, are useful. nose also comes with convenient routines and decorators
    for precisely determining the conditions under which a particular unit test is
    expected to pass or fail (for example, it should raise a particular exception
    to pass, or it should run in less than *X* seconds, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further convenient assert-like functions are provided by NumPy (see [http://docs.scipy.org/doc/numpy/reference/routines.testing.html](http://docs.scipy.org/doc/numpy/reference/routines.testing.html)).
    They are especially useful when working with arrays. For example, `np.testing.assert_allclose(x,
    y)` asserts that the `x` and `y` arrays are almost equal, up to a given precision
    that can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a full testing suite takes time. It imposes strong (but good) constraints
    on your code's architecture. It's a real investment, but it is always profitable
    in the long run. Also, knowing that your project is backed by a full testing suite
    is a real load off your mind.
  prefs: []
  type: TYPE_NORMAL
- en: First, thinking about unit tests from the beginning forces you to think about
    a modular architecture. It is really difficult to write unit tests for a monolithic
    program full of interdependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Second, unit tests make it easier for you to find and fix bugs. If a unit test
    fails after introducing a change in the program, isolating and reproducing the
    bugs becomes trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Third, unit tests help you avoid **regressions**, that is, fixed bugs that silently
    reappear in a later version. When you discover a new bug, you should write a specific
    failing unit test for it. To fix it, make this test pass. Now, if the bug reappears
    later, this unit test will fail and you will immediately be able to address it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you write a complex program in several layers, with an *n+1*
    layer based on an *n* layer. Having a battery of successful unit tests for the
    *n* layer makes you confident that it works as expected. When working on the *n+1*
    layer, you can focus on this layer instead of constantly worrying whether the
    layer below works or not.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is not the whole story, as it just concerns independent components.
    Further levels of testing are required in order to ensure good integration of
    the components within the program.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is a wide topic, and we only scratched the surface in this recipe.
    We give some further information here.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using unit tests is good. However, measuring **test coverage** is even better:
    it quantifies how much of our code is being covered by your testing suite. Ned
    Batchelder''s **coverage** module ([http://nedbatchelder.com/code/coverage/](http://nedbatchelder.com/code/coverage/))
    does precisely this. It integrates very well with nose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install coverage with `pip install coverage`. Then run your testing
    suite with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command instructs nose to launch your testing suite with coverage measurement
    for the `datautils` package only.
  prefs: []
  type: TYPE_NORMAL
- en: The [coveralls.io](http://coveralls.io) service brings test-coverage features
    to a continuous integration server (refer to the *Unit testing and continuous
    integration* section). It works seamlessly with GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Workflows with unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the particular workflow we have used in this example. After writing our
    `download` function, we created a first unit test that passed. Then we created
    a second test that failed. We investigated the issue and fixed the function. The
    second test passed. We could continue writing more and more complex unit tests,
    until we are confident that the function works as expected in most situations.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run `nosetests --pdb` to drop into the Python debugger on failures. This is
    quite convenient to find out quickly why a unit test fails.
  prefs: []
  type: TYPE_NORMAL
- en: This is **test-driven development**, which consists of writing unit tests *before*
    writing the actual code. This workflow forces us to think about what our code
    does and how one uses it, instead of how it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing and continuous integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good habit to get into is running the full testing suite of our project at
    every commit. In fact, it is even possible to do this completely transparently
    and automatically through **continuous integration**. We can set up a server that
    automatically runs our testing suite in the cloud at every commit. If a test fails,
    we get an automatic e-mail telling us what the problem is so that we can fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many continuous integration systems and services: Jenkins/Hudson,
    [https://drone.io](https://drone.io), [http://stridercd.com](http://stridercd.com),
    [https://travis-ci.org](https://travis-ci.org), and many others. Some of them
    play well with GitHub projects. For example, to use Travis CI with a GitHub project,
    create an account on Travis CI, link your GitHub project to this account, and
    then add a `.travis.yml` file with various settings in your repository (see the
    additional details in the following references).'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, unit testing, code coverage, and continuous integration are standard
    practices that should be used for all significant projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development, available at [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Untested code is broken code: test automation in enterprise software delivery*,
    by Martin Aspeli, available at [www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver](http://www.deloittedigital.com/eu/blog/untested-code-is-broken-code-test-automation-in-enterprise-software-deliver)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation of Travis CI in Python, at [http://about.travis-ci.org/docs/user/languages/python/](http://about.travis-ci.org/docs/user/languages/python/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your code with IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is an integral part of software development and interactive computing.
    A widespread debugging technique consists of placing `print` statements in various
    places in the code. Who hasn't done this? It is probably the simplest solution,
    but it is certainly not the most efficient (it's the poor man's debugger).
  prefs: []
  type: TYPE_NORMAL
- en: IPython is perfectly adapted for debugging, and the integrated debugger is quite
    easy to use (actually, IPython merely offers a nice interface to the native Python
    debugger `pdb`). In particular, tab completion works in the IPython debugger.
    This recipe describes how to debug code with IPython.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier versions of the IPython notebook did not support the debugger, that
    is, the debugger could be used in the IPython terminal and Qt console, but not
    in the notebook. This issue was fixed in IPython 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two not-mutually exclusive ways of debugging code in Python. In the
    post-mortem mode, the debugger steps into the code as soon as an exception is
    raised so that we can investigate what caused it. In the step-by-step mode, we
    can stop the interpreter at a breakpoint and resume its execution step by step.
    This process allows us to check carefully the state of our variables as our code
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Both methods can actually be used simultaneously; we can do step-by-step debugging
    in the post-mortem mode.
  prefs: []
  type: TYPE_NORMAL
- en: The post-mortem mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an exception is raised within IPython, execute the `%debug` magic command
    to launch the debugger and step into the code. Also, the `%pdb on` command tells
    IPython to launch the debugger automatically as soon as an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are in the debugger, you have access to several special commands,
    the most important ones being listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`p varname` **prints** the value of a variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` shows your current location within the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u` goes **up** in the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` goes **down** in the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l` shows the **lines** of code around your current location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` shows the **arguments** of the current function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call stack contains the list of all active functions at a given location
    in the code's execution. You can easily navigate up and down the stack to inspect
    the values of the function arguments. Although quite simple to use, this mode
    should let you resolve most of your bugs. For more complex problems, you may need
    to do step-by-step debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Step-by-step debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have several options to start the step-by-step debugging mode. First, in
    order to put a breakpoint somewhere in your code, insert the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you can run a script from IPython with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This command runs the `script.py` file under the control of the debugger with
    a breakpoint on line 20 in `extscript.py` (which is imported at some point by
    `script.py`). Finally, you can do step-by-step debugging as soon as you are in
    the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step-by-step debugging consists of precisely controlling the course of the
    interpreter. Starting from the beginning of a script or from a breakpoint, you
    can resume the execution of the interpreter with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s` executes the current line and stops as soon as possible afterwards (**step-by-step**
    debugging, that is, the most fine-grained execution pattern)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` continues the execution until the **next** line in the current function
    is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r` continues the execution until the current function **returns**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` **continues** the execution until the next breakpoint is reached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`j 30` brings you to line 30 in the current file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add breakpoints dynamically from within the debugger using the `b` command
    or with `tbreak` (temporary breakpoint). You can also clear all or some of the
    breakpoints, enable or disable them, and so on. You can find the full details
    of the debugger at [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To debug your code with IPython, you typically need to execute it first with
    IPython, for example, with `%run`. However, you may not always have an easy way
    of doing this. For instance, your program may run with a custom command-line Python
    script, it may be launched by a complex bash script, or it may be integrated within
    a GUI. In these cases, you can embed an IPython interpreter at any point in your
    code (launched by Python), instead of running your whole program with IPython
    (which may be overkill if you just need to debug a small portion of your code).
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed IPython within your program, simply insert the following commands
    somewhere in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When your Python program reaches this code, it will pause and launch an interactive
    IPython terminal at this specific point. You will then be able to inspect all
    local variables, run any code you want, and possibly debug your code before resuming
    normal execution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: rfoo, available at [https://code.google.com/p/rfoo/](https://code.google.com/p/rfoo/),
    lets you inspect and modify the namespace of a running Python script remotely.
  prefs: []
  type: TYPE_NORMAL
- en: GUI debuggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most Python IDEs offer graphical debugging features (see the *Efficient interactive
    computing workflows with IPython* recipe). A GUI can sometimes be more convenient
    than a command-line debugger. Let's also mention Winpdb ([winpdb.org](http://winpdb.org)),
    a graphical platform-independent Python debugger.
  prefs: []
  type: TYPE_NORMAL
