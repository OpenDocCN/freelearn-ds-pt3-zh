<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Advanced Computing with SciPy, Numba, and NumbaPro"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Computing with SciPy, Numba, and NumbaPro</h1></div></div></div><p>In this chapter, the user will learn how to use <code class="literal">SciPy</code> to perform scientific computations. The <code class="literal">Numba</code> package will then be introduced as a way to accelerate computations. Finally, the <code class="literal">NumbaPro</code> capabilities of parallel execution in the GPU will be presented.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overview of <code class="literal">SciPy</code></li><li class="listitem" style="list-style-type: disc">Advanced mathematical algorithms with <code class="literal">SciPy</code></li><li class="listitem" style="list-style-type: disc">Accelerating computations with <code class="literal">Numba</code> and <code class="literal">NumbaPro</code></li></ul></div><p>Before running the examples in this chapter, load <code class="literal">pylab</code> by running the following command in a computing cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%pylab inline</strong></span>
</pre></div><div class="section" title="Overview of SciPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Overview of SciPy</h1></div></div></div><p>
<code class="literal">SciPy</code> is <a class="indexterm" id="id346"/>an extensive library for applied mathematics and scientific computation. The following is the complete list of all the modules available in the library:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Module</p>
</th><th style="text-align: left" valign="bottom">
<p>Functionality</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cluster</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Clustering algorithms</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">constants</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Physical and mathematical constants</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fftpack</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Fast Fourier Transform</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">integrate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Integration and ordinary differential equations</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">interpolate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Interpolation and splines</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">io</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Input and output</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">linalg</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Linear algebra</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ndimage</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Image processing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">odr</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Orthogonal distance regression</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">optimize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Optimization and root-finding </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">signal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Signal processing</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sparse</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sparse matrices </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">spatial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Spatial data structures</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">special</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Special functions</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">stats</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Statistical distributions</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">weave</code>
</p>
</td><td style="text-align: left" valign="top">
<p>C/C++ integration</p>
</td></tr></tbody></table></div><p>The standard way to import <code class="literal">SciPy</code> modules in scripts is using the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from scipy import signal</strong></span>
</pre></div><p>Then, individual functions can be called with the usual module reference syntax, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>signal.correlate(…)</strong></span>
</pre></div><p>However, many of the <a class="indexterm" id="id347"/>most used functions are available at the top level of the <code class="literal">SciPy</code> hierarchy. Also, we use IPython in the interactive mode and use (as we assume in this book) the magic, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%pylab inline</strong></span>
</pre></div><p>Many of the functions will be available without explicit module reference.</p><p>In the next section, we present a sample of the functions available in <code class="literal">SciPy</code>. The reader is not expected to know the mathematical techniques and algorithms that will be used in the examples in depth.</p></div></div>
<div class="section" title="Advanced mathematical algorithms with SciPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Advanced mathematical algorithms with SciPy</h1></div></div></div><p>In this section, we <a class="indexterm" id="id348"/>will cover some of the algorithms <a class="indexterm" id="id349"/>available in <code class="literal">SciPy</code>. Each of the following subsections features a representative example from a significant area of applied science. The examples are chosen so as not to require extensive domain knowledge but still be realistic. These are the topics and examples that we present:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Solving equations and finding optimal values</strong></span>: We will study a market model that requires the solution of a nonlinear system and a facility location problem requiring a nonstandard optimization.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Calculus and differential equations</strong></span>: We will present a volume calculation that uses integral calculus, and <span class="strong"><strong>Newton's canon</strong></span>, a thought experiment proposed by Isaac Newton, which we will model using a system of differential equations. Finally, we will present a three-dimensional system, the famous Lorenz <a class="indexterm" id="id350"/>equations, which is an early <a class="indexterm" id="id351"/>example displaying chaotic behavior.</li></ul></div><div class="section" title="Solving equations and finding optimal values"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Solving equations and finding optimal values</h2></div></div></div><p>To illustrate <a class="indexterm" id="id352"/>this topic, we use a standard supply-versus-demand model from economics. In this model, supply and demand are related to prices by <a class="indexterm" id="id353"/>functional relationships, and the equilibrium market is found by determining the intersection of the supply and demand curves. The <a class="indexterm" id="id354"/>mathematical formulae we use in the example are somewhat arbitrary (thus possibly unrealistic) but will go beyond what is found in <a class="indexterm" id="id355"/>textbooks, where supply and demand are in general assumed to be linear.</p><p>The formulae that specify the supply and demand curves are as follows:</p><div class="mediaobject"><img alt="Solving equations and finding optimal values" src="graphics/8341OS_05_15.jpg"/></div><p>We will use the <span class="emphasis"><em>function factory</em></span> pattern. Run the following lines of code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def make_supply(A, B, C):</strong></span>
<span class="strong"><strong>    def supply_func(q):</strong></span>
<span class="strong"><strong>        return A * q / (C  - B * q)</strong></span>
<span class="strong"><strong>    return supply_func</strong></span>
<span class="strong"><strong>def make_demand(K, L):</strong></span>
<span class="strong"><strong>    def demand_func(q):</strong></span>
<span class="strong"><strong>        return K / (1 + L * q)</strong></span>
<span class="strong"><strong>    return demand_func</strong></span>
</pre></div><p>The preceding code doesn't directly define the supply and demand curves. Instead, it specifies function factories. This approach makes it easier to work with parameters, which is what we normally want to do in applied problems since we expect the same model to be applicable to a variety of situations.</p><p>Next, we set the <a class="indexterm" id="id356"/>parameter values and call the function factories to <a class="indexterm" id="id357"/>define the functions that actually evaluate the supply and demand curves, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>A, B, C = 23.3, 9.2, 82.4</strong></span>
<span class="strong"><strong>K, L = 1.2, 0.54</strong></span>
<span class="strong"><strong>supply = make_supply(A, B, C)</strong></span>
<span class="strong"><strong>demand = make_demand(K, L)</strong></span>
</pre></div><p>The following <a class="indexterm" id="id358"/>lines of code make a graph of the curves:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>q = linspace(0.01,5,200)</strong></span>
<span class="strong"><strong>plot(q, supply(q), lw = 2)</strong></span>
<span class="strong"><strong>plot(q, demand(q), lw = 2)</strong></span>
<span class="strong"><strong>title('Supply and demand curves')</strong></span>
<span class="strong"><strong>xlabel('Quantity (thousands of units)')</strong></span>
<span class="strong"><strong>ylabel('Price ($)')</strong></span>
<span class="strong"><strong>legend(['Supply', 'Demand'], loc='upper left')</strong></span>
</pre></div><p>The following <a class="indexterm" id="id359"/>is the graph that is the output of the preceding lines of code:</p><div class="mediaobject"><img alt="Solving equations and finding optimal values" src="graphics/8341OS_05_01.jpg"/></div><p>The curves chosen for supply and demand reflect what would be reasonable assumptions: supply increases and demand decreases as the price gets higher. Even with a zero price, the demand is finite (reflecting the fact that there is a limited population interested in the product). On the other hand, the supply curve has a vertical asymptote (not shown in the plot), indicating that there is a production limit (so, even if the price goes to infinity, there is a limited quantity that can be offered in the market).</p><p>The equilibrium <a class="indexterm" id="id360"/>point of the market is the intersection of the supply <a class="indexterm" id="id361"/>and demand curves. To find the equilibrium, we use the <code class="literal">optimize</code> module, which, besides providing functions for optimization, also has <a class="indexterm" id="id362"/>functions to solve numerical equations. The recommended function to find solutions for one-variable functions is <code class="literal">brentq()</code>, as illustrated <a class="indexterm" id="id363"/>in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from scipy import optimize</strong></span>
<span class="strong"><strong>def opt_func(q):</strong></span>
<span class="strong"><strong>    return supply(q) - demand(q)</strong></span>
<span class="strong"><strong>q_eq = optimize.brentq(opt_func, 1.0, 2.0)</strong></span>
<span class="strong"><strong>print q_eq, supply(q_eq), demand(q_eq)</strong></span>
</pre></div><p>The <code class="literal">brentq()</code> function <a class="indexterm" id="id364"/>assumes that the right-hand side of the equation we want to solve is <code class="literal">0</code>. So, we start by defining the <code class="literal">opt_func()</code> function that computes the difference between supply and demand. This function is the first argument of <code class="literal">brentq()</code>. The next two numerical arguments give an interval that contains the solutions. It is important to choose an interval that contains exactly one solution of the equation. In our example, this is easily done by looking at the graph, from which it is clear that the curves intersect between 1 and 2.</p><p>Running the preceding code produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1.75322153719 0.616415252177 0.616415252177</strong></span>
</pre></div><p>The first value is the equilibrium point, which is the number of units (in thousands) that can be sold at the optimal price. The optimal price is computed using both the supply and demand curves (to check that the values are indeed the same).</p><p>To illustrate an <a class="indexterm" id="id365"/>optimization problem in two variables, let's consider a problem of optimal facility location. Suppose a factory has several manufacturing <a class="indexterm" id="id366"/>stations that need materials to be distributed from a <a class="indexterm" id="id367"/>single supply station. The factory floor is rectangular, and the distribution rails must be parallel to the walls of the factory. This last requirement is <a class="indexterm" id="id368"/>what makes the problem interesting. The function to be minimized is related to the so-called <span class="strong"><strong>taxicab</strong></span> <span class="strong"><strong>distance</strong></span>, which is <a class="indexterm" id="id369"/>illustrated in the following image:</p><div class="mediaobject"><img alt="Solving equations and finding optimal values" src="graphics/8341OS_05_02.jpg"/></div><p>The first step is to define the points where the manufacturing stations are given, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>points = array([[10.3,15.4],[6.5,8.8],[15.6,10.3],[4.7,12.8]])</strong></span>
</pre></div><p>The positions are stored as a 4 x 2 <code class="literal">NumPy</code> array called <code class="literal">points</code>, with one point in each row. The following command produces a plot of the points mentioned in the previous command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(points[:,0],points[:,1], 'o', ms=12, mfc='LightSkyBlue')</strong></span>
</pre></div><p>The points are displayed <a class="indexterm" id="id370"/>using a circular marker specified by the <a class="indexterm" id="id371"/>argument <code class="literal">o</code>, which also turns off the line segments <a class="indexterm" id="id372"/>connecting the points. The <code class="literal">ms</code> and <code class="literal">mfc</code> options specify the size of the marker (in pixels) and its color, respectively. The following image is then <a class="indexterm" id="id373"/>generated as the output:</p><div class="mediaobject"><img alt="Solving equations and finding optimal values" src="graphics/8341OS_05_03.jpg"/></div><p>The next step is to define the function to be minimized. We again prefer the approach of defining a function factory, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def make_txmin(points):</strong></span>
<span class="strong"><strong>    def txmin_func(p):</strong></span>
<span class="strong"><strong>        return sum(abs(points - p))</strong></span>
<span class="strong"><strong>    return txmin_func</strong></span>
</pre></div><p>The main point of this code is the way in which the taxicab distance is computed, which takes full advantage of the flexibility of the array operations of <code class="literal">NumPy</code>. This is done in the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>return sum(abs(points - p))</strong></span>
</pre></div><p>This code first computes the vector difference, <code class="literal">points-p</code>. Note that, here, <code class="literal">points</code> is a 4 x 2 array, while <code class="literal">p</code> is a 1 x 2 array. <code class="literal">NumPy</code> realizes that the dimensions of the arrays are different and uses its <span class="emphasis"><em>broadcasting rules</em></span>. The effect is that the array <code class="literal">p</code> is subtracted from each row of the <code class="literal">points</code> array, which is exactly what we want. Then the <code class="literal">abs()</code> function computes the absolute value of each of the entries of the resulting array, and finally <code class="literal">sum()</code> adds all the entries. That's a lot of work done in a single line of code!</p><p>We then have to use the function factory to define the function that will actually compute the taxicab distance.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>txmin = make_txmin(points)</strong></span>
</pre></div><p>The function factory is <a class="indexterm" id="id374"/>simply called with the array containing the actual positions as its argument. At this point, the problem is completely set up, and we are ready <a class="indexterm" id="id375"/>to compute the optimum, which is done with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from scipy import optimize</strong></span>
<span class="strong"><strong>x0 = array([0.,0.])</strong></span>
<span class="strong"><strong>res = optimize.minimize(</strong></span>
<span class="strong"><strong>         txmin, x0,</strong></span>
<span class="strong"><strong>         method='nelder-mead',</strong></span>
<span class="strong"><strong>         options={'xtol':1e-5, 'disp':True})</strong></span>
</pre></div><p>The minimization is computed by a call to the <code class="literal">minimize()</code> function. The first two arguments of this function are the objective function defined in the previous cell, <code class="literal">txmin()</code>, and an initial guess, <code class="literal">x0</code>. We just choose the origin as the initial guess, but in a real-world problem, we <a class="indexterm" id="id376"/>use any information we can gather to select a <a class="indexterm" id="id377"/>guess that is close to the actual minimum. Several optimization methods are available, suitable for different types of objective functions. We <a class="indexterm" id="id378"/>use the <span class="strong"><strong>Nelder-Mead method</strong></span>, which is a heuristic algorithm that does not require smoothness of the objective function. This is well suited for the problem at hand. Finally, we specify two options for the method: the desired tolerance and a display option to print diagnostics. This produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Optimization terminated successfully.</strong></span>
<span class="strong"><strong>         Current function value: 23.800000</strong></span>
<span class="strong"><strong>         Iterations: 87</strong></span>
<span class="strong"><strong>         Function evaluations: 194</strong></span>
</pre></div><p>The preceding output states that a minimum was successfully found and gives its value. Note that, as in any numerical optimization method, in general, it can only be guaranteed that a local minimum was found. In this case, since the objective function is convex, the minimum is guaranteed to be global. The result of the function is stored in a <code class="literal">SciPy</code> data structure of the <code class="literal">OptimizeResult</code> type defined in the <code class="literal">optimize</code> module. To get the optimal position of the facility, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>print res.x</strong></span>
</pre></div><p>The output of the preceding command is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[  8.37782286  11.36247412]</strong></span>
</pre></div><p>To finish this example, we present the code that displays the optimal solution:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(points[:,0],points[:,1], 'o', ms=12, mfc='LightSkyBlue')</strong></span>
<span class="strong"><strong>plot(res.x[0], res.x[1],'o', ms=12, mfc='LightYellow')</strong></span>
<span class="strong"><strong>locstr = 'x={:5.2f}, y={:5.2f}'.format(res.x[0], res.x[1])</strong></span>
<span class="strong"><strong>title('Optimal facility location: {}'.format(locstr))</strong></span>
</pre></div><p>The calls to the <code class="literal">plot()</code> function are similar to the ones in the previous example. To give a nicely formatted title, we first define the <code class="literal">locstr</code> string, which displays the optimal location coordinates. This <a class="indexterm" id="id379"/>is a Python-formatted string with the format <a class="indexterm" id="id380"/>specification of <code class="literal">{:5.2f}</code>, that is, a floating-point field <a class="indexterm" id="id381"/>with width <code class="literal">5</code> and a precision of <code class="literal">2</code> digits. The <a class="indexterm" id="id382"/>result is the following figure:</p><div class="mediaobject"><img alt="Solving equations and finding optimal values" src="graphics/8341OS_05_04.jpg"/></div></div><div class="section" title="Calculus and differential equations"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec24"/>Calculus and differential equations</h2></div></div></div><p>As an example of a <a class="indexterm" id="id383"/>calculus computation, we will show you how to compute the volume of a solid of revolution. The solid is created by rotating the curve displayed in the following figure around the <span class="emphasis"><em>y</em></span>-axis:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_05.jpg"/></div><p>This curve is plotted with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def make_gen(a,b):</strong></span>
<span class="strong"><strong>    def gen_func(y):</strong></span>
<span class="strong"><strong>        return a/pi * arccos(2.0 * y / b - 1.0)</strong></span>
<span class="strong"><strong>    return gen_func</strong></span>
<span class="strong"><strong>a = 5.</strong></span>
<span class="strong"><strong>b = 4.</strong></span>
<span class="strong"><strong>gen = make_gen(a,b)</strong></span>
<span class="strong"><strong>x = linspace(0,b,200)</strong></span>
<span class="strong"><strong>y = gen(x)</strong></span>
<span class="strong"><strong>subplot(111, aspect='equal')</strong></span>
<span class="strong"><strong>plot(x,y,lw=2)</strong></span>
</pre></div><p>The curve is essentially a stretched and transposed inverse cosine function, as defined in the <code class="literal">make_gen()</code> function. It depends on two parameters, <code class="literal">a</code> and <code class="literal">b</code>, that specify its height and length, respectively. The <a class="indexterm" id="id384"/>
<code class="literal">make_gen()</code> function is a function factory that returns a function that actually computes values in the curve. The actual function defining the <a class="indexterm" id="id385"/>curve is called <code class="literal">gen()</code> (for <span class="emphasis"><em>generator</em></span>), so this is the function that is plotted.</p><p>When this curve is rotated <a class="indexterm" id="id386"/>around the vertical axis, we obtain the solid plotted as follows:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_06.jpg"/></div><p>The preceding <a class="indexterm" id="id387"/>figure, of course, was generated with IPython using the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from mpl_toolkits.mplot3d import Axes3D</strong></span>
<span class="strong"><strong>na = 50</strong></span>
<span class="strong"><strong>nr = 50</strong></span>
<span class="strong"><strong>avalues = linspace(0, 2*pi, na, endpoint=False)</strong></span>
<span class="strong"><strong>rvalues = linspace(b/nr, b, nr)</strong></span>
<span class="strong"><strong>avalues_r = repeat(avalues[...,newaxis], nr, axis=1)</strong></span>
<span class="strong"><strong>xvalues = append(0, (rvalues*cos(avalues_r)).flatten())</strong></span>
<span class="strong"><strong>yvalues = append(0, (rvalues*sin(avalues_r)).flatten())</strong></span>
<span class="strong"><strong>zvalues = gen(sqrt(xvalues*xvalues+yvalues*yvalues))</strong></span>
<span class="strong"><strong>fig = plt.figure()</strong></span>
<span class="strong"><strong>ax = fig.gca(projection='3d')</strong></span>
<span class="strong"><strong>ax.plot_trisurf(xvalues, yvalues, zvalues, </strong></span>
<span class="strong"><strong>                color='Cyan',alpha=0.65,linewidth=0.)</strong></span>
</pre></div><p>The key function in this code is the call to <code class="literal">plot_trisurf()</code> in the last line. This function accepts three <code class="literal">NumPy</code> arrays, <code class="literal">xvalues</code>, <code class="literal">yvalues</code>, and <code class="literal">zvalues</code>, specifying the coordinates of the points on the surface. The arrays, <code class="literal">xvalues</code> and <code class="literal">yvalues</code> define points in a succession of concentric circles, as shown in the following image:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_07.jpg"/></div><p>The value of the <code class="literal">z</code> coordinate is obtained by computing <code class="literal">gen(sqrt(x*x+y*y))</code> at each of these points, which has the effect of assigning the same height in the 3D plot to all points of each concentric circle.</p><p>To compute the volume <a class="indexterm" id="id388"/>of the solid, we use the method of cylindrical shells. An explanation of how the method works is beyond the scope of this book, but it boils down to computing an integral, as shown in the following formula:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_08.jpg"/></div><p>In this formula, the <span class="emphasis"><em>f(x)</em></span> function represents the curve being rotated around the <code class="literal">y</code>-axis. To compute this integral, we use the <code class="literal">scipy.integrate</code> package. We use the <code class="literal">quad()</code> function, which is appropriate for the generic integration of functions that do not have singularities. The following is the code for this formula:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import scipy.integrate as integrate</strong></span>
<span class="strong"><strong>int_func  = lambda x: 2 * pi * x * gen(x)</strong></span>
<span class="strong"><strong>integrate.quad(int_func, 0, b)</strong></span>
</pre></div><p>After importing the <code class="literal">integrate</code> module, we define the function to be integrated. Note that we use the <code class="literal">lambda</code> syntax since this is a one-line calculation. Finally, we call <code class="literal">quad()</code> to perform the integration. The arguments to the call are the function being integrated and the bounds of integration (from <code class="literal">0</code> to <code class="literal">b</code> in this case). The following is the output of the preceding <a class="indexterm" id="id389"/>lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(94.24777961000055, 1.440860870616234e-07)</strong></span>
</pre></div><p>The first number is the value of the integral, and the second one is an error estimate.</p><p>In the next example, we consider <span class="emphasis"><em>Newton's canon</em></span>, a thought experiment at the very root of modern physics and calculus. The situation is illustrated in the following image, which is an engraving from the book by Sir Isaac Newton, <span class="emphasis"><em>A Treatise of The System of the World</em></span>:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_14.jpg"/></div><p>Newton asks us to imagine a canon sitting at the top of a very high mountain. If the canon shoots a projectile, it will fly for a while and eventually hit the ground. The larger the initial velocity of the projectile, the further away it will hit the ground. Let's imagine that we can shoot the projectile as fast as we want, and that there is no air resistance. Then, as the initial velocity increases, eventually the projectile will go around the earth and, if the canon is removed quickly <a class="indexterm" id="id390"/>enough, then the projectile will continue its orbit around Earth forever. Newton used this example to explain how the moon could revolve around Earth without ever falling under the action of gravity alone.</p><p>To model this situation, we need to use Newton's law of gravitation as a system of differential equations:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_09.jpg"/></div><p>We will not attempt to explain how these formulae were obtained, with the only important point for us being that there are four state variables, with the first two representing the position of the projectile and the last two representing its velocity vector. Since the movement takes place in a plane through the center of Earth, only two position variables are needed. <span class="emphasis"><em>G</em></span> and <span class="emphasis"><em>M</em></span> are constants representing Newton's universal gravitational constant and the mass of Earth, respectively. The mass of the projectile does not appear, since the gravitational mass is exactly cancelled by the inertial mass.</p><p>The first step to solve this <a class="indexterm" id="id391"/>using <code class="literal">SciPy</code> is to define this set of differential equations, which is done with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>M = 5.9726E24</strong></span>
<span class="strong"><strong>G = 6.67384E-11</strong></span>
<span class="strong"><strong>C = G * M</strong></span>
<span class="strong"><strong>def ode_func(xvec, t):</strong></span>
<span class="strong"><strong>    x1, x2, v1, v2 = xvec</strong></span>
<span class="strong"><strong>    d = (x1 * x1 + x2 * x2) ** 1.5</strong></span>
<span class="strong"><strong>    return array([v1, v2, -C * x1 / d, -C * x2 / d ])</strong></span>
</pre></div><p>All that we need to do is define a function that computes the right-hand side of the system of differential equations. We start by defining the constants, <code class="literal">M</code> and <code class="literal">G</code> (using SI units), and the auxiliary constant <code class="literal">C</code>, since <code class="literal">G</code> and <code class="literal">M</code> only appear in the equations through their product. The system is represented by the <code class="literal">ode_func()</code> function. This function must accept at least two parameters: a <code class="literal">NumPy</code> array, <code class="literal">xvec</code>, and a floating-point value, <code class="literal">t</code>. In our case, <code class="literal">xvec</code> is a four-dimensional vector since there are four state variables in our system. The variable, <code class="literal">t</code>, is not used in the system since there are no external forces (as there would be if we were launching a rocket instead of shooting a projectile). However, it must still be listed as an input parameter.</p><p>Inside <code class="literal">ode_func()</code>, we first extract the elements of the <code class="literal">xvec</code> vector with the assignment, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x1, x2, v1, v2 = xvec</strong></span>
</pre></div><p>This is not strictly necessary but improves readability. We then compute the auxiliary quantity, <code class="literal">d</code> (this is the denominator of the last two equations). Finally, the output array is computed according to the formulae in the system. Note that no derivatives are computed since all information that is needed by the solver is contained in the right-hand side of the equations.</p><p>We are now ready to solve the <a class="indexterm" id="id392"/>system of differential equations using the following lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import scipy.integrate as integrate</strong></span>
<span class="strong"><strong>earth_radius = 6.371E6</strong></span>
<span class="strong"><strong>v0 = 8500</strong></span>
<span class="strong"><strong>h0 = 5E5</strong></span>
<span class="strong"><strong>ic = array([0.0, earth_radius + h0, v0, 0.0])</strong></span>
<span class="strong"><strong>tmax = 8700.0</strong></span>
<span class="strong"><strong>dt = 10.0</strong></span>
<span class="strong"><strong>tvalues = arange(0.0, tmax, dt)</strong></span>
<span class="strong"><strong>xsol = integrate.odeint(ode_func, ic, tvalues)</strong></span>
</pre></div><p>The first line of the preceding code imports the <code class="literal">integrate</code> module, where the differential equations are solved. We then need to specify the initial position and velocity of the projectile. We assume that the canon is at the North Pole, atop a tower of 50,000 m (although this is clearly unrealistic, we just choose such a large value to enhance the visibility of the orbit). Since Earth is not a perfect sphere, we use an average value for the radius. The initial velocity is set to <code class="literal">8500</code> m/s.</p><p>The initial conditions are stored in a <code class="literal">NumPy</code> array with the following assignment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ic = array([0.0, earth_radius + h0, v0, 0.0])</strong></span>
</pre></div><p>The next step is to define the initial time (zero in our case) and the array of times at which the solution is sought. This is done with the following three lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tmax = 8650.0</strong></span>
<span class="strong"><strong>dt = 60.0</strong></span>
<span class="strong"><strong>tvalues = arange(0.0, tmax, dt)</strong></span>
</pre></div><p>We first define <code class="literal">tmax</code> as being the duration of the simulation (in seconds). The variable <code class="literal">dt</code> stores the time intervals at which we want to record the solution. In the preceding code, the solution will be recorded every 60 seconds for 8,650 seconds. The final time was chosen by trial-and-error to correspond, approximately, to one orbit of the projectile.</p><p>We are now ready to compute the solution, which is done with a call to the <code class="literal">odeint()</code> function. The solution is stored in the vector, <code class="literal">xsol</code>, which has one row for each time at which the solution is computed. To see the first few rows of the vector, we can run the following command:</p><div class="informalexample"><pre class="programlisting">xsol[:10]</pre></div><p>The preceding command <a class="indexterm" id="id393"/>produces the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>array([[  0.00000000e+00,   6.87100000e+06,   8.50000000e+03,</strong></span>
<span class="strong"><strong>          0.00000000e+00],</strong></span>
<span class="strong"><strong>       [  5.09624253e+05,   6.85581217e+06,   8.48122162e+03,</strong></span>
<span class="strong"><strong>         -5.05935282e+02],</strong></span>
<span class="strong"><strong>       [  1.01700042e+06,   6.81036510e+06,   8.42515172e+03,</strong></span>
<span class="strong"><strong>         -1.00800330e+03],</strong></span>
<span class="strong"><strong>       [  1.51991202e+06,   6.73500470e+06,   8.33257580e+03,</strong></span>
<span class="strong"><strong>         -1.50243025e+03],</strong></span>
<span class="strong"><strong>       [  2.01620463e+06,   6.63029830e+06,   8.20477026e+03,</strong></span>
<span class="strong"><strong>         -1.98562415e+03],</strong></span>
<span class="strong"><strong>       [  2.50381401e+06,   6.49702131e+06,   8.04345585e+03,</strong></span>
<span class="strong"><strong>         -2.45425372e+03],</strong></span>
<span class="strong"><strong>       [  2.98079103e+06,   6.33613950e+06,   7.85073707e+03,</strong></span>
<span class="strong"><strong>         -2.90531389e+03],</strong></span>
<span class="strong"><strong>       [  3.44532256e+06,   6.14878788e+06,   7.62903174e+03,</strong></span>
<span class="strong"><strong>         -3.33617549e+03],</strong></span>
<span class="strong"><strong>       [  3.89574810e+06,   5.93624710e+06,   7.38099497e+03,</strong></span>
<span class="strong"><strong>         -3.74461812e+03],</strong></span>
<span class="strong"><strong>       [  4.33057158e+06,   5.69991830e+06,   7.10944180e+03,</strong></span>
<span class="strong"><strong>         -4.12884566e+03]])</strong></span>
</pre></div><p>These values are the position and velocity vectors of the projectile from time <code class="literal">0</code> s to time <code class="literal">360</code> s at intervals of <code class="literal">60</code> s.</p><p>We definitely want to produce a plot of the orbit. This can be done by running the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>subplot(111, aspect='equal')</strong></span>
<span class="strong"><strong>axis(earth_radius * array([-1.5, 1.5, -1.8, 1.2]))</strong></span>
<span class="strong"><strong>earth = Circle((0.,0.), </strong></span>
<span class="strong"><strong>                earth_radius, </strong></span>
<span class="strong"><strong>                ec='Black', fc='Brown', lw=3)</strong></span>
<span class="strong"><strong>gca().add_artist(earth)</strong></span>
<span class="strong"><strong>plot(xsol[:,0], xsol[:,1], lw=2, color='DarkBlue')</strong></span>
<span class="strong"><strong>title('Newton\'s Canon, $v_0={}$ m/s'.format(v0))</strong></span>
</pre></div><p>We want to use the same scale in both axes since both axes represent spatial coordinates in meters. This is done in the first line of code. The second line sets the axis limits so that the plot of the orbit fits comfortably in the picture.</p><p>Then, we plot a circle to represent Earth using the following lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>earth = Circle((0.,0.), </strong></span>
<span class="strong"><strong>               earth_radius, </strong></span>
<span class="strong"><strong>               ec='Black', fc='Brown', lw=3)</strong></span>
<span class="strong"><strong>gca().add_artist(earth)</strong></span>
</pre></div><p>We have not emphasized using <code class="literal">Artist</code> objects in our plots since these are at a lower level than is usually required for scientific plots. Here, we are constructing a <code class="literal">Circle</code> object by giving its center, radius, and appearance options: a black edge color, brown face color, and a line width equal to 3. The second line of code shows how to add the <code class="literal">Circle</code> object to the plot.</p><p>After drawing Earth, we <a class="indexterm" id="id394"/>plot the orbit using the following line of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>plot(xsol[:,0], xsol[:,1], lw=2, color='DarkBlue')</strong></span>
</pre></div><p>This is a standard call to the <code class="literal">plot()</code> function. Note that we plot only the first two columns of the <code class="literal">xsol</code> array since these represent the position of the projectile (recall that the other two represent the velocity). The following image is what we get as the output:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_10.jpg"/></div><p>A numerical solution for differential equations is a sophisticated topic, and a complete treatment of the issue is beyond the scope of this book, but we will present the full form of the <code class="literal">odeint()</code> function and <a class="indexterm" id="id395"/>comment on some of the options. The <code class="literal">odeint()</code> function is a Python wrapper on the <code class="literal">lsoda</code> solver from <code class="literal">ODEPACK</code>, the Fortran library. Detailed information about the solver can be found at <a class="ulink" href="http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html">http://people.sc.fsu.edu/~jburkardt/f77_src/odepack/odepack.html</a>
</p><p>The following lines of code <a class="indexterm" id="id396"/>are the complete signature of <code class="literal">odeint()</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>odeint(ode_func, x0, tvalues, args=(), Dfun=None, col_deriv=0,</strong></span>
<span class="strong"><strong>       full_output=0, ml=None, mu=None, rtol=None, atol=None,</strong></span>
<span class="strong"><strong>       tcrit=None, h0=0.0, hmax=0.0, hmin=0.0,ixpr=0, mxstep=0,</strong></span>
<span class="strong"><strong>       mxhnil=0, mxordn=12, mxords=5, printmessg=0)</strong></span>
</pre></div><p>The arguments, <code class="literal">ode_func</code>, <code class="literal">x0</code> and <code class="literal">tvalues</code>, have already been discussed. The argument <code class="literal">args</code> allows us to pass extra parameters to the equation being solved. This is a very common situation, which is illustrated in the next example. In this case, the function defining the system must have the following signature:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ode_func(x, t, p1, p2, … , pn)</strong></span>
</pre></div><p>Here, <code class="literal">p1</code>,<code class="literal"> p2</code>, and <code class="literal">pn</code> are extra parameters. These parameters are fixed for a single solution but can change from one solution to the other (they are normally used to represent the environment). The tuple passed to <code class="literal">args</code> must have a length exactly equal to the number of parameters that <code class="literal">ode_func()</code> requires.</p><p>The following is a partial list of the meaning of the most common options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Dfun</code> is a function <a class="indexterm" id="id397"/>that computes the Jacobian of the system. This may improve the accuracy of the solution.</li><li class="listitem" style="list-style-type: disc">Whether the Jacobian has the derivatives of the right-hand side along its columns (<code class="literal">True</code>, faster) or rows (<code class="literal">False</code>) is specified by <code class="literal">col_deriv</code>.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">full_output</code> is set to <code class="literal">True</code>, the output contains diagnostics about the solution process. This may be useful if errors accumulate and the solution process is not successfully completed.</li></ul></div><p>In the last example in this section, we present the Lorenz oscillator, a simplified model for atmospheric convection, and a famous equation that displays chaotic behavior for certain values of the parameters. We will also use this example to demonstrate how to plot solutions in three dimensions.</p><p>The Lorenz system is defined by the following equations:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_11.jpg"/></div><p>We start by defining a Python function representing the system, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def ode_func(xvec, t, sigma, rho, beta):</strong></span>
<span class="strong"><strong>    x, y, z = xvec</strong></span>
<span class="strong"><strong>    return array([sigma * (y - x),</strong></span>
<span class="strong"><strong>                  x * (rho - z) - y,</strong></span>
<span class="strong"><strong>                  x * y - beta * z ])</strong></span>
</pre></div><p>The only difference between this system and the previous one is the presence of the parameters <code class="literal">sigma</code>, <code class="literal">rho</code>, and <code class="literal">beta</code>. Note that they are just added as extra arguments to <code class="literal">ode_func()</code>. Solving the equation is almost the same as solving the previous example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tmax = 50</strong></span>
<span class="strong"><strong>tdelta = 0.005</strong></span>
<span class="strong"><strong>tvalues = arange(0, tmax, tdelta) </strong></span>
<span class="strong"><strong>ic = array([0.0, 1.0, 0.0])</strong></span>
<span class="strong"><strong>sol = integrate.odeint(ode_func, ic, tvalues, </strong></span>
<span class="strong"><strong>                       args=(10., 28., 8./3.))</strong></span>
</pre></div><p>We define the array of <a class="indexterm" id="id398"/>times and the initial condition just as we did in the previous example. Notice that since this is a three-dimensional problem, there are initial conditions in an array with three components. Then comes the call to <code class="literal">odeint()</code>. The <a class="indexterm" id="id399"/>call now has an extra argument:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>args=(10., 28., 8./3.)</strong></span>
</pre></div><p>This sets <code class="literal">sigma</code>, <code class="literal">rho</code>, and <code class="literal">beta</code>, respectively, to the values <code class="literal">10</code>, <code class="literal">28</code>, and <code class="literal">8/3</code>. These are values that are known to correspond to chaotic solutions.</p><p>The solution can then be plotted with the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from mpl_toolkits.mplot3d import Axes3D</strong></span>
<span class="strong"><strong>fig = plt.figure(figsize=(8,8))</strong></span>
<span class="strong"><strong>from mpl_toolkits.mplot3d import Axes3D</strong></span>
<span class="strong"><strong>fig = plt.figure(figsize=(8,8))</strong></span>
<span class="strong"><strong>ax = fig.add_subplot(111, projection='3d')</strong></span>
<span class="strong"><strong>x, y, z = sol.transpose() </strong></span>
<span class="strong"><strong>ax.plot(x, y, z, lw=0.5, color='DarkBlue')</strong></span>
<span class="strong"><strong>ax.set_xlabel('$x$')</strong></span>
<span class="strong"><strong>ax.set_ylabel('$y$')</strong></span>
<span class="strong"><strong>ax.set_zlabel('$z$')</strong></span>
</pre></div><p>The first three lines of code set up the axes for three-dimensional plotting. The next line extracts the data in a format suitable for plotting:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>x, y, z = sol.transpose()</strong></span>
</pre></div><p>This code illustrates a common pattern. The array <code class="literal">sol</code> contains the coordinates of the solutions along its columns, so we transpose the array so that the data is along the rows of the array, and then assign each row to one of the variables <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>.</p><p>The other lines of <a class="indexterm" id="id400"/>code are pretty straightforward: we call the <code class="literal">plot()</code> function and then add labels to the axes. The following is the figure that we get as the output:</p><div class="mediaobject"><img alt="Calculus and differential equations" src="graphics/8341OS_05_12.jpg"/></div><p>The preceding image is <a class="indexterm" id="id401"/>known as the classical Lorenz butterfly, a striking example of a strange attractor.</p></div></div>
<div class="section" title="Accelerating computations with Numba and NumbaPro"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Accelerating computations with Numba and NumbaPro</h1></div></div></div><p>In this <a class="indexterm" id="id402"/>section, we will discuss <code class="literal">Numba</code> and <code class="literal">NumbaPro</code>, two very exciting libraries to accelerate the <code class="literal">NumPy</code> code. <code class="literal">Numba</code> and <code class="literal">NumbaPro</code> <a class="indexterm" id="id403"/>were created by <span class="emphasis"><em>Continuum Analytics</em></span>, the same company that produces the Anaconda distribution. <code class="literal">Numba</code> is part of the <a class="indexterm" id="id404"/>standard Anaconda distribution, but <code class="literal">NumbaPro</code> is a commercial product that must be purchased separately as part of the <a class="indexterm" id="id405"/>
<code class="literal">Accelerate</code> package. However, <code class="literal">NumbaPro</code> can be downloaded for a free trial period.</p><p>These libraries are unique in that they allow the acceleration of code with the addition of a few lines of code. As the first example, let's consider the following lines of code to multiply two matrices:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>def matrix_multiply(A, B):</strong></span>
<span class="strong"><strong>    m, n = A.shape</strong></span>
<span class="strong"><strong>    n, r = B.shape</strong></span>
<span class="strong"><strong>    C = zeros((m, r), float64)</strong></span>
<span class="strong"><strong>    for i in range(m):</strong></span>
<span class="strong"><strong>        for j in range(r):</strong></span>
<span class="strong"><strong>            acc = 0</strong></span>
<span class="strong"><strong>            for k in range(n):</strong></span>
<span class="strong"><strong>                acc += A[i, k] * B[k, j]</strong></span>
<span class="strong"><strong>            C[i, j] = acc</strong></span>
<span class="strong"><strong>    return C</strong></span>
</pre></div><p>The preceding code uses the straightforward definition of matrix multiplication and looks very much like code that would be written if we were implementing the algorithm in C. It is not Python-like and definitely not optimized. (In a real-world situation, one would simply use the <code class="literal">NumPy</code> built-in matrix multiplication.) Note, in particular, that the dimensions of the matrices are not checked: it is assumed that the number of columns of <code class="literal">A</code> is equal to the number of rows of <code class="literal">B</code>.</p><p>Let's first try the computation with small matrices, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>A = array([[1,2,0],[1,-3,4],[0,-2,1],[3,7,-4]], dtype=float64)</strong></span>
<span class="strong"><strong>B = array([[3,4],[-2,0],[2,4]], dtype = float64)</strong></span>
<span class="strong"><strong>C = matrix_multiply(A, B)</strong></span>
<span class="strong"><strong>print A</strong></span>
<span class="strong"><strong>print B</strong></span>
<span class="strong"><strong>print C</strong></span>
</pre></div><p>We start by defining the matrices <code class="literal">A</code> and <code class="literal">B</code> (note that the dimensions are compatible for multiplication). As in all examples in this section, we are careful to include a data type specification (this may improve optimization). Then, we simply call <code class="literal">matrix_multiply</code>, store the result <a class="indexterm" id="id406"/>in the array <code class="literal">C</code>, and print the three matrices. The result is the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[[  1.   2.   0.]</strong></span>
<span class="strong"><strong> [  1.  -3.   4.]</strong></span>
<span class="strong"><strong> [  0.  -2.   1.]</strong></span>
<span class="strong"><strong> [  3.   7.  -4.]]</strong></span>
<span class="strong"><strong>[[  3    4]</strong></span>
<span class="strong"><strong> [ -2    0]</strong></span>
<span class="strong"><strong> [  2    4]]</strong></span>
<span class="strong"><strong>[[ -1.   4.]</strong></span>
<span class="strong"><strong> [  17. 20.]</strong></span>
<span class="strong"><strong> [  6.   4.]</strong></span>
<span class="strong"><strong> [ -13. -4.]]</strong></span>
</pre></div><p>You can verify that the algorithm is correct by manually checking a few entries. Alternatively, we <a class="indexterm" id="id407"/>can check whether the result agrees <a class="indexterm" id="id408"/>with the built-in matrix multiplication, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>C - A.dot(B)</strong></span>
<span class="strong"><strong>array([[ 0. ,  0.],</strong></span>
<span class="strong"><strong>       [ 0. ,  0.],</strong></span>
<span class="strong"><strong>       [ 0. ,  0.],</strong></span>
<span class="strong"><strong>       [ 0. ,  0.]])</strong></span>
</pre></div><p>Everything seems <a class="indexterm" id="id409"/>to be fine. Now, we want to define some larger random matrices, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>n = 100</strong></span>
<span class="strong"><strong>A = rand(n, n)</strong></span>
<span class="strong"><strong>B = rand(n, n)</strong></span>
</pre></div><p>In a 64-bit architecture, the preceding lines of code will automatically produce matrices of 64-bit floats. Next, we multiply the matrices and time the result as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%%timeit</strong></span>
<span class="strong"><strong>C = matrix_multiply(A, B)</strong></span>
</pre></div><p>The output of the preceding computation is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1 loops, best of 3: 472 ms per loop</strong></span>
</pre></div><p>The timing results will, of course, differ depending on the machine running the code. This example was run on an Intel Core i7 processor at 3.5 GHz with 16 GB of memory running a Microsoft Windows 7, 64-bit operating system.</p><p>Let's now see how we can quickly optimize this function. First, load the <code class="literal">jit</code> function from the <code class="literal">Numba</code> module, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from numba import jit</strong></span>
</pre></div><p>Then, define the <a class="indexterm" id="id410"/>function with the <code class="literal">@jit</code> decorator <a class="indexterm" id="id411"/>preceding it, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@jit</strong></span>
<span class="strong"><strong>def matrix_multiply_jit(A, B):</strong></span>
<span class="strong"><strong>    m, n = A.shape</strong></span>
<span class="strong"><strong>    n, r = B.shape</strong></span>
<span class="strong"><strong>    C = zeros((m, r), float64)</strong></span>
<span class="strong"><strong>    for i in range(m):</strong></span>
<span class="strong"><strong>        for j in range(r):</strong></span>
<span class="strong"><strong>            acc = 0</strong></span>
<span class="strong"><strong>            for k in range(n):</strong></span>
<span class="strong"><strong>                acc += A[i, k] * B[k, j]</strong></span>
<span class="strong"><strong>            C[i, j] = acc</strong></span>
<span class="strong"><strong>    return C</strong></span>
</pre></div><p>Note that the only change to the code is the addition of the decorator. (We also changed the name of the function to avoid confusion, but this is not necessary.) Decorators are an advanced Python <a class="indexterm" id="id412"/>topic, but we do not need to go <a class="indexterm" id="id413"/>into the details of how they work. More <a class="indexterm" id="id414"/>information about decorators is available in the excellent blog postings by Simeon Franklin at <a class="ulink" href="http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/">http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/</a>.</p><p>Let's now time our code, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%%timeit</strong></span>
<span class="strong"><strong>C = matrix_multiply_jit(A, B)</strong></span>
</pre></div><p>The following is the resultant output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>1000 loops, best of 3: 1.8 ms per loop</strong></span>
</pre></div><p>This is a 260-fold improvement with a single line of code! You should keep things in perspective here since this kind of acceleration cannot be expected for generic code. Remember that we wrote our code purposefully in a way that does not use the already-optimized functions from <code class="literal">NumPy</code>. For the sake of comparison and full disclosure, let's compare this with the built-in <code class="literal">dot()</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%%timeit</strong></span>
<span class="strong"><strong>C = A.dot(B)</strong></span>
</pre></div><p>The resultant output is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>10000 loops, best of 3: 28.6 µs per loop</strong></span>
</pre></div><p>So, even with acceleration, our function cannot compete with built-in <code class="literal">NumPy</code>. We emphasize again that the goal of this section is to present an overview of acceleration techniques and not delve deeply into sophisticated optimization methods.</p><p>It is worth having <a class="indexterm" id="id415"/>some understanding of how the <code class="literal">@jit</code> decorator works. When a function decorated by <code class="literal">@jit</code> is called, the library attempts to infer the data type of the arguments and return value, and on the fly produces a compiled <a class="indexterm" id="id416"/>version of the function and then calls it. The result is a function call that is comparable to code written in C.</p><p>Instead of letting the <a class="indexterm" id="id417"/>type of arguments and return value be inferred, it is possible to specify the data types, which may result in improved <a class="indexterm" id="id418"/>performance. The following table consists of the data types supported and the abbreviations used by <code class="literal">Numba</code>:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Abbreviation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">boolean  </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">b1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">bool_ </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">b1 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">byte </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">u1 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uint8 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">u1 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uint16 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">u2 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uint32 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">u4 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uint64 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">u8 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">char </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">i1 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">int8 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">i1 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">int16 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">i2 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">int32 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">i4 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">int64 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">i8 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float_ </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">f4 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float32 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">f4 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">double </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">f8 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">float64 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">f8 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">complex64 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">c8 </code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">complex128 </code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">c16 </code>
</p>
</td></tr></tbody></table></div><p>These names are all defined in the <code class="literal">Numba</code> module. For example, to define a function that adds two floating-point values, we use the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from numba import jit, f8</strong></span>
<span class="strong"><strong>@jit (f8(f8,f8))</strong></span>
<span class="strong"><strong>def my_sum(a, b):</strong></span>
<span class="strong"><strong>    return a + b</strong></span>
</pre></div><p>Note the decorator syntax, which is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@jit (f8(f8,f8))</strong></span>
</pre></div><p>This specifies a <a class="indexterm" id="id419"/>function that takes two <code class="literal">float64</code> arguments and returns a <code class="literal">float64</code> value. The function is then called, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>my_sum(3.5, 6.9)</strong></span>
</pre></div><p>This produces the <a class="indexterm" id="id420"/>expected result. However, if we try something like the following code, we get an error:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>a = array([1.4, 2.0])</strong></span>
<span class="strong"><strong>b = array([2.3, 5,2])</strong></span>
<span class="strong"><strong>my_sum(a,b)</strong></span>
</pre></div><p>It is, however, possible to use arrays with the <code class="literal">@jit</code> decorator. To define a function that adds two <a class="indexterm" id="id421"/>one-dimensional arrays, one would <a class="indexterm" id="id422"/>use the following lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@jit (f8[:](f8[:],f8[:]))</strong></span>
<span class="strong"><strong>def vector_sum(a, b):</strong></span>
<span class="strong"><strong>    return a + b</strong></span>
</pre></div><p>Note how a vector is specified. A two-dimensional array is denoted by <code class="literal">f8[:,:]</code>, a three-dimensional array by <code class="literal">f8[:,:,:]</code>, and so on.</p><p>
<code class="literal">NumbaPro</code> is the commercial version of <code class="literal">Numba</code> and adds several enhancements. We will focus on parallel <a class="indexterm" id="id423"/>processing using the <span class="strong"><strong>Graphics Processing Unit</strong></span> (<span class="strong"><strong>GPU</strong></span>) as an example of an exciting new technology that is made easily available in a notebook.</p><p>To run the examples that follow, the reader must have <code class="literal">NumbaPro</code>, a <code class="literal">CUDA</code>-compatible GPU (henceforth called the "device"), and the latest <code class="literal">CUDA</code>-compatible driver.</p><p>A list of <code class="literal">CUDA</code>-compatible <a class="indexterm" id="id424"/>devices can be found at <a class="ulink" href="https://developer.nvidia.com/cuda-gpus">https://developer.nvidia.com/cuda-gpus</a>. After verifying that you have a compatible device, download and install the latest version of the <code class="literal">CUDA SDK</code> from <a class="ulink" href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a> for the appropriate platform. The <code class="literal">CUDA</code> toolkit comes with several examples that you can use to test the installation.</p><p>The <code class="literal">NumbaPro</code> <a class="indexterm" id="id425"/>download is available at <a class="ulink" href="https://store.continuum.io/cshop/accelerate/">https://store.continuum.io/cshop/accelerate/</a>. Download and install the <code class="literal">Accelerate</code> library.</p><p>To test the setup, start an IPython notebook and run the following in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import numbapro</strong></span>
<span class="strong"><strong>numbapro.check_cuda()</strong></span>
</pre></div><p>If everything is fine, this will print a list of the <code class="literal">CUDA</code> libraries installed by Anaconda as well as a list of the <code class="literal">CUDA</code>-compatible devices available in your system. You will also see a <code class="literal">PASSED</code> message at the end of the display.</p><p>Even though <code class="literal">CUDA</code> <a class="indexterm" id="id426"/>programming is a relatively easy path to massive parallelism, there are still some concepts that have to be mastered before we <a class="indexterm" id="id427"/>can tackle our first <code class="literal">CUDA</code> program. We will outline the basics of the architecture here, discussing only enough to run the <a class="indexterm" id="id428"/>examples that follow. For a complete specification, see the <span class="strong"><strong>CUDA Programming Guide</strong></span>, available at <a class="ulink" href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#programming-model</a>.</p><p>GPUs were originally designed to process rendering operations with greater speed than the computer's CPU <a class="indexterm" id="id429"/>is capable of. This processing <a class="indexterm" id="id430"/>acceleration is achieved, in large measure, by massively parallelizing the graphical operations required by the rendering pipeline.</p><p>A <code class="literal">CUDA</code>-compatible <a class="indexterm" id="id431"/>GPU consists of an array of <span class="strong"><strong>Streaming Multiprocessors</strong></span> (<span class="strong"><strong>SMs</strong></span>). Each one of the SMs, by itself, cannot compete with current CPUs in terms of speed. However, the fact that many SMs can cooperate to solve a problem more than compensates for that. The SMs can also access memory that resides in the GPU, referred to as <span class="emphasis"><em>device memory</em></span>.</p><p>In <code class="literal">CUDA</code>, there is a strict separation between code that runs in the CPU and code that runs in the device (the GPU). One particular restriction is that while CPU code can only access regular computer memory, device code can only access device memory. Code that runs in the device is specified in a function called a <span class="emphasis"><em>kernel</em></span>. The kernel is compiled into a low-level language that is understood by the SMs and runs into each SM asynchronously (meaning that each SM proceeds at its own pace unless special synchronization instructions are found). Thus, a simple computation in <code class="literal">CUDA</code> usually requires the following three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Transfer input data from the computer memory to the device memory.</li><li class="listitem">Launch the kernel in the device.</li><li class="listitem">Transfer output data from the device memory to the computer memory so that it is accessible to the CPU again.</li></ol></div><p>As you will see, the memory transfers are made transparent by Python <code class="literal">CUDA</code>. (There is still the possibility to control it programmatically if needed.)</p><p>The kernel is launched <a class="indexterm" id="id432"/>simultaneously in an array of SMs, and each thread proceeds independently with the computation. Each SM can run several threads in parallel and can access all the device's memory. (The architecture is more complicated, and there are other kinds of memory available that will not be discussed here.) In the simplest case, each thread will access only a few memory areas, each containing a 64-bit floating value, and the memory accessed by a thread is never accessed by any other thread. So, there is no need for synchronization. In more complex problems, synchronization may be a major issue.</p><p>The set of threads being <a class="indexterm" id="id433"/>run features a two-level array structure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Threads are <a class="indexterm" id="id434"/>organized in <span class="strong"><strong>blocks</strong></span>. Each block <a class="indexterm" id="id435"/>is an array of threads with up to <code class="literal">3</code> dimensions The dimensions of a block are stored in a variable called <code class="literal">blockDim</code>. Threads <a class="indexterm" id="id436"/>in a block are identified by the variable, <code class="literal">threadIdx</code>. This is a structure with three integer fields: <code class="literal">threadIdx.x</code>, <code class="literal">threadIdx.y</code>, and <code class="literal">threadIdx.z</code>. These fields uniquely identify each thread in the block.</li><li class="listitem" style="list-style-type: disc">Blocks are organized in a <a class="indexterm" id="id437"/><span class="strong"><strong>grid</strong></span>. The grid is an array of blocks with up to <code class="literal">3</code> dimensions. The dimensions of the grid are stored in a variable called <code class="literal">gridDim</code>. Blocks in a grid are identified by the variable, <code class="literal">gridIdx</code>. This is a structure with three integer fields: <code class="literal">gridIdx.x</code>, <code class="literal">gridIdx.y</code>, and <code class="literal">gridIdx.z</code>. These fields uniquely identify each block in the grid.</li></ul></div><p>An example of this <a class="indexterm" id="id438"/>organizational structure is given in the following figure:</p><div class="mediaobject"><img alt="Accelerating computations with Numba and NumbaPro" src="graphics/8341OS_05_13.jpg"/></div><p>In the preceding example, <code class="literal">gridDim</code> is <code class="literal">(2, 3, 1)</code> since there are two rows and three columns of blocks (and a single space dimension). All the blocks in the grid are one-dimensional, so <code class="literal">blockDim</code> is <code class="literal">(4, 1, 1)</code>. The third thread in the first block of the bottom row, for example, is <a class="indexterm" id="id439"/>identified by the following lines of code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>blockIdx.x=0, blockIdx.y=1, blockIdx.z=1</strong></span>
<span class="strong"><strong>threadIdx.x=2, threadIdx.y=1, threadIdx.z=1</strong></span>
</pre></div><p>At runtime, each individual thread has access to this identifying information.</p><p>A key point of the <a class="indexterm" id="id440"/>
<code class="literal">CUDA</code> architecture is the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All threads <a class="indexterm" id="id441"/>in the same block always run concurrently in a single SM until all threads in the block have terminated</li><li class="listitem" style="list-style-type: disc">Different blocks can run concurrently or serially depending on the availability of an SM to carry out the computation</li></ul></div><p>We are now ready to define the kernel using Python <code class="literal">CUDA</code>. We will write a function that computes the sum of two vectors in the GPU. Run the following code in a cell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from numbapro import cuda</strong></span>
<span class="strong"><strong>@cuda.jit('void(float64[:], float64[:], float64[:])')</strong></span>
<span class="strong"><strong>def sum(a, b, result):</strong></span>
<span class="strong"><strong>    i = cuda.threadIdx.x    </strong></span>
<span class="strong"><strong>    result[i] = a[i] + b[i]</strong></span>
</pre></div><p>We assume that there is only one block of threads, and each thread is responsible for adding the elements of the array at a single position. The array position that a thread is responsible for is identified by the value of <code class="literal">threadIdx.x</code>. Note that the kernel has no return value. We need to specify an array, <code class="literal">result</code>, to hold the return value of the computation.</p><p>Let's now see how this function is called. Note that the grid and block geometry is not defined in the kernel. (The kernel can obtain geometry information if necessary; more on that later.) This is done <a class="indexterm" id="id442"/>when the kernel is launched:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>a = array([1,2,3,4,5], dtype=float64)</strong></span>
<span class="strong"><strong>b = array([5,4,3,2,1], dtype=float64)</strong></span>
<span class="strong"><strong>result = array([0,0,0,0,0], dtype=float64)</strong></span>
<span class="strong"><strong>sum[1,5](a, b, result)</strong></span>
<span class="strong"><strong>print result</strong></span>
</pre></div><p>The preceding lines of <a class="indexterm" id="id443"/>code give the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[ 6.  6.  6.  6.  6.]</strong></span>
</pre></div><p>The main <a class="indexterm" id="id444"/>point in this code is the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sum[1,5](a, b, result)</strong></span>
</pre></div><p>The preceding line launches the kernel in a grid with <code class="literal">1</code> block, with <code class="literal">5</code> threads in the block. Both the grid and the <a class="indexterm" id="id445"/>blocks are one-dimensional. Let's now add larger vectors:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>n = 64</strong></span>
<span class="strong"><strong>a = arange(0,n,dtype=float64)</strong></span>
<span class="strong"><strong>b = arange(n,0,-1, dtype=float64)</strong></span>
<span class="strong"><strong>result = zeros(n,dtype=float64)</strong></span>
<span class="strong"><strong>sum[1,n](a, b, result)</strong></span>
<span class="strong"><strong>print result[:5]</strong></span>
</pre></div><p>The preceding lines of code are essentially the same as before but a little more generic in that the size of the array can be changed. What we want to do is increase the size of <code class="literal">n</code>. If you try a value such as <code class="literal">n=10000</code>, an error of type <code class="literal">CUDA_ERROR_INVALID_VALUE</code> occurs. The problem is that there is a hard limit on the number of threads that can be run by a single SM, that is, there is a limit to the number of threads that can be executed in a single block. To be able to handle large vectors, we need to modify the code so that it can handle multiple blocks. To this end, change the definition of the <code class="literal">sum()</code> function in the following way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from numbapro import cuda</strong></span>
<span class="strong"><strong>@cuda.jit('void(float64[:], float64[:], float64[:], int32)')</strong></span>
<span class="strong"><strong>def sum(a, b, result, n):</strong></span>
<span class="strong"><strong>    tx = cuda.threadIdx.x</strong></span>
<span class="strong"><strong>    bx = cuda.blockIdx.x</strong></span>
<span class="strong"><strong>    bsz = cuda.blockDim.x</strong></span>
<span class="strong"><strong>    i = tx + bx * bsz</strong></span>
<span class="strong"><strong>    if i &lt; n:</strong></span>
<span class="strong"><strong>        result[i] = a[i] + b[i]</strong></span>
</pre></div><p>The first thing to note is that we include an argument of type <code class="literal">int32</code> to hold the size of the arrays being <a class="indexterm" id="id446"/>added. The main point now is that threads in different blocks must address different areas of memory, so the computation of the index <code class="literal">i</code> associated to a thread is more complicated. Essentially, we must know the number of blocks that come before the current block, multiply that by the block dimension, and add the current thread index. Then, before adding the relevant memory positions, we <a class="indexterm" id="id447"/>check if the index is valid. This prevents the thread from accessing areas that are not part of the input/output arrays and <a class="indexterm" id="id448"/>is an essential check in more <a class="indexterm" id="id449"/>complex code. To test the code, run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>n = 100000</strong></span>
<span class="strong"><strong>a = arange(0,n,dtype=float64)</strong></span>
<span class="strong"><strong>b = arange(n,0,-1, dtype=float64)</strong></span>
<span class="strong"><strong>result = zeros(n,dtype=float64)</strong></span>
<span class="strong"><strong>sum[1000,64](a, b, result, n)</strong></span>
<span class="strong"><strong>print result[:5]</strong></span>
</pre></div><p>The preceding code should run without a hitch. Note that we are specifying a grid with <code class="literal">1000</code> blocks and <code class="literal">64</code> threads per block. The number of blocks in a grid is unlimited, the device being responsible for allocating the SMs in an optimal way. Note that the number of blocks must be large enough to cover the input/output arrays. In our case, this means <code class="literal">blockDim.x * gridDim.x &gt;= n</code>.</p><p>We are now ready to compute with large vectors. Try the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>n = 100000</strong></span>
<span class="strong"><strong>a = rand(n)</strong></span>
<span class="strong"><strong>b = rand(n)</strong></span>
<span class="strong"><strong>result = zeros(n, dtype=float64)</strong></span>
<span class="strong"><strong>bd = 10000</strong></span>
<span class="strong"><strong>gd = 64</strong></span>
<span class="strong"><strong>if bd * gd &lt; n:</strong></span>
<span class="strong"><strong>    print 'Block/grid dimensions too small'</strong></span>
<span class="strong"><strong>else:</strong></span>
<span class="strong"><strong>    sum[bd,gd](a, b, result, n)</strong></span>
<span class="strong"><strong>print result[:10]</strong></span>
</pre></div><p>The reader should <a class="indexterm" id="id450"/>experiment with different values of <a class="indexterm" id="id451"/>
<code class="literal">n</code>, <code class="literal">bd</code>, and <code class="literal">gd</code>. Remember that the maximum value of <code class="literal">gd</code> depends on the device in your computer. An interesting experiment <a class="indexterm" id="id452"/>is to check how the computation <a class="indexterm" id="id453"/>scales for larger values of <code class="literal">n</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we covered the use of advanced mathematical algorithms in <code class="literal">SciPy</code>, including solving equations and finding optimal values, integration, and differential equations. The chapter concluded with a discussion on using parallelization in the GPU to accelerate computations.</p></div></body></html>