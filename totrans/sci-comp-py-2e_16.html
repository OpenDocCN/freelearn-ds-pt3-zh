<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Symbolic Computations - SymPy
                </header>
            
            <article>
                
<p>In this chapter, we will give a brief introduction to using Python for symbolic computations. There is powerful software on the market for performing symbolic computations, for example, Maple™<span> </span>or Mathematica™. But sometimes, it might be favorable to make symbolic calculations in the language or framework you are used to. At this stage of the book, we assume that this language is Python, so we seek a tool in Python—the module SymPy.</p>
<p>A complete description of SymPy, if even possible, would fill an entire book, and that is not the purpose of this chapter. Instead, we will stake out a path into this tool by examining some guiding examples, giving a flavor of the potential of this tool as a complement to NumPy and SciPy.</p>
<h1 id="uuid-f1f3a9de-e206-4cbf-9dd8-c23950fe9e23">16.1 What are symbolic computations?</h1>
<p>All computations we did so far in this book were so-called numeric computations. These were a sequence of operations mainly on floating-point numbers. It is the nature of numeric computations that the result is an approximation of the exact solution.</p>
<p>Symbolic computations operate on formulas or symbols by transforming them as taught in algebra or calculus into other formulas. The last step of these transformations might then require that numbers are inserted and a numeric evaluation is performed.</p>
<p>We illustrate the difference by computing this definite integral:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4e541523-3e99-444e-8518-72719cb7a212.png" style="width:8.75em;height:2.92em;"/></div>
<p class="CDPAlignLeft CDPAlign">Symbolically this expression can be transformed by considering the primitive function of the integrand:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/136a2183-869c-4bea-9ed8-7e88338f8fb8.png" style="width:9.83em;height:2.83em;"/></div>
<p>We now obtain a formula for the definite integral by inserting the integral bounds:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b24fc4d8-f270-4bff-ab7b-f80f61ec4949.png" style="width:22.42em;height:2.92em;"/></div>
<p>This is called a closed-form expression for the integral. Very few mathematical problems have a solution that can be given in a closed-form expression. It is the exact value of the integral without any approximation. Also, no error is introduced by representing real numbers as floating-point numbers, which would otherwise introduce round-off errors.</p>
<p>Approximation and round-off come into play at the very last moment, when this expression needs to be evaluated. The square root and the<span> </span><em>arctan</em><span> </span>can only be evaluated approximately by numerical methods. Such an evaluation gives the final result up to a certain (often unknown) precision:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f38ec7ea-892d-4253-820e-8278a24de278.png" style="width:20.42em;height:3.25em;"/></p>
<p>On the other hand, numerical computation would directly approximate the definite integral by some approximation method, for example, Simpson's rule, and deliver a numeric result, often with an estimate of error. In Python, this is done by these commands:</p>
<pre>from scipy.integrate import quad<br/>quad(lambda x : 1/(x**2+x+1),a=0, b=4)   </pre>
<p>They return the value <sub><span><img class="fm-editor-equation" src="assets/5cb34e56-2413-4cbf-a974-1d7aa4b7d1d1.png" style="width:10.25em;height:1.00em;"/></span></sub><span> </span>and an estimate for the error bound <sub><span><img class="fm-editor-equation" src="assets/4cbcec0e-c1e6-415f-b92e-40da53f782ea.png" style="width:12.50em;height:1.08em;"/></span></sub><em>.</em></p>
<p>The following diagram (<em>Figure 16.1</em>) shows the<span> </span>comparison of the numeric and symbolic approximations:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d9bd0385-f8ad-4d45-9a0a-68c897d580fc.png" style="width:20.00em;height:9.25em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 16.1: Symbolic and numeric quadrature</div>
<h2 id="uuid-e1ff7f55-49d1-4ebe-821e-0fd2e6d6d3c8">16.1.1 Elaborating an example in SymPy</h2>
<p>To begin with, let's elaborate on the previous example in SymPy and explain the steps.</p>
<p>First, we have to import the module:</p>
<pre>from sympy import *<br/>init_printing()</pre>
<p>The second command makes sure that formulas are presented in a graphical way, if possible. Then, we generate a symbol and define the integrand:</p>
<pre>x = symbols('x')<br/>f = Lambda(x, 1/(x**2 + x + 1))</pre>
<p><kbd>x</kbd><span> </span>is now a Python object of type<span> </span><kbd>Symbol</kbd><span> </span>and<span> </span><kbd>f</kbd><span> </span>is a SymPy<span> </span><kbd>Lambda</kbd><span> </span>function (note the command starting with a capital letter).</p>
<p>Now we start with the symbolic computation of the integral:</p>
<pre>integrate(f(x),x)    </pre>
<p>Depending on your working environment, the result is presented in different ways; see the following screenshot (<em>Figure 16.2</em>), which represents two different results of a SymPy formula in different environments:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61592d97-d85f-4fb2-bb2f-7c177778629d.png" style="width:23.33em;height:6.17em;"/></div>
<div style="padding-left: 30px" class="packt_figref CDPAlignCenter CDPAlign">Figure 16.2: Two screenshots of a SymPy presentation of formula in two different environments</div>
<p>We can check by differentiation whether the result is correct. To this end, we assign a name to the primitive function and differentiate with respect to <span><img class="fm-editor-equation" src="assets/1618222e-1bbe-4fb4-8342-4f4d2261bf0a.png" style="width:1.00em;height:1.08em;"/></span>:</p>
<pre>pf = Lambda(x, integrate(f(x),x))<br/>diff(pf(x),x)    </pre>
<p>The result obtained will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/99763022-847a-4874-84d2-f502ea8eb61e.png" style="width:10.50em;height:3.92em;"/></p>
<p>Which can be simplified by using the following command:</p>
<pre>simplify(diff(pf(x),x))    </pre>
<p>To</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0acf16ff-1cf7-483e-aa59-4569326b1970.png" style="width:5.92em;height:2.75em;"/></p>
<p>This is the result we expected.</p>
<p>The definite integral is obtained by using the following command:</p>
<pre>pf(4) - pf(0)     </pre>
<p>It gives the following output after simplification with<span> </span><kbd>simplify</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/879b6eed-a37e-405d-8375-9a5343e23cea.png" style="width:12.42em;height:2.67em;"/></div>
<p>To obtain a numerical value, we finally evaluate this expression to a floating-point number:</p>
<pre>(pf(4)-pf(0)).evalf() # returns 0.9896614396123</pre>
<h1 id="uuid-edf98ea2-a462-49be-8305-436bf85d345c">16.2 Basic elements of SymPy</h1>
<p>Here we introduce the basic elements of SymPy. You will find it favorable to be already familiar with classes and data types in Python.</p>
<h2 id="uuid-3aff0846-8e2c-4c8d-aa75-da4ab66559a1">16.2.1 Symbols – the basis of all formulas</h2>
<p>The basic construction element to build a formula in SymPy is the symbol. As we saw in the introductory example, a symbol is created by the command<span> </span><kbd>symbols</kbd>. This SymPy command generates symbol objects from a given string:</p>
<pre>x, y, mass, torque = symbols('x y mass torque')</pre>
<p>It is actually a short form of the following command:</p>
<pre>symbol_list=[symbols(l) for l in 'x y mass torque'.split()]</pre>
<p>Followed by an unpacking step to obtain variables:</p>
<pre> x, y, mass, torque = symbol_list</pre>
<p>The arguments of the command define the string representation of the symbol. The variable name of the symbol chosen is <span>often </span>identical to its string representation, but this is not required by the language:</p>
<pre>row_index=symbols('i',integer=True)<br/>print(row_index**2)  # returns i**2</pre>
<p>Here, we also defined that the symbol is assumed to be an integer.</p>
<p>An entire set of symbols can be defined in a very compact way:</p>
<pre>integervariables = symbols('i:l', integer=True)<br/>dimensions = symbols('m:n', integer=True)<br/>realvariables = symbols('x:z', real=True)</pre>
<p>Similarly, symbols for indexed variables can be defined by using the following:</p>
<pre>A = symbols('A1:3(1:4)')</pre>
<p>This gives a tuple of symbols:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/71f68d7f-b2f6-41b8-afe5-64ecdf84348d.png" style="width:16.83em;height:1.08em;"/></p>
<p>The rules for the range of the indexes are those we saw earlier in this book when working with slices (see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml"/><a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.1</a>: <em>Slicing</em><em>,</em><span> </span>for more details).</p>
<h2 id="uuid-7f5837ed-d162-4387-900e-6bafd4614bc5">16.2.2 Numbers</h2>
<p>Python evaluates operations on numbers directly and introduces unavoidable rounding errors. These would obstruct all symbolic calculations. This is avoided when we <kbd>sympify</kbd><span> </span>numbers:</p>
<pre>1/3  # returns 0.3333333333333333<br/>sympify(1)/sympify(3)  # returns '1/3'</pre>
<p>The <kbd>sympify</kbd> command converts an integer to an object of type <kbd>sympy.core.numbers.Integer</kbd>.</p>
<p>Instead of writing <strong>1/3</strong> as an operation of two integers, it can also be represented directly as a rational number by <kbd>Rational(1,3)</kbd>.</p>
<h2 id="uuid-df0dfc67-6488-455d-92db-c213dba55044">16.2.3 Functions</h2>
<p>SymPy distinguishes between defined and undefined functions. The term undefined functions (which might be a bit misleading) refers to well-defined Python objects for generic functions that have no special properties.</p>
<p>An example of a function with special properties is<span> </span><kbd>atan</kbd><span> </span>or the<span> </span><kbd>Lambda</kbd><span> </span>function used in the introductory example of this chapter.  </p>
<p>Note the different names for the different implementations of the same mathematical function:<span> </span><kbd>sympy.atan</kbd><span> </span>and<span> </span><kbd>scipy.arctan</kbd>.</p>
<h3 id="uuid-69f6cdec-8383-4a6d-84b7-c89e5cc2e13e">Undefined functions</h3>
<p>A symbol for an undefined function is created by giving the<span> </span><kbd>symbols</kbd><span> </span>command an extra class argument:</p>
<pre>f, g = symbols('f g', cls=Function)</pre>
<p>The same can be achieved by using the constructor<span> </span><kbd>Function</kbd> :</p>
<pre>f = Function('f')<br/>g = Function('g')</pre>
<p>With undefined functions, we can evaluate the general rules of calculus.</p>
<p>For example, let's evaluate the following expression:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/689cb5c3-3743-4ad4-ad2d-696ebdb021f9.png" style="width:4.92em;height:2.08em;"/></p>
<p>This is symbolically computed in Python by using the following command:</p>
<pre>x = symbols('x')<br/>f, g = symbols('f g', cls=Function)<br/>diff(f(x*g(x)),x)</pre>
<p>When executed, the previous code returns the following as output:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5df9fcf5-d204-48f3-8337-1d0270539196.png" style="width:16.75em;height:2.83em;"/></p>
<p>This example shows how the product rule and the chain rule were applied.</p>
<p>We can even use an undefined function as a function in several variables, for example:</p>
<pre>x = symbols('x:3')<br/>f(*x)</pre>
<p>which returns the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/19994640-c42f-4bcf-92ac-f90628562304.png" style="width:6.58em;height:1.42em;"/></p>
<p class="mce-root">Note the use of the star operator to unpack a tuple to form<span> </span><em>f</em><span> </span>with arguments; see <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.2.5</a>: <em>Variable Number of Arguments</em>.</p>
<p>By using list comprehension, we can construct a list of all partial derivatives of <sub><img class="fm-editor-equation" src="assets/b097026c-fa3d-44d8-ae9c-b0e748c17a08.png" style="width:0.50em;height:0.92em;"/></sub>:</p>
<pre> [diff(f(*x),xx) for xx in x]</pre>
<p>This returns a list with the elements of <sub><img class="fm-editor-equation" src="assets/90f569a5-38c2-4bf1-a20f-cecf98f7ef51.png" style="width:1.42em;height:1.08em;"/></sub> (the gradient of <span><img class="fm-editor-equation" src="assets/6b258487-c295-41cf-89ad-f94b0fef08e5.png" style="width:0.67em;height:1.25em;"/></span>):</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/234a205a-53c2-4ff5-ba25-566ae553601e.png" style="width:26.17em;height:2.58em;"/></p>
<p>The command can also be rewritten by using the method<span> </span><kbd>diff</kbd><span> </span>of the<span> </span><kbd>Function</kbd><span> </span>object:</p>
<pre>[f(*x).diff(xx) for xx in x]</pre>
<p>Another method is Taylor series expansion:</p>
<pre>x = symbols('x')<br/>f(x).series(x,0,n=4)</pre>
<p>This returns Taylor's formula, together with the rest term expressed by the Landau symbol:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/03334177-36ef-494b-bb9e-43a0984f1471.png" style="width:27.17em;height:2.75em;"/></p>
<h2 id="uuid-71883d8c-11c4-4cd0-b35d-ce7711ce700b">16.2.4 Elementary functions</h2>
<p>Examples for elementary functions in SymPy are trigonometric functions and their inverses. The following example shows how <kbd>simplify</kbd> acts on an expression which includes elementary functions:</p>
<pre>x = symbols('x')<br/>simplify(cos(x)**2 + sin(x)**2)  # returns 1</pre>
<p>Here is another example of the use of elementary functions:</p>
<pre>atan(x).diff(x) - 1./(x**2+1)  # returns 0</pre>
<p>If you use SciPy and SymPy together, we strongly recommend that you use them in different namespaces:</p>
<pre>import numpy as np<br/>import sympy as sym<br/># working with numbers<br/>x=3<br/>y=np.sin(x)<br/># working with symbols<br/>x=sym.symbols('x')<br/>y=sym.sin(x)   </pre>
<h2 id="uuid-6a31f264-7f4c-4ab2-8cda-2671969b9d78">16.2.5 Lambda functions</h2>
<p>In <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.7</a>: <em>Anonymous functions</em>, we saw how to define so-called anonymous functions in Python. The SymPy counterpart is the<span> command </span><kbd>Lambda</kbd>. Note the difference;<span> </span><kbd>lambda</kbd><span> </span>is a<span> </span>keyword while<span> </span><kbd>Lambda</kbd><span> </span>is a constructor.</p>
<p>The command<span> </span><kbd>Lambda</kbd><span> </span>takes two arguments, the symbol of the function's independent variable, and a SymPy expression to evaluate the function.</p>
<p>Here is an example that defines air resistance (also called drag) as a function of speed:</p>
<pre>C,rho,A,v=symbols('C rho A v')<br/># C drag coefficient, A coss-sectional area, rho density<br/># v speed<br/>f_drag = Lambda(v,-Rational(1,2)*C*rho*A*v**2)</pre>
<p><kbd>f_drag</kbd><span> </span>is displayed as a graphical expression:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0ae44672-2bd5-4ad4-9fd6-7c9023392d9b.png" style="width:7.50em;height:2.50em;"/></p>
<p>This function can be evaluated in the usual way by providing it with an argument:</p>
<pre>x = symbols('x')<br/>f_drag(2)<br/>f_drag(x/3)</pre>
<p>Which results in the expressions:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/c39440e8-bc2b-4de3-b2ee-bc078927e835.png" style="width:10.50em;height:2.33em;"/></p>
<p>It is also possible to create functions in several variables by just providing t<span><span>he</span></span> first parameter of <kbd>Lambda</kbd> with a tuple, as follows for example:</p>
<pre>x,y=symbols('x y')<br/>t=Lambda((x,y),sin(x) + cos(2*y))</pre>
<p>A call to this function can be done in two ways, either by directly providing several arguments:</p>
<pre>t(pi,pi/2)  # returns -1</pre>
<p>Or by unpacking a tuple or list:</p>
<pre>p=(pi,pi/2)<br/>t(*p)   # returns -1</pre>
<p>Matrix objects in SymPy <span>even </span>make it possible to define vector-valued functions:</p>
<pre>F=Lambda((x,y),Matrix([sin(x) + cos(2*y), sin(x)*cos(y)]))</pre>
<p>This enables us to compute Jacobians:</p>
<pre>F(x,y).jacobian((x,y))</pre>
<p>Which gives the following expression as output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/41952fb2-f56e-46dc-a96c-e271fadd03b7.png" style="width:14.50em;height:2.67em;"/></p>
<p>In the case of more variables, it is convenient to use a more compact form to define the function:</p>
<pre>x=symbols('x:2')<br/>F=Lambda(x,Matrix([sin(x[0]) + cos(2*x[1]),sin(x[0])*cos(x[1])]))  <br/>F(*x).jacobian(x)</pre>
<h1 id="uuid-430b114c-a118-4234-925f-5be579ab0de4">16.3 Symbolic linear algebra</h1>
<p>Symbolic linear algebra is supported by SymPy's<span> data type</span> <kbd>matrix</kbd> which we will introduce first. Then we will present some linear algebra methods as examples for the broad spectrum of possibilities for symbolic computations in this field.</p>
<h2 id="uuid-96016ba0-5e06-4769-8e7b-e62f2c36416e">16.3.1 Symbolic matrices</h2>
<p>We briefly met the<span> </span><kbd>matrix</kbd><span> </span>data type when we discussed vector-valued functions. There, we saw it in its simplest form, which converts a list of lists into a matrix. To see an example, let's construct a rotation matrix:</p>
<pre>phi=symbols('phi')<br/>rotation=Matrix([[cos(phi), -sin(phi)],<br/>                 [sin(phi), cos(phi)]])</pre>
<p>When working with SymPy matrices we have to note that the operator<span> </span><kbd>*</kbd><span> </span>performs matrix multiplications and is not acting as an elementwise multiplication, which is the case for NumPy arrays. </p>
<p>The previously defined rotation matrix can be checked for orthogonality by using this matrix multiplication and the transpose of a matrix:</p>
<pre>simplify(rotation.T*rotation -eye(2))  # returns a 2 x 2 zero matrix</pre>
<p>The previous example shows how a matrix is transposed and how the identity matrix is created. Alternatively, we could have checked whether its inverse is its transpose, which can be done as follows:</p>
<pre>simplify(rotation.T - rotation.inv())</pre>
<p>Another way to set up a matrix is by providing a list of symbols and a shape:</p>
<pre>M = Matrix(3,3, symbols('M:3(:3)'))</pre>
<p>This creates the following matrix:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cb71b0fa-f4bc-4b43-8b5d-bf5bf626e49d.png" style="width:8.58em;height:3.75em;"/></p>
<p>A third way to create a matrix is by generating its entries by a given function. The syntax is as follows:</p>
<pre>Matrix(number of rows,number of colums, function)</pre>
<p>We exemplify the preceding matrix by considering a Toeplitz matrix. It is a matrix with constant diagonals. Given a <sub><span><img class="fm-editor-equation" src="assets/279a3df8-a97a-4ac5-89e4-d6c9bd841688.png" style="width:3.08em;height:0.92em;"/></span></sub><em> </em>data vector <span><img class="fm-editor-equation" src="assets/296cf8da-ce9c-4a65-85c5-6acd0ae169c0.png" style="width:0.67em;height:0.75em;"/></span>, its elements are defined as:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/cb66a951-698a-47f1-a2ed-7a237cbc8efb.png" style="width:19.75em;height:1.42em;"/></p>
<p>In SymPy, the matrix can be defined by directly making use of this definition:</p>
<pre>def toeplitz(n):<br/>    a = symbols('a:'+str(2*n))<br/>    f = lambda i,j: a[i-j+n-1]<br/>    return Matrix(n,n,f)</pre>
<p>Executing the previous code gives<span> </span><kbd>toeplitz(5)</kbd>:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/61377252-d6c9-4ef9-b650-9c3b81c933dd.png" style="width:10.08em;height:6.42em;"/>.</div>
<p>We can see <span>clearly </span>the desired structures; all elements along the subdiagonals and superdiagonals are the same. We can access matrix elements by the indexes and slices according to the Python syntax introduced in <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.1</a>:<span> </span><em>Slicing</em>:</p>
<pre>M[0,2]=0  # changes one element<br/>M[1,:]=Matrix(1,3,[1,2,3]) # changes an entire row</pre>
<h2 id="uuid-6e18e48a-6830-48ad-9017-161a6b0bc4d8">16.3.2 Examples for linear algebra methods in SymPy</h2>
<p>The basic task in linear algebra is to solve linear equation systems:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/8c1fb4f9-24ee-4cbf-8466-2cb8d3a8ba0b.png" style="width:3.92em;height:1.08em;"/></p>
<p>Let's do this symbolically for a <img class="fm-editor-equation" src="assets/980b1643-67ce-4e96-aa4e-5cfcf5d6595b.png" style="width:2.25em;height:0.83em;"/> matrix:</p>
<pre>A = Matrix(3,3,symbols('A1:4(1:4)'))<br/>b = Matrix(3,1,symbols('b1:4'))<br/>x = A.LUsolve(b)</pre>
<p>The output of this relatively small problem is already merely readable, which can be seen in the following graphical expression:</p>
<p class="CDPAlignLeft CDPAlign">               <img src="assets/d7dd2130-1af6-4fcf-8170-4800b3427a0d.png" style="width:57.25em;height:26.42em;"/></p>
<p>Again, the use of <kbd>simplify</kbd><span> </span>command helps us to detect canceling terms and to collect common factors:</p>
<pre>simplify(x)</pre>
<p>Which will result in the following output, which looks much better:</p>
<div class="CDPAlignLeft CDPAlign">             <img src="assets/41ea66c8-111a-4300-aa55-af4eb092b947.png" style="width:55.50em;height:11.75em;"/></div>
<p>Symbolic computations become very slow when increasing matrix dimensions. For dimensions bigger than 15, memory problems <span>might even occur</span>.</p>
<p>The next figure (<em>Figure 16.3</em>) illustrates the differences in CPU time between symbolically and numerically solving a linear system:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9b5bcdaa-6bed-4e61-9c85-c5754b2d9381.png" style="width:21.75em;height:15.08em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 16.3: CPU time for numerically and symbolically solving a linear system</div>
<h1 id="uuid-daa88577-bd32-418f-b644-a844d99142c4">16.4 Substitutions</h1>
<p>Let's first consider a simple symbolic expression:</p>
<pre>x, a = symbols('x a')<br/>b = x + a</pre>
<p>What happens if we set <kbd>x = 0</kbd> ? We observe that <kbd>b</kbd> did not change. What we did was that we changed the Python variable <kbd>x</kbd>. It now no longer refers to the symbol object but to the integer object <kbd>0</kbd>. The symbol represented by the string <kbd>'x'</kbd> remains unaltered, and so does <kbd>b</kbd>.</p>
<p>Instead, altering an expression by replacing symbols with numbers, other symbols, or expressions is done by a special substitution method, which can be seen in the following code:</p>
<pre>x, a = symbols('x a')<br/>b = x + a<br/>c = b.subs(x,0)   <br/>d = c.subs(a,2*a)  <br/>print(c, d)   # returns (a, 2a)</pre>
<p>This method takes one or two arguments. The following two statements are equivalent:</p>
<pre>b.subs(x,0)<br/>b.subs({x:0})  # a dictionary as argument</pre>
<p>Dictionaries as arguments allow us to make several substitutions in one step:</p>
<pre>b.subs({x:0, a:2*a})  # several substitutions in one</pre>
<p>As items in dictionaries have no defined order—we can never know which would be the first<span>—</span>there is a need for ensuring that permuting the items would not affect the substitution result. Therefore in SymPy, substitutions are first made within the dictionary and then on the expression. This is demonstrated by the following example:</p>
<pre>x, a, y = symbols('x a y')<br/>b = x + a<br/>b.subs({a:a*y, x:2*x, y:a/y})<br/>b.subs({y:a/y, a:a*y, x:2*x})</pre>
<p>Both substitutions return the same result:</p>
<p class="CDPAlignCenter CDPAlign"><sub><img class="fm-editor-equation" src="assets/8a5144a8-5cbf-4da4-9869-c915a219a942.png" style="width:4.25em;height:3.00em;"/></sub> </p>
<p>A third alternative to defining multiple substitutions is by using a list of old-value/new-value pairs instead:</p>
<pre> b.subs([(y,a/y), (a,a*y), (x,2*x)]) </pre>
<p>It is also possible to substitute entire expressions for others:</p>
<pre>n, alpha = symbols('n alpha')<br/>b = cos(n*alpha)<br/>b.subs(cos(n*alpha), 2*cos(alpha)*cos((n-1)*alpha)-cos((n-2)*alpha))</pre>
<p> To illustrate substitutions of matrix elements, we take the <span><img class="fm-editor-equation" src="assets/3a72dcd0-f73c-4b62-8d90-2b07c3477916.png" style="width:2.67em;height:1.00em;"/></span><span> </span>Toeplitz matrix again:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5babfd5f-3ae7-48a1-b6d2-f3532b0201fa.png" style="width:14.00em;height:7.50em;"/></p>
<p>Consider the substitution<span> </span><kbd>T.subs(T[0,2],0)</kbd>. It changes the symbol object at position <kbd>[0, 2]</kbd>, which is the symbol <span><img class="fm-editor-equation" src="assets/ac3eb574-96b2-42d8-9e91-627d68e3c16b.png" style="width:1.33em;height:1.00em;"/></span>. It also occurs at two other places, which are automatically affected by this substitution.</p>
<p class="CDPAlignLeft CDPAlign">The given expression is the resulting matrix:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/981c6235-96e4-4a07-954d-66636e4e29fd.png" style="width:12.83em;height:8.17em;"/></p>
<p class="CDPAlignLeft CDPAlign">Alternatively, we can create a variable for this symbol and use it in the substitution:</p>
<pre>a2 = symbols('a2')<br/>T.subs(a2,0)</pre>
<p>As a more complex example for substitution, let's consider how to turn the Toeplitz matrix into a tridiagonal Toeplitz matrix<em>.</em><span> </span>This can be done in the following ways:</p>
<p>First, we generate a list of those symbols that we want to substitute; and then we use the<span> </span><kbd>zip</kbd><span> </span>command to generate a list of pairs. Finally, we substitute by giving a list of old-value/new-value pairs as described previously:</p>
<pre>symbs = [symbols('a'+str(i)) for i in range(19) if i &lt; 3 or i &gt; 5]<br/>substitutions=list(zip(symbs,len(symbs)*[0]))<br/>T.subs(substitutions)</pre>
<p>This gives the following matrix as a result:</p>
<p style="padding-left: 30px" class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0f3fc866-797d-4810-bffd-f77832bedc89.png" style="width:13.33em;height:8.50em;"/></p>
<h1 id="uuid-f838458b-401f-49b9-964f-572257f153ed">16. 5 Evaluating symbolic expressions</h1>
<p>In the context of scientific computing, there is often the need to first make symbolic manipulations and then convert the symbolic result into a floating-point number.</p>
<p>The central tool for evaluating a symbolic expression is<span> </span><kbd>evalf</kbd>. It converts symbolic expressions to floating-point numbers by using the following:</p>
<pre>pi.evalf()   # returns 3.14159265358979</pre>
<p>The data type of the resulting object is<span> </span><kbd>Float</kbd><span> </span>(note the capitalization), which is a SymPy data type that allows floating-point numbers with an arbitrary number of digits (arbitrary precision).</p>
<p>The default precision corresponds to 15 digits, but it can be changed by giving<span> </span><kbd>evalf</kbd><span> </span>an extra positive integer argument</p>
<p>specifying the desired precision in terms of the numbers of digits:</p>
<pre>pi.evalf(30)   # returns  3.14159265358979323846264338328</pre>
<p>A consequence of working with arbitrary precision is that numbers can be arbitrarily small, that is, the limits of the classical floating-point representation are broken; see <a href="879c0554-386f-4bb1-8fa8-b86c43927545.xhtml">Section 2.2.2</a>: <em>Floating-point numbers</em>.</p>
<p>Interestingly enough, evaluating a SymPy function with an input of type<span> </span><kbd>Float</kbd><span> </span>returns a <kbd>Float</kbd> with the same precision as the input. We demonstrate the use of this fact in a more elaborated example from numerical analysis.</p>
<h2 id="uuid-1401d3d7-312d-4b4b-a21a-e444b0c24e10">16.5.1 Example: A study on the convergence order of Newton's method</h2>
<p>An iterative method that iterates<span> </span><sub><em><img class="fm-editor-equation" src="assets/8038e264-c9a7-4d5f-b660-cd3997fc5d6c.png" style="width:1.33em;height:0.92em;"/></em></sub> is said to converge with order <img class="fm-editor-equation" src="assets/e551ea10-3819-42ef-b8b1-3884edbf01bc.png" style="width:0.58em;height:1.00em;"/> with <img class="fm-editor-equation" src="assets/36ff2bdf-6ca2-4169-ab30-3f4ffcdaccb4.png" style="width:4.75em;height:1.17em;"/><sub>,</sub><span> </span>if there exists a positive constant <span><img class="fm-editor-equation" src="assets/d1e134fb-86be-4b63-ab18-e936219620fe.png" style="width:0.92em;height:1.00em;"/></span> such that</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/69ef133f-4f49-401c-a132-ee87c1697bba.png" style="width:12.25em;height:3.25em;"/></p>
<p>Newton's method, when started with a good initial value, has order <img class="fm-editor-equation" src="assets/d5d4c2b0-7c21-4ae7-abe1-13d87cd15d2e.png" style="width:2.83em;height:1.25em;"/>, and for certain problems, even <img class="fm-editor-equation" src="assets/3778c99a-3238-4758-81e5-ffa04d05c1e4.png" style="width:2.67em;height:1.17em;"/>. Newton's method when applied to the problem <img class="fm-editor-equation" src="assets/3e25a412-60af-451a-9075-b63f22edc726.png" style="width:7.42em;height:1.42em;"/> gives the following iteration scheme:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/df5318b5-ae44-434b-8a96-8c55c1dccdab.png" style="width:26.00em;height:3.25em;"/></p>
<p>Which converges cubically; that is,<span> </span><em>q</em><span> </span>= 3.</p>
<p>This implies that the number of correct digits triples from iteration to iteration. To demonstrate cubic convergence and to numerically determine the constant<span> </span><sub><img class="fm-editor-equation" src="assets/b1a781f0-07e6-4d0d-b5d1-0d40c1bb15fc.png" style="width:0.92em;height:1.00em;"/></sub> is hardly possible with the standard 16-digit <kbd>float</kbd> data type.</p>
<p>The following code uses SymPy together with high-precision evaluation instead and takes the study on cubic convergence to the extreme:</p>
<pre>import sympy as sym<br/>x = sym.Rational(1,2)<br/>xns=[x]<br/><br/>for i in range(1,9):<br/>    x = (x - sym.atan(x)*(1+x**2)).evalf(3000)<br/>    xns.append(x)</pre>
<p>The result is depicted in the next figure (<em>Figure 16.4</em>), which shows that the number of correct digits triples from iteration to iteration:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/0944745e-3381-43e2-b3da-8ce9027d2364.png" style="width:19.58em;height:13.00em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign"> Figure 16.4: A study on the convergence of Newton's method applied to <img class="fm-editor-equation" src="assets/188cd499-6f66-4039-bcfd-e039c4de31da.png" style="width:5.25em;height:1.00em;"/></div>
<p class="CDPAlignLeft CDPAlign">This extreme precision requirement (3,000 digits!) enables us to evaluate seven terms of the preceding sequence to demonstrate cubic convergence in the following way:</p>
<pre>import numpy as np<br/># Test for cubic convergence<br/>print(np.array(np.abs(np.diff(xns[1:]))/np.abs(np.diff(xns[:-1]))**3,<br/>               dtype=np.float64))</pre>
<p>The result is a list of seven terms that let us assume that <span><img class="fm-editor-equation" src="assets/7282e682-14f4-42f1-b2da-f22d4a0db8bb.png" style="width:3.92em;height:1.25em;"/></span>:</p>
<pre>[ 0.41041618, 0.65747717, 0.6666665,  0.66666667, 0.66666667, 0.66666667, 0.66666667]}</pre>
<h2 id="uuid-b4c8c1b6-9428-418c-a11f-929d2536b134">16.5.2 Converting a symbolic expression into a numeric function</h2>
<p>As we have seen, the numerical evaluation of symbolic expressions is done in three steps: first, we do some symbolic computations and then we substitute values by numbers and do an evaluation to a floating-point number with <kbd>evalf</kbd>.</p>
<p>The reason for symbolic computations is often that we want to make parameter studies. This requires that the parameter is modified within a given parameter range. This requires that a symbolic expression is eventually turned into a numeric function.</p>
<h3 id="uuid-b0b41f52-3f2c-494e-a0a0-498f0ec88248">A study on the parameter dependency of polynomial coefficients</h3>
<p>We demonstrate a symbolic/ numeric parameter<span> </span>study by an interpolation example to introduce the SymPy command<span> </span><kbd>lambdify</kbd>.</p>
<p>Let's consider the task to interpolate the data <span><img class="fm-editor-equation" src="assets/1186c128-483c-4d51-8df7-207d483a2da8.png" style="width:5.17em;height:1.25em;"/></span> and <img class="fm-editor-equation" src="assets/58696cc5-47bd-4b9d-a3f5-0c0344b1abda.png" style="width:5.58em;height:1.17em;"/>. Here, <span><img class="fm-editor-equation" src="assets/99eedf3c-a08b-4a54-85e3-061b29472f88.png" style="width:0.42em;height:0.92em;"/></span> is a free parameter, which we will vary over the interval<img class="fm-editor-equation" src="assets/a32da2e1-a0f2-4cd7-aa5b-badedd42495b.png" style="width:4.75em;height:1.25em;"/>.</p>
<p>The quadratic interpolation polynomial has coefficients depending on this parameter:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/ed52c599-8a50-410d-a261-02989af80625.png" style="width:16.08em;height:1.67em;"/></p>
<p>Using SymPy and the monomial approach described in <em>Exercise 3</em> in <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section 4.11</a>: <em>Exercises</em><span> </span>gives<span> </span>us the closed formula for these coefficients:</p>
<pre>t=symbols('t')<br/>x=[0,t,1]<br/># The Vandermonde Matrix<br/>V = Matrix([[0, 0, 1], [t**2, t, 1], [1, 1,1]])<br/>y = Matrix([0,1,-1]) # the data vector<br/>a = simplify(V.LUsolve(y)) # the coefficients<br/># the leading coefficient as a function of the parameter<br/>a2 = Lambda(t,a[0])</pre>
<p>We obtain a symbolic function for the leading coefficient<span> </span><sub><img class="fm-editor-equation" src="assets/ebfc6511-9b09-49d3-b0a7-3cee878c7d64.png" style="width:1.42em;height:1.08em;"/></sub> of the interpolation polynomial:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/958edc0c-d7a9-46bd-8e0f-65209f5dc4cc.png" style="width:7.00em;height:2.58em;"/></p>
<p>Now it is time to turn the expression into a numeric function, for example, to make a plot. This is done by the function <kbd>lamdify</kbd>. This function takes two arguments, the independent variable, and a SymPy function.</p>
<p>For our example in Python, we can write:</p>
<pre>leading_coefficient = lambdify(t,a2(t))</pre>
<p>This function can now be plotted, for example, by the following commands:</p>
<pre>import numpy as np<br/>import matplotlib.pyplot as mp<br/>t_list= np.linspace(-0.4,1.4,200)<br/>ax=mp.subplot(111)<br/>lc_list = [leading_coefficient(t) for t in t_list]<br/>ax.plot(t_list, lc_list)<br/>ax.axis([-.4,1.4,-15,10])<br/>ax.set_xlabel('Free parameter $t$')<br/>ax.set_ylabel('$a_2(t)$')<br/><br/></pre>
<p><em>Figure 16.5</em> is the result of this parameter study, we can clearly see the singularities due to multiple interpolation points (here at <span><img class="fm-editor-equation" src="assets/97299a92-07c9-427b-943c-7dcf074dcf70.png" style="width:2.67em;height:1.00em;"/> </span>or <span><img class="fm-editor-equation" src="assets/266b98d5-623e-4ca0-9e10-2a00f2f33642.png" style="width:2.50em;height:0.92em;"/></span>): </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/25c98c0b-464c-49ce-980f-bb827afc9a79.png" style="width:27.83em;height:18.50em;"/></div>
<div style="padding-left: 30px" class="CDPAlignCenter CDPAlign packt_figref">Figure 16.5: The dependency of a polynomial coefficient on the location of an interpolation point</div>
<h1 id="uuid-08a8fbf7-3cf6-458c-a6d6-dd8d3c0b42dc">16.6 Summary</h1>
<p>In this chapter, you were introduced to the world of symbolic computations and you got a glimpse of the power of SymPy. By following the examples, you learned how to set up symbolic expressions, how to work with symbolic matrices, and you saw how to make simplifications. Working with symbolic functions and transforming them into numerical evaluations, finally, established the link to scientific computing and floating-point results. You experienced the strength of SymPy as you used its full integration into Python with its powerful constructs and legible syntax.</p>
<p>Consider this last chapter as an appetizer rather than a complete menu. We hope you became hungry for future fascinating programming challenges in scientific computing and mathematics.</p>


            </article>

            
        </section>
    </body></html>