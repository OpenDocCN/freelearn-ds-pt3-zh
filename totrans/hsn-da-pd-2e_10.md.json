["```py\n(book_env) $ pip3 install \\\ngit+https://github.com/stefmolin/stock-analysis.git@2nd_edition\n```", "```py\n(book_env) $ git clone \\\ngit@github.com:stefmolin/stock-analysis.git\n(book_env) $ pip3 install -r stock-analysis/requirements.txt\n(book_env) $ pip3 install -e stock-analysis\n```", "```py\nrepo_folder\n|-- <package_name>\n|   |-- __init__.py\n|   |-- some_module.py\n|   `-- <subpackage_name>\n|       |-- __init__.py\n|       |-- another_module.py\n|       `-- last_module.py\n`-- setup.py\n```", "```py\n\"\"\"Gather select stock data.\"\"\"\nimport datetime as dt\nimport re\nimport pandas as pd\nimport pandas_datareader.data as web\nfrom .utils import label_sanitizer\n```", "```py\nclass StockReader:\n    \"\"\"Class for reading financial data from websites.\"\"\"\n    _index_tickers = {'S&P 500': '^GSPC', 'Dow Jones': '^DJI',\n                      'NASDAQ': '^IXIC'}\n```", "```py\n    def __init__(self, start, end=None):\n        \"\"\"\n        Create a `StockReader` object for reading across \n        a given date range.\n        Parameters:\n            - start: The first date to include, as a datetime \n              object or a string in the format 'YYYYMMDD'.\n            - end: The last date to include, as a datetime\n              object or string in the format 'YYYYMMDD'.\n              Defaults to today if not provided.\n        \"\"\"\n        self.start, self.end = map(\n            lambda x: x.strftime('%Y%m%d')\\\n                if isinstance(x, dt.date)\\\n                else re.sub(r'\\D', '', x),\n            [start, end or dt.date.today()]\n        )\n        if self.start >= self.end:\n            raise ValueError('`start` must be before `end`')\n```", "```py\n    @property\n    def available_tickers(self):\n        \"\"\"Indices whose tickers are supported.\"\"\"\n        return list(self._index_tickers.keys())\n```", "```py\n    @classmethod\n    def get_index_ticker(cls, index):\n        \"\"\"\n        Get the ticker of the specified index, if known.\n        Parameters:\n            - index: The name of the index; check \n              `available_tickers` for full list which includes:\n                - 'S&P 500' for S&P 500,\n                - 'Dow Jones' for Dow Jones Industrial Average,\n                - 'NASDAQ' for NASDAQ Composite Index\n        Returns: \n            The ticker as a string if known, otherwise `None`.\n        \"\"\"\n        try:\n            index = index.upper()\n        except AttributeError:\n            raise ValueError('`index` must be a string')\n        return cls._index_tickers.get(index, None)\n```", "```py\n    def get_risk_free_rate_of_return(self, last=True):\n        \"\"\"\n        Get risk-free rate of return w/ 10-year US T-bill \n        from FRED (https://fred.stlouisfed.org/series/DGS10)\n        Parameter:\n            - last: If `True`, return the rate on the last\n              date in the date range else, return a `Series` \n              object for the rate each day in the date range.\n        Returns:\n            A single value or a `pandas.Series` object.\n        \"\"\"\n        data = web.DataReader(\n            'DGS10', 'fred', start=self.start, end=self.end\n        )\n        data.index.rename('date', inplace=True)\n        data = data.squeeze()\n        return data.asof(self.end) \\\n            if last and isinstance(data, pd.Series) else data\n```", "```py\n    @label_sanitizer\n    def get_ticker_data(self, ticker):\n        pass    \n    def get_index_data(self, index):\n        pass\n    def get_bitcoin_data(self, currency_code):\n        pass\n    @label_sanitizer \n    def get_forex_rates(self, from_currency, to_currency,\n                        **kwargs):\n        pass\n```", "```py\n\"\"\"Utility functions for stock analysis.\"\"\"\nfrom functools import wraps\nimport re\nimport pandas as pd\n```", "```py\ndef _sanitize_label(label):\n    \"\"\"\n    Clean up a label by removing non-letter, non-space \n    characters and putting in all lowercase with underscores\n    replacing spaces.\n    Parameters:\n        - label: The text you want to fix.\n    Returns: \n        The sanitized label.\n    \"\"\"\n    return re.sub(r'[^\\w\\s]', '', label)\\\n        .lower().replace(' ', '_')\n```", "```py\ndef label_sanitizer(method):\n    \"\"\"\n    Decorator around a method that returns a dataframe to\n    clean up all labels in said dataframe (column names and \n    index name) by using `_sanitize_label()`.\n    Parameters:\n        - method: The method to wrap.\n    Returns: \n        A decorated method or function.\n    \"\"\"\n    @wraps(method) # keep original docstring for help()\n    def method_wrapper(self, *args, **kwargs):\n        df = method(self, *args, **kwargs)\n        # fix the column names\n        df.columns = [\n            _sanitize_label(col) for col in df.columns\n        ]\n        # fix the index name\n        df.index.rename(\n            _sanitize_label(df.index.name), inplace=True\n        )\n        return df\n    return method_wrapper\n```", "```py\n@label_sanitizer\ndef get_ticker_data(self, ticker):\n    \"\"\"\n    Get historical OHLC data for given date range and ticker.\n    Parameter:\n        - ticker: The stock symbol to lookup as a string.\n    Returns: A `pandas.DataFrame` object with the stock data.\n    \"\"\"\n    return web.get_data_yahoo(ticker, self.start, self.end)\n```", "```py\ndef get_index_data(self, index):\n    \"\"\"\n    Get historical OHLC data from Yahoo! Finance\n    for the chosen index for given date range.\n    Parameter:\n        - index: String representing the index you want\n          data for, supported indices include:\n            - 'S&P 500' for S&P 500,\n            - 'Dow Jones' for Dow Jones Industrial Average,\n            - 'NASDAQ' for NASDAQ Composite Index\n    Returns: \n        A `pandas.DataFrame` object with the index data.\n    \"\"\"\n    if index not in self.available_tickers:\n        raise ValueError(\n            'Index not supported. Available tickers'\n            f\"are: {', '.join(self.available_tickers)}\"\n        )\n    return self.get_ticker_data(self.get_index_ticker(index))\n```", "```py\ndef get_bitcoin_data(self, currency_code):\n    \"\"\"\n    Get bitcoin historical OHLC data for given date range. \n    Parameter:\n        - currency_code: The currency to collect the bitcoin\n          data in, e.g. USD or GBP.\n    Returns: \n        A `pandas.DataFrame` object with the bitcoin data.\n    \"\"\"\n    return self\\\n        .get_ticker_data(f'BTC-{currency_code}')\\\n        .loc[self.start:self.end] # clip dates\n```", "```py\n>>> import stock_analysis\n```", "```py\n\"\"\"Classes for making technical stock analysis easier.\"\"\"\nfrom .stock_analyzer import StockAnalyzer, AssetGroupAnalyzer\nfrom .stock_modeler import StockModeler\nfrom .stock_reader import StockReader\nfrom .stock_visualizer import \\\n    StockVisualizer, AssetGroupVisualizer\n```", "```py\n>>> reader = \\\n...     stock_analysis.StockReader('2019-01-01', '2020-12-31')\n```", "```py\n>>> fb, aapl, amzn, nflx, goog = (\n...     reader.get_ticker_data(ticker)\n...     for ticker in ['FB', 'AAPL', 'AMZN', 'NFLX', 'GOOG']\n... )\n>>> sp = reader.get_index_data('S&P 500')\n>>> bitcoin = reader.get_bitcoin_data('USD') \n```", "```py\nimport pandas as pd\n```", "```py\ndef group_stocks(mapping):\n    \"\"\"\n    Create a new dataframe with many assets and a new column \n    indicating the asset that row's data belongs to.\n    Parameters:\n        - mapping: A key-value mapping of the form \n                   {asset_name: asset_df}\n    Returns: \n        A new `pandas.DataFrame` object\n    \"\"\"\n    group_df = pd.DataFrame()\n    for stock, stock_data in mapping.items():\n        df = stock_data.copy(deep=True)\n        df['name'] = stock\n        group_df = group_df.append(df, sort=True)\n    group_df.index = pd.to_datetime(group_df.index)\n    return group_df\n```", "```py\ndef validate_df(columns, instance_method=True):\n    \"\"\"\n    Decorator that raises a `ValueError` if input isn't a\n    `DataFrame` or doesn't contain the proper columns. Note \n    the `DataFrame` must be the first positional argument\n    passed to this method.\n    Parameters:\n        - columns: A set of required column names.\n          For example, {'open', 'high', 'low', 'close'}.\n        - instance_method: Whether or not the item being\n          decorated is an instance method. Pass `False` to \n          decorate static methods and functions.\n    Returns:\n        A decorated method or function.\n    \"\"\"\n    def method_wrapper(method):\n        @wraps(method)\n        def validate_wrapper(self, *args, **kwargs):\n            # functions and static methods don't pass self so\n            # self is the 1st positional argument in that case\n            df = (self, *args)[0 if not instance_method else 1]\n            if not isinstance(df, pd.DataFrame):\n                raise ValueError(\n                    'Must pass in a pandas `DataFrame`'\n                )\n            if columns.difference(df.columns):\n                raise ValueError(\n                    'Dataframe must contain the following'\n                    f' columns: {columns}'\n                )\n            return method(self, *args, **kwargs)\n        return validate_wrapper\n    return method_wrapper\n```", "```py\n@validate_df(columns={'name'}, instance_method=False)\ndef describe_group(data):\n    \"\"\"\n    Run `describe()` on the asset group.\n    Parameters:\n        - data: Grouped data resulting from `group_stocks()`\n    Returns: \n        The transpose of the grouped description statistics.\n    \"\"\"\n    return data.groupby('name').describe().T\n```", "```py\n>>> from stock_analysis.utils import \\\n...     group_stocks, describe_group\n>>> faang = group_stocks({\n...     'Facebook': fb, 'Apple': aapl, 'Amazon': amzn, \n...     'Netflix': nflx, 'Google': goog\n... })\n>>> faang_sp = group_stocks({\n...     'Facebook': fb, 'Apple': aapl, 'Amazon': amzn, \n...     'Netflix': nflx, 'Google': goog, 'S&P 500': sp\n... })\n>>> all_assets = group_stocks({\n...     'Bitcoin': bitcoin, 'S&P 500': sp, 'Facebook': fb, \n...     'Apple': aapl, 'Amazon': amzn, 'Netflix': nflx, \n...     'Google': goog\n... })\n```", "```py\n>>> describe_group(all_assets).loc['close',]\n```", "```py\n@validate_df(columns=set(), instance_method=False)\ndef make_portfolio(data, date_level='date'):\n    \"\"\"\n    Make a portfolio of assets by grouping by date and \n    summing all columns.\n    Note: the caller is responsible for making sure the \n    dates line up across assets and handling when they don't.\n    \"\"\"\n    return data.groupby(level=date_level).sum()\n```", "```py\n\"\"\"Visualize financial instruments.\"\"\"\nimport math\nimport matplotlib.pyplot as plt\nimport mplfinance as mpf\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom .utils import validate_df\n```", "```py\nclass Visualizer:\n    \"\"\"Base visualizer class not intended for direct use.\"\"\"\n    @validate_df(columns={'open', 'high', 'low', 'close'})\n    def __init__(self, df):\n        \"\"\"Store the input data as an attribute.\"\"\"\n        self.data = df\n```", "```py\n    @staticmethod\n    def add_reference_line(ax, x=None, y=None, **kwargs):\n        \"\"\"\n        Static method for adding reference lines to plots.\n        Parameters:\n            - ax: `Axes` object to add the reference line to.\n            - x, y: The x, y value to draw the line at as a \n              single value or numpy array-like structure.\n                - For horizontal: pass only `y`\n                - For vertical: pass only `x`\n                - For AB line: pass both `x` and `y`\n            - kwargs: Additional keyword args. to pass down.\n        Returns:\n            The matplotlib `Axes` object passed in.\n        \"\"\"\n        try:\n            # numpy array-like structures -> AB line\n            if x.shape and y.shape:\n                ax.plot(x, y, **kwargs)\n        except:\n            # error triggers if x or y isn't array-like\n            try:\n                if not x and not y:\n                    raise ValueError(\n                        'You must provide an `x` or a `y`'\n                    )\n                elif x and not y:\n                    ax.axvline(x, **kwargs) # vertical line\n                elif not x and y:\n                    ax.axhline(y, **kwargs) # horizontal line\n            except:\n                raise ValueError(\n                    'If providing only `x` or `y`, '\n                    'it must be a single value'\n                )\n        ax.legend()\n        return ax\n```", "```py\n    @staticmethod\n    def shade_region(ax, x=tuple(), y=tuple(), **kwargs):\n        \"\"\"\n        Static method for shading a region on a plot.\n        Parameters:\n            - ax: `Axes` object to add the shaded region to.\n            - x: Tuple with the `xmin` and `xmax` bounds for \n              the rectangle drawn vertically.\n            - y: Tuple with the `ymin` and `ymax` bounds for \n              the rectangle drawn horizontally.\n            - kwargs: Additional keyword args. to pass down.\n        Returns: \n            The matplotlib `Axes` object passed in.\n        \"\"\"\n        if not x and not y:\n            raise ValueError(\n                'You must provide an x or a y min/max tuple'\n            )\n        elif x and y:\n            raise ValueError('You can only provide x or y.')\n        elif x and not y:\n            ax.axvspan(*x, **kwargs) # vertical region\n        elif not x and y:\n            ax.axhspan(*y, **kwargs) # horizontal region\n        return ax\n```", "```py\n    @staticmethod\n    def _iter_handler(items):\n        \"\"\"\n        Static method for making a list out of an item if \n        it isn't a list or tuple already.\n        Parameters:\n            - items: The variable to make sure it is a list.\n        Returns: The input as a list or tuple.\n        \"\"\"\n        if not isinstance(items, (list, tuple)):\n            items = [items]\n        return items\n```", "```py\n    def _window_calc(self, column, periods, name, func, \n                     named_arg, **kwargs):\n        \"\"\"\n        To be implemented by subclasses. Defines how to add \n        lines resulting from window calculations.\n        \"\"\"\n        raise NotImplementedError('To be implemented by '\n                                  'subclasses.')\n```", "```py\n    def moving_average(self, column, periods, **kwargs):\n        \"\"\"\n        Add line(s) for the moving average of a column.\n        Parameters:\n            - column: The name of the column to plot.\n            - periods: The rule or list of rules for \n              resampling, like '20D' for 20-day periods.\n            - kwargs: Additional arguments to pass down.\n        Returns: A matplotlib `Axes` object.\n        \"\"\"\n        return self._window_calc(\n            column, periods, name='MA', named_arg='rule',\n            func=pd.DataFrame.resample, **kwargs\n        )\n```", "```py\n    def exp_smoothing(self, column, periods, **kwargs):\n        \"\"\"\n        Add line(s) for the exponentially smoothed moving \n        average of a column.\n        Parameters:\n            - column: The name of the column to plot.\n            - periods: The span or list of spans for,\n              smoothing like 20 for 20-day periods.\n            - kwargs: Additional arguments to pass down.\n        Returns: \n            A matplotlib `Axes` object.\n        \"\"\"\n        return self._window_calc(\n            column, periods, name='EWMA',\n            func=pd.DataFrame.ewm, named_arg='span', **kwargs\n        )\n```", "```py\n    def evolution_over_time(self, column, **kwargs):\n        \"\"\"Creates line plots.\"\"\"\n        raise NotImplementedError('To be implemented by '\n                                  'subclasses.')\n    def after_hours_trades(self):\n        \"\"\"Show the effect of after-hours trading.\"\"\"\n        raise NotImplementedError('To be implemented by '\n                                  'subclasses.')\n    def pairplot(self, **kwargs):\n        \"\"\"Create pairplots.\"\"\"\n        raise NotImplementedError('To be implemented by '\n                                  'subclasses.')\n```", "```py\nclass StockVisualizer(Visualizer):\n    \"\"\"Visualizer for a single stock.\"\"\"\n    def evolution_over_time(self, column, **kwargs):\n        \"\"\"\n        Visualize the evolution over time of a column.\n        Parameters:\n            - column: The name of the column to visualize.\n            - kwargs: Additional arguments to pass down.\n        Returns:\n            A matplotlib `Axes` object.\n        \"\"\"\n        return self.data.plot.line(y=column, **kwargs)\n```", "```py\n    def candlestick(self, date_range=None, resample=None, \n                    volume=False, **kwargs):\n        \"\"\"\n        Create a candlestick plot for the OHLC data.\n        Parameters:\n            - date_range: String or `slice()` of dates to \n              pass to `loc[]`, if `None` the plot will be \n              for the full range of the data.\n            - resample: The offset to use for resampling \n              the data, if desired.\n            - volume: Whether to show a bar plot for volume \n              traded under the candlesticks\n            - kwargs: Keyword args for `mplfinance.plot()`\n        \"\"\"\n        if not date_range:\n            date_range = slice(\n                self.data.index.min(), self.data.index.max()\n            )\n        plot_data = self.data.loc[date_range]\n        if resample:\n            agg_dict = {\n                'open': 'first', 'close': 'last',\n                'high': 'max', 'low': 'min', 'volume': 'sum'\n            }\n            plot_data = plot_data.resample(resample).agg({\n                col: agg_dict[col] for col in plot_data.columns\n                if col in agg_dict\n            })\n        mpf.plot(\n            plot_data, type='candle', volume=volume, **kwargs\n        )\n```", "```py\n    def after_hours_trades(self):\n        \"\"\"\n        Visualize the effect of after-hours trading.\n        Returns: A matplotlib `Axes` object.\n        \"\"\"\n        after_hours = self.data.open - self.data.close.shift()\n        monthly_effect = after_hours.resample('1M').sum()\n        fig, axes = plt.subplots(1, 2, figsize=(15, 3))\n        after_hours.plot(\n            ax=axes[0],\n            title='After-hours trading\\n'\n                  '(Open Price - Prior Day\\'s Close)'\n        ).set_ylabel('price')\n        monthly_effect.index = \\\n            monthly_effect.index.strftime('%Y-%b')\n        monthly_effect.plot(\n            ax=axes[1], kind='bar', rot=90,\n            title='After-hours trading monthly effect',\n            color=np.where(monthly_effect >= 0, 'g', 'r')\n        ).axhline(0, color='black', linewidth=1)\n        axes[1].set_ylabel('price')\n        return axes\n```", "```py\n    @staticmethod\n    def fill_between(y1, y2, title, label_higher, label_lower, \n                     figsize, legend_x):\n        \"\"\"\n        Visualize the difference between assets.\n        Parameters:\n            - y1, y2: Data to plot, filling y2 - y1.\n            - title: The title for the plot.\n            - label_higher: Label for when y2 > y1.\n            - label_lower: Label for when y2 <= y1.\n            - figsize: (width, height) for the plot dimensions.\n            - legend_x: Where to place legend below the plot.\n        Returns: A matplotlib `Axes` object.\n        \"\"\"\n        is_higher = y2 - y1 > 0\n        fig = plt.figure(figsize=figsize)\n        for exclude_mask, color, label in zip(\n            (is_higher, np.invert(is_higher)),\n            ('g', 'r'),\n            (label_higher, label_lower)\n        ):\n            plt.fill_between(\n                y2.index, y2, y1, figure=fig,\n                where=exclude_mask, color=color, label=label\n            )\n        plt.suptitle(title)\n        plt.legend(\n            bbox_to_anchor=(legend_x, -0.1),\n            framealpha=0, ncol=2\n        )\n        for spine in ['top', 'right']:\n            fig.axes[0].spines[spine].set_visible(False)\n        return fig.axes[0]\n```", "```py\n    def open_to_close(self, figsize=(10, 4)):\n        \"\"\"\n        Visualize the daily change in price from open to close.\n        Parameters:\n            - figsize: (width, height) of plot\n        Returns:\n            A matplotlib `Axes` object.\n        \"\"\"\n        ax = self.fill_between(\n            self.data.open, self.data.close, \n            figsize=figsize, legend_x=0.67,\n            title='Daily price change (open to close)',\n            label_higher='price rose', label_lower='price fell'\n        )\n        ax.set_ylabel('price')\n        return ax\n```", "```py\n    def fill_between_other(self, other_df, figsize=(10, 4)):\n        \"\"\"\n        Visualize difference in closing price between assets.\n        Parameters:\n            - other_df: The other asset's data.\n            - figsize: (width, height) for the plot.\n        Returns: \n            A matplotlib `Axes` object.\n        \"\"\"\n        ax = self.fill_between(\n            other_df.open, self.data.close, figsize=figsize, \n            legend_x=0.7, label_higher='asset is higher', \n            label_lower='asset is lower', \n            title='Differential between asset price '\n                  '(this - other)'\n        )\n        ax.set_ylabel('price')\n        return ax\n```", "```py\n    def _window_calc(self, column, periods, name, func, \n                     named_arg, **kwargs):\n        \"\"\"\n        Helper method for plotting a series and adding\n        reference lines using a window calculation.\n        Parameters:\n            - column: The name of the column to plot.\n            - periods: The rule/span or list of them to pass \n              to the resampling/smoothing function, like '20D'\n              for 20-day periods (resampling) or 20 for a \n              20-day span (smoothing)\n            - name: The name of the window calculation (to \n              show in the legend).\n            - func: The window calculation function.\n            - named_arg: The name of the argument `periods` \n              is being passed as.\n            - kwargs: Additional arguments to pass down.\n        Returns:\n            A matplotlib `Axes` object.\n        \"\"\"\n        ax = self.data.plot(y=column, **kwargs)\n        for period in self._iter_handler(periods):\n            self.data[column].pipe(\n                func, **{named_arg: period}\n            ).mean().plot(\n                ax=ax, linestyle='--',\n                label=f\"\"\"{period if isinstance(\n                    period, str\n                ) else str(period) + 'D'} {name}\"\"\"\n            )\n        plt.legend()\n        return ax\n```", "```py\n    def jointplot(self, other, column, **kwargs):\n        \"\"\"\n        Generate a seaborn jointplot for given column in \n        this asset compared to another asset.\n        Parameters:\n            - other: The other asset's dataframe.\n            - column: Column to use for the comparison.\n            - kwargs: Keyword arguments to pass down.\n        Returns: A seaborn jointplot\n        \"\"\"\n        return sns.jointplot(\n            x=self.data[column], y=other[column], **kwargs\n        )\n```", "```py\n    def correlation_heatmap(self, other):\n        \"\"\"\n        Plot the correlations between this asset and another\n        one with a heatmap.\n        Parameters:\n            - other: The other dataframe.\n        Returns: A seaborn heatmap\n        \"\"\"\n        corrs = \\\n            self.data.pct_change().corrwith(other.pct_change())\n        corrs = corrs[~pd.isnull(corrs)]\n        size = len(corrs)\n        matrix = np.zeros((size, size), float)\n        for i, corr in zip(range(size), corrs):\n            matrix[i][i] = corr\n        # create mask to only show diagonal\n        mask = np.ones_like(matrix)\n        np.fill_diagonal(mask, 0)\n        return sns.heatmap(\n            matrix, annot=True, center=0, vmin=-1, vmax=1,\n            mask=mask, xticklabels=self.data.columns, \n            yticklabels=self.data.columns\n        )\n```", "```py\n>>> %matplotlib inline\n>>> import matplotlib.pyplot as plt\n>>> netflix_viz = stock_analysis.StockVisualizer(nflx)\n```", "```py\n>>> ax = netflix_viz.moving_average('close', ['30D', '90D'])\n>>> netflix_viz.shade_region(\n...     ax, x=('2019-10-01', '2020-07-01'), \n...     color='blue', alpha=0.1\n... )\n>>> ax.set(title='Netflix Closing Price', ylabel='price ($)')\n```", "```py\n>>> ax = netflix_viz.exp_smoothing('close', [30, 90]) \n>>> netflix_viz.shade_region(\n...     ax, x=('2020-04-01', '2020-10-01'),\n...     color='blue', alpha=0.1\n... )\n>>> ax.set(title='Netflix Closing Price', ylabel='price ($)')\n```", "```py\n>>> netflix_viz.after_hours_trades()\n```", "```py\n>>> netflix_viz.candlestick(\n...     resample='2W', volume=True, xrotation=90, \n...     datetime_format='%Y-%b –'\n... )\n```", "```py\n>>> import matplotlib as mpl\n>>> mpl.rcdefaults()\n>>> %matplotlib inline\n```", "```py\n>>> netflix_viz.jointplot(sp, 'close')\n```", "```py\n>>> netflix_viz.correlation_heatmap(amzn)\n```", "```py\n>>> tsla = reader.get_ticker_data('TSLA')\n>>> change_date = (tsla.close > nflx.close).idxmax()\n>>> ax = netflix_viz.fill_between_other(tsla)\n>>> netflix_viz.add_reference_line(\n...     ax, x=change_date, color='k', linestyle=':', alpha=0.5,\n...     label=f'TSLA > NFLX {change_date:%Y-%m-%d}'\n... )\n```", "```py\nclass AssetGroupVisualizer(Visualizer):\n    \"\"\"Visualizes groups of assets in a single dataframe.\"\"\"\n    # override for group visuals\n    def __init__(self, df, group_by='name'):\n        \"\"\"This object keeps track of the group by column.\"\"\"\n        super().__init__(df)\n        self.group_by = group_by\n```", "```py\n    def evolution_over_time(self, column, **kwargs):\n        \"\"\"\n        Visualize the evolution over time for all assets.\n        Parameters:\n            - column: The name of the column to visualize.\n            - kwargs: Additional arguments to pass down.\n        Returns: A matplotlib `Axes` object.\n        \"\"\"\n        if 'ax' not in kwargs:\n            fig, ax = plt.subplots(1, 1, figsize=(10, 4))\n        else:\n            ax = kwargs.pop('ax')\n        return sns.lineplot(\n            x=self.data.index, y=column, hue=self.group_by,\n            data=self.data, ax=ax, **kwargs\n        )\n```", "```py\n    def _get_layout(self):\n        \"\"\"\n        Helper method for getting an autolayout of subplots.\n        Returns: `Figure` and `Axes` objects to plot with.\n        \"\"\"\n        subplots_needed = self.data[self.group_by].nunique()\n        rows = math.ceil(subplots_needed / 2)\n        fig, axes = \\\n            plt.subplots(rows, 2, figsize=(15, 5 * rows))\n        if rows > 1:\n            axes = axes.flatten()\n        if subplots_needed < len(axes):\n            # remove excess axes from autolayout\n            for i in range(subplots_needed, len(axes)):\n                # can't use comprehension here\n                fig.delaxes(axes[i])\n        return fig, axes\n```", "```py\n    def _window_calc(self, column, periods, name, func,  \n                     named_arg, **kwargs):\n        \"\"\"\n        Helper method for plotting a series and adding\n        reference lines using a window calculation.\n        Parameters:\n            - column: The name of the column to plot.\n            - periods: The rule/span or list of them to pass \n              to the resampling/smoothing function, like '20D' \n              for 20-day periods (resampling) or 20 for a \n              20-day span (smoothing)\n            - name: The name of the window calculation (to \n              show in the legend).\n            - func: The window calculation function.\n            - named_arg: The name of the argument `periods` \n              is being passed as.\n            - kwargs: Additional arguments to pass down.\n        Returns: \n            A matplotlib `Axes` object.\n        \"\"\"\n        fig, axes = self._get_layout()\n        for ax, asset_name in zip(\n            axes, self.data[self.group_by].unique()\n        ):\n            subset = self.data.query(\n                f'{self.group_by} == \"{asset_name}\"'\n            )\n            ax = subset.plot(\n                y=column, ax=ax, label=asset_name, **kwargs\n            )\n            for period in self._iter_handler(periods):\n                subset[column].pipe(\n                    func, **{named_arg: period}\n                ).mean().plot(\n                    ax=ax, linestyle='--',\n                    label=f\"\"\"{period if isinstance(\n                        period, str\n                    ) else str(period) + 'D'} {name}\"\"\"\n                )\n            ax.legend()\n         plt.tight_layout()\n         return ax\n```", "```py\n    def after_hours_trades(self):\n        \"\"\"\n        Visualize the effect of after-hours trading.\n        Returns: A matplotlib `Axes` object.\n        \"\"\"\n        num_categories = self.data[self.group_by].nunique()\n        fig, axes = plt.subplots(\n            num_categories, 2, figsize=(15, 3 * num_categories)\n        )\n        for ax, (name, data) in zip(\n            axes, self.data.groupby(self.group_by)\n        ):\n            after_hours = data.open - data.close.shift()\n            monthly_effect = after_hours.resample('1M').sum()\n            after_hours.plot(\n                ax=ax[0], \n                title=f'{name} Open Price - Prior Day\\'s Close'\n            ).set_ylabel('price')\n            monthly_effect.index = \\\n                monthly_effect.index.strftime('%Y-%b')\n            monthly_effect.plot(\n                ax=ax[1], kind='bar', rot=90,\n                color=np.where(monthly_effect >= 0, 'g', 'r'),\n                title=f'{name} after-hours trading '\n                      'monthly effect'\n            ).axhline(0, color='black', linewidth=1)\n            ax[1].set_ylabel('price')\n        plt.tight_layout()\n        return axes\n```", "```py\n    def pairplot(self, **kwargs):\n        \"\"\"\n        Generate a seaborn pairplot for this asset group.\n        Parameters:\n            - kwargs: Keyword arguments to pass down.\n        Returns: A seaborn pairplot\n        \"\"\"\n        return sns.pairplot(\n            self.data.pivot_table(\n                values='close', index=self.data.index, \n                columns=self.group_by\n            ), diag_kind='kde', **kwargs\n        )\n```", "```py\n    def heatmap(self, pct_change=True, **kwargs):\n        \"\"\"\n        Generate a heatmap for correlations between assets.\n        Parameters:\n            - pct_change: Whether to show the correlations \n              of the daily percent change in price.\n            - kwargs: Keyword arguments to pass down.\n        Returns: A seaborn heatmap\n        \"\"\"\n        pivot = self.data.pivot_table(\n            values='close', index=self.data.index, \n            columns=self.group_by\n        )\n        if pct_change:\n            pivot = pivot.pct_change()\n        return sns.heatmap(\n            pivot.corr(), annot=True, center=0, \n            vmin=-1, vmax=1, **kwargs\n        )\n```", "```py\n>>> all_assets_viz = \\\n...     stock_analysis.AssetGroupVisualizer(all_assets)\n>>> all_assets_viz.heatmap()\n```", "```py\n>>> faang_sp_viz = \\\n...     stock_analysis.AssetGroupVisualizer(faang_sp)\n>>> bitcoin_viz = stock_analysis.StockVisualizer(bitcoin)\n>>> fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n>>> faang_sp_viz.evolution_over_time(\n...     'close', ax=axes[0], style=faang_sp_viz.group_by\n... )\n>>> bitcoin_viz.evolution_over_time(\n...     'close', ax=axes[1], label='Bitcoin'\n... )\n```", "```py\n\"\"\"Classes for technical analysis of assets.\"\"\"\nimport math\nfrom .utils import validate_df\n```", "```py\nclass StockAnalyzer:\n    \"\"\"Provides metrics for technical analysis of a stock.\"\"\"\n    @validate_df(columns={'open', 'high', 'low', 'close'})\n    def __init__(self, df):\n        \"\"\"Create a `StockAnalyzer` object with OHLC data\"\"\"\n        self.data = df\n```", "```py\n    @property\n    def close(self):\n        \"\"\"Get the close column of the data.\"\"\"\n        return self.data.close\n```", "```py\n    @property\n    def pct_change(self):\n        \"\"\"Get the percent change of the close column.\"\"\"\n        return self.close.pct_change()\n```", "```py\n    @property\n    def pivot_point(self):\n        \"\"\"Calculate the pivot point.\"\"\"\n        return (self.last_close + self.last_high\n                + self.last_low) / 3\n```", "```py\n    @property\n    def last_close(self):\n        \"\"\"Get the value of the last close in the data.\"\"\"\n        return self.data.last('1D').close.iat[0]\n    @property\n    def last_high(self):\n        \"\"\"Get the value of the last high in the data.\"\"\"\n        return self.data.last('1D').high.iat[0]\n    @property\n    def last_low(self):\n        \"\"\"Get the value of the last low in the data.\"\"\"\n        return self.data.last('1D').low.iat[0]\n```", "```py\n    def resistance(self, level=1):\n        \"\"\"Calculate the resistance at the given level.\"\"\"\n        if level == 1:\n            res = (2 * self.pivot_point) - self.last_low\n        elif level == 2:\n            res = self.pivot_point \\\n                  + (self.last_high - self.last_low)\n        elif level == 3:\n            res = self.last_high \\\n                  + 2 * (self.pivot_point - self.last_low)\n        else:\n            raise ValueError('Not a valid level.')\n        return res\n```", "```py\n    def support(self, level=1):\n        \"\"\"Calculate the support at the given level.\"\"\"\n        if level == 1:\n            sup = (2 * self.pivot_point) - self.last_high\n        elif level == 2:\n            sup = self.pivot_point \\\n                  - (self.last_high - self.last_low)\n        elif level == 3:\n            sup = self.last_low \\\n                  - 2 * (self.last_high - self.pivot_point)\n        else:\n            raise ValueError('Not a valid level.')\n        return sup\n```", "```py\n    @property\n    def _max_periods(self):\n        \"\"\"Get the number of trading periods in the data.\"\"\"\n        return self.data.shape[0]\n```", "```py\n    def daily_std(self, periods=252):\n        \"\"\"\n        Calculate daily standard deviation of percent change.\n        Parameters:\n            - periods: The number of periods to use for the\n              calculation; default is 252 for the trading days \n              in a year. Note if you provide a number greater  \n              than the number of trading periods in the data,\n              `self._max_periods` will be used instead.\n        Returns: The standard deviation\n        \"\"\"\n        return self.pct_change\\\n            [min(periods, self._max_periods) * -1:].std()\n```", "```py\n    def annualized_volatility(self):\n        \"\"\"Calculate the annualized volatility.\"\"\"\n        return self.daily_std() * math.sqrt(252)\n```", "```py\n    def volatility(self, periods=252):\n        \"\"\"Calculate the rolling volatility.\n        Parameters:\n            - periods: The number of periods to use for the \n              calculation; default is 252 for the trading  \n              days in a year. Note if you provide a number  \n              greater than the number of trading periods in the\n              data, `self._max_periods` will be used instead.\n        Returns: A `pandas.Series` object.\n        \"\"\"\n        periods = min(periods, self._max_periods)\n        return self.close.rolling(periods).std()\\\n               / math.sqrt(periods)\n```", "```py\n    def corr_with(self, other):\n        \"\"\"Calculate the correlations between dataframes.\n        Parameters:\n            - other: The other dataframe.\n        Returns: A `pandas.Series` object\n        \"\"\"\n        return \\\n            self.data.pct_change().corrwith(other.pct_change())\n```", "```py\n    def cv(self):\n        \"\"\"\n        Calculate the coefficient of variation for the asset.\n        The lower this is, the better the risk/return tradeoff.\n        \"\"\"\n        return self.close.std() / self.close.mean()\n    def qcd(self):\n        \"\"\"Calculate the quantile coefficient of dispersion.\"\"\"\n        q1, q3 = self.close.quantile([0.25, 0.75])\n        return (q3 - q1) / (q3 + q1) \n```", "```py\n    def beta(self, index):\n        \"\"\"\n        Calculate the beta of the asset.\n        Parameters:\n            - index: The data for the index to compare to.\n        Returns: \n            Beta, a float.\n        \"\"\"\n        index_change = index.close.pct_change()\n        beta = self.pct_change.cov(index_change)\\\n               / index_change.var()\n        return beta\n```", "```py\n    def cumulative_returns(self):\n        \"\"\"Calculate cumulative returns for plotting.\"\"\"\n        return (1 + self.pct_change).cumprod()\n```", "```py\n    @staticmethod\n    def portfolio_return(df):\n        \"\"\"\n        Calculate return assuming no distribution per share.\n        Parameters:\n            - df: The asset's dataframe.\n        Returns: The return, as a float.\n        \"\"\"\n        start, end = df.close[0], df.close[-1]\n        return (end - start) / start\n```", "```py\n    def alpha(self, index, r_f):\n        \"\"\"\n        Calculates the asset's alpha.\n        Parameters:\n            - index: The index to compare to.\n            - r_f: The risk-free rate of return.\n        Returns: Alpha, as a float.\n        \"\"\"\n        r_f /= 100\n        r_m = self.portfolio_return(index)\n        beta = self.beta(index)\n        r = self.portfolio_return(self.data)\n        alpha = r - r_f - beta * (r_m - r_f)\n        return alpha\n```", "```py\nr_f by 100 before storing the result back in r_f. It's shorthand for r_f = r_f / 100. Python also has these operators for other arithmetic functions—for example, +=, -=, *=, and %=.\n```", "```py\n    def is_bear_market(self):\n        \"\"\"\n        Determine if a stock is in a bear market, meaning its\n        return in the last 2 months is a decline of 20% or more\n        \"\"\"\n        return \\\n            self.portfolio_return(self.data.last('2M')) <= -.2\n    def is_bull_market(self):\n        \"\"\"\n        Determine if a stock is in a bull market, meaning its\n        return in the last 2 months is an increase of >= 20%.\n        \"\"\"\n        return \\\n            self.portfolio_return(self.data.last('2M')) >= .2\n```", "```py\n    def sharpe_ratio(self, r_f):\n        \"\"\"\n        Calculates the asset's Sharpe ratio.\n        Parameters:\n            - r_f: The risk-free rate of return.\n        Returns: \n            The Sharpe ratio, as a float.\n        \"\"\"\n        return (\n            self.cumulative_returns().last('1D').iat[0] - r_f\n        ) / self.cumulative_returns().std()\n```", "```py\nclass AssetGroupAnalyzer:\n    \"\"\"Analyzes many assets in a dataframe.\"\"\"\n    @validate_df(columns={'open', 'high', 'low', 'close'})\n    def __init__(self, df, group_by='name'):\n        \"\"\"\n        Create an `AssetGroupAnalyzer` object with a \n        dataframe of OHLC data and column to group by.\n        \"\"\"\n        self.data = df \n        if group_by not in self.data.columns:\n            raise ValueError(\n                f'`group_by` column \"{group_by}\" not in df.'\n) \n        self.group_by = group_by\n        self.analyzers = self._composition_handler()\n    def _composition_handler(self):\n        \"\"\"\n        Create a dictionary mapping each group to its analyzer,\n        taking advantage of composition instead of inheritance.\n        \"\"\"\n        return {\n            group: StockAnalyzer(data)\n            for group, data in self.data.groupby(self.group_by)\n        }\n```", "```py\n    def analyze(self, func_name, **kwargs):\n        \"\"\"\n        Run a `StockAnalyzer` method on all assets.\n        Parameters:\n            - func_name: The name of the method to run.\n            - kwargs: Additional arguments to pass down.\n        Returns: \n            A dictionary mapping each asset to the result \n            of the calculation of that function.\n        \"\"\"\n        if not hasattr(StockAnalyzer, func_name):\n            raise ValueError(\n                f'StockAnalyzer has no \"{func_name}\" method.'\n            )\n        if not kwargs:\n            kwargs = {}\n        return {\n            group: getattr(analyzer, func_name)(**kwargs)\n            for group, analyzer in self.analyzers.items()\n        }\n```", "```py\n>>> all_assets_analyzer = \\\n...     stock_analysis.AssetGroupAnalyzer(all_assets)\n```", "```py\n>>> all_assets_analyzer.analyze('cv')\n{'Amazon': 0.2658012522278963,\n 'Apple': 0.36991905161737615,\n 'Bitcoin': 0.43597652683008137,\n 'Facebook': 0.19056336194852783,\n 'Google': 0.15038618497328074,\n 'Netflix': 0.20344854330432688,\n 'S&P 500': 0.09536374658108937}\n```", "```py\n>>> all_assets_analyzer.analyze('annualized_volatility')\n{'Amazon': 0.3851099077041784,\n 'Apple': 0.4670809643500882,\n 'Bitcoin': 0.4635140114227397,\n 'Facebook': 0.45943066572169544,\n 'Google': 0.3833720603377728,\n 'Netflix': 0.4626772090887299,\n 'S&P 500': 0.34491195196047003}\n```", "```py\n>>> all_assets_analyzer.analyze('is_bull_market')\n{'Amazon': False,\n 'Apple': True,\n 'Bitcoin': True,\n 'Facebook': False,\n 'Google': False,\n 'Netflix': False,\n 'S&P 500': False}\n```", "```py\n>>> all_assets_analyzer.analyze('beta', index=sp)\n{'Amazon': 0.7563691182389207,\n 'Apple': 1.173273501105916,\n 'Bitcoin': 0.3716024282483362,\n 'Facebook': 1.024592821854751,\n 'Google': 0.98620762504024,\n 'Netflix': 0.7408228073823271,\n 'S&P 500': 1.0000000000000002}\n```", "```py\n>>> r_f = reader.get_risk_free_rate_of_return() # 0.93\n>>> all_assets_analyzer.analyze('alpha', index=sp, r_f=r_f)\n{'Amazon': 0.7383391908270172,\n 'Apple': 1.7801122522388666,\n 'Bitcoin': 6.355297988074054,\n 'Facebook': 0.5048625273190841,\n 'Google': 0.18537197824248092,\n 'Netflix': 0.6500392764754642,\n 'S&P 500': -1.1102230246251565e-16}\n```", "```py\n>>> from cycler import cycler\n>>> bw_viz_cycler = (\n...     cycler(color=[plt.get_cmap('tab10')(x/10)\n...                   for x in range(10)])\n...     + cycler(linestyle=['dashed', 'solid', 'dashdot',\n...                         'dotted', 'solid'] * 2))\n>>> fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n>>> axes[0].set_prop_cycle(bw_viz_cycler)\n>>> cumulative_returns = \\\n...     all_assets_analyzer.analyze('cumulative_returns')\n>>> for name, data in cumulative_returns.items():\n...     data.plot(\n...         ax=axes[1] if name == 'Bitcoin' else axes[0], \n...         label=name, legend=True\n...     )\n>>> fig.suptitle('Cumulative Returns')\n```", "```py\n\"\"\"Simple time series modeling for stocks.\"\"\"\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom statsmodels.tsa.arima.model import ARIMA\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nimport statsmodels.api as sm\nfrom .utils import validate_df\n```", "```py\nclass StockModeler:\n    \"\"\"Static methods for modeling stocks.\"\"\"\n    def __init__(self):\n        raise NotImplementedError(\n            \"This class must be used statically: \" \n            \"don't instantiate it.\"\n        )\n```", "```py\n    @staticmethod\n    @validate_df(columns={'close'}, instance_method=False)\n    def decompose(df, period, model='additive'):\n        \"\"\"\n        Decompose the closing price of the stock into \n        trend, seasonal, and remainder components.\n        Parameters:\n            - df: The dataframe containing the stock closing\n              price as `close` and with a time index.\n            - period: The number of periods in the frequency.\n            - model: How to compute the decomposition\n              ('additive' or 'multiplicative')\n        Returns:\n            A `statsmodels` decomposition object.\n        \"\"\"\n        return seasonal_decompose(\n            df.close, model=model, period=period\n        )\n```", "```py\nstaticmethod(\n    validate_df(\n        decompose, columns={'close'}, instance_method=False\n    )\n)\n```", "```py\n    @staticmethod\n    @validate_df(columns={'close'}, instance_method=False)\n    def arima(df, *, ar, i, ma, fit=True, freq='B'):\n        \"\"\"\n        Create an ARIMA object for modeling time series.\n        Parameters:\n            - df: The dataframe containing the stock closing\n              price as `close` and with a time index.\n            - ar: The autoregressive order (p).\n            - i: The differenced order (q).\n            - ma: The moving average order (d).\n            - fit: Whether to return the fitted model\n            - freq: Frequency of the time series\n        Returns: \n            A `statsmodels` ARIMA object which you can use \n            to fit and predict.\n        \"\"\"\n        arima_model = ARIMA(\n            df.close.asfreq(freq).fillna(method='ffill'), \n            order=(ar, i, ma)\n        )\n        return arima_model.fit() if fit else arima_model\n```", "```py\n    @staticmethod\n    @validate_df(columns={'close'}, instance_method=False)\n    def arima_predictions(df, arima_model_fitted, start, end,       \n                          plot=True, **kwargs):\n        \"\"\"\n        Get ARIMA predictions as a `Series` object or plot.\n        Parameters:\n            - df: The dataframe for the stock.\n            - arima_model_fitted: The fitted ARIMA model.\n            - start: The start date for the predictions.\n            - end: The end date for the predictions.\n            - plot: Whether to plot the result, default is\n              `True` meaning the plot is returned instead of\n              the `Series` object containing the predictions.\n            - kwargs: Additional arguments to pass down.\n        Returns: \n            A matplotlib `Axes` object or predictions \n            depending on the value of the `plot` argument.\n        \"\"\"\n        predictions = \\\n            arima_model_fitted.predict(start=start, end=end)\n        if plot:\n            ax = df.close.plot(**kwargs)\n            predictions.plot(\n                ax=ax, style='r:', label='arima predictions'\n            )\n            ax.legend()\n        return ax if plot else predictions\n```", "```py\n    @staticmethod\n    @validate_df(columns={'close'}, instance_method=False)\n    def regression(df):\n        \"\"\"\n        Create linear regression of time series with lag=1.\n        Parameters:\n            - df: The dataframe with the stock data.\n        Returns: \n            X, Y, and the fitted model\n        \"\"\"\n        X = df.close.shift().dropna()\n        Y = df.close[1:]\n        return X, Y, sm.OLS(Y, X).fit()\n```", "```py\n    @staticmethod\n    @validate_df(columns={'close'}, instance_method=False)\n    def regression_predictions(df, model, start, end, \n                               plot=True, **kwargs):\n        \"\"\"\n        Get linear regression predictions as a `pandas.Series`\n        object or plot.\n        Parameters:\n            - df: The dataframe for the stock.\n            - model: The fitted linear regression model.\n            - start: The start date for the predictions.\n            - end: The end date for the predictions.\n            - plot: Whether to plot the result, default is\n              `True` meaning the plot is returned instead of\n              the `Series` object containing the predictions.\n            - kwargs: Additional arguments to pass down.\n        Returns: \n            A matplotlib `Axes` object or predictions \n            depending on the value of the `plot` argument.\n        \"\"\"\n        predictions = pd.Series(\n            index=pd.date_range(start, end), name='close'\n        )\n        last = df.last('1D').close\n        for i, date in enumerate(predictions.index):\n            if not i:\n                pred = model.predict(last)\n            else:\n                pred = model.predict(predictions.iloc[i - 1])\n            predictions.loc[date] = pred[0]\n        if plot:\n            ax = df.close.plot(**kwargs)\n            predictions.plot(\n                ax=ax, style='r:', \n                label='regression predictions'\n            )\n            ax.legend()\n        return ax if plot else predictions\n```", "```py\n    @staticmethod\n    def plot_residuals(model_fitted, freq='B'):\n        \"\"\"\n        Visualize the residuals from the model.\n        Parameters:\n            - model_fitted: The fitted model\n            - freq: Frequency that the predictions were \n              made on. Default is 'B' (business day).\n        Returns: \n            A matplotlib `Axes` object.\n        \"\"\"\n        fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n        residuals = pd.Series(\n            model_fitted.resid.asfreq(freq), name='residuals'\n        )\n        residuals.plot(\n            style='bo', ax=axes[0], title='Residuals'\n        )\n        axes[0].set(xlabel='Date', ylabel='Residual')\n        residuals.plot(\n            kind='kde', ax=axes[1], title='Residuals KDE'\n        )\n        axes[1].set_xlabel('Residual')\n        return axes\n```", "```py\n>>> from stock_analysis import StockModeler\n>>> decomposition = StockModeler.decompose(nflx, 20)\n>>> fig = decomposition.plot()\n>>> fig.suptitle(\n...     'Netflix Stock Price Time Series Decomposition', y=1\n... )\n>>> fig.set_figheight(6)\n>>> fig.set_figwidth(10)\n>>> fig.tight_layout()\n```", "```py\n>>> %%capture\n>>> arima_model = StockModeler.arima(nflx, ar=10, i=1, ma=5)\n```", "```py\n>>> print(arima_model.summary())\n```", "```py\n>>> StockModeler.plot_residuals(arima_model)\n```", "```py\n>>> X, Y, lm = StockModeler.regression(nflx)\n>>> print(lm.summary())\n```", "```py\n>>> StockModeler.plot_residuals(lm)\n```", "```py\n>>> import datetime as dt\n>>> start = dt.date(2021, 1, 1)\n>>> end = dt.date(2021, 1, 14)\n>>> jan = stock_analysis.StockReader(start, end)\\\n...     .get_ticker_data('NFLX')\n>>> fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n>>> arima_ax = StockModeler.arima_predictions(\n...     nflx, arima_model, start=start, end=end, \n...     ax=axes[0], title='ARIMA', color='b'\n... )\n>>> jan.close.plot(\n...     ax=arima_ax, style='b--', label='actual close'\n... )\n>>> arima_ax.legend()\n>>> arima_ax.set_ylabel('price ($)')\n>>> linear_reg = StockModeler.regression_predictions(\n...     nflx, lm, start=start, end=end,\n...     ax=axes[1], title='Linear Regression', color='b'\n... )\n>>> jan.close.plot(\n...     ax=linear_reg, style='b--', label='actual close'\n... )\n>>> linear_reg.legend()\n>>> linear_reg.set_ylabel('price ($)')\n```"]