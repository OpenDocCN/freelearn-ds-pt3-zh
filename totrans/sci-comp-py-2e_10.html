<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Series and Dataframes - Working with Pandas
                </header>
            
            <article>
                
<p>In this chapter, we give a brief introduction to pandas—the central tool in Python for data analysis and data handling. You will learn how to work with various time series in Python, the concept of dataframes, and how to access and visualize data. You will also find examples that demonstrate how smoothly pandas interacts with the other central modules in this book, namely NumPy and Matplotlib.</p>
<p>But please note, this chapter can, within the scope of this book, only serve as an <em>appetizer</em>. Its purpose is to equip you with the basic concepts. The full range of visualization, data analysis, and data conversion tools in pandas is impressive.</p>
<p>pandas offers many ways of importing data. Some of them will be presented together with guiding examples throughout this chapter.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>A guiding example: Solar cells</li>
<li>NumPy arrays and pandas DataFrames</li>
<li>Creating and modifying dataframes</li>
<li>Working with dataframes</li>
</ul>
<h1 id="uuid-0b975212-cb50-47b9-8c16-230c758121f9">10. 1 A guiding example: Solar cells</h1>
<p>To describe pandas in the best way, we need data. Thus, in this chapter, we will use production data from solar cell panels on the roof of a private house in the south of Sweden.</p>
<p>In the file <kbd>solarWatts.dat</kbd> there is data about the electricity production <span>in watts </span>per minute. A semicolon is used as a data separator and the first line in the file is a header line, explaining the content of the data columns:</p>
<pre>Date;Watt<br/>           :<br/>2019-10-20 08:22:00 ; 44.0<br/>2019-10-20 08:23:00 ; 61.0<br/>2019-10-20 08:24:00 ; 42.0<br/>           :</pre>
<p>In another file, <kbd>price.dat</kbd>, we find the hourly electricity production price in Swedish crowns. The file is otherwise organized as before:</p>
<pre>Date;SEK<br/>2019-10-20 01:00 ; 0.32<br/>2019-10-20 02:00 ; 0.28<br/>2019-10-20 03:00 ; 0.29<br/>       :</pre>
<p>Finally, in a third file, <kbd>rates.dat</kbd>, we find the daily conversion rates from Swedish crowns to Euros (€):</p>
<pre>Date;Euro_SEK<br/>2019-10-21 ; 10.7311<br/>2019-10-22 ; 10.7303<br/>2019-10-23 ; 10.7385<br/>       :</pre>
<p>We want to extract from this data information about the maximal and minimal production per day, the number of hours of <span>sun</span><span> </span><span>per month, the sunniest day so far, information about sunrise and sunset, and some economic information. We <span>also </span>aim to graphically present data.</span></p>
<p>Note, the data is not collected at the same time points and there might be missing data.</p>
<p>Each file contains a so-called time-series, that is, <span>data </span>depending on <span>time </span>or a discrete sampling of a time-depending function.</p>
<p>We now introduce the concept of dataframes in pandas and compare it to NumPy arrays.</p>
<h1 id="uuid-da6a1c26-70e5-4491-9525-bf3345468d57" class="mce-root">10.2 NumPy arrays and pandas dataframes</h1>
<p class="mce-root">Let's start by just looking at an example of a <sub><img class="fm-editor-equation" src="assets/6bc9c04c-a8b4-41ae-82b5-1760f08e0e9d.png" style="width:3.00em;height:1.17em;"/></sub> NumPy array:</p>
<pre class="mce-root">A=array( [[ 1., 2., 3.],<br/>          [4., 5., 6.]])</pre>
<p class="mce-root">It is displayed as:</p>
<pre class="mce-root">[[1. 2. 3.]<br/> [4. 5. 6.]]</pre>
<p>And its elements are accessed by using indexes generated simply by counting rows and columns, for example, <kbd>A[0,1]</kbd>.</p>
<p class="mce-root">This matrix can be converted to the pandas datatype <kbd>DataFrame</kbd> by keeping the same data and order but representing and accessing it in a different way:</p>
<pre class="mce-root">import pandas as pd<br/>A=array( [[ 1., 2., 3.],<br/>          [ 4., 5., 6.]] )<br/>AF = pd.DataFrame(A)</pre>
<p class="mce-root">This <kbd><span>DataFrame</span></kbd> object, which we will explain in more detail in this chapter, is displayed as</p>
<pre class="mce-root"><br/>      0   1  2<br/> 0   1.0 2.0 3.0<br/> 1   4.0 5.0 6.0</pre>
<p class="mce-root">We see that a pandas dataframe has extra labels for the rows and columns called <em>index</em> and <em>columns</em>. These are the metadata of a dataframe.</p>
<p class="mce-root">Here, they coincide with NumPy's indexing, but that is not always so. The index and columns metadata allows the pandas dataframe to label the data in a way that's known from classical table design:</p>
<pre class="mce-root">AF.columns = ['C1','C2','C3']     <br/>AF.index = ['R1', 'R2']</pre>
<p class="mce-root">This gives us the following output:</p>
<pre class="mce-root">    C1 C2 C3<br/>R1 1.0 2.0 3.0<br/>R2 4.0 5.0 6.0</pre>
<p class="mce-root">We will see now how to work with these labels to address a subframe or just a value in the dataframe.</p>
<h2 id="uuid-cb7e2972-df13-4901-878b-0706e68bb5f0">10.2.1 Indexing rules</h2>
<p>Similar to the way dictionaries use keys to address a value, pandas dataframes use row labels—the dataframe index<span>—</span>and column labels to access individual values:</p>
<pre>AF.loc['R1', 'C2']      # this returns 2.0 </pre>
<p class="mce-root">Or to generate a subframe:</p>
<pre>AF.loc[['R1','R2'],['C1','C2']]</pre>
<p class="mce-root">Resulting in:</p>
<pre>   C1   C2<br/>R1  1  2.0<br/>R2  4  5.0</pre>
<p>You can also address a complete row by using the index label:</p>
<pre>AF.loc['R1']</pre>
<p class="CDPAlignLeft CDPAlign">This returns a pandas <kbd>Series</kbd> object:</p>
<pre>C1    1.0<br/>C2    2.0<br/>C3    3.0<br/>Name: R1, dtype: float64</pre>
<p class="mce-root">If<span> </span><kbd>loc</kbd><span> </span>or<span> </span><kbd>iloc</kbd><span> </span>are called with list arguments or slices, the result is a dataframe.</p>
<p>In that way, an individual dataframe element can also be addressed as follows:</p>
<pre>AF.loc['R1'].loc['C1']    # returns 1.0</pre>
<p>An entire column is addressed directly as follows:</p>
<pre>AF['C1']</pre>
<p>This <span>again</span><span> </span><span>returns a pandas <kbd>Series</kbd> object:</span></p>
<pre>R1    1.0<br/>R2    4.0<br/>Name: C1, dtype: float64</pre>
<p>Alternatively, the column label can be used as an attribute, <kbd>AF.C1</kbd>.</p>
<p class="mce-root">A single column is an instance of the pandas datatype, <kbd>Series</kbd>.</p>
<pre class="mce-root">type(AF.C1) == pd.Series # True </pre>
<p class="mce-root">Note, a pandas series has no column label. It is just a single column corresponding to a single type of measured data.</p>
<p class="mce-root">Still, you can use classical indexing by applying the dataframe method <kbd>iloc</kbd>:</p>
<pre class="mce-root">AF.iloc[[0],[1]]</pre>
<p class="mce-root">This returns:</p>
<pre class="mce-root">    C2<br/> R1 2.0</pre>
<p class="mce-root">If <kbd>loc</kbd> or <kbd>iloc</kbd> are called with list arguments or slices, the result is a dataframe:</p>
<pre class="mce-root">AF.loc['R1':,'C2':] </pre>
<p class="mce-root">Or equivalently:</p>
<pre class="mce-root">AF.loc[['R1','R2'], ['C2','C2']]</pre>
<p class="mce-root">While calling with a pair of single labels just gives an element of the dataframe:</p>
<pre class="mce-root">AF.loc['R1','C2'] # returns 2.0</pre>
<p class="mce-root">This is in full agreement with the way NumPy handles the indexing of arrays. Recall that indexing with slices returns an array, while indexing with single integers returns a single element of the indexed array.</p>
<p class="mce-root">It is important to note that <kbd>loc</kbd> and <kbd>iloc</kbd> are not dataframe methods. Rather, they are attributes that have <kbd>__getitem__</kbd> method; see also <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.1.5</a>: <em>Special methods</em>. That explains the use of brackets instead of parentheses.</p>
<h1 id="uuid-ebf969a4-934e-4e6a-9af7-b93aeeaf20dc">10.3 Creating and modifying dataframes</h1>
<p>We return now to the solar cell data and explain how to create a dataframe from a data file. The format of the file with the given data is CSV. Each line in the file contains one data record with a comma or another character string as a data separator. Here, we used a semicolon as a separator because in many countries the comma is used instead of a decimal separator.</p>
<h2 id="uuid-1e70d485-5930-472d-b148-d0020361809c">10.3.1 Creating a dataframe from imported data</h2>
<p>We want to organize the dataframe in such a way that the dates are used as the index of the dataframe. To be better prepared for operating with dates, we also want that the data import process automatically converts date strings to a pandas <kbd>Timestamp</kbd> object. Finally, you might have noted that the way the date is written in the data files is in the ISO-format <kbd>YY-MM-DD</kbd> format and not in the American <kbd>MM-DD-YY</kbd> or the European <kbd>DD-MM-YY</kbd> format. We can put on our wishlist that pandas automatically recognizes the date format and performs the correct conversion:</p>
<pre>solarWatts = pd.read_csv("solarWatts.dat", <br/>                         sep=';',<br/>                         index_col='Date',<br/>                         parse_dates=[0], infer_datetime_format=True)</pre>
<p>The pandas command <kbd>read_csv</kbd> is the central tool. It has many more parameters than we used here and carefully studying their functionalities saves a lot of programming effort.</p>
<p>We now have a pandas dataframe, <kbd>solarWatts</kbd>, with more than 200,000 data records. Let's directly check the first one:</p>
<pre class="mce-root">solarWatts.iloc[0] </pre>
<p class="mce-root">This returns the following output:</p>
<pre class="mce-root">Watt    7893.0<br/>Name: 2019-10-06 13:23:00, dtype: float64</pre>
<p class="mce-root">We can also ask for the last date. To this end, we use the <span>attribute</span> <kbd>index</kbd> of the dataframe:</p>
<pre>solarWatts.index[-1]   # asking for the last index</pre>
<p> </p>
<p>This returns a pandas <kbd>Timestamp</kbd> object <kbd>Timestamp('2020-06-27 17:54:00')</kbd>. This object or its string representation can be used for indexing.</p>
<p><kbd>Timestamp</kbd> objects make it easy to perform calculations with dates, define time ranges, and compare dates. We can check how much time passed between the measurements:</p>
<pre># returns: Timedelta('0 days 00:01:00')<br/>solarWatts.index[1]-solarWatts.index[0]</pre>
<p>The resulting <span>object</span> <kbd>Timedelta</kbd> tells us that the time elapsed between the first and second records is one minute.</p>
<p>But is all data collected every minute? As pandas is compatible with NumPy, we can apply Numpy's command <kbd>diff</kbd>, which returns an array with the datatype <kbd>timedelta64[ns]</kbd>, that is, the differences are given in nanoseconds. We convert the result directly to minutes and ask for the maximal difference:</p>
<pre>max(numpy.diff(solarWatts.index).astype('timedelta64[m]'))</pre>
<p>With <kbd>numpy.argmax</kbd>, we find the corresponding date:</p>
<pre>solarWatts.iloc[np.argmax(np.diff(solarWatts.index))</pre>
<p>In this piece of code, we first form an array with the time differences (<kbd>timedelta</kbd>). We use this as an index to locate the data record in the pandas dataframe.</p>
<h2 id="uuid-b9d0ff2d-6974-4013-acc2-1724364e48f6">10.3.2 Setting the index</h2>
<p>The default index of a dataframe is the row numbers. These are generated automatically when a dataframe is created and no index is specified. Here is an example.</p>
<p>We create a dataframe from a list of lists:</p>
<pre>towns=[['Stockholm', 'Sweden', 188,975904],<br/>       ['Malmö', 'Sweden', 322, 316588],<br/>       ['Oslo', 'Norway', 481, 693491],<br/>       ['Bergen', 'Norway', 464, 28392]]<br/>town=pd.DataFrame(towns, columns=['City','Country','area','population'])</pre>
<p>This produces a dataframe with rows labeled by their row numbers:</p>
<pre>        City Country  area  population<br/>0  Stockholm  Sweden   188      975904<br/>1      Malmö  Sweden   322      316588<br/>2       Oslo  Norway   481      693491<br/>3     Bergen  Norway   464      28392</pre>
<p>We can change this by choosing a column to be the index. The column can be duplicated<span>—</span>one serving as the index and the other belonging to the data section of the dataframe—or it can be moved to replace the default index column:</p>
<pre>town.set_index('City', drop=False)      # duplicating<br/># droping the column and making an index out of it<br/>town.set_index('City', drop=True)</pre>
<p> </p>
<p>A <em>new</em> dataframe is generated, which looks like this when the <kbd>drop</kbd> parameter was set to <kbd>True</kbd> (default):</p>
<pre>          Country  area  population<br/>City                               <br/>Stockholm  Sweden   188      975904<br/>Malmö      Sweden   322      316588<br/>Oslo       Norway   481      693491<br/>Bergen     Norway   464      283929<br/>Trondheim  Norway   322      199039</pre>
<p>The additional parameter <kbd>inplace</kbd> enables to change the dataframe directly, that is, <em>in place</em>, without generating a new object.</p>
<p>pandas is not restricted to one index only; indeed, several columns can be chosen as an index. Such a multi-index opens for <strong>hierarchical indexing</strong>, a feature of pandas which we will meet again in <a href="6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml">Section 10.4.3</a>: <em>Grouping data</em><em>.<br/></em></p>
<p>Several indexes are specified by a list of columns:</p>
<pre>town.set_index(['Country','City'], inplace=True)</pre>
<p>This gives us the following output:</p>
<pre>                   area  population<br/>Country City                       <br/>Sweden  Stockholm   188      975904<br/>        Malmö       322      316588<br/>Norway  Oslo        481      693491</pre>
<p>Note how the dataframe is displayed now: the first index, <kbd>Country</kbd>, is taken as the one with higher hierarchy level than the second index, <kbd>City</kbd>.</p>
<p>We can address all Swedish towns in the frame as shown here:</p>
<pre>town.loc['Sweden']</pre>
<p>We can even address a particular one:</p>
<pre>town.loc[('Sweden','Malmö')]</pre>
<h2 id="uuid-6e210777-8d90-4264-a800-b88df27fb6b1">10.3.3 Deleting entries</h2>
<p>Entries in a dataframe are deleted by the method <kbd>drop</kbd>.</p>
<p>Again, we use the dataframe from the previous section:</p>
<pre>town=pd.DataFrame(towns, columns=['City','Country','area','population'])<br/>town.set_index('City', inplace=True)</pre>
<p>An entire row is deleted by:</p>
<pre>town.drop('Bergen', axis=0)</pre>
<p>The <span>parameter </span><kbd>axis</kbd> specifies here that we look for a row. Deleting a row requires the column label and the correct <span>parameter</span> <kbd>axis</kbd>:</p>
<pre>town.drop('area', axis=1)</pre>
<h2 id="uuid-e44495c0-2d21-4b16-a1be-c388a18aad79">10.3.4 Merging dataframes</h2>
<p>From the three datafiles we provided for this chapter we used the first one, <kbd>solarwatts.dat</kbd>, to set up a dataframe <kbd>solarWatts</kbd>; see <a href="6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml">Section 10.3.1</a>, <em>Creating a dataframe from imported data</em>. In a similar way, we can create dataframes <kbd>price</kbd> and <kbd>rates</kbd> from the other two files.</p>
<p>We show now how to merge these three dataframes into one and to treat rows with missing data in the resulting dataframe.</p>
<p>First, we merge <kbd>solarWatts</kbd> with <kbd>price</kbd>. For this, we use the pandas command <kbd>merge</kbd>:</p>
<pre>solar_all=pd.merge(solarWatts, price, how='outer', sort=True, on='Date')<br/>solar_all=pd.merge(solar_all, rates, how='outer', sort=True, on='Date')</pre>
<p>It sets the column <kbd>Date</kbd>, which exists in both dataframes as the index of the new frame. The parameter <kbd>how</kbd> defines how to set up the new index column. By specifying <kbd>outer</kbd> we decided to choose the union of both index columns. Finally, we want to sort the index.</p>
<p>As <kbd>solarWatts</kbd> has data for every minute and the price changes on an hourly basis, we obtain in the new dataframe lines like the following:</p>
<pre>                       Watt  SEK  Euro_SEK<br/>Date                                      <br/>2019-10-06 15:03:00  4145.0  NaN       NaN<br/>2019-10-06 15:04:00  5784.0  NaN       NaN</pre>
<p>The missing data is automatically filled with <kbd>NaN</kbd> (which means <em>not a number</em>; see <a href="879c0554-386f-4bb1-8fa8-b86c43927545.xhtml">Section 2.2</a>: <em>Numeric types</em>).</p>
<p>We will study now how to treat missing data.</p>
<h2 id="uuid-7370e198-e040-4029-a469-a06e7928fdcd">10.3.5 Missing data in a dataframe</h2>
<p>We saw in the last section that missing data is often indicated by <kbd>NaN</kbd>. The way missing data is indicated depends on the datatype of the column. Missing timestamps are indicated by the pandas object <kbd>NaT</kbd>, while missing data with another non-numeric datatype is indicated by <kbd>None</kbd>.</p>
<p>The dataframe method <kbd>isnull</kbd> returns a Boolean dataframe with the entry <kbd>True</kbd> at all places with missing data.</p>
<p>We will study various methods for treating missing data before returning to the solar cell data example.</p>
<p>Let's demonstrate these methods on a small dataframe:</p>
<pre class="mce-root">frame = pd.DataFrame(array([[1., -5.,  3., NaN], <br/>                            [3.,  4., NaN, 17.], <br/>                            [6.,  8., 11.,  7.]]), <br/>                     columns=['a','b','c','d'])</pre>
<p class="mce-root">This dataframe is displayed as:</p>
<pre>     a    b    c     d<br/>0  1.0 -5.0  3.0   NaN<br/>1  3.0  4.0  NaN  17.0<br/>2  6.0  8.0 11.0   7.0</pre>
<p>Dataframes with missing data can be handled in different ways:</p>
<ul>
<li>Drop all rows containing missing data, <kbd>frame.dropna(axis=0)</kbd>:</li>
</ul>
<pre style="padding-left: 60px">     a    b     c    d<br/>2  6.0  8.0  11.0  7.0</pre>
<ul>
<li>Drop all columns containing missing data, <kbd>frame.dropna(axis=1)</kbd>:</li>
</ul>
<pre style="padding-left: 60px">   a    b<br/>0  1.0 -5.0<br/>1  3.0  4.0<br/>2  6.0  8.0</pre>
<ul>
<li>Replace the missing data by padding data from previous the row, <kbd>frame.fillna(method='pad',axis=0)</kbd>:   </li>
</ul>
<pre style="padding-left: 60px">    a    b     c     d<br/>0  1.0 -5.0   3.0   NaN<br/>1  3.0  4.0   3.0  17.0<br/>2  6.0  8.0  11.0   7.0  </pre>
<p style="padding-left: 60px">In this case, if there is no data to pad with, <kbd>NaN</kbd> remains.</p>
<ul>
<li class="mce-root"><span>Interpolate numeric data column-wise,</span> <kbd>frame.interpolate(axis=0, method='linear')</kbd>:     </li>
</ul>
<pre style="padding-left: 60px">  a    b     c     <br/>0  1.0 -5.0   3.0   NaN<br/>1  3.0  4.0   7.0  17.0<br/>2  6.0  8.0  11.0   7.0</pre>
<p class="mce-root">Again, values that cannot be computed by interpolation remain as <kbd>NaN</kbd>.</p>
<p class="mce-root">The way we used the method interpolate assumes that data is collected on an equidistant grid. If the index is numeric or a datetime object it can be used as the <img src="assets/8cf5b441-997d-4736-ace9-01b5b1b415c8.png" style="width:0.92em;height:1.00em;"/>-axis. This is achieved, for example, by using the parameter value <kbd>method='polynomial'</kbd>.</p>
<p class="mce-root">To use different methods on different columns is possible by using the parameter inplace:</p>
<pre>frame['c'].fillna(method='pad', inplace=True)<br/>frame['d'].fillna(method='bfill',inplace=True)</pre>
<p class="mce-root">We return now to the solar cell example. Electricity prices change on an hourly basis, valuta exchange rates on a daily basis, and the energy production by the solar panels is recorded every minute during daylight times. This is the reason why the dataframe merging step introduced many NaN (see <a href="6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml">Section 10.3.4</a>, Merging dataframes).</p>
<p class="mce-root">We replace these missing values by padding:</p>
<pre class="mce-root">solar_all['SEK'].fillna(method='pad', axis=0, inplace=True)<br/>solar_all['Euro_SEK'].fillna(method='pad', axis=0, inplace=True)</pre>
<p>There are still <kbd>NaN</kbd> values in the table. The solar cells produce only energy during the daytime with sufficient light. Outside these periods, the column Watt contains the value <kbd>NaN</kbd>. </p>
<p>In the next section, we visualize the data with pandas' dataframe plot functionality and we will see that <kbd>NaN</kbd> values are simply ignored in the plot.</p>
<h1 id="uuid-01658468-7795-4f21-bad6-3544dcfc52b4">10.4 Working with dataframes</h1>
<p>So far, we have seen how to create and modify a dataframe. Now, we turn to data interpretation. We will look at examples of visualization, show how to make simple calculations, and see how to group data. These are all stepping stones into the world of pandas. The strength of this module is in its large range of statistical tools. We leave the presentation of these tools to textbooks on practical statistics, while we focus here on the basic principles of pandas programming. We do not aim for completeness. Again, let's serve an appetizer.</p>
<h2 id="uuid-4d17ebfe-10e2-4a3c-8b1d-5d5c2ff0dc74">10.4.1 Plotting from dataframes</h2>
<p>To demonstrate the plotting functionality, we plot the energy price changes on May 16, 2020. For this, we construct a subframe of the data from that day:</p>
<pre>solar_all.loc['2020-05-16'].plot(y='SEK')</pre>
<p>You can see that we indexed here with the full day. This is a short form of slicing:</p>
<pre>solar_all.loc['2020-05-16 00:00':'2020-05-16 23:59']</pre>
<p>The resulting plot, Figure 10.1, shows the hourly variation of electricity prices in Swedish crowns on a typical day of the year.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/179951bd-d922-48f3-9ebd-c446adc48dee.png" style="width:27.75em;height:18.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.1: Plotting one column of a dataframe; the hourly price in Swedish crowns (SEK) per kWh on May 16, 2020</div>
<p>pandas' plot command is built upon plot from the module matplotlib.pyplot, which we met in <a href="86c61820-e645-486c-9418-10079ffac7f8.xhtml">Chapter 6</a>, Plotting.</p>
<p>It accepts the same parameters, for example, linestyle or marker.</p>
<p>The data for the x axis is taken from the dataframe index if not otherwise specified. Alternatively, you can plot one dataframe column versus another.</p>
<p>Line plots leave gaps where data is missing. You see this in the next figure that displays the solar cell's power in the first week of June 2020. As there is no solar cell data outside daylight time, the plot has gaps. See Figure 10.2.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/85f3638d-5375-42c4-8f13-3d79b12ae54d.png" style="width:31.58em;height:23.67em;"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Figure 10.2: A plot of a data series with missing data (<kbd>NaN</kbd>): the power in Watts of the solar cells in the first week of June 2020. You can clearly see the periods where no energy was produced</div>
<p>The command we used for this plot is as follows:</p>
<pre>ax1=solar_all.loc['2020-06-20':'2020-06-21'].plot(None,'Watt')<br/>ax1.set_ylabel('Power')</pre>
<p>Here, you can see the advantage of working with an axis object, ax1 in this case. This allows us to modify the axis labels or the legend, for example, ax1.legend(['Power [W]').</p>
<p>We give more plot examples in the next sections, when we see how to do some calculations within dataframes and how to group data.</p>
<h2 id="uuid-c86e4d0d-3fdb-40aa-ac60-5f446781f259">10.4.2 Calculations within dataframes</h2>
<p>We can do simple calculations on dataframe columns by applying functions on every element of the column, that is, elementwise application of functions. These functions can be built-in Python functions, NumPy functions, or user-defined functions, such as lambda functions (see <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.7</a>, Anonymous functions).</p>
<p>The simplest way is to operate on the columns directly. In the following example, we convert watts into kilowatts and Swedish crowns (SEK) into Euros by using the conversion rate, which was the actual rate on the day of the measurement:</p>
<pre>solar_converted=pd.DataFrame()<br/>solar_converted['kW']=solar_all['Watt']/1000<br/>solar_converted['Euro']=solar_all['SEK']/solar_all['Euro_SEK']</pre>
<p>Tacitly, we also adjusted the column labels to the converted units.</p>
<p>The command <kbd>solar_converted.loc['2020-07-01 7:00':'2020-07-01 7:04']</kbd> then returns the converted data for July, 1st 2020:</p>
<pre>                      kW      Euro<br/>Date                                   <br/>2020-07-01 07:00:00  2.254  0.037147<br/>2020-07-01 07:01:00  1.420  0.037147<br/>2020-07-01 07:02:00  2.364  0.037147<br/>2020-07-01 07:03:00  0.762  0.037147<br/>2020-07-01 07:04:00  2.568  0.037147</pre>
<p>We can also apply NumPy's (universal) functions to entire rows or columns. The following example computes the maximal power supplied by the solar cells:</p>
<pre>import numpy as np<br/>​np.max(solar_all['Watt']) # returns 12574</pre>
<p>To print the corresponding date, we use the function argmax :</p>
<pre>print(solar_all.index[np.argmax(solar_all['Watt'])])</pre>
<p>The printed date is then:</p>
<pre> 2020-05-16 10:54:00</pre>
<p class="mce-root">From the preceding examples, one can see that missing data marked by NaN is treated really as missing data, that is, as if it was not there. As not all computational methods have this property, it might be safer to replace NaN with 0 in these cases:</p>
<pre class="mce-root">solar_all['Watt'].fillna(value=0., inplace=True)</pre>
<p>For the application of general user-defined functions, there is a dataframe method apply. It performs row- or column-wise operations on the entire dataframe.</p>
<h2 id="uuid-4cae6c61-b433-43e2-8930-b2b81a10ca66">10.4.3 Grouping data</h2>
<p>The ability to group data is one of the essential features for pandas' dataframes. In the solar cell example, you saw that we had a data frequency of one measurement per minute. What if you want to report on an hourly or daily basis instead? We just form groups and aggregate the data in a prescribed way.</p>
<p>The following example forms a new dataframe with the two columns labeled Watt and SEK reporting the peak solar cell power per day and the average price in SEK:</p>
<pre>solar_day=solar_all.groupby(solar_all.index.date).agg({'Watt':'max', <br/>                                                       'SEK':'mean'})</pre>
<p>Again, we can visualize the results by using the dataframe method plot:</p>
<pre>solar_day.index=pd.to_datetime(solar_day.index,format='%Y-%m-%d')<br/>ax=solar_day.loc['2020-06-01':'2020-06-30'].plot.bar('Watt')</pre>
<p class="mce-root">Note, we created an axis object, ax, in order to change the tick labels on the <img src="assets/82a1cecf-66e2-4cc1-8b3f-f212f89db8fb.png" style="width:0.92em;height:1.00em;"/>-axis:</p>
<pre class="mce-root">ax.set_xticklabels([tf.strftime("%m-%d") <br/>                    for tf in solarday.loc['2020-06-01':'2020-06-30'].index])</pre>
<p>This results in Figure 10.3:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0e5178b2-1f65-46fa-a11c-48e1267f916c.png" style="width:36.00em;height:42.33em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.3: Peak solar cell power per day in June 2020</div>
<p>Here, we grouped all days within a month.</p>
<p>We can also jump hierarchies when grouping: In the preceding example we grouped days within a month but we can also group by hours within a month or even from the entire set. For example, to see if the price for electrical energy normally has two peaks per day, we can group the data by hour and form the mean:</p>
<pre>solar_hour=solar_all.groupby(solar_all.index.hour).agg({'SEK':mean})<br/>ax=solar_hour.plot()<br/>ax=solar_hour.plot(marker='*')<br/>ax.set_title('The average energy price change on a day')<br/>ax.set_xlabel('hour of day')<br/>ax.set_ylabel('SEK/kWh')</pre>
<p>These commands result in Figure 10.4:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3ca5b399-dd25-445e-ac3d-cee442b937af.png" style="width:30.25em;height:22.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.4: The result of data grouping hour-wise</div>
<p>Grouping data is often a starting point for getting answers to special questions that require computational steps on grouped data. For instance, in our example, we have the minute-wise power (in Watts) of the solar cells, but what is the hourly energy output in kWh of this system? To answer this question, we have to:</p>
<ul>
<li>Group the data hour-wise in a hierarchical way.</li>
<li>Form the discrete integral of the data on 60 minute intervals.</li>
<li>Store this in a new dataframe or series object.</li>
</ul>
<p>For the first task, we make use of pandas' ability to make a hierarchical indexer. We group hierarchically by year, month, day, and hour:</p>
<pre>grouping_list=[solar_all.index.year, solar_all.index.month, <br/>               solar_all.index.day, solar_all.index.hour]<br/>solar_hour=solar_all.groupby(grouping_list)</pre>
<p>Integration can be done in this case, as we started with the per-minute data, just by summing the data:</p>
<pre># integrating by summing up the data<br/>solar_hour=solar_hour.agg({'Watt':sum}) <br/><br/>solar_hour=solar_hour/(1000*60) # Conversion from Wmin to kWh</pre>
<p>Then we visualize the result in the usual way:</p>
<pre>ax=solar_hour['Watt'].loc[(2020,6,19)].plot.bar()<br/>ax.set_title('Energy production on June, 19 2020')<br/>ax.set_xlabel('Hour')<br/>ax.set_ylabel('Energy [kWh]')</pre>
<p>This gives us Figure 10.5:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/11a87d19-fc4e-44d6-92b6-86a901817dd7.png" style="width:32.33em;height:24.33em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 10.5: An example plot of a dataframe produced by hierarchical grouping</div>
<p>Alternatively, we could have used the command scipy.integrate.simps for the integration of discrete data as a parameter of the aggregate method, agg. As this function does not treat missing data, the remark at the end of <a href="6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml">Section 10.4.2</a>, Calculations within dataframes, applies, and we would have to replace all NaN values with 0 before we start.</p>
<h1 id="uuid-5797e512-f2cc-4ac7-a4f2-ac2cd8af8cef">10.5 Summary</h1>
<p>In this chapter, you got a brief introduction to pandas and saw how the concept of NumPy arrays is extended to dataframes. Instead of a never-complete explanation of the possibilities of dataframes, we guided you using an example of solar cell energy data through the first steps with pandas: setting up a dataframe from a file, merging frames, grouping data, and making calculations.</p>


            </article>

            
        </section>
    </body></html>