- en: '*Chapter 4*: Data Manipulation and Preparation, Paving the Way to Plotly Express'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that preparing data can take much more mental effort and code than the
    process of creating charts. Or, to put it differently, if we invest a good amount
    of time in preparing our data and making certain decisions about how and what
    we intend to do with it, the process of visualization can be made much easier.
    So far, we have used a small part of our dataset and didn't make any changes to
    its shape or format. And when making our charts, we followed the approach of building
    them from scratch by creating a figure and then adding different layers and options
    for traces, titles, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go through a thorough familiarization with the dataset
    and reshape it to an intuitive and easy-to-use format. This will help us in using
    a new approach for creating visualizations, using **Plotly Express**. Instead
    of starting with an empty rectangle and building layers on top of it, we will
    start with the features (columns) of our dataset, and create visualizations based
    on them. In other words, instead of being screen- or chart-oriented, we will work
    with more of a data-oriented approach. We will also compare the two approaches
    and discuss when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will mainly cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding long format (tidy) data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the role of data manipulation skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Plotly Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, no new packages will be used in this chapter, but as a major module
    of Plotly, we can consider Plotly Express to be a new one. We will also be extensively
    using `pandas` for data preparation, reshaping, and general manipulation. This
    will mainly be done in JupyterLab. Our dataset will consist of the files in the
    `data` folder in the root of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04](https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_04).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action at [https://bit.ly/3suvKi4](https://bit.ly/3suvKi4).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by exploring the different formats in which we can have data, and
    what we can do about it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding long format (tidy) data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a moderately complex dataset that we will be working with. It consists
    of four CSV files, containing information on almost all the countries and regions
    in the world. We have more than 60 metrics spanning more than 40 years, which
    means that there are quite a lot of options and combinations to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: But before going through the process of preparing our dataset, I'd like to demonstrate
    our end goal with a simple example, so you have an idea of where we are heading.
    It will also hopefully show why we are investing time in making those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly Express example chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Plotly Express ships with a few datasets for practicing and testing certain
    features whenever you want to do so. They fall under the `data` module of `plotly.express`,
    and calling them as functions returns the respective dataset. Let''s take a look
    at the famous Gapminder dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code displays sample rows of the `gapminder` DataFrame as you
    can see in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Gapminder dataset included in Plotly Express](img/B16780_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The Gapminder dataset included in Plotly Express
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset structure seems straightforward. For each unique combination of
    **country**, **continent**, and **year**, we have three metrics: **lifeExp**,
    **pop**, and **gdpPercap**. The **iso_alpha** and **iso_num** columns seem to
    be encoded values for the countries.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we might summarize the `gapminder` `data_frame` with a `scatter`
    plot.
  prefs: []
  type: TYPE_NORMAL
- en: On the `x` axis, we can have the `y` axis, it would be good to see the `size`
    of the markers reflect the population of the respective countries.
  prefs: []
  type: TYPE_NORMAL
- en: We might also split the chart horizontally (`facet_col`), into sub-plots, one
    for each continent, on one row, and make the sub-plot titles reflect that as well.
    We can also assign a separate `color` to each continent's markers. For more clarity,
    we can set the `title` of the figure to `'Life Expectancy and GDP per capita.
    1952 – 2007'`.
  prefs: []
  type: TYPE_NORMAL
- en: To make them clearer, we can change the `labels` of the X and Y axes' titles
    from `'gdpPercap'` to `'GDP per Capita'`, and from `'lifeExp'` to `'Life Expectancy'`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We would expect the GDP per capita to have outliers and not to be normally distributed,
    so we can set the type of the X-axis scale to logarithmic (`log_x`). The range
    of the Y-axis (`range_y`) should be the interval [20, 100], so we can see how
    life expectancy varies on a fixed vertical range.
  prefs: []
  type: TYPE_NORMAL
- en: Hovering over the markers should show the full information for that particular
    country, and the title of the hover label (`hover_name`) should take the name
    of the country. Having the same chart overlaid on top of itself for all years
    would be really cluttered and almost impossible to read. So let's have a separate
    `animation_frame` for each of the years.
  prefs: []
  type: TYPE_NORMAL
- en: It would be great if we could have a play button that would move the markers
    across years when clicked, one frame per year, like a video, with the option to
    stop it at a certain year.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `height` of the figure should be 600 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code would produce the visualization in *Figure 4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – An interactive chart of the Gapminder dataset using Plotly Express](img/B16780_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – An interactive chart of the Gapminder dataset using Plotly Express
  prefs: []
  type: TYPE_NORMAL
- en: My first observation for this process is that it took us much more text than
    code to describe the chart. Actually, it was a single line of code that produced
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the play button would animate the chart, and you would see a new frame
    for each year. You could also pause or move to a certain year if you want. This
    way you can see how the relationship between the two variables progressed through
    the years, like watching a short movie.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that hovering over a certain marker representing a country
    would show all relevant data that was used to specify the location, size, color,
    and whatever other attributes we might have set. The `hover_name` argument was
    set to `'country'` and this is why you see it in bold as the title of the label.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, we have markers overlapping, which makes it difficult to understand
    the chart. Because Plotly figures are interactive by default, we can easily use
    the modebar buttons to zoom in/out, or we can manually select a certain rectangle
    to zoom into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zooming into Africa by selecting the rectangle that contains only its markers,
    *Figure 4.3* shows how the chart changes, and now it is much easier to read the
    African sub-plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Zooming into specific regions in charts](img/B16780_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Zooming into specific regions in charts
  prefs: []
  type: TYPE_NORMAL
- en: Note that all other continent charts were also zoomed in to the same zoom level
    of Africa. Feel free to explore more of the interactive features, but I hope this
    shows how powerful and intuitive this approach is.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are many colored charts in this chapter. I did my best to make sure you
    can easily distinguish between colored markers as much as possible. It's still
    better to refer to the color version of the book, which is available online, if
    you are reading the print version.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main reasons that allowed us to create such a rich chart with
    one line of code. First, Plotly Express has powerful features and is specially
    designed to produce such charts with minimal code. This will be covered in more
    detail later. Second, the structure of the dataset plays an important role in
    the process. Once we have our data in a consistent format, it becomes easy to
    model, visualize, or run any kind of analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the main aspects of this data format.
  prefs: []
  type: TYPE_NORMAL
- en: Main attributes of long format (tidy) data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the key features of this structure is that it allows each marker on the
    chart to be independently represented by a row. Each value in those rows belongs
    to a distinct column. In turn, those columns each represent a separate variable
    and have their own data types. This makes it easy to map color, size, or whatever
    visual attributes we want, simply by declaring which column values we want to
    express with which visual attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that what I just said is close to the definition of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of columns, where each has exactly one type of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columns in a DataFrame can be of different types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All columns have the same length, even though they might contain missing values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a conceptual point of view, the main difference between a long form DataFrame
    and a regular one is having one observation per row (country, person, brand, or
    a combination of them), and one variable per column (population, size, length,
    height, revenue, and so on). For example, the **country** column contains countries
    and only countries. Additionally, countries are only present in this column. So,
    there is no ambiguity about where or how to access them.
  prefs: []
  type: TYPE_NORMAL
- en: This format is not required and is not any more "correct" than other formats.
    It is simply intuitive, consistent, and easy to use. The actual requirement for
    producing the visualization we just did is to have a set of values for the X axis
    and another set of values of the same length for the Y axis. For other features
    such as color and size, we also need sets of numbers or names of the same length,
    so we can properly map them together. The DataFrame is a natural fit for such
    a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: In the chart we just produced, you can easily see that we can have all markers
    the same size, simply by removing the `size` argument. Changing `facet_col` to
    `facet_row` would immediately have the sub-plots vertically stacked on top of
    one another as opposed to side by side. Minimal tweaks allow us to introduce big
    changes to our visualizations. This is as simple as flipping switches on a dashboard,
    pun intended!
  prefs: []
  type: TYPE_NORMAL
- en: I hope the end goal is now clear. We want to check the four files of our dataset
    and see how to generate long format (tidy) DataFrames. As a result, every column
    would contain data about one variable (year, population, Gini index, and so on),
    and every row would describe an observation (a combination of country, year, metric,
    and other values). Once that is done, we should be able to look at the data, specify
    what we want, and express that with a concise Plotly Express function call.
  prefs: []
  type: TYPE_NORMAL
- en: The process will be much clearer once we start the preparation, so let's start
    right away.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of data manipulation skills
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In practical situations, we rarely have our data in the format that we want;
    we usually have different datasets that we want to merge, and often, we need to
    normalize and clean up the data. For these reasons, data manipulation and preparation
    will always play a big part in any data visualization process. So, we will be
    focusing on this in this chapter and throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plan for preparing our dataset is roughly the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the different files one by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the available data and data types and explore how each can help us categorize
    and analyze the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reshape the data where required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine different DataFrames to add more ways to describe our data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's go through these steps right away.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the data files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by reading in the files in the `data` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things clear, I''ll use the distinct part of each filename as the variable
    name for each DataFrame: `''PovStats<name>.csv''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The series file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start by exploring the `series` file, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the `shape` attribute of the DataFrame, as well as the first
    five rows, as you can see in *Figure 4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The first few rows and columns of the PovStatsSeries file](img/B16780_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The first few rows and columns of the PovStatsSeries file
  prefs: []
  type: TYPE_NORMAL
- en: It seems we have 64 different indicators, and for each one of them, we have
    21 attributes, explanations, and notes. This is already in long format – columns
    contain data about one attribute, and rows are complete representations of an
    indicator, so there is nothing to change. We just need to explore what data is
    available and get familiar with this table.
  prefs: []
  type: TYPE_NORMAL
- en: Using this information, you can easily imagine creating a special dashboard
    for each indicator and placing it on a separate page. Each row seems to have enough
    information to produce an independent page with a title, description, details,
    and so on. The main content area of the page could be a visualization of that
    indicator, for all countries and across all years. This is just one idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at some interesting columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the indicators are spread across four topics, the counts of
    which can be seen above.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a column for `Unit of measure`, which might be interesting to explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It seems we have indicators whose units of measure are either percentages (rates)
    or not available (`NaN`). This might help us later in grouping certain types of
    charts together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important column is the `series` DataFrame by the **Topic** column,
    and then summarizes the **Limitations and Exceptions** column values by their
    count and number of unique values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be seen in *Figure 4.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Counts and unique values of Limitations and Exceptions](img/B16780_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Counts and unique values of Limitations and Exceptions
  prefs: []
  type: TYPE_NORMAL
- en: It looks like this is going to be a good reference point for us to learn more
    about the different indicators that we have. It would also be very helpful for
    the users so they can also get a better understanding of what they are analyzing.
  prefs: []
  type: TYPE_NORMAL
- en: The country file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the next file, `''PovStatsCountry.csv''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the shape of the DataFrame as well as a sample of rows and
    columns, as in *Figure 4.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Sample rows and columns from the country file](img/B16780_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Sample rows and columns from the country file
  prefs: []
  type: TYPE_NORMAL
- en: In the call to `read_csv`, we have specified `keep_default_na=False` and `na_values=''`.
    The reason is that `pandas` interprets strings such as `NA` and `NaN` as indicators
    of missing values. One of the countries, Namibia, has a `NA`, so it was missing
    from the DataFrame. That's why we had to make this change. That's a very good
    example of how things might go wrong in unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: This is very interesting metadata about the countries and regions in our dataset.
    It is a very small dataset but can be very useful in enriching our understanding,
    as well as giving us more options to filter and group our countries. It is also
    in long (tidy) format. Let's take a look at some of its interesting columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Region** column seems straightforward. We can check to see what regions
    are available, as well as the counts of countries in each region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be seen in *Figure 4.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Counts of countries per region](img/B16780_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Counts of countries per region
  prefs: []
  type: TYPE_NORMAL
- en: 'Another column that might be helpful is **Income Group**. Once we have this
    properly mapped to the right values, we might consider splitting our sub-plots
    by income group, as we previously did with continents in the first example of
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Having fifteen `NaN` values is consistent with the number of regions and classifications
    combined, which we will see shortly. The income level of countries is independent
    of their geographic locations.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the `Lower middle income`. I think it's important to distinguish
    between them, and we can easily create a special column for that, so we can differentiate
    between countries and non-countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `is_country` Boolean column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.8* shows a sample of rows containing countries and regions, as well
    as classifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – A sample of countries and regions with the is_country column](img/B16780_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – A sample of countries and regions with the is_country column
  prefs: []
  type: TYPE_NORMAL
- en: 'The full listing of those categories can be found by getting a subset of the
    `country` DataFrame where the **Region** column contains missing values and then
    getting the **Short Name** column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Going through this process is very important in helping you plan your dashboards
    and apps. For example, knowing that we have four classifications for income levels
    means that it makes sense to create sub-plots for them side by side. But if we
    had 20 classifications, it might not be a good idea to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create one more column and then move on to the next file.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are dealing with countries, we can use flags as visual and easy-to-spot
    identifiers. Since flags are emojis, and they are basically Unicode characters,
    they can be rendered as text on our charts, just like other regular text. We can
    later consider using other emojis as symbols that make it easy for the reader
    to spot growth and decline, for example (using the relevant arrow symbols and
    colors). This can also be useful when you don't have much space and you still
    need to communicate something to the users, especially on smaller screens. An
    emoji is worth a thousand words!
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing about country flag emojis is that they are a concatenation
    of two special letters whose name is `"REGIONAL INDICATOR SYMBOL LETTER <letter>"`.
    For example, these are the regional indicator symbols for the letters A and B:AB.
  prefs: []
  type: TYPE_NORMAL
- en: 'You simply have to get the two-letter code of a certain country, and look up
    the name from the `unicodedata` Python Standard Library module. The `lookup` function
    takes the name of a character and returns the character itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once we have two letters representing a country, we can look them up, and concatenate
    them to produce the respective country's flag. We can create a simple function
    that does that. We just need to handle the situation where the provided letters
    are either `NaN` or not part of the country code list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `country_codes` variable and check against it. If the provided
    letters are not in the list, we return the empty character, otherwise we create
    an emoji flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now easily define the `flag` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function, we can create our `flag` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.9* shows a random sample of countries, their flags, and the **is_country**
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Sample of rows showing countries and their flags](img/B16780_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Sample of rows showing countries and their flags
  prefs: []
  type: TYPE_NORMAL
- en: In the case where `NaN` because in many cases we might want to concatenate the
    country name with its flag, for titles or labels for instance, and an empty string
    would not cause any issues. Note that if you save the DataFrame to a file and
    reopen it, `pandas` will interpret empty strings as `NaN`, and you will have to
    either convert them or prevent them from being interpreted as such.
  prefs: []
  type: TYPE_NORMAL
- en: The country-series file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next file "`PovStatsCountry-Series.csv`" simply contains a list of the country
    codes and shows the sources of their population data. We'll see if/when we might
    use this as metadata in a relevant chart.
  prefs: []
  type: TYPE_NORMAL
- en: The footnotes file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we''ll take a quick look at the footnotes file `PovStatsFootNote.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an empty column `YR2015` and that''s why we extract the characters
    starting from index 2\. We renamed the columns to make them consistent with the
    `series` DataFrame, to make it easy to merge them when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.10* shows a few rows from the `footnote` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Sample of rows from the footnote file](img/B16780_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Sample of rows from the footnote file
  prefs: []
  type: TYPE_NORMAL
- en: That looks like a large number of notes about the data. We should make sure
    to include them somehow, to make sure the readers get the full picture. Those
    footnotes seem to be based on combinations of country, indicator, and year. Since
    the three are encoded in a consistent way with other tables, it should be straightforward
    to incorporate and map them to the relevant values elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The data file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next is the main data file, which we have already worked with in previous chapters,
    but we want to now reshape and merge with other DataFrames, for a more intuitive
    and powerful view into our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now explore this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code removes the column named `data` DataFrame, and displays
    a random sample of rows, as you can see in *Figure 4.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Sample of rows and columns from the data file](img/B16780_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Sample of rows and columns from the data file
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s always interesting to know how many missing values we have, and what
    percentage they form of all values. The interesting parts are the columns starting
    from `isna` method returns a `Series` of Booleans for each column. Taking the
    mean of that gets the percentage of missing values per column, as a `Series`.
    Running `mean` again gives the overall percentage of missing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 91.8% of our cells are empty. This has important implications for the results
    because most of the time we won't have enough data, or we won't have it for certain
    countries. Many countries didn't exist in their current form before the early
    nineties, for example, so this is one of the reasons. You can check out the `series`
    DataFrame and all the information about the indicators and the data collection
    issues where applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore how we can reshape DataFrames to and from long format, and
    more importantly, why we would want to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Melting DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first things you probably noticed is that years are spread across
    columns, with the values corresponding to them, each in its respective cell under
    the respective year. The issue is that `1980` is not really a variable. A more
    useful way is to have a `year` variable, and in that column, the values would
    vary from 1974 to 2019\. If you remember the way we created the first chart in
    this chapter, you can see how this makes our life much easier. Let me illustrate
    what I mean, using a small dataset so things are clear, and then we can implement
    the same approach with the `data` DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4.12* shows how we can have the same data structured differently while
    containing the same information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Two datasets containing the same information in two different
    formats](img/B16780_04_12.jpg)![Figure 4.12 – Two datasets containing the same
    information in two different formats](img/B16780_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Two datasets containing the same information in two different
    formats
  prefs: []
  type: TYPE_NORMAL
- en: Our current DataFrame is structured like the table on the right, and it would
    be easier to have it in a format like the one on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difficulty with the wide format is that the variables are presented in
    different ways. In some cases, they are displayed vertically in a column (**country**
    and **indicator**), while in others, they are displayed horizontally across the
    columns **2015** and **2020**. Accessing the same data in the long format DataFrame
    is straightforward: we simply specify the columns that we want. In addition to
    that, we get automatic mapping of values. For example, taking the columns **year**
    and **value** from the long DataFrame would automatically map 2015 to 100, 2015
    to 10, and so on. At the same time, each row is a complete and independent representation
    of the case we are dealing with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that this is doable with one call to the `melt` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an overview of what the preceding code and parameters do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id_vars`: Keep these as rows and duplicate them as needed to keep the mapping
    in place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_vars`: Take these columns and make them values, melt them into a new
    column, and make sure the mapping with other values remains consistent with the
    previous structure. If we don''t specify `value_vars`, then this operation will
    be used for all unspecified columns (all columns except `id_vars`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var_name`: Optional. What you want this newly created column to be named –
    "`year`" in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s do this operation on our `data` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is almost identical to the previous example. We first created a list
    of `id_vars` and used it for the argument of the same name. Right after that,
    we removed the missing values under the `value` column. We could have changed
    the name of this column by using the `value_name` parameter, but "`value`" seems
    appropriate. We then converted the years to integers. Running this code displays
    the shape and a sample of the new `data_melt` DataFrame, shown in *Figure 4.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – The data DataFrame after being "melted"](img/B16780_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – The data DataFrame after being "melted"
  prefs: []
  type: TYPE_NORMAL
- en: The first four columns are the same as they were, with each unique combination
    intact. We now have all the year columns and their values, condensed into two
    columns, **year** and **value**.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can improve the structure further by doing the reverse
    operation on other columns.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Indicator Name** column might be improved by doing the reverse of the
    operation that we just did to the years columns. Ideally, we should have a column
    for population, another one for poverty rates, and so on. Let's first do this
    using our long (melted) example DataFrame so it's clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume we wanted to convert the unique values in the `pivot` method for that.
    This can give us a "round trip" back where we came from, using the `melt` method.
    Here, I''m using it on different columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code would convert the melted DataFrame to a wide format (pivoted)
    DataFrame as you can see in *Figure 4.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – The conversion from long to wide format](img/B16780_04_15.jpg)![Figure
    4.14 – The conversion from long to wide format](img/B16780_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – The conversion from long to wide format
  prefs: []
  type: TYPE_NORMAL
- en: 'The `data_melt` contains names that can be better used as column names, so
    each indicator can be represented independently in its own column, to be consistent
    with our data representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce our `data_pivot` DataFrame, a sample of which you can see
    in *Figure 4.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – The long form (tidy) poverty DataFrame](img/B16780_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – The long form (tidy) poverty DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'If our work is correct, we should now have a unique combination of country
    and year in each row. That was the whole point of the exercise actually. Let''s
    test that our work is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Rows now contain country names, codes, and years, as well as all the values
    for the different indicators. The country information can be enriched by including
    the metadata that we have in the `country` DataFrame. Let's take a look at the
    `merge` function, and after that, we'll start using Plotly Express.
  prefs: []
  type: TYPE_NORMAL
- en: Merging DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at a simple example of how merging works, and then we can
    merge the `data_pivot` and `country` DataFrames. *Figure 4.16* shows how two DataFrames
    can be merged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 How DataFrames are merged](img/B16780_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 How DataFrames are merged
  prefs: []
  type: TYPE_NORMAL
- en: 'The merge operation can be done with the `merge` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the details of the preceding call to `pd.merge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`left_on`: The name of the column(s) from the `left` DataFrame to merge on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right_on`: The name of the column(s) from the `right` DataFrame to merge on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`how`: The `merge` method. In this case, `"left"` means to take all the rows
    in `left` and only match them with rows in `right` that have the same values in
    the `right` that don''t have matches in the `country` column will be discarded.
    The merged DataFrame should end up with the same number of rows as the left DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several other options for this function, and it''s quite powerful.
    Make sure to check out the other merge methods: inner, outer, and right. For our
    case, we will be using the options shown in the previous example, so let''s do
    it now. We will merge `data_pivot` with `country` the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This merge operation produces the `poverty` DataFrame, which you can see in
    *Figure 4.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Merging data_pivot and country](img/B16780_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Merging data_pivot and country
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick check to make sure our work is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The eight additional columns in the rectangle on the right are some of the additional
    columns that were added to our `poverty` DataFrame. Now it's very easy to take
    a certain region or income group, filter by its countries, color by its values,
    or group it however we want. This is now looking like the Gapminder dataset, only
    with many more indicators and years, and more metadata about countries.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a DataFrame that has a consistent structure.
  prefs: []
  type: TYPE_NORMAL
- en: Every column contains data about one and only one variable. All values in columns
    are of the same data type (or missing). Each row can independently represent a
    complete observation, because it contains the full information available, like
    all other rows.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The main drawback of the long format is that it is inefficient for storage.
    From that perspective, we are unnecessarily repeating a lot of values, which takes
    a lot of space. We will tackle this later, but keep in mind that this format is
    extremely efficient in terms of your time as a developer. As we saw in several
    examples, once the mapping is consistent, creating and changing your visualizations
    becomes much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend reading Hadley Wickham''s *Tidy Data* paper, for a deeper
    discussion on several ways in which data might be formatted and different solutions
    for that. The examples shown here are inspired by those principles: [https://www.jstatsoft.org/article/view/v059i10](https://www.jstatsoft.org/article/view/v059i10).'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to explore how to use Plotly Express, first with a toy dataset,
    and then with the dataset that we prepared.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Plotly Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plotly Express is a higher-level plotting system, built on top of Plotly. Not
    only does it handle certain defaults for us, such as labeling axes and legends,
    it enables us to utilize our data to express many of its attributes using visual
    aesthetics (size, color, location, and so on). This can be done simply by declaring
    what attribute we want to express with which column of our data, given a few assumptions
    about the data structure. So, it mainly provides us with the flexibility to approach
    the problem from the data point of view, as mentioned at the beginning of the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a simple DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the DataFrame in *Figure 4.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – A simple example DataFrame](img/B16780_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – A simple example DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: We typically create charts with Plotly Express by calling the type of the chart
    as a function, `px.line`, `px.histogram`, and so on. Each function has its own
    set of parameters, based on its type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways of passing arguments to those functions, and we will
    focus on two main approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A DataFrame with column names: In most cases, the first parameter is `data_frame`.
    You set the DataFrame that you want to visualize, and then you specify the columns
    you want to use for the parameters that you want. For our example DataFrame, if
    we want to create a scatter plot with `px.scatter(data_frame=df, x=''numbers'',
    y=''floats'')`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrays as arguments: Another way of specifying parameters is by simply passing
    lists, tuples, or any array-like data structure, without a `data_frame` argument.
    We can create the same scatter plot by running: `px.scatter(x=df[''numbers''],
    y=df[''floats''])`. This is a straightforward and very fast approach, whenever
    you have lists that you want to explore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also mix the approaches. We can set a `data_frame` argument with a few
    column names as arguments, and we can pass separate lists for other arguments
    when needed. A few examples should illustrate these points easily. The following
    code shows how easy it is to create a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.19* shows the resulting figure in JupyterLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Creating a scatter plot with Plotly Express](img/B16780_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Creating a scatter plot with Plotly Express
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure you noticed that we got the X- and Y-axis titles set for us by default.
    It takes the names of the arguments we gave (the DataFrame columns in this example)
    and uses them for that.
  prefs: []
  type: TYPE_NORMAL
- en: We have several other variables in the DataFrame, and we might be interested
    in checking whether there are any relations between them. For example, let's check
    whether there is a relationship between **floats** and **shapes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rerun the same code and add two parameters that allow us to distinguish
    which markers belong to which shape. We can use the `color` parameter for that,
    and it will assign a different color to each marker based on the `symbol` parameter
    was added, to make it easy to distinguish them. This also makes it easier for
    readers on a colored screen as well, by giving two signals to distinguish the
    markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.20* shows the code and resulting figure in JupyterLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Assigning colors and symbols to markers](img/B16780_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Assigning colors and symbols to markers
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have a legend helping us to distinguish the markers by telling
    us which color and symbol belong to which shape. It also has its own title, all
    generated by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'There seems to be no relationship between floats and shapes. So, let''s try
    coloring and setting symbols based on the **letters** column, which can be done
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.21* demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Setting marker sizes using an independent list](img/B16780_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Setting marker sizes using an independent list
  prefs: []
  type: TYPE_NORMAL
- en: We can see a clear difference based on the letters now. This shows how easy
    it is to explore your datasets by quickly trying out different options. Note that
    we also mixed the approaches this time by setting a `size` for the markers. Size
    wasn't mapped to a value; it was set to make the symbols bigger and easier to
    see. So, we simply passed a list with the marker size that we wanted. The list
    had to have the same length as the other variables that we are visualizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore bar charts with the same approach and using the same dataset.
    We can adjust how the bars are displayed using the `barmode` parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4.22* shows two different ways of displaying the bars – the default,
    on top of each other, and "`group`," as you can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Creating bar charts using different display modes (barmode)](img/B16780_04_24.jpg)![Figure
    4.22 – Creating bar charts using different display modes (barmode)](img/B16780_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Creating bar charts using different display modes (barmode)
  prefs: []
  type: TYPE_NORMAL
- en: The discussion about long (tidy) format data should make it very easy to understand
    how to use Plotly. You just need a basic understanding of the chart type, and
    how it works, and then you can easily set the arguments that you want.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Plotly Express does not require data to be in long format. It is very flexible
    and can handle wide, long, as well as mixed format data. Also, `pandas` and `numpy`
    are extremely flexible in data manipulation. I just believe it is better to use
    a consistent approach for your own productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how Plotly Express relates to the `Figure` object and when to
    use which approach.
  prefs: []
  type: TYPE_NORMAL
- en: Plotly Express and Figure objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s helpful to know that all calls to the Plotly Express chart functions
    return a `Figure` object, the same one we discussed in [*Chapter 3*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044),
    *Working with Plotly''s Figure Objects*. This is very important for customizing
    our charts after creating them, in case you want to change the defaults. Let''s
    say you created a scatter plot, and after that, you wanted to add an annotation
    to it to explain something. You could do it just like we did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Everything you know about the `Figure` object and how it is structured can be
    used with Plotly Express, so this builds on that knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: This naturally raises the question of when to use Plotly Express and when to
    use Plotly's `graph_objects` module for creating charts from a lower level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This question can be tackled by asking the more general question: Given two
    interfaces that do the same thing at different levels of abstraction, how do we
    choose between them?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider three different approaches to having a pizza:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The ordering approach**: You call a restaurant and order your pizza. It arrives
    at your doorstep in half an hour, and you start eating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The supermarket approach**: You go to a supermarket, buy dough, cheese, vegetables,
    and all other ingredients. You then make the pizza yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The farm approach**: You grow tomatoes in your backyard. You raise cows,
    milk them, and convert the milk to cheese, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we go up to higher-level interfaces, towards the ordering approach, the amount
    of knowledge required decreases a lot. Someone else holds responsibility, and
    quality is checked by the market forces of reputation and competition.
  prefs: []
  type: TYPE_NORMAL
- en: The price we pay for this is the diminished freedom and options. Each restaurant
    has a set of options to choose from, and you have to choose from those options.
  prefs: []
  type: TYPE_NORMAL
- en: Going down to lower levels, the amount of knowledge required increases, we have
    to handle more complexity, we hold more responsibility for the outcomes, and it
    takes much more time. What we gain here is much more freedom and power to customize
    our outcomes the way we want. Cost is a major benefit as well, but only on a large
    enough scale. If you only want to have a pizza today, it's probably cheaper to
    order it. But if you plan on having one every day, then you can expect major cost-savings
    if you do it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: This is the trade-off you have in choosing between the higher-level Plotly Express,
    and the lower-level Plotly `graph_objects`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Plotly Express returns `Figure` objects, then it''s generally not a difficult
    decision, because you can retroactively modify them. In general, it''s good to
    use the `graph_objects` module in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-standard visualizations**: Many diagrams created in this book were done
    with Plotly. To create such diagrams with Plotly Express would be quite difficult
    because they are not standard graphs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graph_objects` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graph_objects`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, Plotly Express is usually a better starting point for creating your
    charts, as we saw how powerful and convenient it is.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to use the `poverty` dataset to specify the visualization
    that you want with Plotly Express, starting from the data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Plotly Express chart using the dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how we might summarize the `poverty` `data_frame` with a scatter
    plot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create variables for `year`, `indicator`, and a grouping (`grouper`) metric
    to use in the visualization. The grouping metric will be used to distinguish between
    the markers (using color and symbol), and could take any categorical value from
    the dataset, such as region, income group, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Based on these variables, create a DataFrame, where the `year` column is equal
    to `year`, sort the values by `indicator`, and remove any missing values from
    the columns of `indicator` and `grouper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the `x` axis values to `indicator` and set the `y` axis values to the column
    "`Country Name`". The `color` and `symbol` of the markers should be set using
    `grouper`. The X-axis values are expected to have outliers, and not to be normally
    distributed, so set `log_x` to `True`. The `hover_name` of each hover label should
    take the country name together with its flag. Set the `title` of the figure by
    concatenating `indicator`, "`by`", `grouper`, and `year`. Give markers a constant
    `size`, and set the `height` to `700` pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates the chart in *Figure 4.23*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.23 – The Plotly Express figure using the poverty dataset](img/B16780_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – The Plotly Express figure using the poverty dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'By simply playing with the different combinations of `year`, `grouper`, and
    `indicator`, you can generate hundreds of charts. *Figure 4.24* shows some samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Other figures using the same dataset](img/B16780_04_27.jpg)![Figure
    4.24 – Other figures using the same dataset](img/B16780_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Other figures using the same dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'With these powerful features, and with data formatted as observations by variables,
    we can easily visualize six or seven attributes of our data using several visual
    attributes: X axis, Y axis, marker size, marker symbol, marker color, facets (columns
    or rows), and animations. We can also add more context and information using hover
    labels, as well as annotations. Any combination of those attributes can be explored
    simply by selecting which column to map to which attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now explore how easy it is to enrich our dataset with external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new data and columns to our dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many ways to add more data, but I would like to highlight two very
    easy and effective ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pandas` `read_html` function, which downloads all tables on a web page, you
    can very easily download any such list. Assuming it has the country codes, you
    can merge it with the main DataFrame and start analyzing accordingly. This can
    also be a filtering mechanism, where you simply want a subset of all countries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding new data**: The World Bank has thousands of other similar datasets.
    For example, the population figures we have here are for the total population.
    There are many detailed and segmented population datasets that break the numbers
    down by gender, age, and other factors. Using the World Bank''s API, you can easily
    obtain other data, merge it, and immediately enrich your analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now review what we have done in this chapter and in *Part 1* of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You now have enough information and have seen enough examples to create dashboards
    quickly. In [*Chapter 1*](B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015), *Overview
    of the Dash Ecosystem*, we learned how apps are structured and learned how to
    build fully running apps, but without interactivity. In [*Chapter 2*](B16780_02_Final_NM_ePub.xhtml#_idTextAnchor031),
    *Exploring the Structure of a Dash App*, we explored how interactivity works,
    through callback functions, and we added interactive features to our app. [*Chapter
    3*](B16780_03_Final_NM_ePub.xhtml#_idTextAnchor044), *Working with Plotly's Figure
    Objects*, introduced how Plotly's charts are created, their components, and how
    to manipulate them to achieve the results you want. Finally, in this chapter,
    we introduced Plotly Express, a high-level interface to Plotly that is easy to
    use but more importantly, follows an intuitive approach that is data-oriented,
    as opposed to being chart-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important and biggest parts of creating visualizations is the
    process of preparing data in certain formats, after which it becomes relatively
    straightforward to create those visualizations. Investing in understanding how
    your dataset is structured, as well as investing time and effort in reshaping
    your data, pays well in the end, as we saw in the extensive example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge and examples, as well as our familiarity with our
    dataset, and straightforward mechanisms to enrich it, we are now ready to explore
    in more detail different Dash components, as well as different types of charts.
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 2* will go deep into different chart types, how to use them, and the
    different ways we can combine them with the interactivity features that Dash provides.'
  prefs: []
  type: TYPE_NORMAL
