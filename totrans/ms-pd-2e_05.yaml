- en: Using NumPy and Data Structures with pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is one of the most important ones in this book. We will now begin
    to dive into the nitty-gritty of pandas. We start by taking a tour of NumPy `ndarrays`,
    a data structure not in pandas but NumPy. Knowledge of NumPy `ndarrays` is useful
    as they are the building blocks on which pandas DataFrames have been built. One
    key benefit of NumPy arrays is that they execute what is known as *vectorized*
    operations, which are operations that require traversing/looping on a Python array
    and are much faster.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will present the material via numerous examples using Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: The topics we will cover in this chapter include a tour of the `numpy.ndarray`
    data structure, the `pandas.Series` **one-dimensional** (**1D**) pandas data structure,
    the `pandas.DataFrame` **two-dimensional** (**2D**) pandas tabular data structure,
    and the `pandas.Panel` **three-dimensional** (**3D**) pandas data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy `ndarrays`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing neural networks with NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical applications of multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures in pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy ndarrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are vital objects in the data analysis scenario. Arrays allow for structured
    handling of elements that are stacked across rows and columns. The elements of
    an array are bound by the rule that they should all be of the same data type.
    For example, the medical records of five patients have been presented as an array as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Blood glucose level** | **Heart rate** | **Cholesterol level** |'
  prefs: []
  type: TYPE_TB
- en: '| **Peter Parker** | 100 | 65 | 160 |'
  prefs: []
  type: TYPE_TB
- en: '| **Bruce Wayne** | 150 | 82 | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| **Tony Stark** | 90 | 55 | 80 |'
  prefs: []
  type: TYPE_TB
- en: '| **Barry Allen** | 130 | 73 | 220 |'
  prefs: []
  type: TYPE_TB
- en: '| **Steve Rogers** | 190 | 80 | 150 |'
  prefs: []
  type: TYPE_TB
- en: 'It is seen that all 15 elements are of data type `int`. Arrays could also be
    composed of `strings`, `floats`, or complex numbers. Arrays could be constructed
    from lists—a widely used and versatile data structure in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An element in the *i*^(th) row and *j*^(th) column (for example, first row
    and second column in the first example) of an array or matrix can be accessed
    as shown in the following code. Note that indexing in Python starts from 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has an built-in `array` module to create arrays. However, this array
    module is more like a glorified list where all elements are required to have the
    same data type. An array can be created using the `array` module by providing
    two arguments—the type code of the data type, and the elements in a list, string,
    or any iterable object. Let''s create an array of floats. Here, `d` is the type
    code for a double-floating point value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to create a two-dimensional entity with rows and columns
    using the `array` module. This can be achieved through a nested list of such arrays.
    Special functions implicit with matrices or arrays, such as matrix multiplication,
    determinants, and eigenvalues, are not defined in this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy is the preferred package to create and work on array-type objects. NumPy
    allows multidimensional arrays to be created. Multidimensional arrays provide
    a systematic and efficient framework for storing data. Complex computations, which
    are built-in vectorized operations in the NumPy package, can be done quickly on
    these multidimensional arrays without the need for loops. Consider the earlier
    example where we created a two-dimensional array to store the medical records
    of five patients. The patients'' names and the clinical indicators were the two
    dimensions in this case. Now, if the clinical parameters of the same patients
    were recorded for three years, from 2016 to 2018, then all this information could
    be conveniently represented in a three-dimensional array. The year in which the
    records were fetched will get in as the third dimension. The resultant array will
    be of dimension 3 x 5 x 3, and entirely composed of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **2016** | **2017** | **2018** |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 65 | 160 | 95 | 68 | 140 | 110 | 72 | 160 |'
  prefs: []
  type: TYPE_TB
- en: '| 150 | 82 | 200 | 145 | 80 | 222 | 160 | 95 | 185 |'
  prefs: []
  type: TYPE_TB
- en: '| 90 | 55 | 80 | 90 | 62 | 100 | 100 | 80 | 110 |'
  prefs: []
  type: TYPE_TB
- en: '| 130 | 73 | 220 | 150 | 92 | 200 | 140 | 92 | 120 |'
  prefs: []
  type: TYPE_TB
- en: '| 190 | 80 | 150 | 140 | 60 | 90 | 100 | 55 | 100 |'
  prefs: []
  type: TYPE_TB
- en: In NumPy, these multidimensional arrays are referred to as `ndarrays` (*n*-dimensional
    arrays). All NumPy array objects are of the type `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s view the preceding data as an `ndarray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes of an `ndarray` such as the data type, shape, number of dimensions,
    and size can be accessed by different attributes of the array. Some attributes
    for the `ndarray` `ndarray_1` have been explored in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy''s `ndarray` makes use of a strided indexing scheme for its internal
    memory layout. A memory segment by itself can accommodate only one-dimensional
    structures. Hence, a specific memory allocation scheme such as the strided indexing
    scheme is needed to facilitate easy indexing and slicing of `ndarrays`. A stride
    indicates the number of bytes to jump to traverse to the subsequent element. The
    number of bytes for each stride is determined by the data type of the array. Let''s
    understand strides through the array explored earlier. The number of bytes occupied
    by each element can be determined as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is seen that each element occupies 4 bytes, and the entire array occupies
    180 bytes. The strides for the array are represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The shape of the array is given by the tuple (3, 5, 3). The values in the tuple
    represent the number of years for which there is data, the number of patients,
    and the number of clinical parameters, respectively. For each year or first dimension,
    there are 15 records, and hence to move from one year to another in the array,
    60 bytes should be jumped across. On a similar note, each distinct patient has
    3 records for a given year, and 12 bytes of memory should be moved past to get
    to the next patient.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy array creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy arrays can be created in several ways via calls to various NumPy methods.
    The arrays can be created using the data in lists or any other data structures,
    by specifying numerical ranges to obtain uniformly spaced values or by generating
    random samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest routine to create an array is through the `array` function. This
    function accepts any sequential object, such as a list or tuple, and converts
    it to an array. The following code snippet shows how a 1D array can be created
    through the `array` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, a multidimensional array can be created by passing a list of lists
    to the array function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead of lists, the same result can be achieved with tuples, a list of tuples,
    or a tuple of tuples as well.
  prefs: []
  type: TYPE_NORMAL
- en: Array of ones and zeros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several operations on arrays call for the creation of arrays or matrices with
    ones and zeros. Some special functions in NumPy provide for easy creation of such
    arrays. Usually, these functions take in the shape of the resultant array as an
    input argument in the form of a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The identity function returns a 2D *n x n* square matrix, where *n* is the
    order of the matrix passed as an input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eye` function can also be used to create an identity matrix. It differs
    from the identity matrix in two main aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The eye function returns a 2D rectangular matrix and accepts both the number
    of rows and number of columns (optional argument) as the input. If the number
    of columns is not specified, a square matrix is returned using just the number
    of rows passed in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diagonal can be offset to any position in the upper triangle or lower triangle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, `k` holds the value 0 in the eye function.
  prefs: []
  type: TYPE_NORMAL
- en: Array based on a numerical range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `arange` function of NumPy functionally resembles Python''s range function.
    Based on a start value, stop value, and step value to increment or decrement subsequent
    values, the `arange` function generates a set of numbers. Just like the range
    function, the start and step arguments are optional here. But unlike range, which
    generates a list, `arange` generates an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `linspace` function generates an array of linearly spaced samples for a
    given start point and end point. Unlike the arrange function, which specifies
    the incremental/decremental interval, the `linspace` function accepts the number
    of samples to be generated as an optional argument. By default, 50 samples are
    generated for a given start point and end point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `logspace` and `geomspace` functions create an array of numbers
    following logarithmic and geometric sequences to be created.
  prefs: []
  type: TYPE_NORMAL
- en: The `arange` function and `linspace` function do not allow for any shape specification
    by themselves and produce 1D arrays with the given sequence of numbers. We can
    very well use some shape manipulation methods to mold these arrays to the desired
    shape. These methods will be discussed in the last part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Random and empty arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `random` module of the NumPy package packs within it a whole range of functions
    for random sampling that perform operations right from creating a simple array
    of random numbers to drawing random samples from distribution functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `random.rand` function generates random values from 0 to 1 (uniform distribution)
    to create an array of given shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `random.randn` function samples values from a standard normal distribution
    to build an array of given shape. If the shape parameter is not specified, a single
    value is returned as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `random.randint` function generates an array of integers between the specified
    lower and upper bounds, with the given shape. The limit excludes the upper bound.
    If the upper bound is not mentioned, it is considered to be 1 more than the lower
    bound defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `empty` function returns an array with arbitrary values for the given shape.
    This array requires no initialization and would perform faster than functions
    such as zeros and ones where the values have to be initialized. Caution is needed
    when using this function, and it is to be used only when it is certain that all
    the values in the array would be filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Arrays based on existing arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the NumPy array-creation routines are extremely useful to perform matrix
    operations such as constructing the **diagonal matrix** (**diag**), the **upper
    triangular matrix** (**triu**), and the **lower triangular matrix** (**tril**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `diag` function works only on 1D and 2D arrays. If the input array is 2D,
    the output is a 1D array with the diagonal elements of the input array. If the
    input is a 1D array, the output is a matrix with the input array along its diagonal.
    Here, a parameter k helps to offset the position from the main diagonal and can
    be positive or negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `triu` and `tril` functions have a similar parameter k, which helps offset
    the diagonal. These functions work with any `ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an array of *n* dimensions, a new array can be created by repeating this
    array multiple times along each axis. This can be done with the `tile` function.
    This function accepts two input arguments—the input array and the number of repetitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: NumPy data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the array-creation functions described earlier (except the functions for
    arrays based on existing arrays—`diag`, `triu`, `tril`, and `tile`) have an argument
    `dtype` to define the data type of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an array without predefining the data type, and then check for
    its data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the same array by also setting its data type to `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is seen that the elements of the array are all casted as floating points.
    It is also possible to cast this array as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the elements are cast as strings. The output also specifies the
    data type as `<U2`. It indicates that the elements of the array are Unicode strings
    and the maximum accepted length of string for this array is 2\. This threshold
    on length is decided based on the length of the longest string in the array. Let''s
    understand this with another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Such typecasting is observed in arrays with strings, as optimal memory has to
    be allocated for the array. A single character occupies four bytes. Based on the
    maximum string length, each element will be allotted a memory block of size equal
    to four times the maximum string length.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays also support data types such as boolean and complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The data type of `ndarray` can be changed in much the same way as we cast in
    other languages such as Java or C/C++. The `ndarray.astype` method helps in type
    conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: More information on casting can be found in the official documentation at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html).
  prefs: []
  type: TYPE_NORMAL
- en: NumPy indexing and slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Array indices in NumPy start at `0` as in languages such as Python, Java, and
    C++ and unlike in Fortran, Matlab, and Octave, which start at `1`. Arrays can
    be indexed in the standard way as we would index into any other Python sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can be reversed using the `::-1` idiom as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Multidimensional arrays are indexed using tuples of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we set the entry at `row1` and `column1` to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve row 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve column 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If an index is specified that is out of bounds of the range of an array, `IndexError`
    will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Thus, for 2D arrays, the first dimension denotes rows and the second dimension,
    the columns. The colon (`:`) denotes selection across all elements of the dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Array slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays can be sliced using the syntax `ar[startIndex: endIndex: stepValue]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we wish to include the `endIndex` value, we need to go above it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain the first `nelements` using `ar[:n]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The implicit assumption here is that `startIndex=0, step=1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start at element 4 and select all the elements till the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Slice array with `stepValue=3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the scope of indexing in NumPy, let''s refer to the following
    diagram, which is taken from a NumPy lecture given at SciPy 2013 and can be found
    at [http://scipy-lectures.github.io/_images/numpy_indexing.png](http://scipy-lectures.github.io/_images/numpy_indexing.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9378279b-e9f5-4c20-beb3-2a9863c10d54.png)'
  prefs: []
  type: TYPE_IMG
- en: Pictorial illustration of NumPy indexing
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now examine the meanings of the expressions in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The expression `a[0,3:5]` indicates the start at row 0, columns 3-5, column
    5 not included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the expression `a[4:,4:]`, the first 4 indicates the start at row 4 and will
    give all columns, that is, the array [[40, 41,42,43,44,45] [50,51,52,53,54,55]].
    The second 4 shows the cutoff at the start of column 4 to produce the array [[44,
    45], [54, 55]].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression `a[:,2]` gives all rows from column 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, in the last expression, `a[2::2,::2]`, `2::2` indicates that the start
    is at row 2 and the step value here is also 2\. This would give us the array [[20,
    21, 22, 23, 24, 25], [40, 41, 42, 43, 44, 45]]. Further, `::2` specifies that
    we retrieve columns in steps of 2, producing the end result array ([[20, 22, 24],
    [40, 42, 44]]).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assignment and slicing can be combined as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Array masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy arrays can be used as filters on the larger original array. This process
    of using arrays as filters is called **array masking**. For example, see the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we randomly generate an array of 10 integers between
    0 and 25\. Then, we create a boolean mask array that is used to filter out only
    the even numbers. This masking feature can be very useful, say, for example, if
    we wished to eliminate missing values by replacing them with a default value.
    Here, the missing value `''''` is replaced by `''USA''` as the default country.
    Note that `''''` is also an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays of integers can also be used to index an array to produce another array.
    Note that this produces multiple values; hence, the output must be an array of
    type `ndarray`. This is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the selection object is a list, and elements at indices
    1, 3, 4, 2, and 7 are selected. Now, assume that we change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We get an `IndexError` error since the array is 1D and we''re specifying too
    many indices to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This assignment is also possible with array indexing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When a new array is created from another array by using a list of array indices,
    the new array has the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: Complex indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we illustrate the use of complex indexing to assign values from a smaller
    array into a larger one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Slice out the first 10 elements of `ar`, and replace them with elements from
    `ar2`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Copies and views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A view on a NumPy array is just a particular way of portraying the data it contains.
    Creating a view does not result in a new copy of the array, rather the data it
    contains may be arranged in a specific order, or only certain data rows may be
    shown. Thus, if data is replaced on the underlying array's data, this will be
    reflected in the view whenever the data is accessed via indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial array is not copied into the memory during slicing and is thus
    more efficient. The `np.may_share_memory` method can be used to see whether two
    arrays share the same memory block. However, it should be used with caution as
    it may produce false positives. Modifying a view modifies the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To force NumPy to copy an array, we use the `np.copy` function. As we can see
    in the following array, the original array remains unaffected when the copied
    array is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many methods on NumPy arrays require running mathematical operators such as
    addition, subtraction, multiplication, division, and so on, on the arrays. The
    following section deals with explaining how these operators are applied on the
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Basic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy is highly efficient in performance as it works based on vectorized operations,
    where the need for loops is avoided and the process becomes several times faster.
    All basic arithmetic operations involving +, -, *, and / take place elementwise
    and are vectorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations involving two arrays, such as adding or multiplying two arrays,
    also takes place in a vectorized manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Python''s `timeit` function will give us a sense of how efficient vectorized
    operations are compared to looping over items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This shows that `numpy` operations are about 100 times faster than for loops.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mathematical operators of NumPy can mainly support trigonometric operations,
    arithmetic operations, and exponential and logarithmic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class of these operators, such as `prod`, `sum`, and so on, perform computations
    within the array and serve to reduce the matrix. For example, the `sum` function
    calculates the sum along a given axis. The output will be the sum of elements
    along the axis. These functions can be called as a `numpy.function` or as an `ndarray.method`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Statistical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A wide range of statistical operations, such as computing mean, median, variance,
    and standard deviation, can be calculated for NumPy arrays using the available
    statistical operators. The aggregates, such as mean, median, variance, and standard
    deviation, for an entire array can be calculated as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, these statistical parameters are computed by flattening out the
    array. To compute the statistical parameters along any of the axes, the `axis`
    argument can be defined when calling these functions. Let''s look at this behavior
    with the `mean` function as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There are special implementations of these functions to handle arrays with
    missing values or `NA`s. These functions are `nanmean`, `nanmedian`, `nanstd`,
    `nanvar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `corrcoeff` and `cov` functions help compute the Pearson''s correlation
    coefficients and the covariance matrix for a given array or two given arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logical operators help compare arrays, check the type and contents of an
    array, and perform logical comparison between arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `all` and `any` functions help to evaluate whether all or any values along
    the specified axis evaluate to `True`. Based on the evaluation result, it returns
    `True` or `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For both the `all` and `any` methods described previously, `axis` is an optional
    parameter. When it is not provided, the array is flattened and considered for
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions test for the presence of `NAs` or infinite values in the array.
    Such functionalities are an essential part of data processing and data cleaning.
    These functions take in an array or array-like object as input and return the
    truth value as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Operators such as greater, less, and equal help to perform element-to-element
    comparison between two arrays of identical shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using broadcasting, we can work with arrays that don''t have exactly the same
    shape. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, we can see that `ar2` is broadcast across the rows of `ar` by adding
    it to each row of `ar`, producing the preceding result. Here is another example,
    showing that broadcasting works across dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, both row and column arrays were broadcast and we ended up with a 3 × 3
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Array shape manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often than not, data needs to be transformed before it becomes usable in
    analysis. The same is true for arrays. NumPy has some special sets of functions
    that help in reshaping and transforming arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `reshape` function helps to modify the shape of the array. It accepts two
    main input arguments—the array to be processed and the expected shape as an integer
    or tuple of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously in this chapter, we saw that `np.arange` should rely upon an external
    function to transform the data from being 1D:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `np.reshape` function returns a view of the data, meaning the underlying
    array remains unchanged. In special cases, however, the shape cannot be changed
    without the data being copied. For more details on this, see the documentation
    at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html).
  prefs: []
  type: TYPE_NORMAL
- en: Transposing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `transpose` function reverses the dimensions of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following result is obtained on applying `transpose` on a multidimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Ravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ravel helps to flatten the data from multidimensional to 1D:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The order in which the array is raveled can be set. The order can be `"C"`,
    `"F"`, `"A"`, or `"K"`. `"C"` is the default order, where the array gets flattened
    along the row major, while with "F", flattening occurs along the column major.
    "A" reads the array elements in a Fortran-like index-based order and "K" reads
    the elements in the order in which they are stored in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Adding a new axis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy has the `newaxis` method to add additional axes to the existing array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Basic linear algebra operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linear algebra constitutes a set of vital operations for matrices and arrays.
    The NumPy package is built with a special module called `linalg` to deal with
    all linear algebra requirements. The following segment discusses some frequently
    used functions of the `linalg` module in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dot function of the `linalg` module helps in matrix multiplication. For
    2D arrays, it behaves exactly like matrix multiplication. It requires the last
    dimension of the first array to be equal to the last dimension of the second array.
    The arrays need not have equal numbers of dimensions. For an  N-dimensional array,
    the output will have 2N-2 dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `linalg.multidot` function can help in computing the product of several
    arrays at once, instead of using a nested sequence of dot functions. This function
    automatically finds the most efficient order for evaluating the sequence of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linalg.svd` function helps in singular value decomposition and returns
    three arrays as the result of decomposition. It accepts an array with two or more
    dimensions as the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Eigenvalues and eigenvectors of an array can be calculated with the `linalg.eig`
    function. The `eig` function requires the last two dimensions of the input array
    to be a square. The same function returns both the eigenvalues and the eigenvectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `linalg` module also has functions to solve linear equations. The `linalg.solve`
    function takes in a coefficient matrix and the dependent variable, and solves
    for the exact solution. It requires that all rows of the coefficient matrix must
    be linearly independent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If the best possible solution is needed instead of the exact solution, the least-squares
    solution could be obtained from the `linalg.lstsq` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linalg.det` function computes the determinant of a square array. If there
    are more than two dimensions in the input array, it is treated as a stack of matrices
    and the determinant is computed for each stack. The last two dimensions must,
    however, correspond to a square matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Array sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays can be sorted in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting the array along an axis; first, let''s discuss this along the *y* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will explain the sorting along the *x* axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Sorting by in-place (`np.array.sort`) and out-of-place (`np.sort`) functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Other operations that are available for array sorting include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`np.min()`: This returns the minimum element in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.max()`: This returns the maximum element in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.std()`: This returns the standard deviation of the elements in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.var()`: This returns the variance of elements in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.argmin()`: This returns indices of minimum value in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.argmax()`: This returns indices of maximum value in the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.all()`: This returns elementwise logical ''and'' of all the elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.any()`: This returns elementwise logical ''or'' of all the elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to now, we have been getting acquainted with the functionalities of NumPy.
    In the coming sections, we will look at two practical examples where NumPy arrays
    are widely used for performing complex computations. After that, we will move
    on to delving deeper into the core data structures of pandas, such as DataFrames,
    Series, and Panels—how they are created, modified, and used.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing neural networks with NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While NumPy is definitely not the go-to package for training a neural network
    in real-time scenarios, learning to implement it in NumPy brings out the flexibility
    and might of NumPy for doing complex matrix computations and also provides a better
    understanding of neural networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s synthetically generate a dataset for a binary classification
    problem that will be used for training the neural network. The data will be from
    two different Gaussian distributions, and the model will be trained to classify
    this data into either of the two categories. Let''s generate the data with 1,000
    samples in each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two 1000 x 2 arrays. For the predictor variable, we can use the
    `zeros` and `ones` functions to create two different 1D arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The four arrays—X1, X2, Y1, and Y2—must be stacked together to create the complete
    training set with dimensions 2000 x 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Our aim is to build a simple neural network with one hidden layer and three
    neurons. For a moment, let's move away from NumPy to understand the architecture
    of the neural network we will be building from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a schematic diagram of a simple neural network architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0cca604-4775-4916-ab4c-485a67f061ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Schematic diagram of a simple neural network architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two neurons in the input layer, three neurons in the hidden layer,
    and a single output neuron. The squares represent the bias. To implement the neural
    network, the independent variables and predictor have been stored in `x` and `t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is a binary classification problem, a sigmoid function would be an
    ideal choice for the activation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function does the sigmoid transformation and also derivative computation
    (for backpropagation). The process of training consists of two modes of propagation—feedforward
    and backpropagation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first stage of feedforward is from the input layer to the hidden layer.
    This stage can be summarized with the following set of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ah1 = sigmoid(x1*w_ih11 + x2*w_ih21 + 1* b_ih1)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ah2 = sigmoid(x1*w_ih12 + x2*w_ih22 + 1*b_ih2)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*ah3 = sigmoid(x1*w_ih13 + x2*w_ih23 + 1*b_ih3)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `ah1`, `ah2`, and `ah3` are inputs to the next stage of the feedforward
    network, from the hidden layer to the output. This involves multiplying the input
    matrix of dimensions 2000 x 2 and weight matrix `w_ih` of dimensions 2 x 3 (three
    hidden neurons, hence 3), and then adding the bias. Instead of handling the bias
    components separately, they could be handled as part of the weight matrix. This
    can be done by adding a unit column vector to the input matrix and inserting the
    bias values as the last row of the weight matrix. Hence, the new dimensions of
    the input matrix and weight matrix would be 2000 x 3 and 3 x 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The weight matrix is initialized with random values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `*a_h*` is the input matrix for the second stage of feedforward. Just
    as in the case of input matrix *x, `a_h`* should be appended with unit column
    vectors for the bias and the second weight matrix should be initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the matrix multiplication and sigmoid transformation can be done for this
    stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity''s sake, let''s use mean squared error as the loss function,
    though it would be more appropriate to use a log loss function for a classification
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: E = ((1 / 2) * (np.power((a_o - t), 2)))
  prefs: []
  type: TYPE_NORMAL
- en: This marks the end of feedforward and the beginning of backpropagation. Backpropagation
    aims to find the delta or difference to be made to the weights and biases for
    the error *E* to reduce. The entire process of backpropagation can be summarized
    in the following two equations.
  prefs: []
  type: TYPE_NORMAL
- en: The first one calculates the change in loss function *E* w.r.t *w_ho* and the
    second one calculates the change in loss function *E* w.r.t *w_ih:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/770f0a28-dc2c-4cdf-a2ee-d97502b222af.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/43af660e-3839-4454-b051-0f6acec1f14e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the implementation of these equations in NumPy is as simple as computing
    all the derivatives necessary and finding the corresponding products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The change to be made to the weight has been computed. Let''s use these delta
    values to update the weights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `*eta*` is the learning rate of the model. Feedforward will take place
    again using the updated weights. Backpropagation will again follow to reduce the
    error. Hence, feedforward and backpropagation should take place iteratively for
    a set number of epochs. The complete code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The neural network has been implemented for 5,000 epochs. This is a simple yet
    efficient model quite suitable for a range of problems. Good accuracy can be obtained
    by choosing the right epoch, learning rate, loss function, and activation function.
    To test and validate, make use of just the feedforward module.
  prefs: []
  type: TYPE_NORMAL
- en: Practical applications of multidimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Panel data (spreadsheet-like data with several distinguishable rows and columns;
    the kind of data we generally encounter) is best handled by the DataFrame data
    structure available in pandas and R. Arrays can be used too but it would be tedious.
  prefs: []
  type: TYPE_NORMAL
- en: So what is a good example of data in real life that can be best represented
    by an array? Images, which are generally represented as multidimensional arrays
    of pixels, are a good example. In this section, we will see examples of multidimensional
    representation of an image and why it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Any object detection or image-processing algorithm performed on an image requires
    it to be represented in a numerical array format. For text data, term-document
    matrix and **term frequency-inverse document frequency** (**TF-IDF**) are used
    to vectorize (create numerical arrays) the data. In the case of an image, pixel
    values are used to represent an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a 100 x 50 pixel RGB image, there would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 5,000 pixel values in one channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three channels each for red, blue, and green
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, if you flatten the image pixels as one single vector, its length would
    be 15,000 (5,000 for each of the three channels). A grayscale image would contain
    a single channel. Each pixel value represents the degree of brightness for each
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dataset of multiple images then becomes four-dimensional data representing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Width of the image in pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Height of the image in pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial number of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s verify the shape of the resultant image pixel arrays by reading an image.
    To work with images, a Python package called **opencv** (`cv2`) is quite helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `imread` method returns an array of pixels. Let''s check the object type
    of the returned object `img`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This returns `<class 'numpy.ndarray'>`, which confirms that it returns a `numpy`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s have a look at the shape of the array. It should return us the
    pixel width, pixel height, and number of channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This returns (183, 275, 3).
  prefs: []
  type: TYPE_NORMAL
- en: It is a tuple of three numbers representing image height in pixels, image width
    in pixels, and number of channels. Hence, this image has a height of 183 pixels,
    a width of 275 pixels, and three channels of the dimension 183 x 275 representing
    red, blue, and green.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `img` object looks as follows on printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45a81f61-f7c1-4478-ac6c-1ea05abccf92.png)'
  prefs: []
  type: TYPE_IMG
- en: Image pixels as a multidimensional array
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the question arises, why would someone want to subset an array of image
    pixels? There can be multiple reasons for that:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and/or manipulating a region of interest in the image. This can be
    a small block of the image representing an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting only one color channel from the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The array of pixels can be seen as a plot/image with pixel height and pixel
    width as the axes labels as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc06a144-45ed-47fa-8a48-76a246519643.png)'
  prefs: []
  type: TYPE_IMG
- en: Image pixel arrays plotted as an image
  prefs: []
  type: TYPE_NORMAL
- en: Selecting only one channel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, the third dimension denotes the RGB channel. Hence, to filter
    all the pixels in one channel, we should select all the pixels in the first two
    dimensions and only the channel of interest. Also, the indexing in Python starts
    from 0, thus 0 represents red, 1 represents green, and 2 represents blue. Keeping
    these in mind, let's have a look at the snippets to select the red, green, and
    blue channels of an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet to select the red is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f214d64-224b-44ed-bff5-98cae2c4add8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image pixel array made of selecting only pixels in the red channel visualized
    as an image
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet to select the green is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5a6e4c2-393f-4a3d-9a0b-ff4dfc11077f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image pixel array made of selecting only pixels in the green channel visualized
    as an image
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet to select the blue is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/013cbf29-7d82-4c16-91c8-bdfccc7e6c14.png)'
  prefs: []
  type: TYPE_IMG
- en: Image pixel array made of selecting only pixels in the blue channel visualized
    as an image
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the region of interest of an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to select the tree in the preceding screenshot. Looking at the image
    with axis labels, it is evident that vertical bounds of the tree are within 50
    to 155 pixels while horizontal bounds are within 95 to 190 pixels. Let''s try
    to subset this region with all the channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows us the **region of interest** (**ROI**) that is selected
    therein:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/f8bd95c3-e4a9-4ed7-b0b2-bea749b34226.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an ROI in an image
  prefs: []
  type: TYPE_NORMAL
- en: This operation is akin to cropping an image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pixel values of a certain ROI or a channel can be assigned some different
    values. This can be used to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove certain channels (if we replace the values in that channel with 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste a certain ROI to another part of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example of the latter case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the selected ROI that is being pasted to another
    image area:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/025d5551-131f-4e3d-9de8-04017e15976b.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Pasting a selected ROI to another image area
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have copied the tree ROI and pasted it to an area to the
    left of the selected ROI. This has been obtained by assigning the pixels of the
    pasting destination values equal to the pixel value of the copy source.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple channel selection and suppressing other channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show pixels of only a certain color, the pixels of other colors need to
    be suppressed or assigned a value of 0\. The channel selection can happen via
    indexing or by passing a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing**: Keep in mind that, while indexing, the value to the right of
    the colon represents the higher limit of the channel. It also counts up to *n*-1\.
    For example, `img[:,:,1:3]` will select channels up to channel 2, namely blue,
    starting from channel 1, namely green, but not channel 0, namely red. The snippet  `img[:,:,0:2]`
    will select channel 0 (red channel) and channel 1 (green) but not channel 2 (blue).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: A list such as [0,2] would mean selecting channels 0 and 2, namely
    red and blue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we suppress the non-red, non-green, and non-blue
    pixels so that the resultant pixels appear red, green, and blue respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/94ffe739-2eab-45c1-b5eb-5b45fe244548.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Panel showing image obtained by suppressing the two channels so that it shows
    only the third color (green and blue, red and blue, and red and green respectively
    are suppressed in the three images from left to right)
  prefs: []
  type: TYPE_NORMAL
- en: Audio data can also be represented as arrays of pressure readings across a horizontal
    distance. Similar array manipulation techniques can be used there.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures in pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pandas package was created by Wes McKinney in 2008 as a result of frustrations
    he encountered while working on time series data in R. It is built on top of NumPy
    and provides features not available in it. It provides fast, easy-to-understand
    data structures and helps fill the gap between Python and a language like R. NumPy
    deals with homogeneous blocks of data. Using pandas helps to deal with data in
    a tabular structure composed of different data types.
  prefs: []
  type: TYPE_NORMAL
- en: The official documentation for pandas can be found at [http://pandas.pydata.org/pandas-docs/stable/dsintro.html](http://pandas.pydata.org/pandas-docs/stable/dsintro.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main data structures in pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: Series—1D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame—2D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panel—3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Series is really a 1D NumPy array under the hood. It consists of a NumPy array
    coupled with an array of labels. Just like a NumPy array, a series can be wholly
    composed of any data type. The labels are together called the index of the series.
    A series consists of two components—1D data and the index.
  prefs: []
  type: TYPE_NORMAL
- en: Series creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The general construct for creating a series data structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, data can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An `ndarray`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A scalar value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an index is not specified, the following default index [0,... n-1] will be
    created, where n is the length of the data.
  prefs: []
  type: TYPE_NORMAL
- en: A series can be created from a variety of sources as shown in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using an ndarray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this case, the index must be the same length as the data. The following
    example creates a Series structure of seven random numbers between 0 and 1; the
    index is not specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'An index can also be string objects. The following example creates a Series
    structure of the first five months of the year with a specified index of month
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Using a Python dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dictionary consists of key-value pairs. When a dictionary is used to create
    a Series, the keys form the index, and the values form the 1D data of the Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The index of a pandas Series structure is of type `pandas.core.index.Index`
    and can be viewed as an ordered multiset.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an index is also specified when creating the Series, then this specified
    index setting overrides the dictionary keys. If the specified index contains values
    that are not keys in the original dictionary, `NaN` is appended against that index
    in the Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note that a Series also has a name attribute that can be set as shown in the
    preceding snippet. The name attribute is useful in tasks such as combining Series
    objects into a DataFrame structure.
  prefs: []
  type: TYPE_NORMAL
- en: Using a scalar value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Series can also be initialized with just a scalar value. For scalar data,
    an index must be provided. The value will be repeated for as many index values
    as possible. One possible use of this method is to provide a quick and dirty method
    of initialization, with the Series structure to be filled in later. Let''s see
    how to create a Series using scalar values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Operations on Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The behavior of a Series is very similar to that of NumPy arrays, discussed
    previously in this chapter, with one caveat being that an operation such as slicing
    also slices the index of the series.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Values can be set and accessed using the index label in a dictionary-like manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as in the case of `dict`, `KeyError` is raised if you try to retrieve
    a missing label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This error can be avoided by explicitly using `get` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the default value of `np.NaN` is specified as the value to return
    when the key does not exist in the Series structure.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The slice operation behaves the same way as a NumPy array. Slicing can be done
    using the index numbers as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Other operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arithmetic and statistical operations can be applied, just like for a NumPy
    array. Such operations take place in a vectorized mode in a Series, just as in
    NumPy arrays, and do not require to be looped through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Elementwise operations can also be performed on a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'An important feature of a Series is that data is automatically aligned based
    on the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we can see that for non-matching labels, NaN is inserted. The default
    behavior is that the union of the indexes is produced for unaligned Series structures.
    This is preferable as information is preserved rather than lost. We will handle
    missing values in pandas in a later chapter of the book.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DataFrame is a two-dimensional data structure composed of rows and columns—exactly
    like a simple spreadsheet or a SQL table. Each column of a DataFrame is a pandas
    Series. These columns should be of the same length, but they can be of different
    data types—float, int, bool, and so on. DataFrames are both value-mutable and
    size-mutable. This lets us perform operations that would alter values held within
    the DataFrame or add/delete columns to/from the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to a Series, which has a name and index as attributes, a DataFrame
    has column names and a row index. The row index can be made of either numerical
    values or strings such as month names. Indexes are needed for fast lookups as
    well as proper aligning and joining of data in pandas multilevel indexing is also
    possible in DataFrames. The following is a simple view of a DataFrame with five
    rows and three columns. In general, the index is not counted as a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Event type** | **Total attendees** | **Percentage of student
    participants** |'
  prefs: []
  type: TYPE_TB
- en: '| Monday | C | 42 | 23.56% |'
  prefs: []
  type: TYPE_TB
- en: '| Tuesday | B | 58 | 12.89% |'
  prefs: []
  type: TYPE_TB
- en: '| Wednesday | A | 27 | 45.90% |'
  prefs: []
  type: TYPE_TB
- en: '| Thursday | A | 78 | 47.89% |'
  prefs: []
  type: TYPE_TB
- en: '| Friday | B | 92 | 63.25% |'
  prefs: []
  type: TYPE_TB
- en: DataFrame creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A DataFrame is the most commonly used data structure in pandas. The constructor
    accepts many different types of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary of 1D ndarrays, lists, dictionaries, or Series structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D NumPy array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured or record ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row label indexes and column labels can be specified along with the data. If
    they're not specified, they will be generated from the input data in an intuitive
    fashion, for example, from the keys of `dict `(in the case of column labels) or
    by using `np.range(n)` in the case of row labels, where n corresponds to the number
    of rows.
  prefs: []
  type: TYPE_NORMAL
- en: A DataFrame can be created from a variety of sources as discussed in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using a dictionary of Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each individual entity of a dictionary is a key-value pair. A DataFrame is,
    in essence, a dictionary of several Series put together. The name of the Series
    corresponds to the key, and the contents of the Series correspond to the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, the dictionary with all the Series should be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding dictionary summarizes the performance of six different stocks
    and indicates that the DataFrame will have six columns. Observe that each series
    has a different set of indices and is of different length. The final DataFrame
    will contain a unique set of the values in each of the indices. If a certain column
    has no value at a row index, NA is appended to that cell automatically. Now, the
    following step wraps up this dictionary into a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print the DataFrame created in the preceding step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75b068ce-dd4c-4fbc-8730-dbd82b9d04ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The DataFrame need not necessarily have all the row and column labels from
    the original dictionary. At times, only a subset of these rows and columns may
    be needed. In such cases, the row and column indices can be restricted as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Here, a new column name, `SCNW`, which is not found in the original dictionary,
    has been added. This will result in a column named `SCNW` with NAs throughout.
    Similarly, manually passing an index name that is absent in the original data
    structure will result in a row with NAs throughout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the preceding DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be7e57c0-7726-44fc-a1f3-7bc1ada20582.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The row index and column names can be accessed as attributes of the DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Using a dictionary of ndarrays/lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, the dictionary consisted of Series as the values in
    the key-value pair. It is possible to construct a DataFrame with a dictionary
    of lists instead of a dictionary of Series. Unlike the previous case, the row
    index will not be defined anywhere in the dictionary. Hence, the row label indices
    are generated using `np.range(n)`. Therefore, it is crucial in this case for all
    lists or arrays in the dictionary to be of equal length. If this condition is
    not met, an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dictionary of lists is defined in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s convert this dictionary to a DataFrame and print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f67edac0-e7b9-4f08-ab12-ea05caed53c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the row indices are assigned continuous values from 0 to 4\. The row
    indices can also be given custom values as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e909303f-7d27-436b-940b-f289abe522b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a structured array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structured arrays are slightly different from `ndarrays`. Each field in a structured
    array can be of a different data type. For more information on structured arrays,
    refer to the following: [http://docs.scipy.org/doc/numpy/user/basics.rec.html](http://docs.scipy.org/doc/numpy/user/basics.rec.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a structured array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'This structured array has three fields for which the data types have been defined
    in a list of tuples along with the field names. The same `DataFrame` function
    can be used to construct a `DataFrame` function from a structured array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04cfbbba-25af-42b0-aa79-dd12c9cfc324.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, continuous range of integral values have been assigned to the index.
    It is possible to replace the indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62929fa6-eafd-47b1-97bb-50beb6077f22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The columns can be reordered through the `columns` argument of the `DataFrame`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897d3b35-4b88-4f87-bc43-e9017f76aa77.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a list of dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a list of dictionaries is converted to a DataFrame, each dictionary in
    the list corresponds to a row in the DataFrame and each key in each dictionary
    represents a column label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a list of dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the list of dictionaries can be converted to a DataFrame as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5e285f8-1c32-4def-973e-5917bf985ade.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a dictionary of tuples for multilevel indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A dictionary of tuples can create a structured DataFrame with hierarchically
    indexed rows and columns. The following is a dictionary of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a regular key-value pair, the key is a tuple with two values denoting
    two levels in the row index, and the value is a dictionary in which each key-value
    pair represents a column. Here, again, the key is a tuple and denotes two column
    indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now this dictionary of tuples can be converted to a DataFrame and printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fcaf4d8-6a68-4568-af64-20f6518a0490.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the series has a defined index and name. When being converted to a DataFrame,
    this index is retained and the name of the Series gets assigned as a column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88556948-0368-4e92-bc4c-afd428c9e8cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are also alternative constructors for DataFrames; they can be summarized
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrame.from_dict`: It takes a dictionary of dictionaries or sequences and
    returns a DataFrame. It slightly differs from the method discussed earlier due
    to an argument to specify order. While the other method always converts keys of
    dictionaries to columns, this constructor provides an option to convert the keys
    to row labels:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44774fca-917d-4b5d-91cc-55dcad8f314f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another method to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d87ba0c-a32e-4482-b1b1-c3c4a801b5db.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`DataFrame.from_records`: It takes a list of tuples or structured `ndarray`
    to construct a DataFrame. Unlike the method mentioned earlier for structured arrays,
    this function allows you to set one of the fields of the array as an index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/862ba2b3-6ad0-40c3-9d68-64533ecc0ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: Operations on pandas DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many operations, such as column/row indexing, assignment, concatenation, deletion,
    and so on, can be performed on DataFrames. Let's have a look at them in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Column selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A specific column can be selected out from the DataFrame, as a Series, using
    the column name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Adding a new column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new column can be added to a DataFrame by inserting a scalar value into it.
    Inserting a scalar value into any column of a DataFrame will cause the entire
    column to be filled with that scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9775ac3-2544-48f0-98e4-d7459e807914.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of a scalar value, a list of values can also be assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d8a27ac-4a7f-4241-ad93-4d4c3dd15f91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A column can also be inserted at the desired position using the `insert` method.
    This needs three arguments: the position in which the column is to be inserted,
    the new column name, and the values to be passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c12d5e49-5608-4fe6-abc6-a42ed2d8d50d.png)'
  prefs: []
  type: TYPE_IMG
- en: Deleting columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `del` command can be used to delete a single column as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93bc40ad-3ded-4965-aea4-b12b2a964b20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of `del`, the `pop` method can be used, just like in dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5764f486-de04-440e-b92a-fe73153e01cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Alignment of DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The union of two DataFrames occurs based on row and column indices. Let''s
    understand this through an example. Consider two DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The `+` operator will add values in columns with the same labels in both DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ed89cb6-bbf1-4131-bce3-5c0990bbc714.png)'
  prefs: []
  type: TYPE_IMG
- en: The columns—copper and gold—were not found in both the DataFrames. Hence, NA
    has been appended in these columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you combine a DataFrame object and a Series object, the default behavior
    is to broadcast the Series object across the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9100505a-c637-416d-8434-922c244e322a.png)'
  prefs: []
  type: TYPE_IMG
- en: Other mathematical operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic mathematical operators work on DataFrames. For example, a new column
    can be obtained as a result of adding, multiplying, subtracting, or dividing two
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c9b9d76-9d01-43da-92c9-f9c047be69c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Logical operators such as  | (or), & (and), and ^ (not) work on DataFrames.
    Consider the following two DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, performing the logical or between these two columns yields the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/098e3a86-cc56-41db-bb50-9e90d0da18be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Operations can also be performed on DataFrames using the NumPy functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e57fe462-6e84-436c-8639-dc231cb61d40.png)'
  prefs: []
  type: TYPE_IMG
- en: Panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Panel is a 3D array. It is not as widely used as Series or DataFrames. It
    is not as easily displayed on screen or visualized as the other two because of
    its 3D nature. The Panel data structure is the final piece of the data structure
    puzzle in pandas. It is less widely used. It is generally used for 3D time-series
    data. The three axis names are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`items`: This is axis 0\. Each item corresponds to a DataFrame structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`major_axis`: This is axis 1\. Each item corresponds to the rows of the DataFrame
    structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minor_axis`: This is axis 2\. Each item corresponds to the columns of each
    DataFrame structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panels are deprecated and will not be available in future versions. Hence, it's
    advisable to use multi-indexing in DataFrames instead of Panels.
  prefs: []
  type: TYPE_NORMAL
- en: As with Series and DataFrames, there are different ways to create Panel objects.
    They are explained in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using a 3D NumPy array with axis labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we show how to construct a Panel object from a 3D NumPy array. After
    defining the 3D array, a panel could be created by defining each of the three
    axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Using a Python dictionary of DataFrame objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A panel consists of several DataFrames. To create a panel, let''s define two
    DataFrames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a dictionary of these DataFrames can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Using the DataFrame.to_panel method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A multi-indexed DataFrame is comparable to a Panel. Hence, a multi-indexed
    DataFrame can be directly converted to a Panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The sources of the US/China economic data are the following sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.multpl.com/us-gdp-inflation-adjusted/table](http://www.multpl.com/us-gdp-inflation-adjusted/table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.multpl.com/united-states-population/table](http://www.multpl.com/united-states-population/table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Demographics_of_China](http://en.wikipedia.org/wiki/Demographics_of_China)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980](http://www.theguardian.com/news/datablog/2012/mar/23/china-gdp-since-1980)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Insertion, deletion, and itemwise operations behave the same as in the case
    of DataFrames. Panel structures can be rearranged by transposing them. The feature
    set of the operations of Panels is relatively underdeveloped and not as rich as
    for Series and DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was a quick tour of the power of NumPy and showed a glimpse of
    how it makes life easier while working with pandas. Some of the highlights from
    the chapter were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A  NumPy array is a versatile data structure used for containing multidimensional
    homogeneous data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a variety of methods available for slicing/dicing, creating, and manipulating
    an array in the NumPy package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy arrays have practical applications such as being the building blocks of
    linear algebra operations and a tool to manipulate multidimensional array data
    such as images and audio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays (or matrices) are the computational blocks used in advanced mathematical
    models such as neural networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy arrays are the precursors of some of the essential data structures in
    pandas, namely Series.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Series are very similar to arrays. Series are one-dimensional. A custom-index
    can be passed to Series. Arrays or lists can be converted to Series. An indexed
    Series can be converted to a DataFrame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Series, DataFrames, and Panels are other commonly used data structures in pandas,
    of which DataFrames are the most popular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-indexed DataFrames can be created using a dictionary of tuples. Simple
    dictionaries or dictionaries of lists/arrays can also be used for creating DataFrames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on a variety of data sources for I/O operations
    in pandas. pandas supports a variety of data structures and sources to be read
    from and to be written to. We will learn about all that and more in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://opencv-python-tutroals.readthedocs.io/en/latest/index.html](https://opencv-python-tutroals.readthedocs.io/en/latest/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://corochann.com/basic-image-processing-tutorial-1220.html](http://corochann.com/basic-image-processing-tutorial-1220.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
