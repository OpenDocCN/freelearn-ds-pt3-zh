- en: Selecting Subsets of Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every dimension of data in a Series or DataFrame is labeled through an Index
    object. It is this Index that separates pandas data structures from NumPy's n-dimensional
    array. Indexes provide meaningful labels for each row and column of data, and
    pandas users have the ability to select data through the use of these labels.
    Additionally, pandas allow its users to select data by the integer location of
    the rows and columns. This dual selection capability, one using labels and the
    other using integer location, makes for powerful yet confusing syntax to select
    subsets of data.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting data through the use of labels or integer location is not unique to
    pandas. Python dictionaries and lists are built-in data structures that select
    their data in exactly one of these ways. Both dictionaries and lists have precise
    instructions and limited use-cases for what may be passed to the indexing operator.
    A dictionary's key (its label) must be an immutable object, such as a string,
    integer, or tuple. Lists must either use integers or slice objects for selection.
    Dictionaries can only select one object at a time by passing the key to the indexing
    operator. In some sense, pandas is combining the ability to select data using
    integers, as with lists, and labels, as with dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Series data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting DataFrame rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting DataFrame rows and columns simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting data with both integers and labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up scalar selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing rows lazily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing lexicographically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting Series data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Series and DataFrames are complex data containers that have multiple attributes
    that use the indexing operator to select data in different ways. In addition to
    the indexing operator itself, the `.iloc` and `.loc` attributes are available
    and use the indexing operator in their own unique ways. Collectively, these attributes
    are called the **indexers**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The indexing terminology can get confusing. The term **indexing operator**
    is used here to distinguish it from the other indexers. It refers to the brackets,
    `[]` directly after a Series or DataFrame. For instance, given a Series `s`, you
    can select data in the following ways: `s[item]` and `s.loc[item]`. The first
    uses the indexing operator. The second uses the `.loc` indexer.'
  prefs: []
  type: TYPE_NORMAL
- en: Series and DataFrame indexers allow selection by integer location (like Python
    lists) and by label (like Python dictionaries). The `.iloc` indexer selects only
    by integer location and works similarly to Python lists. The `.loc` indexer selects
    only by index label, which is similar to how Python dictionaries work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both `.loc` and .`iloc` work with Series and DataFrames. This recipe shows how
    to select Series data by integer location with `.iloc` and by label with `.loc`. These
    indexers not only take scalar values but also lists and slices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset with the institution name as the index, and select
    a single column as a Series with the indexing operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.iloc` indexer makes selections only by integer location. Passing an integer
    to it returns a scalar value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To select several different integer locations, pass a list to `.iloc`. This
    returns a Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To select an equally spaced partition of data, use slice notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we turn to the `.loc` indexer, which selects only with index labels. Passing
    a single string returns a scalar value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To select several disjoint labels, use a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To select an equally spaced partition of data, use slice notation. Make sure
    that the start and stop values are strings. You can use an integer to specify
    the step size of the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The values in a Series are referenced by integers beginning from 0\. Step 2
    selects the fourth element of the Series with the `.loc` indexer. Step 3 passes
    a three-item integer list to the indexing operator, which returns a Series with
    those integer locations selected. This feature is an enhancement over a Python
    list, which is incapable of selecting multiple disjoint items in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: In step 4, slice notation with `start`, `stop`, and `step` values specified
    is used to select an entire section of a Series.
  prefs: []
  type: TYPE_NORMAL
- en: Steps 5 through 7 replicate steps 2 through 4 with the label-based indexer,
    `.loc`.  The labels must be exact matches of values in the index. To ensure our
    labels are exact, we choose four labels at random from the index in step 6 and
    store them to a list before selecting their values as a Series. Selections with
    the `.loc` indexer always include the last element, as seen in step 7.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When passing a scalar value to the indexing operator, as with step 2 and step
    5, a scalar value is returned. When passing a list or slice, as in the other steps,
    a Series is returned. This returned value might seem inconsistent, but if we think
    of a Series as a dictionary-like object that maps labels to values, then returning
    the value makes sense. To select a single item and retain the item in its Series,
    pass in as a single-item list rather than a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Care needs to be taken when using slice notation with `.loc`. If the `start`
    index appears after the `stop` index, then an empty Series is returned without
    an exception raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pandas official documentation on indexing ([http://bit.ly/2fdtZWu](http://pandas.pydata.org/pandas-docs/stable/indexing.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting DataFrame rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most explicit and preferred way to select DataFrame rows is with the `.iloc`
    and `.loc` indexers. They are capable of selecting rows or columns independently
    and simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to select rows from a DataFrame using the `.iloc`
    and `.loc` indexers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset, and set the index as the institution name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/094f0eeb-dab6-43fd-8153-7542c88c2be8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pass an integer to the `.iloc` indexer to select an entire row at that position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the same row as the preceding step, pass the index label to the `.loc`
    indexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To select a disjointed set of rows as a DataFrame, pass a list of integers
    to the `.iloc` indexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e7daa02f-de1a-4925-99c9-a5c5df191793.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same DataFrame from step 4 may be reproduced using `.loc` by passing it
    a list of the exact institution names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Use slice notation with `.iloc` to select an entire segment of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/5dd7c6d4-8c2c-4e8d-898e-41d876967360.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Slice notation also works with the `.loc` indexer and is inclusive of the last
    label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passing a scalar value, a list of scalars, or a slice object to the `.iloc`
    or `.loc` indexers causes pandas to scan the index labels for the appropriate
    rows and return them. If a single scalar value is passed, a Series is returned.
    If a list or slice object is passed, then a DataFrame is returned.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In step 5, the list of index labels can be selected directly from the DataFrame
    returned in step 4 without the need for copying and pasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Examining the Index object* recipe from [Chapter 12](a5777e1a-6de5-44f6-b291-429cbceb505f.xhtml),
    *Index Alignment.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting DataFrame rows and columns simultaneously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directly using the indexing operator is the correct method to select one or
    more columns from a DataFrame. However, it does not allow you to select both rows
    and columns simultaneously. To select rows and columns simultaneously, you will
    need to pass both valid row and column selections separated by a comma to either
    the `.iloc` or `.loc` indexers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The generic form to select rows and columns will look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `rows` and `columns` variables may be scalar values, lists, slice objects,
    or boolean sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a boolean sequence to the indexers is covered in [Chapter 11](9f721370-ae04-4425-aab9-d525335b96b3.xhtml),
    *Boolean Indexing*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, each step shows a simultaneous row and column selection using
    `.iloc` and its exact replication using `.loc`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset, and set the index as the institution name. Select
    the first three rows and the first four columns with slice notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/791eb470-4192-49a3-9429-1f9223b2eb6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select all the rows of two different columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/f80c5155-bf61-4a4a-970d-84ab736b3d2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select disjointed rows and columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/08e1066e-11d4-4eac-9fbd-799884602e5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select a single scalar value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Slice the rows and select a single column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the keys to selecting rows and columns simultaneously is to understand
    the use of the comma in the brackets. The selection to the left of the comma always
    selects rows based on the row index. The selection to the right of the comma always
    selects columns based on the column index.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to make a selection for both rows and columns simultaneously.
    Step 2 shows how to select all the rows and a subset of columns. The colon represents
    a slice object that simply returns all the values for that dimension.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When selecting a subset of rows, along with all the columns, it is not necessary
    to use a colon following a comma. The default behavior is to select all the columns
    if there is no comma present. The previous recipe selected rows in exactly this
    manner. You can, however, use a colon to represent a slice of all the columns.
    The following lines of code are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Selecting data with both integers and labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.iloc` and `.loc` indexers each select data by either integer or label
    location but are not able to handle a combination of both input types at the same
    time. In earlier versions of pandas, another indexer, `.ix`, was available to
    select data by both integer and label location. While this conveniently worked
    for those specific situations, it was ambiguous by nature and was a source of
    confusion for many pandas users. The `.ix` indexer has subsequently been deprecated
    and thus should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the `.ix` deprecation, it was possible to select the first five rows
    and the columns of the college dataset from `UGDS_WHITE` through `UGDS_UNKN` using
    `college.ix[:5, 'UGDS_WHITE':'UGDS_UNKN']`. This is now impossible to do directly
    using `.loc` or `.iloc`. The following recipe shows how to find the integer location
    of the columns and then use `.iloc` to complete the selection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset and assign the institution name (`INSTNM`) as the
    index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the Index method `get_loc` to find the integer position of the desired
    columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `col_start` and `col_end` to select columns by integer location using `.iloc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b14e2086-ab61-424c-b881-db682c2fe4c7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Step 2 first retrieves the column index through the `columns` attribute. Indexes
    have a `get_loc` method, which accepts an index label and returns its integer
    location. We find both the start and end integer locations for the columns that
    we wish to slice. We add one because slicing with `.iloc` is exclusive of the
    last item. Step 3 uses slice notation with the rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do a very similar operation to make `.loc` work with a mixture of integers
    and positions. The following shows how to select the 10th through 15th (inclusive)
    rows, along with columns `UGDS_WHITE` through `UGDS_UNKN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this same operation with `.ix` (which is deprecated, so don''t do this)
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to achieve the same results by chaining `.loc` and `.iloc` together,
    but chaining indexers is typically a bad idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Speeding up scalar selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both the `.iloc` and `.loc` indexers are capable of selecting a single element,
    a scalar value, from a Series or DataFrame. However, there exist the indexers,
    `.iat` and `.at`, which respectively achieve the same thing at faster speeds.
    Like `.iloc`, the `.iat` indexer uses integer location to make its selection and
    must be passed two integers separated by a comma. Similar to `.loc`, the `.at`
    index uses labels to make its selection and must be passed an index and column
    label separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is valuable if computational time is of utmost importance. It shows
    the performance improvement of `.iat` and `.at` over `.iloc` and `.loc` when using
    scalar selection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the `college` scoreboard dataset with the institution name as the index.
    Pass a college name and column name to `.loc` in order to select a scalar value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Achieve the same result with `.at`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `%timeit` magic command to find the difference in speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the integer locations of the preceding selections and then time the difference
    between `.iloc` and `.iat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scalar indexers, `.iat` and `.at`, only accept scalar values. They fail
    if anything else is passed to them. They are drop-in replacements for `.iloc`
    and `.loc` when doing scalar selection. The `timeit` magic command times entire
    blocks of code when preceded by two percentage signs and a single time when preceded
    by one percentage sign. It shows that about 2.5 microseconds are saved on average
    by switching to the scalar indexers. This might not be much but can add up quickly
    if scalar selection is repeatedly done in a program.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both `.iat` and `.at` work with Series as well. Pass them a single scalar value,
    and they will return a scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Slicing rows lazily
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipes in this chapter showed how the `.iloc` and `.loc` indexers
    were used to select subsets of both Series and DataFrames in either dimension.
    A shortcut to select the rows exists with just the indexing operator itself. This
    is just a shortcut to show additional features of pandas, but the primary function
    of the indexing operator is actually to select DataFrame columns. If you want
    to select rows, it is best to use `.iloc` or `.loc`, as they are unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we pass a slice object to both the Series and DataFrame indexing
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset with the institution name as the index and then
    select every other row from index 10 to 20:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8bb0dd64-541a-437e-aedb-323fbe9b57d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same slicing exists with Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Both Series and DataFrames can slice by label as well with just the indexing
    operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/84ef652c-f107-4bd0-aec4-8404794a1d74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the same slice by label with a Series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The indexing operator changes behavior based on what type of object is passed
    to it. The following pseudocode outlines how DataFrame indexing operator handles
    the object that it is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding logic covers all the most common cases but is not an exhaustive
    list. The logic for a Series is slightly different and actually more complex than
    it is for a DataFrame. Due to its complexity, it is probably a good idea to avoid
    using just the indexing operator itself on a Series and instead use the explicit
    `.iloc` and `.loc` indexers.
  prefs: []
  type: TYPE_NORMAL
- en: One acceptable use case of the Series indexing operator is when doing boolean
    indexing. See [Chapter 12](7daeb59b-3e8e-4a33-9437-2839c6ed47e4.xhtml), *Index
    Alignment* for more details.
  prefs: []
  type: TYPE_NORMAL
- en: I titled this type of row slicing in this section as *lazy*, as it does not
    use the more explicit `.iloc` or `.loc`. Personally, I always use these indexers
    whenever slicing rows, as there is never a question of exactly what I am doing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to be aware that this lazy slicing does not work for columns,
    just for DataFrame rows and Series. It also cannot be used to select both rows
    and columns simultaneously. Take, for instance, the following code, which attempts
    to select the first ten rows and two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a selection in this manner, you need to use `.loc` or `.iloc`. Here
    is one possible way that selects all the institution labels first and then uses
    the label-based indexer `.loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Slicing lexicographically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.loc` indexer typically selects data based on the exact string label of
    the index. However, it also allows you to select data based on the lexicographic
    order of the values in the index. Specifically, `.loc` allows you to select all
    rows with an index lexicographically using slice notation. This works only if
    the index is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will first sort the index and then use slice notation inside
    the `.loc` indexer to select all rows between two strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read in the college dataset, and set the institution name as the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempt to select all colleges with names lexicographically between `''Sp''`
    and `''Su''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As the index is not sorted, the preceding command fails. Let''s go ahead and
    sort the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/eaefaacf-2f58-4a04-ae64-7f9a6321af9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s rerun the same command from step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2fe10453-8789-4016-80eb-f99bf85cea0e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The normal behavior of `.loc` is to make selections of data based on the exact
    labels passed to it. It raises a `KeyError` when these labels are not found in
    the index. However, one special exception to this behavior exists whenever the
    index is lexicographically sorted, and a slice is passed to it. Selection is now
    possible between the `start` and `stop` labels of the slice, even if they are
    not exact values of the index.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this recipe, it is easy to select colleges between two letters of the alphabet.
    For instance, to select all colleges that begin with the letter `D` through `S`,
    you would use `college.loc['D':'T']`. Slicing like this is still inclusive of
    the last index so this would technically return a college with the exact name
    `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of slicing also works when the index is sorted in the opposite direction.
    You can determine which direction the index is sorted with the index attribute,
    `is_monotonic_increasing` or `is_monotonic_decreasing`. Either of these must be
    `True` in order for lexicographic slicing to work. For instance, the following
    code lexicographically sorts the index from `Z` to `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/ff1d8e8c-7a7e-4812-9426-1515879ecb40.png)'
  prefs: []
  type: TYPE_IMG
- en: Python sorts all capital letters before lowercase and all integers before capital
    letters.
  prefs: []
  type: TYPE_NORMAL
