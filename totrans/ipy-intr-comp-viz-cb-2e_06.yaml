- en: Chapter 6. Advanced Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making nicer matplotlib figures with prettyplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating beautiful statistical plots with seaborn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interactive web visualizations with Bokeh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing a NetworkX graph in the IPython notebook with D3.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting matplotlib figures to D3.js visualizations with mpld3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Vispy for high-performance interactive data visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization is a central theme of this book. We create graphics in most recipes
    because that's the most efficient way to communicate quantitative information.
    In most cases, we use matplotlib to create plots. In this chapter, we will see
    more advanced visualization features in Python.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will see a few packages that let us improve the default styling of
    matplotlib figures and the MATLAB-like pyplot interface. There are other high-level
    visualization programming interfaces that can be more convenient in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the Web platform is getting closer and closer to Python. The IPython notebook
    is a good example of this trend. In this chapter, we will see a few techniques
    and libraries to create interactive Web visualizations in Python. These techniques
    will let us combine the power of Python for data analysis and the power of the
    Web for interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will introduce Vispy, a new high-performance interactive visualization
    library for big data.
  prefs: []
  type: TYPE_NORMAL
- en: Making nicer matplotlib figures with prettyplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matplotlib is sometimes criticized for the default appearance of its figures.
    For example, the default color maps are neither aesthetically appealing nor do
    they present perceptually clear information.
  prefs: []
  type: TYPE_NORMAL
- en: There are many attempts to circumvent this problem. In this recipe, we will
    present **prettyplotlib**, created by Olga Botvinnik. This lightweight Python
    library considerably improves the default styling of many kinds of matplotlib
    figures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the installation instructions of prettyplotlib on the project's
    page at [http://github.com/olgabot/prettyplotlib](http://github.com/olgabot/prettyplotlib).
    You can basically just do `pip install prettyplotlib` in a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first import NumPy and matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then draw several curves with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're reading the printed version of this book, you won't see the colors.
    You can find the colored images on the book's website.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we create the exact same plot with prettyplotlib. We just replace the
    `matplotlib.pyplot` namespace with `prettyplotlib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s show another example with an image. We first use matplotlib''s `pcolormesh()`
    function to display a 2D array as an image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The default *rainbow* color map is known to cause visualized data to be misinterpreted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we use prettyplotlib to display the exact same image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This visualization is much clearer, in that high or low values are more obvious
    than with the rainbow color map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: prettyplotlib merely tweaks the default styling options of matplotlib. The plotting
    interface is basically the same as matplotlib. To understand how to modify matplotlib's
    styling, it is worthwhile looking at prettyplotlib's code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are other ways to improve matplotlib''s styling:'
  prefs: []
  type: TYPE_NORMAL
- en: A blog post by Randal Olson explains how to make clean and beautiful plots with
    matplotlib; this is available at [http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/](http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is some work in progress in matplotlib to add style sheet support; more
    information can be found at [http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst](http://github.com/matplotlib/matplotlib/blob/master/doc/users/style_sheets.rst)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about why rainbow color maps are misleading, at [http://eagereyes.org/basics/rainbow-color-map](http://eagereyes.org/basics/rainbow-color-map)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating beautiful statistical plots with seaborn* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating beautiful statistical plots with seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matplotlib comes with a high-level plotting API called **pyplot**. Inspired
    by MATLAB (a widespread commercial software for numerical computing), this interface
    may be a bit too low-level for scientists, in that it can lead to boilerplate
    code that is difficult to read and maintain. Yet, it is probably one of the most
    widely used plotting interfaces in the scientific Python community.
  prefs: []
  type: TYPE_NORMAL
- en: There exist higher-level, more convenient plotting interfaces. In this recipe,
    we present **seaborn** created by Michael Waskom. This library exposes a high-level
    plotting API that is specifically adapted to statistical figures. It also integrates
    nicely with pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will find the installation instructions of seaborn on the project's page
    at [http://github.com/mwaskom/seaborn](http://github.com/mwaskom/seaborn). You
    can just type `pip install seaborn` in a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy, matplotlib, and seaborn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We generate a random dataset (following the example on seaborn''s website at
    [http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb](http://nbviewer.ipython.org/github/mwaskom/seaborn/blob/master/examples/linear_models.ipynb)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Seaborn implements many easy-to-use statistical plotting functions. For example,
    here is how to create a **violin plot**. This type of plot allows us to show the
    detailed distribution of sets of points, instead of just quartiles like in box
    plots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Seaborn also implements all-in-one statistical visualization functions. For
    example, we can use a single function (`regplot()`) to perform *and* display a
    linear regression between two variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Seaborn has built-in support for pandas data structures. Here, we display the
    pair-wise correlations between all variables defined in a `DataFrame` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides seaborn, there are other high-level plotting interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Grammar of Graphics* is a book by Dr. Leland Wilkinson that has influenced
    many high-level plotting interfaces such as R''s *ggplot2*, Python''s *ggplot*
    by yhat, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vega**, by Trifacta, is a declarative visualization grammar that can be translated
    to D3.js (a JavaScript visualization library). Also, **Vincent** is a Python library
    that lets us create visualizations with Vega.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tableau's **VizQL** is a commercial database-oriented visualization language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some more references:'
  prefs: []
  type: TYPE_NORMAL
- en: Vega available at [http://trifacta.github.io/vega/](http://trifacta.github.io/vega/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vincent available at [http://vincent.readthedocs.org/en/latest/](http://vincent.readthedocs.org/en/latest/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ggplot2 available at [http://ggplot2.org/](http://ggplot2.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ggplot for Python available at [http://blog.yhathq.com/posts/ggplot-for-python.html](http://blog.yhathq.com/posts/ggplot-for-python.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VizQL available at [http://www.tableausoftware.com/fr-fr/products/technology](http://www.tableausoftware.com/fr-fr/products/technology)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Making nicer matplotlib figures with prettyplotlib* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interactive web visualizations with Bokeh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Bokeh** is a library for creating rich interactive visualizations in a browser.
    Plots are designed in Python, and they are entirely rendered in the browser. In
    this recipe, we will learn how to create and render interactive Bokeh figures
    in the IPython notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Bokeh by following the instructions on the website at [http://bokeh.pydata.org](http://bokeh.pydata.org).
    In principle, you can just type `pip install bokeh` in a terminal. On Windows,
    you can also download the binary installer from Chris Gohlke's website at [http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh](http://www.lfd.uci.edu/~gohlke/pythonlibs/#bokeh).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy and Bokeh. We need to call the `output_notebook()` function
    in order to tell Bokeh to render plots in the IPython notebook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create some random data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s draw a curve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An interactive plot is rendered in the notebook. We can pan and zoom by clicking
    on the buttons above the plot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/4818OS_06_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: An interactive plot with Bokeh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s move on to another example. We first load a sample dataset (*Iris flowers*).
    We also generate some colors based on the species of the flowers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we render an interactive scatter plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: An interactive scatter plot with Bokeh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bokeh figures in the notebook are interactive even in the absence of a Python
    server. For example, our figures can be interactive in nbviewer. Bokeh can also
    generate standalone HTML/JavaScript documents from our plots. More examples can
    be found in the gallery at [http://bokeh.pydata.org/docs/gallery.html](http://bokeh.pydata.org/docs/gallery.html).
  prefs: []
  type: TYPE_NORMAL
- en: There is an IPython extension in Bokeh that simplifies the integration of interactive
    plots in the notebook. This is available at [http://github.com/ContinuumIO/bokeh/tree/master/extensions](http://github.com/ContinuumIO/bokeh/tree/master/extensions).
  prefs: []
  type: TYPE_NORMAL
- en: In the same vein, let's mention *plot.ly*, an online commercial service for
    interactive Web-based visualization that offers Python interfaces, available at
    [http://plot.ly](http://plot.ly).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Converting matplotlib figures to D3.js visualizations with mpld3* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing a NetworkX graph in the IPython notebook with D3.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3.js ([http://d3js.org](http://d3js.org)) is a popular interactive visualization
    framework for the Web. Written in JavaScript, it allows us to create data-driven
    visualizations based on Web technologies such as HTML, SVG, and CSS. There are
    many other JavaScript visualization and charting libraries, but we will focus
    on D3.js in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Being a pure JavaScript library, D3.js has in principle nothing to do with Python.
    However, the HTML-based IPython notebook can integrate D3.js visualizations seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a graph in Python with NetworkX and visualize
    it in the IPython notebook with D3.js.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to know the basics of HTML, JavaScript, and D3.js for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We load a famous social graph published in 1977 called **Zachary''s Karate
    Club graph**. This graph represents the friendships between members of a Karate
    club. The club''s president and the instructor were involved in a dispute, resulting
    in a split of this group. Here, we simply display the graph with matplotlib (using
    the `networkx.draw()` function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4818OS_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, we''re going to display this graph in the notebook with D3.js. The first
    step is to bring this graph to JavaScript. Here, we choose to export the graph
    to JSON. D3.js generally expects each edge to be an object with a source and target.
    Also, we specify which side each member has taken (`club` attribute). NetworkX
    comes with a built-in export function that we can use here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create an HTML object that will contain the visualization.
    Here, we create a `<div>` element in the notebook. We also specify a few CSS styles
    for nodes and links (also called edges):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is trickier. We write the JavaScript code to load the graph from
    the JSON file and display it with D3.js. Knowing the basics of D3.js is required
    here (see the documentation of D3.js). The code is long, and you can find it on
    the book''s website. Here, we highlight the most important steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we execute this cell, the HTML object created in the previous cell is
    updated. The graph is animated and interactive; we can click on nodes, see their
    labels, and move them within the canvas:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/4818OS_06_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: An interactive plot in the notebook with D3.js
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3.js' gallery contains many more examples of beautiful, interactive visualizations
    for the Web. They are available at [http://github.com/mbostock/d3/wiki/Gallery](http://github.com/mbostock/d3/wiki/Gallery).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created an HTML/JavaScript interactive visualization from
    a static dataset. With IPython 2.0 and above, we can also create dynamic, real-time
    visualizations that involve bi-directional communication between the browser and
    the Python kernel. There is an experimental implementation by Brian Granger available
    at [http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb](http://nbviewer.ipython.org/github/ellisonbg/talk-2014-strata-sc/blob/master/Graph%20Widget.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Let's also mention **Vincent**, a Python to Vega translator. Vega is a JSON-based
    visualization grammar that can be translated to D3.js. Vincent makes it possible
    to design an interactive visualization in Python and render it in the browser.
    More information can be found at [http://vincent.readthedocs.org/en/latest/](http://vincent.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating interactive web visualizations with Bokeh* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting matplotlib figures to D3.js visualizations with mpld3* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting matplotlib figures to D3.js visualizations with mpld3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **mpld3** library automatically converts matplotlib figures to interactive
    D3.js visualizations. In this recipe, we will see how to use this library in the
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the mpld3 library, you can just type `pip install mpld3` in a terminal.
    See also the main website at [http://mpld3.github.io](http://mpld3.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we load NumPy and matplotlib as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we enable the mpld3 figures in the notebook with a single function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a scatter plot with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The matplotlib figure is rendered with D3.js instead of the standard matplotlib
    backend. In particular, the figure is interactive (we can pan and zoom in the
    figure):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/4818OS_06_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: An interactive matplotlib figure with mpld3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we create a more complex example with multiple subplots that represent
    different 2D projections of a 3D dataset. We use the `sharex` and `sharey` keywords
    in matplotlib''s `subplots()` function to automatically bind the *x* and *y* axes
    of the different figures. Panning and zooming in any of the subplots automatically
    updates all the other subplots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This use case is perfectly handled by mpld3; the D3.js subplots are dynamically
    linked together:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/4818OS_06_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Interactive linked subplots in mpld3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: mpld3 works by first crawling and exporting a matplotlib figure to JSON (in
    the context of the **mplexporter** framework). Then, the library generates D3.js
    code from this JSON representation. This architecture can enable other matplotlib
    backends besides D3.js.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some references:'
  prefs: []
  type: TYPE_NORMAL
- en: mplexporter available at [http://github.com/mpld3/mplexporter](http://github.com/mpld3/mplexporter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mpld3 on GitHub available at [https://github.com/jakevdp/mpld3](https://github.com/jakevdp/mpld3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating interactive web visualizations with Bokeh* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Visualizing a NetworkX graph in the IPython notebook with D3.js* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Vispy for high-performance interactive data visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most existing plotting or visualization libraries in Python can display small
    or medium datasets (that contain no more than a few tens of thousands of points).
    In the *Big Data* era, it is sometimes necessary to display larger datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Vispy ([http://vispy.org](http://vispy.org)) is a young 2D/3D high-performance
    visualization library that can display very large datasets. Vispy leverages the
    computational power of modern Graphics Processing Units (GPUs) through the OpenGL
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The power of GPUs has been fostered by the video game industry in the last two
    decades. GPUs are specialized in high-performance, real-time rendering. As such,
    they are perfectly adapted to interactive scientific plotting.
  prefs: []
  type: TYPE_NORMAL
- en: Vispy offers a Pythonic object-oriented interface to OpenGL, useful to those
    who know OpenGL or who are willing to learn it. Higher-level graphical interfaces
    are also being developed at the time of this writing, and experimental versions
    are already available. These interfaces do not require any knowledge of OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will give a brief introduction to the fundamental concepts
    of OpenGL. There are two situations where you would need to know these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use Vispy today, before the availability of the high-level plotting
    interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to create custom, sophisticated, high-performance visualizations
    that are not yet implemented in Vispy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we display a digital signal using Vispy's object-oriented interface to
    OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vispy depends on NumPy. A backend library is necessary (for example, PyQt4 or
    PySide).
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe has been tested with the development version of Vispy available
    at [http://github.com/vispy/vispy](http://github.com/vispy/vispy). You should
    clone the GitHub repository and install Vispy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The API used in this recipe might change in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import NumPy, `vispy.app` (to display a canvas), and `vispy.gloo` (object-oriented
    interface to OpenGL):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to display a window, we need to create a **Canvas**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using `vispy.gloo`, we need to write **shaders**. These programs, written
    in a C-like language, run on the GPU and give us full flexibility for our visualizations.
    Here, we create a trivial **vertex shader** that directly displays 2D data points
    (stored in the `a_position` variable) in the canvas. We will see more details
    in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other shader we need to create is the **fragment shader**. It lets us control
    the pixels'' color. Here, we display all data points in black:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create an **OpenGL** `Program`. This object contains shaders and links
    the shader variables to the NumPy data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We link the `a_position` variable to a *(1000, 2)* NumPy array that contains
    the coordinates of 1000 data points. In the default coordinate system, the coordinates
    of the four canvas corners are *(+/-1, +/-1)*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a callback function when the window is being resized. Updating the
    **OpenGL viewport** lets us ensure that Vispy uses the entire canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a callback function when the canvas needs to be refreshed. This `on_draw()`
    function renders the entire scene. First, we clear the window in white (it is
    necessary to do this at every frame). Then, we draw a succession of line segments
    using our OpenGL program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we show the canvas and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following figure shows a screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/4818OS_06_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Basic visualization example with Vispy
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL is an open standard for hardware-accelerated interactive visualization.
    It is widely used in video games, industry (**Computer-Aided Design**, or **CAD**),
    virtual reality, and scientific applications (medical imaging, computer graphics,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL is a mature technology created in the early 1990s. In the early 2000s,
    OpenGL 2.0 brought a major new feature: the possibility to customize fundamental
    steps of the **rendering pipeline**. This pipeline defines the way data is processed
    on the GPU for real-time rendering. Many OpenGL courses and tutorials cover the
    old, fixed pipeline. However, Vispy exclusively supports the modern, programmable
    pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will introduce the fundamental concepts of the programmable pipeline
    used in this recipe. OpenGL is considerably more complex than what we can cover
    here. However, Vispy provides a vastly simplified API for the most common features
    of OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vispy is based on **OpenGL ES 2.0**, a flavor of OpenGL that is supported on
    desktop computers, mobile devices, and modern web browsers (through **WebGL**).
    Modern graphics cards can support additional features. These features will be
    available in future versions of Vispy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four major elements in the rendering pipeline of a given OpenGL program:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data buffers** store numerical data on the GPU. The main types of buffers
    are **vertex buffers**, **index buffers**, and **textures**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variables** are available in the shaders. There are four major types of variables:
    **attributes**, **uniforms**, **varyings**, and **texture samplers**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shaders** are GPU programs written in a C-like language called **OpenGL Shading
    Language** (**GLSL**). The two main types of shaders are **vertex shaders** and
    **fragment shaders**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The primitive type** defines the way data points are rendered. The main types
    are points, lines, and triangles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how the rendering pipeline works:'
  prefs: []
  type: TYPE_NORMAL
- en: Data is sent to the GPU and stored in buffers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The vertex shader processes the data in parallel and generates a number of 4D
    points in a normalized coordinate system *(+/-1, +/-1)*. The fourth dimension
    is a homogeneous coordinate (generally 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Graphics primitives (points, lines, and triangles) are generated from the data
    points returned by the vertex shader (**primitive assembly** and **rasterization**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fragment shader processes all primitive pixels in parallel and returns each
    pixel's color as RGBA components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this recipe''s example, there is only one GPU variable: the `a_position`
    attribute. An **attribute** is a variable that takes one value per data point.
    **Uniforms** are global variables (shared by all data points), whereas **varyings**
    are used to pass values from the vertex shader to the fragment shader (with automatic
    linear interpolation for a pixel between two or three vertices).'
  prefs: []
  type: TYPE_NORMAL
- en: In `vispy.gloo`, a `Program` is created with the vertex and fragment shaders.
    Then, the variables declared in the shaders can be set with the `program['varname']
    = value` syntax. When `varname` is an attribute variable, the value can just be
    a NumPy 2D array. In this array, every line contains the components of every data
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can declare uniforms and textures in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `program.draw()` function renders the data using the specified
    primitive type. Here, the `line_strip` primitive type tells the GPU to run through
    all vertices (as returned by the vertex buffer) and to draw a line segment from
    one point to the next. If there are *n* points, there will be *n-1* line segments.
  prefs: []
  type: TYPE_NORMAL
- en: Other primitive types include points and triangles, with several ways of generating
    lines or triangles from a list of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, an index buffer can be provided. An index buffer contains indices
    pointing to the vertex buffers. Using an index buffer would allow us to reuse
    any vertex multiple times during the primitive assembly stage. For example, when
    rendering a cube with a `triangles` primitive type (one triangle is generated
    for every triplet of points), we can use a vertex buffer with eight data points
    and an index buffer with thirty-six indices (three points per triangle, two triangles
    per face, and six faces).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example shown here is extremely simple. The approach provided by OpenGL
    and Vispy is nevertheless particularly powerful. It gives us full control on the
    rendering pipeline, and it allows us to leverage the computational power of GPUs
    in a nearly optimal way.
  prefs: []
  type: TYPE_NORMAL
- en: High performance is achieved by minimizing the number of data transfers to the
    GPU. When displaying static data (for example, a scatter plot), it is possible
    to send the data to the GPU at initialization time only. Yet, rendering dynamic
    data is reasonably fast; the order of magnitude of data transfers is roughly 1
    GBps.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is critical to use as few OpenGL draw calls as possible. Every
    draw incurs a significant overhead. High performance is achieved by rendering
    all similar primitive types at once (**batch rendering**). GPUs are particularly
    efficient with batch rendering, even when the properties of the points are different
    (for example, points with various sizes and colors).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, geometric or pixel transformations can be executed on the GPU with
    very high performance using the shaders. The massive architecture of GPUs, consisting
    of hundreds or thousands of computing units, is fully leveraged when transformations
    are implemented in the shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'General-purpose computations can be done in the shaders in the context of visualization.
    There is one major drawback compared to proper GPGPU frameworks like CUDA or OpenCL:
    in the vertex shader, a given thread has access to one data point only. Similarly,
    in the fragment shader, a thread has only access to one pixel. Yet, certain types
    of simulations or visualization effects require interactions between vertices
    or pixels. There are ways to mitigate this issue, but they lead to a drop in performance.'
  prefs: []
  type: TYPE_NORMAL
- en: However, it is possible to interoperate OpenGL with CUDA/OpenCL. Buffers can
    be shared between OpenGL and the GPGPU framework. Complex CUDA/OpenCL computations
    can be implemented on vertex buffers or textures in real-time, leading to highly
    efficient rendering of numerical simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Vispy for scientific visualization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen in this recipe, Vispy requires the user to know OpenGL and GLSL.
    However, higher-level graphical interfaces are currently being developed. These
    interfaces will bring to scientists the power of GPUs for high-performance interactive
    visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visuals** will provide reusable, reactive graphical components like shapes,
    polygons, 3D meshes, graphs, and others. These visuals will be fully customizable
    and can be used without knowledge of OpenGL. A **shader composition system** will
    allow advanced users to reuse snippets of GLSL code in a modular way.'
  prefs: []
  type: TYPE_NORMAL
- en: Visuals will be organized within a **scene graph** implementing GPU-based **transformations**.
  prefs: []
  type: TYPE_NORMAL
- en: Scientific plotting interfaces will be implemented. Vispy can also serve as
    a high-performance backend for existing plotting libraries such as matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Vispy will also support full integration in the IPython notebook using WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, Vispy will be able to implement many kinds of scientific visualizations:'
  prefs: []
  type: TYPE_NORMAL
- en: Scatter plots can be rendered efficiently with **point sprites**, using one
    vertex per data point. Panning and zooming can be implemented in the vertex shader,
    enabling fast interactive visualization of millions of points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static or dynamic (real-time) digital signals can be displayed with polylines.
    High-quality rendering of curves can be achieved using an OpenGL implementation
    of **Anti-Grain Geometry**, a high-quality 2D rendering library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs can be displayed by combining points and line segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D meshes can be displayed with triangles and index buffers. Geometric transformations
    and realistic lighting can be implemented in the vertex and fragment shaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time streams of images can be displayed efficiently with textures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axes, grids, ticks, text, and labels can be rendered efficiently in the fragment
    shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many examples can be found in Vispy's gallery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Vispy's gallery available at [http://vispy.org/gallery.html](http://vispy.org/gallery.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern OpenGL tutorial, by Nicolas P. Rougier, available at [http://www.loria.fr/~rougier/teaching/opengl/](http://www.loria.fr/~rougier/teaching/opengl/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hardware-accelerated interactive data visualization for neuroscience in Python*,
    an article available at [http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full](http://journal.frontiersin.org/Journal/10.3389/fninf.2013.00036/full)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vispy users mailing list available at [http://groups.google.com/forum/#!forum/vispy](http://groups.google.com/forum/#!forum/vispy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vispy-dev mailing list available at [http://groups.google.com/forum/#!forum/vispy-dev](http://groups.google.com/forum/#!forum/vispy-dev)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Anti-Grain Geometry library on Wikipedia, available at [http://en.wikipedia.org/wiki/Anti-Grain_Geometry](http://en.wikipedia.org/wiki/Anti-Grain_Geometry)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
