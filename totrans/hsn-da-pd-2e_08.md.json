["```py\n>>> import seaborn as sns\n```", "```py\n>>> %matplotlib inline\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> import pandas as pd \n>>> fb = pd.read_csv(\n...     'data/fb_stock_prices_2018.csv',\n...     index_col='date', \n...     parse_dates=True\n... )\n>>> quakes = pd.read_csv('data/earthquakes.csv')\n```", "```py\n>>> sns.stripplot(\n...     x='magType', \n...     y='mag', \n...     hue='tsunami',\n...     data=quakes.query('parsed_place == \"Indonesia\"')\n... )\n```", "```py\n>>> sns.swarmplot(\n...     x='magType', \n...     y='mag', \n...     hue='tsunami',\n...     data=quakes.query('parsed_place == \"Indonesia\"'),\n...     size=3.5 # point size\n... )\n```", "```py\n>>> sns.boxenplot(\n...     x='magType', y='mag', data=quakes[['magType', 'mag']]\n... )\n>>> plt.title('Comparing earthquake magnitude by magType')\n```", "```py\n>>> fig, axes = plt.subplots(figsize=(10, 5))\n>>> sns.violinplot(\n...     x='magType', y='mag', data=quakes[['magType', 'mag']], \n...     ax=axes, scale='width' # all violins have same width\n... )\n>>> plt.title('Comparing earthquake magnitude by magType')\n```", "```py\n>>> sns.heatmap(\n...     fb.sort_index().assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low\n...     ).corr(), \n...     annot=True, \n...     center=0, \n...     vmin=-1, \n...     vmax=1\n... )\n```", "```py\n>>> sns.pairplot(fb)\n```", "```py\n>>> sns.pairplot(\n...     fb.assign(quarter=lambda x: x.index.quarter), \n...     diag_kind='kde', hue='quarter'\n... )\n```", "```py\n>>> sns.jointplot(\n...     x='log_volume', \n...     y='max_abs_change', \n...     data=fb.assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low\n...     )\n... )\n```", "```py\n>>> sns.jointplot(\n...     x='log_volume', \n...     y='max_abs_change', \n...     kind='hex',\n...     data=fb.assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low\n...     )\n... )\n```", "```py\n>>> sns.jointplot(\n...     x='log_volume', \n...     y='max_abs_change', \n...     kind='kde',\n...     data=fb.assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low\n...     )\n... )\n```", "```py\n>>> sns.jointplot(\n...     x='log_volume', \n...     y='max_abs_change', \n...     kind='reg',\n...     data=fb.assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low\n...     )\n... )\n```", "```py\n>>> sns.jointplot(\n...     x='log_volume', \n...     y='max_abs_change', \n...     kind='resid',\n...     data=fb.assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low\n...     )\n... )\n# update y-axis label (discussed next section)\n>>> plt.ylabel('residuals')\n```", "```py\n>>> fb_reg_data = fb.assign(\n...     log_volume=np.log(fb.volume), \n...     max_abs_change=fb.high - fb.low\n... ).iloc[:,-2:]\n```", "```py\n>>> import itertools\n```", "```py\n>>> iterator = itertools.repeat(\"I'm an iterator\", 1)\n>>> for i in iterator:\n...     print(f'-->{i}')\n-->I'm an iterator\n>>> print(\n...     'This printed once because the iterator '\n...     'has been exhausted'\n... )\nThis printed once because the iterator has been exhausted\n>>> for i in iterator:\n...     print(f'-->{i}')\n```", "```py\n>>> iterable = list(itertools.repeat(\"I'm an iterable\", 1))\n>>> for i in iterable:\n...     print(f'-->{i}')\n-->I'm an iterable\n>>> print('This prints again because it\\'s an iterable:')\nThis prints again because it's an iterable:\n>>> for i in iterable:\n...     print(f'-->{i}')\n-->I'm an iterable\n```", "```py\ndef reg_resid_plots(data):\n    \"\"\"\n    Using `seaborn`, plot the regression and residuals plots \n    side-by-side for every permutation of 2 columns in data.\n    Parameters:\n        - data: A `pandas.DataFrame` object\n    Returns:\n        A matplotlib `Axes` object.\n    \"\"\"\n    num_cols = data.shape[1]\n    permutation_count = num_cols * (num_cols - 1)\n    fig, ax = \\\n        plt.subplots(permutation_count, 2, figsize=(15, 8))\n    for (x, y), axes, color in zip(\n        itertools.permutations(data.columns, 2), \n        ax,\n        itertools.cycle(['royalblue', 'darkorange'])\n    ):\n        for subplot, func in zip(\n            axes, (sns.regplot, sns.residplot)\n        ):\n            func(x=x, y=y, data=data, ax=subplot, color=color)\n            if func == sns.residplot:\n                subplot.set_ylabel('residuals')\n    return fig.axes\n```", "```py\n>>> from viz import reg_resid_plots\n>>> reg_resid_plots(fb_reg_data)\n```", "```py\n>>> sns.lmplot(\n...     x='log_volume', \n...     y='max_abs_change', \n...     col='quarter',\n...     data=fb.assign(\n...         log_volume=np.log(fb.volume), \n...         max_abs_change=fb.high - fb.low,\n...         quarter=lambda x: x.index.quarter\n...     )\n... )\n```", "```py\n>>> g = sns.FacetGrid(\n...     quakes.query(\n...         'parsed_place.isin('\n...         '[\"Indonesia\", \"Papua New Guinea\"]) '\n...         'and magType == \"mb\"'\n...     ),   \n...     row='tsunami',\n...     col='parsed_place',\n...     height=4\n... )\n```", "```py\n>>> g = g.map(sns.histplot, 'mag', kde=True)\n```", "```py\n>>> %matplotlib inline\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> import pandas as pd \n>>> fb = pd.read_csv(\n...     'data/fb_stock_prices_2018.csv', \n...     index_col='date', \n...     parse_dates=True\n... ) \n>>> covid = pd.read_csv('data/covid19_cases.csv').assign(\n...     date=lambda x: \\\n...         pd.to_datetime(x.dateRep, format='%d/%m/%Y')\n... ).set_index('date').replace(\n...     'United_States_of_America', 'USA'\n... ).sort_index()['2020-01-18':'2020-09-18']\n```", "```py\n>>> fb.close.plot()\n>>> plt.title('FB Closing Price')\n>>> plt.xlabel('date')\n>>> plt.ylabel('price ($)')\n```", "```py\n>>> fb.iloc[:,:4]\\\n...     .plot(subplots=True, layout=(2, 2), figsize=(12, 5))\n>>> plt.title('Facebook 2018 Stock Data')\n>>> plt.ylabel('price ($)')\n```", "```py\n>>> axes = fb.iloc[:,:4]\\\n...     .plot(subplots=True, layout=(2, 2), figsize=(12, 5))\n>>> plt.suptitle('Facebook 2018 Stock Data')\n>>> for ax in axes.flatten():\n...     ax.set_ylabel('price ($)')\n```", "```py\n>>> fb.assign(\n...     ma=lambda x: x.close.rolling(20).mean()\n... ).plot(\n...     y=['close', 'ma'], \n...     title='FB closing price in 2018',\n...     label=['closing price', '20D moving average'],\n...     style=['-', '--']\n... )\n>>> plt.legend(loc='lower left')\n>>> plt.ylabel('price ($)')\n```", "```py\n>>> new_cases = covid.reset_index().pivot(\n...     index='date',\n...     columns='countriesAndTerritories',\n...     values='cases'\n... ).fillna(0)\n>>> pct_new_cases = new_cases.apply(\n...     lambda x: x / new_cases.apply('sum', axis=1), axis=0\n... )[\n...     ['Italy', 'China', 'Spain', 'USA', 'India', 'Brazil']\n... ].sort_index(axis=1).fillna(0)\n>>> ax = pct_new_cases.plot(\n...     figsize=(12, 7),\n...     style=['-'] * 3 + ['--', ':', '-.'],\n...     title='Percentage of the World\\'s New COVID-19 Cases'\n...           '\\n(source: ECDC)'\n... )\n>>> ax.legend(title='Country', framealpha=0.5, ncol=2)\n>>> ax.set_xlabel('')\n>>> ax.set_ylabel('percentage of the world\\'s COVID-19 cases')\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> ax = pct_new_cases.plot(\n...     figsize=(12, 7),\n...     style=['-'] * 3 + ['--', ':', '-.'],\n...     title='Percentage of the World\\'s New COVID-19 Cases'\n...           '\\n(source: ECDC)'\n... )\n>>> ax.legend(framealpha=0.5, ncol=2)\n>>> ax.set_xlabel('')\n>>> ax.set_ylabel('percentage of the world\\'s COVID-19 cases')\n>>> ax.set_ylim(0, None)\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> ax = pct_new_cases.plot(\n...     figsize=(12, 7),\n...     style=['-'] * 3 + ['--', ':', '-.'],\n...     title='Percentage of the World\\'s New COVID-19 Cases'\n...           '\\n(source: ECDC)'\n... )\n>>> tick_locs = covid.index[covid.index.day == 18].unique()\n>>> tick_labels = \\\n...     [loc.strftime('%b %d\\n%Y') for loc in tick_locs]\n>>> plt.xticks(tick_locs, tick_labels)\n>>> ax.legend(framealpha=0.5, ncol=2)\n>>> ax.set_xlabel('')\n>>> ax.set_ylabel('percentage of the world\\'s COVID-19 cases')\n>>> ax.set_ylim(0, None)\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> from matplotlib.ticker import PercentFormatter\n>>> ax = pct_new_cases.plot(\n...     figsize=(12, 7),\n...     style=['-'] * 3 + ['--', ':', '-.'],\n...     title='Percentage of the World\\'s New COVID-19 Cases'\n...           '\\n(source: ECDC)'\n... )\n>>> tick_locs = covid.index[covid.index.day == 18].unique()\n>>> tick_labels = \\\n...     [loc.strftime('%b %d\\n%Y') for loc in tick_locs]\n>>> plt.xticks(tick_locs, tick_labels)\n>>> ax.legend(framealpha=0.5, ncol=2)\n>>> ax.set_xlabel('')\n>>> ax.set_ylabel('percentage of the world\\'s COVID-19 cases')\n>>> ax.set_ylim(0, None)\n>>> ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> from matplotlib.ticker import EngFormatter\n>>> ax = covid.query('continentExp != \"Other\"').groupby([\n...     'continentExp', pd.Grouper(freq='1D')\n... ]).cases.sum().unstack(0).apply('cumsum').plot(\n...     style=['-', '-', '--', ':', '-.'],\n...     title='Cumulative COVID-19 Cases per Continent'\n...           '\\n(source: ECDC)'\n... )\n>>> ax.legend(title='', loc='center left')\n>>> ax.set(xlabel='', ylabel='total COVID-19 cases')\n>>> ax.yaxis.set_major_formatter(EngFormatter())\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> ax = new_cases.New_Zealand['2020-04-18':'2020-09-18'].plot(\n...     title='Daily new COVID-19 cases in New Zealand'\n...           '\\n(source: ECDC)'\n... )\n>>> ax.set(xlabel='', ylabel='new COVID-19 cases')\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> from matplotlib.ticker import MultipleLocator\n>>> ax = new_cases.New_Zealand['2020-04-18':'2020-09-18'].plot(\n...     title='Daily new COVID-19 cases in New Zealand'\n...           '\\n(source: ECDC)'\n... )\n>>> ax.set(xlabel='', ylabel='new COVID-19 cases') \n>>> ax.yaxis.set_major_locator(MultipleLocator(base=3))\n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> %matplotlib inline\n>>> import matplotlib.pyplot as plt\n>>> import pandas as pd\n>>> fb = pd.read_csv(\n...     'data/fb_stock_prices_2018.csv', \n...     index_col='date', \n...     parse_dates=True\n... )\n>>> quakes = pd.read_csv('data/earthquakes.csv')\n```", "```py\n>>> from stock_analysis import StockAnalyzer\n>>> fb_analyzer = StockAnalyzer(fb)\n>>> support, resistance = (\n...     getattr(fb_analyzer, stat)(level=3)\n...     for stat in ['support', 'resistance']\n... )\n>>> support, resistance\n(124.4566666666667, 138.5266666666667)\n```", "```py\n>>> fb.close['2018-12']\\\n...     .plot(title='FB Closing Price December 2018')\n>>> plt.axhline(\n...     y=resistance, color='r', linestyle='--',\n...     label=f'resistance (${resistance:,.2f})'\n... )\n>>> plt.axhline(\n...     y=support, color='g', linestyle='--',\n...     label=f'support (${support:,.2f})'\n... )\n>>> plt.ylabel('price ($)')\n>>> plt.legend()\n```", "```py\nimport itertools\ndef std_from_mean_kde(data):\n    \"\"\"\n    Plot the KDE along with vertical reference lines\n    for each standard deviation from the mean.\n    Parameters:\n        - data: `pandas.Series` with numeric data\n    Returns:\n        Matplotlib `Axes` object.\n    \"\"\"\n    mean_mag, std_mean = data.mean(), data.std()\n    ax = data.plot(kind='kde')\n    ax.axvline(mean_mag, color='b', alpha=0.2, label='mean')\n    colors = ['green', 'orange', 'red']\n    multipliers = [1, 2, 3]\n    signs = ['-', '+']\n    linestyles = [':', '-.', '--']\n    for sign, (color, multiplier, style) in itertools.product(\n        signs, zip(colors, multipliers, linestyles)\n    ):\n        adjustment = multiplier * std_mean\n        if sign == '-':\n            value = mean_mag – adjustment\n            label = '{} {}{}{}'.format(\n                r'$\\mu$', r'$\\pm$', multiplier, r'$\\sigma$'\n            )\n        else:\n            value = mean_mag + adjustment\n            label = None # label each color only once\n        ax.axvline(\n            value, color=color, linestyle=style, \n            label=label, alpha=0.5\n        )\n    ax.legend()\n    return ax\n```", "```py\n>>> from viz import std_from_mean_kde\n>>> ax = std_from_mean_kde(\n...     quakes.query(\n...         'magType == \"mb\" and parsed_place == \"Indonesia\"'\n...     ).mag\n... )\n>>> ax.set_title('mb magnitude distribution in Indonesia')\n>>> ax.set_xlabel('mb earthquake magnitude')\n```", "```py\n>>> ax = fb.close.plot(title='FB Closing Price')\n>>> ax.axhspan(support, resistance, alpha=0.2)\n>>> plt.ylabel('Price ($)')\n```", "```py\n>>> fb_q4 = fb.loc['2018-Q4']\n>>> plt.fill_between(fb_q4.index, fb_q4.high, fb_q4.low)\n>>> plt.xticks([\n...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'\n... ])\n>>> plt.xlabel('date')\n>>> plt.ylabel('price ($)')\n>>> plt.title(\n...     'FB differential between high and low price Q4 2018'\n... )\n```", "```py\n>>> fb_q4 = fb.loc['2018-Q4']\n>>> plt.fill_between(\n...     fb_q4.index, fb_q4.high, fb_q4.low, \n...     where=fb_q4.index.month == 12, \n...     color='khaki', label='December differential'\n... )\n>>> plt.plot(fb_q4.index, fb_q4.high, '--', label='daily high')\n>>> plt.plot(fb_q4.index, fb_q4.low, '--', label='daily low') \n>>> plt.xticks([\n...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'\n... ])\n>>> plt.xlabel('date')\n>>> plt.ylabel('price ($)')\n>>> plt.legend()\n>>> plt.title(\n...     'FB differential between high and low price Q4 2018'\n... )\n```", "```py\n>>> ax = fb.close.plot(\n...     title='FB Closing Price 2018',\n...     figsize=(15, 3)\n... )\n>>> ax.set_ylabel('price ($)')\n>>> ax.axhspan(support, resistance, alpha=0.2)\n>>> plt.annotate(\n...     f'support\\n(${support:,.2f})',\n...     xy=('2018-12-31', support),\n...     xytext=('2019-01-21', support),\n...     arrowprops={'arrowstyle': '->'}\n... )\n>>> plt.annotate(\n...     f'resistance\\n(${resistance:,.2f})',\n...     xy=('2018-12-23', resistance)\n... ) \n>>> for spine in ['top', 'right']:\n...     ax.spines[spine].set_visible(False)\n```", "```py\n>>> close_price = fb.loc['2018-07-25', 'close']\n>>> open_price = fb.loc['2018-07-26', 'open']\n>>> pct_drop = (open_price - close_price) / close_price\n>>> fb.close.plot(title='FB Closing Price 2018', alpha=0.5)\n>>> plt.annotate(\n...     f'{pct_drop:.2%}', va='center',\n...     xy=('2018-07-27', (open_price + close_price) / 2),\n...     xytext=('2018-08-20', (open_price + close_price) / 2),\n...     arrowprops=dict(arrowstyle='-[,widthB=4.0,lengthB=0.2')\n... )\n>>> plt.ylabel('price ($)')\n```", "```py\n>>> fb.plot(\n...     y='open',\n...     figsize=(5, 3),\n...     color='#8000FF',\n...     legend=False,\n...     title='Evolution of FB Opening Price in 2018'\n... )\n>>> plt.ylabel('price ($)')\n```", "```py\nfb.plot(\n    y='open',\n    figsize=(5, 3),\n    color=(128 / 255, 0, 1),\n    legend=False,\n    title='Evolution of FB Opening Price in 2018'\n)\nplt.ylabel('price ($)')\n```", "```py\n>>> from matplotlib import cm\n>>> cm.datad.keys()\ndict_keys(['Blues', 'BrBG', 'BuGn', 'BuPu', 'CMRmap', 'GnBu', \n           'Greens', 'Greys', 'OrRd', 'Oranges', 'PRGn', \n           'PiYG', 'PuBu', 'PuBuGn', 'PuOr', 'PuRd', 'Purples', \n           'RdBu', 'RdGy', 'RdPu', 'RdYlBu', 'RdYlGn', \n           'Reds', ..., 'Blues_r', 'BrBG_r', 'BuGn_r', ...])\n```", "```py\n>>> ax = fb.assign(\n...     rolling_min=lambda x: x.low.rolling(20).min(),\n...     rolling_max=lambda x: x.high.rolling(20).max()\n... ).plot(\n...     y=['rolling_max', 'rolling_min'], \n...     colormap='coolwarm_r', \n...     label=['20D rolling max', '20D rolling min'],\n...     style=[':', '--'],\n...     figsize=(12, 3),\n...     title='FB closing price in 2018 oscillating between '\n...           '20-day rolling minimum and maximum price'\n... )\n>>> ax.plot(\n...     fb.close, 'purple', alpha=0.25, label='closing price'\n... )\n>>> plt.legend()\n>>> plt.ylabel('price ($)')\n```", "```py\n>>> cm.get_cmap('ocean')(.5)\n(0.0, 0.2529411764705882, 0.5019607843137255, 1.0)\n```", "```py\n>>> import color_utils\n```", "```py\nimport re\ndef hex_to_rgb_color_list(colors):\n    \"\"\"\n    Take color or list of hex code colors and convert them \n    to RGB colors in the range [0,1].\n    Parameters:\n        - colors: Color or list of color strings as hex codes\n    Returns:\n        The color or list of colors in RGB representation.\n    \"\"\"\n    if isinstance(colors, str):\n        colors = [colors]\n    for i, color in enumerate(\n        [color.replace('#', '') for color in colors]\n    ):\n        hex_length = len(color)\n        if hex_length not in [3, 6]:\n            raise ValueError(\n                'Colors must be of the form #FFFFFF or #FFF'\n            )\n        regex = '.' * (hex_length // 3)\n        colors[i] = [\n            int(val * (6 // hex_length), 16) / 255\n            for val in re.findall(regex, color)\n        ]\n    return colors[0] if len(colors) == 1 else colors\n```", "```py\nfrom matplotlib.colors import ListedColormap\nimport numpy as np\ndef blended_cmap(rgb_color_list):\n    \"\"\"\n    Create a colormap blending from one color to the other.\n    Parameters:\n        - rgb_color_list: List of colors represented as \n          [R, G, B] values in the range [0, 1], like \n          [[0, 0, 0], [1, 1, 1]], for black and white.\n    Returns: \n        A matplotlib `ListedColormap` object\n    \"\"\"\n    if not isinstance(rgb_color_list, list):\n        raise ValueError('Colors must be passed as a list.')\n    elif len(rgb_color_list) < 2:\n        raise ValueError('Must specify at least 2 colors.')\n    elif (\n        not isinstance(rgb_color_list[0], list)\n        or not isinstance(rgb_color_list[1], list)\n    ) or (\n        (len(rgb_color_list[0]) != 3 \n        or len(rgb_color_list[1]) != 3)\n    ):\n        raise ValueError(\n            'Each color should be a list of size 3.'\n        )\n    N, entries = 256, 4 # red, green, blue, alpha\n    rgbas = np.ones((N, entries))\n    segment_count = len(rgb_color_list) – 1\n    segment_size = N // segment_count\n    remainder = N % segment_count # need to add this back later\n    for i in range(entries - 1): # we don't alter alphas\n        updates = []\n        for seg in range(1, segment_count + 1):\n            # handle uneven splits due to remainder\n            offset = 0 if not remainder or seg > 1 \\\n                     else remainder\n            updates.append(np.linspace(\n                start=rgb_color_list[seg - 1][i], \n                stop=rgb_color_list[seg][i], \n                num=segment_size + offset\n            ))\n        rgbas[:,i] = np.concatenate(updates)\n    return ListedColormap(rgbas)\n```", "```py\nimport matplotlib.pyplot as plt\ndef draw_cmap(cmap, values=np.array([[0, 1]]), **kwargs):\n    \"\"\"\n    Draw a colorbar for visualizing a colormap.\n    Parameters:\n        - cmap: A matplotlib colormap\n        - values: Values to use for the colormap\n        - kwargs: Keyword arguments to pass to `plt.colorbar()`\n    Returns:\n        A matplotlib `Colorbar` object, which you can save \n        with: `plt.savefig(<file_name>, bbox_inches='tight')`\n    \"\"\"\n    img = plt.imshow(values, cmap=cmap)\n    cbar = plt.colorbar(**kwargs)\n    img.axes.remove()\n    return cbar\n```", "```py\n>>> my_colors = ['#800080', '#FFA500', '#FFFF00']\n>>> rgbs = color_utils.hex_to_rgb_color_list(my_colors)\n>>> my_cmap = color_utils.blended_cmap(rgbs)\n>>> color_utils.draw_cmap(my_cmap, orientation='horizontal')\n```", "```py\n>>> import itertools\n>>> colors = itertools.cycle(['#ffffff', '#f0f0f0', '#000000'])\n>>> colors\n<itertools.cycle at 0x1fe4f300>\n>>> next(colors)\n'#ffffff'\n```", "```py\nfrom my_plotting_module import master_color_list\ndef color_generator():\n    yield from master_color_list\n```", "```py\n>>> from matplotlib.colors import ListedColormap\n>>> red_black = ListedColormap(['red', 'black'], N=2000)\n>>> [red_black(i) for i in range(3)]\n[(1.0, 0.0, 0.0, 1.0), \n (0.0, 0.0, 0.0, 1.0), \n (1.0, 0.0, 0.0, 1.0)]\n```", "```py\ndef color_generator():\n    for year in range(1992, 200019): # integers [1992, 200019)\n        if year % 100 == 0 and year % 400 != 0: \n            # special case (divisible by 100 but not 400)\n            color = '#f0f0f0'\n        elif year % 4 == 0:\n            # leap year (divisible by 4)\n            color = '#000000'\n        else:\n            color = '#ffffff'\n        yield color\n```", "```py\n>>> year_colors = color_generator()\n>>> year_colors\n<generator object color_generator at 0x7bef148dfed0>\n>>> next(year_colors)\n'#000000'\n```", "```py\n>>> year_colors = (\n...     '#ffffff'\n...     if (not year % 100 and year % 400) or year % 4\n...     else '#000000' for year in range(1992, 200019)\n... )\n>>> year_colors\n<generator object <genexpr> at 0x7bef14415138>\n>>> next(year_colors)\n'#000000'\n```", "```py\n>>> weekly_volume_traded = fb.loc['2018-Q4']\\\n...     .groupby(pd.Grouper(freq='W')).volume.sum()\n>>> weekly_volume_traded.index = \\\n...     weekly_volume_traded.index.strftime('W %W')\n>>> ax = weekly_volume_traded.plot(\n...     kind='bar',\n...     hatch='*',\n...     color='lightgray',\n...     title='Volume traded per week in Q4 2018'\n... )\n>>> ax.set(\n...     xlabel='week number', \n...     ylabel='volume traded'\n... )\n```", "```py\n>>> import calendar\n>>> fb_q4 = fb.loc['2018-Q4']\n>>> for texture, month in zip(\n...     ['oo', '/\\\\/\\\\', '...'], [10, 11, 12]\n... ):\n...     plt.fill_between(\n...         fb_q4.index, fb_q4.high, fb_q4.low,\n...         hatch=texture, facecolor='white',\n...         where=fb_q4.index.month == month,\n...         label=f'{calendar.month_name[month]} differential'\n...     )\n>>> plt.plot(fb_q4.index, fb_q4.high, '--', label='daily high')\n>>> plt.plot(fb_q4.index, fb_q4.low, '--', label='daily low')\n>>> plt.xticks([\n...     '2018-10-01', '2018-11-01', '2018-12-01', '2019-01-01'\n... ])\n>>> plt.xlabel('date')\n>>> plt.ylabel('price ($)')\n>>> plt.title(\n...     'FB differential between high and low price Q4 2018'\n... )\n>>> plt.legend()\n```"]