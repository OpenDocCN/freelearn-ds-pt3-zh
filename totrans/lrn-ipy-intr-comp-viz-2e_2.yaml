- en: Chapter 2. Interactive Work with IPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will detail the various improvements that IPython brings
    to the standard Python console. In particular, we will perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the system shell from IPython for powerful interactions between the shell
    and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use dynamic introspection to explore Python objects or even a new Python package
    without even the need to look at the documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily debug and benchmark your code from IPython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use the IPython notebook to improve considerably the way you interact
    with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extended shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPython is not only an extended Python console, but it also provides several
    ways to interact with the operating system during a Python interactive session
    without quitting the console. The shell features of IPython are not meant to replace
    the Unix shell, and IPython offers far less features. Yet, it is still quite convenient
    to be able to navigate through the filesystem during a Python session and to occasionally
    call system commands from IPython. Moreover, IPython provides useful magic commands
    that considerably improve productivity and reduce repetitive typing during an
    interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through the filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will show how we can download and extract compressed files from the
    Internet, navigate in a filesystem hierarchy, and open text files from IPython.
    To do this, we will use an example with real data about the social networks of
    hundreds of anonymous people on Facebook (who volunteered to share their data
    anonymously to computer scientists for research purposes). This BSD-licensed data
    are provided freely by the SNAP project from Stanford University ([http://snap.stanford.edu/data/](http://snap.stanford.edu/dat)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the example code files for all Packt books that you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. In addition, all examples
    can be downloaded from the author''s website: [http://ipython.rossant.net](http://ipython.rossant.net).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to download the ZIP file containing the data from the author''s
    webpage. We use the native Python module `urllib2` to download the file, and the
    `zipfile` module to extract it. Let''s enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we downloaded the file `http://ipython.rossant.net/facebook.zip` in the
    memory, and we are going to save it on the hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create a new folder named `data` in the current directory, and we enter
    it. The dollar (`$`) sign allows us to use a Python variable within a system or
    magic command. Let''s enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `mkdir` is a particular IPython *alias* redirecting a magic command to
    a shell command. The list of aliases can be obtained with the magic `%alias` command.
    In this folder, we are going to save the file we have just downloaded (in line
    eight, we locally save the ZIP file in `facebook.zip` in the current directory
    `data`), and extract it in the current folder (as shown in line nine, with the
    `extractall` method of `zip` and a `ZipFile` object). Let''s enter the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explore what we have just downloaded using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each number identifies a Facebook user (called the `ego` user).
    The `.edges` file contains its *social graph*, that is, the graph where each node
    is a friend, and two friends of the `ego` user are connected if they are friends
    of each other. This graph is stored as an `edges` list, a text file where each
    line contains two connected nodes' identifiers separated by a space. The `.circles`
    file contains manually-created friends' lists, that is, the groups of friends
    that share common attributes from the `ego` user's viewpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we save the current `facebook` directory as a bookmark using the following
    command so we can easily enter into this directory later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, in any future session with the same IPython profile, we can type `cd fbdata`
    to enter into this directory, whichever directory we call this command from. The
    `-l` and `-d` options allow to respectively list all defined bookmarks, and delete
    a specified bookmark. Typing `%bookmark?` displays the list of all options. This
    magic command can be really helpful when navigating back and forth between several
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another convenient navigation-related function in IPython is *tab* completion.
    IPython can automatically complete the file or folder name we are typing if we
    press the *Tab* key. If several options are possible, IPython will show us the
    list of all possible options. It also works with filenames, for instance, in the
    `open` built-in function, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the system shell from IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also launch commands using the system shell directly from IPython, and
    retrieve the result as a list of strings in a Python variable. To do this, we
    need to prefix shell commands with `!`. For example, assuming that we are using
    a Unix system, we can type the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Unix command `ls -1 -S` lists all files in the current directory, sorted
    by decreasing size, and with one file per line. The pipe `| grep edges` filters
    only those files that contain `edges` (these are the files with social graphs
    of different networks). Then, the Python variable `files` contains the list of
    all filenames, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use Python variables in the system command, using either the `$`
    syntax for single variables, or `{}` for any Python expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `head -n5 {files[0]}` command displays the first five lines of the first
    file in the `files` list, that is, the first five lines of the largest `.edges`
    file in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we find ourselves using the same command over and over, we can create an
    **alias** to save some repetitive typing, using the magic `%alias` command. For
    instance, in the following example we create an alias called `largest` that is
    used to display on a single column `(-1`) all files with their sizes (`-hs`),
    filtered with a specified string (`grep`) and ordered by their decreasing size
    (`-S`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In line five, note the `%s` positional placeholder for the `largest` alias,
    which will be replaced by any argument given to the alias (as shown in line six).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, by default, this alias will not be saved for future use in the next
    interactive sessions (after closing IPython). We need to save it explicitly with
    the `%store` magic command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In addition, to recover the stored aliases and variables in a later session,
    we will need to type `%store -r`.
  prefs: []
  type: TYPE_NORMAL
- en: The extended Python console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now explore the Python-related capabilities of the **IPython** console.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython keeps track of all our input history across all sessions. Since this
    history can become quite large after months or years of working with IPython,
    there are convenient ways of navigating through it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we can press the up and down keys at any time in the IPython prompt to
    navigate linearly through our recent history. If we type something before pressing
    the up and downkeys, we only navigate through the input commands that match what
    we have typed so far. Pressing *Ctrl* + *R* opens a prompt that allows us to search
    for a line that contains whatever we type in this prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The `%history` magic command (and `%hist`, which is an alias) accepts multiple
    convenient options to display the part of the input history we are interested
    in. By default, `%history` displays all our input history in the current session.
    We can specify a specific line range with a simple syntax, for example, `hist
    4-6 8` for lines four to six and line eight. We can also choose to display our
    history from the previous sessions with the syntax `hist 243/4-8` for lines four
    to eight in session 243\. Finally, we can number the sessions relative to the
    current session using the syntax `%hist ~1/7`, which shows line seven of the previous
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful options for `%history` include `-o`, which displays the output
    in addition to the input; `-n`, which displays the line numbers; `-f`, which saves
    the history to a file; and `-p`, which displays the classic `>>>` prompt. For
    example, this can prove to be useful for automatically creating a `doctest` file
    from the history. Also, the `-g` option allows to filter the history with a specified
    string (like `grep`). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we display the history of the first two lines with the line
    number, the output, and the default Python prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a related command is `%store`, which is used to save the content of
    any Python variable for later use in any future interactive session. The `%store
    name` command saves the variable `name`, and `%store -d name` deletes it. To recover
    the stored variables, we need to use `%store -r`.
  prefs: []
  type: TYPE_NORMAL
- en: Import/export of Python code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following section, we will first see how to import code from a Python
    script in the interactive console, and then how to export code from the history
    into an external file.
  prefs: []
  type: TYPE_NORMAL
- en: Importing code in IPython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A first possibility to import code in IPython is to copy and paste code from
    a file to IPython. When using the **IPython** console, the `%paste` magic command
    can be used to import and execute the code contained in the clipboard. IPython
    automatically dedents the code and removes the `>` and `+` characters at the beginning
    of the lines, allowing to paste the `diff` and `doctest` files directly from e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `%run` magic command executes a Python script in the console,
    by default, in an empty namespace. It means that any variable defined in the interactive
    namespace is not available within the executed script. However, at the end of
    the execution, the control returns to IPython's prompt, and the variables defined
    in the script are then imported in the interactive namespace. This is very convenient
    for exploring the state of all variables at the end of the script's execution.
    This behavior can be changed with the `-i` option, which uses the interactive
    namespace for the execution. The variables defined in the interactive namespace
    before the script's execution are then available in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s write a script `/home/me/data/egos.py` that lists all ego
    identifiers in Facebook''s `data` folder. Since each filename is of the form `<egoid>.<extension>`,
    we list all the files, remove the extensions, and take the sorted list of all
    unique identifiers. The script should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here is an explanation of what the last line does. The `lambda` function takes
    a filename as an argument following the template `<egoid>.<extension>`, and returns
    the `egoid` ID as an integer. It uses the `split` method of any string, which
    splits a string with a given character and returns a list of substrings, which
    are separated by this character. Here, the first element of the list is the `<egoid>`
    part. The `map` built-in Python function applies this `lambda` function to all
    filenames. The `set` function converts this list to a `set` object, thereby removing
    all duplicates and keeping only a list of unique identifiers (since any identifier
    appears twice with two different extensions). Finally, the `sorted` function converts
    the `set` object to a list, and sorts it in an increasing order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the current directory in IPython is `/home/me/data`, following is
    the command to execute this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `egos.py` script, the folder name `facebook` is retrieved from the command-line
    arguments, like in a standard command-line Python script, with `sys.argv[1]`.
    After the script has been executed, the `ids` variable defined in the script is
    available in the interactive namespace, and contains the list of unique `ego`
    identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, following is what happens if we do not provide the folder name as an argument
    to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: An exception is raised in line four since `folder` is not defined. If we want
    the script to use the `folder` variable defined in the interactive namespace,
    we need to use the `-i` option.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Interactive workflow in exploratory research**'
  prefs: []
  type: TYPE_NORMAL
- en: A standard workflow in exploratory research or in data analysis is to implement
    algorithms in one or several Python modules and write a script that executes the
    full process. This script can then be executed with `%run` and allows further
    interactive exploration of the script variables. This iterative process involves
    switching between a text editor and the **IPython** console. A more modern and
    practical approach is to use the IPython notebook, as we will see in the section
    *Using the IPython notebook*.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting code to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the `%run` magic command allows to import code from a file to the interactive
    console, the `%edit` command does the opposite. By default, `%edit` opens the
    system''s text editor and executes the code when we close the editor. If we supply
    an argument to `%edit`, this command will try to open the text editor with the
    code we supplied. The argument can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A Python script filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string variable containing Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A range of line numbers, with the same syntax of `%history`, which was used
    previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any Python object, in which case IPython will try to open the editor with the
    file where this object has been defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more modern and powerful way of using a multiline text editor with IPython
    is to use the notebook, as we will see in the *Using the IPython notebook* section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic introspection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython offers several features for dynamically inspecting Python objects in
    the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At any time, we can type `TAB` in the console to let IPython either complete
    or propose a list of possible names or commands that match what we have typed
    so far. This allows, in particular, to dynamically inspect all attributes and
    methods of any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion also works for global variables in the interactive namespace,
    modules, and file paths in the current directory. By default, variables that begin
    with `_` (underscore) are not shown, because it is a Python convention to prefix
    private variables with an underscore. However, typing `_` before pressing *Tab*
    forces IPython to display all private variables.
  prefs: []
  type: TYPE_NORMAL
- en: An example of tab completion NetworkX
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, we will use tab completion to find out how we can load and manipulate
    a graph with the *NetworkX* package. This package is commonly used when working
    with graphs. Let''s execute the following command to import the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the available options for opening a graph, we can look for the possible
    methods prefixed with `read`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `.edges` files contain a list of edges, we try the following command
    (assuming we are in the `fbdata` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the graph `g` appears to be loaded, we can explore the methods offered
    by this new object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The 0 ego user then appears to have 333 friends, and there are 2519 connections
    between these friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the structure of this graph a bit more. How well connected are
    any two users in this graph? The theory of small-world graphs predicts that any
    two persons are about six links away in a social graph. Here, we can compute the
    *radius* and *diameter* of the graph, that is, the minimum and maximum path length
    between any two nodes. Tab completion shows that there is a `radius` method in
    the NetworkX package. So, we try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our graph appears to be disconnected since the radius and diameter are not
    well defined. To work around this problem, we can take a connected component of
    the graph, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second proposition looks like a good choice (hence, the importance of choosing
    good names when creating a package!), as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are five connected components; we take the largest one and compute its
    radius and diameter. Hence, any two friends are connected through less than 11
    levels, and there is one friend that is less than six links away from any other
    friend.
  prefs: []
  type: TYPE_NORMAL
- en: Tab completion with custom classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we define our own classes, we can customize the way their instances work
    with IPython tab completion. All we have to do is override the `__dir__` method
    to return the list of attributes as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This feature can be useful in some scenarios where the list of interesting attributes
    of an instance is defined dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Source code introspection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPython can also display information about the internals of a variable, in particular
    about the source code when it is defined in a file. First, typing `?` before or
    after a variable name prints useful information about it. Typing `??` gives more
    detailed information, in particular, the source code of the object, if it is a
    function defined in a file.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, several magic commands display specific information about a variable,
    such as the source code of the function (`%psource`) or of the file (`%pfile`)
    where it is defined, the docstring (`%pdoc`), or the definition header `(%pdef`).
  prefs: []
  type: TYPE_NORMAL
- en: The `%pfile` magic command also accepts a Python filename, in which case, it
    prints the file's contents with syntax highlighting. With this function, IPython
    can then act as a code viewer with syntax highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: Using the interactive debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most of us, debugging is an important part of the programming job. IPython
    makes it extremely convenient to debug a script or an entire application. It provides
    interactive access to an enhanced version of the Python debugger.
  prefs: []
  type: TYPE_NORMAL
- en: First, when we encounter an exception, we can use the `%debug` magic command
    to launch the IPython debugger at the exact point where the exception was raised.
    If we activate the `%pdb` magic command, the debugger will be automatically launched
    upon the very next exception. We can also start IPython with `ipython --pdb` for
    the same behavior. Finally, we can run a whole script under the control of the
    debugger with the `%run -d` command. This command executes the specified script
    with a break point at the first line so that we can precisely control the execution
    flow of the script. We can also specify explicitly where to put the first breakpoint;
    typing `%run -d -b29 script.py` pauses the program execution on line 29 of `script.py`.
    We first need to type `c` to start the script execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the debugger launches, the prompt becomes `ipdb>`. The program execution
    is then paused at a given point in the code. We can use the `w` command to display
    the line and the location in the stack traceback where the debugger has paused.
    At this point, we have access to all local variables and we can control precisely
    how we want to resume the execution. Within the debugger, several commands are
    available to navigate into the traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u`/`d` for going *up/down* into the call stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` to *step* into the next statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` to continue execution until the *next line* in the current function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r` to continue execution until the current function *returns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` to *continue* execution until the next breakpoint or exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other useful commands include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`p` to evaluate and *print* any expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` to obtain the *arguments* of the current functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `!` prefix to execute any Python command within the debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire list of commands can be found in the documentation of the `pdb` module
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive benchmarking and profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Donald Knuth said:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Premature optimization is the root of all evil."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that optimization should only occur in case of absolute necessity,
    and if the code has been thoroughly profiled so that you know exactly what portion
    of the code needs to be optimized. IPython makes this benchmarking and profiling
    process easy.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the execution time of a command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, the `%timeit` magic function uses the Python's `timeit` module to estimate
    the execution time of any Python statement. If we have defined a function `fun(x)`,
    `%timeit fun(x)` executes this command multiple times and returns an average of
    the execution time. The number of calls is determined automatically; there are
    `r` loops of `n` executions each. These numbers can be specified with the `-r`
    and `-n` options to `%timeit`. Also, we can easily estimate the execution time
    of a script with the `%run -t` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we compute the *center* of `sg`, that is, the set
    of nodes with eccentricity equal to the radius (that is, the friends in the `ego`
    circle who are the most well connected to all other friends), and estimate the
    time it takes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the previous example that it took 377 milliseconds for Python
    and NetworkX to compute the center of `sg`. The `center` function has been called
    three times (`best of 3` in the output `19`), and the smallest time of execution
    has been automatically selected (since the very first execution can take longer,
    due to some Python imports, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: Profiling a script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To obtain much more detailed information about the execution time of a program,
    we can execute it under the control of a *profiler*, like the one provided natively
    by the `profile` Python module. Profiling is a complex topic, and we are just
    going to show a basic usage example here. More details about the `profile` module
    can be found in the official Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To run a script under the control of the profiler, we can execute it from IPython
    with `%run -p` or with the equivalent `%prun` magic command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will write a small Python script that computes the center of the graph
    without using the built-in NetworkX `center` function. Let''s create a script
    called `center.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run it and estimate the time it takes using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This script took more than two minutes to execute; this looks particularly bad!
    We can run the profiler with the command `%run –p center.py` to find out what
    is taking so long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The profiler outputs details about calls of every Python function used directly
    or indirectly in this script. For example, the `cumtime` column prints the cumulative
    time spent within every function. It appears, from the previous example, that
    `eccentricity` and `radius` are the major bottlenecks, because they are called
    648 and 324 times, respectively! Looking more closely at the code shows that we
    are indeed doing something stupid; that is, we are calling these two functions
    repetitively within the loop. We can considerably improve the performance of this
    script by *caching* the output of these functions. Let''s modify the script in
    `center2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we compute the eccentricity of all nodes with a single call to `eccentricity`
    before the loop, and we compute the radius of the graph only once. Let''s check
    the performance of this improved script by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this modification, our computation takes less than a second instead of
    two minutes! Of course, even if this example was a particularly trivial one, this
    kind of mistake can be made by any programmer at some point in a long program.
    Then, it may not be so obvious to find this bottleneck just by reading the code.
    The best way to find such hotspots is to use a profiler, and IPython makes this
    task particularly easy.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using a line-by-line profiler**'
  prefs: []
  type: TYPE_NORMAL
- en: For even more fine-grained profiling, we can use a line-by-line profiler. This
    tool analyzes the time taken by every single line in a set of functions chosen
    by the programmer. In Python, the `line_profiler` package does exactly this. The
    functions to profile are indicated with a `@profile` decorator. Its usage is less
    straightforward than the IPython profiler, and we invite the interested reader
    to check out the package's website at [http://packages.python.org/line_profiler/](http://packages.python.org/line_profiler/).
    We will also mention it in [Chapter 6](ch06.html "Chapter 6. Customizing IPython"),
    *Customizing IPython*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the IPython notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IPython notebook is increasingly used in the Python community, in particular
    for scientific research and education. It brings both a powerful HTML user interface
    to IPython and a way of saving a whole interactive session in a notebook file
    in a JSON format. The latter functionality brings reproducibility to interactive
    computing, a crucial feature notably in scientific research. Notebooks run in
    the browser and can contain, not only Python code, but also text in a markup language,
    such as Markdown, as well as images, videos, or rich content media. Notebooks
    can be converted into other formats, such as Python scripts, HTML, or PDF. Courses,
    blog posts, and books are being written with the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**IPython Qt console**'
  prefs: []
  type: TYPE_NORMAL
- en: There is another rich IPython frontend similar to the notebook that is based
    on Qt instead of HTML. You can find more information about it at [http://ipython.org/ipython-doc/stable/interactive/qtconsole.html](http://ipython.org/ipython-doc/stable/interactive/qtconsole.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPython notebook server requires several dependencies. If you use either
    a full distribution, or if you have installed IPython from a binary package, you
    should have nothing more to do. If you have installed IPython manually, you will
    need PyZMQ and Tornado. PyZMQ is a Python wrapper to the ZMQ socket library, whereas
    Tornado is a Python library implementing the HTTP server that the notebook uses.
    You can install these packages either with `easy_install` , `pip`, or from the
    source.
  prefs: []
  type: TYPE_NORMAL
- en: The notebook dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check that everything is correctly installed, type `ipython notebook` in
    a shell. This will launch a local web server on the 8888 port (by default). Go
    to `http://127.0.0.1:8888/` in a browser and check if you can see the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The notebook dashboard](img/9932_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The notebook dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Browser compatibility with the notebook**'
  prefs: []
  type: TYPE_NORMAL
- en: The IPython notebook is compatible with browsers such as Chrome, Safari, Firefox
    6 and later versions, and Internet Explorer 10 and later versions. These browsers
    support the **WebSocket** protocol, which is used by the notebook.
  prefs: []
  type: TYPE_NORMAL
- en: The page in the previous screenshot is the **notebook dashboard** ; it lists
    all notebooks in the directory where we launched `ipython notebook` from. An IPython
    notebook file has a `.ipynb` extension; it is a text file containing structured
    data in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This file contains the inputs and outputs of an interaction session, as well
    as some metadata used by IPython internally.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Viewing notebooks online**'
  prefs: []
  type: TYPE_NORMAL
- en: IPython notebooks can be viewed and shared online on the IPython Notebook Viewer
    available at [http://nbviewer.ipython.org/](http://nbviewer.ipython.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start and create a new notebook. Click on the **New Notebook** button
    at the top-right of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Working with cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now in a notebook. The user interface is clean and focuses on the essential
    features. At the top, the menu and the toolbar offer access to all commands. The
    main area below them shows, by default, an empty input cell. Python code can be
    typed into this input cell. An important feature of an input cell is that pressing
    the *Enter* key does not execute the cell, but rather inserts a new line. Writing
    code into a cell is then closer to what a standard text editor offers, compared
    to the classic **IPython** console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start typing the command as shown in the following screenshot, and note how
    tab completion is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with cells](img/9932_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tab completion in the notebook
  prefs: []
  type: TYPE_NORMAL
- en: An input cell can be executed in two ways. By pressing *Shift* + *Enter*, all
    the code within the cell is executed in the current IPython interactive namespace.
    The output then appears in an output area right below the input cell, and a new
    input cell is created below. By pressing *Ctrl* + *Enter*, no new input cell is
    created and only the output is shown. Typically, we will use the latter command
    for quick in-place experiments when we just need to evaluate some Python expression
    and we do not want to save the cell's output in the notebook (although we can
    always delete cells later).
  prefs: []
  type: TYPE_NORMAL
- en: In the end, a notebook contains a linear succession of input and output cells,
    representing a coherent and reproducible interactive session. Typically, a single
    cell contains a set of instructions, which perform some high-level action that
    requires several consecutive commands.
  prefs: []
  type: TYPE_NORMAL
- en: The interface offers commands to edit, delete, split, and merge cells. These
    commands can be accessed through the menu, the toolbar, or keyboard shortcuts.
    We can display the list of all keyboard shortcuts by pressing *Ctrl* + *M*, then
    *H*. Most notebook commands are executed with a sequence of keystrokes that begin
    with *Ctrl* + *M*, followed by a single key press.
  prefs: []
  type: TYPE_NORMAL
- en: Cell magics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cell magics** are special magic commands that are applied to a whole cell
    instead of a single line. They are prefixed with `%%` instead of `%`, and can
    be used either in the **IPython** console, or in the IPython notebook. The list
    of all cell magics can be obtained with the command `%lsmagic`. Two useful cell
    magics include `%%!` for executing several system shell commands from IPython,
    and `%%file` for creating a text file, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Managing notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can save the notebook we are working on at any time by clicking on the **Save**
    button or by pressing *Ctrl* + *S* or *Ctrl* + *M*, then *S*. By default, the
    notebook filename is `Untitled0`, but we can rename it with the `Rename` command
    in the **File** menu.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new notebook from an existing Python script by dragging the
    Python file from the system explorer to the IPython dashboard. This will create
    a new notebook with the same name as our script, but with a `.ipynb` extension.
    A notebook can be downloaded as a Python script or as a `.ipynb` file.
  prefs: []
  type: TYPE_NORMAL
- en: Multimedia and rich text editing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very useful feature of the notebook is the possibility to insert rich text
    in cells using a popular marker text format called **Markdown** (described at
    [http://daringfireball.net/projects/markdown/syntax](http://daringfireball.net/projects/markdown/syntax)).
    Edition features such as bold, italic, headers, and bullet points can be inserted
    with a simple syntax. To do this, we need to convert a cell into a **Markdown**
    cell with the `Cell >` Markdown command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can type our text with the Markdown syntax. If we press *Shift* +
    *Enter*, the text will be automatically formatted, and it can be edited with a
    double-click. The following screenshot shows both the Markdown code and the corresponding
    formatted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multimedia and rich text editing](img/9932OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Markdown input and output in the notebook
  prefs: []
  type: TYPE_NORMAL
- en: Graph plotting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s illustrate the plotting capabilities of the notebook with our social
    network example. We are going to draw the graph `sg`. First, we need to launch
    the notebook with the command `ipython notebook --pylab inline`. This option will
    be covered in more detail in [Chapter 4](ch04.html "Chapter 4. Interactive Plotting
    and Graphical Interfaces"), *Figures and Graphical Interfaces*. It allows to insert
    figures within the notebook, thanks to the Matplotlib library. NetworkX offers
    several Matplotlib-based commands to plot graphs. In the following example, we
    use the `draw_networkx` function to draw the graph `sg`, along with several parameters
    to improve the readability of the graph (the full list of options can be found
    on the NetworkX documentation website):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph plotting](img/9932_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drawing a graph in the notebook
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a broad overview of the features that IPython offers to simplify
    and extend the way we interact with IPython in our day-to-day programming job.
    From the powerful Python history to the essential dynamic introspection features,
    deciding whether to use IPython or the standard Python console for interactive
    programming is a no-brainer. Also, the notebook offers a modern way of using IPython
    for a wide variety of uses, such as simply recording an interactive session and
    creating a programming course, a presentation, or even a book!
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, what IPython offers does not stop here. It really comes into its own when
    using it with external packages offering numerical computing and visualization
    features: NumPy, SciPy, Matplotlib, and others. These packages can absolutely
    be used without IPython. However, using IPython fully makes sense since it then
    allows *interactive* numerical computing and visualization with the Python programming
    language. Together, these tools are becoming the platform of choice for open-source
    scientific computing, even competing with the widespread commercial solutions
    of reference. In the next chapter, we will cover the numerical computing capabilities
    of the platform.'
  prefs: []
  type: TYPE_NORMAL
