- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Calculus and Differential Equations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微积分与微分方程
- en: In this chapter, we will discuss various topics related to calculus. Calculus
    is the branch of mathematics that concerns the processes of differentiation and
    integration. Geometrically, the derivative of a function represents the gradient
    of the curve of the function, and the integral of a function represents the area
    below the curve of the function. Of course, these characterizations only hold
    in certain circumstances, but they provide a reasonable foundation for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论与微积分相关的各种主题。微积分是数学的一个分支，涉及到微分和积分的过程。在几何上，函数的导数表示函数曲线的梯度，而函数的积分表示曲线下方的面积。当然，这些描述仅在某些情况下成立，但它们为本章提供了合理的基础。
- en: 'We’ll start by looking at calculus for a simple class of functions: polynomials.
    In the first recipe, we’ll create a class that represents a polynomial and define
    methods that differentiate and integrate the polynomial. Polynomials are convenient
    because the derivative or integral of a polynomial is again a polynomial. Then,
    we’ll use the `SymPy` package to perform symbolic differentiation and integration
    on more general functions. After that, we’ll look at methods for solving equations
    using the SciPy package. Then, we’ll turn our attention to numerical integration
    (quadrature) and solving differential equations. We’ll use the SciPy package to
    solve **ordinary differential equations** (**ODEs**) and systems of ODEs, and
    then use a finite difference scheme to solve a simple partial differential equation.
    Finally, we’ll use the **Fast Fourier transform** (**FFT**) to process a noisy
    signal and filter out the noise.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从研究一种简单类型的函数——多项式的微积分开始。在第一个实例中，我们将创建一个表示多项式的类，并定义求导和积分的方法。多项式之所以方便，是因为多项式的导数或积分仍然是一个多项式。接下来，我们将使用
    `SymPy` 包对更一般的函数进行符号微分和积分。然后，我们将使用 SciPy 包中的方法求解方程。接着，我们将把注意力转向数值积分（求积）和求解微分方程。我们将使用
    SciPy 包求解**常微分方程**（**ODEs**）及常微分方程系统，并利用有限差分法求解简单的偏微分方程。最后，我们将使用**快速傅里叶变换**（**FFT**）处理噪声信号并滤除噪声。
- en: The content of this chapter will help you solve problems that involve calculus,
    such as computing the solution to differential equations, which frequently arise
    when describing the physical world. We’ll also dip into calculus later in [*Chapter
    9*](B19085_09.xhtml#_idTextAnchor360) when we discuss optimization. Several optimization
    algorithms require some kind of knowledge of derivatives, including the backpropagation
    commonly used in **machine** **learning** (**ML**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容将帮助你解决涉及微积分的问题，例如求解微分方程的解，而微分方程在描述物理世界时经常出现。稍后在 [*第九章*](B19085_09.xhtml#_idTextAnchor360)中，我们将进一步讨论优化问题。多个优化算法需要一定的导数知识，包括广泛应用于**机器学习**（**ML**）中的反向传播。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: Working with polynomials and calculus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式与微积分运算
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SymPy 进行符号微分和积分
- en: Solving equations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解方程
- en: Integrating functions numerically using SciPy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SciPy 数值积分
- en: Solving simple differential equations numerically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值求解简单微分方程
- en: Solving systems of differential equations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求解微分方程系统
- en: Solving partial differential equations numerically
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值求解偏微分方程
- en: Using discrete Fourier transforms for signal processing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用离散傅里叶变换进行信号处理
- en: Automatic differentiation and calculus using JAX
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX 进行自动微分和微积分
- en: Solving differential equations using JAX
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JAX 求解微分方程
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to the scientific Python packages NumPy and SciPy, we also need
    the SymPy, JAX, and `diffrax` packages. These can be installed using your favorite
    package manager, such as `pip`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了科学计算 Python 包 NumPy 和 SciPy，我们还需要 SymPy、JAX 和 `diffrax` 包。你可以通过你喜欢的包管理器（如
    `pip`）进行安装：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are different options for the way you install JAX. Please see the official
    documentation for more details: [https://github.com/google/jax#installation](https://github.com/google/jax#installation).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 JAX 有多种方式，请参阅官方文档了解更多详细信息：[https://github.com/google/jax#installation](https://github.com/google/jax#installation)。
- en: The code for this chapter can be found in the `Chapter 03` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2003](https://github.com/PacktPublishing/Applying-Math-with-Python-2nd-Edition/tree/main/Chapter%2003).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Primer on calculus
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calculus is the study of functions and the way that they change. There are
    two major processes in calculus: **differentiation** and **integration**. Differentiation
    takes a function and produces a new function—called the **derivative**—that is
    the *best linear approximation* at each point. (You may see this described as
    the **gradient** of the function. Integration is often described as *anti-differentiation*—indeed,
    differentiating the integral of a function does give back the original function—but
    is also an abstract description of the area between the graph of the function
    and the ![](img/Formula_03_001.png) axis, taking into account where the curve
    is above or below the axis.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstractly, the derivative of a function ![](img/Formula_03_002.png) at a point
    ![](img/Formula_03_003.png) is defined as a limit (which we won’t describe here)
    of the quantity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_004.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'This is because this small number ![](img/Formula_03_005.png) becomes smaller
    and smaller. This is the *difference in* ![](img/Formula_03_006.png) divided by
    the *difference in* ![](img/Formula_03_007.png), which is why the derivative is
    sometimes written as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_008.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'There are numerous rules for differentiating common function forms: for example,
    in the first recipe, we will see that the derivative of ![](img/Formula_03_009.png)
    is ![](img/Formula_03_010.png). The derivative of the exponential function ![](img/Formula_03_011.png)
    is, again, ![](img/Formula_03_012.png); the derivative of ![](img/Formula_03_013.png)
    is ![](img/Formula_03_014.png); and the derivative of ![](img/Formula_03_0141.png)
    is ![](img/Formula_03_016.png). These basic building blocks can be combined using
    the *product rule* and *chain rule*, and by the fact that derivatives of sums
    are sums of derivatives, to differentiate more complex functions.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'In its indefinite form, integration is the opposite process of differentiation.
    In its definite form, the integral of a function ![](img/Formula_03_017.png) is
    the (signed) area that lies between the curve of ![](img/Formula_03_018.png) and
    the ![](img/Formula_03_019.png) axis—note that this is a simple number, not a
    function. The indefinite integral of ![](img/Formula_03_020.png) is usually written
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_021.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Here, the derivative of this function is ![](img/Formula_03_022.png). The definite
    integral of ![](img/Formula_03_023.png) between ![](img/Formula_03_024.png) and
    ![](img/Formula_03_025.png) is given by the following equation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_026.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/Formula_03_027.png) is the indefinite integral of ![](img/Formula_03_028.png).
    We can, of course, define the indefinite integral abstractly, using limits of
    sums approximating the area below the curve, and then define the indefinite integral
    in terms of this abstract quantity. (We won’t go into detail here.) The most important
    thing to remember with indefinite integrals is the **constant** **of integration**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_027.png) 是 ![](img/Formula_03_028.png) 的不定积分。我们当然可以通过使用近似曲线下方区域的和的极限来抽象地定义不定积分，然后用这个抽象量来定义不定积分。（我们在这里不详细探讨。）需要记住的最重要的事情是**积分常数**。
- en: 'There are several easily deduced indefinite integrals (*anti-derivatives*)
    that we can quickly deduce: the integral of ![](img/Formula_03_029.png) is ![](img/Formula_03_030.png)
    (this is what we would differentiate to get ![](img/Formula_03_031.png)); the
    integral of ![](img/Formula_03_032.png) is ![](img/Formula_03_033.png); the integral
    of ![](img/Formula_03_034.png) is ![](img/Formula_03_035.png); and the integral
    of ![](img/Formula_03_036.png) is ![](img/Formula_03_037.png). In all these examples,
    ![](img/Formula_03_038.png) is the constant of integration. We can combine these
    simple rules to integrate more interesting functions by using the techniques of
    integration by parts or integration by substitution (and a host of much more involved
    techniques that we won’t mention here).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个容易推导的定积分（*反导数*），我们可以快速推导出：![](img/Formula_03_029.png) 的积分是 ![](img/Formula_03_030.png)（这是我们求导得到
    ![](img/Formula_03_031.png) 的结果）；![](img/Formula_03_032.png) 的积分是 ![](img/Formula_03_033.png)；![](img/Formula_03_034.png)
    的积分是 ![](img/Formula_03_035.png)；![](img/Formula_03_036.png) 的积分是 ![](img/Formula_03_037.png)。在所有这些例子中，![](img/Formula_03_038.png)
    是积分常数。我们可以结合这些简单的规则，通过分部积分法或代换积分法（以及一些更复杂的技术，我们这里不作详细讨论）来对更有趣的函数进行积分。
- en: Working with polynomials and calculus
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作多项式和微积分
- en: 'Polynomials are among the simplest functions in mathematics and are defined
    as a sum:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式是数学中最简单的函数之一，它们被定义为一个和式：
- en: '![](img/Formula_03_039.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_039.jpg)'
- en: Here, ![](img/Formula_03_040.png) represents a placeholder to be substituted
    (an indeterminate), and ![](img/Formula_03_041.png) is a number. Since polynomials
    are simple, they provide an excellent means for a brief introduction to calculus.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_040.png) 代表一个要被替换的占位符（不确定量），而 ![](img/Formula_03_041.png)
    是一个数字。由于多项式非常简单，它们为微积分的简要介绍提供了极好的手段。
- en: In this recipe, we will define a simple class that represents a polynomial and
    write methods for this class to perform differentiation and integration.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，我们将定义一个表示多项式的简单类，并为该类编写微分和积分的方法。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: There are no additional packages required for this recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例不需要额外的包。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following steps describe how to create a class representing a polynomial,
    and implement differentiation and integration methods for this class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建一个表示多项式的类，并为该类实现微分和积分方法：
- en: 'Let’s start by defining a simple class to represent a polynomial:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从定义一个简单的类来表示多项式开始：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have defined a basic class for a polynomial, we can move on to
    implement the differentiation and integration operations for this `Polynomial`
    class to illustrate how these operations change polynomials. We start with differentiation.
    We generate new coefficients by multiplying each element in the current list of
    coefficients without the first element. We use this new list of coefficients to
    create a new `Polynomial` instance that is returned:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个表示多项式的基本类，我们可以继续实现该 `Polynomial` 类的微分和积分操作，以说明这些操作如何改变多项式。我们从微分开始。通过将当前系数列表中的每个元素与第一个元素之外的其他元素相乘，我们生成新的系数。然后，我们使用这个新的系数列表创建一个新的
    `Polynomial` 实例，并返回该实例：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To implement the integration method, we need to create a new list of coefficients
    containing the new constant (converted to a float for consistency) given by the
    argument. We then add to this list of coefficients the old coefficients divided
    by their new position in the list:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现积分方法，我们需要创建一个新的系数列表，其中包含由参数给出的新常数（为了保持一致性，转换为浮点数）。然后我们将旧系数除以它们在列表中的新位置，添加到这个系数列表中：
- en: '[PRE14]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, to make sure these methods work as expected, we should test these
    two methods with a simple case. We can check this using a very simple polynomial,
    such as ![](img/Formula_03_042.png):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保这些方法按预期工作，我们应该通过一个简单的例子来测试这两种方法。我们可以使用一个非常简单的多项式来进行检查，例如 ![](img/Formula_03_042.png)：
- en: '[PRE20]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The derivative here is given the coefficients ![](img/Formula_03_043.png) and
    ![](img/Formula_03_044.png), which corresponds to the polynomial ![](img/Formula_03_045.png),
    which is indeed the derivative of ![](img/Formula_03_046.png). Similarly, the
    coefficients of the integral correspond to the polynomial ![](img/Formula_03_047.png),
    which is also correct (with constant of integration ![](img/Formula_03_048.png)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的导数给出了系数 ![](img/Formula_03_043.png) 和 ![](img/Formula_03_044.png)，它对应的多项式是
    ![](img/Formula_03_045.png)，这实际上是 ![](img/Formula_03_046.png) 的导数。类似地，积分的系数对应的多项式是
    ![](img/Formula_03_047.png)，这也是正确的（包含积分常数 ![](img/Formula_03_048.png)）。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Polynomials offer an easy introduction to the basic operations of calculus,
    but it isn’t so easy to construct Python classes for other general classes of
    functions. That being said, polynomials are extremely useful because they are
    well understood and, perhaps more importantly, calculus for polynomials is very
    easy. For powers of a variable ![](img/Formula_03_049.png), the rule for differentiation
    is to multiply by the power and reduce the power by 1 so that ![](img/Formula_03_050.png)
    becomes ![](img/Formula_03_051.png), so our rule for differentiating a polynomial
    is to simply multiply each coefficient by its position and remove the first coefficient.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式为微积分的基本运算提供了一个简单的介绍，但要为其他一般函数类构建 Python 类并不是那么容易。也就是说，多项式非常有用，因为它们已经被很好地理解，并且更重要的是，多项式的微积分运算非常简单。对于一个变量的幂
    ![](img/Formula_03_049.png)，微分规则是将幂与该幂相乘并将幂减 1，结果是 ![](img/Formula_03_050.png)
    变为 ![](img/Formula_03_051.png)，所以我们对多项式的微分规则是将每个系数乘以它的位置，并去掉第一个系数。
- en: Integration is more complex since the integral of a function is not unique.
    We can add any constant to an integral and obtain a second integral. For powers
    of a variable ![](img/Formula_03_052.png), the rule for integration is to increase
    the power by 1 and divide by the new power so that ![](img/Formula_03_053.png)
    becomes ![](img/Formula_03_054.png). Therefore, to integrate a polynomial, we
    increase each power of ![](img/Formula_03_055.png) by 1 and divide the corresponding
    coefficient by the new power. Hence, our rule is to first insert the new constant
    of integration as the first element and divide each of the existing coefficients
    by its new position in the list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 积分更加复杂，因为一个函数的积分不是唯一的。我们可以在积分中加上任何常数，从而得到第二个积分。对于一个变量的幂 ![](img/Formula_03_052.png)，积分规则是将幂加
    1 并除以新的幂，结果是 ![](img/Formula_03_053.png) 变为 ![](img/Formula_03_054.png)。因此，要对多项式进行积分，我们将每个幂的
    ![](img/Formula_03_055.png) 加 1，并将相应的系数除以新的幂。因此，我们的规则是先插入新的积分常数作为第一个元素，然后将每个现有系数除以它在列表中的新位置。
- en: The `Polynomial` class that we defined in the recipe is rather simplistic but
    represents the core idea. A polynomial is uniquely determined by its coefficients,
    which we can store as a list of numerical values. Differentiation and integration
    are operations that we can perform on this list of coefficients. We include a
    simple `__repr__` method to help with the display of `Polynomial` objects, and
    a `__call__` method to facilitate evaluation at specific numerical values. This
    is mostly to demonstrate the way that a polynomial is evaluated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中定义的 `Polynomial` 类相当简化，但它代表了核心思想。一个多项式是由它的系数唯一决定的，我们可以将系数存储为数值列表。微分和积分是我们可以对这个系数列表执行的操作。我们包括了一个简单的
    `__repr__` 方法来帮助显示 `Polynomial` 对象，并且提供了一个 `__call__` 方法来便于在特定数值下进行计算。这个方法主要是为了展示多项式如何被计算。
- en: Polynomials are useful for solving certain problems that involve evaluating
    a computationally expensive function. For such problems, we can sometimes use
    some kind of polynomial interpolation, where we *fit* a polynomial to another
    function, and then use the properties of polynomials to help solve the original
    problem. Evaluating a polynomial is much *cheaper* than the original function,
    so this can lead to dramatic improvements in speed. This usually comes at the
    cost of some accuracy. For example, Simpson’s rule for approximating the area
    under a curve approximates the curve by quadratic polynomials over intervals defined
    by three consecutive mesh points. The area below each quadratic polynomial can
    be calculated easily by integration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式对于解决某些涉及评估计算开销大的函数的问题非常有用。对于这类问题，我们有时可以使用某种多项式插值，将一个多项式拟合到另一个函数上，然后利用多项式的性质来帮助解决原始问题。评估多项式比原始函数要*便宜*得多，因此这可以显著提高速度。这通常会以牺牲一些精度为代价。例如，辛普森法则通过在由三个连续网格点定义的区间上，用二次多项式来逼近曲线下的面积。每个二次多项式下的面积可以通过积分轻松计算。
- en: There’s more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Polynomials have many more important roles in computational programming than
    simply demonstrating the effect of differentiation and integration. For this reason,
    a much richer `Polynomial` class is provided in the `numpy.polynomial` NumPy package.
    The NumPy `Polynomial` class, and the various derived subclasses, are useful in
    all kinds of numerical problems and support arithmetic operations as well as other
    methods. In particular, there are methods for fitting polynomials to collections
    of data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式在计算编程中比单纯展示微分和积分的效果要扮演更多重要角色。因此，`numpy.polynomial` NumPy包中提供了一个更为丰富的`Polynomial`类。NumPy的`Polynomial`类及其衍生的各种子类在各种数值问题中都非常有用，支持算术运算以及其他方法。特别地，这些方法可以用于将多项式拟合到数据集合上。
- en: 'NumPy also provides classes, derived from `Polynomial`, that represent various
    special kinds of polynomials. For example, the `Legendre` class represents a specific
    system of polynomials called *Legendre polynomials*. Legendre polynomials are
    defined for ![](img/Formula_03_056.png) satisfying ![](img/Formula_03_057.png)
    and form an orthogonal system, which is important for applications such as numerical
    integration and the **finite element method** for solving partial differential
    equations. Legendre polynomials are defined using a recursive relation. We define
    them as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了从`Polynomial`类派生出的各种类，用于表示不同类型的特殊多项式。例如，`Legendre`类表示一种叫做*勒让德多项式*的特定多项式系统。勒让德多项式的定义为满足![](img/Formula_03_056.png)的![](img/Formula_03_057.png)，并形成一个正交系统，这在数值积分和用于求解偏微分方程的**有限元法**等应用中非常重要。勒让德多项式通过递归关系来定义。我们将其定义如下：
- en: '![](img/Formula_03_058.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_058.jpg)'
- en: 'Furthermore, for each ![](img/Formula_03_059.png), we define the ![](img/Formula_03_060.png)th
    Legendre polynomial to satisfy the recurrence relation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于每个![](img/Formula_03_059.png)，我们定义第![](img/Formula_03_060.png)个勒让德多项式，使其满足递推关系：
- en: '![](img/Formula_03_061.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_061.jpg)'
- en: There are several other so-called *orthogonal (systems of) polynomials*, including
    *Laguerre polynomials*, *Chebyshev polynomials*, and *Hermite polynomials*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种所谓的*正交（多项式）系统*，包括*拉盖尔多项式*、*切比雪夫多项式*和*厄尔米特多项式*。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: Calculus is certainly well documented in mathematical texts, and there are many
    textbooks that cover the basic methods all the way to the deep theory. Orthogonal
    systems of polynomials are also well documented among numerical analysis texts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分在数学文献中有详细的记录，许多教科书覆盖了从基本方法到深层理论的内容。正交多项式系统也在数值分析的文献中得到了详细的记录。
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号微分和积分
- en: At some point, you may have to differentiate a function that is not a simple
    polynomial, and you may need to do this in some kind of automated fashion—for
    example, if you are writing software for education. The Python scientific stack
    includes a package called SymPy, which allows us to create and manipulate symbolic
    mathematical expressions within Python. In particular, SymPy can perform differentiation
    and integration of symbolic functions, just like a mathematician.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到某个时候，你可能需要对一个非简单多项式的函数进行微分，并且你可能需要以某种自动化的方式来完成这项工作——例如，如果你正在编写教育类软件。Python的科学计算堆栈包含一个名为SymPy的包，它允许我们在Python中创建和操作符号数学表达式。特别是，SymPy能够像数学家一样进行符号函数的微分和积分。
- en: In this recipe, we will create a symbolic function and then differentiate and
    integrate this function using the SymPy library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个符号函数，然后使用 SymPy 库对该函数进行微分和积分。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Unlike some of the other scientific Python packages, there does not seem to
    be a standard alias under which SymPy is imported in the literature. Instead,
    the documentation uses a star import at several points, which is not in line with
    the *PEP8* style guide. This is possibly to make the mathematical expressions
    more natural. We will simply import the module under its name `sympy`, to avoid
    any confusion with the `scipy` package’s standard abbreviation, `sp` (which is
    the natural choice for `sympy` too):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他科学 Python 包不同，文献中似乎没有标准别名用于导入 SymPy。相反，文档在多个地方使用了星号导入，这与*PEP8* 风格指南不符。这可能是为了让数学表达式看起来更自然。我们将简单地使用其名称
    `sympy` 导入该模块，以避免与 `scipy` 包的标准缩写 `sp`（这也是 `sympy` 的自然选择）混淆：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this recipe, we will define a symbolic expression that represents the following
    function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将定义一个符号表达式，表示以下函数：
- en: '![](img/Formula_03_062.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_062.jpg)'
- en: Then, we will see how to symbolically differentiate and integrate this function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到如何对这个函数进行符号微分和积分。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Differentiating and integrating symbolically (as you would do by hand) is very
    easy using the SymPy package. Follow these steps to see how it is done:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SymPy 包进行符号微分和积分（就像你手动操作一样）非常简单。按照以下步骤操作，看看如何实现：
- en: 'Once SymPy is imported, we define the symbols that will appear in our expressions.
    This is a Python object that has no particular value, just like a mathematical
    variable, but can be used in formulas and expressions to represent many different
    values simultaneously. For this recipe, we need only define a symbol for ![](img/Formula_03_063.png),
    since we will only require constant (literal) symbols and functions in addition
    to this. We use the `symbols` routine from `sympy` to define a new symbol. To
    keep the notation simple, we will name this new symbol `x`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦导入 SymPy，我们就定义将在表达式中出现的符号。这是一个 Python 对象，没有特定值，就像数学变量一样，但可以在公式和表达式中同时表示多个不同的值。在这个食谱中，我们只需要定义一个符号用于
    ![](img/Formula_03_063.png)，因为除了这个符号外，我们只需要常量（字面量）符号和函数。我们使用 `sympy` 中的 `symbols`
    函数来定义一个新符号。为了简化符号表示，我们将这个新符号命名为 `x`：
- en: '[PRE26]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The symbols defined using the `symbols` function support all of the arithmetic
    operations, so we can construct the expression directly using the symbol `x` we
    just defined:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `symbols` 函数定义的符号支持所有算术运算，因此我们可以直接使用刚刚定义的符号 `x` 构建表达式：
- en: '[PRE27]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can use the symbolic calculus capabilities of SymPy to compute the
    derivative of `f`—that is, differentiate `f`. We do this using the `diff` routine
    in `sympy`, which differentiates a symbolic expression with respect to a specified
    symbol and returns an expression for the derivative. This is often not expressed
    in its simplest form, so we use the `sympy.simplify` routine to simplify the result:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以利用 SymPy 的符号计算能力来计算 `f` 的导数——也就是对 `f` 进行微分。我们使用 `sympy` 中的 `diff` 函数来对符号表达式进行微分，并返回导数的表达式。由于结果通常不是最简形式，我们使用
    `sympy.simplify` 函数来简化结果：
- en: '[PRE28]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can check whether the result of the symbolic differentiation using SymPy
    is correct, compared to the derivative computed by hand using the product rule,
    defined as a SymPy expression, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查使用 SymPy 进行符号微分的结果是否正确，并与手工使用乘积法则计算的导数进行比较，该导数作为 SymPy 表达式定义，如下所示：
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'SymPy equality tests whether two expressions are equal, but not whether they
    are symbolically equivalent. Therefore, we must first simplify the difference
    of the two statements we wish to test and test for equality to `0`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SymPy 的等式测试检查两个表达式是否相等，但不检查它们是否在符号上等价。因此，我们必须首先简化我们希望测试的两个语句的差异，并测试是否等于 `0`：
- en: '[PRE32]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can integrate the derivative `fp` using SymPy by using the `integrate` function
    and check that this is again equal to `f`. It is a good idea to also provide the
    symbol with which the integration is to be performed by providing it as the second
    optional argument:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 SymPy 的 `integrate` 函数对导数 `fp` 进行积分，并检查结果是否仍然等于 `f`。最好还通过提供第二个可选参数来指定进行积分的符号：
- en: '[PRE33]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, the result of integrating the derivative `fp` gives back the
    original function `f` (although we are technically missing the constant of integration
    ![](img/Formula_03_064.png)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，积分导数 `fp` 的结果将返回原始函数 `f`（尽管我们在技术上缺少了积分常数 ![](img/Formula_03_064.png)）。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SymPy defines various classes to represent certain kinds of expressions. For
    example, symbols, represented by the `Symbol` class, are examples of *atomic expressions*.
    Expressions are built up in a similar way to how Python builds an abstract syntax
    tree from source code. These expression objects can then be manipulated using
    methods and standard arithmetic operations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 定义了各种类来表示某些类型的表达式。例如，由 `Symbol` 类表示的符号是 *原子表达式* 的例子。表达式的构建方式与 Python 从源代码构建抽象语法树类似。这些表达式对象可以使用方法和标准算术操作进行操作。
- en: SymPy also defines standard mathematical functions that can operate on `Symbol`
    objects to create symbolic expressions. The most important feature is the ability
    to perform symbolic calculus—rather than the numerical calculus that we explore
    in the remainder of this chapter—and give exact (sometimes called *analytic*)
    solutions to calculus problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 还定义了标准数学函数，这些函数可以作用于 `Symbol` 对象，以创建符号表达式。最重要的功能是能够执行符号微积分——与我们在本章剩余部分探索的数值微积分不同——并给出微积分问题的精确（有时称为
    *解析*）解。
- en: The `diff` routine from the SymPy package performs differentiation on these
    symbolic expressions. The result of this routine is usually not in its simplest
    form, which is why we used the `simplify` routine to simplify the derivative in
    the recipe. The `integrate` routine symbolically integrates a `scipy` expression
    with respect to a given symbol. (The `diff` routine also accepts a symbol argument
    that specifies the symbol for differentiating against.) This returns an expression
    whose derivative is the original expression. This routine does not add a constant
    of integration, which is good practice when doing integrals by hand.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 包中的 `diff` 例程对这些符号表达式进行微分。该例程的结果通常不是其最简形式，这就是为什么我们在食谱中使用 `simplify` 例程来简化导数的原因。`integrate`
    例程对给定符号进行符号积分（与 `scipy` 表达式相关）。(`diff` 例程也接受一个符号参数，用来指定微分所依赖的符号。) 该例程返回一个其导数为原始表达式的表达式。该例程不会添加积分常数，这在手动积分时是一种良好的实践。
- en: There’s more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: SymPy can do much more than simple algebra and calculus. There are submodules
    for various areas of mathematics, such as number theory, geometry, and other discrete
    mathematics (such as combinatorics).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 能做的远不止简单的代数和微积分。它有许多子模块，涵盖数学的各个领域，例如数论、几何学和其他离散数学（如组合数学）。
- en: 'SymPy expressions (and functions) can be built into Python functions that can
    be applied to NumPy arrays. This is done using the `lambdify` routine from the
    `sympy.utilities` module. This converts a SymPy expression to a numerical expression
    that uses the NumPy equivalents of the SymPy standard functions to evaluate the
    expressions numerically. The result is similar to defining a Python Lambda, hence
    the name. For example, we could convert the function and derivative from this
    recipe into Python functions using this routine:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 表达式（和函数）可以构建成 Python 函数，这些函数可以应用于 NumPy 数组。这是通过 `sympy.utilities` 模块中的
    `lambdify` 例程完成的。该例程将 SymPy 表达式转换为数值表达式，使用 SymPy 标准函数的 NumPy 等效函数来数值求解表达式。结果类似于定义一个
    Python Lambda，因此得名。例如，我们可以使用该例程将这个食谱中的函数和导数转换为 Python 函数：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `lambdify` routine takes two arguments. The first is the variables to be
    provided, `x` in the previous code block, and the second is the expression to
    be evaluated when this function is called. For example, we can evaluate the lambdified
    SymPy expressions defined previously as if they were ordinary Python functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify` 例程接受两个参数。第一个是需要提供的变量，在前面的代码块中为 `x`，第二个是当调用此函数时要评估的表达式。例如，我们可以像普通
    Python 函数一样评估之前定义的 lambdified SymPy 表达式：'
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can even evaluate these lambdified expressions on NumPy arrays (as usual,
    with NumPy imported as `np`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在 NumPy 数组上评估这些 lambdified 表达式（和往常一样，先导入 NumPy，通常命名为 `np`）：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `lambdify` routine uses the Python `exec` routine to execute the code, so
    it should not be used with unsanitized input.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify` 例程使用 Python 的 `exec` 例程来执行代码，因此不应与未经清理的输入一起使用。'
- en: Solving equations
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解方程
- en: Many mathematical problems eventually reduce to solving an equation of the form
    ![](img/Formula_03_065.png), where ![](img/Formula_03_066.png) is a function of
    a single variable. Here, we try to find a value of ![](img/Formula_03_067.png)
    for which the equation holds. The values of ![](img/Formula_03_068.png) for which
    the equation holds are sometimes called *roots* of the equation. There are numerous
    algorithms for finding solutions to equations of this form. In this recipe, we
    will use the Newton-Raphson and secant methods to solve an equation of the form
    ![](img/Formula_03_069.png).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数学问题最终归结为求解形式为 ![](img/Formula_03_065.png) 的方程，其中 ![](img/Formula_03_066.png)
    是单变量的函数。在这里，我们试图找到一个 ![](img/Formula_03_067.png) 的值，使得方程成立。使方程成立的 ![](img/Formula_03_068.png)
    的值有时称为方程的 *根*。对于这种形式的方程，有许多算法可以找到其解。在这个食谱中，我们将使用牛顿-拉弗森方法和割线法来求解形式为 ![](img/Formula_03_069.png)
    的方程。
- en: The Newton-Raphson method (Newton’s method) and the secant method are good,
    standard root-finding algorithms that can be applied in almost any situation.
    These are *iterative methods* that start with an approximation of the root and
    iteratively improve this approximation until it lies within a given tolerance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森方法（牛顿法）和割线法是非常好的标准求根算法，可以在几乎任何情况下应用。这些是 *迭代方法*，从根的近似值开始，逐步改进这个近似值，直到它位于给定的容差范围内。
- en: 'To demonstrate these techniques, we will use the function from the *Differentiating
    and integrating symbolically using SymPy* recipe, defined by the following formula:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些技术，我们将使用来自 *使用SymPy进行符号微分和积分* 这一食谱中的函数，定义如下公式：
- en: '![](img/Formula_03_070.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_070.jpg)'
- en: This is defined for all real values of ![](img/Formula_03_071.png) and has exactly
    two roots, one at ![](img/Formula_03_072.png) and one at ![](img/Formula_03_073.png).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在所有实数值的 ![](img/Formula_03_071.png) 上都有定义，并且恰好有两个根，一个在 ![](img/Formula_03_072.png)
    处，另一个在 ![](img/Formula_03_073.png) 处。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The SciPy package contains routines for solving equations (among many other
    things). The root-finding routines can be found in the `optimize` module from
    the `scipy` package. As usual, we import NumPy as `np`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 包含用于求解方程的例程（以及许多其他功能）。求根的例程可以在 `scipy` 包中的 `optimize` 模块找到。像往常一样，我们将 NumPy
    导入为 `np`。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'The `optimize` package provides routines for numerical root finding. The following
    instructions describe how to use the `newton` routine from this module:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimize` 包提供了用于数值求解根的例程。以下说明描述了如何使用该模块中的 `newton` 例程：'
- en: 'The `optimize` module is not listed in the `scipy` namespace, so you must import
    it separately:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimize` 模块没有列在 `scipy` 命名空间中，因此必须单独导入：'
- en: '[PRE38]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we must define this function and its derivative in Python:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在 Python 中定义这个函数及其导数：
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The derivative of this function was computed in the previous recipe:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数的导数已在之前的食谱中计算过：
- en: '[PRE42]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For both the Newton-Raphson and secant methods, we use the `newton` routine
    from `optimize`. Both the secant method and the Newton-Raphson method require
    the function as the first argument and the first approximation, `x0`, as the second
    argument. To use the Newton-Raphson method, we must provide the derivative of
    ![](img/Formula_03_074.png), using the `fprime` keyword argument:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于牛顿-拉弗森方法和割线法，我们都使用 `optimize` 中的 `newton` 例程。无论是割线法还是牛顿-拉弗森方法，都需要将函数作为第一个参数，将第一个近似值
    `x0` 作为第二个参数。使用牛顿-拉弗森方法时，我们必须提供 ![](img/Formula_03_074.png) 的导数，并使用 `fprime` 关键字参数：
- en: '[PRE44]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To use the secant method, only the function is needed, but we must provide
    the first two approximations for the root; the second is provided as the `x1`
    keyword argument:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用割线法，只需要函数，但必须提供根的前两个近似值；第二个近似值通过 `x1` 关键字参数提供：
- en: '[PRE46]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Neither the Newton-Raphson nor the secant method is guaranteed to converge to
    a root. It is perfectly possible that the iterates of the method will simply cycle
    through a number of points (periodicity) or fluctuate wildly (chaos).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森方法和割线法都不能保证一定会收敛到一个根。方法的迭代过程有可能会在若干点之间循环（周期性）或剧烈波动（混沌）。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The Newton-Raphson method for a function ![](img/Formula_03_075.png) with derivative
    ![](img/Formula_03_076.png) and initial approximation ![](img/Formula_03_077.png)
    is defined iteratively using this formula:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数 ![](img/Formula_03_075.png)，其导数为 ![](img/Formula_03_076.png)，初始近似值为 ![](img/Formula_03_077.png)，牛顿-拉弗森方法通过以下公式进行迭代定义：
- en: '![](img/Formula_03_078.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_078.jpg)'
- en: For each integer, ![](img/Formula_03_079.png). Geometrically, this formula arises
    by considering the direction in which the gradient is negative (so, the function
    is decreasing) if ![](img/Formula_03_080.png) or positive (so, the function is
    increasing) if ![](img/Formula_03_081.png).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个整数，![](img/Formula_03_079.png)。从几何角度来看，这个公式通过考虑梯度为负（因此，函数在减小）时的方向（如果![](img/Formula_03_080.png)），或者梯度为正（因此，函数在增加）时的方向（如果![](img/Formula_03_081.png)）来得到。
- en: 'The secant method is based on the Newton-Raphson method, but replaces the first
    derivative with the following approximation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法基于牛顿-拉夫森方法，但将第一导数替换为以下近似值：
- en: '![](img/Formula_03_082.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_082.jpg)'
- en: 'When ![](img/Formula_03_083.png) is sufficiently small, which occurs if the
    method is converging, then this is a good approximation. The price paid for not
    requiring the derivative of the function ![](img/Formula_03_084.png) is that we
    require an additional initial guess to start the method. The formula for the method
    is given as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当![](img/Formula_03_083.png)足够小（这会在方法收敛时发生），那么这是一个很好的近似值。不需要函数![](img/Formula_03_084.png)的导数所付出的代价是我们需要额外的初始猜测来启动该方法。该方法的公式如下：
- en: '![](img/Formula_03_085.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_085.jpg)'
- en: Generally speaking, if either method is given an initial guess (guesses for
    the secant method) that is sufficiently close to a root, then the method will
    converge to that root. The Newton-Raphson method can also fail if the derivative
    is zero at one of the iterations, in which case the formula is not well defined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果给定任一方法一个足够接近根的初始猜测（割线法的猜测），则该方法将收敛到该根。牛顿-拉夫森方法也可能失败，如果在某次迭代中导数为零，此时公式将无法定义。
- en: There’s more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The methods mentioned in this recipe are general-purpose methods, but there
    are others that may be faster or more accurate in some circumstances. Broadly
    speaking, root-finding algorithms fall into two categories: algorithms that use
    information about the function’s gradient at each iterate (Newton-Raphson, secant,
    Halley) and algorithms that require bounds on the location of a root (bisection
    method, Regula-Falsi, Brent). The algorithms discussed so far are of the first
    kind, and while generally quite fast, they may fail to converge.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中提到的方法是通用方法，但在某些情况下，可能有其他方法更快或更准确。广义上讲，根求解算法可以分为两类：使用每次迭代时函数梯度信息的算法（如牛顿-拉夫森、割线法、哈雷法），以及需要知道根的区间范围的算法（如二分法、正则法、布伦特法）。到目前为止讨论的算法属于第一类，虽然通常非常快速，但它们可能会失败并无法收敛。
- en: 'The second kind of algorithm is those for which a root is known to exist within
    a specified interval ![](img/Formula_03_086.png). We can check whether a root
    lies within such an interval by checking that ![](img/Formula_03_087.png) and
    ![](img/Formula_03_088.png) have different signs—that is, one of ![](img/Formula_03_089.png)
    or ![](img/Formula_03_090.png) is true (provided, of course, that the function
    is *continuous*, which tends to be the case in practice). The most basic algorithm
    of this kind is the bisection algorithm, which repeatedly bisects the interval
    until a sufficiently good approximation to the root is found. The basic premise
    is to split the interval between ![](img/Formula_03_091.png) and ![](img/Formula_03_092.png)
    at the mid-point and select the interval in which the function changes sign. The
    algorithm repeats until the interval is very small. The following is a rudimentary
    implementation of this algorithm in Python:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类算法是那些已知根存在于指定区间![](img/Formula_03_086.png)内的算法。我们可以通过检查![](img/Formula_03_087.png)和![](img/Formula_03_088.png)的符号是否不同来判断根是否位于该区间内——也就是说，![](img/Formula_03_089.png)或![](img/Formula_03_090.png)中的一个条件成立（当然，前提是函数是*连续的*，这在实际中通常是成立的）。这类算法中最基础的就是二分法，它通过反复二分区间直到找到足够精确的根的近似值。基本原理是将区间![](img/Formula_03_091.png)和![](img/Formula_03_092.png)的中点分割，并选择函数符号变化的区间。该算法重复进行，直到区间非常小。以下是该算法的一个简单Python实现：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method is guaranteed to converge since, at each step, the distance ![](img/Formula_03_093.png)
    is halved. However, it is possible that the method will require more iterations
    than Newton-Raphson or the secant method. A version of the bisection method can
    also be found in `optimize`. This version is implemented in C and is considerably
    more efficient than the version presented here, but the bisection method is not
    the fastest method in most cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Brent’s method is an improvement on the bisection method and is available in
    the `optimize` module as `brentq`. It uses a combination of bisection and interpolation
    to quickly find the root of an equation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is important to note that the techniques that involve bracketing (bisection,
    regula-falsi, Brent) cannot be used to find the root functions of a complex variable,
    whereas those techniques that do not use bracketing (Newton, secant, Halley) can.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some equations are not quite of the form ![](img/Formula_03_094.png)
    but can still be solved using these techniques. This is done by rearranging the
    equation so that it is of the required form (renaming functions if necessary).
    This is usually not too difficult and simply requires moving any terms on the
    right-hand side over to the left-hand side. For example, if you wish to find the
    fixed points of a function—that is, when ![](img/Formula_03_095.png)—then we would
    apply the method to the related function given by ![](img/Formula_03_096.png).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Integrating functions numerically using SciPy
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integration can be interpreted as the area that lies between a curve and the
    ![](img/Formula_03_097.png) axis, signed according to whether this area is above
    or below the axis. Some integrals cannot be computed directly using symbolic means,
    and instead, have to be approximated numerically. One classic example of this
    is the Gaussian error function, which was mentioned in the *Understanding basic
    mathematical functions* section in [*Chapter 1*](B19085_01.xhtml#_idTextAnchor014),
    *An Introduction to Basic Packages, Functions, and Concepts*. This is defined
    by the following formula:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_098.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Furthermore, the integral that appears here cannot be evaluated symbolically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use numerical integration routines in the
    SciPy package to compute the integral of a function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `scipy.integrate` module, which contains several routines for computing
    numerical integrals. We also import the NumPy library as `np`. We import this
    module as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps describe how to numerically integrate a function using
    SciPy:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We evaluate the integral that appears in the definition of the error function
    at the value ![](img/Formula_03_099.png). For this, we need to define the integrand
    (the function that appears inside the integral) in Python:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are two main routines in `scipy.integrate` for performing numerical integration
    (quadrature) that can be used. The first is the `quad` function, which uses QUADPACK
    to perform the integration, and the second is `quadrature`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.integrate`中有两种主要的例程可以用于执行数值积分（求积），分别是`quad`函数和`quadrature`。第一个是使用QUADPACK执行积分的`quad`函数，第二个是`quadrature`。'
- en: 'The `quad` routine is a general-purpose integration tool. It expects three
    arguments, which are the function to be integrated (`erf_integrand`), the lower
    limit (`-1.0`), and the upper limit (`1.0`):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quad`例程是一个通用的积分工具。它需要三个参数：要积分的函数（`erf_integrand`），下限（`-1.0`）和上限（`1.0`）：'
- en: '[PRE53]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The first returned value is the value of the integral, and the second is an
    estimate of the error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个返回值是积分的值，第二个返回值是误差的估计。
- en: 'Repeating the computation with the `quadrature` routine, we get the following.
    The arguments are the same as for the `quad` routine:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`quadrature`例程重复计算，我们得到如下结果。其参数与`quad`例程相同：
- en: '[PRE55]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The output is the same format as the code, with the value of the integral and
    then an estimate of the error. Notice that the error is larger for the `quadrature`
    routine. This is a result of the method terminating once the estimated error falls
    below a given tolerance, which can be modified when the routine is called.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出格式与代码相同，首先是积分值，然后是误差估计。请注意，`quadrature`例程的误差较大。这是由于该方法在估算误差小于给定容忍度时终止，而该容忍度可以在调用例程时进行修改。
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Most numerical integration techniques follow the same basic procedure. First,
    we choose points ![](img/Formula_03_100.png) for ![](img/Formula_03_101.png) in
    the region of integration, and then use these values and the values ![](img/Formula_03_102.png)
    to approximate the integral. For example, with the trapezium rule, we approximate
    the integral with the following formula:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数值积分技术遵循相同的基本过程。首先，我们选择积分区域内的点![](img/Formula_03_100.png) 和![](img/Formula_03_101.png)，然后使用这些值和![](img/Formula_03_102.png)来近似积分。例如，使用梯形法则时，我们使用以下公式来近似积分：
- en: '![](img/Formula_03_103.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_103.jpg)'
- en: 'Here, ![](img/Formula_03_104.png) and ![](img/Formula_03_105.png) is the (common)
    difference between adjacent ![](img/Formula_03_106.png) values, including the
    endpoints ![](img/Formula_03_107.png) and ![](img/Formula_03_108.png). This can
    be implemented in Python as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_104.png) 和 ![](img/Formula_03_105.png) 是相邻的![](img/Formula_03_106.png)值之间的（常见）差异，包括端点![](img/Formula_03_107.png)和![](img/Formula_03_108.png)。这可以在Python中实现如下：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The algorithms used by `quad` and `quadrature` are far more sophisticated than
    this. Using this function to approximate the integral of `erf_integrand` using
    `trapezium` with 500 steps yields a result of 1.4936463036001209, which agrees
    with the approximations from the `quad` and `quadrature` routines to five decimal
    places.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`quad`和`quadrature`使用的算法比这要复杂得多。使用此函数通过`trapezium`法则和500步来近似积分`erf_integrand`，得到的结果为1.4936463036001209，与`quad`和`quadrature`例程的五位小数近似值一致。'
- en: The `quadrature` routine uses a fixed tolerance Gaussian quadrature, whereas
    the `quad` routine uses an adaptive algorithm implemented in the Fortran library
    QUADPACK routines. Timing both routines, we find that the `quad` routine is approximately
    five times faster than the `quadrature` routine for the problem described in the
    recipe. The `quad` routine executes in approximately 27 µs, averaging over 1 million
    executions, while the `quadrature` routine executes in approximately 134 µs. (Your
    results may differ depending on your system.) Generally speaking, you should use
    the quad method since it is both faster and more accurate unless you need the
    Gaussian quadrature implemented by `quadrature`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`quadrature`例程使用固定容忍度的高斯求积，而`quad`例程则使用在Fortran库QUADPACK中实现的自适应算法。对两个例程进行计时，我们发现`quad`例程比`quadrature`例程快大约五倍，尤其是在本食谱中描述的问题上。`quad`例程的执行时间约为27微秒，经过100万次执行的平均值，而`quadrature`例程的执行时间约为134微秒。（您的结果可能会因系统而异。）一般来说，除非您需要`quadrature`实现的高斯求积，否则应使用`quad`方法，因为它既更快又更准确。'
- en: There’s more...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: The routines mentioned in this section require the integrand function to be
    known, which is not always the case. Instead, it might be the case that we know
    a number of pairs ![](img/Formula_03_109.png) with ![](img/Formula_03_110.png),
    but we don’t know the function ![](img/Formula_03_111.png) to evaluate at additional
    points. In this case, we can use one of the sampling quadrature techniques from
    `scipy.integrate`. If the number of known points is very large and all points
    are equally spaced, we can use Romberg integration for a good approximation of
    the integral. For this, we use the `romb` routine. Otherwise, we can use a variant
    of the trapezium rule (as shown previously) using the `trapz` routine, or Simpson’s
    rule using the `simps` routine.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到的例程要求已知被积函数，这并不总是成立。相反，我们可能已知一些数对 ![](img/Formula_03_109.png) 和 ![](img/Formula_03_110.png)，但我们并不知道函数
    ![](img/Formula_03_111.png)，也无法在额外的点上进行评估。在这种情况下，我们可以使用 `scipy.integrate` 中的某种采样求积技术。如果已知点的数量非常大且所有点间距相等，我们可以使用
    Romberg 积分法进行良好的积分近似。为此，我们使用 `romb` 例程。否则，我们可以使用梯形规则的变体（如前所示），利用 `trapz` 例程，或者使用辛普森法则，通过
    `simps` 例程进行计算。
- en: Solving simple differential equations numerically
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值求解简单微分方程
- en: 'Differential equations arise in situations where a quantity evolves, usually
    over time, according to a given relationship. They are extremely common in engineering
    and physics, and appear quite naturally. One of the classic examples of a (very
    simple) differential equation is the law of cooling devised by Newton. The temperature
    of a body cools at a rate proportional to the current temperature. Mathematically,
    this means that we can write the derivative of the temperature ![](img/Formula_03_112.png)
    of the body at time ![](img/Formula_03_113.png) using the following differential
    equation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程出现在某些量随着时间或其他因素变化的情形中，通常根据给定的关系式进行演化。它们在工程学和物理学中极为常见，且自然地出现。微分方程的一个经典（非常简单）的例子是牛顿提出的冷却定律。一个物体的温度以与当前温度成正比的速率降低。从数学角度看，这意味着我们可以使用以下微分方程来表示在时间
    ![](img/Formula_03_113.png) 时刻物体的温度 ![](img/Formula_03_112.png) 的导数：
- en: '![](img/Formula_03_114.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_114.jpg)'
- en: 'Here, ![](img/Formula_03_115.png) is a positive constant that determines the
    rate of cooling. This differential equation can be solved *analytically* by first
    *separating the variables* and then integrating and rearranging them. After performing
    this procedure, we obtain the general solution:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_115.png) 是一个正的常数，用于确定冷却速率。这个微分方程可以通过先*分离变量*，然后进行积分和重排来*解析*求解。经过这一过程，我们可以得到一般解：
- en: '![](img/Formula_03_116.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_116.jpg)'
- en: Here, ![](img/Formula_03_117.png) is the initial temperature.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_03_117.png) 是初始温度。
- en: In this recipe, we will solve a simple ODE numerically using the `solve_ivp`
    routine from SciPy.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用 SciPy 的 `solve_ivp` 例程数值求解一个简单的常微分方程（ODE）。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will demonstrate the technique for solving a differential equation numerically
    in Python using the cooling equation described previously since we can compute
    the true solution in this case. We take the initial temperature to be ![](img/Formula_03_118.png)
    and ![](img/Formula_03_119.png). Let’s also find the solution for ![](img/Formula_03_120.png)
    values between ![](img/Formula_03_121.png) and ![](img/Formula_03_122.png).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何在 Python 中使用先前描述的冷却方程来数值求解一个微分方程，因为在这种情况下我们可以计算真实解。我们将初始温度设为 ![](img/Formula_03_118.png)
    和 ![](img/Formula_03_119.png)。同时，我们还要找到 ![](img/Formula_03_120.png) 在 ![](img/Formula_03_121.png)
    和 ![](img/Formula_03_122.png) 之间的解。
- en: 'For this recipe, we will need the NumPy library imported as `np`, the Matplotlib
    `pyplot` interface imported as `plt`, and the `integrate` module imported from
    SciPy:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要导入 NumPy 库，命名为 `np`，导入 Matplotlib 的 `pyplot` 接口，命名为 `plt`，以及从 SciPy
    导入 `integrate` 模块：
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'A general (first-order) differential equation has the following form:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的（一级）微分方程具有以下形式：
- en: '![](img/Formula_03_123.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_123.jpg)'
- en: 'Here, ![](img/Formula_03_124.png) is some function of ![](img/Formula_03_125.png)
    (the independent variable) and ![](img/Formula_03_126.png) (the dependent variable).
    In this formula, ![](img/Formula_03_127.png) is the dependent variable and ![](img/Formula_03_128.png).
    The routines for solving differential equations in the SciPy package require the
    function ![](img/Formula_03_129.png) and an initial value ![](img/Formula_03_130.png)and
    the range of ![](img/Formula_03_131.png) values where we need to compute the solution.
    To get started, we need to define our function ![](img/Formula_03_132.png) in
    Python and create a variables ![](img/Formula_03_133.png) and ![](img/Formula_03_134.png)
    range ready to be supplied to the SciPy routine:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we need to define the initial condition from which the solution should
    be found. For technical reasons, the initial ![](img/Formula_03_136.png) values
    must be specified as a one-dimensional NumPy array:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Since, in this case, we already know the true solution, we can also define
    this in Python ready to compare to the numerical solution that we will compute:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Let’s see how to solve this initial value problem using SciPy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to solve a differential equation numerically and plot the
    solution along with the error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `solve_ivp` routine from the `integrate` module in SciPy to solve
    the differential equation numerically. We add a parameter for the maximum step
    size, with a value of `0.1`, so that the solution is computed at a reasonable
    number of points:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we extract the solution values from the `sol` object returned from the
    `solve_ivp` method:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we plot the solution on a set of axes, as follows. Since we are also
    going to plot the approximation error on the same figure, we create two subplots
    using the `subplots` routine:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This plots the solution on a set of axes displayed on the left-hand side of
    *Figure 3**.1*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to compute the true solution at the points that we obtained
    from the `solve_ivp` routine, and then calculate the absolute value of the difference
    between the true and approximated solutions:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, on the right-hand side of *Figure 3**.1*, we plot the error in the
    approximation with a logarithmic scale on the ![](img/Formula_03_137.png) axis.
    We can then plot this on the right-hand side with a logarithmic scale ![](img/Formula_03_1371.png)
    axis using the `semilogy` plot command, as we saw in [*Chapter 2*](B19085_02.xhtml#_idTextAnchor036),
    *Mathematical Plotting* *with Matplotlib*:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The left-hand plot in *Figure 3**.1* shows decreasing temperature over time,
    while the right-hand plot shows that the error increases as we move away from
    the known value given by the initial condition:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Plot of the numerical solution to the cooling equation'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.1.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Plot of the numerical solution to the cooling equation
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the right-hand side plot is on a logarithmic scale and, while the
    rate of increase looks fairly dramatic, the values involved are very small (of
    order ![](img/Formula_03_138.png)).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most methods for solving differential equations are *time-stepping* methods.
    The pairs ![](img/Formula_03_139.png) are generated by taking small ![](img/Formula_03_140.png)
    steps and approximating the value of the function ![](img/Formula_03_141.png).
    This is perhaps best illustrated by Euler’s method, which is the most basic time-stepping
    method. Fixing a small step size ![](img/Formula_03_142.png), we form the approximation
    at the ![](img/Formula_03_143.png)th step using the following formula:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_144.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: We start from the known initial value ![](img/Formula_03_145.png). We can easily
    write a Python routine that performs Euler’s method as follows (there are, of
    course, many different ways to implement Euler’s method; this is a very simple
    example).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up the method by creating lists that will store the ![](img/Formula_03_146.png)
    values and ![](img/Formula_03_150.png) values that we will return:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Euler’s method continues until we hit the end of the ![](img/Formula_03_146.png)
    range. Here, we use a `while` loop to accomplish this. The body of the loop is
    very simple; we first increment a counter `i`, and then append the new ![](img/Formula_03_146.png)
    and ![](img/Formula_03_150.png) values to their respective lists:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The method used by the `solve_ivp` routine, by default, is the **Runge-Kutta-Fehlberg**
    (**RKF45**) method, which has the ability to adapt the step size to ensure that
    the error in the approximation stays within a given tolerance. This routine expects
    three positional arguments: the function ![](img/Formula_03_151.png), the ![](img/Formula_03_152.png)
    range on which the solution should be found, and the initial ![](img/Formula_03_153.png)
    value (![](img/Formula_03_154.png) in our example). Optional arguments can be
    provided to change the solver, the number of points to compute, and several other
    settings.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The function passed to the `solve_ivp` routine must have two arguments, as
    in the general differential equation described in the *Getting ready* section.
    The function can have additional arguments, which can be provided using the `args`
    keyword for the `solve_ivp` routine, but these must be positioned after the two
    necessary arguments. Comparing the `euler` routine we defined earlier to the `solve_ivp`
    routine, both with a (maximum) step size of 0.1, we find that the maximum true
    error between the `solve_ivp` solution is in the order of 10-11, whereas the `euler`
    solution only manages an error of 0.19\. The `euler` routine is working, but the
    step size is much too large to overcome the accumulating error. For comparison,
    *Figure 3**.2* is a plot of the solution and error as produced by Euler’s method.
    Compare *Figure 3**.2* to *Figure 3**.1*. Note the scale on the error plot is
    dramatically different:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Plot of solution and error using Euler’s method with step size
    0.1'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.2.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Plot of solution and error using Euler’s method with step size
    0.1
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The `solve_ivp` routine returns a solution object that stores information about
    the solution that has been computed. Most important here are the `t` and `y` attributes,
    which contain the ![](img/Formula_03_155.png) values on which the solution ![](img/Formula_03_156.png)
    is computed and the solution ![](img/Formula_03_157.png) itself. We used these
    values to plot the solution we computed. The ![](img/Formula_03_157.png) values
    are stored in a NumPy array of shape `(n, N)`, where `n` is the number of components
    of the equation (here, 1), and `N` is the number of points computed. The ![](img/Formula_03_157.png)
    values held in `sol` are stored in a two-dimensional array, which in this case
    has one row and many columns. We use the slice `y[0, :]` to extract this first
    row as a one-dimensional array that can be used to plot the solution in step 4.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We use a logarithmically scaled ![](img/Formula_03_157.png) axis to plot the
    error because what is interesting there is the order of magnitude. Plotting it
    on a non-scaled ![](img/Formula_03_157.png) axis would give a line that is very
    close to the ![](img/Formula_03_162.png) axis, which doesn’t show the increase
    in the error as we move through the ![](img/Formula_03_163.png) values. The logarithmically
    scaled ![](img/Formula_03_157.png) axis shows this increase clearly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `solve_ivp` routine is a convenient interface for a number of solvers for
    differential equations, the default being the RKF45 method. The different solvers
    have different strengths, but the RKF45 method is a good general-purpose solver.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more detailed instructions on how to add subplots to a figure in Matplotlib,
    see the *Adding subplots* recipe from [*Chapter 2*](B19085_02.xhtml#_idTextAnchor036),
    *Mathematical Plotting* *with Matplotlib*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Solving systems of differential equations
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Differential equations sometimes occur in systems consisting of two or more
    interlinked differential equations. A classic example is a simple model of the
    populations of competing species. This is a simple model of competing species
    labeled ![](img/Formula_03_165.png) (the prey) and ![](img/Formula_03_166.png)
    (the predators) given by the following equations:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_167.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: The first equation dictates the growth of the prey species ![](img/Formula_03_169.png),
    which, without any predators, would be exponential growth. The second equation
    dictates the growth of the predator species ![](img/Formula_03_170.png), which,
    without any prey, would be exponential decay. Of course, these two equations are
    *coupled*; each population change depends on both populations. The predators consume
    the prey at a rate proportional to the product of their two populations, and the
    predators grow at a rate proportional to the relative abundance of prey (again
    the product of the two populations).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will analyze a simple system of differential equations and
    use the SciPy `integrate` module to obtain approximate solutions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tools for solving a system of differential equations using Python are the
    same as those for solving a single equation. We again use the `solve_ivp` routine
    from the `integrate` module in SciPy. However, this will only give us a predicted
    evolution over time with given starting populations. For this reason, we will
    also employ some plotting tools from Matplotlib to better understand the evolution.
    As usual, the NumPy library is imported as `np` and the Matplotlib `pyplot` interface
    is imported as `plt`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps walk us through how to analyze a simple system of differential
    equations:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to define a function that holds the system of equations.
    This function needs to take two arguments as for a single equation, except the
    dependent variable ![](img/Formula_03_171.png) (in the notation from the *Solving
    simple differential equations numerically* recipe) will now be an array with as
    many elements as there are equations. Here, there will be two elements. The function
    we need for the example system in this recipe is defined as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we have defined the system in Python, we can use the `quiver` routine from
    Matplotlib to produce a plot that will describe how the populations will evolve—given
    by the equations—at numerous starting populations. We first set up a grid of points
    on which we will plot this evolution. It is a good idea to choose a relatively
    small number of points for the `quiver` routine; otherwise, it becomes difficult
    to see details in the plot. For this example, we plot the population values between
    0 and 100:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we compute the values of the system at each of these pairs. Notice that
    neither equation in the system is time-dependent (they are autonomous); the time
    variable ![](img/Formula_03_172.png) is unimportant in the calculation. We supply
    the value `0` for the ![](img/Formula_03_172.png) argument:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `dp` and `dw` variables now hold the *direction* in which the population
    of ![](img/Formula_03_174.png) and ![](img/Formula_03_175.png) will evolve, respectively,
    if we started at each point in our grid. We can plot these directions together
    using the `quiver` routine from `matplotlib.pyplot`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Plotting the result of these commands now gives us *Figure 3**.3*, which gives
    a *global* picture of how solutions evolve:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – A quiver plot showing the population dynamics of two competing
    species'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.3.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – A quiver plot showing the population dynamics of two competing
    species
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: To understand a solution more specifically, we need some initial conditions
    so that we can use the `solve_ivp` routine described in the previous recipe.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have two equations, our initial conditions will have two values. (Recall
    in the *Solving simple differential equations numerically* recipe, we saw that
    the initial condition provided to `solve_ivp` needs to be a NumPy array.) Let’s
    consider the initial values ![](img/Formula_03_176.png) and ![](img/Formula_03_177.png).
    We define these in a NumPy array, being careful to place them in the correct order:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we can use `solve_ivp` from the `scipy.integrate` module. We need to provide
    the `max_step` keyword argument to make sure that we have enough points in the
    solution to give a smooth solution curve:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Let’s plot this solution on our existing figure to show how this specific solution
    relates to the direction plot we have already produced. We also plot the initial
    condition at the same time:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The result of this is shown in *Figure 3**.4*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Solution trajectory plotted over a quiver plot showing the general
    behavior'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.4.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Solution trajectory plotted over a quiver plot showing the general
    behavior
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the trajectory plotted is a closed loop. This means that the
    populations have a stable and periodic relationship. This is a common pattern
    when solving these equations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method used for a system of ODEs is exactly the same as for a single ODE.
    We start by writing the system of equations as a single vector differential equation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_178.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: This can then be solved using a time-stepping method as though ![](img/Formula_03_179.png)
    were a simple scalar value.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The technique of plotting the directional arrows on a plane using the `quiver`
    routine is a quick and easy way of learning how a system might evolve from a given
    state. The derivative of a function represents the gradient of the curve ![](img/Formula_03_180.png),
    and so a differential equation describes the gradient of the solution function
    at position ![](img/Formula_03_179.png) and time ![](img/Formula_03_182.png).
    A system of equations describes the gradient of separate solution functions at
    a given position ![](img/Formula_03_179.png) and time ![](img/Formula_03_182.png).
    Of course, the position is now a two-dimensional point, so when we plot the gradient
    at a point, we represent this as an arrow that starts at the point, in the direction
    of the gradient. The length of the arrow represents the size of the gradient;
    the longer the arrow, the *faster* the solution curve will move in that direction.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'When we plot the solution trajectory on top of this direction field, we can
    see that the curve (starting at the point) follows the direction indicated by
    the arrows. The behavior shown by the solution trajectory is a *limit cycle*,
    where the solution for each variable is periodic as the two species’ populations
    grow or decline. This description of the behavior is perhaps clearer if we plot
    each population against time, as seen in *Figure 3**.5*. What is not immediately
    obvious from *Figure 3**.4* is that the solution trajectory loops around several
    times, but this is clearly shown in *Figure 3**.5*:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Plots of populations P and W against time'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.5.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Plots of populations P and W against time
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The periodic relationship described previously is clear in *Figure 3**.5*. Moreover,
    we can see the lag between the peak populations of the two species. Species ![](img/Formula_03_185.png)
    experiences peak population approximately 0.3 time periods after species ![](img/Formula_03_186.png).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique of analyzing a system of ODEs by plotting variables against one
    another, starting at various initial conditions, is called *phase space (plane)
    analysis*. In this recipe, we used the `quiver` plotting routine to quickly generate
    an approximation of the phase plane for a system of differential equations. By
    analyzing the phase plane of a system of differential equations, we can identify
    different local and global characteristics of the solution, such as limit cycles.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Solving partial differential equations numerically
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Partial differential equations are differential equations that involve *partial
    derivatives* of functions in two or more variables, as opposed to *ordinary derivatives*
    in only a single variable. Partial differential equations are a vast topic, and
    could easily fill a series of books. A typical example of a partial differential
    equation is the (one-dimensional) *heat equation*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_187.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![](img/Formula_03_188.png) is a positive constant and ![](img/Formula_03_189.png)
    is a function. The solution to this partial differential equation is a function
    ![](img/Formula_03_190.png), which represents the temperature of a rod, occupying
    the ![](img/Formula_03_191.png) range ![](img/Formula_03_192.png), at a given
    time ![](img/Formula_03_193.png). To keep things simple, we will take ![](img/Formula_03_194.png),
    which amounts to saying that no heating/cooling is applied to the system, ![](img/Formula_03_195.png),
    and ![](img/Formula_03_196.png). In practice, we can rescale the problem to fix
    the constant ![](img/Formula_03_197.png), so this is not a restrictive problem.
    In this example, we will use boundary conditions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_198.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: 'These are equivalent to saying that the ends of the rod are held at the constant
    temperature 0\. We will also use the initial temperature profile:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_199.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: This initial temperature profile describes a smooth curve between the values
    of 0 and 2 that peaks at a value of 3, which might be the result of heating the
    rod at the center to a temperature of 3.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use a method called *finite differences*, where we divide the
    rod into a number of equal segments and the time range into a number of discrete
    steps. We then compute approximations for the solution at each of the segments
    and each time step.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use finite differences to solve a simple partial differential
    equation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will need the NumPy and Matplotlib packages, imported as
    `np` and `plt`, as usual. We also need to import the `mplot3d` module from `mpl_toolkits`
    since we will be producing a 3D plot:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We will also need some modules from the SciPy package.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps, we work through solving the heat equation using finite
    differences:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create variables that represent the physical constraints of the
    system—the extent of the bar and the value of ![](img/Formula_03_200.png):'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We first divide the ![](img/Formula_03_201.png) range into ![](img/Formula_03_202.png)
    equal intervals—we take ![](img/Formula_03_203.png) for this example—using ![](img/Formula_03_204.png)
    points. We can use the `linspace` routine from NumPy to generate these points.
    We also need the common length of each interval ![](img/Formula_03_205.png):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we need to set up the steps in the time direction. We take a slightly
    different approach here; we set the time step size ![](img/Formula_03_206.png)
    and the number of steps (implicitly making the assumption that we start at time
    0):'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: In order for the method to behave properly, we must have the following formula:![](img/Formula_03_207.jpg)
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, the system can become unstable. We store the left-hand side of this
    in a variable for use in step 5, and use an assertion to check that this inequality
    holds:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we can construct a matrix that holds the coefficients from the finite
    difference scheme. To do this, we use the `diags` routine from the `scipy.sparse`
    module to create a sparse, tridiagonal matrix:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, we create a blank matrix that will hold the solution:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We need to add the initial profile to the first row. The best way to do this
    is to create a function that holds the initial profile and store the result of
    evaluating this function on the `x` array in the matrix `u` that we just created:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now, we can simply loop through each step, computing the next row of the matrix
    `u` by multiplying `A` and the previous row:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Finally, to visualize the solution we have just computed, we can plot the solution
    as a surface using Matplotlib:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The result of this is the surface plot shown in *Figure 3**.6*:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6  -Numerical solution of the heat equation over the range'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.6.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 -Numerical solution of the heat equation over the range ![](img/Formula_03_208.png)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Along the ![](img/Formula_03_209.png) axis, we can see that the overall shape
    is similar to the shape of the initial profile but becomes flatter as time progresses.
    Along the ![](img/Formula_03_210.png) axis, the surface exhibits the exponential
    decay that is characteristic of cooling systems.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The finite difference method works by replacing each of the derivatives with
    a simple fraction that involves only the value of the function, which we can estimate.
    To implement this method, we first break down the spatial range and time range
    into a number of discrete intervals, separated by mesh points. This process is
    called *discretization*. Then, we use the differential equation and the initial
    conditions and boundary conditions to form successive approximations, in a manner
    very similar to the time-stepping methods used by the `solve_ivp` routine in the
    *Solving simple differential equations* *numerically* recipe.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: In order to solve a partial differential equation such as the heat equation,
    we need at least three pieces of information. Usually, for the heat equation,
    this will come in the form of *boundary conditions* for the spatial dimension,
    which tell us what the behavior is at either end of the rod, and *initial conditions*
    for the time dimension, which is the initial temperature profile over the rod.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'The finite difference scheme described previously is usually referred to as
    the **forward time cen** (**FTCS**) scheme, since we use the *forward finite difference*
    to estimate the time derivative and the *central finite difference* to estimate
    the (second-order) spatial derivative. The formula for the first-order finite
    difference approximation is shown here:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_211.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the second-order approximation is given by the following formula:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_212.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: 'Substituting these approximations into the heat equation, and using the approximation
    ![](img/Formula_03_213.png) for the value of ![](img/Formula_03_214.png) after
    ![](img/Formula_03_215.png) time steps at the ![](img/Formula_03_216.png) spatial
    point, we get this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_217.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
- en: 'This can be rearranged to obtain the following formula:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_218.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: Roughly speaking, this equation says that the next temperature at a given point
    depends on the surrounding temperatures at the previous time. This also shows
    why the condition on the `r` value is necessary; if the condition does not hold,
    the middle term on the right-hand side will be negative.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this system of equations in matrix form:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_219.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/Formula_03_220.png) is a vector containing the approximation ![](img/Formula_03_221.png)
    and matrix ![](img/Formula_03_222.png), which was defined in step 4\. This matrix
    is tridiagonal, which means the nonzero entries appear on, or adjacent to, the
    leading diagonal. We use the `diag` routine from the SciPy `sparse` module, which
    is a utility for defining these kinds of matrices. This is very similar to the
    process described in the *Solving equations* recipe of this chapter. The first
    and last rows of this matrix have zeros, except in the top left and bottom right,
    respectively, that represent the (non-changing) boundary conditions. The other
    rows have coefficients that are given by the finite difference approximations
    for the derivatives on either side of the differential equation. We first create
    diagonal entries and entries above and below the diagonal, and then we use the
    `diags` routine to create a sparse matrix. The matrix should have ![](img/Formula_03_223.png)
    rows and columns, to match the number of mesh points, and we set the data type
    as double-precision floats and **compressed sparse row** (**CSR**) format.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The initial profile gives us the vector ![](img/Formula_03_224.png), and from
    this first point, we can compute each subsequent time step by simply performing
    a matrix multiplication, as we saw in step 7.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method we describe here is rather crude since the approximation can become
    unstable, as we mentioned, if the relative sizes of time steps and spatial steps
    are not carefully controlled. This method is *explicit* since each time step is
    computed explicitly using only information from the previous time step. There
    are also *implicit* methods, which give a system of equations that can be solved
    to obtain the next time step. Different schemes have different characteristics
    in terms of the stability of the solution.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'When the function ![](img/Formula_03_225.png) is not 0, we can easily accommodate
    this change by using the following assignment:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_226.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: 'Here, the function is suitably vectorized to make this formula valid. In terms
    of the code used to solve the problem, we need only include the definition of
    the function and then change the loop of the solution, as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Physically, this function represents an external heat source (or sink) at each
    point along the rod. This may change over time, which is why, in general, the
    function should have both ![](img/Formula_03_227.png) and ![](img/Formula_03_228.png)
    as arguments (though they need not both be used).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'The boundary conditions we gave in this example represent the ends of the rod
    being kept at a constant temperature of 0\. These kinds of boundary conditions
    are sometimes called *Dirichlet* boundary conditions. There are also *Neumann*
    boundary conditions, where the derivative of the function ![](img/Formula_03_229.png)
    is given at the boundary. For example, we might have been given the following
    boundary conditions:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_230.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'This could be interpreted physically as the ends of the rod being insulated
    so that heat cannot escape through the endpoints. For such boundary conditions,
    we need to modify the matrix ![](img/Formula_03_231.png) slightly, but otherwise,
    the method remains the same. Indeed, inserting an imaginary ![](img/Formula_03_232.png)
    value to the left of the boundary and using the backward finite difference at
    the left-hand boundary (![](img/Formula_03_233.png)), we obtain the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_234.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: 'Using this in the second-order finite difference approximation, we get this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_235.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'This means that the first row of our matrix should contain ![](img/Formula_03_236.png),
    then ![](img/Formula_03_237.png), followed by ![](img/Formula_03_238.png). Using
    a similar computation for the right-hand limit gives a similar final row of the
    matrix:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: For more complex problems involving partial differential equations, it is probably
    more appropriate to use a *finite elements* solver. Finite element methods use
    a more sophisticated approach for computing solutions than partial differential
    equations, which are generally more flexible than the finite difference method
    we saw in this recipe. However, this comes at the cost of requiring more setup
    that relies on more advanced mathematical theory. On the other hand, there is
    a Python package for solving partial differential equations using finite element
    methods such as **FEniCS** ([fenicsproject.org](https://fenicsproject.org)). The
    advantage of using packages such as FEniCS is that they are usually tuned for
    performance, which is important when solving complex problems with high accuracy.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FEniCS documentation gives a good introduction to the finite element method
    and a number of examples of using the package to solve various classic partial
    differential equations. A more comprehensive introduction to the method and the
    theory is given in the following book: *Johnson, C.* (*2009*). *Numerical solution
    of partial differential equations by the finite element method*. *Mineola, N.Y.:*
    *Dover Publications*.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: For more details on how to produce three-dimensional surface plots using Matplotlib,
    see the *Surface and contour plots* recipe from [*Chapter 2*](B19085_02.xhtml#_idTextAnchor036),
    *Mathematical Plotting* *with Matplotlib*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Using discrete Fourier transforms for signal processing
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most useful tools coming from calculus is the **Fourier transform**
    (**FT**). Roughly speaking, the FT changes the representation, in a reversible
    way, of certain functions. This change of representation is particularly useful
    in dealing with signals represented as a function of time. In this instance, the
    FT takes the signal and represents it as a function of frequency; we might describe
    this as transforming from signal space to frequency space. This can be used to
    identify the frequencies present in a signal for identification and other processing.
    In practice, we will usually have a discrete sample of a signal, so we have to
    use the **discrete Fourier transform** (**DFT**) to perform this kind of analysis.
    Fortunately, there is a computationally efficient algorithm, called the FFT, for
    applying the DFT to a sample.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: We will follow a common process for filtering a noisy signal using the FFT.
    The first step is to apply the FFT and use the data to compute the **power spectral
    density** (**PSD**) of the signal. Then, we identify peaks and filter out the
    frequencies that do not contribute a sufficiently large amount to the signal.
    Then, we apply the inverse FFT to obtain the filtered signal.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use the FFT to analyze a sample of a signal and identify
    the frequencies present and clean the noise from the signal.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will only need the NumPy and Matplotlib packages imported
    as `np` and `plt`, as usual. We will need an instance of the default random number
    generator, created as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Now, let’s see how to use the DFT.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these instructions to use the FFT to process a noisy signal:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a function that will generate our underlying signal:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Next, we create our sample signal by adding some Gaussian noise to the underlying
    signal. We also create an array that holds the true signal at the sample ![](img/Formula_03_239.png)
    values for convenience later:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We use the `fft` module from NumPy to compute DFTs. We import this from NumPy
    before we start our analysis:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To see what the noisy signal looks like, we can plot the sample signal points
    with the true signal superimposed:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The plot created here is shown in *Figure 3**.7*. As we can see, the noisy
    signal does not bear much resemblance to the true signal (shown with the dashed
    line):'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Noisy signal sample with true signal superimposed'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.7.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – Noisy signal sample with true signal superimposed
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use the DFT to extract the frequencies that are present in the
    sample signal. The `fft` routine in the `fft` module performs the DFT:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The `fft` module provides a routine for constructing the appropriate frequency
    values called `fftfreq`. For convenience, we also generate an array containing
    the integers at which the positive frequencies occur:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Next, compute the PSD of the signal, as follows:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now, we can plot the PSD of the signal for the positive frequencies and use
    this plot to identify frequencies:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The result can be seen in *Figure 3**.8*. We can see in this diagram that there
    are spikes at roughly **4** and **7**, which are the frequencies of the signal
    that we defined earlier:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – PSD of a signal generated using the FFT'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.8.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – PSD of a signal generated using the FFT
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'We can identify these two frequencies to try to reconstruct the true signal
    from the noisy sample. All of the minor peaks that appear are not larger than
    2,000, so we can use this as a cut-off value for the filter. Let’s now extract
    from the list of all positive frequency indices the (hopefully 2) indices that
    correspond to the peaks above 2,000 in the PSD:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Next, we create a new, clean spectrum that contains only the frequencies that
    we have extracted from the noisy signal. We do this by creating an array that
    contains only 0, and then copying the value of `spectrum` from those indices that
    correspond to the filtered frequencies and the negatives thereof:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Now, we use the inverse FFT (using the `ifft` routine) to transform this clean
    spectrum back to the time domain of the original sample. We take the real part
    using the `real` routine from NumPy to eliminate the erroneous imaginary parts:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Finally, we plot this filtered signal over the true signal and compare the
    results:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The result of step 11 is shown in *Figure 3**.9*. We can see that the filtered
    signal closely matches the true signal, except for some small discrepancies:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Filtered signal generated using FFTs superimposed over the true
    signal'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.9.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Filtered signal generated using FFTs superimposed over the true
    signal
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Figure 3**.9* that the filtered signal (dashed line) fits fairly
    closely over the true signal (lighter solid line). It captures most (but not all)
    of the oscillations of the true signal.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The FT of a function ![](img/Formula_03_240.png) is given by the following
    integral:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_241.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
- en: 'The DFT is given by the following integral:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_242.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
- en: Here, the ![](img/Formula_03_243.png) values are the sample values as complex
    numbers. The DFT can be computed using the preceding formula, but in practice,
    this is not efficient. Computing using this formula is ![](img/Formula_03_244.png).
    The FFT algorithm improves the complexity to ![](img/Formula_03_245.png), which
    is significantly better. The book *Numerical Recipes* (full bibliographic details
    given in the *Further reading* section) gives a very good description of the FFT
    algorithm and the DFT.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: We will apply the DFT to a sample generated from a known signal (with known
    frequency modes) so that we can see the connection between the results we obtain
    and the original signal. To keep this signal simple, we created a signal that
    has only two frequency components with values 4 and 7\. From this signal, we generated
    a sample that we analyzed. Because of the way the FFT works, it is best if the
    sample has a size that is a power of 2; if this isn’t the case, we can pad the
    sample with zero elements to make this the case. We add some Gaussian noise to
    the sample signal, which takes the form of a normally distributed random number.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: The array returned by the `fft` routine contains ![](img/Formula_03_246.png)
    elements, where ![](img/Formula_03_247.png) is the sample size. The element that
    index 0 corresponds to is the 0 frequency or DC shift. The next ![](img/Formula_03_248.png)elements
    are the values corresponding to the positive frequencies, and the final ![](img/Formula_03_249.png)
    elements are the values corresponding to the negative frequencies. The actual
    values of the frequencies are determined by the number of sampled points ![](img/Formula_03_250.png)
    and the sample spacing, which, in this example, is stored in `sample_d`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'The PSD at the frequency ![](img/Formula_03_251.png) is given by the following
    formula:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_252.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
- en: Here, ![](img/Formula_03_253.png) represents the FT of the signal at frequency
    ![](img/Formula_03_254.png). The PSD measures the contribution of each frequency
    to the overall signal, which is why we see peaks at approximately 4 and 7\. Since
    Python indexing allows us to use negative indices for elements starting from the
    end of the sequence, we can use the positive index array to get both the positive
    and negative frequency elements from `spectrum`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: In step 9, we identified the indices of the two frequencies that peak above
    2,000 on the plot. The frequencies that correspond to these indices are 3.984375
    and 6.97265625, which are not exactly equal to 4 and 7 but are very close. The
    reason for this discrepancy is the fact that we have sampled a continuous signal
    using a finite number of points. (Using more points will, of course, yield better
    approximations.)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: In step 11, we took the real part of the data returned from the inverse FFT.
    This is because, technically speaking, the FFT works with complex data. Since
    our data contained only real data, we expect that this new signal should also
    contain only real data. However, there will be some small errors made, meaning
    that the results are not totally real. We can remedy this by taking the real part
    of the inverse FFT. This is appropriate because we can see that the imaginary
    parts are very small.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: We can see in *Figure 3**.9* that the filtered signal very closely matches the
    true signal, but not exactly. This is because, as mentioned previously, we are
    approximating a continuous signal with a relatively small sample.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signal processing in a production setting would probably make use of a specialized
    package, such as the `signal` module from `scipy`, or some lower-level code or
    hardware to perform filtering or cleaning of a signal. This recipe should be taken
    as more of a demonstration of the use of FFT as a tool for working with data sampled
    from some kind of underlying periodic structure (the signal). FFTs are useful
    for solving partial differential equations, such as the heat equation seen in
    the *Solving partial differential equations* *numerically* recipe.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about random numbers and the normal distribution (Gaussian)
    can be found in [*Chapter 4*](B19085_04.xhtml#_idTextAnchor138), *Working with
    Randomness* *and Probability*.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Automatic differentiation and calculus using JAX
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAX is a linear algebra and automatic differentiation framework developed by
    Google for ML. It combines the capabilities of **Autograd** and its **Accelerated
    Linear Algebra** (**XLA**) optimizing compiler for linear algebra and ML. In particular,
    it allows us to easily construct complex functions, with automatic gradient computation,
    that can be run on **Graphics Processing Units** (**GPUs**) or **Tensor Processing
    Units** (**TPUs**). On top of all of this, it is relatively simple to use. In
    this recipe, we see how to make use of the JAX **just-in-time** (**JIT**) compiler,
    get the gradient of a function, and make use of different computation devices.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need the JAX package installed. We will make use of the
    Matplotlib package, with the `pyplot` interface imported as `plt` as usual. Since
    we’re going to plot a function of two variables, we also need to import the `mplot3d`
    module from the `mpl_toolkits` package.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to define a JIT-compiled function using JAX, compute
    the gradient of this function, and use a GPU or TPU to perform calculations:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the parts of the JAX library that we will use:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Now, we can define our function, with the `@jit` decorator applied to tell
    JAX to JIT compile this function where necessary:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Next, we define a grid and plot our function:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The resulting plot is shown in *Figure 3**.10*:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Plot of a function of two variables computed using JAX'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.10.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Plot of a function of two variables computed using JAX
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we use the `grad` function (and the `jit` decorator) to define two new
    functions that are the partial derivatives with respect to the first and second
    arguments:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'To quickly check that these functions are working, we print the values of these
    functions at ![](img/Formula_03_255.png):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'To finish off, let’s plot the partial derivative with respect to ![](img/Formula_03_256.png):'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The partial derivative plot is shown in *Figure 3**.11*:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Plot of the partial derivative of the function computed using
    autodiff in JAX'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.11.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Plot of the partial derivative of the function computed using
    autodiff in JAX
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: A quick check confirms that this is indeed a plot of the partial derivative
    with respect to ![](img/Formula_03_256.png) of the function ![](img/Formula_03_258.png).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JAX is an interesting mix of a JIT compiler, with an emphasis on fast linear
    algebra operations, combined with the power of Autograd, with support for acceleration
    devices (and several other features that we don’t use here). The JIT compilation
    works by tracing the linear algebra operations performed on the JAX version of
    the NumPy library and constructing an intermediate representation of the function
    in a form that can be understood by the XLA compiler. For any of this to work,
    you need to make sure that you only use the NumPy module from JAX (`jax.numpy`)
    rather than the *real* NumPy. JAX also provides a version of the SciPy package.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat of this approach is that the functions must be *pure*: they should
    not have side effects beyond the return value, and should not depend on any data
    not passed by arguments. It might still work if this is not the case, but you
    might get unexpected results—remember that the Python version of the function
    might only be executed once. Something else to consider is that, unlike NumPy
    arrays, JAX NumPy arrays cannot be updated in place using index notation and assignment.
    This, and several other current important caveats, are listed in the JAX documentation
    (refer to the following section, *See also…*).'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: The `jit` decorator instructs JAX to construct compiled versions of the function
    where appropriate. It might actually produce several compiled versions depending
    on the types of arguments provided (for example, a different compiled function
    for scalar values versus array values).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: The `grad` function takes a function and produces a new function that computes
    the derivative with respect to the input variable. If the function has more than
    one input variable, then this is the partial derivative with respect to the first
    argument. The second optional argument, `argnums`, is used to specify which derivatives
    to compute. In the recipe, we have a function of two variables and used the `grad(f,
    0)` and `grad(f, 1)` commands to get the functions representing the two partial
    derivatives of the `f` function.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Most of the functions from `jax.numpy` have the same interface as from `numpy`—we
    see a few of these functions in the recipe. The difference is that JAX versions
    produce arrays that are stored correctly for the accelerator device if one is
    used. We can use these arrays in contexts that expect NumPy arrays, such as plotting
    functions, without any issues.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: In step 5 of the recipe, we printed the value of the two partial derivatives.
    Notice that we used the values `1.` and `-1.`. It is important to note that using
    the integer equivalent `1` and `-1` would have failed because of the way JAX handles
    floating-point numbers. (Since most GPU devices do not handle double-precision
    floating-point numbers well, the default float type in JAX is `float32`.)
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: In step 6, we computed the derivative over the same region as the function.
    To do this, we had to flatten the ![](img/Formula_03_259.png) and ![](img/Formula_03_260.png)
    arrays and then use the `vmap` function to vectorize the `fx` derivative before
    reshaping the result. There is a complication in the way that `grad` works, which
    means that `fx` does not vectorize in the way we expect.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JAX is designed to scale well as needs change, so lots of the components are
    designed with concurrency in mind. For instance, the random numbers module provides
    a random number generator that is capable of splitting effectively so that computations
    can run concurrently without changing the outcome. This wouldn’t be possible,
    for example, with a Mersenne Twister random generator, which would potentially
    produce different answers depending on the number of threads used because it doesn’t
    *split* in a statistically sound way.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lots more information can be found in the JAX documentation:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[https://jax.readthedocs.io/en/latest/](https://jax.readthedocs.io/en/latest/)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Solving differential equations using JAX
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAX provides a set of tools for solving a wide array of problems. Solving differential
    equations—such as initial value problems described in the *Solving simple differential
    equations numerically* recipe—should be well within the capabilities of this library.
    The `diffrax` package provides various solvers for differential equations leveraging
    the power and convenience of JAX.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'In the earlier recipe, we solved a relatively simple first-order ODE. In this
    recipe, we’re going to solve a second-order ODE to illustrate the technique. A
    **second-order ODE** is a differential equation that involves both the first and
    second derivatives of a function. To keep things simple, we’re going to solve
    a *linear* second-order ODE of the following form:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_261.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
- en: 'Here, ![](img/Formula_03_262.png) is a function of ![](img/Formula_03_263.png)
    to be found. In particular, we’re going to solve the following equation:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_264.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
- en: The initial conditions are ![](img/Formula_03_265.png) and ![](img/Formula_03_266.png).
    (Note that this is a second-order differential equation, so we need two initial
    conditions.)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can start to solve this equation, we need to do some pen-and-paper
    work to reduce the second-order equation to a system of first-order differential
    equations that can be solved numerically. To do this, we make a substitution ![](img/Formula_03_267.png)
    and ![](img/Formula_03_268.png). When we do this, we get a system like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_03_269.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
- en: We also get the initial conditions ![](img/Formula_03_270.png) and ![](img/Formula_03_271.png).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will need the `diffrax` package installed, along with JAX.
    As usual, we import the Matplotlib `pyplot` interface under the alias `plt`. We
    import `jax.numpy` under the alias `jnp` and the `diffrax` package.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to use JAX and the `diffrax` library to solve
    a second-order linear differential equation:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to set up our function that represents the system of first-order
    ODEs we constructed in the *Getting* *ready* section:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Next, we set up the `diffrax` environment that we will use to solve the equation.
    We’ll use the solver recommended in the `diffrax` *quickstart guide* – see the
    *See also* section below for more details. The setup is as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Now, we use the `diffeqsolve` routine from `diffrax` to solve the differential
    equation on the range ![](img/Formula_03_272.png):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Now we have solved the equation, we need to extract the values for ![](img/Formula_03_273.png)
    from the `solution` object:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Finally, we plot the results on a new figure:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The resulting plot is shown in *Figure 3**.12*:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Numerical solution to a second-order linear ODE'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '](img/3.12.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Numerical solution to a second-order linear ODE
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: We can see that when ![](img/Formula_03_274.png) is close to ![](img/Formula_03_275.png),
    the solution is approximately linear, but later on, the solution becomes non-linear.
    (The ![](img/Formula_03_274.png) range might be too small to see the interesting
    behavior of this system.)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`diffrax` is built on top of JAX and provides various solvers for differential
    equations. In the recipe, we used the Dormand-Prince 5(4) `Dopri5` solver class,
    which is another example of a Runge-Kutta method for solving ODEs similar to the
    Runge-Kutta-Fehlberg method we saw in an earlier recipe.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, `diffrax` translates the ODE initial value problem into a
    `diffrax` able to solve other kinds of differential equations besides these simple
    ODEs shown here; one of the goals of the library is to provide tools for numerically
    solving **stochastic differential equations** (**SDEs**). Since it is based on
    JAX, it should be easy to integrate this into other JAX workflows. It also has
    support for backpropagation through various adjoint methods.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'More information about the `diffrax` library and the methods it contains can
    be found in the documentation:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.kidger.site/diffrax](https://docs.kidger.site/diffrax'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calculus is a very important part of every undergraduate mathematics course.
    There are a number of excellent textbooks on calculus, including the classic textbook
    by Spivak and the more comprehensive course by Adams and Essex:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '*Spivak, M.* (*2006*). *Calculus*. *3rd ed*. *Cambridge: Cambridge* *University
    Press*.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adams, R.* and *Essex, C.* (*2018*). *Calculus: A Complete Course*. *9th ed*.
    *Don Mills,* *Ont: Pearson*.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A good source for numerical differentiation and integration is the classic
    *Numerical Recipes* book, which gives a comprehensive description of how to solve
    many computational problems in C++, including a summary of the theory:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '*Press, W.*, *Teukolsky, S.*, *Vetterling, W*. and *Flannery, B.* (*2007*).
    *Numerical Recipes: The Art of Scientific Computing*. *3rd ed*. *Cambridge: Cambridge*
    *University Press*.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
