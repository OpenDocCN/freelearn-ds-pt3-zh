<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Container Types
                </header>
            
            <article>
                
<p>Container types are used to group objects together. The main difference between the different container types is the way individual elements are accessed and how operations are defined. In this chapter, we discuss container types such as lists, tuples, dictionaries, and sets and related concepts such as indexing techniques. <span>More specialized containers such as pandas DataFrames will be presented in <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Chapter 4</a>: <em>L</em><em>inear Algebra – Arrays</em>, <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Chapter 5</a>: <em>Advanced Array Concepts</em>, and <a href="6db12ffa-0569-4e1e-9059-2f7ada99c3e3.xhtml">Chapter 10</a>: <em>Series and DataFrames.</em></span></p>
<p>In particular, we will cover the following topics:</p>
<ul>
<li>Lists</li>
<li>Arrays</li>
<li>Tuples</li>
<li>Dictionaries</li>
<li>Sets</li>
</ul>
<h1 id="uuid-ce4d549f-8258-4b9d-89ae-abb914091b08">3.1 Lists</h1>
<p>In this section, we introduce lists <span>–</span> the most frequently used container datatype in Python. With lists, we can refer to several, even totally different, Python objects together.</p>
<p>A list is, as the name hints, a list of objects of any kind:</p>
<pre>L = ['a', 20.0, 5]
M = [3,['a', -3.0, 5]]</pre>
<p>The first list in this example contains a string, a float, and an integer object. The second list in this example, <span><span><kbd>M</kbd></span></span>, contains <span>another list </span>as its second item.</p>
<p>The individual objects are enumerated by assigning each element an index. The first element in the list gets index <img class="fm-editor-equation" src="assets/24755493-7391-4f8c-ae55-d7059940bc62.png" style="width:0.58em;height:1.00em;"/>. This <em>zero-based indexing</em> is<span> </span>frequently used in mathematical notation. Consider as an example for zero-based indexing the usual indexing of coefficients of a polynomial.</p>
<p>The index allows us to access the following objects from the two lists defined in the preceding example:</p>
<pre>L[1] # returns 20.0
L[0] # returns 'a'
M[1] # returns ['a',-3.0,5]
M[1][2] # returns 5</pre>
<p>The bracket notation here corresponds to the use of subscripts in mathematical formulas.<span> </span><kbd>L</kbd><span> </span>is a simple list, while<span> </span><kbd>M</kbd><span> </span>itself contains a list so that you need two indexes to access an element of the inner list.</p>
<p>A list containing subsequent integers can easily be generated by the command<span> </span><kbd>range</kbd>:</p>
<pre>L=list(range(4)) <br/># generates a list with four elements: [0, 1, 2 ,3]</pre>
<p>A more general use is to provide this command with start, stop, and step parameters:</p>
<pre>L=list(range(17,29,4))  <br/># generates [17, 21, 25]</pre>
<p>The command<span> </span><kbd>len</kbd><span> </span>returns the length of the list:</p>
<pre>len(L) # returns 3</pre>
<h2 id="uuid-49da1861-86f5-4fbb-8f73-70321c36ac6f">3.1.1 Slicing</h2>
<p>Like cutting a slice from a loaf of bread, lists can be cut into slices. Slicing a list between <kbd>i</kbd><span> </span>and<span> </span><kbd>j</kbd><span> </span>creates a new list containing the elements starting at<span> </span>index <kbd>i</kbd> and ending just before<span> </span><kbd>j</kbd>.</p>
<p>For slicing, a range of indexes has to be given.<span> </span><kbd>L[i:j]</kbd><span> </span>means create a list by taking all elements from<span> </span><kbd>L</kbd><span> </span>starting at<span> </span><kbd>L[i]</kbd><span> </span>until<span> </span><kbd>L[j-1]</kbd>. In other words, the new list is obtained by removing the first<span> </span><kbd>i</kbd><span> </span>elements from<span> </span><kbd>L</kbd><span> </span>and taking the next<span> </span><kbd>j-i</kbd><span> </span>elements <img class="fm-editor-equation" src="assets/8c30c1ca-2375-4303-ae1a-4ce9475c5eba.png" style="width:6.25em;height:1.17em;"/>. </p>
<p><span>Here, </span><kbd>L[i:]</kbd><span> </span><span>means remove the</span> <span><img class="fm-editor-equation" src="assets/21174276-5eae-46d9-a4fd-c9a015c1b95e.png" style="width:0.50em;height:1.25em;"/> </span><span>first elements and</span><span> </span><kbd>L[:i]</kbd><span> </span><span>means take only the first</span> <span><img class="fm-editor-equation" src="assets/097a8bc0-54d3-4cd5-a899-9b12859a5e0e.png" style="width:0.50em;height:1.25em;"/></span><span>elements:</span></p>
<pre>L = ['C', 'l', 'o', 'u', 'd', 's']
L[1:5] # remove one element and take four from there:
# returns ['l', 'o', 'u', 'd']</pre>
<p>You may omit the first or last bound of the slicing:</p>
<pre>L = ['C', 'l', 'o', 'u', 'd', 's']
L[1:] # ['l', 'o', 'u', 'd', 's']
L[:5] # ['C', 'l', 'o', 'u', 'd']
L[:] # the entire list</pre>
<p>Python allows the use of negative indexes for counting from the right. In particular, the element<span> </span><kbd>L[-1]</kbd><span> </span>is the last element in the list<span> </span><kbd>L</kbd>. S<span>imilarly,</span><span> </span><kbd>L[:-i]</kbd><span> </span><span>means remove the last</span><span> <em><strong>i</strong></em></span><span> </span><span>elements, and</span><span> </span><kbd>L[-i:]</kbd><span> </span><span>means take only the last</span><span> <strong><em>i</em></strong> </span><span>elements. This may be combined in</span><span> </span><kbd>L[i:-j]</kbd><span> to remove the first</span><span> <em><strong>i</strong></em></span><span> </span><span>and the last</span><span> <em><strong>j</strong></em> </span><span>elements.</span></p>
<p>Here is an example:</p>
<pre>L = ['C', 'l', 'o', 'u', 'd', 's']
L[-2:] # ['d', 's']
L[:-2] # ['C', 'l', 'o', 'u']￼</pre>
<p>Omitting one index in the range corresponds to half-open intervals in ℝ. The half-open interval (∞,<span> </span><em>a</em>) means take all numbers strictly lower than<span> </span><em>a</em>; this is similar to the syntax<span> </span><kbd>L[:j] </kbd><span>; see </span><em>Figure 3.1</em><span> for more examples:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a6c8df0-b30b-4234-bcfb-034a2469b627.png" style="width:13.58em;height:20.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 3.1: Some typical slicing situations</div>
<p class="mce-root">Notice that you never get index errors with <em>out-of-bound slices</em>. Possibly, you may obtain empty lists:</p>
<pre>L = list(range(4)) # [0, 1, 2, 3]
L[4] # IndexError: list index out of range
L[1:100] # same as L[1:]
L[-100:-1] # same as L[:-1]
L[-100:100] # same as L[:]
L[5:0] # empty list []
L[-2:2] # empty list []</pre>
<p>Be careful when using variables in indexing that may become negative, since it changes the slice completely. This might lead to unexpected results:</p>
<pre>a = [1,2,3]
for iteration in range(4): 
    print(sum(a[0:iteration-1]))</pre>
<p>The result is<span> </span><kbd>3</kbd>,<span> </span><kbd>0</kbd>,<span> </span><kbd>1</kbd>,<span> </span><kbd>3</kbd><span> </span>while you expect<span> </span><kbd>0</kbd>,<span> </span><kbd>0</kbd>,<span> </span><kbd>1</kbd>,<span> </span><kbd>3</kbd>.</p>
<p>Let's sum up the use of slices:</p>
<ul>
<li><kbd>L[i:]</kbd><span> </span>amounts to taking all elements except the<span> first </span><em>i</em><span> </span>ones.</li>
<li><kbd>L[:i]</kbd><span> </span>amounts to taking the first <em>i</em> elements.</li>
<li><kbd>L[-i:]</kbd><span> </span>amounts to taking the last<span> </span><em>i</em><span> </span>elements.</li>
<li><kbd>L[:-i]</kbd><span> </span>amounts to taking all elements except the <span>last</span><span> </span><em>i</em><span> </span>ones.</li>
</ul>
<h3 id="uuid-5f465eac-dc40-4e97-9ee9-344a4d57eea5">Strides</h3>
<p>When computing slices, you may also specify a stride, which is the length of the step from one index to the other. The default stride is <kbd>1</kbd>.</p>
<p>Here is an example:</p>
<pre>L = list(range(100))
L[:10:2] # [0, 2, 4, 6, 8]
L[::20] # [0, 20, 40, 60, 80]
L[10:20:3] # [10, 13, 16, 19]</pre>
<p>Note that the stride may also be negative:</p>
<pre>L[20:10:-3] # [20, 17, 14, 11]</pre>
<p>It is also possible to create a new list that is reversed, using a negative stride:</p>
<pre>L = [1, 2, 3]
R = L[::-1] # L is not modified
R # [3, 2, 1]</pre>
<p>Alternatively, you might want to use the method <kbd>reverse</kbd>, which is explained in <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml"/><a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.4</a>: <em>List methods.</em></p>
<h2 id="uuid-336528a5-cf19-49f9-b810-f6cedc022a69">3.1.2 Altering lists</h2>
<p>Typical operations on lists are the insertion and deletion of elements and list concatenation. With the slicing notation, list insertion and deletion become obvious; deletion is just replacing a part of a list with an empty list<span> </span><kbd>[]</kbd>:</p>
<pre>L = ['a', 1, 2, 3, 4]
L[2:3] = [] # ['a', 1, 3, 4]
L[3:] = [] # ['a', 1, 3]</pre>
<p>Insertion means replacing an empty slice with the list to be inserted:</p>
<pre>L[1:1] = [1000, 2000] # ['a', 1000, 2000, 1, 3]</pre>
<p>Two lists are concatenated by the plus operator<span> </span><kbd>+</kbd><span> </span>:</p>
<pre>L = [1, -17]
M = [-23.5, 18.3, 5.0]
L + M # gives [1, -17, 23.5, 18.3, 5.0]</pre>
<p>Concatenating a list<span> </span><kbd>n</kbd><span> </span>times with itself motivates the use of the multiplication operator <kbd>*</kbd>:</p>
<pre>n = 3
n * [1.,17,3] # gives [1., 17, 3, 1., 17, 3, 1., 17, 3]
[0] * 5 # gives [0,0,0,0,0]</pre>
<p>There are no arithmetic operations on a list, such as elementwise summation or division. For such operations, we use arrays; see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.2</a>: A quick glance at the concept of arrays.</p>
<h2 id="uuid-20fcef3d-9847-4597-a79f-2e2123b4c1f5">3.1.3 Belonging to a list</h2>
<p>You may use the keywords <kbd>in</kbd><span> </span>and<span> </span><kbd>not in</kbd><span> </span>to determine whether an element belongs to a list or not, which is similar to <span><img class="fm-editor-equation" src="assets/240418bd-550d-4d6d-a5f3-501370f5490d.png" style="width:1.00em;height:1.08em;"/> </span><span>and</span><span> </span><span><img class="fm-editor-equation" src="assets/c905a7b8-fd14-4009-9804-7be9fe23cad1.png" style="width:0.83em;height:1.50em;"/> i</span><span>n mathematics:</span></p>
<pre>L = ['a', 1, 'b', 2]
'a' in L # True
3 in L # False
4 not in L # True</pre>
<h2 id="uuid-72f27283-6df9-48a0-91ab-38e605c9428b">3.1.4 List methods</h2>
<p>Some useful methods of the<span> </span><kbd>list</kbd><span> </span>type are collected in the following <em>Table 3.1</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Command</strong></td>
<td><strong>Action</strong></td>
</tr>
<tr>
<td><kbd>list.append(x)</kbd></td>
<td>Add<span> </span><kbd>x</kbd><span> </span>to the<span> </span>end of the list.</td>
</tr>
<tr>
<td><kbd>list.extend(L)</kbd></td>
<td>Extend the list by the elements of the list<span> </span><kbd>L</kbd>.</td>
</tr>
<tr>
<td><kbd>list.insert(i,x)</kbd></td>
<td>Insert<span> </span><kbd>x</kbd><span> </span>at<span> </span>position<span> </span><kbd>i</kbd>.</td>
</tr>
<tr>
<td><kbd>list.remove(x)</kbd></td>
<td>Remove the first item from the list whose value is<span> </span><kbd>x</kbd>.</td>
</tr>
<tr>
<td><kbd>list.sort()</kbd></td>
<td>Sort the items of the list.</td>
</tr>
<tr>
<td><kbd>list.reverse()</kbd></td>
<td>Reverse the elements of the list.</td>
</tr>
<tr>
<td><kbd>list.pop()</kbd></td>
<td>Remove the last element of the list.</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 3.1: In-place methods of the datatype list</div>
<p>These methods are in-place operations, that is, they change the list directly.</p>
<p>Other methods, such as those given in <em>Table 3.2</em>, do not alter the list, but return some information or create a new list object:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Command</strong></td>
<td><strong>Action</strong></td>
</tr>
<tr>
<td><kbd>list.count(x)</kbd></td>
<td>Count how often <kbd>x</kbd><span> </span>appears in the list.</td>
</tr>
<tr>
<td><kbd>list.copy()</kbd></td>
<td>Create a copy of the list.</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 3.2: Methods of the datatype list that return a new object</div>
<h3 id="uuid-adf7f628-623b-43ab-8de5-89f86b634545">In-place operations</h3>
<p>Most methods that result in a list are in-place operations. These are operations that change a Python object directly without creating a new object of the same type. They can be best explained by looking at the following example,<span> </span><kbd>reverse</kbd>:</p>
<pre>L = [1, 2, 3]
L.reverse() # the list L is now reversed
L # [3, 2, 1]</pre>
<p>Be aware of in-place operations. You might be tempted to write:</p>
<pre>L=[3, 4, 4, 5]
newL = L.sort()</pre>
<p>This is correct Python. But in-place operations return the value<span> </span><kbd>None</kbd> and alter the list. Therefore, using the variable <kbd>newL</kbd> as if it was a (sorted) list, for example, as </p>
<pre><span>print(newL[0])</span></pre>
<p>causes an error:</p>
<pre>TypeError: 'NoneType' object is not subscriptable</pre>
<p>Here, we demonstrate in-place list operations:</p>
<pre>L = [0, 1, 2, 3, 4]
L.append(5) # [0, 1, 2, 3, 4, 5]
L.reverse() # [5, 4, 3, 2, 1, 0]
L.sort() # [0, 1, 2, 3, 4, 5]
L.remove(0) # [1, 2, 3, 4, 5]
L.pop() # [1, 2, 3, 4]
L.pop() # [1, 2, 3]
L.extend(['a','b','c']) # [1, 2, 3, 'a', 'b', 'c']</pre>
<p><kbd>L</kbd><span> </span>is altered. The<span> </span><span>method</span><span> </span><kbd>count</kbd><span> </span><span>is an example of a method that generates a new object:</span></p>
<pre>L.count(2) # returns 1</pre>
<h2 id="uuid-1a5c011d-62d7-4db8-a5ea-5b594658c96d">3.1.5 Merging lists <span>–</span> zip</h2>
<p>A particularly useful function for lists is <kbd>zip</kbd>. It can be used to merge two given lists into a new list by pairing the elements of the original lists. The result is a list of tuples (see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section<span> 3.3</span></a><span>: </span><em>Tuples</em>):</p>
<pre>ind = [0,1,2,3,4]
color = ["red", "green", "blue", "alpha"]
list(zip(color,ind)) <br/># gives [('red', 0), ('green', 1), ('blue', 2), ('alpha', 3)]</pre>
<p>This example also demonstrates what happens if the lists have different lengths: the length of the zipped list is the shorter of the two input lists.</p>
<p><span>The function </span><kbd>zip</kbd><span> </span>creates a special iterable object that can be turned into a list by applying the function<span> </span><kbd>list</kbd>, as in the preceding example. See <a href="66c25bba-72d2-46a9-929a-1f57fa7a1684.xhtml">Section 9.3</a>: <em>Iterable objects </em>for more details on iterable objects.</p>
<h2 id="uuid-fded9983-e285-4e1d-a0f4-4f37df2d2243">3.1.6 List comprehension</h2>
<p>A convenient way to build up lists is by using the list comprehension construct, possibly with a condition inside. The syntax of a list comprehension is:</p>
<pre>[&lt;expr&gt; for &lt;variable&gt; in &lt;list&gt;]</pre>
<p>or more generally:</p>
<pre>[&lt;expr&gt; for &lt;variable&gt; in &lt;list&gt; if &lt;condition&gt;]</pre>
<p>Here are some examples:</p>
<pre>L = [2, 3, 10, 1, 5]
L2 = [x*2 for x in L] # [4, 6, 20, 2, 10]
L3 = [x*2 for x in L if 4 &lt; x &lt;= 10] # [20, 10]</pre>
<p>It is possible to have several<span> </span><kbd>for</kbd><span> </span>loops inside a list comprehension:</p>
<pre>M = [[1,2,3],[4,5,6]]
flat = [M[i][j] for i in range(2) for j in range(3)] 
# returns [1, 2, 3, 4, 5, 6]</pre>
<p>This is of particular interest when dealing with arrays; see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.2</a>: <em>A quick glance at the concept of arrays</em>.</p>
<p class="mce-root">List<span> </span>comprehension is closely related to the mathematical notation for sets. Compare <sub><img class="fm-editor-equation" src="assets/17ea4cf5-e5a8-43b6-ac07-2dd603f247c2.png" style="width:8.33em;height:1.33em;"/></sub>and<span> </span><kbd>L2 = [2*x for x in L]</kbd>. One big difference though is that lists are ordered while sets aren't; see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.5</a>: <em>Sets</em>.</p>
<p>As we complete our understanding of lists, we'll now move on to the next section, where we will learn about arrays.</p>
<h1 id="uuid-f8b9fdbc-7bd5-4024-987d-004ae656b9fc">3.2 A quick glance at the concept of arrays</h1>
<p>The NumPy package offers arrays, which are container structures for manipulating vectors, matrices, or even higher-order tensors in mathematics. In this section, we point out the similarities between arrays and lists. But arrays deserve a broader presentation, which will be given in <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Chapter 4</a>:<span> </span><em>Linear Algebra <span>–</span> Arrays</em>, and<span> </span><span><a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml"/><a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml"/><a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml"/><a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Chapter 5</a>:</span><span> </span><em>Advanced Array Concepts</em>.</p>
<p>Arrays are constructed from lists by the function<span> </span><kbd>array</kbd><span> </span>:</p>
<pre>v = array([1.,2.,3.])
A = array([[1.,2.,3.],[4.,5.,6.]])</pre>
<p>To access an element of a vector, we need one index, while an element of a matrix is addressed by two indexes:</p>
<pre>v[2]     # returns 3.0
A[1,2]   # returns 6.0</pre>
<p>At first glance, arrays are similar to lists, but be aware that they are different in a fundamental way, which can be explained by the following points:</p>
<ul>
<li>Access to array data corresponds to that of lists, using square brackets and slices. But for arrays representing matrices, a double index is used. Lists assigned to a slice of an array can be used to alter the array:</li>
</ul>
<pre style="padding-left: 60px">M = array([[1.,2.],[3.,4.]])
v = array([1., 2., 3.])
v[0] # 1
v[:2] # array([1.,2.])
M[0,1] # 2
v[:2] = [10, 20] # v is now array([10., 20., 3.])</pre>
<ul>
<li>The number of elements in a vector, or the number of rows of a matrix, is obtained by the function<span> </span><kbd>len</kbd>:</li>
</ul>
<pre style="padding-left: 60px">len(v) # 3</pre>
<ul>
<li>Arrays store only elements of the same numeric type (usually<span> </span><kbd>float</kbd> or<span> </span><kbd>complex</kbd><span> </span>but also<span> </span><kbd>int</kbd>). </li>
<li>The operations<span> </span><kbd>+</kbd>,<span> </span><kbd>*</kbd>,<span> </span><kbd>/</kbd>, and<span> </span><kbd>-</kbd><span> </span>are all elementwise. The function <kbd>dot</kbd><span> </span>and, in Python versions ≥ 3.5, the infix operator<span> </span><kbd>@</kbd><span> </span>are used for the scalar product and the corresponding matrix operations.</li>
<li>Unlike lists, there is no<span> </span><kbd>append</kbd><span> </span>method for arrays. Nevertheless, there are special methods to construct arrays by stacking smaller size arrays; see <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section 4.7</a>: <em>Stacking</em>. A related point is that arrays are not as elastic as lists; you cannot use slices to change their length.</li>
<li>Vector slices are views, that is, they may be used to modify the original array; see <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.1</a>: <em>Array views and copies</em>.</li>
</ul>
<p>We gave you in this section a quick glance at the container type <kbd>array</kbd>. It is so central in scientific computing with Python that we will devote two entire chapters to it with many more aspects to be presented and discussed; see <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Chapter 4</a>: <em>Linear Algebra <span>–</span> Arrays</em>, and <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Chapter 5</a>: <em>Advanced Array Concepts</em>.</p>
<h1 id="uuid-e145707f-8830-4351-a437-d0102dec6687">3.3 Tuples</h1>
<p>A tuple is an immutable list. Immutable means that it cannot be modified. A tuple is written as a comma-separated sequence of objects (a list without brackets). To increase readability, you often enclose a tuple in a pair of parentheses:</p>
<pre>my_tuple = 1, 2, 3     # our first tuple
my_tuple = (1, 2, 3)   # the same
my_tuple = 1, 2, 3,    # again the same
len(my_tuple) # 3, same as for lists
my_tuple[0] = 'a'   # error! tuples are immutable</pre>
<p>Omitting parentheses can have side effects; see the following example:</p>
<pre>1, 2 == 3, 4 # returns (1, False, 4) 
(1, 2) == (3, 4) # returns False</pre>
<p>The comma indicates that the object is a tuple:</p>
<pre>singleton = 1,   # note the comma
len(singleton)   # 1<br/>singleton = (1,) # this creates the same tuple</pre>
<p>Tuples are useful when a group of values goes together; for example, they are used to return multiple values from functions. See <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.3</a>: <em>Return values</em>.</p>
<h2 id="uuid-b820f443-e487-4449-aaf6-289694d28370">3.3.1 Packing and unpacking variables</h2>
<p> You may assign several variables at once by unpacking a list or tuple:</p>
<pre>a, b = 0, 1 # a gets 0 and b gets 1
a, b = [0, 1] # exactly the same effect
(a, b) = 0, 1 # same
[a,b] = [0,1] # same thing</pre>
<p><span>Use packing and unpacking to swap the contents of two variables:</span><span> </span></p>
<pre>a, b = b, a</pre>
<h1 id="uuid-1c8bd051-7a48-4147-86a1-967d27bdcb1f">3.4 Dictionaries</h1>
<p>Lists, tuples, and arrays are ordered sets of objects. Individual objects are inserted, accessed, and processed according to their place in the list. On the other hand, dictionaries are unordered sets of pairs. You access dictionary data by keys. </p>
<h2 id="uuid-ec7237ad-6b75-4d63-9a87-459338c74b07">3.4.1 Creating and altering dictionaries</h2>
<p>For example, we may create a dictionary containing the data of a rigid body in mechanics, as follows:</p>
<pre>truck_wheel = {'name':'wheel','mass':5.7,
               'Ix':20.0,'Iy':1.,'Iz':17.,
               'center of mass':[0.,0.,0.]}</pre>
<p>A key/data pair is indicated by a colon, <kbd>:</kbd>. These pairs are comma-separated and listed inside a pair of curly brackets, <kbd>{}</kbd>.</p>
<p>Individual elements are accessed by their keys:</p>
<pre>truck_wheel['name']   # returns 'wheel'
truck_wheel['mass']   # returns 5.7</pre>
<p>New objects are added to the dictionary by creating a new key:</p>
<pre>truck_wheel['Ixy'] = 0.0</pre>
<p>Dictionaries are also used to provide parameters to a function (refer to Section<span> 7.2: </span><em>Parameters and arguments</em><span> </span>in<span> </span><a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Chapter 7</a>,<span> </span><em>Functions</em>, for further information).</p>
<p>Keys in a dictionary can be, among others, strings, functions, tuples with immutable elements, and classes. Keys cannot be lists or arrays.</p>
<p>The command<span> </span><kbd>dict</kbd> generates a dictionary from a list with key/value pairs:</p>
<pre>truck_wheel = dict([('name','wheel'),('mass',5.7),       <br/>                    ('Ix',20.0), ('Iy',1.), ('Iz',17.), <br/>                    ('center of mass',[0.,0.,0.])])</pre>
<p>The<span> </span><kbd>zip</kbd><span> </span>function may come in handy in this context; see <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.15</a>:<span> </span><em>Merging lists <span>–</span> zip</em>.</p>
<h2 id="uuid-ab17a6d3-bfa1-4463-b556-172b146cf448">3.4.2 Looping over dictionaries</h2>
<p>There are mainly three ways to loop over dictionaries:</p>
<ul>
<li>By keys:</li>
</ul>
<pre style="padding-left: 60px">for key in truck_wheel.keys():
    print(key) # prints (in any order) 'Ix', 'Iy', 'name',...</pre>
<p style="padding-left: 60px">or equivalently:</p>
<pre style="padding-left: 60px">for key in truck_wheel:
    print(key) # prints (in any order) 'Ix', 'Iy', 'name',...</pre>
<ul>
<li>By value:</li>
</ul>
<pre style="padding-left: 60px">for value in truck_wheel.values():
    print(value) 
    # prints (in any order) 1.0, 20.0, 17.0, 'wheel', ...</pre>
<ul>
<li>By item, that is, key/value pairs:</li>
</ul>
<pre style="padding-left: 60px">for item in truck_wheel.items():
    print(item) 
    # prints (in any order) ('Iy', 1.0), ('Ix, 20.0),...</pre>
<p>Please consult <a href="f95f92d6-d8d1-46a6-bb5b-560714044c70.xhtml">Section 14.4</a>: <em>Shelves</em><span> </span>for a special dictionary object for file access.</p>
<h1 id="uuid-382e6c6a-0158-432b-b35a-ac1c55c13459">3.5 Sets</h1>
<p>The last container object we introduce in this section is defined by the data type <kbd>set</kbd>. </p>
<p>Sets are containers that share properties and operations with sets in mathematics. A mathematical set is a collection of distinct objects. <span>Like in mathematics, in Python the elements of a set are </span><span>also</span><span> </span><span>listed within a pair of braces.</span></p>
<p>Here are some mathematical set expressions:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/aad383dc-c771-4612-9a69-441947c90471.png" style="width:32.33em;height:1.25em;"/></p>
<p>And here are their Python counterparts:</p>
<pre>A = {1,2,3,4}
B = {5}
C = A.union(B)   # returns{1,2,3,4,5}
D = A.intersection(C)   # returns {1,2,3,4}
E = C.difference(A)   # returns {5}
5 in C   # returns True</pre>
<p>Sets contain an element only once, corresponding to the aforementioned definition:</p>
<pre>A = {1,2,3,3,3}
B = {1,2,3}
A == B # returns True</pre>
<p>Moreover, a set is unordered; that is, the order of the elements in the set is not defined:</p>
<pre>A = {1,2,3}
B = {1,3,2}
A == B # returns True</pre>
<p>Sets in Python can contain all kinds of immutable objects, that is, numeric objects, strings, and Booleans.</p>
<p>There are the methods <kbd>union</kbd><span> </span>and<span> </span><kbd>intersection</kbd> for the corresponding mathematical operations:</p>
<pre>A={1,2,3,4}
A.union({5})
A.intersection({2,4,6}) # returns {2, 4}</pre>
<p>Also, sets can be compared using the methods<span> </span><kbd>issubset</kbd><span> </span>and<span> </span><kbd>issuperset</kbd>:</p>
<pre>{2,4}.issubset({1,2,3,4,5}) # returns True
{1,2,3,4,5}.issuperset({2,4}) # returns True</pre>
<p class="mce-root">An empty set is defined in Python by <kbd>empty_set=set([])</kbd> and not by<span> </span><kbd>{}</kbd>, which would define an empty dictionary!</p>
<h1 id="uuid-e330a68d-d6bd-4533-9adb-956043069ce5">3.6 Container conversions</h1>
<p>We summarize in the following<span> </span><em>Table 3.3</em><span> </span>the most important properties of the container types presented so far. (Arrays will be treated separately in <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Chapter 4</a>: <em>Linear Algebra <span>–</span> Arrays</em>):</p>
<table style="border-collapse: collapse;border-color: #000000;width: 100%" border="1">
<tbody>
<tr style="height: 31px">
<td style="width: 19.9419%" class="CDPAlignCenter CDPAlign">
<p><strong>Type</strong></p>
</td>
<td style="width: 16.3601%" class="CDPAlignCenter CDPAlign">
<p><strong>Access</strong></p>
</td>
<td style="width: 15.4895%" class="CDPAlignCenter CDPAlign">
<p><strong>Order</strong></p>
</td>
<td style="width: 26.6208%" class="CDPAlignCenter CDPAlign">
<p><strong>Duplicate Values</strong></p>
</td>
<td style="width: 19.8451%" class="CDPAlignCenter CDPAlign">
<p><strong>Mutability</strong></p>
</td>
</tr>
<tr style="height: 61px">
<td style="width: 19.9419%" class="CDPAlignCenter CDPAlign">
<p>List</p>
</td>
<td style="width: 16.3601%" class="CDPAlignCenter CDPAlign">
<p>By index</p>
</td>
<td style="width: 15.4895%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
<td style="width: 26.6208%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
<td style="width: 19.8451%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
</tr>
<tr style="height: 50px">
<td style="width: 19.9419%" class="CDPAlignCenter CDPAlign">
<p>Tuple</p>
</td>
<td style="width: 16.3601%" class="CDPAlignCenter CDPAlign">
<p>By index</p>
</td>
<td style="width: 15.4895%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
<td style="width: 26.6208%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
<td style="width: 19.8451%" class="CDPAlignCenter CDPAlign">
<p>No</p>
</td>
</tr>
<tr style="height: 51px">
<td style="width: 19.9419%" class="CDPAlignCenter CDPAlign">
<p>Dictionary</p>
</td>
<td style="width: 16.3601%" class="CDPAlignCenter CDPAlign">
<p>By key</p>
</td>
<td style="width: 15.4895%" class="CDPAlignCenter CDPAlign">
<p>No</p>
</td>
<td style="width: 26.6208%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
<td style="width: 19.8451%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
</tr>
<tr style="height: 45.584px">
<td style="width: 19.9419%" class="CDPAlignCenter CDPAlign">
<p>Set</p>
</td>
<td style="width: 16.3601%" class="CDPAlignCenter CDPAlign">
<p>No</p>
</td>
<td style="width: 15.4895%" class="CDPAlignCenter CDPAlign">
<p>No</p>
</td>
<td style="width: 26.6208%" class="CDPAlignCenter CDPAlign">
<p>No</p>
</td>
<td style="width: 19.8451%" class="CDPAlignCenter CDPAlign">
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 3.3: Container types</div>
<p>As you can see in the previous table, there is a difference in accessing container elements, and sets and dictionaries are not ordered.</p>
<p>Due to the different properties of the various container types, we frequently convert one type to another (see <em>Table 3.4</em>):</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr style="height: 66px">
<td class="CDPAlignCenter CDPAlign">
<p><strong>Container Types</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Syntax</strong></p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>List → Tuple</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>tuple([1, 2, 3])</kbd></p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>Tuple → List</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>list((1, 2, 3))</kbd></p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>List, Tuple → Set</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>set([1, 2]), set((1, ))</kbd></p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>Set → List</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>list({1, 2 ,3})</kbd></p>
</td>
</tr>
<tr style="height: 61px">
<td class="CDPAlignCenter CDPAlign">
<p>Dictionary → List</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><kbd>{'a':4}.values()</kbd></p>
</td>
</tr>
<tr style="height: 32px">
<td class="CDPAlignCenter CDPAlign">
<p>List → Dictionary</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 3.4: Conversion rules for container types</div>
<p>We saw in this section how to convert container types. In <a href="879c0554-386f-4bb1-8fa8-b86c43927545.xhtml">Chapter 2</a>: <em>Variables and Basic Types</em>, we saw how to convert more elementary datatypes such as numbers. So, it is time now to consider how to actually check which datatype a variable has, which is the topic of the next section.</p>
<h1 id="uuid-8437b323-2b67-4a87-9abe-4009e5d5cf2e">3.7 Checking the type of a variable</h1>
<p>The direct way to see the type of a variable is to use the <span>command </span>type:</p>
<pre>label = 'local error'
type(label) # returns str
x = [1, 2] # list
type(x) # returns list</pre>
<p>However, if you want to test for a variable to be of a certain type, you should use<span> </span><kbd>isinstance</kbd><span> </span>(instead of comparing the types with<span> </span><kbd>type</kbd>):</p>
<pre>isinstance(x, list) # True</pre>
<p>The reason for using<span> </span><kbd>isinstance</kbd><span> </span>becomes apparent after having read about the concept of subclassing and inheritance in <a href="1654fae9-6203-4871-8352-e436445fa49a.xhtml">Section 8.5</a>: <em>Subclassing and inheritance</em>. In short, often different types share some common properties with some basic type. The classical example is the type<span> </span><kbd>bool</kbd>, which is derived by subclassing from the more general type<span> </span><kbd>int</kbd>. In this situation, we see how the command<span> </span><kbd>isinstance</kbd> can be used in a more general way:</p>
<pre>test = True
isinstance(test, bool) # True
isinstance(test, int) # True
type(test) == int # False
type(test) == bool # True</pre>
<p>So, in order to make sure that the variable<span> </span><kbd>test</kbd><span> can be used as if it were</span> an integer <span>–</span> the particular type may be irrelevant <span>–</span> you should check that it is an instance of<span> </span><kbd>int</kbd>:</p>
<pre>if isinstance(test, int): print("The variable is an integer")</pre>
<p class="mce-root">Python is not a typed language. That means that objects are identified by what they can do rather than what they are. For instance, if you have a string manipulating function that acts on an object by using the <kbd>len</kbd> method, then your function will probably be useful for any objects implementing the <kbd>len</kbd> method.</p>
<p>So far, we have come across different datatypes: <kbd>float</kbd>, <kbd>int</kbd>, <kbd>bool</kbd>, <kbd>complex</kbd>, <kbd>list</kbd>, <kbd>tuple</kbd>, <kbd>module</kbd>, <kbd>function</kbd>, <kbd>str</kbd>,<span> </span><kbd>dict</kbd>, and<span> </span><kbd>array</kbd>.</p>
<h1 id="uuid-177e7bcf-eed3-4ce9-bc0f-4ad7da4b4623">3.8 Summary</h1>
<p>In this chapter, you learned how to work with container types, mainly lists. It is important to know how to fill these containers and how to access and manage their content. We saw that there is access by position or by keyword.</p>
<p>We will meet the important concept of slicing again in the next chapter on arrays. These are specially designed containers for mathematical operations.</p>
<h1 id="uuid-f40baf89-02c9-49ee-b922-5faccc486255">3.9 Exercises</h1>
<p><strong>Ex. 1:</strong> Execute the following statements:</p>
<pre>L = [1, 2]
L3 = 3*L</pre>
<ol>
<li>What is the content of<span> </span><kbd>L3</kbd>?</li>
<li>Try to predict the outcome of the following commands:</li>
</ol>
<pre style="padding-left: 60px">L3[0]
L3[-1]
L3[10]</pre>
<ol start="3">
<li>What does the following command do?</li>
</ol>
<pre style="padding-left: 60px">L4 = [k**2 for k in L3]</pre>
<ol start="4">
<li>Concatenate<span> </span><span><kbd>L3</kbd> </span>and<span> </span><kbd>L4</kbd><span> </span>to a new list<span> </span><kbd>L5</kbd>.</li>
</ol>
<p><strong>Ex. 2:</strong> Use the<span> </span><kbd>range</kbd><span> </span>command and a list comprehension to generate a list with 100 equidistantly spaced values between 0 and 1.</p>
<p><strong>Ex. 3:</strong> Assume that the following signal is stored in a list:</p>
<pre>L = [0,1,2,1,0,-1,-2,-1,0]</pre>
<p>What is the outcome of:</p>
<pre>L[0]
L[-1]
L[:-1]
L + L[1:-1] + L
L[2:2] = [-3]
L[3:4] = []
L[2:5] = [-5]</pre>
<p>Do this exercise by inspection only, that is, without using your Python shell.</p>
<p><strong>Ex. 4:</strong> Consider the Python statements:</p>
<pre>L = [n-m/2 for n in range(m)]
ans = 1 + L[0] + L[-1]</pre>
<p>and assume that the variable<span> </span><kbd>m</kbd><span> </span>has been previously assigned an integer value. What is the value of<span> </span><kbd>ans</kbd>? Answer this question without executing the statements in Python.</p>
<p><strong>Ex. 5:</strong><span> </span>Consider the recursion formula:</p>
<p><img src="assets/11b74e07-fe97-4c9e-a0b6-1b384cff0015.png"/></p>
<ol>
<li>Create a list<span> </span><kbd>u</kbd>. Store in its first three elements the three values <img class="fm-editor-equation" src="assets/921ed357-eca6-4286-ace3-ea396515a5c5.png" style="width:3.42em;height:1.58em;"/>, and <img class="fm-editor-equation" src="assets/232fc9b2-0542-4858-843d-d4e57c224f47.png" style="width:2.17em;height:1.42em;"/>. These represent the starting values<span> <img class="fm-editor-equation" src="assets/e5832afc-9afc-46ae-b065-53b9711fd5b9.png" style="width:3.67em;height:1.08em;"/></span> and<span> </span><span><img class="fm-editor-equation" src="assets/0683b5d5-4b9d-4362-8a66-35245b0bc4a7.png" style="width:1.33em;height:1.08em;"/></span> in the given formula. Build up the complete list from the recursion formula.</li>
<li>Construct a second list, <kbd>td</kbd>, in which you store the values <em><img class="fm-editor-equation" src="assets/4256cd7e-e93c-49c4-9bc6-1404ee654be4.png" style="width:1.33em;height:1.00em;"/></em>, with <span><img class="fm-editor-equation" src="assets/2c943450-f803-4e9c-b44d-66af7f791edd.png" style="width:8.25em;height:1.25em;"/></span>. Plot<span> </span><kbd>td</kbd><span> </span>versus<span> </span><kbd>u</kbd> (see <a href="86c61820-e645-486c-9418-10079ffac7f8.xhtml">Section 6.1</a>: <em>Making plots</em>). Make a second plot in which you plot the difference, that is,<span> <img class="fm-editor-equation" src="assets/13138cdc-1cc2-4ce8-9f80-d82f7a7c630c.png" style="width:4.83em;height:1.42em;"/></span>, where <span><img class="fm-editor-equation" src="assets/325d4dc1-fe3d-4d4c-907c-f8aa912e0b37.png" style="width:1.33em;height:1.42em;"/></span>represents the values inside the vector<span> </span><kbd>td</kbd>. Set axis labels and a title.</li>
</ol>
<p>The recursion is a multistep formula to solve the differential equation <img class="fm-editor-equation" src="assets/bddef92b-5e38-4de4-a136-f9b278e2e06a.png" style="width:4.42em;height:1.33em;"/> with the initial value <img class="fm-editor-equation" src="assets/75f4fafd-e7c9-405b-9cf0-a5263202aa3d.png" style="width:6.75em;height:1.33em;"/>.</p>
<p><sub><img class="fm-editor-equation" src="assets/e544c41b-2a9b-49b5-b72f-c77590198308.png" style="width:1.50em;height:1.08em;"/></sub> approximates<span> <sub><img class="fm-editor-equation" src="assets/9b609804-6bf2-47e1-a952-85b804bab70c.png" style="width:7.42em;height:1.50em;"/></sub></span>.</p>
<p><strong>Ex. 6:</strong> Let<span> </span><img class="fm-editor-equation" src="assets/2f193357-daa9-41f6-a179-e4971501a234.png" style="width:0.92em;height:1.08em;"/> and<span> </span><span><img class="fm-editor-equation" src="assets/b785da32-e046-4761-8745-9258b57b0bf8.png" style="width:0.83em;height:0.92em;"/></span> be sets. The set <img class="fm-editor-equation" src="assets/59f36140-6831-4e59-a86c-031dc8f9cb56.png" style="width:6.50em;height:1.17em;"/> is called the symmetric difference of the two sets. Write a function that performs this operation. Compare your results to the result of the command:</p>
<pre>A.symmetric_difference(B).</pre>
<p><strong>Ex. 7:</strong> Verify in Python the statement that the empty set is a subset of any set.</p>
<p><strong>Ex. 8:</strong> Study other operations on sets. You can find a complete list of those by using the command completion feature of <kbd>IPython</kbd>. In particular, study the <kbd>update</kbd><span> </span>and<span> </span><kbd>intersection_update</kbd> methods. What is the difference between<span> </span><kbd>intersection</kbd><span> </span>and<span> </span><kbd>intersection_update</kbd>?</p>


            </article>

            
        </section>
    </body></html>