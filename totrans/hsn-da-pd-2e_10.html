<html><head></head><body>
		<div id="_idContainer343">
			<h1 id="_idParaDest-147"><em class="italic"><a id="_idTextAnchor146"/>Chapter 7</em>: Financial Analysis – Bitcoin and the Stock Market</h1>
			<p>It's time to switch gears and work on an application. In this chapter, we will explore a financial application by performing an analysis of bitcoin and the stock market. This chapter builds upon everything we have learned so far—we will extract data from the Internet; perform some exploratory data analysis; create visualizations with <strong class="source-inline">pandas</strong>, <strong class="source-inline">seaborn</strong>, and <strong class="source-inline">matplotlib</strong>; calculate important metrics for analyzing the performance of financial instruments using <strong class="source-inline">pandas</strong>; and get a taste of building some models. Note that we are not trying to learn financial analysis here, but rather walk through an introduction of how the skills we have learned in this book can be applied to financial analysis.</p>
			<p>This chapter is also a departure from the standard workflow in this book. Up until this point, we have been working with Python as more of a functional programming language. However, Python also supports <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). This means we can build classes that will carry out the major tasks we need to perform, which in this chapter are the following: collecting data from the Internet (with the <strong class="source-inline">StockReader</strong> class), visualizing financial assets (with the <strong class="source-inline">Visualizer</strong> classes), calculating financial metrics (with the <strong class="source-inline">StockAnalyzer</strong> class), and modeling financial data (with the <strong class="source-inline">StockModeler</strong> class). Since we will need a lot of code to make the analysis process clean and easy to reproduce, we will build a Python package to house these classes. The code will be reproduced in the text and explained as usual; however, we don't need to type/run it on our own—be sure to read the <em class="italic">Chapter materials</em> section for this chapter to get set up properly.</p>
			<p>This chapter will be challenging and may require a few rereads; however, it will teach best practices, and the skills acquired here will dramatically improve your coding skills, which will quickly pay off. One main takeaway should be that OOP can be very helpful in packaging up analysis tasks. Each class should have a single purpose and be well documented. If we have many classes, we should spread them across separate files and make a package. This makes it very easy for others to install/use them and for us to standardize the way certain tasks are performed across a project. As an example, we shouldn't have each of our collaborators on a project writing their own functions to connect to a database. Standardized, well-documented code will save lots of headaches down the road. </p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Building a Python package</li>
				<li>Collecting financial data</li>
				<li>Conducting exploratory data analysis</li>
				<li>Performing technical analysis of financial instruments</li>
				<li>Modeling performance using historical data</li>
			</ul>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Chapter materials</h1>
			<p>For this chapter, we will be creating our own package for stock analysis. This makes it extremely easy for us to distribute our code and for others to use our code. The final product of this package is on GitHub at <a href="https://github.com/stefmolin/stock-analysis/tree/2nd_edition">https://github.com/stefmolin/stock-analysis/tree/2nd_edition</a>. Python's package manager, <strong class="source-inline">pip</strong>, is capable of installing packages from GitHub and also building them locally; this leaves us with either of the following choices as to how we want to proceed:</p>
			<ul>
				<li>Install from GitHub if we don't plan on editing the source code for our own use.</li>
				<li>Fork and clone the repository and then install it on our machine in order to modify the code.</li>
			</ul>
			<p>If we wish to install from GitHub directly, we don't need to do anything here since this was installed when we set up our environment back in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>; however, for reference, we would do the following to install packages from GitHub:</p>
			<p class="source-code">(book_env) $ pip3 install \</p>
			<p class="source-code">git+https://github.com/stefmolin/stock-analysis.git@2nd_edition</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">@2nd_edition</strong> portion of the URL tells <strong class="source-inline">pip</strong> to install the version that was tagged <strong class="source-inline">2nd_edition</strong>. To install the version of the code on a particular branch instead, replace this with <strong class="source-inline">@&lt;branch_name&gt;</strong>. For example, if we want the code being developed on a branch called <strong class="source-inline">dev</strong>, we use <strong class="source-inline">@dev</strong>. Be sure to check that the branch exists first, of course. We can also use the commit hash in the same fashion to grab a specific commit. More information is available at <a href="https://pip.pypa.io/en/latest/reference/pip_install/#git">https://pip.pypa.io/en/latest/reference/pip_install/#git</a>. </p>
			<p>To install locally in editable mode—meaning that any changes will automatically be reflected locally without having to reinstall—we use the <strong class="source-inline">-e</strong> flag. Run the following from the command line in the virtual environment we created in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>, to do so. Note that this will clone the latest version of the package, which may be different from the version in the text (the version with the <strong class="source-inline">2nd_edition</strong> tag):</p>
			<p class="source-code">(book_env) $ git clone \</p>
			<p class="source-code"><strong class="bold">git@github.com:stefmolin/stock-analysis.git</strong></p>
			<p class="source-code">(book_env) $ pip3 install -r stock-analysis/requirements.txt</p>
			<p class="source-code">(book_env) $ pip3 install -e stock-analysis</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This example uses <strong class="source-inline">git clone</strong> over SSH; if SSH keys are not set up already, clone over HTTPS instead by using a variation of the URL: <strong class="source-inline">https://github.com/stefmolin/stock-analysis.git</strong>. Alternatively, follow the instructions on GitHub for generating SSH keys first. Consult this Stack Overflow post if you're interested in just cloning the version with the <strong class="source-inline">2nd_edition</strong> tag: <a href="https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag">https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag</a>.</p>
			<p>We will be using this package throughout this chapter. The directory for this chapter in this book's repository has the <strong class="source-inline">financial_analysis.ipynb</strong> notebook we will use for our actual analysis and can be found at <a href="https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_07">https://github.com/stefmolin/Hands-On-Data-Analysis-with-Pandas-2nd-edition/tree/master/ch_07</a>. The <strong class="source-inline">data/</strong> folder contains backup files in case the data sources have changed since publication or there are any errors when collecting the data with the <strong class="source-inline">StockReader</strong> class; simply read in the CSV files and follow along with the rest of this chapter should this happen. Similarly, the <strong class="source-inline">exercises/</strong> folder contains backup files for the exercises.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If we change a file in a package installed in editable mode when working with Jupyter Notebooks, we will need to restart our kernel or open a new Python shell and reimport the package. This is because Python will cache it after import. Other options include using <strong class="source-inline">importlib.reload()</strong> or the IPython <strong class="source-inline">autoreload</strong> extension (<a href="https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html">https://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html</a>).</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Building a Python package</h1>
			<p>Building<a id="_idIndexMarker836"/> packages is considered good coding practice since it allows for writing modular code and reuse. <strong class="bold">Modular code</strong> is code that is written in many smaller pieces for more pervasive use, without needing to know the underlying implementation details of everything involved in a task. For example, when we use <strong class="source-inline">matplotlib</strong> to plot something, we don't need to know what the code inside the functions we call is doing exactly—it suffices to simply know what the input and output will be to build on top of it.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>Package structure</h2>
			<p>A <strong class="bold">module</strong> is a<a id="_idIndexMarker837"/> single <a id="_idIndexMarker838"/>file of Python code that can be<a id="_idIndexMarker839"/> imported; <strong class="source-inline">window_calc.py</strong> from <a href="B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 4</em></a>, <em class="italic">Aggregating Pandas DataFrames</em>, and <strong class="source-inline">viz.py</strong> from <a href="B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Plotting with Seaborn and Customization Techniques</em>, were both modules. A <strong class="bold">package</strong> is a collection of modules organized into directories. Packages can also be imported, but when we import a package we have access to certain modules inside, so we don't have to import each one individually. This also allows us to build modules that import from each other without the need to maintain a single very large module.</p>
			<p>To turn modules into a package, we follow these steps:</p>
			<ol>
				<li>Create a directory with the name of the package (<strong class="source-inline">stock_analysis</strong> for this chapter).</li>
				<li>Place the modules in the aforementioned directory.</li>
				<li>Add an <strong class="source-inline">__init__.py</strong> file containing any Python code to run upon importing the package (this can be—and often is—empty).</li>
				<li>Make a <strong class="source-inline">setup.py</strong> file at the same level as the package's top-level directory (<strong class="source-inline">stock_analysis</strong> here), which will give <strong class="source-inline">pip</strong> instructions on how to install the package. See the <em class="italic">Further reading</em> section for information on creating this.</li>
			</ol>
			<p>Once the aforementioned <a id="_idIndexMarker840"/>steps are complete, the package can be installed with <strong class="source-inline">pip</strong>. Note that, while our package only contains a single directory, we can build a package with as many subpackages as we desire. These subpackages are created just as if we were creating a package, with the exception that they don't need a <strong class="source-inline">setup.py</strong> file:</p>
			<ol>
				<li value="1">Create a directory for the subpackage inside the main package directory (or inside some other subpackage).</li>
				<li>Place the subpackage's modules in this directory.</li>
				<li>Add the <strong class="source-inline">__init__.py</strong> file, with code that should be run when the subpackage is imported (this can be empty).</li>
			</ol>
			<p>The directory hierarchy for a package with a single subpackage would look something like this:</p>
			<p class="source-code">repo_folder</p>
			<p class="source-code">|-- &lt;package_name&gt;</p>
			<p class="source-code">|   |-- __init__.py</p>
			<p class="source-code">|   |-- some_module.py</p>
			<p class="source-code">|   `-- &lt;subpackage_name&gt;</p>
			<p class="source-code">|       |-- __init__.py</p>
			<p class="source-code">|       |-- another_module.py</p>
			<p class="source-code">|       `-- last_module.py</p>
			<p class="source-code">`-- setup.py</p>
			<p>Some other things to be aware of when building a package include the following:</p>
			<ul>
				<li>Writing a <strong class="bold">README</strong> file <a id="_idIndexMarker841"/>for the repository so that others know what it contains (see <a href="https://www.makeareadme.com/">https://www.makeareadme.com/</a>).</li>
				<li><strong class="bold">Linting</strong> the<a id="_idIndexMarker842"/> code in order to conform to coding standards and analyze the code for possible errors (check out the <strong class="source-inline">pylint</strong> package at <a href="https://www.pylint.org/">https://www.pylint.org/</a>).</li>
				<li>Adding tests that will make sure changes to the code don't break anything and that the code does what it is meant to do (take a look at the <strong class="source-inline">pytest</strong> package at <a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a>).</li>
			</ul>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Overview of the stock_analysis package</h2>
			<p>In this chapter, we <a id="_idIndexMarker843"/>will be creating a Python package<a id="_idIndexMarker844"/> called <strong class="source-inline">stock_analysis</strong> using the various Python packages we have discussed so far, along with the Python standard library. This package is located in the <strong class="source-inline">stock-analysis</strong> repository (<a href="https://github.com/stefmolin/stock-analysis">https://github.com/stefmolin/stock-analysis</a>), which is arranged like this:</p>
			<div>
				<div id="_idContainer314" class="IMG---Figure">
					<img src="image/Figure_7.1_B16834.jpg" alt="Figure 7.1 – Structure of the stock-analysis repository&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 7.1 – Structure of the stock-analysis repository</p>
			<p>The modules in our package will contain custom classes for conducting the technical analysis of an asset. <strong class="bold">Classes</strong> should be designed for a single purpose; this makes it easier to build, use, and debug if issues arise. Therefore, we will be building several classes in order to cover the various facets of our financial analysis. We will need a class for each of <a id="_idIndexMarker845"/>the <a id="_idIndexMarker846"/>following purposes:</p>
			<div>
				<div id="_idContainer315" class="IMG---Figure">
					<img src="image/Figure_7.2_B16834.jpg" alt="Figure 7.2 – Main themes and classes for the stock_analysis package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Main themes and classes for the stock_analysis package</p>
			<p>It can be helpful to visualize the interaction between modules in a package and the functionality <a id="_idIndexMarker847"/>each class provides. For this purpose, we <a id="_idIndexMarker848"/>can build <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) diagrams.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>UML diagrams</h2>
			<p><strong class="bold">UML diagrams</strong> show<a id="_idIndexMarker849"/> information about which attributes and methods classes <a id="_idIndexMarker850"/>have and how classes are related to others. We can see in the following diagram that all the modules rely on <strong class="source-inline">utils.py</strong> for utility functions:</p>
			<div>
				<div id="_idContainer316" class="IMG---Figure">
					<img src="image/Figure_7.3_B16834.jpg" alt="Figure 7.3 – Module dependencies in the stock_analysis package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 7.3 – Module dependencies in the stock_analysis package</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="source-inline">pylint</strong> package comes with <strong class="source-inline">pyreverse</strong>, which makes UML diagrams. If <strong class="source-inline">graphviz</strong> is installed (<a href="http://www.graphviz.org/download/">http://www.graphviz.org/download/</a>), running the following from the command line generates a PNG file for the relationship between modules and a UML diagram for the classes (provided the repository was cloned and <strong class="source-inline">pylint</strong> is installed): <strong class="source-inline">pyreverse -o png stock_analysis</strong></p>
			<p>The UML diagram <a id="_idIndexMarker851"/>for the classes in the <strong class="source-inline">stock_analysis</strong> package looks like this:</p>
			<div>
				<div id="_idContainer317" class="IMG---Figure">
					<img src="image/Figure_7.4_B16834.jpg" alt="Figure 7.4 – UML diagrams for classes in the stock_analysis package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – UML diagrams for classes in the stock_analysis package</p>
			<p>The top <a id="_idIndexMarker852"/>section in each box contains the class name; the middle section contains the attributes of that class; while the bottom section contains any methods defined in that class. Notice the arrows pointing from the <strong class="source-inline">AssetGroupVisualizer</strong> and <strong class="source-inline">StockVisualizer</strong> classes to the <strong class="source-inline">Visualizer</strong> class? This means that both are a type of <strong class="source-inline">Visualizer</strong>. The methods shown for the <strong class="source-inline">AssetGroupVisualizer</strong> and <strong class="source-inline">StockVisualizer</strong> classes are defined differently in those classes compared to the <strong class="source-inline">Visualizer</strong> class. We will <a id="_idIndexMarker853"/>cover this in more depth in the <em class="italic">Exploratory data analysis</em> section. Throughout the remaining sections of this chapter, we will be going over each of the classes in the <strong class="source-inline">stock_analysis</strong> package in more detail and using their functionality to perform technical analysis of financial assets.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Collecting financial data</h1>
			<p>Back in <a href="B16834_02_Final_SK_ePub.xhtml#_idTextAnchor035"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Pandas DataFrames</em>, and <a href="B16834_03_Final_SK_ePub.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Data Wrangling with Pandas</em>, we <a id="_idIndexMarker854"/>worked with APIs to gather data; however, there are other ways to collect data from the Internet. We can use <strong class="bold">web scraping</strong> to<a id="_idIndexMarker855"/> extract data from the HTML page itself, which <strong class="source-inline">pandas</strong> offers with the <strong class="source-inline">pd.read_html()</strong> function—it returns a dataframe for each of the HTML tables it finds on the page. For economic and financial data, an alternative is the <strong class="source-inline">pandas_datareader</strong> package, which the <strong class="source-inline">StockReader</strong> class in the <strong class="source-inline">stock_analysis</strong> package uses to collect financial data.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In case anything has changed with the data sources that are used in this chapter or you encounter errors when using the <strong class="source-inline">StockReader</strong> class to collect data, the CSV files in the <strong class="source-inline">data/</strong> folder can be read in as a replacement in order to follow along with the text; for example: </p>
			<p class="callout"><strong class="source-inline">pd.read_csv('data/bitcoin.csv', index_col='date',</strong><strong class="source-inline"> </strong><strong class="source-inline">            parse_dates=True)</strong></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>The StockReader class</h2>
			<p>Since we will<a id="_idIndexMarker856"/> be collecting data for various assets across the same date range, it makes sense to create a class that hides all of the implementation details and, therefore, avoid lots of copying and pasting (and potential mistakes). For this purpose, we will build the <strong class="source-inline">StockReader</strong> class, which will make it easier to collect data for bitcoin, stocks, and stock market indices. We can simply create an instance of the <strong class="source-inline">StockReader</strong> class by providing the date range we want for our analysis, and then use the methods it provides to get whichever data we please. The following UML diagram provides a high-level overview of the implementation:</p>
			<div>
				<div id="_idContainer318" class="IMG---Figure">
					<img src="image/Figure_7.5_B16834.jpg" alt="Figure 7.5 – UML diagram for the StockReader class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – UML diagram for the StockReader class</p>
			<p>The UML <a id="_idIndexMarker857"/>diagram tells us that the <strong class="source-inline">StockReader</strong> class provides an attribute for the available tickers (<strong class="source-inline">available_tickers</strong>) and can perform the following actions:</p>
			<ul>
				<li>Pull bitcoin data in the desired currency with the <strong class="source-inline">get_bitcoin_data()</strong> method.</li>
				<li>Pull daily foreign exchange rates data with the <strong class="source-inline">get_forex_rates()</strong> method.</li>
				<li>Pull data for an index on the stock market (such as the S&amp;P 500) with the <strong class="source-inline">get_index_data()</strong> method.</li>
				<li>Look up the ticker (stock market symbol) for a specific index (for instance, ^GSPC for the S&amp;P 500 ticker on Yahoo! Finance) with the <strong class="source-inline">get_index_ticker()</strong> method.</li>
				<li>Collect the risk-free rate of return with the <strong class="source-inline">get_risk_free_rate_of_return()</strong> method.</li>
				<li>Pull data for a ticker on the stock market (such as NFLX for Netflix) with the <strong class="source-inline">get_ticker_data()</strong> method.</li>
			</ul>
			<p>Now that we understand why we need this class and have a high-level overview of its structure, we can proceed to looking at the code. Since there is a lot of code in the <strong class="source-inline">stock_analysis/stock_reader.py</strong> module to review, we will break down the file piece by piece. Note that this may change the indentation level, so please consult the file itself for the full version.</p>
			<p>The first line of the module is the <strong class="bold">docstring</strong> for the module. If we run <strong class="source-inline">help()</strong> on the module itself, that will appear near the top. This describes the purpose of our module. This is immediately<a id="_idIndexMarker858"/> followed by any imports we will need:</p>
			<p class="source-code">"""Gather select stock data."""</p>
			<p class="source-code">import datetime as dt</p>
			<p class="source-code">import re</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import pandas_datareader.data as web</p>
			<p class="source-code">from .utils import label_sanitizer</p>
			<p>Notice that the <strong class="source-inline">import</strong> statements are organized<a id="_idIndexMarker859"/> in three groups, following <strong class="bold">PEP 8</strong> (Python style guidelines available at https://www.python.org/dev/peps/pep-0008/), which states that they should be in the following order:</p>
			<ol>
				<li value="1">Standard library imports (<strong class="source-inline">datetime</strong> and <strong class="source-inline">re</strong>)</li>
				<li>Third-party libraries (<strong class="source-inline">pandas</strong> and <strong class="source-inline">pandas_datareader</strong>)</li>
				<li>Relative import from another module in the <strong class="source-inline">stock_analysis</strong> package (<strong class="source-inline">.utils</strong>)</li>
			</ol>
			<p>After our imports, we define the <strong class="source-inline">StockReader</strong> class. First, we create a dictionary mapping tickers for indices to a descriptive name in <strong class="source-inline">_index_tickers</strong>. Notice that our class also has a docstring, which defines its purpose. Here, we will only reproduce a few of the tickers available:</p>
			<p class="source-code">class StockReader:</p>
			<p class="source-code">    """Class for reading financial data from websites."""</p>
			<p class="source-code">    _index_tickers = {'S&amp;P 500': '^GSPC', 'Dow Jones': '^DJI',</p>
			<p class="source-code">                      'NASDAQ': '^IXIC'}</p>
			<p>When building a class, there are many <strong class="bold">special methods</strong> (colloquially referred to as <em class="italic">dunder methods</em> because their names start and end with double underscores) that we can provide to<a id="_idIndexMarker860"/> customize the behavior of the class when it's used with language operators:</p>
			<ul>
				<li>Initialize an object (<strong class="source-inline">__init__()</strong>).</li>
				<li>Make an object comparable for sorting (<strong class="source-inline">__eq__()</strong>, <strong class="source-inline">__lt__()</strong>, <strong class="source-inline">__gt__()</strong>, and more).</li>
				<li>Perform arithmetic on the object (<strong class="source-inline">__add__()</strong>, <strong class="source-inline">__sub__()</strong>, <strong class="source-inline">__mul__()</strong>, and so on).</li>
				<li>Be able to use built-in Python functions such as <strong class="source-inline">len()</strong> on it (<strong class="source-inline">__len__()</strong>).</li>
				<li>Get a string representation of the object for use with the <strong class="source-inline">print()</strong> function (<strong class="source-inline">__repr__()</strong> and <strong class="source-inline">__str__()</strong>).</li>
				<li>Support iteration and indexing (<strong class="source-inline">__getitem__()</strong>, <strong class="source-inline">__iter__()</strong>, and <strong class="source-inline">__next__()</strong>).</li>
			</ul>
			<p>Thankfully, we don't have to write all this functionality every time we make a class. In most cases, we just need the <strong class="source-inline">__init__()</strong> method, which is run when we create an object. (More information on special methods can be found at <a href="https://dbader.org/blog/python-dunder-methods">https://dbader.org/blog/python-dunder-methods</a> and <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names.">https://docs.python.org/3/reference/datamodel.html#special-method-names.</a>)</p>
			<p>Objects of the <strong class="source-inline">StockReader</strong> class hold on to the start and end dates that data will be gathered for, so we put this in the <strong class="source-inline">__init__()</strong> method. We parse the dates that are passed in by the caller to allow for the use of any date separator; for example, we will be able to handle inputs of Python <strong class="source-inline">datetime</strong> objects; strings in the form of <strong class="source-inline">'YYYYMMDD'</strong>; or strings representing dates using any separator that matches the non-digit regular expression (<strong class="source-inline">\D</strong>), such as <strong class="source-inline">'YYYY|MM|DD'</strong> or <strong class="source-inline">'YYYY/MM/DD'</strong>. The separator, if there is one, gets replaced with an empty string so that we can build our datetimes using the <strong class="source-inline">'YYYYMMDD'</strong> format in our method. In addition, we raise a <strong class="source-inline">ValueError</strong> if the<a id="_idIndexMarker861"/> caller gives us a start date equal to or after the end date:</p>
			<p class="source-code">    def __init__(self, start, end=None):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Create a `StockReader` object for reading across </p>
			<p class="source-code">        a given date range.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - start: The first date to include, as a datetime </p>
			<p class="source-code">              object or a string in the format 'YYYYMMDD'.</p>
			<p class="source-code">            - end: The last date to include, as a datetime</p>
			<p class="source-code">              object or string in the format 'YYYYMMDD'.</p>
			<p class="source-code">              Defaults to today if not provided.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        self.start, self.end = map(</p>
			<p class="source-code">            lambda x: x.strftime('%Y%m%d')\</p>
			<p class="source-code">                if isinstance(x, dt.date)\</p>
			<p class="source-code">                else <strong class="bold">re.sub(r'\D', '', x)</strong>,</p>
			<p class="source-code">            [start, end or dt.date.today()]</p>
			<p class="source-code">        )</p>
			<p class="source-code">        if <strong class="bold">self.start &gt;= self.end</strong>:</p>
			<p class="source-code">            raise ValueError('`start` must be before `end`')</p>
			<p>Note that we didn't define <strong class="source-inline">_index_tickers</strong> in the <strong class="source-inline">__init__()</strong> method, which is called upon creation of this object, because we only need one copy of this information for all the objects<a id="_idIndexMarker862"/> that are created from this class. The <strong class="source-inline">_index_tickers</strong> class attribute is private (signified, by convention, with a preceding underscore) in the sense that unless a user of this class knows the name of it, they won't find it easily (note that methods can also be private). This is done with the intention of protecting it (although it isn't guaranteed) and also because the user doesn't need it directly (it's for the internal workings of the class). Instead, we will provide a <strong class="bold">property</strong>, which we can access as an attribute, and a class method for getting the value mapped to a given key in that dictionary.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="bold">Class methods</strong> are<a id="_idIndexMarker863"/> methods that can be used on the class itself, without having to create an instance of the class beforehand. This contrasts with the instance methods<a id="_idIndexMarker864"/> we have seen so far. <strong class="bold">Instance methods</strong> are used with instances of a class for actions specific to that instance. We often don't need class methods, but if we have data that is shared across all instances of a class, it makes more sense to create a class method rather than an instance method. </p>
			<p>Since <strong class="source-inline">_index_tickers</strong> is private, we want to provide an easy way for users of our class to see what is available. Therefore, we will create a property for the keys of <strong class="source-inline">_index_tickers</strong>. To do so, we use the <strong class="source-inline">@property</strong> decorator. <strong class="bold">Decorators</strong> are functions that wrap around other <a id="_idIndexMarker865"/>functions, allowing for the execution of extra code before and/or after the inner function executes. This class makes heavy use of decorators: we will use some already written ones (<strong class="source-inline">@property</strong> and <strong class="source-inline">@classmethod</strong>) and write one of our own to clean up and standardize the results across the methods that gather the data (<strong class="source-inline">@label_sanitizer</strong>). To use a decorator, we place it above the function or method definition:</p>
			<p class="source-code">    <strong class="bold">@property</strong></p>
			<p class="source-code">    def available_tickers(self):</p>
			<p class="source-code">        """Indices whose tickers are supported."""</p>
			<p class="source-code">        return list(self._index_tickers.keys())</p>
			<p>Furthermore, we provide a way of getting the ticker using a class method because our tickers are stored in a class variable. Class methods, by convention, receive <strong class="source-inline">cls</strong> as their first argument while<a id="_idIndexMarker866"/> instance methods receive <strong class="source-inline">self</strong>:</p>
			<p class="source-code">    <strong class="bold">@classmethod</strong></p>
			<p class="source-code">    def get_index_ticker(<strong class="bold">cls</strong>, index):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Get the ticker of the specified index, if known.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - index: The name of the index; check </p>
			<p class="source-code">              `available_tickers` for full list which includes:</p>
			<p class="source-code">                - 'S&amp;P 500' for S&amp;P 500,</p>
			<p class="source-code">                - 'Dow Jones' for Dow Jones Industrial Average,</p>
			<p class="source-code">                - 'NASDAQ' for NASDAQ Composite Index</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            The ticker as a string if known, otherwise `None`.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        try:</p>
			<p class="source-code">            index = index.upper()</p>
			<p class="source-code">        except AttributeError:</p>
			<p class="source-code">            raise ValueError('`index` must be a string')</p>
			<p class="source-code">        return cls._index_tickers.get(index, None)</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If we want to prohibit certain actions within our code, we can check for them and <strong class="source-inline">raise</strong> errors as we see fit; this allows us to provide more informative error messages or simply accompany specific errors with some additional actions before reraising them (by using <strong class="source-inline">raise</strong> without an expression). If, instead, we wish to run certain code when something goes wrong, we use a <strong class="source-inline">try...except</strong> block: we surround the possibly troublesome code with <strong class="source-inline">try</strong> and put what to do if trouble occurs in the <strong class="source-inline">except</strong> clause.</p>
			<p>When we get to the <em class="italic">Technical analysis of financial instruments</em> section, we will need the risk-free rate of return to calculate some of the metrics. This is the rate of return of an investment that has no risk of financial loss; in practice, we use the 10-year US Treasury bill. Since this rate will depend on the date range we are analyzing, we will add this functionality to the <strong class="source-inline">StockReader</strong> class and avoid having to look it up ourselves. We will use<a id="_idIndexMarker867"/> the <strong class="source-inline">pandas_datareader</strong> package to collect this data from the Federal Reserve Bank of St. Louis (<a href="https://fred.stlouisfed.org/series/DGS10">https://fred.stlouisfed.org/series/DGS10</a>), providing the option to return the daily rates for the date range we are studying (to analyze the data itself) or just the last one (if we need a single value for a calculation):</p>
			<p class="source-code">    def get_risk_free_rate_of_return(self, last=True):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Get risk-free rate of return w/ 10-year US T-bill </p>
			<p class="source-code">        from FRED (https://fred.stlouisfed.org/series/DGS10)</p>
			<p class="source-code">        Parameter:</p>
			<p class="source-code">            - last: If `True`, return the rate on the last</p>
			<p class="source-code">              date in the date range else, return a `Series` </p>
			<p class="source-code">              object for the rate each day in the date range.</p>
			<p class="source-code">        Returns:</p>
			<p class="source-code">            A single value or a `pandas.Series` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        data = web.DataReader(</p>
			<p class="source-code">            'DGS10', 'fred', start=self.start, end=self.end</p>
			<p class="source-code">        )</p>
			<p class="source-code">        data.index.rename('date', inplace=True)</p>
			<p class="source-code">        data = data.squeeze()</p>
			<p class="source-code">        return data.asof(self.end) \</p>
			<p class="source-code">            if last and isinstance(data, pd.Series) else data</p>
			<p>The remaining method code is replaced with <strong class="source-inline">pass</strong>, which tells Python to do nothing (and reminds<a id="_idIndexMarker868"/> us to update it later) so that the code can function as it was reproduced. We will write the following methods in the next section:</p>
			<p class="source-code">    @label_sanitizer</p>
			<p class="source-code">    def get_ticker_data(self, ticker):</p>
			<p class="source-code">        pass    </p>
			<p class="source-code">    def get_index_data(self, index):</p>
			<p class="source-code">        pass</p>
			<p class="source-code">    def get_bitcoin_data(self, currency_code):</p>
			<p class="source-code">        pass</p>
			<p class="source-code">    @label_sanitizer </p>
			<p class="source-code">    def get_forex_rates(self, from_currency, to_currency,</p>
			<p class="source-code">                        **kwargs):</p>
			<p class="source-code">        pass</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Since we aren't going to be looking at foreign exchange rates, we won't cover the <strong class="source-inline">get_forex_rates()</strong> method in this chapter; however, this method provides an additional example of how to use the <strong class="source-inline">pandas_datareader</strong> package, so I encourage you to take a look at it. Note that, in order to use this method, you will need to get a free API key from AlphaVantage at <a href="https://www.alphavantage.co/support/#api-key">https://www.alphavantage.co/support/#api-key</a>.</p>
			<p>Both the <strong class="source-inline">get_ticker_data()</strong> and <strong class="source-inline">get_forex_rates()</strong> methods are decorated with <strong class="source-inline">@label_sanitizer</strong>, which aligns the data we receive from various sources to the same column<a id="_idIndexMarker869"/> names so that we don't have to clean them later. The <strong class="source-inline">@label_sanitizer</strong> decorator is defined in the <strong class="source-inline">stock_analysis/utils.py</strong> module. As we did previously, let's begin by looking at the docstring and imports of the <strong class="source-inline">utils</strong> module:</p>
			<p class="source-code">"""Utility functions for stock analysis."""</p>
			<p class="source-code">from functools import wraps</p>
			<p class="source-code">import re</p>
			<p class="source-code">import pandas as pd</p>
			<p>Next, we have the <strong class="source-inline">_sanitize_label()</strong> function, which will clean up a single label. Note that we prefix the function name with an underscore because we don't intend for the users of our package to use this directly—it is for our decorator to use:</p>
			<p class="source-code">def _sanitize_label(label):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Clean up a label by removing non-letter, non-space </p>
			<p class="source-code">    characters and putting in all lowercase with underscores</p>
			<p class="source-code">    replacing spaces.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - label: The text you want to fix.</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        The sanitized label.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    return re.sub(r'[^\w\s]', '', label)\</p>
			<p class="source-code">        .lower().replace(' ', '_')</p>
			<p>Finally, we define the <strong class="source-inline">@label_sanitizer</strong> decorator, which is a function that cleans up the column<a id="_idIndexMarker870"/> and index names in the data we get from the Internet. Without this decorator, the column names in our collected data could have unexpected characters such as asterisks or spaces in them, making them unwieldy. By using the decorator, the methods will always return a dataframe with the names cleaned, saving us a step:</p>
			<p class="source-code">def label_sanitizer(method):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Decorator around a method that returns a dataframe to</p>
			<p class="source-code">    clean up all labels in said dataframe (column names and </p>
			<p class="source-code">    index name) by using `_sanitize_label()`.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - method: The method to wrap.</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        A decorated method or function.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    @wraps(method) # keep original docstring for help()</p>
			<p class="source-code">    def method_wrapper(self, *args, **kwargs):</p>
			<p class="source-code">        df = method(self, *args, **kwargs)</p>
			<p class="source-code">        # fix the column names</p>
			<p class="source-code">        df.columns = [</p>
			<p class="source-code">            _sanitize_label(col) for col in df.columns</p>
			<p class="source-code">        ]</p>
			<p class="source-code">        # fix the index name</p>
			<p class="source-code">        df.index.rename(</p>
			<p class="source-code">            _sanitize_label(df.index.name), inplace=True</p>
			<p class="source-code">        )</p>
			<p class="source-code">        return df</p>
			<p class="source-code">    return method_wrapper</p>
			<p>Note that <a id="_idIndexMarker871"/>there is also a decorator inside the definition of the <strong class="source-inline">label_sanitizer()</strong> function. The <strong class="source-inline">@wraps</strong> decorator from the <strong class="source-inline">functools</strong> module in the standard library gives the decorated function/method the same docstring it had beforehand; this is necessary because decoration actually creates a new function/method, thus rendering <strong class="source-inline">help()</strong> pretty useless unless we intervene.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Using the <strong class="source-inline">@label_sanitizer</strong> syntax is <strong class="bold">syntactic sugar</strong>, meaning that it makes it easier to express, compared to defining the method and then writing <strong class="source-inline">method = label_sanitizer(method)</strong>. However, both are valid.</p>
			<p>Now that we understand decorators, we are ready to finish building the <strong class="source-inline">StockReader</strong> class. Note that we will be using and creating additional decorators for the other classes in the <strong class="source-inline">stock_analysis</strong> package as well, so make sure that you are comfortable with them before moving on.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Collecting historical data from Yahoo! Finance</h2>
			<p>The foundation <a id="_idIndexMarker872"/>of our data collection<a id="_idIndexMarker873"/> will be the <strong class="source-inline">get_ticker_data()</strong> method. It uses the <strong class="source-inline">pandas_datareader</strong> package to grab the data from Yahoo! Finance: </p>
			<p class="source-code">@label_sanitizer</p>
			<p class="source-code">def get_ticker_data(self, ticker):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Get historical OHLC data for given date range and ticker.</p>
			<p class="source-code">    Parameter:</p>
			<p class="source-code">        - ticker: The stock symbol to lookup as a string.</p>
			<p class="source-code">    Returns: A `pandas.DataFrame` object with the stock data.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    return web.get_data_yahoo(ticker, self.start, self.end)</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">There have been issues with <strong class="source-inline">pandas_datareader</strong> and the Yahoo! Finance API in the past, causing the <strong class="source-inline">pandas_datareader</strong> developers to deprecate support for it via the <strong class="source-inline">web.DataReader()</strong> function (<a href="https://pandas-datareader.readthedocs.io/en/latest/whatsnew.html#v0-6-0-january-24-2018">https://pandas-datareader.readthedocs.io/en/latest/whatsnew.html#v0-6-0-january-24-2018</a>); instead, we have to use their workaround: <strong class="source-inline">web.get_data_yahoo()</strong>.</p>
			<p>To collect data for a stock market index, we can use the <strong class="source-inline">get_index_data()</strong> method, which first looks up the index's ticker and then calls the <strong class="source-inline">get_ticker_data()</strong> method we just defined. Note that since the <strong class="source-inline">get_ticker_data()</strong> method <a id="_idIndexMarker874"/>is decorated with <strong class="source-inline">@label_sanitizer</strong>, the <strong class="source-inline">get_index_data()</strong> method doesn't<a id="_idIndexMarker875"/> need the <strong class="source-inline">@label_sanitizer</strong> decorator:</p>
			<p class="source-code">def get_index_data(self, index):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Get historical OHLC data from Yahoo! Finance</p>
			<p class="source-code">    for the chosen index for given date range.</p>
			<p class="source-code">    Parameter:</p>
			<p class="source-code">        - index: String representing the index you want</p>
			<p class="source-code">          data for, supported indices include:</p>
			<p class="source-code">            - 'S&amp;P 500' for S&amp;P 500,</p>
			<p class="source-code">            - 'Dow Jones' for Dow Jones Industrial Average,</p>
			<p class="source-code">            - 'NASDAQ' for NASDAQ Composite Index</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        A `pandas.DataFrame` object with the index data.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    if index not in self.available_tickers:</p>
			<p class="source-code">        raise ValueError(</p>
			<p class="source-code">            'Index not supported. Available tickers'</p>
			<p class="source-code">            f"are: {', '.join(self.available_tickers)}"</p>
			<p class="source-code">        )</p>
			<p class="source-code">    return self.get_ticker_data(self.get_index_ticker(index))</p>
			<p>Yahoo! Finance <a id="_idIndexMarker876"/>also provides data for bitcoin; however, we must pick a currency to use. The <strong class="source-inline">get_bitcoin_data()</strong> method accepts a currency code to create the symbol for the search on Yahoo! Finance (for instance, BTC-USD for bitcoin data in USD). The actual collection of the<a id="_idIndexMarker877"/> data is once again handled <a id="_idIndexMarker878"/>by the <strong class="source-inline">get_ticker_data()</strong> method:</p>
			<p class="source-code">def get_bitcoin_data(self, currency_code):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Get bitcoin historical OHLC data for given date range. </p>
			<p class="source-code">    Parameter:</p>
			<p class="source-code">        - currency_code: The currency to collect the bitcoin</p>
			<p class="source-code">          data in, e.g. USD or GBP.</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        A `pandas.DataFrame` object with the bitcoin data.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    return self\</p>
			<p class="source-code">        .get_ticker_data(f'BTC-{currency_code}')\</p>
			<p class="source-code">        .loc[self.start:self.end] # clip dates</p>
			<p>At this point, the <strong class="source-inline">StockReader</strong> class is ready for use, so let's get started in the <strong class="source-inline">financial_analysis.ipynb</strong> notebook and import the <strong class="source-inline">stock_analysis</strong> package that will be used for the rest of this chapter:</p>
			<p class="source-code">&gt;&gt;&gt; import stock_analysis</p>
			<p>Python runs the <strong class="source-inline">stock_analysis/__init__.py</strong> file when we import the <strong class="source-inline">stock_analysis</strong> package:</p>
			<p class="source-code">"""Classes for making technical stock analysis easier."""</p>
			<p class="source-code">from .stock_analyzer import StockAnalyzer, AssetGroupAnalyzer</p>
			<p class="source-code">from .stock_modeler import StockModeler</p>
			<p class="source-code">from .stock_reader import StockReader</p>
			<p class="source-code">from .stock_visualizer import \</p>
			<p class="source-code">    StockVisualizer, AssetGroupVisualizer</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The code in the <strong class="source-inline">stock_analysis/__init__.py</strong> file makes it easier for us to access the package's classes—for example, rather than having to run <strong class="source-inline">stock_analysis.stock_reader.StockReader()</strong>, we only have to run <strong class="source-inline">stock_analysis.StockReader()</strong>to create a <strong class="source-inline">StockReader</strong> object. </p>
			<p>Next, we will<a id="_idIndexMarker879"/> create<a id="_idIndexMarker880"/> an instance of the <strong class="source-inline">StockReader</strong> class by providing the start and (optionally) end dates for the data it will collect. We will work with 2019-2020 data. Note that when we run this code, Python is calling the <strong class="source-inline">StockReader.__init__()</strong> method:</p>
			<p class="source-code">&gt;&gt;&gt; reader = \</p>
			<p class="source-code">...     stock_analysis.StockReader('2019-01-01', '2020-12-31')</p>
			<p>Now, we will collect the <strong class="bold">Facebook, Apple, Amazon, Netflix, and Google</strong> (<strong class="bold">FAANG</strong>), S&amp;P 500, and<a id="_idIndexMarker881"/> bitcoin data. Since all the stocks we are working with are priced in USD, we will ask for the bitcoin data in USD. Note that we are using a generator expression and multiple assignment to get dataframes for each FAANG stock:</p>
			<p class="source-code">&gt;&gt;&gt; fb, aapl, amzn, nflx, goog = (</p>
			<p class="source-code">...     reader.get_ticker_data(ticker)</p>
			<p class="source-code">...     for ticker in ['FB', 'AAPL', 'AMZN', 'NFLX', 'GOOG']</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; sp = reader.get_index_data('S&amp;P 500')</p>
			<p class="source-code">&gt;&gt;&gt; bitcoin = reader.get_bitcoin_data('USD') </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Be sure to run <strong class="source-inline">help(stock_analysis.StockReader)</strong> or <strong class="source-inline">help(reader)</strong> to see all the<a id="_idIndexMarker882"/> methods and properties that <a id="_idIndexMarker883"/>are defined. The output clearly denotes which methods are class methods in a different section, and the properties will be listed at the bottom in the<strong class="screen-inline"> data descriptors </strong>section. This is an important step to take in order to get familiar with new code.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Exploratory data analysis</h1>
			<p>Now that we <a id="_idIndexMarker884"/>have our data, we want to get familiar with it. As we saw in <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em> and <a href="B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Plotting with Seaborn and Customization Techniques</em>, creating good visualizations requires knowledge of <strong class="source-inline">matplotlib</strong>, and—depending on the data format and the end goal for the visualization—<strong class="source-inline">seaborn</strong>. Just as we did with the <strong class="source-inline">StockReader</strong> class, we want to make it easier to visualize both individual assets and groups of assets, so rather than expecting users of our package (and, perhaps, our collaborators) to be proficient with <strong class="source-inline">matplotlib</strong> and <strong class="source-inline">seaborn</strong>, we will create wrappers around this functionality. This means that users of this package only have to be able to use the <strong class="source-inline">stock_analysis</strong> package to visualize their financial data. In addition, we are able to set a standard for how the visualizations look and avoid copying and pasting large amounts of code for each new analysis we want to conduct, which brings consistency and efficiency gains. </p>
			<p>To make all of this possible, we have the <strong class="source-inline">Visualizer</strong> classes in <strong class="source-inline">stock_analysis/stock_visualizer.py</strong>. There are three classes in this file:</p>
			<ul>
				<li><strong class="source-inline">Visualizer</strong>: This is the base class for defining the functionality of a <strong class="source-inline">Visualizer</strong> object. Most of the methods are <strong class="bold">abstract</strong>, meaning that the subclasses (children) that inherit from this superclass (parent) will need to override them and implement the code; these define what an object should do, without getting into the specifics.</li>
				<li><strong class="source-inline">StockVisualizer</strong>: This is the subclass we will use to visualize a single asset. </li>
				<li><strong class="source-inline">AssetGroupVisualizer</strong>: This is the subclass we will use to visualize multiple assets using <strong class="source-inline">groupby()</strong> operations.</li>
			</ul>
			<p>Before we discuss <a id="_idIndexMarker885"/>the code for these classes, let's go over some additional functions in the <strong class="source-inline">stock_analysis/utils.py</strong> file, which will help create these asset groups and describe them for EDA purposes. For these functions, we need to import <strong class="source-inline">pandas</strong>:</p>
			<p class="source-code">import pandas as pd</p>
			<p>The <strong class="source-inline">group_stocks()</strong> function takes in a dictionary that maps the name of the asset to the dataframe for that asset and outputs a new dataframe with all the data from the input dataframes and a new column, denoting which asset the data belongs to:</p>
			<p class="source-code">def group_stocks(mapping):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Create a new dataframe with many assets and a new column </p>
			<p class="source-code">    indicating the asset that row's data belongs to.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - mapping: A key-value mapping of the form </p>
			<p class="source-code">                   {asset_name: asset_df}</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        A new `pandas.DataFrame` object</p>
			<p class="source-code">    """</p>
			<p class="source-code">    group_df = pd.DataFrame()</p>
			<p class="source-code">    for stock, stock_data in mapping.items():</p>
			<p class="source-code">        df = stock_data.copy(deep=True)</p>
			<p class="source-code">        df['name'] = stock</p>
			<p class="source-code">        group_df = group_df.append(df, sort=True)</p>
			<p class="source-code">    group_df.index = pd.to_datetime(group_df.index)</p>
			<p class="source-code">    return group_df</p>
			<p>Since we will have<a id="_idIndexMarker886"/> many methods and functions throughout the package that will expect their dataframes in a specific format, we will build a new decorator: <strong class="source-inline">@validate_df</strong>. This decorator checks that the input to a given method or function is an object of type <strong class="source-inline">DataFrame</strong> and that it has at least the columns specified with the <strong class="source-inline">columns</strong> argument of the decorator. We will provide the columns as a <strong class="source-inline">set</strong> object. This allows us to check the set difference between the columns we must have and the columns in the input data (see <a href="B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 4</em></a>, <em class="italic">Aggregating Pandas DataFrames</em>, for a review of set operations). If the dataframe has the columns we request (at a minimum), the set difference will be empty, which means that the dataframe passes the test. This decorator will raise a <strong class="source-inline">ValueError</strong> if either of these conditions is violated. </p>
			<p>Let's take a look at how this is defined in the <strong class="source-inline">stock_analysis/utils.py</strong> file:</p>
			<p class="source-code">def validate_df(columns, instance_method=True):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Decorator that raises a `ValueError` if input isn't a</p>
			<p class="source-code">    `DataFrame` or doesn't contain the proper columns. Note </p>
			<p class="source-code">    the `DataFrame` must be the first positional argument</p>
			<p class="source-code">    passed to this method.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - columns: A set of required column names.</p>
			<p class="source-code">          For example, {'open', 'high', 'low', 'close'}.</p>
			<p class="source-code">        - instance_method: Whether or not the item being</p>
			<p class="source-code">          decorated is an instance method. Pass `False` to </p>
			<p class="source-code">          decorate static methods and functions.</p>
			<p class="source-code">    Returns:</p>
			<p class="source-code">        A decorated method or function.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    def method_wrapper(method):</p>
			<p class="source-code">        @wraps(method)</p>
			<p class="source-code">        def validate_wrapper(self, *args, **kwargs):</p>
			<p class="source-code">            # functions and static methods don't pass self so</p>
			<p class="source-code">            # self is the 1st positional argument in that case</p>
			<p class="source-code">            df = (self, *args)[0 if not instance_method else 1]</p>
			<p class="source-code">            <strong class="bold">if not isinstance(df, pd.DataFrame)</strong>:</p>
			<p class="source-code">                raise ValueError(</p>
			<p class="source-code">                    'Must pass in a pandas `DataFrame`'</p>
			<p class="source-code">                )</p>
			<p class="source-code">            <strong class="bold">if columns.difference(df.columns)</strong>:</p>
			<p class="source-code">                raise ValueError(</p>
			<p class="source-code">                    'Dataframe must contain the following'</p>
			<p class="source-code">                    f' columns: {columns}'</p>
			<p class="source-code">                )</p>
			<p class="source-code">            return method(self, *args, **kwargs)</p>
			<p class="source-code">        return validate_wrapper</p>
			<p class="source-code">    return method_wrapper</p>
			<p>Groups made with the <strong class="source-inline">group_stocks()</strong> function can be described in a single output using<a id="_idIndexMarker887"/> the <strong class="source-inline">describe_group()</strong> function. The <strong class="source-inline">group_stocks()</strong> function adds a column called <strong class="source-inline">name</strong> that <strong class="source-inline">describe_group()</strong> looks for, so we use the <strong class="source-inline">@validate_df</strong> decorator to make sure that the format is correct before trying to run the function:</p>
			<p class="source-code">@validate_df(columns={'name'}, instance_method=False)</p>
			<p class="source-code">def describe_group(data):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Run `describe()` on the asset group.</p>
			<p class="source-code">    Parameters:</p>
			<p class="source-code">        - data: Grouped data resulting from `group_stocks()`</p>
			<p class="source-code">    Returns: </p>
			<p class="source-code">        The transpose of the grouped description statistics.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    return data.groupby('name').describe().T</p>
			<p>Let's use<a id="_idIndexMarker888"/> the <strong class="source-inline">group_stocks()</strong> function to make some asset groups for our analysis:</p>
			<p class="source-code">&gt;&gt;&gt; from stock_analysis.utils import \</p>
			<p class="source-code">...     group_stocks, describe_group</p>
			<p class="source-code">&gt;&gt;&gt; faang = group_stocks({</p>
			<p class="source-code">...     'Facebook': fb, 'Apple': aapl, 'Amazon': amzn, </p>
			<p class="source-code">...     'Netflix': nflx, 'Google': goog</p>
			<p class="source-code">... })</p>
			<p class="source-code">&gt;&gt;&gt; faang_sp = group_stocks({</p>
			<p class="source-code">...     'Facebook': fb, 'Apple': aapl, 'Amazon': amzn, </p>
			<p class="source-code">...     'Netflix': nflx, 'Google': goog, 'S&amp;P 500': sp</p>
			<p class="source-code">... })</p>
			<p class="source-code">&gt;&gt;&gt; all_assets = group_stocks({</p>
			<p class="source-code">...     'Bitcoin': bitcoin, 'S&amp;P 500': sp, 'Facebook': fb, </p>
			<p class="source-code">...     'Apple': aapl, 'Amazon': amzn, 'Netflix': nflx, </p>
			<p class="source-code">...     'Google': goog</p>
			<p class="source-code">... })</p>
			<p>Using these groups, the output of <strong class="source-inline">describe()</strong> can be much more informative for comparison purposes compared to running it on each dataframe separately. The <strong class="source-inline">describe_group()</strong> function handles running <strong class="source-inline">describe()</strong> with <strong class="source-inline">groupby()</strong>. This makes it easier to look at the summary for the closing price across assets: </p>
			<p class="source-code">&gt;&gt;&gt; describe_group(all_assets).loc['close',]</p>
			<p>At a glance, we can see that we have more data for bitcoin than the rest. This is because the prices change daily, whereas for stocks, we only see the data for trading days. Another thing we can glean from this is scale; bitcoin is not only much more volatile but is much higher in value than everything else:</p>
			<div>
				<div id="_idContainer319" class="IMG---Figure">
					<img src="image/Figure_7.6_B16834.jpg" alt="Figure 7.6 – Summary statistics for the closing price per financial instrument&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Summary statistics for the closing price per financial instrument</p>
			<p>If we don't <a id="_idIndexMarker889"/>want to look at the assets individually, we can combine them into a portfolio, which we can treat as a single asset. The <strong class="source-inline">make_portfolio()</strong> function from <strong class="source-inline">stock_analysis/utils.py</strong> groups the data by date and sums all the columns, giving us the total stock price and volume traded of our portfolio:</p>
			<p class="source-code">@validate_df(columns=set(), instance_method=False)</p>
			<p class="source-code">def make_portfolio(data, date_level='date'):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Make a portfolio of assets by grouping by date and </p>
			<p class="source-code">    summing all columns.</p>
			<p class="source-code">    Note: the caller is responsible for making sure the </p>
			<p class="source-code">    dates line up across assets and handling when they don't.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    return data.groupby(level=date_level).sum()</p>
			<p>This function assumes that the assets are traded on the same frequency. Bitcoin trades every day of the week, while the stock market doesn't. For this reason, we would have to decide how to handle this difference before using this function if our portfolio was a mix of bitcoin and the stock market; consult our discussion of reindexing in <a href="B16834_03_Final_SK_ePub.xhtml#_idTextAnchor061"><em class="italic">Chapter 3</em></a>, <em class="italic">Data Wrangling with Pandas</em>, for a possible strategy. We will use this function in the exercises at the <a id="_idIndexMarker890"/>end of this chapter to build a portfolio of the FAANG stocks, which all trade on the same frequency, in order to look at the effect of after-hours trading on the FAANG stocks as a whole.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/>The Visualizer class family</h2>
			<p>As we <a id="_idIndexMarker891"/>learned from previous chapters, visualization<a id="_idIndexMarker892"/> will make our analysis much easier, so let's begin our discussion of the <strong class="source-inline">Visualizer</strong> classes in <strong class="source-inline">stock_analysis/stock_visualizer.py</strong>. First, we will define our base class, <strong class="source-inline">Visualizer</strong>. The following UML diagram tells us this is our base class because it has arrows pointing to it. These arrows originate from the subclasses (<strong class="source-inline">AssetGroupVisualizer</strong> and <strong class="source-inline">StockVisualizer</strong>):</p>
			<div>
				<div id="_idContainer320" class="IMG---Figure">
					<img src="image/Figure_7.7_B16834.jpg" alt="Figure 7.7 – Visualizer class hierarchy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Visualizer class hierarchy</p>
			<p><em class="italic">Figure 7.7</em> also tells <a id="_idIndexMarker893"/>us the methods we will <a id="_idIndexMarker894"/>be defining for each of the classes in this section. This includes methods for visualizing the effect of after-hours trading (<strong class="source-inline">after_hours_trades()</strong>) and the evolution over time of an asset's price (<strong class="source-inline">evolution_over_time()</strong>), which we will use to compare assets visually.</p>
			<p>We start the module with our docstring and imports. For our visualizations, we will need <strong class="source-inline">matplotlib</strong>, <strong class="source-inline">numpy</strong>, <strong class="source-inline">pandas</strong>, and <strong class="source-inline">seaborn</strong>, along with <strong class="source-inline">mplfinance</strong> (a <strong class="source-inline">matplotlib</strong> derivative package for financial visualizations):</p>
			<p class="source-code">"""Visualize financial instruments."""</p>
			<p class="source-code">import math</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">import mplfinance as mpf</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">import seaborn as sns</p>
			<p class="source-code">from .utils import validate_df</p>
			<p>Next, we begin by defining the <strong class="source-inline">Visualizer</strong> class. This class will hold the data it will be used <a id="_idIndexMarker895"/>to <a id="_idIndexMarker896"/>visualize, so we put this in the <strong class="source-inline">__init__()</strong> method:</p>
			<p class="source-code">class Visualizer:</p>
			<p class="source-code">    """Base visualizer class not intended for direct use."""</p>
			<p class="source-code">    @validate_df(columns={'open', 'high', 'low', 'close'})</p>
			<p class="source-code">    def __init__(self, df):</p>
			<p class="source-code">        """Store the input data as an attribute."""</p>
			<p class="source-code">        self.data = df</p>
			<p>This base class will<a id="_idIndexMarker897"/> provide us with <strong class="bold">static methods</strong> for adding reference lines to plots and also adding shaded regions, without needing to remember which <strong class="source-inline">matplotlib</strong> function we need to call for the orientation; static methods don't depend on the class for data. We define the <strong class="source-inline">add_reference_line()</strong> method for adding horizontal or vertical lines (and anything in between) using the <strong class="source-inline">@staticmethod</strong> decorator; notice we don't have <strong class="source-inline">self</strong> or <strong class="source-inline">cls</strong> as the first argument:</p>
			<p class="source-code">    <strong class="bold">@staticmethod</strong></p>
			<p class="source-code">    def add_reference_line(ax, x=None, y=None, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Static method for adding reference lines to plots.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - ax: `Axes` object to add the reference line to.</p>
			<p class="source-code">            - x, y: The x, y value to draw the line at as a </p>
			<p class="source-code">              single value or numpy array-like structure.</p>
			<p class="source-code">                - For horizontal: pass only `y`</p>
			<p class="source-code">                - For vertical: pass only `x`</p>
			<p class="source-code">                - For AB line: pass both `x` and `y`</p>
			<p class="source-code">            - kwargs: Additional keyword args. to pass down.</p>
			<p class="source-code">        Returns:</p>
			<p class="source-code">            The matplotlib `Axes` object passed in.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        try:</p>
			<p class="source-code">            # numpy array-like structures -&gt; AB line</p>
			<p class="source-code">            if x.shape and y.shape:</p>
			<p class="source-code">                ax.plot(x, y, **kwargs)</p>
			<p class="source-code">        except:</p>
			<p class="source-code">            # error triggers if x or y isn't array-like</p>
			<p class="source-code">            try:</p>
			<p class="source-code">                if not x and not y:</p>
			<p class="source-code">                    raise ValueError(</p>
			<p class="source-code">                        'You must provide an `x` or a `y`'</p>
			<p class="source-code">                    )</p>
			<p class="source-code">                elif x and not y:</p>
			<p class="source-code">                    ax.axvline(x, **kwargs) # vertical line</p>
			<p class="source-code">                elif not x and y:</p>
			<p class="source-code">                    ax.axhline(y, **kwargs) # horizontal line</p>
			<p class="source-code">            except:</p>
			<p class="source-code">                raise ValueError(</p>
			<p class="source-code">                    'If providing only `x` or `y`, '</p>
			<p class="source-code">                    'it must be a single value'</p>
			<p class="source-code">                )</p>
			<p class="source-code">        ax.legend()</p>
			<p class="source-code">        return ax</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">See the <em class="italic">Further reading</em> section for more information on class methods, static methods, and abstract methods.</p>
			<p>The <strong class="source-inline">shade_region()</strong> static <a id="_idIndexMarker898"/>method for adding<a id="_idIndexMarker899"/> shaded regions to a plot is similar to the <strong class="source-inline">add_reference_line()</strong> static method:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    def shade_region(ax, x=tuple(), y=tuple(), **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Static method for shading a region on a plot.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - ax: `Axes` object to add the shaded region to.</p>
			<p class="source-code">            - x: Tuple with the `xmin` and `xmax` bounds for </p>
			<p class="source-code">              the rectangle drawn vertically.</p>
			<p class="source-code">            - y: Tuple with the `ymin` and `ymax` bounds for </p>
			<p class="source-code">              the rectangle drawn horizontally.</p>
			<p class="source-code">            - kwargs: Additional keyword args. to pass down.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            The matplotlib `Axes` object passed in.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        if not x and not y:</p>
			<p class="source-code">            raise ValueError(</p>
			<p class="source-code">                'You must provide an x or a y min/max tuple'</p>
			<p class="source-code">            )</p>
			<p class="source-code">        elif x and y:</p>
			<p class="source-code">            raise ValueError('You can only provide x or y.')</p>
			<p class="source-code">        elif x and not y:</p>
			<p class="source-code">            ax.axvspan(*x, **kwargs) # vertical region</p>
			<p class="source-code">        elif not x and y:</p>
			<p class="source-code">            ax.axhspan(*y, **kwargs) # horizontal region</p>
			<p class="source-code">        return ax</p>
			<p>Since we want<a id="_idIndexMarker900"/> our plotting capabilities to <a id="_idIndexMarker901"/>be flexible, we are going to define a static method that will make it easy for us to plot one or many items without needing to check the number of items beforehand. This will be utilized in the classes we build using the <strong class="source-inline">Visualizer</strong> class as our base:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    def _iter_handler(items):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Static method for making a list out of an item if </p>
			<p class="source-code">        it isn't a list or tuple already.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - items: The variable to make sure it is a list.</p>
			<p class="source-code">        Returns: The input as a list or tuple.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        if not isinstance(items, (list, tuple)):</p>
			<p class="source-code">            items = [items]</p>
			<p class="source-code">        return items</p>
			<p>We want to <a id="_idIndexMarker902"/>support window functions for <a id="_idIndexMarker903"/>single assets and groups of them; however, the implementation <a id="_idIndexMarker904"/>of this will vary, so we will define an <strong class="bold">abstract method</strong> (a method without implementation) in the superclass, and the subclasses will override it to provide the implementation:</p>
			<p class="source-code">    def _window_calc(self, column, periods, name, func, </p>
			<p class="source-code">                     named_arg, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        To be implemented by subclasses. Defines how to add </p>
			<p class="source-code">        lines resulting from window calculations.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        raise NotImplementedError('To be implemented by '</p>
			<p class="source-code">                                  'subclasses.')</p>
			<p>This allows us to define functionality that depends on <strong class="source-inline">_window_calc()</strong> but doesn't need to know the <a id="_idIndexMarker905"/>exact implementation, just the result. The <strong class="source-inline">moving_average()</strong> method <a id="_idIndexMarker906"/>uses <strong class="source-inline">_window_calc()</strong> to add moving average lines to the plot:</p>
			<p class="source-code">    def moving_average(self, column, periods, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Add line(s) for the moving average of a column.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - column: The name of the column to plot.</p>
			<p class="source-code">            - periods: The rule or list of rules for </p>
			<p class="source-code">              resampling, like '20D' for 20-day periods.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return self._window_calc(</p>
			<p class="source-code">            column, periods, name='MA', named_arg='rule',</p>
			<p class="source-code">            func=pd.DataFrame.resample, **kwargs</p>
			<p class="source-code">        )</p>
			<p>In a similar fashion, we define the <strong class="source-inline">exp_smoothing()</strong> method, which will use <strong class="source-inline">_window_calc()</strong> to add exponentially smoothed moving average lines to the plot:</p>
			<p class="source-code">    def exp_smoothing(self, column, periods, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Add line(s) for the exponentially smoothed moving </p>
			<p class="source-code">        average of a column.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - column: The name of the column to plot.</p>
			<p class="source-code">            - periods: The span or list of spans for,</p>
			<p class="source-code">              smoothing like 20 for 20-day periods.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return self._window_calc(</p>
			<p class="source-code">            column, periods, name='EWMA',</p>
			<p class="source-code">            func=pd.DataFrame.ewm, named_arg='span', **kwargs</p>
			<p class="source-code">        )</p>
			<p>Note that<a id="_idIndexMarker907"/> while we have methods for<a id="_idIndexMarker908"/> adding the moving average and the exponentially smoothed moving average to a plot of a column, they both call <strong class="source-inline">_window_calc()</strong>, which isn't defined here. This is because each of the subclasses will have its own implementation of <strong class="source-inline">_window_calc()</strong>, while they will inherit the top-level method without the need to override <strong class="source-inline">moving_average()</strong> or <strong class="source-inline">exp_smoothing()</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that methods preceded with a single underscore (<strong class="source-inline">_</strong>) are Python's version of <strong class="bold">private methods</strong>—they <a id="_idIndexMarker909"/>can still be accessed outside this class, but they don't show up when we run <strong class="source-inline">help()</strong> on objects of that class. We created <strong class="source-inline">_window_calc()</strong> as a private method because users of the <strong class="source-inline">Visualizer</strong> classes will only need to call <strong class="source-inline">moving_average()</strong> and <strong class="source-inline">exp_smoothing()</strong>.</p>
			<p>Finally, we will add placeholders for the methods all subclasses will have. These are abstract methods that will be defined by each subclass individually because the implementation will be different<a id="_idIndexMarker910"/> depending on if we are visualizing a single asset or a group of them. For brevity, the<a id="_idIndexMarker911"/> following is a subset of the abstract methods defined in this class:</p>
			<p class="source-code">    def evolution_over_time(self, column, **kwargs):</p>
			<p class="source-code">        """Creates line plots."""</p>
			<p class="source-code">        raise NotImplementedError('To be implemented by '</p>
			<p class="source-code">                                  'subclasses.')</p>
			<p class="source-code">    def after_hours_trades(self):</p>
			<p class="source-code">        """Show the effect of after-hours trading."""</p>
			<p class="source-code">        raise NotImplementedError('To be implemented by '</p>
			<p class="source-code">                                  'subclasses.')</p>
			<p class="source-code">    def pairplot(self, **kwargs):</p>
			<p class="source-code">        """Create pairplots."""</p>
			<p class="source-code">        raise NotImplementedError('To be implemented by '</p>
			<p class="source-code">                                  'subclasses.')</p>
			<p>The subclasses will also define any methods that are unique to them and/or override the implementation of the <strong class="source-inline">Visualizer</strong> class, if necessary. Anything they don't override, they will inherit. By using <strong class="bold">inheritance</strong>, we can define a broad class such as <strong class="source-inline">Visualizer</strong> by what all <strong class="source-inline">Visualizers</strong> should do and then have more specific versions, such as the <strong class="source-inline">StockVisualizer</strong> class, which <a id="_idIndexMarker912"/>handles single assets only.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Visualizing a stock</h2>
			<p>Let's start <a id="_idIndexMarker913"/>the <strong class="source-inline">StockVisualizer</strong> class by inheriting from <strong class="source-inline">Visualizer</strong>; we will choose not to override the <strong class="source-inline">__init__()</strong> method because the <strong class="source-inline">StockVisualizer</strong> class will only have a dataframe as an attribute. Instead, we will provide implementations for the methods that need to be added (which are unique to this class) or overridden.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">We will only cover a subset of the functionality in the interest of brevity; however, I highly encourage you to both read through the full code base and test out the functionality in the notebook.</p>
			<p>The first <a id="_idIndexMarker914"/>method we will override is <strong class="source-inline">evolution_over_time()</strong>, which will create a line plot of a column over time:</p>
			<p class="source-code">class StockVisualizer(<strong class="bold">Visualizer</strong>):</p>
			<p class="source-code">    """Visualizer for a single stock."""</p>
			<p class="source-code">    def evolution_over_time(self, column, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the evolution over time of a column.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - column: The name of the column to visualize.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns:</p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return <strong class="bold">self.data.plot.line(y=column, **kwargs)</strong></p>
			<p>Next, we will<a id="_idIndexMarker915"/> use <strong class="source-inline">mplfinance</strong> to create a <strong class="bold">candlestick plot</strong>, which is a way to visualize the OHLC data together. Each row of the OHLC time series will be plotted as a candlestick. When the candlestick is black, the asset's closing price was smaller than the<a id="_idIndexMarker916"/> opening price (it lost value); when the candlestick is white, the asset's closing price was higher than its opening price, as illustrated in the following diagram:</p>
			<div>
				<div id="_idContainer321" class="IMG---Figure">
					<img src="image/Figure_7.8_B16834.jpg" alt="Figure 7.8 – Understanding a candlestick plot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Understanding a candlestick plot</p>
			<p>The <strong class="source-inline">candlestick()</strong> method also provides options to resample the data, show volume traded, and plot a specific date range:</p>
			<p class="source-code">    def candlestick(self, date_range=None, resample=None, </p>
			<p class="source-code">                    volume=False, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Create a candlestick plot for the OHLC data.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - date_range: String or `slice()` of dates to </p>
			<p class="source-code">              pass to `loc[]`, if `None` the plot will be </p>
			<p class="source-code">              for the full range of the data.</p>
			<p class="source-code">            - resample: The offset to use for resampling </p>
			<p class="source-code">              the data, if desired.</p>
			<p class="source-code">            - volume: Whether to show a bar plot for volume </p>
			<p class="source-code">              traded under the candlesticks</p>
			<p class="source-code">            - kwargs: Keyword args for `mplfinance.plot()`</p>
			<p class="source-code">        """</p>
			<p class="source-code">        if not date_range:</p>
			<p class="source-code">            date_range = slice(</p>
			<p class="source-code">                self.data.index.min(), self.data.index.max()</p>
			<p class="source-code">            )</p>
			<p class="source-code">        plot_data = self.data.loc[date_range]</p>
			<p class="source-code">        if resample:</p>
			<p class="source-code">            agg_dict = {</p>
			<p class="source-code">                'open': 'first', 'close': 'last',</p>
			<p class="source-code">                'high': 'max', 'low': 'min', 'volume': 'sum'</p>
			<p class="source-code">            }</p>
			<p class="source-code">            plot_data = plot_data.resample(resample).agg({</p>
			<p class="source-code">                col: agg_dict[col] for col in plot_data.columns</p>
			<p class="source-code">                if col in agg_dict</p>
			<p class="source-code">            })</p>
			<p class="source-code">        mpf.plot(</p>
			<p class="source-code">            plot_data, type='candle', volume=volume, **kwargs</p>
			<p class="source-code">        )</p>
			<p>Now, we add the <strong class="source-inline">after_hours_trades()</strong> method, which helps us visualize the effect after-hours<a id="_idIndexMarker917"/> trading had on an individual asset, with bars colored red for losses and green for gains:</p>
			<p class="source-code">    def after_hours_trades(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the effect of after-hours trading.</p>
			<p class="source-code">        Returns: A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        after_hours = self.data.open - self.data.close.shift()</p>
			<p class="source-code">        monthly_effect = after_hours.resample('1M').sum()</p>
			<p class="source-code">        fig, axes = plt.subplots(1, 2, figsize=(15, 3))</p>
			<p class="source-code">        after_hours.plot(</p>
			<p class="source-code">            ax=axes[0],</p>
			<p class="source-code">            title='After-hours trading\n'</p>
			<p class="source-code">                  '(Open Price - Prior Day\'s Close)'</p>
			<p class="source-code">        ).set_ylabel('price')</p>
			<p class="source-code">        monthly_effect.index = \</p>
			<p class="source-code">            monthly_effect.index.strftime('%Y-%b')</p>
			<p class="source-code">        monthly_effect.plot(</p>
			<p class="source-code">            ax=axes[1], kind='bar', rot=90,</p>
			<p class="source-code">            title='After-hours trading monthly effect',</p>
			<p class="source-code">            color=np.where(monthly_effect &gt;= 0, 'g', 'r')</p>
			<p class="source-code">        ).axhline(0, color='black', linewidth=1)</p>
			<p class="source-code">        axes[1].set_ylabel('price')</p>
			<p class="source-code">        return axes</p>
			<p>Next, we will add a static method that will allow us to fill the area between two curves of our <a id="_idIndexMarker918"/>choosing. The <strong class="source-inline">fill_between()</strong> method will use <strong class="source-inline">plt.fill_between()</strong> to color the area green or red depending on which curve is higher:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    def fill_between(y1, y2, title, label_higher, label_lower, </p>
			<p class="source-code">                     figsize, legend_x):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the difference between assets.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - y1, y2: Data to plot, filling y2 - y1.</p>
			<p class="source-code">            - title: The title for the plot.</p>
			<p class="source-code">            - label_higher: Label for when y2 &gt; y1.</p>
			<p class="source-code">            - label_lower: Label for when y2 &lt;= y1.</p>
			<p class="source-code">            - figsize: (width, height) for the plot dimensions.</p>
			<p class="source-code">            - legend_x: Where to place legend below the plot.</p>
			<p class="source-code">        Returns: A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        <strong class="bold">is_higher = y2 - y1 &gt; 0</strong></p>
			<p class="source-code">        fig = plt.figure(figsize=figsize)</p>
			<p class="source-code">        <strong class="bold">for exclude_mask, color, label in zip(</strong></p>
			<p class="source-code"><strong class="bold">            (is_higher, np.invert(is_higher)),</strong></p>
			<p class="source-code"><strong class="bold">            ('g', 'r'),</strong></p>
			<p class="source-code"><strong class="bold">            (label_higher, label_lower)</strong></p>
			<p class="source-code"><strong class="bold">        ):</strong></p>
			<p class="source-code"><strong class="bold">            plt.fill_between(</strong></p>
			<p class="source-code"><strong class="bold">                y2.index, y2, y1, figure=fig,</strong></p>
			<p class="source-code"><strong class="bold">                where=exclude_mask, color=color, label=label</strong></p>
			<p class="source-code"><strong class="bold">            )</strong></p>
			<p class="source-code">        plt.suptitle(title)</p>
			<p class="source-code">        plt.legend(</p>
			<p class="source-code">            bbox_to_anchor=(legend_x, -0.1),</p>
			<p class="source-code">            framealpha=0, ncol=2</p>
			<p class="source-code">        )</p>
			<p class="source-code">        for spine in ['top', 'right']:</p>
			<p class="source-code">            fig.axes[0].spines[spine].set_visible(False)</p>
			<p class="source-code">        return fig.axes[0]</p>
			<p>The <strong class="source-inline">open_to_close()</strong> method will help us visualize the daily differential between opening and closing price via the <strong class="source-inline">fill_between()</strong> static method. We will color the area green if the <a id="_idIndexMarker919"/>closing price is higher than the opening price and red if the opposite is true:</p>
			<p class="source-code">    def open_to_close(self, figsize=(10, 4)):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the daily change in price from open to close.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - figsize: (width, height) of plot</p>
			<p class="source-code">        Returns:</p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        ax = self.fill_between(</p>
			<p class="source-code">            self.data.open, self.data.close, </p>
			<p class="source-code">            figsize=figsize, legend_x=0.67,</p>
			<p class="source-code">            title='Daily price change (open to close)',</p>
			<p class="source-code">            label_higher='price rose', label_lower='price fell'</p>
			<p class="source-code">        )</p>
			<p class="source-code">        ax.set_ylabel('price')</p>
			<p class="source-code">        return ax</p>
			<p>In addition to visualizing the differential between the opening and closing price of an individual asset, we will want to compare prices between assets. The <strong class="source-inline">fill_between_other()</strong> method will help us visualize the differential between the asset we created the visualizer for and another asset, using <strong class="source-inline">fill_between()</strong> again. We will color <a id="_idIndexMarker920"/>the differential green when the visualizer's asset is higher than the other asset and red for when it is lower:</p>
			<p class="source-code">    def fill_between_other(self, other_df, figsize=(10, 4)):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize difference in closing price between assets.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - other_df: The other asset's data.</p>
			<p class="source-code">            - figsize: (width, height) for the plot.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        ax = self.fill_between(</p>
			<p class="source-code">            other_df.open, self.data.close, figsize=figsize, </p>
			<p class="source-code">            legend_x=0.7, label_higher='asset is higher', </p>
			<p class="source-code">            label_lower='asset is lower', </p>
			<p class="source-code">            title='Differential between asset price '</p>
			<p class="source-code">                  '(this - other)'</p>
			<p class="source-code">        )</p>
			<p class="source-code">        ax.set_ylabel('price')</p>
			<p class="source-code">        return ax<strong class="bold"> </strong></p>
			<p>The time has finally come to override the <strong class="source-inline">_window_calc()</strong> method, which defines how to add reference lines based on window calculations for a single asset. Note how we are able to use the <strong class="source-inline">pipe()</strong> method (introduced in <a href="B16834_04_Final_SK_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 4</em></a>, <em class="italic">Aggregating Pandas DataFrames</em>) to make our window calculation plots work with different functions, and the <strong class="source-inline">_iter_handler()</strong> method to make our loop work without having to check if we have more than one<a id="_idIndexMarker921"/> reference line to plot:</p>
			<p class="source-code">    def _window_calc(self, column, periods, name, func, </p>
			<p class="source-code">                     named_arg, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Helper method for plotting a series and adding</p>
			<p class="source-code">        reference lines using a window calculation.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - column: The name of the column to plot.</p>
			<p class="source-code">            - periods: The rule/span or list of them to pass </p>
			<p class="source-code">              to the resampling/smoothing function, like '20D'</p>
			<p class="source-code">              for 20-day periods (resampling) or 20 for a </p>
			<p class="source-code">              20-day span (smoothing)</p>
			<p class="source-code">            - name: The name of the window calculation (to </p>
			<p class="source-code">              show in the legend).</p>
			<p class="source-code">            - func: The window calculation function.</p>
			<p class="source-code">            - named_arg: The name of the argument `periods` </p>
			<p class="source-code">              is being passed as.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns:</p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        ax = self.data.plot(y=column, **kwargs)</p>
			<p class="source-code">        for period in <strong class="bold">self._iter_handler(periods)</strong>:</p>
			<p class="source-code">            self.data[column].<strong class="bold">pipe(</strong></p>
			<p class="source-code"><strong class="bold">                func, **{named_arg: period}</strong></p>
			<p class="source-code"><strong class="bold">            )</strong>.mean().plot(</p>
			<p class="source-code">                ax=ax, linestyle='--',</p>
			<p class="source-code">                label=f"""{period if isinstance(</p>
			<p class="source-code">                    period, str</p>
			<p class="source-code">                ) else str(period) + 'D'} {name}"""</p>
			<p class="source-code">            )</p>
			<p class="source-code">        plt.legend()</p>
			<p class="source-code">        return ax</p>
			<p>So far, each <a id="_idIndexMarker922"/>visualization concerned data for a single asset; however, sometimes we want to be able to visualize the relationship between assets, so we will build a wrapper around the <strong class="source-inline">jointplot()</strong> function from <strong class="source-inline">seaborn</strong>:</p>
			<p class="source-code">    def jointplot(self, other, column, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Generate a seaborn jointplot for given column in </p>
			<p class="source-code">        this asset compared to another asset.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - other: The other asset's dataframe.</p>
			<p class="source-code">            - column: Column to use for the comparison.</p>
			<p class="source-code">            - kwargs: Keyword arguments to pass down.</p>
			<p class="source-code">        Returns: A seaborn jointplot</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return sns.jointplot(</p>
			<p class="source-code">            x=self.data[column], y=other[column], **kwargs</p>
			<p class="source-code">        )</p>
			<p>Another way of viewing the relationship between assets is the correlation matrix. <strong class="source-inline">DataFrame</strong> objects have a <strong class="source-inline">corrwith()</strong> method that will calculate the correlation coefficient between each column and the same column (by name) in another dataframe. This doesn't fill the matrix that's needed for a heatmap, as we saw in previous chapters; rather, it is the diagonal. The <strong class="source-inline">correlation_heatmap()</strong> method creates a matrix for the <strong class="source-inline">sns.heatmap()</strong> function and fills in the diagonal with the correlation coefficients; then, it makes sure that only the diagonal is <a id="_idIndexMarker923"/>displayed using a mask. In addition, we will use the daily percentage change of each column when calculating the correlations to handle the difference in scale (for instance, between Apple's stock price and Amazon's stock price):</p>
			<p class="source-code">    def correlation_heatmap(self, other):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Plot the correlations between this asset and another</p>
			<p class="source-code">        one with a heatmap.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - other: The other dataframe.</p>
			<p class="source-code">        Returns: A seaborn heatmap</p>
			<p class="source-code">        """</p>
			<p class="source-code">        corrs = \</p>
			<p class="source-code">            self.data.pct_change().corrwith(other.pct_change())</p>
			<p class="source-code">        corrs = corrs[~pd.isnull(corrs)]</p>
			<p class="source-code">        size = len(corrs)</p>
			<p class="source-code">        matrix = np.zeros((size, size), float)</p>
			<p class="source-code">        for i, corr in zip(range(size), corrs):</p>
			<p class="source-code">            matrix[i][i] = corr</p>
			<p class="source-code">        # create mask to only show diagonal</p>
			<p class="source-code">        mask = np.ones_like(matrix)</p>
			<p class="source-code">        np.fill_diagonal(mask, 0)</p>
			<p class="source-code">        return sns.heatmap(</p>
			<p class="source-code">            matrix, annot=True, center=0, vmin=-1, vmax=1,</p>
			<p class="source-code">            mask=mask, xticklabels=self.data.columns, </p>
			<p class="source-code">            yticklabels=self.data.columns</p>
			<p class="source-code">        )</p>
			<p>Now that <a id="_idIndexMarker924"/>we understand some of the functionality available in the <strong class="source-inline">StockVisualizer</strong> class, we can begin our exploratory analysis. Let's create a <strong class="source-inline">StockVisualizer</strong> object to perform some EDA on the Netflix stock data:</p>
			<p class="source-code">&gt;&gt;&gt; %matplotlib inline</p>
			<p class="source-code">&gt;&gt;&gt; import matplotlib.pyplot as plt</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">netflix_viz = stock_analysis.StockVisualizer(nflx)</strong></p>
			<p>Once we initialize our <strong class="source-inline">StockVisualizer</strong> object with the Netflix dataframe, we can generate many different plot types. We won't go over examples of everything this object lets us do (I will leave that up to you to experiment with), but let's take a look at the closing price over time with some moving averages to study the trend:</p>
			<p class="source-code">&gt;&gt;&gt; ax = netflix_viz.moving_average('close', ['30D', '90D'])</p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.shade_region(</p>
			<p class="source-code">...     ax, x=('2019-10-01', '2020-07-01'), </p>
			<p class="source-code">...     color='blue', alpha=0.1</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set(title='Netflix Closing Price', ylabel='price ($)')</p>
			<p>These moving averages give us a smoothed version of the stock price curve. Notice that, in the shaded region, the 90-day moving average is acting like a ceiling for the stock price:</p>
			<div>
				<div id="_idContainer322" class="IMG---Figure">
					<img src="image/Figure_7.9_B16834.jpg" alt="Figure 7.9 – Netflix stock price with moving averages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – Netflix stock price with moving averages</p>
			<p>Traders<a id="_idIndexMarker925"/> experiment with different-period moving averages depending on the task at hand, such as anticipating upside moves (increases in stock price) and making planned exits before downside moves (decreases in stock price). Other uses include calculating automatic <strong class="bold">support</strong> and <strong class="bold">resistance</strong> levels (which we first saw in <a href="B16834_06_Final_SK_ePub.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Plotting with Seaborn and Customization Techniques</em>) by finding the portion of the moving average line that props up the data from beneath or the one that acts as a ceiling for the data, respectively. When a stock price approaches the support, the price tends to be attractive enough that people buy, thus increasing the price (moving up from the support toward the resistance). However, when the stock reaches the resistance, it tends to encourage people to sell, bringing the stock price down (moving away from the resistance and toward the support). </p>
			<p><em class="italic">Figure 7.10</em> shows an example of how support (green) and resistance (red) act as lower and upper bounds, respectively, for the stock price; once the price hits either of these bounds, it tends to bounce back in the opposite direction due to buyers/sellers of the stock taking action:</p>
			<div>
				<div id="_idContainer323" class="IMG---Figure">
					<img src="image/Figure_7.10_B16834.jpg" alt="Figure 7.10 – Example support and resistance for Netflix stock in 2018&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Example support and resistance for Netflix stock in 2018</p>
			<p>Often, the <strong class="bold">exponentially weighted moving average</strong> (<strong class="bold">EWMA</strong>) can provide a better trend<a id="_idIndexMarker926"/> since<a id="_idIndexMarker927"/> we can put additional emphasis on more recent values. Let's see how exponential smoothing looks for our data:</p>
			<p class="source-code">&gt;&gt;&gt; ax = netflix_viz.exp_smoothing('close', [30, 90]) </p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.shade_region(</p>
			<p class="source-code">...     ax, x=('2020-04-01', '2020-10-01'),</p>
			<p class="source-code">...     color='blue', alpha=0.1</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; ax.set(title='Netflix Closing Price', ylabel='price ($)')</p>
			<p>The 90-day EWMA appears to be acting as the support level in the shaded region:</p>
			<div>
				<div id="_idContainer324" class="IMG---Figure">
					<img src="image/Figure_7.11_B16834.jpg" alt="Figure 7.11 – Netflix stock price with EWMAs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Netflix stock price with EWMAs</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The notebook<a id="_idIndexMarker928"/> contains a cell for interactive visualization of the moving average and the EWMA using widgets. We can use these types of visualizations to determine the best window for the calculations. Note that using this cell may require some additional setup, but it is all noted right above the cell in the notebook.</p>
			<p>In the exercises for <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em>, we wrote code for generating a visualization that represented the effect that after-hours trading had on Facebook; the <strong class="source-inline">StockVisualizer</strong> class also has this functionality. Let's use the <strong class="source-inline">after_hours_trades()</strong> method to see how Netflix fared:</p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.after_hours_trades()</p>
			<p>Netflix had a rough third quarter in 2019 in terms of after-hours trades:</p>
			<div>
				<div id="_idContainer325" class="IMG---Figure">
					<img src="image/Figure_7.12_B16834.jpg" alt="Figure 7.12 – Visualizing the effect of after-hours trading on Netflix stock&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Visualizing the effect of after-hours trading on Netflix stock</p>
			<p>We can use candlestick plots to study the OHLC data. Let's create one for Netflix, along with a bar plot for volume traded, by using the <strong class="source-inline">candlestick()</strong> method. We will also resample <a id="_idIndexMarker929"/>the data into 2-week intervals to improve the visibility of the candlesticks:</p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.candlestick(</p>
			<p class="source-code">...     resample='2W', volume=True, xrotation=90, </p>
			<p class="source-code">...     datetime_format='%Y-%b –'</p>
			<p class="source-code">... )</p>
			<p>Remember from <em class="italic">Figure 7.8</em> that when the body of the candlestick is white, it means that the stock gained value. Note that, for the most part, the spikes in volume traded were accompanied by increases in stock value:</p>
			<div>
				<div id="_idContainer326" class="IMG---Figure">
					<img src="image/Figure_7.13_B16834.jpg" alt="Figure 7.13 – Candlestick plot with trading volume&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – Candlestick plot with trading volume</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Traders use<a id="_idIndexMarker930"/> candlestick plots to look for and analyze patterns in an asset's performance, which can be used to make trading decisions. Check out this article for an introduction to candlestick plots and some common patterns traders look for: <a href="https://www.investopedia.com/trading/candlestick-charting-what-is-it/">https://www.investopedia.com/trading/candlestick-charting-what-is-it/</a>.</p>
			<p>Before moving on, we need to reset our plot styles. The <strong class="source-inline">mplfinance</strong> package sets many of the available styling options for its plots, so let's return to the style we are familiar with for now:</p>
			<p class="source-code">&gt;&gt;&gt; import matplotlib as mpl</p>
			<p class="source-code">&gt;&gt;&gt; mpl.rcdefaults()</p>
			<p class="source-code">&gt;&gt;&gt; %matplotlib inline</p>
			<p>We have already taken a look at a stock in isolation (Facebook) in prior chapters, so let's take this in a different direction and compare Netflix to others. Let's use the <strong class="source-inline">jointplot()</strong> method to see how Netflix compares to the S&amp;P 500:</p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.jointplot(sp, 'close')</p>
			<p>If we take a look at the plot, they appear to be weakly positively correlated. With financial analysis, we can <a id="_idIndexMarker931"/>calculate a metric called <strong class="bold">beta</strong> that indicates an asset's correlation<a id="_idIndexMarker932"/> to an index, such as the S&amp;P 500. We will calculate beta in the <em class="italic">Technical analysis of financial instruments</em> section later in this chapter:</p>
			<div>
				<div id="_idContainer327" class="IMG---Figure">
					<img src="image/Figure_7.14_B16834.jpg" alt="Figure 7.14 – Comparing Netflix to the S&amp;P 500&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – Comparing Netflix to the S&amp;P 500</p>
			<p>We can use the <strong class="source-inline">correlation_heatmap()</strong> method to visualize the correlations between Netflix and Amazon as a heatmap, using the daily percentage change of each of the columns:</p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.correlation_heatmap(amzn)</p>
			<p>Netflix <a id="_idIndexMarker933"/>and Amazon are weakly positively correlated, but only on the OHLC data:</p>
			<div>
				<div id="_idContainer328" class="IMG---Figure">
					<img src="image/Figure_7.15_B16834.jpg" alt="Figure 7.15 – Correlation heatmap between Netflix and Amazon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – Correlation heatmap between Netflix and Amazon</p>
			<p>Lastly, we can use the <strong class="source-inline">fill_between_other()</strong> method to see how another asset grew (or fell) in price compared to Netflix. We will compare Netflix to Tesla here to see an example of one stock surpassing another:</p>
			<p class="source-code">&gt;&gt;&gt; tsla = reader.get_ticker_data('TSLA')</p>
			<p class="source-code">&gt;&gt;&gt; change_date = (tsla.close &gt; nflx.close).idxmax()</p>
			<p class="source-code">&gt;&gt;&gt; ax = netflix_viz.fill_between_other(tsla)</p>
			<p class="source-code">&gt;&gt;&gt; netflix_viz.add_reference_line(</p>
			<p class="source-code">...     ax, x=change_date, color='k', linestyle=':', alpha=0.5,</p>
			<p class="source-code">...     label=f'TSLA &gt; NFLX {change_date:%Y-%m-%d}'</p>
			<p class="source-code">... )</p>
			<p>Notice that the shaded region shrinks in height as it approaches the reference line—this is the difference between the values in Netflix stock and Tesla stock decreasing over time. On<a id="_idIndexMarker934"/> November 11, 2020, as Tesla overtakes Netflix, the shaded region changes in color (from green to red) and begins to increase in height as Tesla widens the gap:</p>
			<div>
				<div id="_idContainer329" class="IMG---Figure">
					<img src="image/Figure_7.16_B16834.jpg" alt="Figure 7.16 – Stock price differential between Netflix and Tesla&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Stock price differential between Netflix and Tesla</p>
			<p>Up until this point, we have discussed visualizing a single asset—in this case, Netflix—so let's move on and see how we can perform some EDA across asset groups with the <strong class="source-inline">AssetGroupVisualizer</strong> class.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Visualizing multiple assets</h2>
			<p>As we did <a id="_idIndexMarker935"/>previously, we will start by inheriting from the <strong class="source-inline">Visualizer</strong> class and writing our docstring. Note that the <strong class="source-inline">AssetGroupVisualizer</strong> class also keeps track of the column to use for <strong class="source-inline">groupby()</strong> operations, so we override the <strong class="source-inline">__init__()</strong> method; since this change was meant to be in addition to what was already there, we call the <strong class="source-inline">__init__()</strong> method of the superclass as well:</p>
			<p class="source-code">class AssetGroupVisualizer(Visualizer):</p>
			<p class="source-code">    """Visualizes groups of assets in a single dataframe."""</p>
			<p class="source-code">    <strong class="bold"># override for group visuals</strong></p>
			<p class="source-code"><strong class="bold">    def __init__(self, df, group_by='name'):</strong></p>
			<p class="source-code"><strong class="bold">        """This object keeps track of the group by column."""</strong></p>
			<p class="source-code"><strong class="bold">        super().__init__(df)</strong></p>
			<p class="source-code"><strong class="bold">        self.group_by = group_by</strong></p>
			<p>Next, we define the <strong class="source-inline">evolution_over_time()</strong> method to plot the same column for all the assets<a id="_idIndexMarker936"/> in the group in a single plot for comparison purposes. Since our data is of a different shape, we will use <strong class="source-inline">seaborn</strong> this time:</p>
			<p class="source-code">    def evolution_over_time(self, column, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the evolution over time for all assets.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - column: The name of the column to visualize.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        if 'ax' not in kwargs:</p>
			<p class="source-code">            fig, ax = plt.subplots(1, 1, figsize=(10, 4))</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            ax = kwargs.pop('ax')</p>
			<p class="source-code">        return sns.lineplot(</p>
			<p class="source-code">            x=self.data.index, y=column, hue=self.group_by,</p>
			<p class="source-code">            data=self.data, ax=ax, **kwargs</p>
			<p class="source-code">        )</p>
			<p>When using <strong class="source-inline">seaborn</strong> or only plotting a single asset, we didn't have to worry about the layout of <a id="_idIndexMarker937"/>our subplots; however, for some of the other asset group visualizations, we need a way to automatically determine a reasonable subplot layout. For this, we will add the <strong class="source-inline">_get_layout()</strong> method, which will generate the <strong class="source-inline">Figure</strong> and <strong class="source-inline">Axes</strong> objects we need for a given number of subplots (determined by the number of unique assets in the group):</p>
			<p class="source-code">    def _get_layout(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Helper method for getting an autolayout of subplots.</p>
			<p class="source-code">        Returns: `Figure` and `Axes` objects to plot with.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        subplots_needed = self.data[self.group_by].nunique()</p>
			<p class="source-code">        rows = math.ceil(subplots_needed / 2)</p>
			<p class="source-code">        fig, axes = \</p>
			<p class="source-code">            plt.subplots(rows, 2, figsize=(15, 5 * rows))</p>
			<p class="source-code">        if rows &gt; 1:</p>
			<p class="source-code">            axes = axes.flatten()</p>
			<p class="source-code">        if subplots_needed &lt; len(axes):</p>
			<p class="source-code">            # remove excess axes from autolayout</p>
			<p class="source-code">            for i in range(subplots_needed, len(axes)):</p>
			<p class="source-code">                # can't use comprehension here</p>
			<p class="source-code">                fig.delaxes(axes[i])</p>
			<p class="source-code">        return fig, axes</p>
			<p>Now, we <a id="_idIndexMarker938"/>need to define how <strong class="source-inline">_window_calc()</strong> will work with groups. We will need to use our <strong class="source-inline">_get_layout()</strong> method to build subplots for each of the assets in the group:</p>
			<p class="source-code">    def _window_calc(self, column, periods, name, func,  </p>
			<p class="source-code">                     named_arg, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Helper method for plotting a series and adding</p>
			<p class="source-code">        reference lines using a window calculation.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - column: The name of the column to plot.</p>
			<p class="source-code">            - periods: The rule/span or list of them to pass </p>
			<p class="source-code">              to the resampling/smoothing function, like '20D' </p>
			<p class="source-code">              for 20-day periods (resampling) or 20 for a </p>
			<p class="source-code">              20-day span (smoothing)</p>
			<p class="source-code">            - name: The name of the window calculation (to </p>
			<p class="source-code">              show in the legend).</p>
			<p class="source-code">            - func: The window calculation function.</p>
			<p class="source-code">            - named_arg: The name of the argument `periods` </p>
			<p class="source-code">              is being passed as.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        fig, axes = self._get_layout()</p>
			<p class="source-code">        for ax, asset_name in zip(</p>
			<p class="source-code">            axes, self.data[self.group_by].unique()</p>
			<p class="source-code">        ):</p>
			<p class="source-code">            subset = self.data.query(</p>
			<p class="source-code">                f'{self.group_by} == "{asset_name}"'</p>
			<p class="source-code">            )</p>
			<p class="source-code">            ax = subset.plot(</p>
			<p class="source-code">                y=column, ax=ax, label=asset_name, **kwargs</p>
			<p class="source-code">            )</p>
			<p class="source-code">            for period in self._iter_handler(periods):</p>
			<p class="source-code">                subset[column].pipe(</p>
			<p class="source-code">                    func, **{named_arg: period}</p>
			<p class="source-code">                ).mean().plot(</p>
			<p class="source-code">                    ax=ax, linestyle='--',</p>
			<p class="source-code">                    label=f"""{period if isinstance(</p>
			<p class="source-code">                        period, str</p>
			<p class="source-code">                    ) else str(period) + 'D'} {name}"""</p>
			<p class="source-code">                )</p>
			<p class="source-code">            ax.legend()</p>
			<p class="source-code">         plt.tight_layout()</p>
			<p class="source-code">         return ax</p>
			<p>We can override <strong class="source-inline">after_hours_trades()</strong> to<a id="_idIndexMarker939"/> visualize the effect of after-hours trading on a group of assets using subplots and iterating over the assets in the group:</p>
			<p class="source-code">    def after_hours_trades(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the effect of after-hours trading.</p>
			<p class="source-code">        Returns: A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        num_categories = self.data[self.group_by].nunique()</p>
			<p class="source-code">        fig, axes = plt.subplots(</p>
			<p class="source-code">            num_categories, 2, figsize=(15, 3 * num_categories)</p>
			<p class="source-code">        )</p>
			<p class="source-code">        for ax, (name, data) in zip(</p>
			<p class="source-code">            axes, self.data.groupby(self.group_by)</p>
			<p class="source-code">        ):</p>
			<p class="source-code">            after_hours = data.open - data.close.shift()</p>
			<p class="source-code">            monthly_effect = after_hours.resample('1M').sum()</p>
			<p class="source-code">            after_hours.plot(</p>
			<p class="source-code">                ax=ax[0], </p>
			<p class="source-code">                title=f'{name} Open Price - Prior Day\'s Close'</p>
			<p class="source-code">            ).set_ylabel('price')</p>
			<p class="source-code">            monthly_effect.index = \</p>
			<p class="source-code">                monthly_effect.index.strftime('%Y-%b')</p>
			<p class="source-code">            monthly_effect.plot(</p>
			<p class="source-code">                ax=ax[1], kind='bar', rot=90,</p>
			<p class="source-code">                color=np.where(monthly_effect &gt;= 0, 'g', 'r'),</p>
			<p class="source-code">                title=f'{name} after-hours trading '</p>
			<p class="source-code">                      'monthly effect'</p>
			<p class="source-code">            ).axhline(0, color='black', linewidth=1)</p>
			<p class="source-code">            ax[1].set_ylabel('price')</p>
			<p class="source-code">        plt.tight_layout()</p>
			<p class="source-code">        return axes</p>
			<p>With <a id="_idIndexMarker940"/>the <strong class="source-inline">StockVisualizer</strong> class, we were able to generate a joint plot between two assets' closing prices, but here we can override <strong class="source-inline">pairplot()</strong> to allow us to see the relationships between the closing prices across assets in the group:</p>
			<p class="source-code">    def pairplot(self, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Generate a seaborn pairplot for this asset group.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - kwargs: Keyword arguments to pass down.</p>
			<p class="source-code">        Returns: A seaborn pairplot</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return sns.pairplot(</p>
			<p class="source-code">            self.data.pivot_table(</p>
			<p class="source-code">                values='close', index=self.data.index, </p>
			<p class="source-code">                columns=self.group_by</p>
			<p class="source-code">            ), diag_kind='kde', **kwargs</p>
			<p class="source-code">        )</p>
			<p>Finally, we<a id="_idIndexMarker941"/> add the <strong class="source-inline">heatmap()</strong> method, which generates a heatmap of the correlations between the closing prices of all the assets in the group:</p>
			<p class="source-code">    def heatmap(self, pct_change=True, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Generate a heatmap for correlations between assets.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - pct_change: Whether to show the correlations </p>
			<p class="source-code">              of the daily percent change in price.</p>
			<p class="source-code">            - kwargs: Keyword arguments to pass down.</p>
			<p class="source-code">        Returns: A seaborn heatmap</p>
			<p class="source-code">        """</p>
			<p class="source-code">        pivot = self.data.pivot_table(</p>
			<p class="source-code">            values='close', index=self.data.index, </p>
			<p class="source-code">            columns=self.group_by</p>
			<p class="source-code">        )</p>
			<p class="source-code">        if pct_change:</p>
			<p class="source-code">            pivot = pivot.pct_change()</p>
			<p class="source-code">        return sns.heatmap(</p>
			<p class="source-code">            pivot.corr(), annot=True, center=0, </p>
			<p class="source-code">            vmin=-1, vmax=1, **kwargs</p>
			<p class="source-code">        )</p>
			<p>We can use<a id="_idIndexMarker942"/> the <strong class="source-inline">heatmap()</strong> method to see how the daily percentage change across assets compares. This will handle the difference in scale between the assets (Google and Amazon have much higher stock prices than Facebook and Apple, meaning that gains of a few dollars mean more to Facebook and Apple):</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_viz = \</p>
			<p class="source-code">...     stock_analysis.AssetGroupVisualizer(all_assets)</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_viz.heatmap()</p>
			<p>Apple-S&amp;P 500 and Facebook-Google have the strongest correlations, with bitcoin having no correlation with anything:</p>
			<div>
				<div id="_idContainer330" class="IMG---Figure">
					<img src="image/Figure_7.17_B16834.jpg" alt="Figure 7.17 – Correlations between asset prices&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.17 – Correlations between asset prices</p>
			<p>In the interest <a id="_idIndexMarker943"/>of brevity, rather than show all the methods for visualizing an asset group, which will result in large plots, I will leave that to you to view and try out in the notebook. However, let's combine these <strong class="source-inline">Visualizers</strong> to see how all of our assets evolved over time:</p>
			<p class="source-code">&gt;&gt;&gt; faang_sp_viz = \</p>
			<p class="source-code">...     stock_analysis.AssetGroupVisualizer(faang_sp)</p>
			<p class="source-code">&gt;&gt;&gt; bitcoin_viz = stock_analysis.StockVisualizer(bitcoin)</p>
			<p class="source-code">&gt;&gt;&gt; fig, axes = plt.subplots(1, 2, figsize=(15, 5))</p>
			<p class="source-code">&gt;&gt;&gt; faang_sp_viz.evolution_over_time(</p>
			<p class="source-code">...     'close', ax=axes[0], style=faang_sp_viz.group_by</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; bitcoin_viz.evolution_over_time(</p>
			<p class="source-code">...     'close', ax=axes[1], label='Bitcoin'</p>
			<p class="source-code">... )</p>
			<p>Note that bitcoin had huge gains to close out 2020 (check out the scale on the <em class="italic">y</em>-axis), and Amazon <a id="_idIndexMarker944"/>also saw a lot of growth in 2020:</p>
			<div>
				<div id="_idContainer331" class="IMG---Figure">
					<img src="image/Figure_7.18_B16834.jpg" alt="Figure 7.18 – Evolution of asset price over time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.18 – Evolution of asset price over time</p>
			<p>Now that we have a good feel for our data, we are ready to look at some metrics. Note that, while we only looked at and used a subset of the code, I encourage you to try out all the methods in the <strong class="source-inline">Visualizer</strong> classes using the notebook for this chapter; the exercises will also offer an additional occasion to use them.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Technical analysis of financial instruments</h1>
			<p>With technical <a id="_idIndexMarker945"/>analysis of assets, metrics (such as cumulative returns and volatility) are calculated to compare various assets to each other. As with the previous two sections in this chapter, we will be writing a module with classes to help us. We will need the <strong class="source-inline">StockAnalyzer</strong> class for technical analysis of a single asset and the <strong class="source-inline">AssetGroupAnalyzer</strong> class for technical analysis of a group of assets. These classes are in the <strong class="source-inline">stock_analysis/stock_analyzer.py</strong> file.</p>
			<p>As with the <a id="_idIndexMarker946"/>other modules, we will start with our docstring and imports:</p>
			<p class="source-code">"""Classes for technical analysis of assets."""</p>
			<p class="source-code">import math</p>
			<p class="source-code">from .utils import validate_df</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>The StockAnalyzer class</h2>
			<p>For <a id="_idIndexMarker947"/>analyzing <a id="_idIndexMarker948"/>individual assets, we will build the <strong class="source-inline">StockAnalyzer</strong> class, which calculates metrics for a given asset. The following UML diagram shows all the metrics that it provides:</p>
			<div>
				<div id="_idContainer332" class="IMG---Figure">
					<img src="image/Figure_7.19_B16834.jpg" alt="Figure 7.19 – Structure of the StockAnalyzer class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19 – Structure of the StockAnalyzer class</p>
			<p>A <strong class="source-inline">StockAnalyzer</strong> instance <a id="_idIndexMarker949"/>will be initialized with the data for the asset on which we want to <a id="_idIndexMarker950"/>perform a technical analysis. This means that our <strong class="source-inline">__init__()</strong> method will need to accept the data as a parameter:</p>
			<p class="source-code">class StockAnalyzer:</p>
			<p class="source-code">    """Provides metrics for technical analysis of a stock."""</p>
			<p class="source-code">    @validate_df(columns={'open', 'high', 'low', 'close'})</p>
			<p class="source-code">    def __init__(self, df):</p>
			<p class="source-code">        """Create a `StockAnalyzer` object with OHLC data"""</p>
			<p class="source-code">        self.data = df</p>
			<p>Most of the calculations for our technical analysis will rely on the closing price of the stock, so rather than needing to write <strong class="source-inline">self.data.close</strong> in all of our methods, we will create a property so that we can access it with <strong class="source-inline">self.close</strong> instead. This makes our code cleaner and easier to follow:</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def close(self):</p>
			<p class="source-code">        """Get the close column of the data."""</p>
			<p class="source-code">        return self.data.close</p>
			<p>A few <a id="_idIndexMarker951"/>calculations will also need the percent change of the <strong class="source-inline">close</strong> column, so<a id="_idIndexMarker952"/> we will make a property for easier access to that as well:</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def pct_change(self):</p>
			<p class="source-code">        """Get the percent change of the close column."""</p>
			<p class="source-code">        return self.close.pct_change()</p>
			<p>Since we will be calculating <a id="_idIndexMarker953"/>support and resistance levels using the <strong class="bold">pivot point</strong>, which is the average of the high, low, and close on the last day in the data, we will make a property for it, as well:</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def pivot_point(self):</p>
			<p class="source-code">        """Calculate the pivot point."""</p>
			<p class="source-code">        return (self.last_close + self.last_high</p>
			<p class="source-code">                + self.last_low) / 3</p>
			<p>Note that we are also using other properties—<strong class="source-inline">self.last_close</strong>, <strong class="source-inline">self.last_high</strong>, and <strong class="source-inline">self.last_low</strong>—which we define using the <strong class="source-inline">last()</strong> method on the data, before selecting the column in question and using <strong class="source-inline">iat[]</strong> to get just the price:</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def last_close(self):</p>
			<p class="source-code">        """Get the value of the last close in the data."""</p>
			<p class="source-code">        return self.data.last('1D').close.iat[0]</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def last_high(self):</p>
			<p class="source-code">        """Get the value of the last high in the data."""</p>
			<p class="source-code">        return self.data.last('1D').high.iat[0]</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def last_low(self):</p>
			<p class="source-code">        """Get the value of the last low in the data."""</p>
			<p class="source-code">        return self.data.last('1D').low.iat[0]</p>
			<p>Now, we<a id="_idIndexMarker954"/> have everything we need to calculate support and resistance. We<a id="_idIndexMarker955"/> will be calculating each at three different levels, where the first level is the closest to the closing price and the third level is the farthest. The first level will therefore be the most restrictive level, and the third will be the least restrictive. We define the <strong class="source-inline">resistance()</strong> method as follows, allowing the caller to specify the level to calculate:</p>
			<p class="source-code">    def resistance(self, level=1):</p>
			<p class="source-code">        """Calculate the resistance at the given level."""</p>
			<p class="source-code">        if level == 1:</p>
			<p class="source-code">            res = (2 * self.pivot_point) - self.last_low</p>
			<p class="source-code">        elif level == 2:</p>
			<p class="source-code">            res = self.pivot_point \</p>
			<p class="source-code">                  + (self.last_high - self.last_low)</p>
			<p class="source-code">        elif level == 3:</p>
			<p class="source-code">            res = self.last_high \</p>
			<p class="source-code">                  + 2 * (self.pivot_point - self.last_low)</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            raise ValueError('Not a valid level.')</p>
			<p class="source-code">        return res</p>
			<p>The <strong class="source-inline">support()</strong> method<a id="_idIndexMarker956"/> is <a id="_idIndexMarker957"/>defined in a similar fashion:</p>
			<p class="source-code">    def support(self, level=1):</p>
			<p class="source-code">        """Calculate the support at the given level."""</p>
			<p class="source-code">        if level == 1:</p>
			<p class="source-code">            sup = (2 * self.pivot_point) - self.last_high</p>
			<p class="source-code">        elif level == 2:</p>
			<p class="source-code">            sup = self.pivot_point \</p>
			<p class="source-code">                  - (self.last_high - self.last_low)</p>
			<p class="source-code">        elif level == 3:</p>
			<p class="source-code">            sup = self.last_low \</p>
			<p class="source-code">                  - 2 * (self.last_high - self.pivot_point)</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            raise ValueError('Not a valid level.')</p>
			<p class="source-code">        return sup</p>
			<p>Next, we will work on creating methods for analyzing asset volatility. First, we will calculate the daily standard deviation of the percent change in the closing price, for which we will need to specify the number of trading periods. In order to make sure that we can't use more trading periods than we have in the data, we will define a property with the maximum value we can use for this argument:</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def _max_periods(self):</p>
			<p class="source-code">        """Get the number of trading periods in the data."""</p>
			<p class="source-code">        return self.data.shape[0]</p>
			<p>Now that <a id="_idIndexMarker958"/>we have our maximum, we can define the <strong class="source-inline">daily_std()</strong> method, which calculates <a id="_idIndexMarker959"/>the daily standard deviation of the daily percentage change:</p>
			<p class="source-code">    def daily_std(self, periods=252):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Calculate daily standard deviation of percent change.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - periods: The number of periods to use for the</p>
			<p class="source-code">              calculation; default is 252 for the trading days </p>
			<p class="source-code">              in a year. Note if you provide a number greater  </p>
			<p class="source-code">              than the number of trading periods in the data,</p>
			<p class="source-code">              `self._max_periods` will be used instead.</p>
			<p class="source-code">        Returns: The standard deviation</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return self.pct_change\</p>
			<p class="source-code">            [<strong class="bold">min(periods, self._max_periods)</strong> * -1:].std()</p>
			<p>While <strong class="source-inline">daily_std()</strong> is useful on its own, we can take this a step further and calculate annualized volatility by multiplying the daily standard deviation by the square root of the number of trading periods in the year, which we assume to be 252:</p>
			<p class="source-code">    def annualized_volatility(self):</p>
			<p class="source-code">        """Calculate the annualized volatility."""</p>
			<p class="source-code">        return self.daily_std() * math.sqrt(252)</p>
			<p>In addition, we <a id="_idIndexMarker960"/>can<a id="_idIndexMarker961"/> look at rolling volatility by using the <strong class="source-inline">rolling()</strong> method:</p>
			<p class="source-code">    def volatility(self, periods=252):</p>
			<p class="source-code">        """Calculate the rolling volatility.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - periods: The number of periods to use for the </p>
			<p class="source-code">              calculation; default is 252 for the trading  </p>
			<p class="source-code">              days in a year. Note if you provide a number  </p>
			<p class="source-code">              greater than the number of trading periods in the</p>
			<p class="source-code">              data, `self._max_periods` will be used instead.</p>
			<p class="source-code">        Returns: A `pandas.Series` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        periods = min(periods, self._max_periods)</p>
			<p class="source-code">        return self.close.rolling(periods).std()\</p>
			<p class="source-code">               / math.sqrt(periods)</p>
			<p>We often want to compare assets, so we provide the <strong class="source-inline">corr_with()</strong> method to calculate the correlations between them using daily percentage change:</p>
			<p class="source-code">    def corr_with(self, other):</p>
			<p class="source-code">        """Calculate the correlations between dataframes.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - other: The other dataframe.</p>
			<p class="source-code">        Returns: A `pandas.Series` object</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return \</p>
			<p class="source-code">            self.data.pct_change().corrwith(other.pct_change())</p>
			<p>Next, we<a id="_idIndexMarker962"/> define<a id="_idIndexMarker963"/> some metrics for comparing the level of dispersion of assets. In <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>, we discussed the coefficient of variation (the <strong class="source-inline">cv()</strong> method) and the quantile coefficient of dispersion (the <strong class="source-inline">qcd()</strong> method), which we can use to achieve this, both of which we will add here:</p>
			<p class="source-code">    def cv(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Calculate the coefficient of variation for the asset.</p>
			<p class="source-code">        The lower this is, the better the risk/return tradeoff.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return self.close.std() / self.close.mean()</p>
			<p class="source-code">    def qcd(self):</p>
			<p class="source-code">        """Calculate the quantile coefficient of dispersion."""</p>
			<p class="source-code">        q1, q3 = self.close.quantile([0.25, 0.75])</p>
			<p class="source-code">        return (q3 - q1) / (q3 + q1) </p>
			<p>In addition, we want a way to quantify the volatility of an asset compared to an index, such as the S&amp;P 500, for which we calculate <strong class="bold">beta</strong>—the ratio of the covariance of the asset's return <a id="_idIndexMarker964"/>and<a id="_idIndexMarker965"/> the index's return to the variance of the asset's return. We add the <strong class="source-inline">beta()</strong> method, which allows the user to specify the index to use as a benchmark:</p>
			<p class="source-code">    def beta(self, index):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Calculate the beta of the asset.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - index: The data for the index to compare to.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            Beta, a float.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        index_change = index.close.pct_change()</p>
			<p class="source-code">        beta = self.pct_change.cov(index_change)\</p>
			<p class="source-code">               / index_change.var()</p>
			<p class="source-code">        return beta</p>
			<p>Next, we define a method for calculating the cumulative returns of an asset as a series. This is defined as the cumulative product of one plus the percent change in closing price:</p>
			<p class="source-code">    def cumulative_returns(self):</p>
			<p class="source-code">        """Calculate cumulative returns for plotting."""</p>
			<p class="source-code">        return (1 + self.pct_change).cumprod()</p>
			<p>The next few metrics we want to support require calculating the return of the portfolio. To make things simpler, we will assume that there is no distribution per share so that the return of the<a id="_idIndexMarker966"/> portfolio is the percent change from the starting price to the ending price over the time<a id="_idIndexMarker967"/> period covered by the data. We will define this as a static method since we will need to calculate this for an index, and not just the data stored in <strong class="source-inline">self.data</strong>:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    def portfolio_return(df):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Calculate return assuming no distribution per share.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - df: The asset's dataframe.</p>
			<p class="source-code">        Returns: The return, as a float.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        start, end = df.close[0], df.close[-1]</p>
			<p class="source-code">        return (end - start) / start</p>
			<p>While beta allows us to <a id="_idIndexMarker968"/>compare an asset's volatility to an index, <strong class="bold">alpha</strong> allows us to compare the returns of the asset to those of an index. To do so, we also need the risk-free rate of return, which is the rate of return of an investment that has no risk of financial loss; in practice, we use US Treasury bills for this. Calculating alpha requires<a id="_idIndexMarker969"/> calculating the <a id="_idIndexMarker970"/>portfolio return of the index and the asset, along with beta:</p>
			<p class="source-code">    def alpha(self, index, r_f):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Calculates the asset's alpha.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - index: The index to compare to.</p>
			<p class="source-code">            - r_f: The risk-free rate of return.</p>
			<p class="source-code">        Returns: Alpha, as a float.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        r_f /= 100</p>
			<p class="source-code">        r_m = self.portfolio_return(index)</p>
			<p class="source-code">        beta = self.beta(index)</p>
			<p class="source-code">        r = self.portfolio_return(self.data)</p>
			<p class="source-code">        alpha = r - r_f - beta * (r_m - r_f)</p>
			<p class="source-code">        return alpha</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="source-inline">r_f /= 100</strong> in the previous code snippet divides <strong class="source-inline">r_f</strong> by <strong class="source-inline">100</strong> before storing the result back in <strong class="source-inline">r_f</strong>. It's shorthand for <strong class="source-inline">r_f = r_f / 100</strong>. Python also has these operators for other arithmetic functions—for example, <strong class="source-inline">+=</strong>, <strong class="source-inline">-=</strong>, <strong class="source-inline">*=</strong>, and <strong class="source-inline">%=</strong>.</p>
			<p>We also want to add <a id="_idIndexMarker971"/>methods <a id="_idIndexMarker972"/>that will tell us whether the asset is in a <strong class="bold">bear market</strong> or a <strong class="bold">bull market</strong>, meaning that it had a decline or increase <a id="_idIndexMarker973"/>in stock price of 20% or more in<a id="_idIndexMarker974"/> the last 2 months, respectively:</p>
			<p class="source-code">    def is_bear_market(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Determine if a stock is in a bear market, meaning its</p>
			<p class="source-code">        return in the last 2 months is a decline of 20% or more</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return \</p>
			<p class="source-code">            self.portfolio_return(self.data.last('2M')) &lt;= -.2</p>
			<p class="source-code">    def is_bull_market(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Determine if a stock is in a bull market, meaning its</p>
			<p class="source-code">        return in the last 2 months is an increase of &gt;= 20%.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return \</p>
			<p class="source-code">            self.portfolio_return(self.data.last('2M')) &gt;= .2</p>
			<p>Lastly, we will add a<a id="_idIndexMarker975"/> method for calculating the <strong class="bold">Sharpe ratio</strong>, which tells us the return we receive in excess of the risk-free rate of return for the volatility we take on with the investment:</p>
			<p class="source-code">    def sharpe_ratio(self, r_f):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Calculates the asset's Sharpe ratio.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - r_f: The risk-free rate of return.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            The Sharpe ratio, as a float.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return (</p>
			<p class="source-code">            self.cumulative_returns().last('1D').iat[0] - r_f</p>
			<p class="source-code">        ) / self.cumulative_returns().std()</p>
			<p>Take some time <a id="_idIndexMarker976"/>to digest the code in this module as we are continuing to build upon what we have<a id="_idIndexMarker977"/> discussed. We won't be using all of these metrics for our technical analysis, but I encourage you to try them out in the notebook for this chapter.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>The AssetGroupAnalyzer class</h2>
			<p>All the calculations <a id="_idIndexMarker978"/>we will work with in this section are defined on <a id="_idIndexMarker979"/>the <strong class="source-inline">StockAnalyzer</strong> class; however, rather than having to run these for each of the assets we want to compare, we will also create the <strong class="source-inline">AssetGroupAnalyzer</strong> class (in the same module) that's capable of providing these metrics for a group of assets.</p>
			<p>The <strong class="source-inline">StockAnalyzer</strong> and <strong class="source-inline">AssetGroupAnalyzer</strong> classes will share much of their functionality, which makes a strong argument for designing them with inheritance; however, sometimes—as in this case—composition can make more sense. When objects contain instances of other classes, it is referred to as <strong class="bold">composition</strong>. This design decision leaves us with the following very simple UML diagram for the <strong class="source-inline">AssetGroupAnalyzer</strong> class:</p>
			<div>
				<div id="_idContainer333" class="IMG---Figure">
					<img src="image/Figure_7.20_B16834.jpg" alt="Figure 7.20 – Structure of the AssetGroupAnalyzer class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20 – Structure of the AssetGroupAnalyzer class</p>
			<p>We create<a id="_idIndexMarker980"/> an <strong class="source-inline">AssetGroupAnalyzer</strong> instance by providing the dataframe for the assets and the name of the grouping column (if not <strong class="source-inline">name</strong>). Upon initialization, the <strong class="source-inline">_composition_handler()</strong> method is called to create a dictionary of <strong class="source-inline">StockAnalyzer</strong> objects (one for each asset):</p>
			<p class="source-code">class AssetGroupAnalyzer:</p>
			<p class="source-code">    """Analyzes many assets in a dataframe."""</p>
			<p class="source-code">    @validate_df(columns={'open', 'high', 'low', 'close'})</p>
			<p class="source-code">    def __init__(self, df, group_by='name'):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Create an `AssetGroupAnalyzer` object with a </p>
			<p class="source-code">        dataframe of OHLC data and column to group by.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        <strong class="bold">self.data = df </strong></p>
			<p class="source-code"><strong class="bold">        if group_by not in self.data.columns:</strong></p>
			<p class="source-code"><strong class="bold">            raise ValueError(</strong></p>
			<p class="source-code"><strong class="bold">                f'`group_by` column "{group_by}" not in df.'</strong></p>
			<p class="source-code"><strong class="bold">            ) </strong></p>
			<p class="source-code"><strong class="bold">        self.group_by = group_by</strong></p>
			<p class="source-code"><strong class="bold">        self.analyzers = self._composition_handler()</strong></p>
			<p class="source-code">    def _composition_handler(self):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Create a dictionary mapping each group to its analyzer,</p>
			<p class="source-code">        taking advantage of composition instead of inheritance.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        <strong class="bold">return {</strong></p>
			<p class="source-code"><strong class="bold">            group: StockAnalyzer(data)</strong></p>
			<p class="source-code"><strong class="bold">            for group, data in self.data.groupby(self.group_by)</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p>The <strong class="source-inline">AssetGroupAnalyzer</strong> class <a id="_idIndexMarker981"/>has only one public<a id="_idIndexMarker982"/> method, <strong class="source-inline">analyze()</strong>—all the actual calculations are delegated to the <strong class="source-inline">StockAnalyzer</strong> objects stored in the <strong class="source-inline">analyzers</strong> attribute:</p>
			<p class="source-code">    def analyze(self, func_name, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Run a `StockAnalyzer` method on all assets.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - func_name: The name of the method to run.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A dictionary mapping each asset to the result </p>
			<p class="source-code">            of the calculation of that function.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        if not hasattr(StockAnalyzer, func_name):</p>
			<p class="source-code">            raise ValueError(</p>
			<p class="source-code">                f'StockAnalyzer has no "{func_name}" method.'</p>
			<p class="source-code">            )</p>
			<p class="source-code">        if not kwargs:</p>
			<p class="source-code">            kwargs = {}</p>
			<p class="source-code">        <strong class="bold">return {</strong></p>
			<p class="source-code"><strong class="bold">            group: getattr(analyzer, func_name)(**kwargs)</strong></p>
			<p class="source-code"><strong class="bold">            for group, analyzer in self.analyzers.items()</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p>With inheritance, in <a id="_idIndexMarker983"/>this case, all the methods would have to<a id="_idIndexMarker984"/> be overridden because they can't handle the <strong class="source-inline">groupby()</strong> operation. Conversely, with composition, all that's necessary is to create <strong class="source-inline">StockAnalyzer</strong> objects for each asset and use dictionary comprehensions for the calculations. Another neat thing is that, by using <strong class="source-inline">getattr()</strong>, there is no need to mirror the methods in the <strong class="source-inline">AssetGroupAnalyzer</strong> class because <strong class="source-inline">analyze()</strong> can grab the method by name using the <strong class="source-inline">StockAnalyzer</strong> objects.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Comparing assets</h2>
			<p>Let's use <a id="_idIndexMarker985"/>the <strong class="source-inline">AssetGroupAnalyzer</strong> class to compare all the assets we have collected data for. As with prior sections, we won't use all the methods in the <strong class="source-inline">StockAnalyzer</strong> class here, so be sure to try them out on your own:</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_analyzer = \</p>
			<p class="source-code">...     stock_analysis.<strong class="bold">AssetGroupAnalyzer</strong>(all_assets)</p>
			<p>Remember from <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>, that the <strong class="bold">coefficient of variation</strong> (<strong class="bold">CV</strong>) is the <a id="_idIndexMarker986"/>ratio of the standard deviation to the mean; this helps us compare the variation of asset closing prices, even though their means are of different magnitudes (for instance, Amazon and Apple). The CV can also be used to compare the volatility to the expected return of an investment and quantify the risk-return trade-off. Let's use the CV to see which asset's closing price is the most widely dispersed:</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_analyzer.analyze('cv')</p>
			<p class="source-code">{'Amazon': 0.2658012522278963,</p>
			<p class="source-code"> 'Apple': 0.36991905161737615,</p>
			<p class="source-code"> <strong class="bold">'Bitcoin': 0.43597652683008137</strong>,</p>
			<p class="source-code"> 'Facebook': 0.19056336194852783,</p>
			<p class="source-code"> 'Google': 0.15038618497328074,</p>
			<p class="source-code"> 'Netflix': 0.20344854330432688,</p>
			<p class="source-code"> 'S&amp;P 500': 0.09536374658108937}</p>
			<p>It's probably not a surprise that bitcoin has the widest spread. Rather than use the closing price, percent change daily can be used to calculate the annualized volatility. This involves calculating the standard deviations of percent change over the last year and multiplying<a id="_idIndexMarker987"/> it by the square root of the number of trading days in the year (the code assumes 252). By using percent change, large changes in price (relative to the asset's price) will be penalized more severely. Using annualized volatility, Facebook looks much more volatile compared to when we used the CV (although still not the most volatile):</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_analyzer.analyze('annualized_volatility')</p>
			<p class="source-code">{'Amazon': 0.3851099077041784,</p>
			<p class="source-code"> 'Apple': 0.4670809643500882,</p>
			<p class="source-code"> 'Bitcoin': 0.4635140114227397,</p>
			<p class="source-code"> <strong class="bold">'Facebook': 0.45943066572169544,</strong></p>
			<p class="source-code"> 'Google': 0.3833720603377728,</p>
			<p class="source-code"> 'Netflix': 0.4626772090887299,</p>
			<p class="source-code"> 'S&amp;P 500': 0.34491195196047003}</p>
			<p>Given that all the assets have gained value toward the end of our dataset, let's check if any of them have entered a <strong class="bold">bull market</strong>, meaning that the asset's return in the last 2 months is a 20% or greater gain:</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_analyzer.analyze('is_bull_market')</p>
			<p class="source-code">{'Amazon': False,</p>
			<p class="source-code"> <strong class="bold">'Apple': True,</strong></p>
			<p class="source-code"><strong class="bold"> 'Bitcoin': True</strong>,</p>
			<p class="source-code"> 'Facebook': False,</p>
			<p class="source-code"> 'Google': False,</p>
			<p class="source-code"> 'Netflix': False,</p>
			<p class="source-code"> 'S&amp;P 500': False}</p>
			<p>It looks like Apple and bitcoin had quite a November and December in 2020. The other assets appear to not have fared as well; however, none of them are in a bear market (we can confirm this by passing <strong class="source-inline">'is_bear_market'</strong> to <strong class="source-inline">analyze()</strong>). Yet another way to analyze volatility is to compare the assets to an index by calculating <strong class="bold">beta</strong>. Positive values<a id="_idIndexMarker988"/> greater than 1 indicate volatility higher than the index, while negative values less than -1 indicate inverse relationships to the index:</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_analyzer.analyze('beta', index=sp)</p>
			<p class="source-code">{'Amazon': 0.7563691182389207,</p>
			<p class="source-code"> <strong class="bold">'Apple': 1.173273501105916,</strong></p>
			<p class="source-code"> <strong class="bold">'Bitcoin': 0.3716024282483362,</strong></p>
			<p class="source-code"> 'Facebook': 1.024592821854751,</p>
			<p class="source-code"> 'Google': 0.98620762504024,</p>
			<p class="source-code"> 'Netflix': 0.7408228073823271,</p>
			<p class="source-code"> 'S&amp;P 500': 1.0000000000000002}</p>
			<p>Using the betas from the previous result, we can see that Apple is the most volatile compared to the S&amp;P 500, meaning that if this was our portfolio (leaving out bitcoin for the moment), adding Apple would have increased the portfolio risk. However, we know that bitcoin is not correlated to the S&amp;P 500 (see the correlation heatmap in <em class="italic">Figure 7.17</em>), so this low beta is misleading.</p>
			<p>The last metric we will take a look at is <strong class="bold">alpha</strong>, which is used to compare the return of an investment to the market. Calculating alpha requires that we pass in the risk-free rate of return (<strong class="source-inline">r_f</strong>); we typically use the return of a US Treasury bill for this number. Rates can be looked up at <a href="https://www.treasury.gov/resource-center/data-chart-center/interest-rates/pages/TextView.aspx?data=yield">https://www.treasury.gov/resource-center/data-chart-center/interest-rates/pages/TextView.aspx?data=yield</a>; alternatively, we can use our <strong class="source-inline">StockReader</strong> object (<strong class="source-inline">reader</strong>) to collect this for us. Let's compare the alphas for the assets using the S&amp;P 500 as our index:</p>
			<p class="source-code">&gt;&gt;&gt; r_f = reader.get_risk_free_rate_of_return() # 0.93</p>
			<p class="source-code">&gt;&gt;&gt; all_assets_analyzer.analyze('alpha', index=sp, r_f=r_f)</p>
			<p class="source-code">{'Amazon': 0.7383391908270172,</p>
			<p class="source-code"> 'Apple': 1.7801122522388666,</p>
			<p class="source-code"> 'Bitcoin': 6.355297988074054,</p>
			<p class="source-code"> 'Facebook': 0.5048625273190841,</p>
			<p class="source-code"> 'Google': 0.18537197824248092,</p>
			<p class="source-code"> 'Netflix': 0.6500392764754642,</p>
			<p class="source-code"> 'S&amp;P 500': -1.1102230246251565e-16}</p>
			<p>Everything beat the S&amp;P 500, which essentially being a portfolio of 500 stocks has lower risk and lower <a id="_idIndexMarker989"/>returns<a id="_idIndexMarker990"/> due to <strong class="bold">diversification</strong>. This brings us to cumulative returns, which shows the return for each dollar we invested. To make this plot a little easier to interpret in the black and white text, we will create a custom <strong class="source-inline">Cycler</strong> object (<a href="https://matplotlib.org/cycler/">https://matplotlib.org/cycler/</a>) that varies the color and line styles:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">from cycler import cycler</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">bw_viz_cycler = (</strong></p>
			<p class="source-code">...     <strong class="bold">cycler(color=[plt.get_cmap('tab10')(x/10)</strong></p>
			<p class="source-code">...                   <strong class="bold">for x in range(10)])</strong></p>
			<p class="source-code">...     <strong class="bold">+ cycler(linestyle=['dashed', 'solid', 'dashdot',</strong></p>
			<p class="source-code">...                         <strong class="bold">'dotted', 'solid'] * 2))</strong></p>
			<p class="source-code">&gt;&gt;&gt; fig, axes = plt.subplots(1, 2, figsize=(15, 5))</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">axes[0].set_prop_cycle(bw_viz_cycler)</strong></p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">cumulative_returns = \</strong></p>
			<p class="source-code">...     <strong class="bold">all_assets_analyzer.analyze('cumulative_returns')</strong></p>
			<p class="source-code">&gt;&gt;&gt; for name, data in cumulative_returns.items():</p>
			<p class="source-code">...     data.plot(</p>
			<p class="source-code">...         ax=axes[1] if name == 'Bitcoin' else axes[0], </p>
			<p class="source-code">...         label=name, legend=True</p>
			<p class="source-code">...     )</p>
			<p class="source-code">&gt;&gt;&gt; fig.suptitle('Cumulative Returns')</p>
			<p>Despite<a id="_idIndexMarker991"/> the struggles in early 2020, all of the assets gained value. Notice that the bitcoin subplot's <em class="italic">y</em>-axis goes from 0 to 7 (right subplot), while the stock market subplot (left) covers half of that range:</p>
			<div>
				<div id="_idContainer334" class="IMG---Figure">
					<img src="image/Figure_7.21_B16834.jpg" alt="Figure 7.21 – Cumulative returns for all assets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – Cumulative returns for all assets</p>
			<p>Now that we have a good understanding of how to analyze financial instruments, let's try our hand at forecasting future performance.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Modeling performance using historical data</h1>
			<p>The goal of this section is to give us a taste of<a id="_idIndexMarker992"/> how to build some models; as such, the following examples are not meant to be the best possible model, but rather <a id="_idIndexMarker993"/>a simple and relatively quick implementation for learning purposes. Once again, the <strong class="source-inline">stock_analysis</strong> package has a class for this section's task: <strong class="source-inline">StockModeler</strong>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">To fully understand the statistical elements of this section and modeling in general, we need a solid understanding of statistics; however, the purpose of this discussion is to show how modeling techniques can be applied to financial data without dwelling on the underlying mathematics.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>The StockModeler class</h2>
			<p>The <strong class="source-inline">StockModeler</strong> class <a id="_idIndexMarker994"/>will <a id="_idIndexMarker995"/>make it easier for us to build and evaluate some simple financial models without needing to interact directly with the <strong class="source-inline">statsmodels</strong> package. In addition, we will reduce the number of steps that are needed to generate a model with the methods we create. The following UML diagram shows that this is a rather simple class. Notice that we have no attributes because <strong class="source-inline">StockModeler</strong> is a <strong class="bold">static class</strong> (meaning that we don't instantiate it):</p>
			<div>
				<div id="_idContainer335" class="IMG---Figure">
					<img src="image/Figure_7.22_B16834.jpg" alt="Figure 7.22 – Structure of the StockModeler class&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Structure of the StockModeler class</p>
			<p>The <strong class="source-inline">StockModeler</strong> class <a id="_idIndexMarker996"/>is defined in <strong class="source-inline">stock_analysis/stock_modeler.py</strong> and has methods for both building models <a id="_idIndexMarker997"/>and doing some preliminary analysis of their performance. As usual, we start the module with our docstring and imports:</p>
			<p class="source-code">"""Simple time series modeling for stocks."""</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">import pandas as pd</p>
			<p class="source-code">from statsmodels.tsa.arima.model import ARIMA</p>
			<p class="source-code">from statsmodels.tsa.seasonal import seasonal_decompose</p>
			<p class="source-code">import statsmodels.api as sm</p>
			<p class="source-code">from .utils import validate_df</p>
			<p>Next, we will start the <strong class="source-inline">StockModeler</strong> class and raise an error if someone tries to instantiate it:</p>
			<p class="source-code">class StockModeler:</p>
			<p class="source-code">    """Static methods for modeling stocks."""</p>
			<p class="source-code">    def __init__(self):</p>
			<p class="source-code">        raise NotImplementedError(</p>
			<p class="source-code">            "This class must be used statically: " </p>
			<p class="source-code">            "don't instantiate it."</p>
			<p class="source-code">        )</p>
			<p>One of the<a id="_idIndexMarker998"/> tasks we want this class to support is time series decomposition, which <a id="_idIndexMarker999"/> we discussed back in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>. We imported the <strong class="source-inline">seasonal_decompose()</strong> function from <strong class="source-inline">statsmodels</strong>, so we just have to call it on the closing price in our <strong class="source-inline">decompose()</strong> method:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    @validate_df(columns={'close'}, instance_method=False)</p>
			<p class="source-code">    def decompose(df, period, model='additive'):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Decompose the closing price of the stock into </p>
			<p class="source-code">        trend, seasonal, and remainder components.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - df: The dataframe containing the stock closing</p>
			<p class="source-code">              price as `close` and with a time index.</p>
			<p class="source-code">            - period: The number of periods in the frequency.</p>
			<p class="source-code">            - model: How to compute the decomposition</p>
			<p class="source-code">              ('additive' or 'multiplicative')</p>
			<p class="source-code">        Returns:</p>
			<p class="source-code">            A `statsmodels` decomposition object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        return seasonal_decompose(</p>
			<p class="source-code">            df.close, model=model, period=period</p>
			<p class="source-code">        )</p>
			<p>Notice that<a id="_idIndexMarker1000"/> we have two decorators for the <strong class="source-inline">decompose()</strong> method. The topmost decorator is <a id="_idIndexMarker1001"/>applied on the result of the ones below it. In this example, we have the following:</p>
			<p class="source-code">staticmethod(</p>
			<p class="source-code">    validate_df(</p>
			<p class="source-code">        decompose, columns={'close'}, instance_method=False</p>
			<p class="source-code">    )</p>
			<p class="source-code">)</p>
			<p>In addition, we want to support creating ARIMA models, which we also discussed in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>. ARIMA models use the <em class="italic">ARIMA(p, d, q)</em> notation, where <em class="italic">p</em> is the number of time lags (or order) of the AR model, <em class="italic">d</em> is the number of past values that were subtracted from the data (the I model), and <em class="italic">q</em> is the number of periods used in the MA model. So, an <em class="italic">ARIMA(1, 1, 1)</em> is a model with one time lag for the autoregressive portion, data differenced once, and a 1-period moving average. If we have any zeros for the orders, we can eliminate those—for example, <em class="italic">ARIMA(1, 0, 1)</em> is equivalent to <em class="italic">ARMA(1, 1)</em>, and <em class="italic">ARIMA(0, 0, 3)</em> is equivalent to <em class="italic">MA(3)</em>. A seasonal ARIMA model is written as <em class="italic">ARIMA(p, d, q)(P, D, Q)</em><span class="subscript">m</span> where <em class="italic">m</em> is the number of periods in the seasonal model and <em class="italic">P</em>, <em class="italic">D</em>, and <em class="italic">Q</em> are the orders for the seasonal ARIMA model. The <strong class="source-inline">StockModeler.arima()</strong> method doesn't support the seasonal components (for simplicity) and takes <em class="italic">p</em>, <em class="italic">d</em>, and <em class="italic">q</em> as parameters, but to avoid confusion we will name them after the ARIMA feature they represent—for example, <strong class="source-inline">ar</strong> for autoregressive (<em class="italic">p</em>). In addition, we<a id="_idIndexMarker1002"/> are going to have our static method provide the option of fitting the model before<a id="_idIndexMarker1003"/> returning it:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    @validate_df(columns={'close'}, instance_method=False)</p>
			<p class="source-code">    def arima(df, *, ar, i, ma, fit=True, freq='B'):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Create an ARIMA object for modeling time series.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - df: The dataframe containing the stock closing</p>
			<p class="source-code">              price as `close` and with a time index.</p>
			<p class="source-code">            - ar: The autoregressive order (p).</p>
			<p class="source-code">            - i: The differenced order (q).</p>
			<p class="source-code">            - ma: The moving average order (d).</p>
			<p class="source-code">            - fit: Whether to return the fitted model</p>
			<p class="source-code">            - freq: Frequency of the time series</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A `statsmodels` ARIMA object which you can use </p>
			<p class="source-code">            to fit and predict.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        arima_model = ARIMA(</p>
			<p class="source-code">            df.close.asfreq(freq).fillna(method='ffill'), </p>
			<p class="source-code">            order=(ar, i, ma)</p>
			<p class="source-code">        )</p>
			<p class="source-code">        return arima_model.fit() if fit else arima_model</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note that the method signature (<strong class="source-inline">df, *, ar, i, ma, ...</strong>) has an asterisk (<strong class="source-inline">*</strong>) in it. This forces the parameters listed after it to be supplied as keyword arguments when calling the method. It's a nice way to make sure that whoever uses this is explicit about what they want.</p>
			<p>To go along with this, we want a way to evaluate the ARIMA model's predictions, so we will add the <strong class="source-inline">arima_predictions()</strong> static method. We will also provide the option of <a id="_idIndexMarker1004"/>getting <a id="_idIndexMarker1005"/>back the predictions as a <strong class="source-inline">Series</strong> object or as a plot:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    @validate_df(columns={'close'}, instance_method=False)</p>
			<p class="source-code">    def arima_predictions(df, arima_model_fitted, start, end,       </p>
			<p class="source-code">                          plot=True, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Get ARIMA predictions as a `Series` object or plot.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - df: The dataframe for the stock.</p>
			<p class="source-code">            - arima_model_fitted: The fitted ARIMA model.</p>
			<p class="source-code">            - start: The start date for the predictions.</p>
			<p class="source-code">            - end: The end date for the predictions.</p>
			<p class="source-code">            - plot: Whether to plot the result, default is</p>
			<p class="source-code">              `True` meaning the plot is returned instead of</p>
			<p class="source-code">              the `Series` object containing the predictions.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A matplotlib `Axes` object or predictions </p>
			<p class="source-code">            depending on the value of the `plot` argument.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        predictions = \</p>
			<p class="source-code">            arima_model_fitted.predict(start=start, end=end)</p>
			<p class="source-code">        if plot:</p>
			<p class="source-code">            ax = df.close.plot(**kwargs)</p>
			<p class="source-code">            predictions.plot(</p>
			<p class="source-code">                ax=ax, style='r:', label='arima predictions'</p>
			<p class="source-code">            )</p>
			<p class="source-code">            ax.legend()</p>
			<p class="source-code">        return ax if plot else predictions</p>
			<p>Similar to<a id="_idIndexMarker1006"/> what <a id="_idIndexMarker1007"/>we built for ARIMA models, we will also provide the <strong class="source-inline">regression()</strong> method for building a linear regression model of the closing price with a lag of 1. For this, we will once again use <strong class="source-inline">statsmodels</strong> (in <a href="B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Getting Started with Machine Learning in Python</em>, we will use <strong class="source-inline">scikit-learn</strong> for linear regression instead):</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    @validate_df(columns={'close'}, instance_method=False)</p>
			<p class="source-code">    def regression(df):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Create linear regression of time series with lag=1.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - df: The dataframe with the stock data.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            X, Y, and the fitted model</p>
			<p class="source-code">        """</p>
			<p class="source-code">        X = df.close.shift().dropna()</p>
			<p class="source-code">        Y = df.close[1:]</p>
			<p class="source-code">        return X, Y, sm.OLS(Y, X).fit()</p>
			<p>As with the <strong class="source-inline">arima_predictions()</strong> method, we want to provide a way to review the<a id="_idIndexMarker1008"/> predictions<a id="_idIndexMarker1009"/> from the model, either as a <strong class="source-inline">Series</strong> object or as a plot. Unlike the ARIMA model, it will only predict one value at a time. Therefore, we will start our predictions on the day after the last closing price and iteratively use the previous prediction to predict the next one. To handle all this, we will write the <strong class="source-inline">regression_predictions()</strong> method:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    @validate_df(columns={'close'}, instance_method=False)</p>
			<p class="source-code">    def regression_predictions(df, model, start, end, </p>
			<p class="source-code">                               plot=True, **kwargs):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Get linear regression predictions as a `pandas.Series`</p>
			<p class="source-code">        object or plot.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - df: The dataframe for the stock.</p>
			<p class="source-code">            - model: The fitted linear regression model.</p>
			<p class="source-code">            - start: The start date for the predictions.</p>
			<p class="source-code">            - end: The end date for the predictions.</p>
			<p class="source-code">            - plot: Whether to plot the result, default is</p>
			<p class="source-code">              `True` meaning the plot is returned instead of</p>
			<p class="source-code">              the `Series` object containing the predictions.</p>
			<p class="source-code">            - kwargs: Additional arguments to pass down.</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A matplotlib `Axes` object or predictions </p>
			<p class="source-code">            depending on the value of the `plot` argument.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        predictions = pd.Series(</p>
			<p class="source-code">            index=pd.date_range(start, end), name='close'</p>
			<p class="source-code">        )</p>
			<p class="source-code">        last = df.last('1D').close</p>
			<p class="source-code">        for i, date in enumerate(predictions.index):</p>
			<p class="source-code">            if not i:</p>
			<p class="source-code">                pred = model.predict(last)</p>
			<p class="source-code">            else:</p>
			<p class="source-code">                pred = model.predict(predictions.iloc[i - 1])</p>
			<p class="source-code">            predictions.loc[date] = pred[0]</p>
			<p class="source-code">        if plot:</p>
			<p class="source-code">            ax = df.close.plot(**kwargs)</p>
			<p class="source-code">            predictions.plot(</p>
			<p class="source-code">                ax=ax, style='r:', </p>
			<p class="source-code">                label='regression predictions'</p>
			<p class="source-code">            )</p>
			<p class="source-code">            ax.legend()</p>
			<p class="source-code">        return ax if plot else predictions</p>
			<p>Lastly, for both <a id="_idIndexMarker1010"/>the ARIMA and linear regression models, we want to <a id="_idIndexMarker1011"/>visualize the errors in the predictions, or <strong class="bold">residuals</strong>. The fitted models both have a <strong class="source-inline">resid</strong> attribute, which will give us the residuals; we simply need to plot them as a scatter plot to check their variance and a KDE to check their mean. For this, we will add the <strong class="source-inline">plot_residuals()</strong> method:</p>
			<p class="source-code">    @staticmethod</p>
			<p class="source-code">    def plot_residuals(model_fitted, freq='B'):</p>
			<p class="source-code">        """</p>
			<p class="source-code">        Visualize the residuals from the model.</p>
			<p class="source-code">        Parameters:</p>
			<p class="source-code">            - model_fitted: The fitted model</p>
			<p class="source-code">            - freq: Frequency that the predictions were </p>
			<p class="source-code">              made on. Default is 'B' (business day).</p>
			<p class="source-code">        Returns: </p>
			<p class="source-code">            A matplotlib `Axes` object.</p>
			<p class="source-code">        """</p>
			<p class="source-code">        fig, axes = plt.subplots(1, 2, figsize=(15, 5))</p>
			<p class="source-code">        residuals = pd.Series(</p>
			<p class="source-code">            model_fitted.resid.asfreq(freq), name='residuals'</p>
			<p class="source-code">        )</p>
			<p class="source-code">        residuals.plot(</p>
			<p class="source-code">            style='bo', ax=axes[0], title='Residuals'</p>
			<p class="source-code">        )</p>
			<p class="source-code">        axes[0].set(xlabel='Date', ylabel='Residual')</p>
			<p class="source-code">        residuals.plot(</p>
			<p class="source-code">            kind='kde', ax=axes[1], title='Residuals KDE'</p>
			<p class="source-code">        )</p>
			<p class="source-code">        axes[1].set_xlabel('Residual')</p>
			<p class="source-code">        return axes</p>
			<p>Now, let's <a id="_idIndexMarker1012"/>take<a id="_idIndexMarker1013"/> the <strong class="source-inline">StockModeler</strong> class for a spin, once again using the Netflix data.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Time series decomposition</h2>
			<p>As mentioned<a id="_idIndexMarker1014"/> in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>, time series can be decomposed into trend, seasonal, and remainder components utilizing a specified frequency. This can be achieved with the <strong class="source-inline">statsmodels</strong> package, which <strong class="source-inline">StockModeler.decompose()</strong> is using:</p>
			<p class="source-code">&gt;&gt;&gt; <strong class="bold">from stock_analysis import StockModeler</strong></p>
			<p class="source-code">&gt;&gt;&gt; decomposition = <strong class="bold">StockModeler.decompose(nflx, 20)</strong></p>
			<p class="source-code">&gt;&gt;&gt; fig = decomposition.plot()</p>
			<p class="source-code">&gt;&gt;&gt; fig.suptitle(</p>
			<p class="source-code">...     'Netflix Stock Price Time Series Decomposition', y=1</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; fig.set_figheight(6)</p>
			<p class="source-code">&gt;&gt;&gt; fig.set_figwidth(10)</p>
			<p class="source-code">&gt;&gt;&gt; fig.tight_layout()</p>
			<p>This returns <a id="_idIndexMarker1015"/>the decomposition plot for Netflix with a frequency of 20 trading days:</p>
			<div>
				<div id="_idContainer336" class="IMG---Figure">
					<img src="image/Figure_7.23_B16834.jpg" alt="Figure 7.23 – Time series decomposition of Netflix's stock price over time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23 – Time series decomposition of Netflix's stock price over time</p>
			<p>For more<a id="_idIndexMarker1016"/> complicated models, we could decompose and then build our model around the components. That is beyond the scope of this chapter, however, so let's move on to ARIMA models.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>ARIMA</h2>
			<p>As we<a id="_idIndexMarker1017"/> discussed in <a href="B16834_01_Final_SK_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Data Analysis</em>, ARIMA <a id="_idIndexMarker1018"/>models have autoregressive, difference, and moving average components. They can also be built using the <strong class="source-inline">statsmodels</strong> package, which the <strong class="source-inline">StockModeler.arima()</strong> method is using; this method returns a fitted ARIMA model for the stock according to the specifications provided. Here, we will use the <strong class="source-inline">%%capture</strong> magic to avoid printing any warnings triggered by the ARIMA model fitting, since we are making a simple model to explore functionality:</p>
			<p class="source-code">&gt;&gt;&gt; %%capture</p>
			<p class="source-code">&gt;&gt;&gt; arima_model = StockModeler.arima(nflx, ar=10, i=1, ma=5)</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We're picking these values because they run in a reasonable amount of time. In practice, we can use the <strong class="source-inline">autocorrelation_plot()</strong> function from the <strong class="source-inline">pandas.plotting</strong> module that was introduced in <a href="B16834_05_Final_SK_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 5</em></a>, <em class="italic">Visualizing Data with Pandas and Matplotlib</em>, to help find a good value for <strong class="source-inline">ar</strong>.</p>
			<p>Once the model is fitted, we can obtain information on it with the model's <strong class="source-inline">summary()</strong> method:</p>
			<p class="source-code">&gt;&gt;&gt; print(arima_model.summary())</p>
			<p>The summary <a id="_idIndexMarker1019"/>is quite extensive, and <a id="_idIndexMarker1020"/>we should read the documentation when looking to interpret it; however, this article is likely to be a more digestible introduction: <a href="https://medium.com/analytics-vidhya/interpreting-arma-model-results-in-statsmodels-for-absolute-beginners-a4d22253ad1c">https://medium.com/analytics-vidhya/interpreting-arma-model-results-in-statsmodels-for-absolute-beginners-a4d22253ad1c</a>. Be advised that interpreting this summary will require a solid understanding of statistics:</p>
			<div>
				<div id="_idContainer337" class="IMG---Figure">
					<img src="image/Figure_7.24_B16834.jpg" alt="Figure 7.24 – Summary of our ARIMA model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24 – Summary of our ARIMA model</p>
			<p>For our purposes, a simpler way of analyzing the model is to look at the <strong class="bold">residuals</strong>, or the discrepancy between the observed values and predictions made by the model. The residuals should have a mean of 0 and have equal variance throughout, meaning that they should not depend on the independent variable (which is the date, in this case). The latter requirement is<a id="_idIndexMarker1021"/> referred to as <strong class="bold">homoskedasticity</strong>; when this assumption is not met, the estimates given by the model are not optimal. The <strong class="source-inline">StockModeler.plot_residuals()</strong> method helps check for this visually:</p>
			<p class="source-code">&gt;&gt;&gt; StockModeler.plot_residuals(arima_model)</p>
			<p>While the residuals are centered <a id="_idIndexMarker1022"/>at 0 (right subplot), they are <strong class="bold">heteroskedastic</strong>—note how their <a id="_idIndexMarker1023"/>variance appears to increase <a id="_idIndexMarker1024"/>over time (left subplot):</p>
			<div>
				<div id="_idContainer338" class="IMG---Figure">
					<img src="image/Figure_7.25_B16834.jpg" alt="Figure 7.25 – Evaluating the residuals of our ARIMA model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25 – Evaluating the residuals of our ARIMA model</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When we looked at the model summary in <em class="italic">Figure 7.24</em>, <strong class="source-inline">statsmodels</strong> ran a statistical test for heteroskedasticity using the default significance level of 0.05. The value of the test statistic is labeled <strong class="bold">Heteroskedasticity (H)</strong> and the p-value is labeled <strong class="bold">Prob(H) (two-sided)</strong>. Note that the result was statistically significant (the p-value was less than or equal to the significance level), meaning it's very unlikely that our residuals are homoskedastic.</p>
			<p>As an <a id="_idIndexMarker1025"/>alternative to building an <a id="_idIndexMarker1026"/>ARIMA model, the <strong class="source-inline">StockModeler</strong> class also gives us the option of using linear regression to model the closing price of a financial instrument.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Linear regression with statsmodels</h2>
			<p>The <strong class="source-inline">StockModeler.regression()</strong> method <a id="_idIndexMarker1027"/>builds a linear regression model for closing <a id="_idIndexMarker1028"/>price <a id="_idIndexMarker1029"/>as a function of the prior day's closing price using <strong class="source-inline">statsmodels</strong>:</p>
			<p class="source-code">&gt;&gt;&gt; X, Y, lm = StockModeler.regression(nflx)</p>
			<p class="source-code">&gt;&gt;&gt; print(lm.summary())</p>
			<p>Once again, the <strong class="source-inline">summary()</strong> method gives us statistics on the model's fit:</p>
			<div>
				<div id="_idContainer339" class="IMG---Figure">
					<img src="image/Figure_7.26_B16834.jpg" alt="Figure 7.26 – Summary of our linear regression model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.26 – Summary of our linear regression model</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Take a look at this article for some guidance on how to interpret the summary: <a href="https://medium.com/swlh/interpreting-linear-regression-through-statsmodels-summary-4796d359035a">https://medium.com/swlh/interpreting-linear-regression-through-statsmodels-summary-4796d359035a</a>.</p>
			<p>The <a id="_idIndexMarker1030"/>adjusted R<span class="superscript">2</span> makes this model look very good <a id="_idIndexMarker1031"/>since it is near 1 (in <a href="B16834_09_Final_SK_ePub.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Getting Started with Machine Learning in Python</em>, we <a id="_idIndexMarker1032"/>will discuss this metric further); however, we know that this is simply because stock data is highly autocorrelated, so let's look at the residuals again:</p>
			<p class="source-code">&gt;&gt;&gt; StockModeler.plot_residuals(lm)</p>
			<p>This model also suffers from heteroskedasticity:</p>
			<div>
				<div id="_idContainer340" class="IMG---Figure">
					<img src="image/Figure_7.27_B16834.jpg" alt="Figure 7.27 – Evaluating the residuals of our linear regression model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.27 – Evaluating the residuals of our linear regression model</p>
			<p>Let's now <a id="_idIndexMarker1033"/>see <a id="_idIndexMarker1034"/>whether the ARIMA model or the linear regression<a id="_idIndexMarker1035"/> model performs better at forecasting Netflix stock's closing prices.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Comparing models</h2>
			<p>In order<a id="_idIndexMarker1036"/> to compare our <a id="_idIndexMarker1037"/>models, we need to test their predictions on some new data. Let's gather the daily closing price of Netflix stock for the first two weeks in January 2021 and use the prediction methods in the <strong class="source-inline">StockModeler</strong> class to visualize our model predictions versus reality:</p>
			<p class="source-code">&gt;&gt;&gt; import datetime as dt</p>
			<p class="source-code">&gt;&gt;&gt; start = dt.date(2021, 1, 1)</p>
			<p class="source-code">&gt;&gt;&gt; end = dt.date(2021, 1, 14)</p>
			<p class="source-code">&gt;&gt;&gt; jan = stock_analysis.StockReader(start, end)\</p>
			<p class="source-code">...     .get_ticker_data('NFLX')</p>
			<p class="source-code">&gt;&gt;&gt; fig, axes = plt.subplots(1, 2, figsize=(15, 5))</p>
			<p class="source-code">&gt;&gt;&gt; arima_ax = StockModeler.arima_predictions(</p>
			<p class="source-code">...     nflx, arima_model, start=start, end=end, </p>
			<p class="source-code">...     ax=axes[0], title='ARIMA', color='b'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; jan.close.plot(</p>
			<p class="source-code">...     ax=arima_ax, style='b--', label='actual close'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; arima_ax.legend()</p>
			<p class="source-code">&gt;&gt;&gt; arima_ax.set_ylabel('price ($)')</p>
			<p class="source-code">&gt;&gt;&gt; linear_reg = StockModeler.regression_predictions(</p>
			<p class="source-code">...     nflx, lm, start=start, end=end,</p>
			<p class="source-code">...     ax=axes[1], title='Linear Regression', color='b'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; jan.close.plot(</p>
			<p class="source-code">...     ax=linear_reg, style='b--', label='actual close'</p>
			<p class="source-code">... )</p>
			<p class="source-code">&gt;&gt;&gt; linear_reg.legend()</p>
			<p class="source-code">&gt;&gt;&gt; linear_reg.set_ylabel('price ($)')</p>
			<p>The ARIMA<a id="_idIndexMarker1038"/> model's <a id="_idIndexMarker1039"/>predictions look more in line with the pattern we would expect, but, given the unpredictable nature of the stock market, both models are far off from what actually happened in the first two weeks of January 2021:</p>
			<div>
				<div id="_idContainer341" class="IMG---Figure">
					<img src="image/Figure_7.28_B16834.jpg" alt="Figure 7.28 – Model predictions versus reality&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28 – Model predictions versus reality</p>
			<p>As we can<a id="_idIndexMarker1040"/> see, forecasting stock performance is not easy, even for a few days. There is a lot of data that is not being captured <a id="_idIndexMarker1041"/>by these models, such as news stories, regulations, and changes in management, to name a few. No matter how well a model appears to fit, be weary of trusting predictions as these will be extrapolations, and there is a lot of randomness not being accounted for.</p>
			<p>To further illustrate this, take a look at the following set of plots that have been generated using random walks and stock data. Only one is real data, but which one? The answer follows the plots, so be sure to take a guess before looking:</p>
			<div>
				<div id="_idContainer342" class="IMG---Figure">
					<img src="image/Figure_7.29_B16834.jpg" alt="Figure 7.29 – Real or fake stock data?&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29 – Real or fake stock data?</p>
			<p>Each of these <a id="_idIndexMarker1042"/>time series originates at the same point (Microsoft's closing price on July 1, 2019), but<a id="_idIndexMarker1043"/> only <strong class="bold">A</strong> is real stock data—<strong class="bold">B</strong>, <strong class="bold">C</strong>, and <strong class="bold">D</strong> are all random walks. Hard (or impossible) to tell, right?</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Summary</h1>
			<p>In this chapter, we saw how building Python packages for our analysis applications can make it very easy for others to carry out their own analyses and reproduce ours, as well as for us to create repeatable workflows for future analyses. </p>
			<p>The <strong class="source-inline">stock_analysis</strong> package we created in this chapter contained classes for gathering stock data from the Internet (<strong class="source-inline">StockReader</strong>); visualizing individual assets or groups of them (<strong class="source-inline">Visualizer</strong> family); calculating metrics for single assets or groups of them for comparisons (<strong class="source-inline">StockAnalyzer</strong> and <strong class="source-inline">AssetGroupAnalyzer</strong>, respectively); and time series modeling with decomposition, ARIMA, and linear regression (<strong class="source-inline">StockModeler</strong>). We also got our first look at using the <strong class="source-inline">statsmodels</strong> package in the <strong class="source-inline">StockModeler</strong> class. This chapter showed us how the <strong class="source-inline">pandas</strong>, <strong class="source-inline">matplotlib</strong>, <strong class="source-inline">seaborn</strong>, and <strong class="source-inline">numpy</strong> functionality that we've covered so far in this book has come together and how these libraries can work harmoniously with other packages for custom applications. I strongly encourage you to reread the code in the <strong class="source-inline">stock_analysis</strong> package and test out some of the methods we didn't cover in this chapter to make sure you have the concepts down.</p>
			<p>In the next chapter, we will work on another application as we learn how to build a simulator for login attempts and try our hand at rule-based anomaly detection.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Exercises</h1>
			<p>Use the <strong class="source-inline">stock_analysis</strong> package to complete the following exercises. Unless otherwise noted, use data from 2019 through the end of 2020. In case there are any issues collecting the data with the <strong class="source-inline">StockReader</strong> class, backup CSV files are provided in the <strong class="source-inline">exercises/</strong> directory:</p>
			<ol>
				<li value="1">Using the <strong class="source-inline">StockAnalyzer</strong> and <strong class="source-inline">StockVisualizer</strong> classes, calculate and plot three levels of support and resistance for Netflix's closing price.</li>
				<li>With the <strong class="source-inline">StockVisualizer</strong> class, look at the effect of after-hours trading on the FAANG stocks:<p>a) As individual stocks</p><p>b) As a portfolio using the <strong class="source-inline">make_portfolio()</strong> function from the <strong class="source-inline">stock_analysis.utils</strong> module</p></li>
				<li>Using the <strong class="source-inline">StockVisualizer.open_to_close()</strong> method, create a plot that fills the area between the FAANG stocks' opening price (as a portfolio) and its closing price each day in red if the price declined and in green if the price increased. As a bonus, do the same for a portfolio of bitcoin and the S&amp;P 500.</li>
				<li>Mutual funds and <strong class="bold">exchange-traded funds</strong> (<strong class="bold">ETFs</strong>) are funds that are composed of many assets. They are built to mitigate risk, so volatility for the fund will be lower than that of the assets that compose it. (Information on how they differ can be found at <a href="https://www.investopedia.com/articles/exchangetradedfunds/08/etf-mutual-fund-difference.asp">https://www.investopedia.com/articles/exchangetradedfunds/08/etf-mutual-fund-difference.asp</a>.) Compare a mutual fund or ETF of your choice to three of its largest stocks (by composition) using annualized volatility and the <strong class="source-inline">AssetGroupAnalyzer</strong> class.</li>
				<li>Write a function that returns a dataframe of one row with columns for <strong class="source-inline">alpha</strong>, <strong class="source-inline">beta</strong>, <strong class="source-inline">sharpe_ratio</strong>, <strong class="source-inline">annualized_volatility</strong>, <strong class="source-inline">is_bear_market</strong>, and <strong class="source-inline">is_bull_market</strong>, which each contain the results of running the respective methods on a given stock using the <strong class="source-inline">StockAnalyzer</strong> class. Dictionary comprehensions and the <strong class="source-inline">getattr()</strong> function, as used in the <strong class="source-inline">AssetGroupAnalyzer.analyze()</strong> method, will be useful.</li>
				<li>With the <strong class="source-inline">StockModeler</strong> class, build an ARIMA model fit on the S&amp;P 500 data from January 1, 2019 through November 30, 2020 and use it to predict the performance in December 2020. Be sure to examine the residuals and compare the predicted performance to the actual performance.</li>
				<li>Request an API key for AlphaVantage (<a href="https://www.alphavantage.co/support/#api-key">https://www.alphavantage.co/support/#api-key</a>) and collect the daily foreign exchange rate from USD to JPY using the <strong class="source-inline">get_forex_rates()</strong> method on the same <strong class="source-inline">StockReader</strong> object you created to collect the data for the previous exercises. Build a candlestick plot with the data from February 2019 through January 2020, resampled to 1-week intervals. Hint: take a look at the <strong class="source-inline">slice()</strong> function from the standard library (<a href="https://docs.python.org/3/library/functions.html#slice">https://docs.python.org/3/library/functions.html#slice</a>) in order to provide the date range.</li>
			</ol>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Further reading</h1>
			<p>Check out the following resources for more information on the material covered in this chapter:</p>
			<ul>
				<li><em class="italic">A guide to Python's function decorators</em>: <a href="https://www.thecodeship.com/patterns/guide-to-python-function-decorators/">https://www.thecodeship.com/patterns/guide-to-python-function-decorators/</a></li>
				<li><em class="italic">Alpha</em>: <a href="https://www.investopedia.com/terms/a/alpha.asp">https://www.investopedia.com/terms/a/alpha.asp</a></li>
				<li><em class="italic">An Introduction to Classes and Inheritance (in Python)</em>: <a href="http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/">http://www.jesshamrick.com/2011/05/18/an-introduction-to-classes-and-inheritance-in-python/</a></li>
				<li><em class="italic">Beta</em>: <a href="https://www.investopedia.com/terms/b/beta.asp">https://www.investopedia.com/terms/b/beta.asp</a></li>
				<li><em class="italic">Coefficient of Variation (CV)</em>: <a href="https://www.investopedia.com/terms/c/coefficientofvariation.asp">https://www.investopedia.com/terms/c/coefficientofvariation.asp</a></li>
				<li><em class="italic">Classes (Python Documentation)</em>: <a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a><span class="hidden"> </span></li>
				<li><em class="italic">How After-Hours Trading Affects Stock Prices</em>: <a href="https://www.investopedia.com/ask/answers/05/saleafterhours.asp">https://www.investopedia.com/ask/answers/05/saleafterhours.asp</a></li>
				<li><em class="italic">How to Create a Python Package</em>: <a href="https://www.pythoncentral.io/how-to-create-a-python-package/">https://www.pythoncentral.io/how-to-create-a-python-package/</a></li>
				<li><em class="italic">How to Create an ARIMA Model for Time Series Forecasting in Python</em>: <a href="https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/">https://machinelearningmastery.com/arima-for-time-series-forecasting-with-python/</a> </li>
				<li><em class="italic">Linear Regression in Python using statsmodels</em>: <a href="https://datatofish.com/statsmodels-linear-regression/">https://datatofish.com/statsmodels-linear-regression/</a></li>
				<li><em class="italic">Object-Oriented Programming</em>: <a href="https://python.swaroopch.com/oop.html">https://python.swaroopch.com/oop.html</a></li>
				<li><em class="italic">Random walk</em>: <a href="https://en.wikipedia.org/wiki/Random_walk">https://en.wikipedia.org/wiki/Random_walk</a></li>
				<li><em class="italic">Stock Analysis</em>: <a href="https://www.investopedia.com/terms/s/stock-analysis.asp">https://www.investopedia.com/terms/s/stock-analysis.asp</a></li>
				<li><em class="italic">Support and Resistance Basics</em>: <a href="https://www.investopedia.com/trading/support-and-resistance-basics/">https://www.investopedia.com/trading/support-and-resistance-basics/</a><span class="hidden"> </span></li>
				<li><em class="italic">Technical Analysis</em>: <a href="https://www.investopedia.com/technical-analysis-4689657">https://www.investopedia.com/technical-analysis-4689657</a></li>
				<li><em class="italic">The definitive guide on how to use static, class or abstract methods in Python</em>: <a href="https://julien.danjou.info/guide-python-static-class-abstract-methods/">https://julien.danjou.info/guide-python-static-class-abstract-methods/</a><span class="hidden"> </span></li>
				<li><em class="italic">Writing the Setup Script</em>: <a href="https://docs.python.org/3/distutils/setupscript.html">https://docs.python.org/3/distutils/setupscript.html</a></li>
			</ul>
		</div>
	</body></html>