- en: '*Chapter 2*: Uploading, Downloading, and Manipulating Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have exclusively used simulated data in our Streamlit
    apps. This was useful for getting a good background in some of the basics of Streamlit,
    but most data science is not done on simulated data, but on real-world datasets
    that data scientists already have, or on datasets provided by users.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on the world of data in Streamlit apps, covering everything
    you will need to know to bring datasets to life using Streamlit. We will cover
    data manipulation, using user imported data, flow control, debugging Streamlit
    apps, and speeding up our data applications using caching through an example dataset
    called Palmer's Penguins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The setup – Palmer's Penguins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Streamlit apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data manipulation in Streamlit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will need to download the Palmer's Penguins dataset, which
    can be found at [https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv](https://github.com/tylerjrichards/streamlit_apps/blob/main/penguin_app/penguins.csv).
    The setup for this chapter, along with an explanation of the dataset, can be found
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The setup – Palmer's Penguins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we'll be using a delightful dataset about Arctic penguins
    that comes from the work of Dr. Kristen Gorman ([https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php))
    and the Palmer Station, Antarctica LTER ([https://pal.lternet.edu/](https://pal.lternet.edu/)).
  prefs: []
  type: TYPE_NORMAL
- en: Dataset acknowledgment
  prefs: []
  type: TYPE_NORMAL
- en: Data from the Palmer LTER data repository was supported by the Office of Polar
    Programs, NSF Grants OPP-9011927, OPP-9632763, and OPP-0217282.
  prefs: []
  type: TYPE_NORMAL
- en: This data is a common alternative to the famous Iris datasets and includes data
    on 344 individual penguins with 3 species represented. The data can be found in
    the GitHub repository for this book ([https://github.com/tylerjrichards/streamlit_apps](https://github.com/tylerjrichards/streamlit_apps)),
    in the `penguin_app` folder entitled `penguins.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: As we've discussed before, Streamlit apps run from inside our Python script.
    This sets the base directory to the location of the Python file with our Streamlit
    app, which means we can access any other files that we put in our app directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a folder for our new app in our existing `streamlit_apps`
    folder using the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, download the data and put the resulting CSV file (named `penguins.csv`
    in the example) in the `penguin_app` folder. Now, our folder should have the `penguins.py`
    file and our `penguins.csv` file. For our first go around, we''re just going to
    print out the first five rows of our DataFrame using the `st.write()` function
    we learned earlier using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following Streamlit app when we run `streamlit
    run penguins.py` in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The first five penguins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The first five penguins
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good idea of what the data looks like, we will explore the
    dataset a bit more and then begin adding to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Palmer's Penguins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin working with this dataset, we should make some visualizations
    to better understand the data. As we saw before, we have many columns in this
    data, from the bill length to the flipper length, to the island the penguin lives
    on, to even the species of penguin. For our first visualization, we can see the
    flipper length by body mass for the three species:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Flippers and weight'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Flippers and weight
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the Gentoo species has a high flipper length and body mass,
    and it appears that flipper length is correlated with body mass for all species.
    Next, let''s look at the relationship between bill length and flipper length:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Flippers and bills'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Flippers and bills
  prefs: []
  type: TYPE_NORMAL
- en: From this graph, we can see that the Chinstrap species seem to have a longer
    bill than the Adelie species. There are many more combinations of variables that
    we could plot on a scatterplot, but could we instead make a data explorer Streamlit
    app do this for us?
  prefs: []
  type: TYPE_NORMAL
- en: The final goal of this mini-app is going to be to ask the user to specify one
    of the species of penguins and to then also choose two other variables to use
    for a scatterplot. We'll start by learning how to take those inputs, and then
    create a dynamic visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last user input that we learned about was the number input function, which
    won''t help us here. Streamlit has a select box function (`st.selectbox()`) that
    allows us to ask the user to select one option from multiple options (in our case,
    three options), and the function returns whatever the user selects. We will use
    this to get the three inputs for our scatterplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates three new variables from three new select boxes that the
    user can input in our Streamlit app. The following screenshot shows the Streamlit
    app from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – User input on penguins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – User input on penguins
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the `selected_species` variable, we can filter our DataFrame
    and make a quick scatterplot using the selected `x` and `y` variables, as in this
    next block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This bit of preceding code adds to the previous example by loading our DataFrame,
    filtering by species, and then plotting in the same method from the previous chapter,
    which will result in the same app as before but with a scatterplot attached as
    well, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – First penguins scatterplot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – First penguins scatterplot
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to play around with this app and make sure that all the inputs and outputs
    are working correctly. Also notice that we''ve used the input variables to set
    out *x* axis and *y* axis labels, which means that those will update automatically
    when we make any new selections. Our graph doesn''t explicitly show what species
    is being graphed, so let''s practice making dynamic text. The following adds dynamic
    text to our Streamlit app''s graph title with the `format()` function native to
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds the species to our scatterplot and results in the following
    Streamlit app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Dynamic graph titles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Dynamic graph titles
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks great! We can also graph each species by hue and shape, as we did
    in the introductory graphs earlier in this book. The following code does this,
    and also uses the Seaborn dark grid theme to stand out against Streamlit''s white
    background a bit better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows our new and improved Palmer''s Penguins app,
    which allows us to select *x* and *y* axes and plots a scatterplot for us with
    the species in a different hue and shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Screenshot with shapes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Screenshot with shapes
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You are likely looking at this application through a black and white screenshot,
    which will only show the shape difference.
  prefs: []
  type: TYPE_NORMAL
- en: The last step for this app is to allow the user to upload their own data. What
    if we wanted the research team at any point to be able to upload their data to
    this app and see the graphed results? Or what if there were three research groups,
    all with their own unique data with different column names, that wanted to use
    a method that we created? We'll approach this problem one aspect at a time. First,
    how do we accept data from users?
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit has a function called `file_uploader()` that allows users of the app
    to upload data up to 200 MB in size (as a default). It works just like the other
    interactive widgets we've used before, with one exception. Our default in an interactive
    widget-like select box is just the first value in our list, but it does not make
    sense to have a default uploaded file before the user actually interacts with
    the app! The default user uploaded file has a value of `None`.
  prefs: []
  type: TYPE_NORMAL
- en: This begins to cover a very important concept in Streamlit development, which
    is flow control. Flow control can be understood as thinking carefully through
    all the steps of your application because Streamlit will try to run the entire
    app at once if we're not explicit about things, such as wanting to wait until
    the user has uploaded a file to attempt to create a graphic or manipulate a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control in Streamlit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we talked about before, there are two solutions to this data upload default
    problem. We can provide a default file to use until the user interacts with the
    application, or we can stop the app until a file is uploaded. Let''s start with
    the first option. The following code uses the `st.file_uploader()` function from
    within an `if` statement. If the user uploads a file, then the app uses that;
    if they do not, then we default to the file we have used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code in our terminal, we see our three user inputs
    (the *x* axis, the *y* axis, and the dataset), and also the graph even if we have
    yet to upload a file. The following screenshot shows this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – File input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – File input
  prefs: []
  type: TYPE_NORMAL
- en: The clear advantage of this approach is that there are always results shown
    in this application, but the results may not be useful to the user! For larger
    applications, this is a subpar solution as well because any data stored inside
    the app, regardless of use, is going to slow the application down. Later, in [*Chapter
    7*](B16864_07_Final_VK_ePub.xhtml#_idTextAnchor074), *Exploring Streamlit Components*,
    we'll discuss all of our options for deployment, including a built-in deployment
    option called Streamlit Sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second option is to stop the application entirely unless the user has uploaded
    a file. For that option, we''re going to use a new Streamlit function called `stop()`,
    which (predictably) stops the flow whenever it is called. It is best practice
    to use this to find errors in the app and to encourage the user to make some change
    or describe the error that is happening. This is not necessary for us but is a
    good thing to know for future applications. The following code uses an `if-else`
    statement with `st.stop()` in the `else` statement to prevent the entire app from
    running when `st.file_uploader()` is unused:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see with the following screenshot, until we upload our own data,
    we will not see a scatterplot, and the application stops. The Streamlit app simply
    waits to run fully until the user has uploaded their file instead of throwing
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Streamlit stop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16864_02_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Streamlit stop
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to data manipulation and create more complicated Streamlit
    apps, we should touch on some best practices for debugging Streamlit apps.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Streamlit apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We broadly have two options for Streamlit development.
  prefs: []
  type: TYPE_NORMAL
- en: Develop in Streamlit and `st.write()` as a debugger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore in Jupyter and then copy to Streamlit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing in Streamlit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first option, we write our code directly in Streamlit as we're experimenting
    and exploring exactly what our application will do. We've basically been taking
    this option already, which works very well if we have less exploration work and
    more implementation work to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: What you see is what you get
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need to maintain both IPython and Python versions of the same app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better experience for learning how to write production code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: A slower feedback loop (the entire app must run before feedback)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A potentially unfamiliar development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring in Jupyter and then copying to Streamlit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another option is to utilize the extremely popular Jupyter data science product
    to write and test out the Streamlit app's code before placing it in the necessary
    script and formatting it correctly. This can be useful for exploring new methods
    that will live in the Streamlit app, but it has serious downsides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: The lightning-fast feedback loop makes it easier to experiment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users may be more familiar with Jupyter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full app does not have to be run to get results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter may provide deceptive results if run out of order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '''Copying'' code over from Jupyter is time-consuming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python versioning may be different between Jupyter and Streamlit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My recommendation here is to develop Streamlit apps inside the environment where
    they are going to be run (that is, a Python file). For debugging, heavily utilize
    the `st.write()` function, which can print out nearly any Python object (dictionary,
    DataFrame, list, string, number, graph, and so on) that you may need. Try to only
    use another development environment such as Jupyter as a last resort!
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation in Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Streamlit runs our Python file from the top down as a script, and so we can
    perform data manipulation with powerful libraries such as pandas in the same way
    that we might in a Jupyter notebook or a regular Python script. As we''ve discussed
    before, we can do all our regular data manipulation as normal. For our Palmer''s
    Penguins app, what if we wanted the user to be able to filter out penguins based
    on their gender? The following code filters our DataFrame using pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A couple of things to note here. First, we've added another `selectbox` plugin,
    with male, female, and all options. We could have done this by asking for a text
    input, but for data manipulation, we want to restrict user action as much as possible.
    We also made sure to dynamically change the title, which is recommended for clarity
    as we want to show the user that the data has been filtered by their input directly
    in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we create more computationally intensive Streamlit apps and begin to use
    and upload larger datasets, we should start worrying about the runtime of these
    apps and work to increase our efficiency whenever possible. The easiest way to
    make a Streamlit app more efficient is through caching, which is storing some
    results in memory so that the app does not repeat the same work whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: A good analogy to an app's cache is a human's short-term memory, where we keep
    bits of information close at hand that we think might be useful. When something
    is in our short-term memory, we don't have to think very hard to get access to
    that piece of information. In the same way, when we cache a piece of information
    in Streamlit, we are making a bet that we'll use that information often.
  prefs: []
  type: TYPE_NORMAL
- en: The way Streamlit caching works more specifically is by storing the results
    of a function in our app, and if that function is called with the same parameters
    by another user (or by us if we rerun the app), Streamlit does not run the same
    function but instead loads the result of the function from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's prove to ourselves that this works! First, we'll create a function for
    our data upload part of the Penguins app, and then use the time library to artificially
    make the function take much longer than it would normally and see whether we can
    make our app faster using `st.cache()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code, we first made a new function called `load_file()`,
    which waits 3 seconds, and then loads the file that we need. Normally we would
    not intentionally slow down our app, but we want to know whether caching works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's run this app and then select the hamburger icon in the top right
    and press the rerun button (we can also just press the *R* key to rerun).
  prefs: []
  type: TYPE_NORMAL
- en: 'We notice that each time we rerun the app, it takes at least 3 seconds. Now,
    let''s add our cache decorator on top of the `load_file` function and run our
    app again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we run the app a few times, we can notice that it is much faster! When we
    rerun the app, two things happen. First, Streamlit checks the cache to ascertain
    whether that same function with the same inputs has been run before and returns
    the Penguins data from memory, and second, it does not run the `load_file` function
    at all, meaning we never run the `time.sleep(3)` command and also never spend
    the time required to load the data into Streamlit. We'll explore this caching
    function in more detail, but this method will get us the majority of the efficiency
    gains.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was full of fundamental building blocks that we will use vigorously
    throughout the remainder of this book, and that you will use to develop your own
    Streamlit applications.
  prefs: []
  type: TYPE_NORMAL
- en: On data, we covered how to bring our own DataFrames into Streamlit and how to
    accept user input in the form of a data file that brings us past only being able
    to simulate data. On other skillsets, we learned how to use our cache to make
    our data apps faster, how to control the flow of our Streamlit apps, and how to
    debug our Streamlit apps using `st.write()`. That's it for this chapter. Next,
    we'll move on to data visualization!
  prefs: []
  type: TYPE_NORMAL
