<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-91"><em class="italic"><a id="_idTextAnchor090"/>Chapter 6</em>: Exploring Variables with Scatter Plots and Filtering Subsets with Sliders</h1>
			<p>We are now going to tackle one of the most versatile, useful, and ubiquitous types of charts, the <strong class="bold">scatter plot</strong>. As its name implies, we basically scatter markers (which can be points, squares, circles, bubbles, or other symbols) on the Cartesian plane, where mainly their horizontal and vertical distances express the values they represent. Other visual attributes, such as size, color, and symbol, might be used to express other attributes, as we saw in some previous examples. As most of the fundamentals regarding figures and creating charts have been covered, we won't be spending much time on that, focusing instead on the particular details and options available to scatter plots. We will also explore and work with <strong class="bold">sliders</strong> as a new interactive component. Let's start right away, but first, here are the topics that we will be covering:</p>
			<ul>
				<li>Learning about the different ways of using scatter plots: markers, lines, and text</li>
				<li>Creating multiple scatter traces in a single plot</li>
				<li>Mapping and setting colors with scatter plots</li>
				<li>Handling over-plotting and outlier values by managing opacity, symbols, and scales</li>
				<li>Introducing sliders and range sliders</li>
				<li>Customizing the marks and values of sliders</li>
			</ul>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>The same tools that we used in the previous chapter will be used here. We will also focus a little on Plotly's <strong class="source-inline">graph_objects</strong> module for creating scatter plots, because it provides other tools and is very useful when customizing our plots further. The packages to use are Plotly, Dash, Dash Core Components, Dash HTML Components, Dash Bootstrap Components, pandas, and JupyterLab.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_06</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3ancblu">https://bit.ly/3ancblu</a>.</p>
			<p>We start by exploring the different ways, or the different things, if you want, that we can plot with scatter plots.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Learning about the different ways of using scatter plots: markers, lines, and text</h1>
			<p>We have a number of different options when using <strong class="source-inline">graph_objects</strong> to create scatter plots, as mentioned in the introduction, so we will be exploring it together with Plotly Express. To give you an idea of the versatility of the available <a id="_idIndexMarker289"/>scatter plots, the following code extracts all the <strong class="source-inline">scatter</strong> methods available to the <strong class="source-inline">Figure</strong> object, as well as those available in Plotly Express:</p>
			<p class="source-code">import plotly.graph_objects as go</p>
			<p class="source-code">import plotly.express as px</p>
			<p class="source-code">fig = go.Figure()</p>
			<p class="source-code">[f for f in dir(fig) if 'scatter' in f]</p>
			<p class="source-code"><strong class="bold">['add_scatter',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scatter3d',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scattercarpet',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scattergeo',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scattergl',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scattermapbox',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scatterpolar',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scatterpolargl',</strong></p>
			<p class="source-code"><strong class="bold"> 'add_scatterternary']</strong></p>
			<p class="source-code">[f for f in dir(px) if 'scatter' in f]</p>
			<p class="source-code"><strong class="bold">['scatter',</strong></p>
			<p class="source-code"><strong class="bold"> 'scatter_3d',</strong></p>
			<p class="source-code"><strong class="bold"> 'scatter_geo',</strong></p>
			<p class="source-code"><strong class="bold"> 'scatter_mapbox',</strong></p>
			<p class="source-code"><strong class="bold"> 'scatter_matrix',</strong></p>
			<p class="source-code"><strong class="bold"> 'scatter_polar',</strong></p>
			<p class="source-code"><strong class="bold"> 'scatter_ternary']</strong></p>
			<p>As you<a id="_idIndexMarker290"/> can see, there are some overlaps in the available methods, and there are also some methods that aren't available in both modules. We won't go into all of them, but it's good to know them, because you can easily utilize your knowledge of regular scatter plots for the other types. Let's now take a look at some of the differences between using those options. </p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Markers, lines, and text</h2>
			<p>One <a id="_idIndexMarker291"/>interesting option that is available in the <strong class="source-inline">go.Scatter</strong> object is the <strong class="source-inline">mode</strong> parameter. This can take any combination of markers, lines, and/or text. You can specify one, two, or all three options together. When <a id="_idIndexMarker292"/>specifying more <a id="_idIndexMarker293"/>than one option, you have to specify them as<a id="_idIndexMarker294"/> a single string, where elements are separated by the plus sign, for example, <strong class="source-inline">"markers+text"</strong>. Let's first get to know the indicators that we are going to focus on in this chapter, and immediately explore the plotting options:</p>
			<ol>
				<li>Run the required imports and create the <strong class="source-inline">poverty</strong> DataFrame:<p class="source-code">import pandas as pd</p><p class="source-code">import plotly.graph_objects as go</p><p class="source-code">poverty = pd.read_csv('data/poverty.csv')</p></li>
				<li>Our dataset contains three levels of daily income at which poverty is measured. They measure "the mean shortfall in income or consumption from the poverty line – $1.90 a day". They also have the same measure for two other levels, $3.20 and $5.50. They are also available as absolute counts in different columns, but we will focus on the percentages in this chapter. Their columns start with Poverty gap, which we can use as a pattern to extract the columns that we want:<p class="source-code">perc_pov_cols =\</p><p class="source-code">poverty.filter(regex='Poverty gap').columns</p><p class="source-code">perc_pov_cols</p><p class="source-code"><strong class="bold">Index(['Poverty gap at $1.90 a day (2011 PPP) (%)',</strong></p><p class="source-code"><strong class="bold">       'Poverty gap at $3.20 a day (2011 PPP) (% of population)',</strong></p><p class="source-code"><strong class="bold">       'Poverty gap at $5.50 a day (2011 PPP) (% of population)'],   </strong></p><p class="source-code"><strong class="bold">      dtype='object')</strong></p></li>
				<li>To<a id="_idIndexMarker295"/> make things simple, we will be starting all related variable names and objects with <strong class="source-inline">perc_pov_</strong> to make it clear that we are dealing with the poverty percentages. Keep in mind that we now have several objects and functions in the app, and we want to make sure we keep things simple, clear, and consistent. We now use the list we just created to create three variables, one for each poverty level: <p class="source-code">perc_pov_19 = perc_pov_cols[0]</p><p class="source-code">perc_pov_32 = perc_pov_cols[1]</p><p class="source-code">perc_pov_55 = perc_pov_cols[2]</p></li>
				<li>As usual, we need to look at the description of those indicators and, most importantly, at the limitations that they may have: <p class="source-code">series[series['Indicator Name']==\</p><p class="source-code">perc_pov_19]['Short definition'][25]</p><p class="source-code"><strong class="bold">'Poverty gap at $1.90 a day (2011 PPP) is the mean shortfall in income or consumption from the poverty line $1.90 a day (counting the nonpoor as having zero shortfall), expressed as a percentage of the poverty line. This measure reflects the depth of poverty as well as its incidence. As a result of revisions in PPP exchange rates, poverty rates for individual countries cannot be compared with poverty rates reported in earlier editions.'</strong></p></li>
				<li>The <a id="_idIndexMarker296"/>definitions are pretty much the same for the three indicators, and the limitations are also similar to what we saw in the previous chapter. Feel free to read the details, but keep in mind that these are not perfect numbers, and we have to be careful if we were to make any interpretations. We now create a variable for a country and use it to create a subset DataFrame containing the data for <strong class="source-inline">country</strong> and <strong class="source-inline">perc_pov_19</strong>:<p class="source-code">country = 'China'</p><p class="source-code">df =\</p><p class="source-code">poverty[poverty['Country Name']==country][['year', perc_pov_19]].dropna()</p></li>
				<li>Create a <strong class="source-inline">Figure</strong> and then add a scatter plot to it, using the relevant method. The <strong class="source-inline">mode</strong> parameter should be given one of the options discussed previously, and it is shown here simply as <strong class="source-inline">mode</strong>:<p class="source-code">fig = go.Figure()</p><p class="source-code">fig.add_scatter(x=df['year'],</p><p class="source-code">                y=df[perc_pov_19],</p><p class="source-code">                text=df[perc_pov_19],</p><p class="source-code">                <strong class="bold">mode=mode</strong>)</p><p class="source-code">fig.show()</p></li>
			</ol>
			<p><em class="italic">Figure 6.1</em> shows the effect of running the preceding code with each of the possible options for <strong class="source-inline">mode</strong>, with the figure titles showing how to set this option:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B16780_06_1.jpg" alt="Figure 6.1 – Different ways of setting the mode parameter for scatter plots"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Different ways of setting the mode parameter for scatter plots</p>
			<p>You <a id="_idIndexMarker297"/>can also see the other options in <em class="italic">Figure 6.2</em>:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B16780_06_2.jpg" alt="Figure 6.2 – Other ways of setting the mode parameter for scatter plots"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Other ways of setting the mode parameter for scatter plots</p>
			<p>Plotly Express has separate <a id="_idIndexMarker298"/>functions for scatter and line plots. You can plot text using the <strong class="source-inline">scatter</strong> function, which can be done by either choosing which column of your DataFrame contains the text to plot, or by providing a list of the text elements. The Plotly Express <strong class="source-inline">scatter</strong> function contains a <strong class="source-inline">text</strong> parameter that can be used for that.</p>
			<p>Let's now take a look at how we can utilize this code to create multiple scatter plot traces.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Creating multiple scatter traces in a single plot</h1>
			<p>We <a id="_idIndexMarker299"/>will mostly be focusing on using Plotly Express <a id="_idIndexMarker300"/>as much as possible, because of its convenience, and the other advantages previously discussed in <a href="B16780_04_Final_NM_ePub.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Manipulation and Preparation - Paving the Way to Plotly Express</em>. It's still very important to know how to work with <strong class="source-inline">Figure</strong> objects as you will encounter many situations where you will need to work with them, especially when you have a lot of customizations to make. Also, keep in mind that although the most important chart types are supported by Plotly Express, not all of them are.</p>
			<p>Let's extend the<a id="_idIndexMarker301"/> preceding chart with traces of other <a id="_idIndexMarker302"/>countries and compare the two approaches. We start with the <strong class="source-inline">graph_objects</strong> module's <strong class="source-inline">Figure</strong> object:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">countries</strong> list to filter with:<p class="source-code">countries = ['Argentina', 'Mexico', 'Brazil']</p></li>
				<li>Create a subset of <strong class="source-inline">poverty</strong>, which we will call <strong class="source-inline">df</strong>, where the values of the <strong class="source-inline">Country Name</strong> column are in the <strong class="source-inline">countries</strong> list (using the <strong class="source-inline">isin</strong> method). We then extract the <strong class="source-inline">year</strong>, <strong class="source-inline">Country Name</strong>, and <strong class="source-inline">perc_pov_19</strong> columns and drop the missing values:<p class="source-code">df = (poverty</p><p class="source-code">      [poverty['Country Name'].isin(countries)]</p><p class="source-code">      [['year','Country Name', perc_pov_19]]</p><p class="source-code">      .dropna())</p></li>
				<li>Create a <strong class="source-inline">Figure</strong> object, assigning it to a variable, <strong class="source-inline">fig</strong>:<p class="source-code">fig = go.Figure()</p></li>
				<li>We now want to add a trace for each country that we want to plot. This can be done by looping over the countries and creating a sub-DataFrame that contains only data for the current country: <p class="source-code">for country in countries:</p><p class="source-code">    df_country = df[df['Country Name']==country]</p></li>
				<li>We now add a new trace (within the same loop, and at the same level of indentation) by using the <strong class="source-inline">add_scatter</strong> method. Note that we set <strong class="source-inline">mode='markers+lines'</strong> and we use the <strong class="source-inline">name</strong> attribute to set the title of this trace in the legend:<p class="source-code">    fig.add_scatter(x=df_country['year'],</p><p class="source-code">                    y=df_country[perc_pov_19],</p><p class="source-code">                    <strong class="bold">name=country,</strong></p><p class="source-code">                    <strong class="bold">mode='markers+lines'</strong>)</p></li>
				<li>We also<a id="_idIndexMarker303"/> need to add a title for the <em class="italic">y</em>-axis, and<a id="_idIndexMarker304"/> then we can easily show the figure:<p class="source-code">fig.layout.yaxis.title = perc_pov_19</p><p class="source-code">fig.show()</p></li>
			</ol>
			<p>Running the preceding code produces the chart in <em class="italic">Figure 6.3</em>:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B16780_06_3.jpg" alt="Figure 6.3 – Creating multiple scatter plots using the graph_objects module"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Creating multiple scatter plots using the graph_objects module</p>
			<p>Now, let's compare that to how we would do it with Plotly Express. The code to produce it is so short, clear, and intuitive that it barely warrants an explanation:</p>
			<p class="source-code">px.scatter(df, x='year', y=perc_pov_19, color='Country Name')</p>
			<p>We chose the value for the <strong class="source-inline">data_frame</strong> parameter and selected which columns we want for the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">color</strong> parameters from <strong class="source-inline">df</strong>. The code then produces the chart in <em class="italic">Figure 6.4</em>:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B16780_06_4.jpg" alt="Figure 6.4 – Creating multiple scatter plots using Plotly Express"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Creating multiple scatter plots using Plotly Express</p>
			<p>We also get the <a id="_idIndexMarker305"/>axes labeled automatically and the <a id="_idIndexMarker306"/>legend labeled properly, and we even have a title for the legend, using the column name that we selected for the <strong class="source-inline">color</strong> parameter.</p>
			<p>There is a minor issue though. The disconnected points are not as easy to read as in the previous chart. This is especially important in this case because we are expressing a sequence of events, and the lines make it much clearer. With interactive dashboards, we don't know what our users are going to select, which means that they might produce charts that are even harder to read than this one. Plotly Express has separate functions for scatter and line plots, so in order to make it a "lines+markers" plot, we need to assign this to a <strong class="source-inline">Figure</strong> object and then add line traces. Here are the steps to do this: </p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Figure</strong> object and assign it to a variable, <strong class="source-inline">fig</strong>:<p class="source-code">fig = px.scatter(df,</p><p class="source-code">                 x='year',</p><p class="source-code">                 y=perc_pov_19,</p><p class="source-code">                 color='Country Name')</p></li>
				<li>Create another <strong class="source-inline">Figure</strong> object, exactly like the previous one, with a different name and chart type: <p class="source-code"><strong class="bold">fig_lines</strong> = px.<strong class="bold">line</strong>(df,</p><p class="source-code">                    x='year',</p><p class="source-code">                    y=perc_pov_19,</p><p class="source-code">                    color='Country Name')</p></li>
				<li>From <strong class="source-inline">fig_lines</strong>, we want to add its traces to <strong class="source-inline">fig</strong>. If you remember, the traces can be found under the <strong class="source-inline">data</strong> attribute of the <strong class="source-inline">Figure</strong> object. The <strong class="source-inline">data</strong> attribute is a tuple with each element corresponding to a trace. So, we need to loop over those traces (of the <strong class="source-inline">data</strong> attribute) and add them to <strong class="source-inline">fig</strong>:<p class="source-code">for trace in fig_lines.<strong class="bold">data</strong>:</p><p class="source-code">    <strong class="bold">trace.showlegend = False</strong></p><p class="source-code">    fig.add_trace(trace)</p><p class="source-code">fig.show()</p></li>
			</ol>
			<p>Note that <a id="_idIndexMarker307"/>each new line trace will have its label <a id="_idIndexMarker308"/>on the legend. So we would have redundant line labels in the legend, which we had to remove. We handled that by setting the <strong class="source-inline">showlegend</strong> attribute to <strong class="source-inline">False</strong> for each of the traces. Running this code produces the chart in <em class="italic">Figure 6.5</em>:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B16780_06_5.jpg" alt="Figure 6.5 – Creating multiple scatter and line plots using Plotly Express"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Creating multiple scatter and line plots using Plotly Express</p>
			<p>Comparing the mental effort and amount of code required to produce the same chart in two different approaches, we can see that there wasn't that much of a difference. This is typical when you want to produce something customized and/or something good enough for publishing. Still, for exploration purposes, Plotly Express is clearly a great starting point, and once you get a good idea of the data, you can better decide on which approach to adopt.</p>
			<p>We have <a id="_idIndexMarker309"/>seen an example of implicitly <a id="_idIndexMarker310"/>managing color on scatter plots (the colors were automatically set or us), and we are now ready to explore more options for managing color. If you are reading this on the printed grayscale version, you will see different shades of colors that might be distinguishable, but as we did previously, we will also use symbols to make it explicit and easy to understand.</p>
			<p>Let's now explore the different options that we have for managing color.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Mapping and setting colors with scatter plots</h1>
			<p>Colors <a id="_idIndexMarker311"/>are extremely important in conveying and expressing <a id="_idIndexMarker312"/>information about our charts. It is also a very big<a id="_idIndexMarker313"/> topic, and a full discussion is beyond the <a id="_idIndexMarker314"/>scope of this book. We will focus on colors for two types of variables – discrete and continuous. We will also tackle two ways of using colors in our charts: mapping variables to colors, and manually setting our colors. </p>
			<p>We start by exploring the differences between the two types of variables.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Discrete and continuous variables</h2>
			<p>Simply speaking, continuous variables<a id="_idIndexMarker315"/> are the ones that can take an infinite number of possible values in a certain range of numbers. For example, population is a number that can take any value, based on the number of people living in a certain country. Continuous variables are typically numbers (integers or real numbers). Height, weight, and speed are other examples as well.</p>
			<p>Discrete variables, on <a id="_idIndexMarker316"/>the other hand, are variables that can take the value of any one of a limited set of items. Most importantly, discrete variables cannot take values in between the items. Countries are one such example. A country can either be country A or country B, but can't be 10% A and 90% B. Discrete variables are typically text variables, and usually have a relatively small number of unique items.</p>
			<p>The way we use color to express the nature of our variables is as follows: </p>
			<ul>
				<li>For continuous variables, we<a id="_idIndexMarker317"/> use a color scale that takes on colors that gradually change between two or more colors, as the values they represent change. For example, if our color scale starts as white for the lowest value, and ends up as blue at the highest value, all values in between would take on varying shades of white and blue. A marker that has a color that contains more blue than white means that its value is closer to the maximum value of that variable and vice versa. We will try this shortly.</li>
				<li>Discrete variables <a id="_idIndexMarker318"/>are distinct items, and the colors we use for them need to be as distinct from each other as possible, especially the ones that appear next to each other. Examples will make this clear, and we start with continuous variables.</li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Using color with continuous variables</h2>
			<p>Using the same <a id="_idIndexMarker319"/>metric we started with, we want to take an<a id="_idIndexMarker320"/> arbitrary year and plot the indicator value for each of the countries. We already know how to do this. We now want to add a new dimension to our chart. We want to use color to show another value, for example, population. This will allow us to see whether there is any correlation between population and the metric we are plotting (poverty at $1.90 in this case). Let's prepare our variables and data:</p>
			<ol>
				<li value="1">Create variables for the indicator and year of choice: <p class="source-code">indicator = perc_pov_19</p><p class="source-code">year = 1991</p></li>
				<li>Using the indicator and year, we create a subset of <strong class="source-inline">poverty</strong> where the year column is equal to our variable, <strong class="source-inline">year</strong>, and the <strong class="source-inline">is_country</strong> column is <strong class="source-inline">True</strong>. We then drop the missing values and sort the values according to this column. The following code achieves this: <p class="source-code">df =\</p><p class="source-code">poverty[poverty['year'].eq(year) &amp; poverty['is_country']].dropna(subset=[indicator]).sort_values(indicator)</p></li>
				<li>All we have to do is select the column we want for mapping its values to the appropriate colors, and we do this as we usually do with Plotly Express: <p class="source-code">px.scatter(df,</p><p class="source-code">           x=indicator,</p><p class="source-code">           y='Country Name',</p><p class="source-code">           <strong class="bold">color='Population, total'</strong>)</p></li>
			</ol>
			<p>The preceding <a id="_idIndexMarker321"/>code produces <a id="_idIndexMarker322"/>the chart in <em class="italic">Figure 6.6</em>:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B16780_06_6.jpg" alt="Figure 6.6 – Setting color for continuous variables with Plotly Express"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Setting color for continuous variables with Plotly Express</p>
			<p>We basically added a new layer to our visualization with the column that we selected. Each visual attribute adds another dimension to the chart, and makes it richer, but adding too many dimensions might make it overwhelming and difficult to read. It's up to us to strike the right balance and make sure we are presenting something meaningful and readable to our audience.</p>
			<p>We can immediately see that the country with the highest population in the chart (the United States, in bright yellow) has one of the lowest values for our indicator. We can also see that since most other markers are closer to purple in color, this shows that the country with the highest population has quite an extreme value for that metric compared to the others. It seems to be an outlier in population, but not so, with the poverty indicator. The popup that appears when we hover over a marker also takes the same color and, being much bigger than the marker, makes it very easy to relate the color to its relative position on the color bar. The color <strong class="bold">scale</strong> that we have here is only one of tens of scales that we can chose from. Changing that is also very easy, and we simply need to provide the name of that scale to the parameter, <strong class="source-inline">color_scale_continuous</strong>. We can see how to do that, as well as its effect, in <em class="italic">Figure 6.7</em>, where we chose the <strong class="bold">cividis</strong> scale:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B16780_06_7.jpg" alt="Figure 6.7 – Choosing a different continuous color scale"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Choosing a different continuous color scale</p>
			<p>There is no <a id="_idIndexMarker323"/>additional information in this chart, only that we <a id="_idIndexMarker324"/>changed the color scale to a different one. It's intuitive to understand this color scale, as it moves between dark blue and bright yellow, and all combinations of colors in between. The scale is also known as a "sequential" scale, because it shows how values move from a low to a high value. You can get a full list of named color scales by running <strong class="source-inline">px.colors.named_colorscales()</strong>, which will return the names of those scales. More interesting is the option to see all those scales and compare them, so you can choose which one you want. You can produce a chart with all available scales of a certain type by running <strong class="source-inline">px.colors.sequential.swatches()</strong>, and you can see part of the output in <em class="italic">Figure 6.8</em>: </p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B16780_06_8.jpg" alt="Figure 6.8 – The first few sequential scales available in Plotly"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The first few sequential scales available in Plotly</p>
			<p>Another<a id="_idIndexMarker325"/> interesting way of showing the color scales in action <a id="_idIndexMarker326"/>is by using the <strong class="source-inline">swatches_continuous</strong> functions. For example, <em class="italic">Figure 6.9</em> shows the result of running <strong class="source-inline">px.colors.sequential.swatches_continuous()</strong>:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B16780_06_9.jpg" alt="Figure 6.9 – The first few sequential scales available in Plotly as they would appear in a color bar"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – The first few sequential scales available in Plotly as they would appear in a color bar</p>
			<p>This gives an <a id="_idIndexMarker327"/>even better idea of how they would actually<a id="_idIndexMarker328"/> look, and shows colors with smooth transitions in between.</p>
			<p>You can use the <strong class="source-inline">swatches</strong> functions for other types of color scales and sequences. You simply run the previous command and replace <strong class="source-inline">sequential</strong> with any of the following: <strong class="source-inline">carto</strong>, <strong class="source-inline">cmocean</strong>, <strong class="source-inline">colorbrewer</strong>, <strong class="source-inline">cyclical</strong>, <strong class="source-inline">diverging</strong>, or <strong class="source-inline">qualitative</strong>.</p>
			<p>So far, we have mapped the data values and colors automatically by choosing which column's values we want to use for that. There is also the option of manually setting the color scales. </p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Manually creating color scales</h2>
			<p>One way of <a id="_idIndexMarker329"/>doing this is by providing a list of two or more colors to the <strong class="source-inline">color_continuous_scale</strong> parameter. By default, the first color you provide will be assigned to the minimum value and the last color to the maximum value. Values in between will take combinations, resulting in shades of the two colors. This shows how close the data point is to each of the extremes. We'll see an example of using more than two colors shortly. Using the same code and setting <strong class="source-inline">color_continuous_scale=["steelblue", "darkorange"]</strong> produces the chart in <em class="italic">Figure 6.10</em>:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B16780_06_10.jpg" alt="Figure 6.10 – Manually setting continuous color scales"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.10 – Manually setting continuous color scales</p>
			<p>This gives a<a id="_idIndexMarker330"/> glimpse of how granular the options are, and this is barely scratching the surface of what is available. Sometimes, you may want to rescale your data so the colors adopt a smoother progression from the minimum to the maximum. The charts we just created are a good candidate for this. We have one outlier when it comes to population, so it might be better to set the <strong class="source-inline">color</strong> parameter to a scaled version of our data if we want to do that. In general, because there are numerous scales that are well-established and tested, it is better to choose from them instead of manually setting your own colors. Another important consideration is color blindness, and trying to use scales that cater for people who have it. You don't want to use colors that are indistinguishable by some of your readers. You can run a simple check by searching online as to whether or not a color scale is colorblind-friendly.</p>
			<p>Let's now set a scale that uses three colors. The <strong class="source-inline">RdBu</strong> (red blue) scale goes from red to blue, with mid values taking white as their color. It is one of the default scales. Let's quickly plot a simple chart with this scale: </p>
			<p class="source-code">y = [-2, -1, 0, 1, 2, 3, 4, 5, 6]</p>
			<p class="source-code">px.scatter(x=range(1, len(y)+1),</p>
			<p class="source-code">           y=y,</p>
			<p class="source-code">           <strong class="bold">color=y</strong>,</p>
			<p class="source-code">           <strong class="bold">color_continuous_scale='RdBu'</strong>)</p>
			<p>We created a<a id="_idIndexMarker331"/> list of integers in the range [-2, 6] and mapped their colors to the <strong class="source-inline">RdBu</strong> scale, which produces the chart in <em class="italic">Figure 6.11</em>:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B16780_06_11.jpg" alt="Figure 6.11 – Manually setting a continuous diverging color scale"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Manually setting a continuous diverging color scale</p>
			<p>In this case, you can see the colors moving from red to white to blue, passing through the intermediate shades of each color. This is also known as a "diverging" scale. There is a midpoint (the white point in this case) where colors diverge, signifying two different types of values. Usually, we use this to show values above and below a certain value. In this case, we wanted to show negative values in red, zero values in white, and positive values in blue. But we didn't get that. The white midpoint was set as the midpoint of the data, which happens to be the fifth element of our list, and its value is 2. </p>
			<p>This can be fixed by using the <strong class="source-inline">color_continuous_midpoint</strong> parameter, as you can see in <em class="italic">Figure 6.12</em>:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B16780_06_12.jpg" alt="Figure 6.12 – Manually setting a midpoint for a continuous diverging color scale"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Manually setting a midpoint for a continuous diverging color scale</p>
			<p>We now have a <a id="_idIndexMarker332"/>more meaningful midpoint, where the divergence in color makes it easy to see positive and negative values. Another important thing this achieves is that it also shows us how skewed the data is. Note that we don't have any red markers in the chart. We have two pinkish ones, while we have more blue values. This perfectly corresponds to the list of numbers, which contains two negative, and six positive values. The color bar also makes it clear that we are only covering part of the red spectrum, while blue is fully covered.</p>
			<p>There are many other options for setting colors, scaling the data, and expressing different values. I encourage you to learn more about this topic, and the good news is that Plotly provides options to customize colors the way you want.</p>
			<p>Let's now see how color works with discrete variables. </p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Using color with discrete variables</h2>
			<p>The objective now is not to <a id="_idIndexMarker333"/>visualize the degrees of difference <a id="_idIndexMarker334"/>between values. We now want to group values based on a criterion and see the differences across those groups of values. We can immediately see what happens if we simply set the <strong class="source-inline">color</strong> parameter to a column that has text values. For example, we can set <strong class="source-inline">color="Income Group"</strong> to get the chart in <em class="italic">Figure 6.13</em>:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B16780_06_13.jpg" alt="Figure 6.13 – Using color with categorical variables"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Using color with categorical variables</p>
			<p>Everything was automatically handled for us. Simply because we chose a column with text values, Plotly <a id="_idIndexMarker335"/>Express grouped the data according to that <a id="_idIndexMarker336"/>column, and chose a sequence of colors that are distinct from one another, so we can see how values change across the groups. We also used symbols to make it easier to see, especially on a grayscale version of the chart. This was achieved by setting <strong class="source-inline">symbol='Income Group'</strong>. </p>
			<p>As with continuous variables, we can also set our own discrete color sequence by providing one to the <strong class="source-inline">color_discrete_sequence</strong> parameter. <em class="italic">Figure 6.14</em> shows the effect of setting this parameter, by using one of the sequences provided by Plotly: </p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B16780_06_14.jpg" alt="Figure 6.14 – Setting a different color sequence for categorical variables"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – Setting a different color sequence for categorical variables</p>
			<p>Note that we <a id="_idIndexMarker337"/>have chosen a sequence by getting it from the <a id="_idIndexMarker338"/>available list, <strong class="source-inline">px.colors.qualitative.G10</strong>, and as you may have guessed, you can generate all the available sequences by running <strong class="source-inline">px.colors.qualitative.swatches()</strong>.</p>
			<p>As we did with continuous variables, we can also manually set the colors of our discrete variables by providing a list of named colors. We can also use the colors' hexadecimal representation, for example, <strong class="source-inline">#aeae14</strong>, or the RGB values, for example, <strong class="source-inline">'rgb(25, 85, 125)'</strong>. Passing our chosen colors to the <strong class="source-inline">color_discrete_sequence</strong> parameter, we get the chart in <em class="italic">Figure 6.15</em>:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B16780_06_15.jpg" alt="Figure 6.15 – Manually setting the colors of a sequence for categorical variables"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – Manually setting the colors of a sequence for categorical variables</p>
			<p>When you manually select the colors of your choice, you need to make sure that you provide a list of colors that has the same number of elements as the unique values of the variable you<a id="_idIndexMarker339"/> are trying to visualize. Otherwise, it will <a id="_idIndexMarker340"/>cycle through the colors you provided, and this might be misleading. Again, it's usually better to select from the available established sequences, but you can set them manually if you want to. When we set the colors that we want, we didn't specify which item should take which color. We simply stated that we want the unique values to take this set of colors. Sometimes, you may want to explicitly map certain colors to certain categories. Once you know the unique values, you can provide a dictionary to the <strong class="source-inline">color_discrete_map</strong> parameter, and then map each value to the color of your choice: </p>
			<p class="source-code">color_discrete_map={'High income': 'darkred',</p>
			<p class="source-code">                    'Upper middle income': 'steelblue',</p>
			<p class="source-code">                    'Lower middle income': 'orange',</p>
			<p class="source-code">                    'Low income': 'darkblue'}</p>
			<p>Setting this option produces the chart in <em class="italic">Figure 6.16</em>: </p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B16780_06_16.jpg" alt="Figure 6.16 – Manually setting the colors for each value of a sequence for categorical variables"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – Manually setting the colors for each value of a sequence for categorical variables</p>
			<p>Note that most continuous variable parameters contains "scale," while the discrete ones contain "sequence." This can help in remembering and understanding the fundamental difference in the process of mapping colors to the two kinds of variables. </p>
			<p>With <a id="_idIndexMarker341"/>continuous variables, we are giving the readers the<a id="_idIndexMarker342"/> ability to see the approximate value of the markers based on the color, as well as the relative position in the dataset. It is not clear cut, but you can tell that the population of a certain country is around twenty million, and that it looks like it's one of the highest countries in this dataset. Users can, of course, hover and get the exact value if they want. With discrete variables, we are basically more interested in grouping by those variables and seeing trends across those groups. </p>
			<p>We covered a small subset of what can be done with colors, and now we move to consider a few other issues that might arise with scatter plots, namely, outliers and having many data points to plot.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Handling over-plotting and outlier values by managing opacity, symbols, and scales</h1>
			<p>Let's say we are <a id="_idIndexMarker343"/>now interested in seeing the relationship between our variable<a id="_idIndexMarker344"/> and population for the same year that we have been working on. We want to have <strong class="source-inline">Population, total</strong> on the <em class="italic">x</em>-axis, and <strong class="source-inline">perc_pov_19</strong> on the <em class="italic">y</em>-axis.</p>
			<p>We first create a subset of <strong class="source-inline">poverty</strong> where <strong class="source-inline">year</strong> is equal to 2010, and <strong class="source-inline">is_country</strong> is <strong class="source-inline">True</strong>, and sort the values using <strong class="source-inline">Population, total</strong>: </p>
			<p class="source-code">df =\</p>
			<p class="source-code">poverty[poverty['year'].eq(2010) &amp; poverty['is_country']].sort_values('Population, total')</p>
			<p>Let's now see what it looks like when we plot those two variables. Here is the code: </p>
			<p class="source-code">px.scatter(df,</p>
			<p class="source-code">           y=perc_pov_19,</p>
			<p class="source-code">           x='Population, total',</p>
			<p class="source-code">           title=' - '.join([perc_pov_19, '2010']),</p>
			<p class="source-code">           height=500)</p>
			<p>Running this produces the chart in <em class="italic">Figure 6.17</em>:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B16780_06_17.jpg" alt="Figure 6.17 – Over-plotting and outliers in charts"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – Over-plotting and outliers in charts</p>
			<p>The <a id="_idIndexMarker345"/>existence of one outlier, China, with a population close to 1.4 billion, forces all markers to be squeezed to a very narrow part of our chart. We also have a<a id="_idIndexMarker346"/> small cluster of values above 25 on the <em class="italic">y</em>-axis, but the difference is nowhere as extreme as the horizontal one. Another important issue is that there are many markers on top of one another. Having solid-colored markers means that if you plot one marker on top of another, it will not make any difference; not even a thousand markers will. The existence of the two issues together make it a very challenging chart to read. </p>
			<p>We are going to explore a few techniques that might help with these situations, and evaluate when and how they might be useful. </p>
			<p>Since we have many points crowded on a very small part of the chart, we are likely to have several of them overlapping. Let's see the effect of changing the opacity and size of the markers. </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Controlling the opacity and size of markers</h2>
			<p>The <strong class="source-inline">opacity</strong> parameter <a id="_idIndexMarker347"/>takes values in the range [0, 1], inclusive. We can <a id="_idIndexMarker348"/>manually give it a number to control how opaque we want our markers to be. A value of <strong class="source-inline">0</strong> means completely transparent, which can also be thought of as a way to hide our markers (or a subset of them). A value of <strong class="source-inline">1</strong> means the markers will be fully opaque, taking whatever color they were assigned, and fully covering the area they are on. This also means that an <strong class="source-inline">opacity</strong> of <strong class="source-inline">0.1</strong> means that the marker will be 10% opaque. The practical implication for that is that it means that it will take 10 markers on top of one another to completely cover the area they are plotted on. If we set it to <strong class="source-inline">0.5</strong> (or 50%), this means that two markers would fully cover the area, and so on.</p>
			<p>Since the<a id="_idIndexMarker349"/> markers are quite small, and we don't have that<a id="_idIndexMarker350"/> many values, we can also increase their size for better visibility. The <strong class="source-inline">size</strong> parameter, just like all other parameters, can take the name of a column in our DataFrame, or a list of numbers. This is another visual attribute that we can use to express the values of a certain column where the relative sizes reflect the relative value that each marker represents. It is also sometimes called a bubble chart. For this case, we want to provide a fixed size. This can easily be done by providing a list having the same length as the DataFrame we are analyzing. This would give the markers a uniform default size, which might not be what we want, so we can control it with the <strong class="source-inline">size_max</strong> parameter. Reusing the same code and setting <strong class="source-inline">opacity=0.1</strong>, <strong class="source-inline">size=[5]*len(df)</strong>, and <strong class="source-inline">size_max=15</strong>, we get the chart in <em class="italic">Figure 6.18</em>:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B16780_06_18.jpg" alt="Figure 6.18 – Modifying the opacity and size of markers"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – Modifying the opacity and size of markers</p>
			<p>This looks a little better. We have bigger markers, and with an <strong class="source-inline">opacity</strong> of <strong class="source-inline">0.1</strong>, we can better see that the majority of markers are concentrated very close to the origin. Most likely, there is more nuance than that, but because of the outlier that we have, those differences seem very small.</p>
			<p>There will always be a trade-off between opacity and visibility. The more transparent your markers are, the clearer you can see, especially with hundreds or thousands of markers. But at the same time, they might become so transparent that you can't see anything. At <strong class="source-inline">0.1</strong> <strong class="source-inline">opacity</strong>, we are approaching that stage.</p>
			<p>Let's now take a look at another technique, which involves the use of logarithmic scales for the axes.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Using logarithmic scales</h2>
			<p>Normal scales are intuitive<a id="_idIndexMarker351"/> and easy to understand. Just like physical objects, a piece of wood that is twice the length of another one contains twice as much wood, provided it is of the same width and depth. In the previous two figures, for example, the distance between 0 and 0.2 billion is the same as the distance between 0.2 and 0.4 billion. The "data distance" is also the same. On a normal scale, and in this example, every tick corresponds to an increase of a certain amount (0.2 billion in this case). On a logarithmic scale, every additional tick corresponds to a multiple of the previous one.</p>
			<p>For example, the numbers 10, 20, 30, and 40 form a typical sequence that you might see on a normal scale. If the scale was logarithmic, we don't add 10; we would <strong class="bold">multiply</strong> by 10, making the sequence 10, 100, 1,000, and 10,000. Running the same code as we used previously and adding <strong class="source-inline">log_x=True</strong>, we get the updated chart in <em class="italic">Figure 6.19</em>:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B16780_06_19.jpg" alt="Figure 6.19 – Using a logarithmic scale"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – Using a logarithmic scale</p>
			<p>Our chart now looks quite different, but it is still actually the same chart. Note that we have changed the <strong class="source-inline">opacity</strong> to <strong class="source-inline">0.25</strong>, because <strong class="source-inline">0.1</strong> was difficult to see, and because we now have the markers a lot more dispersed than previously. We now have a much more nuanced view of how the population is distributed. We can see that the most opaque part is around the ten million mark. Compared to 1.4 billion, this is pretty much zero, which is what the previous chart told us, but now we have a better view.</p>
			<p>Note that the major<a id="_idIndexMarker352"/> ticks are each 10 times larger than the previous one (<strong class="bold">10k</strong>, <strong class="bold">100k</strong>, <strong class="bold">1M</strong>, <strong class="bold">10M</strong>, <strong class="bold">100M</strong>, and <strong class="bold">1B</strong>), or for every major tick we are adding a zero. At the same time, we can see minor ticks, <strong class="bold">2</strong> and <strong class="bold">5</strong>, meaning that these positions represent twice and five times, respectively, the value of the previous major tick.</p>
			<p>Let's explore another option that we might consider in such situations. We will not use any opacity this time, but we will introduce a lot of space to our markers by changing the symbol that we use. Setting symbols can be managed exactly like setting discrete colors. <strong class="source-inline">symbol_sequence</strong> is the parameter responsible for that, it will cycle through the options that we provide, and then assign one for each unique discrete value in our column. We give it a list containing one value, so all markers will have the same symbol.</p>
			<p>We now remove the <strong class="source-inline">opacity</strong> argument and replace it with <strong class="source-inline">symbol_sequence=['circle_open']</strong> to get the new chart in <em class="italic">Figure 6.20</em>:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B16780_06_20.jpg" alt="Figure 6.20 – Modifying the symbols of markers"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – Modifying the symbols of markers</p>
			<p>This might be even better, as we are not sacrificing any visibility by changing the opacity. We achieved our objective of seeing where the markers are clustered, because it takes a lot of open circles to fully cover an area. The logarithmic scale spreads the markers horizontally, so it is easier to see how they are distributed. The tick labels clearly indicate the values, but we might need to make it very clear and explicit if our audience is not familiar with this kind of scale.</p>
			<p>We can imagine<a id="_idIndexMarker353"/> providing users with all the options that we just tried. We can think of having a component that allows users to modify the opacity, another component to toggle between normal and logarithmic scales, and maybe another to change the symbols. Ideally, we shouldn't make it that difficult for users to read our charts. It's best to do the work ourselves and provide sensible defaults after having explored the data. Based on what we have explored so far, let's consider what those defaults might be.</p>
			<p>We know that this chart plots countries, and that they cannot be more than 200. This means we can set a default opacity level that is appropriate for that number of markers. Having thousands of markers might require a much lower <strong class="source-inline">opacity</strong> level, such as <strong class="source-inline">0.02</strong>, for example. Open circles seem to have worked well for us by introducing space, so we might also choose that as the default symbol, and forget about opacity altogether. The same applies to the <strong class="source-inline">size</strong> parameter. Knowing that we are plotting population figures, and that it is most likely always going to contain outliers, as in this case, we might keep the logarithmic scale as the default.</p>
			<p>A more general type of interactive chart might allow users to modify the indicators that they want to explore. In this case, we might give them those options. However, with more freedom and generality, our users will have to handle more of the data handling details themselves.</p>
			<p>We have established a good understanding of our metrics and seen many examples of many countries. This exploration is crucial for building a dashboard with sensible defaults, as we just saw. Let's now explore the new interactive components of this chapter – the <strong class="source-inline">Slider</strong> components.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Introducing sliders and range sliders</h1>
			<p>The <strong class="source-inline">Slider</strong> and <strong class="source-inline">RangeSlider</strong> components <a id="_idIndexMarker354"/>are basically circles that users can drag <a id="_idIndexMarker355"/>horizontally or vertically to set or change a certain value. They are typically used for setting continuous values, as their appearance and dragging functionality are a <a id="_idIndexMarker356"/>natural fit for that. But this is not a requirement as we can use them for categorical/discrete values as well. We have seen that we have three levels of our <strong class="source-inline">perc_pov_</strong> metrics, and we know that we have all the years in our dataset to choose from. We now want to create two sliders. One allows users to select the level of poverty that they want to analyze, and the other allows them to select the year. Each combination of selections will create a different subset, and result in a different chart. <em class="italic">Figure 6.21</em> shows the top part of the end result that we will be working toward: </p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B16780_06_21.jpg" alt="Figure 6.21 – Two sliders controlling a chart"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – Two sliders controlling a chart</p>
			<p>As you can see, the<a id="_idIndexMarker357"/> new functionality requires three main components – two <strong class="source-inline">Slider</strong> components and one <strong class="source-inline">Graph</strong> component. Of course, we have a few others to control the layout, as well as labels, but the focus is mainly going to be on how to create and incorporate this new functionality.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline">RangeSlider</strong> component is <a id="_idIndexMarker358"/>almost identical to the <strong class="source-inline">Slider</strong> component. The main <a id="_idIndexMarker359"/>difference is that it contains more than one handle, so users can modify the maximum and minimum points within which they want to filter data. For now, we will focus on normal <strong class="source-inline">Slider</strong> components, and we will tackle the <strong class="source-inline">RangeSlider</strong> component in later chapters.</p>
			<p>As always, we will create this as a standalone app in JupyterLab, and once it is working fine, we will add it to the app. Let's start first by getting to know the <strong class="source-inline">Slider</strong> component, how it works, and then create the layout of our app. </p>
			<p>You can create a minimal app and, within the app's layout, create the <strong class="source-inline">Slider</strong> component, just like you do with other components, by calling <strong class="source-inline">dcc.Slider()</strong>:</p>
			<p class="source-code">app = JupyterDash(__name__)</p>
			<p class="source-code">app.layout = html.Div([</p>
			<p class="source-code">    <strong class="bold">dcc.Slider()</strong></p>
			<p class="source-code">])</p>
			<p class="source-code">app.run_server(mode='inline')</p>
			<p>This will create a simple app with a single component, as you can see in <em class="italic">Figure 6.22</em>: </p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B16780_06_22.jpg" alt="Figure 6.22 – A bare-bones slider component"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22 – A bare-bones slider component</p>
			<p>This is visually easy to use, and it's clear that users can slide the circle horizontally. There are no guides however, and users don't know what values they are modifying, so let's fix that. We will start by creating our first slider, containing the three poverty levels that we are analyzing. Let's take a look at the parameters that we are going to use for this: </p>
			<ul>
				<li><strong class="source-inline">min</strong>: As the name suggests, this is the minimum value of the slider.</li>
				<li><strong class="source-inline">max</strong>: This also sets the upper limit for the values.</li>
				<li><strong class="source-inline">step</strong>: As we go (slide) from <strong class="source-inline">min</strong> to <strong class="source-inline">max</strong>, what should the increment size be? By default, it is set to <strong class="source-inline">1</strong>, but you can set it to a higher or lower value. For example, if you wanted users to manage opacity, you can set <strong class="source-inline">min=0</strong>, <strong class="source-inline">max=1</strong>, and <strong class="source-inline">step=0.01</strong>. This would give users 100 options to choose from.</li>
				<li><strong class="source-inline">dots</strong>: Should the slider display dots or should it be a simple line? In our case, we want users to choose between three distinct values, so it makes sense to set this option to <strong class="source-inline">True</strong>.</li>
				<li><strong class="source-inline">included</strong>: Note that the slider in <em class="italic">Figure 6.22</em> is light blue to the left of the handle, and gray to its right. As you slide, the blue part expands/contracts with the handle, which is the default behavior. In our case, we are giving the user three distinct options, so we want to remove this to emphasize this fact, so we set its value to <strong class="source-inline">False</strong>. </li>
				<li><strong class="source-inline">value</strong>: This is the default value that the slider should take.</li>
			</ul>
			<p>Here is an example of a <strong class="source-inline">Slider</strong> component<a id="_idIndexMarker360"/> that ranges from <strong class="source-inline">0</strong> to <strong class="source-inline">10</strong>: </p>
			<p class="source-code">dcc.Slider(min=0,</p>
			<p class="source-code">           max=10,</p>
			<p class="source-code">           step=1,</p>
			<p class="source-code">           dots=True,</p>
			<p class="source-code">           included=False)</p>
			<p>This produces the new slider in <em class="italic">Figure 6.23</em>:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B16780_06_23.jpg" alt="Figure 6.23 – A slider component with custom options"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23 – A slider component with custom options</p>
			<p>The dots now guide users on where they can select, and it hints that the options are distinct from one another, especially that we set <strong class="source-inline">included=False</strong>.</p>
			<p>Another crucial parameter that <strong class="source-inline">Slider</strong> takes is the <strong class="source-inline">marks</strong> parameter. We need to show users what each dot corresponds to. In some cases, we might not have enough space to display all values, in which case we skip some of the values. We will do this in our years slider, but first let's <a id="_idIndexMarker361"/>create the poverty indicator slider. We first do it without the <strong class="source-inline">marks</strong> parameter, and then add it after that:</p>
			<p class="source-code">dcc.Slider(id='perc_pov_indicator_slider',</p>
			<p class="source-code">           min=0,</p>
			<p class="source-code">           max=2,</p>
			<p class="source-code">           step=1,</p>
			<p class="source-code">           value=0,</p>
			<p class="source-code">           included=False)</p>
			<p>For <strong class="source-inline">id</strong>, as with other variables, we followed the rule of starting with <strong class="source-inline">perc_pov_</strong> to be consistent with other related objects in the app. The values that the callback function will receive from this component are going to be <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, and <strong class="source-inline">2</strong>, and this is based on the <strong class="source-inline">min</strong>, <strong class="source-inline">max</strong>, and <strong class="source-inline">step</strong> arguments we gave. Now, those values don't mean anything in our situation, because we actually want the full text of the name of the indicator. We can simply handle this by taking the value of the slider and using it as the index for the <strong class="source-inline">perc_pov_cols</strong> list that we created. In our callback function, we will use this integer value to extract the respective indicator. We will see this later when we construct our callback function. Let's now create the marks for our slider.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Customizing the marks and values of sliders </h1>
			<p>The<a id="_idIndexMarker362"/> simplest way to create these is by using a dictionary: <strong class="source-inline">{0: '$1.9', 1: '$3.2', 2: '$5.5'}</strong>. They keys will be used as the <strong class="source-inline">value</strong> attribute, and<a id="_idIndexMarker363"/> the values of the dictionary are what the <a id="_idIndexMarker364"/>user will see for each poverty level. This will<a id="_idIndexMarker365"/> suffice for our case, and we can use it as such.</p>
			<p>We optionally have the chance to customize the style of our labels, which can take any CSS attribute as a dictionary. If you look at <em class="italic">Figure 6.21</em>, you can see that the marks (numbers) of the two sliders have a very light color, and they might give the impression that they belong to the same slider. We can improve this by setting their colors to a dark color. We can also set a bold font for the indicator slider. This will help distinguish them from the years, and it will also emphasize their uniqueness. Years are easy to immediately grasp, but users are most likely not familiar with the levels of poverty tracked in the dataset. </p>
			<p>We want<a id="_idIndexMarker366"/> to get a color that is consistent with our charts. And <a id="_idIndexMarker367"/>since we will be using the cividis color scale, it's a good <a id="_idIndexMarker368"/>opportunity to get to know how we can extract its <a id="_idIndexMarker369"/>colors. The <strong class="source-inline">px.colors.sequential</strong> module contains, among other things, lists of the colors of the sequential color scales. We can get cividis by running the following command:</p>
			<p class="source-code">px.colors.sequential.Cividis</p>
			<p class="source-code"><strong class="bold">['#00224e',</strong></p>
			<p class="source-code"><strong class="bold"> '#123570',</strong></p>
			<p class="source-code"><strong class="bold"> '#3b496c',</strong></p>
			<p class="source-code"><strong class="bold"> '#575d6d',</strong></p>
			<p class="source-code"><strong class="bold"> '#707173',</strong></p>
			<p class="source-code"><strong class="bold"> '#8a8678',</strong></p>
			<p class="source-code"><strong class="bold"> '#a59c74',</strong></p>
			<p class="source-code"><strong class="bold"> '#c3b369',</strong></p>
			<p class="source-code"><strong class="bold"> '#e1cc55',</strong></p>
			<p class="source-code"><strong class="bold"> '#fee838']</strong></p>
			<p>The list we receive contains the 10 colors that are actually used to construct this scale. Recall that we tried this manually with 2 and 3 colors. It's also interesting to know that you can get the reversed version of a scale by appending <strong class="source-inline">_r</strong> to its name, for example,<strong class="source-inline"> px.colors.sequential.Cividis_r</strong>. This would give us the same scale, but the yellow would correspond to the lower values in this case.</p>
			<p>Now, the color that we want to use for the labels of the marks is going to be the darkest one in cividis, which we can easily extract and assign to a variable as follows:</p>
			<p class="source-code">cividis0 = px.colors.sequential.Cividis[0]</p>
			<p>Using this, we can now set our <strong class="source-inline">marks</strong> argument as follows:</p>
			<p class="source-code">marks={0: {'label': '$1.9', 'style': {'color': cividis0, 'fontWeight': 'bold'}}, </p>
			<p class="source-code">       1: {'label': '$3.2', 'style': {'color': cividis0, 'fontWeight': 'bold'}},</p>
			<p class="source-code">       2: {'label': '$5.5', 'style': {'color': cividis0, 'fontWeight': 'bold'}}}</p>
			<p>What we did was basically extend the dictionary, where, instead of strings as values, we added dictionaries in the following form:</p>
			<p class="source-code"><strong class="bold"> {'label': &lt;label&gt;, 'style': {&lt;attribute_1&gt;: &lt;value_1&gt;, &lt;attribute_2&gt;: &lt;value_2&gt;}</strong></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In general, CSS attributes such as <strong class="source-inline">font-size</strong> and <strong class="source-inline">font-weight</strong> are hyphen-separated, and written in lowercase. In Dash, you can use the same attributes, but you have to remove the hyphens, and use camelCase (<strong class="source-inline">fontSize</strong> and <strong class="source-inline">fontWeight</strong>), as you can see in the previous code snippet.</p>
			<p>Similar to<a id="_idIndexMarker370"/> what we just did, let's now create the other slider <a id="_idIndexMarker371"/>with similar customizations. First, and in order to isolate <a id="_idIndexMarker372"/>our subset, we can create a special DataFrame for<a id="_idIndexMarker373"/> these variables:</p>
			<p class="source-code">perc_pov_df =\</p>
			<p class="source-code">poverty[poverty['is_country']].dropna(subset=perc_pov_cols)</p>
			<p class="source-code">perc_pov_years = sorted(set(perc_pov_df['year']))</p>
			<p>The important thing is that we removed any missing values from <strong class="source-inline">perc_pov_cols</strong>, and we also created a sorted list of unique years, <strong class="source-inline">perc_pov_years</strong>, using <strong class="source-inline">sorted</strong> and <strong class="source-inline">set</strong>. </p>
			<p>The following code creates our new slider for the years: </p>
			<p class="source-code">dcc.Slider(id='perc_pov_year_slider',</p>
			<p class="source-code">           min=perc_pov_years[0],</p>
			<p class="source-code">           max=perc_pov_years[-1],</p>
			<p class="source-code">           step=1,</p>
			<p class="source-code">           included=False,</p>
			<p class="source-code">           <strong class="bold">value=2018</strong>,</p>
			<p class="source-code">           marks={year: {'label': str(year),</p>
			<p class="source-code">                         'style': {'color': cividis0}}</p>
			<p class="source-code">                  for year in <strong class="bold">perc_pov_years[::5]</strong>})</p>
			<p>This is <a id="_idIndexMarker374"/>pretty much the same as we did for the indicators. We <a id="_idIndexMarker375"/>set the default to 2018, which is the latest year for<a id="_idIndexMarker376"/> which we have data. If this was a dynamically updated <a id="_idIndexMarker377"/>app, we can also set this value to the maximum of <strong class="source-inline">perc_pov_years</strong>. Note that we set the marks to show only one in five years. Otherwise, the slider would be very difficult to use. With this, we can see the slight difference in fonts and colors in <em class="italic">Figure 6.24</em>:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B16780_06_24.jpg" alt="Figure 6.24 – Sliders with updated colors"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24 – Sliders with updated colors</p>
			<p>The final part of our layout is going to be the <strong class="source-inline">Graph</strong> component:</p>
			<p class="source-code">dcc.Graph(id='perc_pov_scatter_chart')</p>
			<p>As I mentioned before, we also have <strong class="source-inline">Label</strong> components, as well as <strong class="source-inline">Col</strong> and <strong class="source-inline">Row</strong> components to better manage the layout, but they weren't discussed, as we have already created several examples using them. </p>
			<p>We are now ready to create our callback function to link the three elements that we just created:</p>
			<ol>
				<li value="1">We first create the decorator of the function. This is straightforward, as we did with previous examples. The slight difference is that we have two inputs in this case. In the definition of the function, the order of the parameters will correspond to the order of the <strong class="source-inline">Input</strong> elements, so we will name them accordingly:<p class="source-code">@app.callback(Output('perc_pov_scatter_chart', 'figure'),</p><p class="source-code">              Input('perc_pov_<strong class="bold">year</strong>_slider', 'value'),</p><p class="source-code">              Input('perc_pov_<strong class="bold">indicator</strong>_slider', 'value'))</p></li>
				<li>In the next part, we create the function's signature, as well as the first few lines. The parameters are named <strong class="source-inline">year</strong> and <strong class="source-inline">indicator</strong>. We now use the indicator value (which is an integer) to get the corresponding element from <strong class="source-inline">perc_pov_cols</strong>. We then create the variable <strong class="source-inline">df</strong>, which filters <strong class="source-inline">perc_pov_df</strong> to only have values from <strong class="source-inline">year</strong>. Then, define we <strong class="source-inline">dropna</strong> and <strong class="source-inline">sort_values</strong>. There <a id="_idIndexMarker378"/>was a year that didn't have any data, but <a id="_idIndexMarker379"/>had to be included in the values <a id="_idIndexMarker380"/>of the slider, so we need to handle the<a id="_idIndexMarker381"/> case when/if users select it. This is done using the simple check <strong class="source-inline">if df.empty</strong>, as you can see here:<p class="source-code">def plot_perc_pov_chart(<strong class="bold">year</strong>, <strong class="bold">indicator</strong>):</p><p class="source-code">    indicator = perc_pov_cols[indicator]</p><p class="source-code">    df = (perc_pov_df</p><p class="source-code">          [perc_pov_df['year'].eq(year)]</p><p class="source-code">          .dropna(subset=[indicator])</p><p class="source-code">          .sort_values(indicator))</p><p class="source-code">    if df.empty:</p><p class="source-code">        raise PreventUpdate</p></li>
				<li>Now that we have our DataFrame ready, we can create the <strong class="source-inline">Figure</strong> and return it. Most of the code should now be familiar. The <strong class="source-inline">hover_name</strong> parameter is used to add a title to the popup when users hover over markers. Setting it to <strong class="source-inline">Country Name</strong> would cause the title to take the respective country's name and display it in bold. We also utilized the same dynamic height trick that we used in the <a id="_idIndexMarker382"/>last chapter, where we set a fixed height, and <a id="_idIndexMarker383"/>added 20 pixels for each country. The <strong class="source-inline">ticksuffix</strong> option <a id="_idIndexMarker384"/>we added at the end<a id="_idIndexMarker385"/> should be self-explanatory, to make it clear that these are percentages:<p class="source-code">fig = px.scatter(df,</p><p class="source-code">                 x=indicator,</p><p class="source-code">                 y='Country Name',</p><p class="source-code">                 color='Population, total',</p><p class="source-code">                 size=[30]*len(df),</p><p class="source-code">                 size_max=15,</p><p class="source-code">                 <strong class="bold">hover_name='Country Name'</strong>,</p><p class="source-code">                 height=250 +(20*len(df)),</p><p class="source-code">                 color_continuous_scale='cividis',</p><p class="source-code">                 title=indicator + '&lt;b&gt;: ' + f'{year}' +'&lt;/b&gt;')</p><p class="source-code">fig.layout.paper_bgcolor = '#E5ECF6'</p><p class="source-code"><strong class="bold">fig.layout.xaxis.ticksuffix = '%'</strong></p><p class="source-code">return fig</p></li>
			</ol>
			<p>Adding the layout elements and callback to our app, we finally get the additional functionality in the form of two sliders that can generate more than 130 charts through their combinations. <em class="italic">Figure 6.25</em> shows the final result:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B16780_06_25.jpg" alt="Figure 6.25 – Two sliders and a scatter plot – final result"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25 – Two sliders and a scatter plot – final result</p>
			<p>Congratulations on yet another addition to your app! This time, we created our first multiple input callback, which enriched the options that users can generate, without being complicated or overwhelming. </p>
			<p>From a functionality <a id="_idIndexMarker386"/>perspective, there is nothing really different between<a id="_idIndexMarker387"/> dropdowns and sliders. We could have <a id="_idIndexMarker388"/>implemented the same thing with dropdowns, and it would <a id="_idIndexMarker389"/>have worked fine. The advantage of dropdowns is that they are extremely efficient in terms of space utilization. A small rectangle can contain tens or even hundreds of hidden options that users can search. Those options can be very long strings that may be impossible to fit next to each other, on a slider, for example.</p>
			<p>On the other hand, sliders give a better perspective. They implicitly contain metadata about the options. You can immediately see the minimum and maximum points, and how widely they are spread. When you select an option, you can easily tell how extreme your choice was relative to the other options that are available. In the case of the poverty level slider, users can see all available options immediately. And finally, sliders are more similar to how we interact with physical objects, so playing with them might be more engaging than other interactive components. So, space restrictions, the types of variables that we are analyzing, and how we want to display them are some considerations that affect our choice of interactive components that we decide to utilize.</p>
			<p>You probably noticed that we are focusing less on how to put things together in the app, and that's intentional. We have already covered these topics several times, and it is designed to also encourage you to do them yourself and experiment with other options. You can always refer back to the code repository to check your work and for the minor details.</p>
			<p>Let's now recap what we have covered in this chapter.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Summary</h1>
			<p>We introduced scatter plots and saw how to create them, both using the <strong class="source-inline">graph_objects</strong> module, and using Plotly Express. We saw how to create multiple traces and tried different approaches for that. We then discussed color mapping and setting and explored how different the process is for continuous and discrete (categorical) variables. We saw different scales – sequential, diverging, and qualitative. We also saw how we can set our own colors, sequences, and scales. We also tackled some issues that arise when we have outliers, and when we have over-plotting. We experimented with opacity, changing symbols, and marker sizes, as well as using logarithmic scales to make our charts more readable. We also introduced sliders and learned how they work, and created two sliders that work together to generate charts expressing three values (as opposed to two values previously). We then created a callback function that managed those interactions and integrated it into our app.</p>
			<p>By now, and with all the examples and techniques covered, we are getting closer to the point of creating dashboards in the same way as we create slideshows and presentations. Once we master the layout elements, it's very easy to customize any size and position we want. And now that we are exploring different chart types and data visualization techniques, it will become easier to manage things and modify them the way we want.</p>
			<p>All the charts we have explored so far used regular geometric shapes, including circles, lines, and rectangles. In the next chapter, we will explore irregular shapes, and how to visualize them, in the form of maps. Maps are very engaging, and easily recognizable, yet not so straightforward to visualize, like simple regular shapes. This will be explored next.</p>
		</div>
	</body></html>