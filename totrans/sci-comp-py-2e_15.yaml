- en: Testing
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll focus on two aspects of testing for scientific programming.
    The first aspect is the often difficult topic of *what to test* in scientific
    computing. The second aspect covers the question of *how to test*. We will distinguish
    between manual and automated testing. Manual testing is what is done by every
    programmer to quickly check that a program is doing what it should or should not.
    Automated testing is the refined, automated variant of that idea. We will introduce
    some tools available for automatic testing in general, with a view of the particular
    case of scientific computing.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Manual testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During code development, you do a lot of small tests in order to test its functionality.
    This could be called manual testing. Typically, you would test if a given function
    does what it is supposed to do, by manually testing the function in an interactive
    environment. For instance, suppose that you implement the bisection algorithm.
    It is an algorithm that finds a zero (root) of a scalar non-linear function. To
    start the algorithm, an interval has to be given with the property that the function
    takes different signs on the interval boundaries (see Exercise 4 in [Section 7.10](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml):
    Exercises, for more information).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then test an implementation of that algorithm, typically by checking
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: A solution is found when the function has opposite signs at the interval boundaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exception is raised when the function has the same sign at the interval boundaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual testing, as necessary as it may seem to be, is unsatisfactory. Once you
    have convinced yourself that the code does what it is supposed to do, you formulate
    a relatively small number of demonstration examples to convince others of the
    quality of the code. At that stage, you often lose interest in the tests made
    during development, and they are forgotten or even deleted. As soon as you change
    a detail and things no longer work correctly, you might regret that your earlier
    tests are no longer available.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 Automatic testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The correct way to develop any piece of code is to use automatic testing. The
    advantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: The automated repetition of a large number of tests after every code refactoring and
    before any new versions are launched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silent documentation of the use of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Documentation of the test coverage of your code: Did things work before a change
    or was a certain aspect never tested?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in the program and in particular in its structure that do not affect
    its functionality are called code refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: We suggest developing tests in parallel to coding. Good design of tests is an
    art of its own and there is rarely an investment that guarantees such a good pay-off
    in development time savings as the investment in good tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will go through the implementation of a simple algorithm with the automated
    testing methods in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.1 Testing the bisection algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine automated testing for the bisection algorithm. With this algorithm,
    a zero of a real-valued function is found. It is described in *Exercise 4* in [Section
    7.10](35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml): *Exercises*. An implementation
    of the algorithm can have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume this to be stored in a file named `bisection.py`. As the first test
    case, we test that the zero of the function ![](img/73d8d9ce-c997-4f58-b10d-293373566190.png) is
    found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you meet the Python keyword `assert` for the first time. It raises
    the exception `AssertionError` if its first argument returns the value `False`.
    Its optional second argument is a string with additional information. We use the
    function `allclose` in order to test for equality of floats.
  prefs: []
  type: TYPE_NORMAL
- en: Let's comment on some of the features of the test function. We use an assertion
    to make sure that an exception will be raised if the code does not behave as expected.
    We have to manually run the test in the line `test_identity()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many tools to automate this kind of call; we will see one of those
    in [Section 15.2.2](dfb91b0a-8012-4043-af84-5cff4c6506db.xhtml): *Using the unittest
    module*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now set up a second test that checks if `bisect` raises an exception
    when the function has the same sign on both ends of the interval. For now, we
    will suppose that the exception raised is `ValueError`. In the following example,
    we will check the initial interval ![](img/94594833-3513-47cc-922c-b6e7d33b41bb.png).
    For the bisection algorithm, it should fulfill the sign condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, an `AssertionError` is raised if the exception is not of the type `ValueError`.
    There are tools to simplify the preceding construction to check that an exception
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful test is the edge case test. Here we test arguments or user input,
    which are likely to create mathematically undefined situations or states of the
    program not foreseen by the programmer. For instance, what happens if both bounds
    are equal? What happens if ![](img/d002cedc-dd50-438b-ba03-6b7658b83e07.png) ?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example for such an edge test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A test checks that the program unit does what is demanded by its specification.
    In the preceding example, we assumed that the specifications state that in the
    case ![](img/093d5afe-63f2-4229-ab93-0aa2be3c9dae.png) the two values should tacitly
    be interchanged. And that is what was tested. An alternative way would be to specify
    that this situation would be considered as wrong input, which the user has to
    correct. There, we would have tested for an appropriate exception, for example,
    `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.2 Using the unittest module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python module `unittest` greatly facilitates automated testing. This module
    requires that we rewrite our previous tests to be compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test would have to be rewritten in a `class`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the differences from the previous implementation. First, the
    test is now a method and a part of a class. The class must inherit from `unittest.TestCase`.
    The test method''s name must start with `test`. Note that we may now use one of
    the assertion tools of the `unittest` package, namely `assertAlmostEqual`. Finally,
    the tests are run using `unittest.main`. We recommend writing the tests in a file
    separate from the code to be tested. That is why it starts with an `import`. The
    test passes and returns as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it with a loose tolerance parameter, for example, `1.e-3`, a failure
    of the test will be reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Tests can and should be grouped together as methods of a test class, as given
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the last test we used the method `unittest.TestCase.assertRaises`.
    It tests whether an exception is correctly raised. Its first parameter is the
    exception type, for example, `ValueError`, `Exception`, and its second argument
    is the name of the function, which is expected to raise the exception. The remaining
    arguments are the arguments for this function.
  prefs: []
  type: TYPE_NORMAL
- en: The command `unittest.main()` creates an instance of the class `TestIdentity` and
    executes those methods starting with `test`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.3 Test setUp and tearDown methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The class `unittest.TestCase` provides two special methods, `setUp` and `tearDown`,
    which run before and after every call to a test method. This is needed when testing
    generators, which are exhausted after every test. We demonstrate this by testing
    a program that checks the line in a file in which a given string occurs for the
    first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We assume that this code is saved in a file named `find_in_file.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A test has to prepare a file and open it and remove it after the test as given
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before each test `setUp` is run and after each test `tearDown` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up testdata when a test case is created
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The methods `setUp` and `tearDown` are executed before and after any test method
    of a test case. This is necessary when the test methods change the data. They
    guarantee that the test data is restored before the next test is executed.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is also often a situation where your tests do not change the
    test data and you want to save time by only once setting up the data. This is
    done by the class method `setUpClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block schematically illustrates how the method `setUpClass`
    is used. You might also want to check [Section 8.4](1654fae9-6203-4871-8352-e436445fa49a.xhtml):
    *Class attributes and class methods* again.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 15.2.4 Parameterizing tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We frequently want to repeat the same test with different datasets. When using
    the functionalities of `unittest`, this requires us to automatically generate
    test cases with the corresponding methods injected.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, we first construct a test case with one or several methods that
    will be used, when we later set up test methods. We'll consider the bisection
    method again and let's check if the values it returns are really zeros of the
    given function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first build the test case and the method that we will use for the tests
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we dynamically create test functions as attributes of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the data is provided as a list of dictionaries. The function
    `make_test_function` dynamically generates a test function, which uses a particular
    data dictionary to perform the test with the previously defined method `checkifzero`.
    Finally, the command `setattr` is used to make these test functions methods of
    the class `Tests`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.5 Assertion tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we collect the most important tools for raising an `AssertionError`.
    We saw the command `assert` and three tools from `unittest`, namely `assertAlmostEqual`,
    `assertEqual`, and `assertRaises`. The following table (Table 15.1) summarizes
    the most important assertion tools and the related modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assertion tool and application example** | **Module** |'
  prefs: []
  type: TYPE_TB
- en: '| `assert 5==5` | – |'
  prefs: []
  type: TYPE_TB
- en: '| `assertEqual(5.27, 5.27)` | `unittest.TestCase` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertAlmostEqual(5.24, 5.2,places = 1)` |  `unittest.TestCase` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertTrue(5 > 2)` | `unittest.TestCase` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertFalse(2 < 5)` | `unittest.TestCase` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertRaises(ZeroDivisionError,lambda x: 1/x,0.)` | `unittest.TestCase`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `assertIn(3,{3,4})` | `unittest.TestCase` |'
  prefs: []
  type: TYPE_TB
- en: '| `assert_array_equal(A,B)` | `numpy.testing` |'
  prefs: []
  type: TYPE_TB
- en: '| `assert_array_almost_equal(A, B, decimal=5)` | `numpy.testing` |'
  prefs: []
  type: TYPE_TB
- en: '| `assert_allclose(A, B, rtol=1.e-3,atol=1.e-5)` | `numpy.testing` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.1: Assertion tools in Python, unittest, and NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.6 Float comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two floating-point numbers should not be compared with the `==` comparison,
    because the result of a computation is often slightly off due to rounding errors.
    There are numerous tools to test the equality of floats for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `allclose` checks that two arrays are almost equal. It can be used in
    a test function, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `self` refers to a `unittest.Testcase` instance. There are also testing
    tools in the `numpy` package `testing`. These are imported by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Testing that two scalars or two arrays are equal is done using `numpy.testing.assert_array_allmost_equal`
    or `numpy.testing.assert_allclose`. These methods differ in the way they describe
    the required accuracy, as shown in the preceding table, *Table 15.1.*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/561e22e7-9410-4f8e-98c0-5f5472a83c2e.png) factorization decomposes
    a given matrix into a product of an orthogonal matrix ![](img/3ec22240-f164-4c4c-91e2-08c4baac3ee3.png) and
    an upper triangular matrix ![](img/79db8e65-2824-4d59-8a3a-731f50166e27.png) as
    given in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Is the method applied correctly? We can check this by verifying that ![](img/daa3b63f-d531-4c68-af13-88bd2340ad86.png) is
    indeed an orthogonal matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we might perform a sanity test by checking if ![](img/93b48b98-bfcb-48d8-863c-e9a6af4c7585.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All this can be collected into the test case `unittest` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note in `assert_allclose` the parameter `atol` defaults to zero, which often
    causes problems when working with matrices having small elements.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.7 Unit and functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now, we have only used functional tests. A functional test checks whether
    the functionality is correct. For the bisection algorithm, this algorithm actually
    finds a zero when there is one. In that simple example, it is not really clear
    what a unit test is. Although it might seem slightly contrived, it is still possible
    to make a unit test for the bisection algorithm. It will demonstrate how unit
    testing often leads to more compartmentalized implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the bisection method, we would like to check, for instance, that at
    each step the interval is chosen correctly. How to do that? Note that it is absolutely
    impossible with the current implementation because the algorithm is hidden inside
    the function. One possible remedy is to run only one step of the bisection algorithm.
    Since all the steps are similar, we might argue that we have tested all the possible
    steps. We also need to be able to inspect the current bounds `a` and `b` at the
    current step of the algorithm. So we have to add the number of steps to be run
    as a parameter and change the return interface of the function. We will do that
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have to change the existing unit tests in order to accommodate
    that change. We may now add a unit test as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 15.2.8 Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging is sometimes necessary while testing, in particular, if it is not
    immediately clear why a given test does not pass. In that case, it is useful to
    be able to debug a given test in an interactive session. This is, however, made
    difficult by the design of the class `unittest.TestCase`, which prevents easy
    instantiation of test case objects. The solution is to create a special instance
    for debugging purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that, in the previous example of the class `TestIdentity`, we want
    to test the method `test_functionality`. This would be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this test can be run individually with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will run this individual test and it allows for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2.9 Test discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you write a Python package, various tests might be spread out through the
    package. The module `discover `finds, imports, and runs these test cases. The
    basic call from the command line is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts looking for test cases in the current directory and recurses the
    directory tree downward to find Python objects with the `''test''` string contained
    in its name. The command takes optional arguments. Most important are `-s` to
    modify the start directory and `-p` to define the pattern to recognize the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 15.3 Measuring execution time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to take decisions on code optimization, you often have to compare several
    code alternatives and decide which code should be preferred based on the execution
    time. Furthermore, discussing execution time is an issue when comparing different
    algorithms. In this section, we present a simple and easy way to measure execution
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.1 Timing with a magic function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to measure the execution time of a single statement is to use
    IPython’s magic function `%timeit`.
  prefs: []
  type: TYPE_NORMAL
- en: The shell IPython adds additional functionality to standard Python. These extra
    functions are called magic functions.
  prefs: []
  type: TYPE_NORMAL
- en: As the execution time of a single statement can be extremely short, the statement is
    placed in a loop and executed several times. By taking the minimum measured time,
    you make sure that other tasks running on the computer do not influence the measured
    result too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider four alternative ways to extract nonzero elements from an array
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Measuring time with IPython’s magic function `%timeit` gives the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The parameter `-n` controls how often the statement is executed before time
    is measured and the `-r` parameter controls the number of repetitions.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.2 Timing with the Python module timeit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python provides the module `timeit`, which can be used to measure execution
    time. It requires that, first, a time object is constructed. It is constructed from
    two strings: a string with setup commands and a string with the commands to be
    executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We take the same four alternatives as in the preceding example. The array and
    function definitions are written now in a string called `setup_statements` and
    four timing objects are constructed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The timer objects have a method `repeat`. It takes the two parameters `repeat` and `number`.
    It executes the statement of the timer object in a loop, measures the time, and
    repeats this experiment corresponding to the parameter `repeat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue the preceding example and measure execution times as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to the method in the example using `timeit`, we obtain lists of
    all the obtained measurements. As the computing time may vary depending on the
    overall load of the computer, the minimal value in such a list can be considered
    a good approximation to the computation time necessary to execute the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3.3 Timing with a context manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we present the third method. It serves to show another application
    of a context manager. We first construct a context manager object for measuring
    the elapsed time as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `__enter__` and `__exit__` methods make this class a context
    manager. The `__exit__` method's parameters `ty`, `val`, and `tb` are in the normal
    case `None`. If an exception is raised during execution, they take the exception
    type, its value, and traceback information. The return value `False` indicates
    that the exception has not been caught so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now show the use of the context manager to measure the execution time
    of the four alternatives in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will then display a message like `Time elapsed 15.0129795074 ms`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the timing result should be accessible in a variable, the `enter` method
    must return the `Timer` instance (uncomment the `return` statement) and a `with
    ... as ...` construction has to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 15.4 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No program development without testing! We showed the importance of well-organized
    and documented tests. Some professionals even start development by first specifying
    tests. A useful tool for automatic testing is the module `unittest`, which we
    explained in detail. While testing improves the reliability of code, profiling
    is needed to improve the performance. Alternative ways to code may result in large
    performance differences. We showed how to measure computation time and how to
    localize bottlenecks in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5 Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1:** Two matrices ![](img/2d8e6f34-43b2-4e70-82aa-0403dfc9d4e9.png) are
    called similar if there exists a matrix ![](img/2a9104de-2907-4372-acd8-224c1bc3e52c.png),
    such that ![](img/9eb00513-26a8-4b51-bc70-69e23ce0e356.png). The matrices ![](img/bda68266-6133-47e1-af9f-7ceb31af3bb3.png)
    and *![](img/b1ee0969-d1f6-4ca0-b59e-952e73467c51.png)* have the same eigenvalues.
    Write a test checking that two matrices are similar, by comparing their eigenvalues.
    Is it a functional or a unit test?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2:** Create two vectors of large dimensions. Compare the execution time
    of various ways to compute their dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SciPy function: `v @ w`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator and sum: `sum((x*y for x,y in zip(v,w)))`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensive list and sum: `sum([x*y for x,y in zip(v,w)])`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ex. 3:** Let ![](img/3526771a-a59b-41d5-83c6-f33e83a0e3cb.png) be a vector.
    The vector ![](img/bc63c3f4-50dc-4b1c-be52-85d26cfad5bb.png) with components'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/084b74cc-dc2c-42bf-a28c-da33c7175588.png)'
  prefs: []
  type: TYPE_IMG
- en: 'is called a moving average of ![](img/8ac291cf-4704-4bef-8bc3-988982c3b547.png).
    Determine which of the two alternatives to compute ![](img/76df3e80-0678-45d1-9303-c3644ca27e70.png)
    is faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
