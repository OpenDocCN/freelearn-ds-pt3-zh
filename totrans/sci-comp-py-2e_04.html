<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Linear Algebra - Arrays
                </header>
            
            <article>
                
<p class="CDPAlignLeft CDPAlign">Linear algebra is one of the essential building blocks of computational mathematics. The objects of linear algebra are vectors and matrices. The package NumPy includes all the necessary tools to manipulate those objects.</p>
<p>The first task is to build matrices and vectors or to alter existing ones by slicing. The other main task is the dot operation, which embodies most linear algebra operations (scalar product, matrix-vector product, and matrix-matrix product). Finally, various methods are available to solve linear problems.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Overview of the array type</li>
<li>Mathematical preliminaries</li>
<li>The array type</li>
<li>Accessing array entries</li>
<li>Functions to construct arrays </li>
<li>Accessing and changing the shape</li>
<li>Stacking </li>
<li>Functions acting on arrays </li>
<li>Linear algebra methods in SciPy</li>
</ul>
<h1 id="uuid-68307cfe-7a8d-4f5f-8918-57861f216afd">4.1 Overview of the array type</h1>
<p>For the impatient, here is how to use arrays in a nutshell. Be aware though that the behavior of arrays may be surprising at first, so we encourage you to read on after this introductory section.</p>
<p>Note again, the presentation in this chapter assumes like everywhere else in this book that you have the module NumPy imported:</p>
<pre>from numpy import *</pre>
<p>By importing NumPy, we give access to the datatype <kbd>ndarray</kbd>, which we'll describe in the next sections. </p>
<h2 id="uuid-40116a6e-9887-4708-886c-b7b086c374f5">4.1.1 Vectors and matrices</h2>
<p>Creating vectors is as simple as using the function <kbd>array</kbd> to convert a list into an array:</p>
<pre>v = array([1.,2.,3.])</pre>
<p>The object<span> </span><kbd>v</kbd> is now a vector that behaves much like a vector in linear algebra. We have already emphasized the differences with the list object in Python in <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.2</a>: <em>A quick glance at the concept of arrays</em>.</p>
<p>Here are some illustrations of the basic linear algebra operations on vectors:</p>
<pre># two vectors with three components
v1 = array([1., 2., 3.])
v2 = array([2, 0, 1.])

# scalar multiplications/divisions
2*v1 # array([2., 4., 6.])
v1/2 # array([0.5, 1., 1.5])

# linear combinations
3*v1 # array([ 3., 6., 9.])
3*v1 + 2*v2 # array([ 7., 6., 11.])

# norm
from numpy.linalg import norm
norm(v1) # 3.7416573867739413
# scalar product
dot(v1, v2) # 5.0
v1 @ v2 # 5.0 ; alternative formulation</pre>
<p>Note that all basic arithmetic operations are performed elementwise:</p>
<pre># elementwise operations:
v1 * v2 # array([2., 0., 3.])
v2 / v1 # array([2.,0.,.333333])
v1 - v2 # array([-1., 2., 2.])/
v1 + v2 # array([ 3., 2., 4.])</pre>
<p>Some functions act elementwise on arrays as well:</p>
<pre>cos(v1) # cosine, elementwise: array([ 0.5403, -0.4161, -0.9899])</pre>
<p>This subject will be covered in <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section</a><span> 4.8: </span><em>Functions acting on arrays.</em></p>
<p>A matrix is created in a similar way to a vector, but from a list of lists instead:</p>
<pre>M = array([[1.,2],[0.,1]])</pre>
<p class="mce-root">Note, vectors are not column or row matrices<span>. </span>An <span><img class="fm-editor-equation" src="assets/dd804db6-ce44-4feb-b8b6-359bc63442df.png" style="width:0.83em;height:0.75em;"/></span> vector, an <img class="fm-editor-equation" src="assets/75c70cc7-6946-4e16-af4b-c6ba929f7142.png" style="width:2.33em;height:0.83em;"/>, and a <img class="fm-editor-equation" src="assets/6f7b05e6-6f92-4cef-831d-790496c52a3b.png" style="width:2.50em;height:0.83em;"/> matrix are three different objects even if they contain the same data.</p>
<p>To create a row matrix containing the same data as the vector<span> </span><kbd>v = array([1., 2., 1.])</kbd>, we apply the method <kbd>reshape</kbd>:</p>
<pre>R = v.reshape((1,3))
shape(R)                # (1,3): this is a row matrix</pre>
<p>The corresponding column matrix is obtained by <kbd>reshape</kbd> in a corresponding manner:</p>
<pre>C = v.reshape((3, 1))
shape(C) # (3,1): this is a column matrix</pre>
<p>After having learned how to create arrays and after having seen basic array operations, we will study now how array elements and subarrays can be addressed by indexing and slicing.</p>
<h2 id="uuid-bda94725-6401-4858-af6a-49d18c875dd8">4.1.2 Indexing and slices</h2>
<p>Indexing and slicing are similar to the corresponding operations for lists. The main difference is that there may be several indexes or slices when the array is a matrix. The subject will be covered in depth in <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section 4.4.1</a>: <em>Basic array slicing</em>; here, we just give some illustrative examples of indexing and slicing:</p>
<pre>v = array([1., 2., 3])
M = array([[1., 2],[3., 4]])

v[0] # works as for lists
v[1:] # array([2., 3.])

M[0, 0] # 1.
M[1:] # returns the matrix array([[3., 4]])
M[1] # returns the vector array([3., 4.])

# access
v[0] # 1.
v[0] = 10

# slices
v[:2] # array([10., 2.])
v[:2] = [0, 1] # now v == array([0., 1., 3.])
v[:2] = [1, 2, 3] # error!</pre>
<p>As arrays are the basic datatype for all tasks in computational linear algebra, we <span>now</span><span> </span><span>present in this overview section some examples, the dot product and the solution of linear equation systems.</span></p>
<h2 id="uuid-7a0d86f3-f71e-44f5-a08b-8cfc3685611f">4.1.3 Linear algebra operations</h2>
<p>The essential operator that performs most of the usual operations of linear algebra is the Python function <kbd>dot</kbd>. It is used for matrix-vector multiplications (see <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section 4.2.4</a>: <em>The dot operations</em> for more details):</p>
<pre>dot(M, v) # matrix vector multiplication; returns a vector
M @ v # alternative formulation</pre>
<p>It may be used to compute a scalar product between two vectors:</p>
<pre>dot(v, w) <br/># scalar product; the result is a scalar
v @ w # alternative formulation</pre>
<p>Lastly, it is<span> </span>used to compute matrix-matrix products:</p>
<pre>dot(M, N) # results in a matrix
M @ N # alternative formulation</pre>
<h3 id="uuid-ea3de2f8-3ae5-4e59-80ee-62bebe288ac7">Solving a linear system</h3>
<p>If <sub><img class="fm-editor-equation" src="assets/d658ccfe-c6c7-4c0f-9b56-efc5b11df1c4.png" style="width:0.75em;height:1.00em;"/></sub> is a matrix and <sub><img class="fm-editor-equation" src="assets/16de0f6a-2627-450c-bd4f-0d2a6fab42a3.png" style="width:0.50em;height:1.00em;"/></sub> is a vector, you can solve the linear equation system</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1378855e-0cd6-4a0c-b7e0-23e04a9d4809.png" style="width:3.33em;height:0.92em;"/></div>
<p>by using the function <kbd>solve</kbd> from the linear algebra submodule <kbd>numpy.linalg</kbd>:</p>
<pre>from numpy.linalg import solve
x = solve(A, b)</pre>
<p>For example, to solve</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b6d5dd31-f278-4cf2-8ab2-cd4287fa3b29.png" style="width:9.42em;height:2.67em;"/></p>
<p>the following Python statements are executed:</p>
<pre>from numpy.linalg import solve
A = array([[1., 2.], [3., 4.]])
b = array([1., 4.])
x = solve(A, b)
allclose(dot(A, x), b) # True
allclose(A @ x, b) # alternative formulation</pre>
<p>The command<span> </span><kbd>allclose</kbd><span> </span>is<span> </span>used here to compare two vectors. If they are close enough to each other, this command returns<span> </span><kbd>True</kbd>. Optionally a tolerance value can be set. For more methods related to linear equation systems, see <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section</a><span> 4.9:</span><span> </span><em>Linear algebra methods in SciPy</em>.</p>
<p>Now, you have seen the first and essential way of how to use arrays in Python. In the following sections, we'll show you more details and the underlying principles.</p>
<h1 id="uuid-91298146-bcef-47d1-81a1-c6d4afc0c306">4.2 Mathematical preliminaries</h1>
<p>In order to understand how arrays work in NumPy, it is useful to understand the mathematical parallel between accessing tensor (matrix and vector) elements by indexes and evaluating mathematical functions by providing arguments. We also cover in this section the generalization of the dot product as a reduction operator.</p>
<h2 id="uuid-e28e0397-90e0-4d9c-8886-ad5393e83454">4.2.1 Arrays as functions</h2>
<p>Arrays may be considered from several different points of view<span>. If you want to approach the concept from a mathematical point of view, you might benefit from </span>understanding arrays through an analogy of functions of several variables<span>. This view will later be taken again, when explaining the concept of broadcasting in</span> <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml"><span>S</span><span>ection</span></a><span> 5.5: </span><em>Broadcasting</em><em>.</em></p>
<p>For instance, selecting a component of a given vector in <img class="fm-editor-equation" src="assets/0827edf6-8019-496b-87da-a611639c6ab4.png" style="width:1.33em;height:1.00em;"/>may just be considered a function from the set of <span><img class="fm-editor-equation" src="assets/49fb25fc-995c-4a1c-b7db-fb0ca393e72e.png" style="width:1.25em;height:1.00em;"/></span> to <img class="fm-editor-equation" src="assets/cab4aa7c-b61f-459e-afa8-71cd5baa66f1.png" style="width:0.75em;height:1.00em;"/>, where we define the set:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/f1785531-d885-4fce-80da-fc35bec04dbe.png" style="width:10.67em;height:1.33em;"/></div>
<p>Here the set <span><img class="fm-editor-equation" src="assets/9ff103aa-3603-4365-9d45-818b85a2c38d.png" style="width:1.42em;height:1.17em;"/></span> has<span> </span><em>n</em><span> </span>elements. The Python function<span> </span><kbd>range</kbd><span> </span>generates <sub><em><span><img class="fm-editor-equation" src="assets/45ed4521-0799-4a89-9601-da50700491a7.png" style="width:1.33em;height:1.08em;"/></span></em></sub>.</p>
<p>Selecting an element of a given matrix, on the other hand, is a function of two parameters, taking its value in <img class="fm-editor-equation" src="assets/2dd26863-2ac9-4c48-83ef-25700ef810e6.png" style="width:0.83em;height:1.00em;"/>. Picking a particular element of an<span> </span><em><img class="fm-editor-equation" src="assets/07d6e38b-b49b-4337-8925-160b771356ab.png" style="width:3.25em;height:0.75em;"/></em> matrix may thus be considered a function from <span><img class="fm-editor-equation" src="assets/5398c6ee-de44-43c1-b7fb-7c30dbfe6117.png" style="width:3.92em;height:1.00em;"/></span> to <img class="fm-editor-equation" src="assets/f0d6533e-221c-4d66-8138-a00f24e830e0.png" style="width:0.75em;height:1.00em;"/>.</p>
<h2 id="uuid-1d952a7a-91b8-49a7-ade6-9cc3cbabf890">4.2.2 Operations are elementwise</h2>
<p>NumPy arrays are essentially treated as mathematical functions. This is in particular true for operations. Consider two functions, <img class="fm-editor-equation" src="assets/4cdad02e-e6f4-4c17-95c7-bfd5cf329282.png" style="width:0.58em;height:1.08em;"/> and <img class="fm-editor-equation" src="assets/6acb3ba5-69f9-4970-a5f4-90f7281ac936.png" style="width:0.58em;height:1.08em;"/>, defined on the same domain and taking real values. The product <img class="fm-editor-equation" src="assets/8bd32329-08fb-4861-b05a-64b90be30405.png" style="width:1.75em;height:1.08em;"/> of those two functions is defined as the pointwise product, that is,</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/1e717cdf-b96e-492a-a775-81175e062d39.png" style="width:10.33em;height:1.25em;"/></p>
<p>Note that this construction is possible for any operation between two functions. For an arbitrary operation defined on two scalars, which we denote here by<span> <img class="fm-editor-equation" src="assets/17a32615-8ff1-488f-b7df-8fc015e28be2.png" style="width:0.67em;height:0.83em;"/></span>, we could define<span> </span><img class="fm-editor-equation" src="assets/4e03099d-ba8c-47a9-865e-a675a56e4e02.png" style="width:2.17em;height:1.25em;"/> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9564f5b5-d0d8-45d1-9a6a-f8d3968aac02.png" style="width:12.83em;height:1.50em;"/></p>
<p>This innocuous remark allows us to understand NumPy's stance on operations; all operations are elementwise in arrays. For instance, the product between two matrices,<span> </span><span><img class="fm-editor-equation" src="assets/498ba54b-8eb4-40c7-9b03-4ff15b67a00d.png" style="width:1.00em;height:0.75em;"/></span> and <span><img class="fm-editor-equation" src="assets/2aa90bb5-7dbc-4b46-9e63-053f3c934bcf.png" style="width:0.92em;height:0.75em;"/></span>, is defined, as with functions, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9fc20d80-879e-43b3-be9d-6d65c0bd6d78.png" style="width:9.00em;height:1.50em;"/></p>
<h2 id="uuid-6af97795-de0a-4297-a9da-0277bde80ffb">4.2.3 Shape and number of dimensions</h2>
<p>There is a clear distinction between a:</p>
<ul>
<li><em>Scalar:</em> A function with no arguments</li>
<li><em>Vector:</em> A function with one argument</li>
<li><em>Matrix:</em> A function with two arguments</li>
<li><em>Higher-order tensor</em>: A function with more than two arguments</li>
</ul>
<p>In what follows, the number of dimensions is the number of arguments of a function. The shape corresponds essentially to the domain of a function.</p>
<p>For instance, a vector of size<span> </span><em>n</em><span> </span>is a function from the set <img class="fm-editor-equation" src="assets/3e022549-3df7-4296-89f7-f07c4a254201.png" style="width:1.58em;height:1.25em;"/><span> </span>to <img class="fm-editor-equation" src="assets/67c574fe-7309-413d-bc56-5dbfee30661e.png" style="width:0.92em;height:1.08em;"/>. As a result, its domain  is <img class="fm-editor-equation" src="assets/914d84e0-9c6a-4895-9e11-c42f794a770a.png" style="width:1.58em;height:1.33em;"/>. Its shape is defined as the singleton (<em>n,</em>). Similarly, a matrix of size <span><img class="fm-editor-equation" src="assets/61fcaba3-7269-4d3d-b042-734057d63e0b.png" style="width:3.42em;height:0.83em;"/></span><span> </span>is a function defined on <img class="fm-editor-equation" src="assets/cbf9a605-eaf9-45d2-843e-ee7498361ef6.png" style="width:4.17em;height:1.08em;"/>. The corresponding shape is simply the pair (<em>m</em>,<span> </span><em>n</em>). The shape of an array is obtained by the function <kbd>numpy.shape</kbd>, and the number of dimensions by the function<span> </span><kbd>numpy.ndim</kbd>; see also <a href="b9f628e9-f682-41be-b5a6-94359f8629fc.xhtml">Section 4.6</a>: <em>Accessing and changing the shape</em>.</p>
<h2 id="uuid-53cd52db-90ab-40ec-91ee-44e22608b19d">4.2.4 The dot operations</h2>
<p>Treating arrays as functions, although very powerful, completely neglects the linear algebra structures we are familiar with, that is, matrix-vector and matrix-matrix operations. Fortunately, these linear algebra operations may all be written in a similar unified form:</p>
<p>The vector-vector operation:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/5d4531ef-e516-4ea5-907d-0de7b6edc077.png" style="width:7.17em;height:3.17em;"/></div>
<p>The matrix-vector operation:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6b07789a-b088-40b2-aa11-da31e046119c.png" style="width:7.42em;height:3.00em;"/></div>
<p>The matrix-matrix<span> </span><span>operation</span>:</p>
<div class="CDPAlignCenter CDPAlign"><span><img class="fm-editor-equation" src="assets/d1e4e002-ee95-448c-91bd-4c9ecfa7120d.png" style="width:9.08em;height:2.83em;"/></span></div>
<p class="mce-root"/>
<p>The vector-matrix<span> </span><span>operation</span>:</p>
<div class="CDPAlignCenter CDPAlign"><span><img class="fm-editor-equation" src="assets/91a09614-743b-4b57-8b5c-2b98fd13232b.png" style="width:8.75em;height:3.25em;"/></span></div>
<p>The essential mathematical concept is that of reduction. For a matrix-vector operation, the reduction is given by:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/aec07b60-4dd3-4aa2-a52c-c21caae0c27d.png" style="width:5.17em;height:3.33em;"/></div>
<p>In general, a reduction operation defined between two tensors, <span><img class="fm-editor-equation" src="assets/1f0c151e-39a4-4e33-b6cf-23789680aa6e.png" style="width:0.83em;height:1.00em;"/></span><span> </span>and <span><img class="fm-editor-equation" src="assets/8016ef96-8baa-48ac-80e0-56016e765985.png" style="width:0.92em;height:1.08em;"/></span><span>, </span>of respective number of dimensions <span><img class="fm-editor-equation" src="assets/58f0e0a7-a065-40a0-82b0-d8c685294696.png" style="width:1.08em;height:0.75em;"/> </span>and <span><img class="fm-editor-equation" src="assets/cfd803fd-209a-4fa1-82cc-b2fa4237e1ac.png" style="width:0.67em;height:0.67em;"/></span><span> </span>may be defined as:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/6d735bf5-14bf-40c0-b43b-3347aab64854.png" style="width:35.67em;height:4.00em;"/></div>
<p>Clearly, the shapes of the tensors must be compatible with that operation to make<br/>
any sense. This requirement is familiar for matrix-matrix multiplication. The multiplication<span> <img class="fm-editor-equation" src="assets/e5b3c2c8-d223-4b63-9afe-67c3946130b2.png" style="width:1.58em;height:0.67em;"/> <br/></span>of matrices<span> <img class="fm-editor-equation" src="assets/40c5c7dc-0cc9-4c09-b130-5ed416713e2c.png" style="width:1.08em;height:0.92em;"/></span> and <em><img class="fm-editor-equation" src="assets/2ed6b962-1034-42c4-bcd7-9f6df445ef53.png" style="width:0.92em;height:0.83em;"/></em> only makes sense if the number of columns of <span><img class="fm-editor-equation" src="assets/3f6cc52f-5279-45b4-ab25-c779292f6c32.png" style="width:1.00em;height:0.83em;"/> </span>equals the number of rows of <em><img class="fm-editor-equation" src="assets/4fc01d29-fe44-4681-8146-b4b1da231ed4.png" style="width:0.83em;height:0.83em;"/></em>.</p>
<p>Another consequence of the reduction operation is that it produces a new tensor with<span> <img class="fm-editor-equation" src="assets/907b8b22-fae5-42f9-bff7-b0381719d8fa.png" style="width:4.92em;height:1.00em;"/> </span>dimensions. In <em>Table 4.1</em>, we gather the output of the reduction operation for the familiar cases involving matrices and vectors:</p>
<table style="border-collapse: collapse;width: 100%;border-color: #000000" border="1">
<tbody>
<tr style="height: 10px">
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><strong><img class="fm-editor-equation" src="assets/badb856c-cd63-4a10-a3c2-8d733fd6ecc6.png" style="width:9.75em;height:1.42em;"/></strong></p>
</td>
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><strong><img class="fm-editor-equation" src="assets/61296058-9a76-48b0-a429-4e031bf7f616.png" style="width:9.75em;height:1.42em;"/></strong></p>
</td>
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><strong><img class="fm-editor-equation" src="assets/a80b9a58-4dbc-4325-ba0b-20a3c0b6c80c.png" style="width:7.08em;height:1.42em;"/></strong></p>
</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/28959d31-3da1-4a37-b9ba-a658517250f8.png" style="width:5.00em;height:1.42em;"/></p>
</td>
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/669e969c-43c9-462d-8448-9d6663e312eb.png" style="width:4.67em;height:1.42em;"/></p>
</td>
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/72498382-abab-44ee-ba00-50bbbfecc71e.png" style="width:4.83em;height:1.42em;"/></p>
</td>
</tr>
<tr style="height: 15.5332px">
<td style="height: 15.5332px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/9c3f79f5-ffa7-4480-8e0a-590a2a493fe5.png" style="width:4.75em;height:1.33em;"/></p>
</td>
<td style="height: 15.5332px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/f6d4ee8a-e85c-4952-a3d1-e6810b28d983.png" style="width:5.00em;height:1.42em;"/></p>
</td>
<td style="height: 15.5332px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/c6bd4cfd-a634-4531-90b9-69050d2a9ac0.png" style="width:4.67em;height:1.33em;"/></p>
</td>
</tr>
<tr style="height: 10px">
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/9e9cd9c3-4a88-4eb3-b242-a59c8b0b2b13.png" style="width:4.67em;height:1.42em;"/></p>
</td>
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/742d6bd6-3c77-497f-8f05-ba91268a2709.png" style="width:4.75em;height:1.42em;"/></p>
</td>
<td style="height: 10px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/ab0a2853-845f-403d-818a-9163956b0ba9.png" style="width:4.25em;height:1.33em;"/></p>
</td>
</tr>
<tr style="height: 32px">
<td style="height: 32px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/74866b6c-26bb-499a-bfc9-93c23837a315.png" style="width:4.67em;height:1.42em;"/></p>
</td>
<td style="height: 32px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/f8606684-f88f-4c51-991c-29b266868d6e.png" style="width:4.50em;height:1.25em;"/></p>
</td>
<td style="height: 32px" class="CDPAlignCenter CDPAlign">
<p><img class="fm-editor-equation" src="assets/7c5146dc-ee25-4f2b-867d-f726be6c87ab.png" style="width:4.67em;height:1.42em;"/></p>
</td>
</tr>
</tbody>
</table>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">​Table 4.1: Output of the reduction operation involving matrices and vectors</div>
<p>In Python, all reduction operations are performed using the<span> </span><kbd>dot</kbd> function or alternatively the <kbd>@</kbd> operator:</p>
<pre>angle = pi/3
M = array([[cos(angle), -sin(angle)], 
           [sin(angle), cos(angle)]])
v = array([1., 0.])
y = dot(M, v)</pre>
<p>In Python version 3.5 or higher, the dot product can be written either in its operator form,<span> </span><kbd>dot(M, v)</kbd>, or by using the infix notation,<span> </span><kbd>M @ v</kbd>. From now on we'll<span> </span>stick<span> </span>to the more handy infix notation; you can modify the examples if the other form is preferred. We note, however, that <kbd>dot</kbd> performs type casting to arrays if its arguments are of other types that can be cast to an array, such as list or float. The infix operator form with <kbd>@</kbd> does not have this feature.</p>
<p class="mce-root">The multiplication operator<span> </span><kbd>*</kbd><span> </span>is always elementwise. It has nothing to do with the dot operation. Even if<span> </span><em><img class="fm-editor-equation" src="assets/04ede9d1-0823-4b24-a5e7-fc247edcc0fa.png" style="width:0.92em;height:1.00em;"/> </em>is a matrix and <span><img class="fm-editor-equation" src="assets/8d8c60e1-cd74-45d6-9ec6-1798e72a0077.png" style="width:0.67em;height:0.83em;"/></span> is a vector, <span><kbd>A*v</kbd></span> is still a legal operation. This will be explained in <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.5</a>: <em>Broadcasting</em>.</p>
<p>In this section, we identified the use of arrays with matrices and vectors in mathematics and explained operations. In particular, the most central operation in scientific computation, the dot product, was explained. We turn now to the array datatype <kbd>ndarray</kbd> and its methods more generally.</p>
<h1 id="uuid-dc4931e9-47be-44de-970d-ff5c8f0b40d6">4.3 The array type</h1>
<p>The objects used to manipulate vectors, matrices, and more general tensors in NumPy are called ndarrays, or just arrays for short. In this section, we examine their essential properties, how to create them, and how to access their information.</p>
<h2 id="uuid-487823f2-5495-4f9c-89d5-ec7a8ae9c651">4.3.1 Array properties</h2>
<p>Arrays are essentially characterized by the three properties, described in <em>Table 4.2</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Name</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>shape</kbd></p>
</td>
<td>
<p>This describes how the data should be interpreted, as a vector, a matrix, or a higher-order tensor, and it gives the corresponding dimension. It is accessed with the<span> attribute </span><kbd>shape</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>dtype</kbd></p>
</td>
<td>
<p>This gives the type of the underlying data (float, complex, integer, and so on).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>strides</kbd></p>
</td>
<td>
<p>This attribute specifies in which order the data should be read. For instance, a matrix could be stored in memory contiguously column by column (FORTRAN convention), or row by row (C convention). The attribute is a tuple with the numbers of bytes that have to be skipped in memory to reach the next row and the number of bytes to be skipped to reach the next column. It even allows for a more flexible interpretation of the data in memory, which is what makes array views possible.</p>
</td>
</tr>
</tbody>
</table>
<div style="padding-left: 210px" class="packt_figref CDPAlignLeft CDPAlign">Table 4.2: The three characterizing properties of an array</div>
<p>Consider, for example, the following array:</p>
<pre>A = array([[1, 2, 3], [3, 4, 6]])
A.shape   # (2, 3)
A.dtype   # dtype('int64')
A.strides # (24, 8)</pre>
<p>Its elements have the type<span> </span><kbd>'int64'</kbd>; that is, they use 64 bits or 8 bytes in memory. The complete array is stored in memory row-wise. The distance from<span> </span><kbd>A[0, 0]</kbd><span> </span>to the first element in the next row<span> </span><kbd>A[1,0]</kbd><span> </span>is thus 24 bytes (three matrix elements) in memory. Correspondingly, the distance in memory between<span> </span><kbd>A[0,0]</kbd><span> </span>and<span> </span><kbd>A[0,1]</kbd><span> </span>is 8 bytes (one matrix element). These values are stored in the attribute<span> </span><kbd>strides</kbd>.</p>
<h2 id="uuid-4ed27529-6bfd-4943-add7-0a511b31bd7f">4.3.2 Creating arrays from lists</h2>
<p>The general way to create an array is by using the function<span> </span><kbd>array</kbd>. The syntax to create a real-valued vector would be:</p>
<pre>V = array([1., 2., 1.], dtype=float)</pre>
<p>To create a complex vector with the same data, you use:</p>
<pre>V = array([1., 2., 1.], dtype=complex)</pre>
<p>When no type is specified, the type is guessed. The<span> </span><kbd>array</kbd><span> </span>function chooses the type that allows storing all the specified values:</p>
<pre>V = array([1, 2]) # [1, 2] is a list of integers
V.dtype # int64
V = array([1., 2]) # [1., 2] mix float/integer
V.dtype # float64
V = array([1. + 0j, 2.]) # mix float/complex
V.dtype # complex128</pre>
<p>NumPy silently casts floats into integers, which might give unexpected results:</p>
<pre>a = array([1, 2, 3])
a[0] = 0.5
a # now: array([0, 2, 3])</pre>
<p>The same, often unexpected array type casting happens from <kbd>complex</kbd> to <kbd>float</kbd>.</p>
<h3 id="uuid-71d942fc-424f-4868-8d38-446315e22819"><strong>Array and Python parentheses</strong></h3>
<p>As we noticed in <a href="cbb0e54a-9e37-4356-8553-6f051956f80e.xhtml">Section 1.2.2</a>: <em>Line joining</em>, Python allows a line break when some opening brace or parenthesis is not closed. This allows a convenient syntax for array creation, which makes it more pleasing to the human eye:</p>
<pre># the identity matrix in 2D
Id = array([[1., 0.], [0., 1.]])
# Python allows this:
Id = array([[1., 0.],
            [0., 1.]])
# which is more readable</pre>
<p>So far, you saw a lot of differences in the definition and use between arrays and lists. Accessing array elements, in contrast, seems quite similar to the way list elements are accessed. But especially the use of multiple indexes and the resulting objects from the slicing operations require that we look at these issues in more detail.</p>
<h1 id="uuid-91cad039-a035-4f88-8ff5-0b9671098199">4.4 Accessing array entries</h1>
<p>Array entries are accessed by indexes. In contrast to vector coefficients, two indexes are needed to access matrix coefficients. These are given in one pair of brackets. This distinguishes the array syntax from a list of lists. There, two pairs of brackets are needed to access elements.</p>
<pre>M = array([[1., 2.],[3., 4.]])
M[0, 0] # first row, first column: 1.0
M[-1, 0] # last row, first column: 3.0</pre>
<p>Let's look now in more detail at the use of double indexes and slices.</p>
<h2 id="uuid-4b717441-3b74-4ea7-8cfa-cc8b97409830">4.4.1 Basic array slicing</h2>
<p>Slices are similar to those of lists (see also <a href="c4f97b8b-36c4-4db4-9e58-02aac275b257.xhtml">Section 3.1.1</a>: <em>Slicing</em>) except that they might now be in more than one dimension:</p>
<ul>
<li><kbd>M[i,:]</kbd><span> </span>is a vector filled by the row <span><img class="fm-editor-equation" src="assets/60a8e43a-37e5-406e-bad5-90981a04b955.png" style="width:0.50em;height:1.25em;"/> </span>of <span><img class="fm-editor-equation" src="assets/c0e17bfb-4fea-4289-9f4f-582181cc5699.png" style="width:1.25em;height:1.00em;"/></span><em>.</em></li>
<li><span><kbd>M[:,j]</kbd> </span>is a vector filled by the column<span> <img class="fm-editor-equation" src="assets/47def328-ef21-466c-8046-1574defb7ec6.png" style="width:0.50em;height:1.00em;"/></span><span> </span>of <span><img class="fm-editor-equation" src="assets/450c6166-8464-42a9-b6c1-acce375705c0.png" style="width:1.08em;height:0.92em;"/></span><em>.</em></li>
<li><span><kbd>M[2:4,:]</kbd> </span>is a slice of <kbd>2:4</kbd><span> </span>on the rows only.</li>
<li><span><kbd>M[2:4,1:4]</kbd> </span>is a slice of rows and columns.</li>
</ul>
<p>The result of matrix slicing is given in the following <em>Figure 4.1</em>:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/b07bb9d1-b49f-46b6-9d8d-9d8db197d47e.png" style="width:40.58em;height:30.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 4.1: The result of matrix slicing</div>
<p class="mce-root">If you omit an index or a slice, NumPy assumes you are taking rows only.<span> </span><kbd>M[3]</kbd><span> </span>is a vector that is a view on the third row of<span> </span><em>M </em>and <kbd>M[1:3]</kbd><span> </span>is a matrix that is a view on the second and third rows of <span><img class="fm-editor-equation" src="assets/26f718b7-5dab-4498-99cf-52a2ff1616a6.png" style="width:1.17em;height:1.00em;"/></span><em>.</em></p>
<p>Changing the elements of a slice affects the entire array (see also <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.1</a>: <em>Array views and copies</em>):</p>
<pre>v = array([1., 2., 3.])
v1 = v[:2] # v1 is array([1., 2.])
v1[0] = 0. # if v1 is changed ...
v # ... v is changed too: array([0., 2., 3.])</pre>
<p>General slicing rules are given in <em>Table 4.3</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr style="height: 34px">
<td class="CDPAlignCenter CDPAlign">
<p><strong>Access</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>ndim</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Kind</strong></p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>index, index</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>0</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>scalar</p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>slice, index</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>1</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>vector</p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p>index, slice</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>1</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>vector</p>
</td>
</tr>
<tr style="height: 29.8945px">
<td class="CDPAlignCenter CDPAlign">
<p>slice, slice</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>2</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>matrix</p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 4.3: General slicing rules</div>
<p>The results of slicing operations for an array<span> </span><kbd>M</kbd><span> </span>of shape<span> </span><em>(4, 4)</em><span> </span>are given in <em>Table 4.4</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p><strong>Access</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Shape</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>ndim</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Kind</strong></p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p><kbd>M[:2, 1:-1]</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>(2,2)</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>2</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>matrix</p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p><kbd>M[1,:]</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>(4,)</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>1</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>vector</p>
</td>
</tr>
<tr style="height: 10px">
<td class="CDPAlignCenter CDPAlign">
<p><kbd>M[1,1]</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>()</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>0</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>scalar</p>
</td>
</tr>
<tr style="height: 38.3828px">
<td class="CDPAlignCenter CDPAlign">
<p><kbd>M[1:2,:]</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>(1,4)</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>2</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>matrix</p>
</td>
</tr>
<tr style="height: 33px">
<td class="CDPAlignCenter CDPAlign">
<p><kbd>M[1:2, 1:2]</kbd></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>(1,1)</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>2</p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p>matrix</p>
</td>
</tr>
</tbody>
</table>
<div style="padding-left: 90px" class="packt_figref"/>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 4.4: Result of slicing operations for an array M of shape (4,4)</div>
<h2 id="uuid-87316327-724c-4a66-9354-cb2de169dfe4">4.4.2 Altering an array using slices</h2>
<p>You may alter an array using slices or by direct access. The following changes only one element in a <img class="fm-editor-equation" src="assets/b44e53a3-95ce-43a3-a6b4-3616878d891c.png" style="width:2.58em;height:1.00em;"/> matrix<span> <img class="fm-editor-equation" src="assets/c54c7a2c-59a0-4e88-bb60-28e29b2a1852.png" style="width:1.17em;height:0.92em;"/>:</span></p>
<pre>M[1, 2] = 2.0 # scalar</pre>
<p>Also, we may change one full row of the matrix:</p>
<pre>M[2, :] = [1., 2., 3.] # vector</pre>
<p>Similarly, we may also replace a full submatrix:</p>
<pre>M[1:3, :] = array([[1., 2., 3.],[-1.,-2., -3.]])</pre>
<p class="mce-root">There is a distinction between a column matrix and a vector. The following assignment with a column matrix returns no error:<span> </span></p>
<pre class="mce-root">M[1:4, 1:2] = array([[1.],[0.],[-1.0]])<span> </span></pre>
<p class="mce-root">while the assignment with a vector returns a<span> </span><kbd>ValueError</kbd><span>:</span></p>
<pre class="mce-root">M[1:4, 1:2] = array([1., 0., -1.0]) #  error</pre>
<p>The general slicing rules are shown in<span> </span><em>Table 4.3</em>. The matrices and vectors in the preceding examples must have the right size to fit into matrix <span><img class="fm-editor-equation" src="assets/b75a4632-4ef1-495c-891e-1184dfa2bc58.png" style="width:0.92em;height:0.75em;"/></span>. You may also make use of the broadcasting rules (see <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.5</a>: <em>Broadcasting</em>) to determine the allowed size of the replacement arrays. If the replacement array does not have the right shape, a<span> </span><kbd>ValueError</kbd><span> </span>exception will be raised.</p>
<p>We saw how to construct arrays from other arrays by slicing. In the next section, we will consider special NumPy functions that are useful to directly create and initialize arrays.</p>
<h1 id="uuid-d3bc2ad4-5168-45aa-988e-18e2eda1b7c3">4.5 Functions to construct arrays</h1>
<p>The usual way to set up an array is via a list. But there are also a couple of convenient methods for generating special arrays, which are given in <em>Table 4.5</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>
<p><strong>Methods</strong></p>
</td>
<td>
<p><strong>Shape</strong></p>
</td>
<td>
<p><strong>Generates</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>zeros((n,m))</kbd></p>
</td>
<td>
<p><em>(n,m)</em></p>
</td>
<td>
<p>Matrix filled with zeros</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ones((n,m)) </kbd></p>
</td>
<td>
<p><em>(n,m)</em></p>
</td>
<td>
<p>Matrix filled with ones</p>
</td>
</tr>
<tr>
<td>
<p><kbd>full((n,m),q)</kbd></p>
</td>
<td>
<p><em>(n,m)</em></p>
</td>
<td>
<p>Matrix filled with <img class="fm-editor-equation" src="assets/d4907979-e755-4827-ae0b-318783930a2d.png" style="width:0.42em;height:0.67em;"/></p>
</td>
</tr>
<tr>
<td>
<p><kbd>diag(v,k) </kbd></p>
</td>
<td>
<p><em>(n,n)</em></p>
</td>
<td>
<p>(Sub-, super-) diagonal matrix from a vector <span><img class="fm-editor-equation" src="assets/9cb240a7-8fe3-4f7a-862a-2057841ca009.png" style="width:0.50em;height:0.58em;"/></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>random.rand(n,m) </kbd></p>
</td>
<td>
<p><em>(n,m)</em></p>
</td>
<td>
<p>Matrix filled with uniformly distributed random numbers in <kbd>(0,1)</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>arange(n)</kbd></p>
</td>
<td>
<p><em>(n,)</em></p>
</td>
<td>
<p>First <span><img class="fm-editor-equation" src="assets/cacd22ff-75a8-40a9-ad1d-b8e06d0c8dd9.png" style="width:0.58em;height:0.58em;"/></span><span> </span>integers</p>
</td>
</tr>
<tr>
<td>
<p><kbd>linspace(a,b,n) </kbd></p>
</td>
<td>
<p><em>(n,)</em></p>
</td>
<td>
<p>Vector with <img class="fm-editor-equation" src="assets/76197639-ef19-4b09-89f0-b6702c4638f1.png" style="width:0.58em;height:0.58em;"/><span> </span>equispaced points between <span><img class="fm-editor-equation" src="assets/a68eb689-1673-4372-a195-a071d550b333.png" style="width:0.67em;height:0.67em;"/></span><span> </span>and <span><img class="fm-editor-equation" src="assets/86a00f21-9e02-489e-9ea3-cdd43faa105e.png" style="width:0.42em;height:1.00em;"/></span></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_figref CDPAlignCenter CDPAlign">Table 4.5: Commands to create arrays</div>
<p class="CDPAlignLeft CDPAlign">These commands may take additional arguments. In particular, the commands<span> </span><kbd>zeros</kbd>,<span> </span><kbd>ones</kbd>, <kbd>full</kbd>, and <kbd>arange</kbd><span> </span>take<span> </span><kbd>dtype</kbd><span> </span>as an optional argument. The default type is<span> </span><kbd>float</kbd>, except for<span> </span><kbd>arange</kbd>. There are also methods such as <kbd>zeros_like</kbd><span> </span>and<span> </span><kbd>ones_like</kbd>, which are slight variants of the preceding ones. For instance, the command <kbd>zeros_like(A)</kbd><span> </span>is equivalent to<span> </span><kbd>zeros(shape(A))</kbd>.</p>
<p>The function <kbd>identity</kbd><span> </span>constructs an identity matrix of a given size:</p>
<pre>I = identity(3)</pre>
<p>The command is identical to:</p>
<pre>I = array([[ 1., 0., 0.],
           [ 0., 1., 0.],
           [ 0., 0., 1.]])</pre>
<h1 id="uuid-99600b0e-01eb-4fe2-9d2f-fbc278725f19">4.6 Accessing and changing the shape</h1>
<p>The number of dimensions is what distinguishes a vector from a matrix. The <em>shape</em> is what distinguishes vectors of different sizes, or matrices of different sizes. In this section, we examine how to obtain and change the shape of an array.</p>
<h2 id="uuid-37126c71-8709-43be-bb61-be65019866e2">4.6.1 The function shape</h2>
<p>The shape of a matrix is the tuple of its dimensions. The shape of an <img class="fm-editor-equation" src="assets/116a1156-6428-4645-83b5-91a371d0ac37.png" style="width:2.92em;height:0.67em;"/> matrix is the tuple<span> </span><kbd>(n, m)</kbd>. It can be obtained by the function <kbd>shape</kbd>:</p>
<pre>M = identity(3)
shape(M) # (3, 3)</pre>
<p>or, simply by its attribute</p>
<pre>M.shape  # (3, 3)</pre>
<p>However, the advantage of using <kbd>shape</kbd><span> </span>as a function and not as an attribute is that the function may be used on scalars and lists as well. This may come in handy when code is supposed to work with both scalars and arrays:</p>
<pre>shape(1.) # ()
shape([1,2]) # (2,)
shape([[1,2]]) # (1,2)</pre>
<p>For a vector, the shape is a singleton containing the length of that vector:</p>
<pre>v = array([1., 2., 1., 4.])
shape(v) # (4,) &lt;- singleton (1-tuple)</pre>
<h2 id="uuid-ecee1854-2384-4936-b2b5-5ada99b98187"><span>4.6.2 Number of dimensions</span></h2>
<p> </p>
<p> </p>
<p>The number of dimensions of an array is obtained with the function <kbd>ndim</kbd> or using the array attribute <kbd>ndim</kbd>:</p>
<pre>ndim(A) # 2
A.ndim # 2</pre>
<p>Note that the number of dimensions, given by the function<span> </span><kbd>ndim</kbd>, of a tensor<span> </span><kbd>T</kbd><span> </span>(a vector, matrix, or higher-order tensor) is always equal to the length of its shape:</p>
<pre>T = zeros((2,2,3)) # tensor of shape (2,2,3); three dimensions
ndim(T) # 3
len(shape(T)) # 3</pre>
<h2 id="uuid-aee375f4-be7a-4699-9fea-f7cb36425226">4.6.3 Reshape</h2>
<p>The method<span> </span><kbd>reshape</kbd><span> </span>gives a new view of the array, with a new shape, without copying the data:</p>
<pre>v = array([0,1,2,3,4,5])
M = v.reshape(2,3)
shape(M) # returns (2,3)
M[0,0] = 10 # now v[0] is 10</pre>
<p>The various effects of <kbd>reshape</kbd><span> </span>on an array defined by<span> </span><kbd>arange(6)</kbd> are given in <em>Figure 4.2</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c83ae739-a14a-4dac-b732-b5926366fe1d.png" style="width:26.50em;height:22.17em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 4.2: The various effects of <kbd>reshape</kbd> on an array</div>
<p><span><kbd>reshape</kbd> does not create a new array. It rather gives a new view on the existing array. In the preceding example, changing one element of</span><span> </span><kbd>M</kbd><span> </span><span>would automatically result in a change in the corresponding element in</span><span> </span><kbd>v</kbd><span>. When this behavior is not acceptable, you need to copy the data, as explained in <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.1</a>: <em>Array views and copies</em>.</span></p>
<p>If you try to reshape an array with a shape that does not multiply to the original shape, an error is raised:</p>
<pre> ValueError: total size of new array must be unchanged.</pre>
<p>Sometimes, it is convenient to specify only one <kbd>shape</kbd> parameter and let Python determine the other in such a way that it multiplies to the original shape. This is done by setting the free <kbd>shape</kbd> parameter<span> to </span><kbd>-1</kbd>:</p>
<pre>v = array([1, 2, 3, 4, 5, 6, 7, 8])
M = v.reshape(2, -1)
shape(M) # returns (2, 4)
M = v.reshape(-1, 2)
shape(M) # returns (4,2 )
M = v.reshape(3,- 1) # returns error</pre>
<h3 id="uuid-c9b75dc0-35b8-430a-bb03-771cf58055be">Transpose</h3>
<p>A special form of reshaping is <em>transposing</em>. It just switches the two shape elements of the matrix. The transpose of a matrix<span> </span><img class="fm-editor-equation" src="assets/01c5013f-d771-4398-8b4a-09a7127faf37.png" style="width:0.83em;height:1.00em;"/> is a matrix<span> </span><img class="fm-editor-equation" src="assets/1e85d89b-68ed-4ce3-afcb-def575a94660.png" style="width:0.67em;height:0.75em;"/> such that</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0d4d53d1-e828-4034-a089-d1a79219f880.png" style="width:4.83em;height:1.42em;"/></div>
<p>which is resolved in the following way:</p>
<pre>A = ...
shape(A) # (3,4)

B = A.T  # A transpose
shape(B) # (4,3)</pre>
<p class="mce-root"><kbd>transpose</kbd> does not copy: transposition is very similar to reshaping. In particular, it does not copy the data either and just returns<span> </span>a view on the same array:<span> </span></p>
<pre class="mce-root">A= array([[ 1., 2.],[ 3., 4.]]) <br/>B=A.T 
A[1,1]=5. <br/>B[1,1] # 5.0</pre>
<p>Transposing a vector makes no sense since vectors are tensors of one dimension, that is, functions of one variable <span>–</span> the index. NumPy will, however, comply and return exactly the same object:</p>
<pre>v = array([1., 2., 3.])
v.T # exactly the same vector!</pre>
<p>What you have in mind when you want to transpose a vector is probably to create a row or column matrix. This is done using<span> </span><kbd>reshape</kbd>:</p>
<pre>v.reshape(-1, 1) # column matrix containing v
v.reshape(1, -1) # row matrix containing v</pre>
<h1 id="uuid-b940438f-228e-490c-8ae5-dccadda467dc">4.7 Stacking</h1>
<p>The universal method to build matrices from a couple of (matching) submatrices is<span> </span><kbd>concatenate</kbd>. Its syntax is:</p>
<pre>concatenate((a1, a2, ...), axis = 0)</pre>
<p>This command stacks the submatrices vertically (on top of each other) when<span> </span><kbd>axis=0</kbd><span> </span>is specified. With the argument<span> </span><kbd>axis=1</kbd>, they are stacked horizontally, and this generalizes according to arrays with more dimensions. This function is called by several convenient functions, as follows:</p>
<ul>
<li><kbd>hstack</kbd>: Used to stack arrays horizontally</li>
<li><kbd>vstack</kbd>: Used to stack arrays vertically</li>
<li><kbd>columnstack</kbd>: Used to stack vectors in columns</li>
</ul>
<h2 id="uuid-951ee720-619e-4fdf-a13a-0a147f4f7c87">4.7.1 Stacking vectors</h2>
<p class="CDPAlignLeft CDPAlign">You may stack vectors row-wise or column-wise using<span> </span><kbd>vstack</kbd><span> </span>and<span> </span><kbd>column_stack</kbd>, as illustrated in <em>Figure 4.3</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/489416aa-cee4-4c78-bd61-6d55509b1907.png" style="width:45.08em;height:10.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4.3: Difference between vstack and column_stack</div>
<div class="CDPAlignCenter CDPAlign">
<p>Note that <kbd>hstack</kbd><span> </span><span>would produce the concatenation of <kbd>v1</kbd> and <kbd>v2</kbd>. </span></p>
</div>
<p>Let's consider the symplectic permutation as an example for vector stacking: we have a vector of size <img class="fm-editor-equation" src="assets/95e7f926-6570-4979-aff3-cfd2456400df.png" style="width:1.17em;height:1.00em;"/>. We want to perform a symplectic transformation of a vector with an even number of components, that is, exchange the first half with the second half of the vector with sign change:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d1945fef-683a-48a7-8b84-69079e39b55f.png" style="width:41.67em;height:1.83em;"/></p>
<p>This operation is resolved in Python as follows:</p>
<pre># v is supposed to have an even length.
def symp(v):
    n = len(v) // 2 # use the integer division //
    return hstack([v[-n:], -v[:n]])</pre>
<h1 id="uuid-518a5cef-c885-4830-a929-af43a981fc1e">4.8 Functions acting on arrays</h1>
<p>There are different types of functions acting on arrays. Some act elementwise, and they return an array of the same shape. Those are called <em>universal functions</em>. Other array functions return an array of a different shape. In this section,<span> we will meet both types of functions and also learn how to convert scalar functions into <em>universal functions</em>.</span></p>
<h2 id="uuid-926bf92f-1928-40ae-8508-d8f2496595be">4.8.1 Universal functions</h2>
<p>Universal functions are functions that act elementwise on arrays. They thus have an output array that has the same shape as the input array. These functions allow us to compute the result of a scalar function on a whole array at once. </p>
<h3 id="uuid-4d753d1f-6cbc-4a86-b129-340021551875">Built-in universal functions</h3>
<p>A typical example is the<span> </span><kbd>cos</kbd><span> </span>function (the one provided by NumPy):</p>
<pre>cos(pi) # -1
cos(array([[0, pi/2, pi]])) # array([[1, 0, -1]])</pre>
<p>Note that universal functions work on arrays in a componentwise manner. This is also true for operators, such as multiplication or exponent:</p>
<pre>2 * array([2, 4]) # array([4, 8])
array([1, 2]) * array([1, 8]) # array([1, 16])
array([1, 2])**2 # array([1, 4])
2**array([1, 2]) # array([2, 4])
array([1, 2])**array([1, 2]) # array([1, 4])</pre>
<h3 id="uuid-bd852ae3-4c41-4993-ab17-6798247766d0">Creation of universal functions</h3>
<p>Your function will automatically be universal if you use only universal functions in it. If, however, your function uses functions that are not universal, you might get scalar results, or even an error when trying to apply them on an array:</p>
<pre>def const(x):
    return 1
const(array([0, 2])) # returns 1 instead of array([1, 1])</pre>
<p>Another example is the following:</p>
<pre>def heaviside(x):
    if x &gt;= 0:
        return 1.
    else: 
        return 0.
 
heaviside(array([-1, 2])) # error</pre>
<p>The expected behavior would be that the<span> </span><kbd>heaviside</kbd><span> </span>function applied to a vector<span> </span><kbd>[a,<span> </span>b]</kbd><span> </span>would return<span> </span><kbd>[heaviside(<em>a</em>),<span> </span><span>heaviside(<em>b</em>)</span>]</kbd>. Alas, this does not work because the function always returns a scalar, no matter the size of the input argument. Besides, using the function with an array input would cause the statement <kbd>if</kbd> to raise an exception, as is explained in detail in <a href="e60692b7-f6d2-42df-a59f-bfaf357ea932.xhtml">Section 5.2.1</a>: <em>Boolean arrays</em>.</p>
<p>The NumPy function<span> </span><kbd>vectorize</kbd><span> </span>allows us to quickly solve this problem:</p>
<pre>vheaviside = vectorize(heaviside)
vheaviside(array([-1, 2])) # array([0, 1]) as expected</pre>
<p>A typical application of this method is its use when plotting a function:</p>
<pre>xvals = linspace(-1, 1, 100)
plot(xvals, vectorize(heaviside)(xvals))
axis([-1.5, 1.5, -0.5, 1.5])</pre>
<p><span><em>Figure 4.4</em> shows the resulting graph:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/87adeed7-835b-464a-bcc8-b0bb49a621e6.png" style="width:33.83em;height:25.92em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 4.4: Heaviside function</div>
<p class="mce-root">The<span> </span><span>function</span><span> </span><kbd>vectorize</kbd><span> </span><span>provides a convenient way to quickly transform a function, so that it operates elementwise on lists and arrays.</span></p>
<p><kbd>vectorize</kbd> can also be used as a decorator:</p>
<pre>@vectorize <br/>def heaviside(x): <br/>    if x &gt;= 0: <br/>       return 1. <br/>    else:  <br/>       return 0. <br/># and a call of this results in:<br/>heaviside(array([-1, 2])) # array([0, 1])</pre>
<p>Decorators will be introduced in <a href="35749482-dbc7-41b2-aa19-dc63b242f18f.xhtml">Section 7.8</a>: <em>Functions as decorators.</em></p>
<h2 id="uuid-a90fa030-18ca-460e-818b-497feddb737a">4.8.2 Array functions</h2>
<p>There are a number of functions acting on arrays that do not act componentwise. Examples of such functions are<span> </span><kbd>max</kbd>,<span> </span><kbd>min</kbd>, and<span> </span><kbd>sum</kbd>. These functions may operate on the entire matrix, row-wise, or column-wise. When no argument is provided, they act on the entire matrix.</p>
<p>Suppose:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b4b74487-2302-49d4-9832-3dfaa7c465be.png" style="width:8.58em;height:2.50em;"/></p>
<p>The function <kbd>sum</kbd> acting on that matrix returns a scalar:</p>
<pre>sum(A) # 36</pre>
<p><span>The command has an optional parameter,</span> <kbd>axis</kbd>. It allows us to choose along which axis to perform the operation. For instance, if the axis is <span><img class="fm-editor-equation" src="assets/34738052-9fa9-47b9-82ff-83a13e4cff45.png" style="width:0.58em;height:0.92em;"/></span>, it means that the sum should be computed along the first axis. The sum along axis <span><img class="fm-editor-equation" src="assets/b3c35afb-1602-49a5-af3a-b4f4a92bb398.png" style="width:0.58em;height:1.00em;"/></span><span> </span>of an array of shape <img class="fm-editor-equation" src="assets/925c52a4-d0cd-400d-a844-1f5ff7e56e72.png" style="width:3.00em;height:1.25em;"/> will be a vector of length <span><img class="fm-editor-equation" src="assets/0ae89473-603a-4d7f-a6e1-002309711489.png" style="width:0.67em;height:0.67em;"/></span>.</p>
<p>Suppose we compute the sum of<span> </span><kbd>A</kbd><span> </span>along the axis <img class="fm-editor-equation" src="assets/fb5a95be-3141-40c3-bb6c-4fa00dbd0586.png" style="width:0.50em;height:0.92em;"/>:</p>
<pre>sum(A, axis=0) # array([ 6, 8, 10, 12])</pre>
<p>This amounts to computing the sum on the columns:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2aa3de70-06db-4cc0-882f-20d159526e22.png" style="width:11.00em;height:5.50em;"/></div>
<p>The result is a vector:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d594fcb4-c367-4178-8eac-e9669d2c878f.png" style="width:11.00em;height:2.83em;"/></div>
<p>Now suppose we compute the sum along axis<span> </span><em>1</em>:</p>
<pre>A.sum(axis=1) # array([10, 26])</pre>
<p>This amounts to computing the sum on the rows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b10b3aa4-6ef4-4079-bb86-d68282cd1f94.png" style="width:10.00em;height:5.00em;"/></div>
<p>The result is a vector:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d8e2b4fb-ca07-4164-8283-bee562f7dd36.png" style="width:6.67em;height:3.42em;"/></div>
<p>After having seen in this section functions acting on arrays in general, we turn now to some functions solving tasks in basic scientific computing. We exemplify this by considering some standard tasks in linear algebra.</p>
<h1 id="uuid-85f58ac5-a996-4134-8044-cc73a6fc4f6b">4.9 Linear algebra methods in SciPy</h1>
<p>SciPy offers a large range of methods from numerical linear algebra in its <span>module</span><span> </span><kbd>scipy.linalg</kbd>. Many of these methods are Python wrapping programs from<span> </span><kbd>LAPACK</kbd>, a collection of well-approved FORTRAN subroutines used to solve linear equation systems and eigenvalue problems, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[5]</a>. Linear algebra methods are the core of any method in scientific computing, and the fact that SciPy uses wrappers instead of pure Python code makes these central methods extremely fast. We present in detail here how two linear algebra problems are solved with Scipy to give you a flavor of this module.</p>
<p class="mce-root">You met before some linear algebra functions taken from the module <kbd>numpy.linalg</kbd>. Both packages NumPy and SciPy are compatible, but Scipy has its focus on scientific computing methods and is more comprehensive, while NumPy's focus is on the array datatype and it provides only some linear algebra methods for convenience.</p>
<h2 id="uuid-4f5ad3c6-04ed-49e0-9428-1ae6e1d8d4d4">4.9.1 Solving several linear equation systems with LU</h2>
<p>Let <span><img class="fm-editor-equation" src="assets/4196e6f5-3ee7-4824-9a06-1e2a0023f791.png" style="width:0.75em;height:0.83em;"/></span> be an <em><img class="fm-editor-equation" src="assets/6e3bf0cd-1219-43c9-8e6e-80888770ba90.png" style="width:3.25em;height:0.83em;"/></em> matrix and<span> <img class="fm-editor-equation" src="assets/919aa858-0c1e-4349-929f-6cab888543b5.png" style="width:6.17em;height:1.17em;"/></span> be a sequence of <img class="fm-editor-equation" src="assets/aec0a0b8-00cd-4635-9c1c-0686cbc24cc0.png" style="width:0.83em;height:0.83em;"/> vectors. We consider the problem to find <span><img class="fm-editor-equation" src="assets/143b692e-7046-4f9d-b164-fe5cd9effa12.png" style="width:0.83em;height:0.83em;"/> </span>vectors<span> </span><span><img class="fm-editor-equation" src="assets/67cb9bbc-afe6-4faa-849b-1d68041b2802.png" style="width:1.08em;height:0.92em;"/></span> such that:</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/0a0273f7-82f3-4066-88da-b79083ea9d5f.png" style="width:4.75em;height:1.33em;"/></div>
<p>We assume that the vectors<span> </span><img class="fm-editor-equation" src="assets/85efadf5-99b6-44b4-a962-833b8b3d8355.png" style="width:0.83em;height:1.25em;"/> are not known simultaneously. In particular, it is quite a common situation that the <img class="fm-editor-equation" src="assets/871fa756-0080-460c-92c0-fd64f972467f.png" style="width:0.42em;height:0.92em;"/><sup>th</sup> problem has to be solved before <img class="fm-editor-equation" src="assets/0282095b-b6ca-4e70-8a8a-dce30fc06d5f.png" style="width:2.17em;height:1.42em;"/>becomes available, for example in the context of the simplified Newton iteration, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml"/><a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[24]</a>.</p>
<p><img class="fm-editor-equation" src="assets/85bac675-3f92-4601-af52-ca94f39eef12.png" style="width:1.33em;height:0.83em;"/> factorization is a way to organize the classical Gauss elimination method in such a way that the computation is done in two steps:</p>
<ul>
<li>A factorization step of the matrix <span><img class="fm-editor-equation" src="assets/00bdf963-c2e4-44f6-b55f-d79be2f3f4d9.png" style="width:0.83em;height:1.00em;"/></span><span> </span>to get matrices in triangular form</li>
<li>A relatively cheap backward and forward elimination step that works on the instances of <img class="fm-editor-equation" src="assets/efd18f9b-201c-4d88-a885-7fe6cc05eec3.png" style="width:0.92em;height:1.17em;"/>and benefits from the more time-consuming factorization step</li>
</ul>
<p>The method also uses the fact that if<span> </span><span><img class="fm-editor-equation" src="assets/cecba16b-7cc5-4ca7-a597-a6c22ccac977.png" style="width:0.75em;height:0.92em;"/></span> is a permutation matrix such that<span> </span><img class="fm-editor-equation" src="assets/99dfac8f-563a-4c50-98cd-e977f9ac85b5.png" style="width:1.25em;height:0.75em;"/> is the original matrix with its rows permuted, the two systems <img class="fm-editor-equation" src="assets/b6467921-e799-4a7c-87d1-df158307b3d2.png" style="width:3.08em;height:0.92em;"/> and <img class="fm-editor-equation" src="assets/2d88dcdc-57aa-4e10-9cdb-494fbec51d25.png" style="width:4.58em;height:0.92em;"/> have the same solution.</p>
<p><img class="fm-editor-equation" src="assets/4578b253-5ead-4eef-9412-b4e3ea7439f6.png" style="width:1.58em;height:0.92em;"/> factorization finds a permutation matrix <img class="fm-editor-equation" src="assets/6c293ce8-4881-4f96-a225-cc7dfa04a769.png" style="width:0.75em;height:1.00em;"/>, a lower triangular matrix <img class="fm-editor-equation" src="assets/44e8c59b-3b02-4ad4-9363-2b8a92b506fe.png" style="width:0.58em;height:0.75em;"/>, and an upper triangular matrix <img class="fm-editor-equation" src="assets/98ffc1b2-a1c7-45ba-9c92-71043ecb2d05.png" style="width:0.92em;height:1.00em;"/> such that:</p>
<p class="CDPAlignLeft CDPAlign"><img class="fm-editor-equation" src="assets/caaf71e0-07ba-4fc0-80e0-cb79f1286d6c.png" style="width:4.42em;height:0.92em;"/>or equivalently <img class="fm-editor-equation" src="assets/beaa3fdf-6087-4498-8883-f8d9797efc06.png" style="width:4.08em;height:0.83em;"/>.</p>
<p>Such a factorization always exists. Furthermore,<span> </span><span><img class="fm-editor-equation" src="assets/3d8a0cf3-0fba-48ef-992d-4654fb86a225.png" style="width:0.67em;height:0.83em;"/></span> can be determined in such a way that <em><img class="fm-editor-equation" src="assets/6bc9dce9-f3fd-46c4-a547-553c7e51e6a7.png" style="width:3.67em;height:1.17em;"/></em>. Thus, the essential data from<span> </span><img class="fm-editor-equation" src="assets/35f23021-e8c1-4326-b7e9-7909b1e2f02f.png" style="width:0.67em;height:0.83em;"/> that has to be stored is<span> </span><img class="fm-editor-equation" src="assets/9f65052f-5fc6-451c-acc0-509bb256677c.png" style="width:1.33em;height:1.08em;"/> with <img class="fm-editor-equation" src="assets/9e90e974-9f89-492b-a3e8-3e8376d73586.png" style="width:1.92em;height:1.00em;"/>. Consequently,<span> </span><em><span><img class="fm-editor-equation" src="assets/2b0e1170-2606-4e74-88b1-2c0681f6076c.png" style="width:0.75em;height:1.00em;"/></span></em> and<span> </span><span><img class="fm-editor-equation" src="assets/8d7fe4fb-c2fb-4d10-9f76-b4ffb42ae6c3.png" style="width:0.75em;height:0.92em;"/></span> can be stored together in an<span> </span><span><img class="fm-editor-equation" src="assets/46e6348b-3f0b-442e-8b32-6c724c4ea4f5.png" style="width:2.92em;height:0.75em;"/></span> array, while the information about the permutation matrix <img class="fm-editor-equation" src="assets/0bdf51ae-0e08-4759-8a69-fe3479b39ccb.png" style="width:0.75em;height:0.92em;"/> just requires an <span><img class="fm-editor-equation" src="assets/d0f432d4-6869-4b90-9b12-31e8f12db89b.png" style="width:0.75em;height:0.67em;"/></span> integer vector – the pivot vector.</p>
<p>In SciPy, there are two methods to compute the<span> </span>LU<span> </span>factorization. The standard one is<span> </span><kbd>scipy.linalg.lu</kbd>, which returns the three matrices<span> </span><kbd>L</kbd>,<span> </span><kbd>U</kbd>, and<span> </span><kbd>P</kbd>. The other method is <kbd>lu_factor</kbd>.<span> </span>That is the method we describe here, because it will be conveniently used later in combination with<span> </span><kbd>lu_solve</kbd>:</p>
<pre>import scipy.linalg as sl
[LU,piv] = sl.lu_factor(A)</pre>
<p>Here, the<span> matrix </span><kbd>A</kbd><span> </span>is factorized and an array with the information about<span> </span><kbd>L</kbd><span> </span>and<span> </span><kbd>U</kbd><span> </span>is returned, together with the pivot vector. With this information, the system can be solved by performing row interchanges of the vectors<span> </span><em><img class="fm-editor-equation" src="assets/153577e0-6458-4c62-92a0-8cf350510081.png" style="width:0.92em;height:1.17em;"/></em> according to the information stored in the pivot vector, backward substitution using <em><img class="fm-editor-equation" src="assets/96b762f1-848b-444d-a841-7d0d2766a23c.png" style="width:0.83em;height:1.00em;"/>,</em><span> </span>and finally, forward substitution using <img class="fm-editor-equation" src="assets/db5a6831-edd9-4a37-bb7e-8284f8a66aef.png" style="width:0.83em;height:1.08em;"/>. This is bundled in Python, in the <span>method</span> <kbd>lu_solve</kbd>. The following code snippet shows how the system <img class="fm-editor-equation" src="assets/a8a9ac9f-b68e-45f0-a555-b8e489316cd5.png" style="width:4.58em;height:1.25em;"/>is solved once the LU factorization is performed and its results stored in the tuple (LU, piv):</p>
<pre>import scipy.linalg as sl
xi = sl.lu_solve((LU, piv), bi)</pre>
<h2 id="uuid-9c7091b9-88f2-4826-87e4-c82802a0a1ba">4.9.2 Solving a least square problem with SVD</h2>
<p>A linear equation system <img class="fm-editor-equation" src="assets/81eb24c9-baf8-4329-a16e-e721ec9262e1.png" style="width:3.42em;height:1.00em;"/>, with<span> </span><span><img class="fm-editor-equation" src="assets/92a1bee6-65ee-4def-b0a6-8ed17278ef02.png" style="width:0.83em;height:1.00em;"/></span> being an<span> </span><em><img class="fm-editor-equation" src="assets/1d73bf3f-58a2-414e-9d7d-1afb6720205a.png" style="width:3.25em;height:0.75em;"/></em> matrix and <em><img class="fm-editor-equation" src="assets/0fd80a0a-c81b-47b2-8e56-e2d1858c1e2a.png" style="width:3.08em;height:0.75em;"/></em>, is called an overdetermined linear system. In general, it has no classical solution and you seek a vector <span><img class="fm-editor-equation" src="assets/6d0da559-17ca-4da7-bf6f-c8fc0c776aae.png" style="width:3.58em;height:1.00em;"/> </span>with the property:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d2456b56-3d9c-4b6d-b439-8a14d3933796.png" style="width:17.92em;height:3.75em;"/></p>
<p>Here, <img class="fm-editor-equation" src="assets/cbba8bf7-fee6-4d90-bdda-74de6bd48875.png" style="width:2.75em;height:1.50em;"/> denotes the Euclidean vector<span> </span>norm <img class="fm-editor-equation" src="assets/1b83e74f-85d8-4b81-9f8c-03be5257c74e.png" style="width:12.00em;height:2.42em;"/>.</p>
<p>This problem is called a least square problem. A stable method to solve it is based on factorizing<span> <img class="fm-editor-equation" src="assets/b6070459-10bf-46cd-8a81-79da90e4677d.png" style="width:5.17em;height:1.17em;"/></span><em>,</em> with<span> </span><span><img class="fm-editor-equation" src="assets/b2199c3b-3baf-4d99-b440-5a7f8128e122.png" style="width:0.67em;height:0.75em;"/></span> being an <img class="fm-editor-equation" src="assets/9f894183-c602-4e45-acd2-1a5b1dfa8e57.png" style="width:3.25em;height:0.67em;"/> orthogonal matrix,<span> </span><span><img class="fm-editor-equation" src="assets/321ee887-ee37-47ad-88e9-f433f47452eb.png" style="width:0.75em;height:0.92em;"/></span> an <img class="fm-editor-equation" src="assets/ec15b505-3dc6-454e-8ac0-432c1126e3c5.png" style="width:3.33em;height:0.83em;"/> orthogonal matrix, and <img class="fm-editor-equation" src="assets/9b49437c-733d-43d8-a853-e62eeeb21ea9.png" style="width:4.83em;height:1.42em;"/> an <img class="fm-editor-equation" src="assets/e6e9669b-28f8-427e-84dd-a81995d4af03.png" style="width:3.17em;height:0.75em;"/> matrix with the property <img class="fm-editor-equation" src="assets/408d1afa-77dd-400a-9f84-938372b59921.png" style="width:3.08em;height:1.17em;"/> for all<span> </span><img class="fm-editor-equation" src="assets/a93a7e22-86c4-451e-b37c-70929ccdb519.png" style="width:2.17em;height:1.17em;"/>. This factorization is called a <strong>singular value decomposition</strong><em> </em>(<strong>SVD</strong>).</p>
<p>We write</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/d56a3d65-e4e2-4ec7-82c4-5c66a05cb0c9.png" style="width:5.75em;height:3.17em;"/></div>
<p>with a diagonal <em><img class="fm-editor-equation" src="assets/482f5dde-34d4-431c-9b78-7922c29f02c6.png" style="width:3.00em;height:0.83em;"/></em> matrix <img class="fm-editor-equation" src="assets/214f9d14-1fe5-4917-bf5f-903e54fc58fe.png" style="width:1.33em;height:1.08em;"/>. If we assume that<span> </span><img class="fm-editor-equation" src="assets/00bda032-6d12-4c96-bf4f-35e863ba8b90.png" style="width:0.83em;height:0.92em;"/> has full rank, then <sub><em><img class="fm-editor-equation" src="assets/40f74b62-32ab-4ffa-91ac-ae281d11d3da.png" style="width:1.33em;height:1.17em;"/></em></sub> is invertible and it can be shown that </p>
<p><img class="fm-editor-equation" src="assets/82c957bc-cd01-4ee7-9538-c30b62c29ffc.png" style="width:12.83em;height:1.83em;"/></p>
<p>holds. </p>
<p>If we split <img class="fm-editor-equation" src="assets/871828cc-22c0-46f1-837c-68393d365c37.png" style="width:6.58em;height:1.17em;"/> with <img class="fm-editor-equation" src="assets/5ef1ec2f-a76a-4523-bfcb-990bf31f162f.png" style="width:1.25em;height:1.08em;"/> being an<span> </span><span><img class="fm-editor-equation" src="assets/0a7fbf6f-dae4-4e00-8074-6c9453a683e9.png" style="width:3.08em;height:0.75em;"/></span> submatrix, then the preceding equation can be simplified to:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/4a49ee33-bc31-403a-8fa2-723e1e78588d.png" style="width:8.75em;height:1.83em;"/> </p>
<p>SciPy provides a function called <kbd>svd</kbd>, which we use to solve this task:</p>
<pre>import scipy.linalg as sl 
[U1, Sigma_1, VT] = sl.svd(A, full_matrices = False,
                              compute_uv = True) 
xast = dot(VT.T, dot(U1.T, b) / Sigma_1)
r = dot(A, xast) - b # computes the residual
nr = sl.norm(r, 2) # computes the Euclidean norm of r</pre>
<p>The keyword<span> </span><kbd>full_matrices</kbd><span> tells whether </span>the complete matrix <img class="fm-editor-equation" src="assets/9e72bfce-f08d-4f8a-a8b1-1ffef56ddffa.png" style="width:0.83em;height:1.08em;"/> or only its submatrix <em><img class="fm-editor-equation" src="assets/51d29c20-bb37-4615-b3eb-5f131e0ed12b.png" style="width:1.08em;height:1.00em;"/></em> should be computed. As you often use<span> </span><kbd>svd</kbd><span> </span>to compute only singular values, <img class="fm-editor-equation" src="assets/0ff12784-516f-4184-9447-e2016fa22484.png" style="width:1.50em;height:1.00em;"/>, we have, in our case, to explicitly demand the computation of<span> </span><img class="fm-editor-equation" src="assets/0be678a3-b8e0-4f25-88c3-38878a4d6a97.png" style="width:0.83em;height:0.92em;"/> and<span> </span><img class="fm-editor-equation" src="assets/e209beca-7321-416e-a764-1645933a0536.png" style="width:0.75em;height:0.92em;"/> by using the keyword<span> </span><kbd>compute_uv</kbd>.</p>
<p>The SciPy function<span> </span><kbd>scipy.linalg.lstsq</kbd><span> </span>solves the least squares problem directly by internally using an SVD.</p>
<h2 id="uuid-a1cf7ab1-5a86-4a91-926f-1ae796754dcd">4.9.3 More methods</h2>
<p>In the examples so far, you met a couple of methods for computational tasks in linear algebra, for example,<span> </span><kbd>solve</kbd>. More methods are available after the command <kbd>import scipy.linalg as sl</kbd> is executed. The most common of them are listed in <em>Table 4.6</em>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Methods</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>sl.det</kbd></td>
<td>Determinant of a matrix</td>
</tr>
<tr>
<td><kbd>sl.eig</kbd></td>
<td>Eigenvalues and eigenvectors of a matrix</td>
</tr>
<tr>
<td><kbd>sl.inv</kbd></td>
<td>Matrix inverse</td>
</tr>
<tr>
<td><kbd>sl.pinv</kbd></td>
<td>Matrix pseudoinverse</td>
</tr>
<tr>
<td><kbd>sl.norm</kbd></td>
<td>Matrix or vector norm</td>
</tr>
<tr>
<td><kbd>sl.svd</kbd></td>
<td>Singular value decomposition</td>
</tr>
<tr>
<td><kbd>sl.lu</kbd></td>
<td>LU decomposition</td>
</tr>
<tr>
<td><kbd>sl.qr</kbd></td>
<td>QR decomposition</td>
</tr>
<tr>
<td><kbd>sl.cholesky</kbd></td>
<td>Cholesky decomposition</td>
</tr>
<tr>
<td><kbd>sl.solve</kbd></td>
<td>Solution of a general or symmetric linear system: <em>Ax = b</em></td>
</tr>
<tr>
<td><kbd>sl.solve.banded</kbd></td>
<td>The same for banded matrices</td>
</tr>
<tr>
<td><kbd>sl.lstsq</kbd></td>
<td>Least squares solution</td>
</tr>
</tbody>
</table>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">Table <span>4.6: Linear algebra functions of the module</span> scipy.linalg</div>
<p>Execute<span> </span><kbd>import scipy.linalg as sl</kbd><span> </span>first.</p>
<h1 id="uuid-ef4d7a28-da00-49c1-89d2-5c6a91592a2e">4.10 Summary</h1>
<p>In this chapter, we worked with the most important objects in linear algebra – vectors and matrices. For this, we learned how to define arrays and we met important array methods. A smaller section demonstrated how to use modules from<span> </span><kbd>scipy.linalg</kbd><span> </span>to solve central tasks in linear algebra.</p>
<p>In the following chapter, we consider more advanced and special aspects of arrays. </p>
<h1 id="uuid-72086d08-247d-4788-a8ea-ad629c14592e">4.11 Exercises</h1>
<p><strong>Ex. 1:</strong> Consider a <img class="fm-editor-equation" src="assets/94b86ce2-e6b2-475b-9f14-76c5e36c9e19.png" style="width:2.58em;height:1.00em;"/> matrix:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/b9199d20-b134-4715-ae5c-f5f77974c909.png" style="width:9.58em;height:5.67em;"/></p>
<ol>
<li>Construct this matrix in Python using the function<span> </span><kbd>array</kbd>.</li>
<li>Construct the same matrix using the function<span> </span><kbd>arange</kbd> followed by a suitable <kbd>reshape</kbd>.</li>
<li>What is the result of the expression<span> </span><kbd>M[2,:]</kbd>? What is the result of the similar expression<span> </span><kbd>M[2:]</kbd>?</li>
</ol>
<p><strong>Ex. 2</strong>: Given a vector<span> </span><em>x</em>, construct in Python the following matrix:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/fe063b6f-16f0-4f56-9598-adfd011526fe.png" style="width:16.25em;height:7.83em;"/></p>
<p>Here, <span><img class="fm-editor-equation" src="assets/6b2583e7-6896-4d67-964d-fd049538ba7f.png" style="width:1.17em;height:1.00em;"/></span> are the components of the vector<span> </span><img class="fm-editor-equation" src="assets/18d85501-1ef0-49b3-8a5b-9e48a139c592.png" style="width:0.75em;height:0.83em;"/> (numbered from zero). Given a vector <img class="fm-editor-equation" src="assets/219de5ca-b350-487d-aa10-0ad36e6b5f28.png" style="width:0.50em;height:0.75em;"/>, solve in Python the linear equation system <img class="fm-editor-equation" src="assets/ebed84dd-d1d0-4f9e-a484-605bfc06c9bb.png" style="width:3.33em;height:1.08em;"/>. Let the components of<span> </span><span><img class="fm-editor-equation" src="assets/03a227be-9acb-460e-9c61-af0cd3bd9232.png" style="width:0.58em;height:0.75em;"/></span> be denoted by <em><img class="fm-editor-equation" src="assets/7e32640f-ea55-4d20-95c8-cb2b8f653841.png" style="width:6.92em;height:1.08em;"/></em>. Write a function<span> </span><kbd>poly</kbd>, which has<span> </span><img class="fm-editor-equation" src="assets/2b36f4f3-1189-45e2-bb5a-a0425f127e30.png" style="width:0.58em;height:0.75em;"/> and<span> </span><img class="fm-editor-equation" src="assets/782f3b31-642b-4427-8c2a-4ed1be231cd2.png" style="width:0.67em;height:0.83em;"/> as input and computes the polynomial:</p>
<p><img src="assets/11bad0bb-4452-4459-9007-88365688c530.png" style="width:11.42em;height:4.67em;"/></p>
<p>Plot this polynomial and depict in the same plot the points <img class="fm-editor-equation" src="assets/2f31ef49-1465-45fe-8d17-22e1a9ebb089.png" style="width:3.75em;height:1.42em;"/> as small stars. Try your code with the vectors:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9f72d9a2-9a68-4ea6-a11e-3fb839a38d7b.png" style="width:17.08em;height:2.83em;"/></p>
<p><strong>Ex. 3:</strong> The matrix<span> </span><img class="fm-editor-equation" src="assets/bcb237c4-8b52-4760-b9f7-a53906c9378f.png" style="width:0.92em;height:1.08em;"/> in<span> </span><em>Ex. 2</em><span> </span>is called a <em>Vandermonde matrix</em>. It can be set up in Python directly with the command<span> </span><kbd>vander</kbd>. Evaluating a polynomial defined by a coefficient vector can be done with the Python command<span> </span><kbd>polyval</kbd>. Repeat<span> </span><em>Ex. 2</em><span> </span>by using these commands.</p>
<p><strong>Ex. 4:</strong> Let<span> </span><span><img class="fm-editor-equation" src="assets/ee99a147-92c3-476d-a39a-a74ad9c0985c.png" style="width:0.75em;height:0.92em;"/></span> be a one-dimensional array. Construct another array <img class="fm-editor-equation" src="assets/290f6f75-cb1d-4a2f-8ff2-0a8e1a7921d0.png" style="width:0.42em;height:1.25em;"/> with values <img class="fm-editor-equation" src="assets/6b23c9cd-6a6c-45c1-a2a7-fd6205634028.png" style="width:14.33em;height:1.50em;"/>. In statistics, this array is called the <em>moving average</em> of <img class="fm-editor-equation" src="assets/31b367fc-8e36-4ceb-930b-b3b4c8cdb0ec.png" style="width:0.67em;height:0.75em;"/>. In approximation theory, it plays the role of the Greville abscissae of cubic splines. Try to avoid the use of <kbd>for</kbd> loops in your scrip t.</p>
<p><strong>Ex. 5:</strong></p>
<ol>
<li>Construct from the matrix<span> </span><img class="fm-editor-equation" src="assets/7178b185-4f57-411e-ab36-1878955e902b.png" style="width:0.83em;height:1.00em;"/>given in<span> </span><em>Ex. 2</em><span> </span>a matrix<span> </span><img class="fm-editor-equation" src="assets/2df3ed42-0a6a-41a5-a792-3ea9d7c739c0.png" style="width:0.83em;height:1.08em;"/> by deleting <img class="fm-editor-equation" src="assets/0c7572b8-ae60-4056-bc23-b7755d8fd266.png" style="width:0.83em;height:0.92em;"/>'s first column.</li>
<li>Form the matrix <img class="fm-editor-equation" src="assets/6eebcb7e-0a31-45fa-9f86-314c2724d5a4.png" style="width:6.42em;height:1.17em;"/>.</li>
</ol>
<ol start="3">
<li>Compute<span> </span><img class="fm-editor-equation" src="assets/9f1f2ce4-d0bc-4b76-90e6-a007bf3de393.png" style="width:2.83em;height:1.00em;"/> with<span> </span><em>y</em><span> </span>from<span> </span><em>Ex. 2</em>.</li>
<li>Use<span> </span><img class="fm-editor-equation" src="assets/c3627f5c-ffb0-472c-adcd-349774cbc08b.png" style="width:0.58em;height:0.83em;"/> and<span> </span><kbd>polyval</kbd><span> </span>to plot the polynomial defined by <img class="fm-editor-equation" src="assets/6914b439-8e00-43a4-9d05-cf710057f952.png" style="width:0.50em;height:0.75em;"/>. Plot in the same picture again the points <img class="fm-editor-equation" src="assets/fa578596-8b6d-4e5d-8d45-3444e2a19f77.png" style="width:3.92em;height:1.50em;"/>.</li>
</ol>
<p><strong>Ex. 6:</strong><span> </span><em>Ex. 5</em><span> </span>describes the least squares method. Repeat that exercise but use SciPy's<span> </span><kbd>scipy.linalg.lstsq</kbd><span> </span>method instead.</p>
<p><strong>Ex. 7:</strong> Let<span> </span><span><img class="fm-editor-equation" src="assets/9c8c6479-a5f2-468d-89ff-ebba2e920bf6.png" style="width:0.67em;height:0.83em;"/></span> be a vector written in its coordinate form as a <img class="fm-editor-equation" src="assets/dfb4ade8-dd92-4337-8bbb-69ad3e591092.png" style="width:1.92em;height:0.75em;"/> matrix <img class="fm-editor-equation" src="assets/d5202a4a-76e0-49b2-aa6a-a3700a41331e.png" style="width:6.17em;height:1.50em;"/>. Construct the projection matrices:</p>
<div class="CDPAlignLeft CDPAlign"><img class="fm-editor-equation" src="assets/a37ac33c-9332-43af-88a3-44340ef9916e.png" style="width:5.25em;height:3.17em;"/> and <img class="fm-editor-equation" src="assets/23ac98e4-77db-423f-8ce7-456009c627ba.png" style="width:5.25em;height:1.17em;"/></div>
<p>Show experimentally that<span> </span><span><img class="fm-editor-equation" src="assets/83a4e7b1-68fc-49e9-b334-210006ce7cf4.png" style="width:0.67em;height:0.83em;"/></span> is an eigenvector for both matrices<span> </span><img class="fm-editor-equation" src="assets/92b532e7-074a-4860-aa1c-7f8c7173159e.png" style="width:0.83em;height:1.00em;"/> and <img class="fm-editor-equation" src="assets/0bc7f0fb-df10-4658-b18d-928f7a13cc76.png" style="width:0.83em;height:1.00em;"/>. What are the corresponding eigenvalues?</p>
<p><strong>Ex. 8:</strong> In numerical linear algebra the <em><img class="fm-editor-equation" src="assets/44464ed2-4f61-4367-8619-39608a28d1e7.png" style="width:3.42em;height:0.75em;"/></em> matrix<span> </span><img class="fm-editor-equation" src="assets/5f13f90a-e7a8-4775-a9e7-b9d2228e5ca4.png" style="width:0.92em;height:1.00em;"/> with the property</p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/9c02fdfc-2636-4564-b3ff-0995d87fa34d.png" style="width:16.33em;height:4.67em;"/></div>
<p>is used as an example for an extreme growth factor, when performing<span> </span>LU<span> </span>factorization, see <a href="12bddbb5-edd0-46c6-8f7a-9475aaf01a9d.xhtml">[36, p. 165]</a>.</p>
<p>Set up this matrix in Python for various values of <img class="fm-editor-equation" src="assets/a92b5fed-a950-43f8-ac67-7f39e1606d55.png" style="width:1.00em;height:0.75em;"/>, compute its<span> </span>LU<span> </span>factorization using the command <kbd>scipy.linalg.lu</kbd><span>, </span><span>and derive experimentally a statement about the growth factor</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/92f0c83e-a714-49df-a074-f358f6ea7290.png" style="width:8.92em;height:3.50em;"/></div>
<p class="CDPAlignLeft CDPAlign">in relation to <img class="fm-editor-equation" src="assets/eadd88ba-9e5c-48dc-95c9-f34ba0fe8f6b.png" style="width:1.00em;height:0.67em;"/>.</p>


            </article>

            
        </section>
    </body></html>