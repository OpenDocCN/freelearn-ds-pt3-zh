- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Web Apps with Forms, Session State, and Customizable Subdomains
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Streamlit, *forms*, *Session State*, and *customizable subdomains* are all
    features that allow for more advanced customization and functionality in web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '*Forms* allow users to create interactive forms within their Streamlit web
    app that can be used to collect user input and perform actions based on a specific
    group of inputs. Forms can contain a variety of input elements, such as text fields,
    drop-down menus, and checkboxes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '*Session State* is a feature that allows users to store and persist data across
    different sessions of their web app. This can be useful for storing user preferences
    or app settings.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *customizable subdomains* allow users to create a custom subdomain
    for their Streamlit app that can be useful for branding or creating a more memorable
    URL (instead of using the standard anonymous URL proposed automatically).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: What are forms and when and why do we use them?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Session State and when do we use it?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are customizable subdomains and what possibilities do they offer?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be using the following libraries, packages, and tools:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in this chapter can be accessed through the following GitHub link:
    [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are forms and when and why do we use them?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Streamlit forms** is a feature that allows you to create interactive web
    forms in your Streamlit apps. These forms enable you to collect user input through
    different widgets such as textboxes, selects, checkboxes, and more. When a user
    submits a form, Streamlit automatically captures the input values and makes them
    available to your Python code.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit forms is simple. You can define the form boundaries with `st.form()`
    and add widgets within it. Streamlit provides a variety of input components that
    make it easy for users to enter information such as text input, number input,
    and so on. This integration with Python eliminates the need for manual form handling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit forms offer customization options to improve the user experience.
    You can add labels, default values, and tooltips to guide users. Additionally,
    you can control a form’s layout and style to match your app’s design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Form submission is always triggered by a submit button, allowing you to capture
    user input and perform actions based on it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, forms are groups of widgets, and we can run different groups
    of forms independently of one another. Let’s write some simple code to show this
    feature:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: Starting point for forms](img/B21147_15_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Starting point for forms'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is extremely simple: after importing `streamlit`, we just
    print a title on the screen. Here is the result:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: Starting point from the browser perspective](img/B21147_15_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Starting point from the browser perspective'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To introduce forms in our code, we essentially have two approaches. Let’s take
    a look at them one by one.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The context manager approach
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way to introduce forms in our code is the *context manager approach*,
    an elegant approach that uses the `with` instruction. The `with` instruction makes
    it possible to *declare* the form just at the beginning of the code block (on
    *line 8* in *Figure 15**.3*) and then just use instructions in the usual way,
    typing `st.` with the name of the widget. So, write this code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: The context manager approach](img/B21147_15_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: The context manager approach'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the code shown in *Figure 15**.3*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: On *line 8*, we created a form leveraging the `with` instruction. Please note
    that the only argument of the form is its key, and it can be any kind of text.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, on *lines 9* and *10*, we inserted a couple of widgets in our new
    form, specifically a couple of `text_input` instances used to save the first name
    and last name of a hypothetical user.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 11*, we just merged the first and last names.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 13* is very important because each form needs to be activated by a submit
    button, which must be created using the `form_submit_button` method. In this case,
    as an argument, we use the label to be visualized in the form.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on *line 15*, we used an `if` clause to double-check whether the button
    has been pushed; if it has, we print a success message.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the result in the browser:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: Result using the context manager approach in the browser](img/B21147_15_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Result using the context manager approach in the browser'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: When we click on the `text_input` instances and the button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the message out of the form, we can slightly change the code, as shown
    in the following figure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: Keeping the success message outside the form](img/B21147_15_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: Keeping the success message outside the form'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `if` clause indentation has been changed to be exactly below the `with`
    instruction, which means below the form – that is, outside its code block. This
    is the result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: A different position for the greeting message](img/B21147_15_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: A different position for the greeting message'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see the second approach, a classic one, used to introduce forms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The classic approach
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classic approach is quite straightforward, since it doesn’t require the
    `with` instruction:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: The classic approach to introduce forms in our code](img/B21147_15_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: The classic approach to introduce forms in our code'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we are doing this time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: On *line 19*, we directly introduce the form.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, on *lines 20* and *21*, we create two new widgets, `text_input`
    and `selectbox`, respectively.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 22*, we create a submit button. As usual, an `if` clause oversees whether
    or not the submit button has been pushed. It’s important to understand that, in
    this case, the indentation of the `if` clause will always be at the same level
    as that of the form, so the success message will always be outside the form box.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how the two forms created using the two approaches look in the browser:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8: Two forms created with the context manager and classic approaches](img/B21147_15_08.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: Two forms created with the context manager and classic approaches'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we can insert data (this means using widgets) independently
    into the two forms. In fact, the two submit buttons are completely unrelated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Forms are a very powerful way of keeping widgets and components segregated in
    a specific area of our web app. Let’s now see how to deal with so-called *sessions*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: What is Session State and when do we use it?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Streamlit was launched in 2019, and *statefulness* was a little problem for
    quite a long time since states weren’t managed natively. However, starting from
    version 0.8.4, things changed, and the official claim ([https://blog.streamlit.io/session-state-for-streamlit/](https://blog.streamlit.io/session-state-for-streamlit/))
    was as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*You can now store information across app interactions* *and rerun!*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, that claim is really perfect because it conveys everything about
    sessions. Streamlit’s **Session State** feature offers an efficient and sophisticated
    approach to session management. This feature enables the storage of variables
    across multiple reruns, facilitates the creation of interactive events on input
    widgets, and allows the use of callback functions to manage these events effectively.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The robust capabilities of Session State enhance the development of various
    applications. These capabilities include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Integrating widgets that are interdependent
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing engaging stateful games, such as Battleship and Tic-Tac-Toe
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting data and image annotation tasks
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending functionalities for diverse and complex uses, such as persistence
    of user data across multiple requests and efficient management of resources and
    data
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, using Streamlit without Session State means that interacting with
    a widget initiates a rerun, causing the variables defined in the script to reset
    with each execution. In contrast, employing Session State enables the preservation
    of variable values across reruns, which is particularly beneficial when there
    is a need to maintain variable states without reinitialization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following code to see a little example in action and understand
    more. Start by writing the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9: Session State in code](img/B21147_15_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: Session State in code'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind Session State is simple and genial: Streamlit always runs from
    top to bottom on every iteration, so we check whether a variable of our interest
    (`count` in the example) has already been initialized in `st.session_state`. If
    it is not initialized yet, we initialize it to a specific value (`0` in our case);
    otherwise, we don’t do anything.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Session State 的核心思想既简单又巧妙：Streamlit 每次迭代时都会从上到下执行，因此我们检查我们关注的变量（示例中的 `count`）是否已经在
    `st.session_state` 中初始化。如果尚未初始化，我们将其初始化为一个特定的值（在我们的例子中是 `0`）；否则，我们什么都不做。
- en: So, `st.session_state` is just a kind of *collection* that saves variables we
    don’t want to initialize every time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`st.session_state` 就是一种 *集合*，用于保存我们不希望每次都初始化的变量。
- en: 'The preceding code is very easy. Here’s a breakdown:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单。下面是详细的解析：
- en: On *line 13*, we check whether the `count` variable is not in `session_state`;
    in this case, we initialize it to `0`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 13 行*，我们检查 `count` 变量是否不在 `session_state` 中；如果不在，我们将其初始化为 `0`。
- en: On *line 19*, we create a button to increment the count variable and we perform
    this operation using `st.session_state.count`; in this way, we remember the `count`
    variable’s value
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 19 行*，我们创建了一个按钮来递增 `count` 变量，并通过 `st.session_state.count` 执行此操作；这样，我们就能记住
    `count` 变量的值。
- en: On *line 24*, we do the same, but decrementing the `count` variable
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 24 行*，我们做了相同的操作，但是是对 `count` 变量进行递减。
- en: Finally, on *line 28*, we visualize a little message on the screen showing the
    `count` variable value
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在 *第 28 行*，我们在屏幕上可视化显示 `count` 变量的值。
- en: 'This is the result in the browser:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器中的结果：
- en: '![Figure 15.10: Session State in action](img/B21147_15_10.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.10：Session State 的应用](img/B21147_15_10.jpg)'
- en: 'Figure 15.10: Session State in action'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10：Session State 的应用
- en: Please verify that every time you click on the **Increment** or **Decrement**
    button, the value of **Count** is automatically updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请验证每次点击 **递增** 或 **递减** 按钮时，**Count** 的值是否会自动更新。
- en: The code in *Figure 15**.9* demonstrates the persistence of values across reruns.
    However, let’s explore a more intricate scenario. In Streamlit, it is feasible
    to assign *callbacks* to various widgets, such as `st.button` or `st.slider`.
    This is achieved by utilizing the `on_change` argument, allowing for more advanced
    interactivity and functionality.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15.9* 中的代码展示了值在重新运行时的持久性。然而，让我们探讨一个更复杂的场景。在 Streamlit 中，可以将 *回调* 分配给不同的小部件，如
    `st.button` 或 `st.slider`。这通过使用 `on_change` 参数实现，允许更高级的互动和功能。'
- en: A callback, often referred to as a *call-after* function, is a segment of executable
    code that is provided as an argument to another piece of code. This arrangement
    anticipates that the receiving code will execute the callback at a specified moment.
    Typical scenarios for such execution include user interactions such as clicking
    a button or adjusting a slider – essentially, whenever a change is detected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数，通常称为 *回调后* 函数，是一段可执行的代码，作为参数传递给另一段代码。这个安排预期接收代码会在指定的时刻执行回调函数。此类执行的典型场景包括用户交互，如点击按钮或调整滑块
    —— 本质上是每当检测到变化时。
- en: 'Utilizing Session State enables the management of events linked to modifications
    in a widget or button clicks through callback functions. This implies that when
    a callback function is associated with a widget, any alteration in the widget
    initiates a specific sequence: the callback function is executed first, followed
    by a top-to-bottom execution of the application.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Session State 可以通过回调函数管理与小部件修改或按钮点击相关的事件。这意味着，当一个回调函数与小部件关联时，小部件的任何变化都会启动一个特定的序列：首先执行回调函数，然后应用程序会从上到下地执行。
- en: 'Let’s see callbacks in action:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看回调函数的实际应用：
- en: '![Figure 15.11: Callbacks in code](img/B21147_15_11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11：代码中的回调函数](img/B21147_15_11.jpg)'
- en: 'Figure 15.11: Callbacks in code'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11：代码中的回调函数
- en: 'Here’s a breakdown of the code in *Figure 15**.11*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 *图 15.11* 中代码的详细解析：
- en: On *line 32*, we define a callback function named `update_first`. This function
    updates the value of the *second* variable contained in the `session_state` widget
    to the value of the *first* variable always stored in the `session_state` widget.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 32 行*，我们定义了一个名为 `update_first` 的回调函数。这个函数将 `session_state` 小部件中 *第二个* 变量的值更新为始终存储在
    `session_state` 小部件中的 *第一个* 变量的值。
- en: On *line 35*, we define a second callback function that is exactly the same
    as the first one, but updates the value of the *first* variable according to the
    value of the *second* one.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *第 35 行*，我们定义了第二个回调函数，它与第一个完全相同，但会根据 *第二个* 变量的值更新 *第一个* 变量的值。
- en: 'On *lines 39 and 40*, we introduce two `text_input` widgets. Among their arguments,
    as usual, we can find a label and a key, but this time there is something new:
    `on_change`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第39行和40行*，我们引入了两个`text_input`小部件。在它们的参数中，像往常一样，我们可以找到标签和键，但这次有一个新内容：`on_change`。
- en: Here, the callbacks enter action when a change happens in the widgets (so, when
    some text is inserted) when the `update_first` function is executed at *line 39*
    and the `update_second` function is executed on *line 40*.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，当小部件中发生变化（比如插入文本）时，回调函数开始起作用，`update_first`函数在*第39行*执行，而`update_second`函数在*第40行*执行。
- en: 'In this way, we create two widgets with mirrored values. This is the result
    in the browser:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们创建了两个具有镜像值的小部件。浏览器中的结果如下：
- en: '![Figure 15.12: Result of the callback action](img/B21147_15_12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.12：回调操作的结果](img/B21147_15_12.jpg)'
- en: 'Figure 15.12: Result of the callback action'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.12：回调操作的结果
- en: As we can see, every time we insert text into the first input box, the second
    one is updated, and vice versa.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每次在第一个输入框中插入文本时，第二个输入框也会被更新，反之亦然。
- en: Session State is perhaps one of the most powerful features of Streamlit. Please
    learn carefully how to leverage it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 会话状态可能是Streamlit最强大的功能之一。请仔细学习如何利用它。
- en: Let’s now see the advantages offered by *customizable subdomains*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下*自定义子域名*所带来的优势。
- en: What are customizable subdomains and what possibilities do they offer?
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是自定义子域名，它们提供了哪些可能性？
- en: 'We have already deployed two applications on Streamlit Cloud: the *NLP App*
    and the *COVID-19 Detection Tool*. So, we are quite familiar with the process,
    and even how to solve problems arising due to big files or a need for unconventional
    libraries.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Streamlit Cloud上部署了两个应用程序：*NLP应用*和*COVID-19检测工具*。因此，我们对这个过程非常熟悉，甚至知道如何解决因大文件或需要非常规库而出现的问题。
- en: 'Upon deploying our application on Community Cloud, it is assigned an automatically
    generated subdomain, which is structured based on our GitHub repository. This
    subdomain, unique to our application, serves as a means to share the app with
    others. Nevertheless, the default subdomain can often be cumbersome and not particularly
    user-friendly. For instance, a subdomain such as the following may not be easily
    memorable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将应用程序部署到Community Cloud后，它会分配一个自动生成的子域名，结构基于我们的GitHub仓库。这个子域名是应用程序独有的，用于与他人分享该应用。然而，默认的子域名往往很笨重，并且不太友好。例如，下面这样的子域名可能并不容易记住：
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To enhance shareability and recognition, we have the option to establish a
    custom subdomain. This customization allows the subdomain to better represent
    the content of our app, our personal brand, or any other preferred aspect. The
    custom URL would then be formatted as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强共享性和识别度，我们可以选择建立一个自定义子域名。这一自定义使得子域名能够更好地代表我们应用的内容、个人品牌或其他任何偏好方面。自定义URL的格式如下：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To tailor the subdomain of your application within Streamlit’s Cloud workspace,
    follow these straightforward steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要定制你应用在Streamlit Cloud工作区内的子域名，请按照以下简单步骤操作：
- en: 'Navigate to the right of your app, click on the **︙** overflow menu, and then
    select **Settings**:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至你应用的右侧，点击**︙**溢出菜单，然后选择**设置**：
- en: '![Figure 15.13: Deployed app settings on Streamlit Cloud](img/B21147_15_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.13：在Streamlit Cloud上的部署应用设置](img/B21147_15_13.jpg)'
- en: 'Figure 15.13: Deployed app settings on Streamlit Cloud'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13：在Streamlit Cloud上的部署应用设置
- en: In the app settings modal, access the **General** tab. Here, you’ll find your
    app’s current unique subdomain.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用设置模态框中，访问**常规**标签。这里，你会看到你应用的当前唯一子域名。
- en: Choose a custom subdomain that is between `6` and `63` characters long for your
    app’s URL.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的应用URL选择一个长度在`6`到`63`个字符之间的自定义子域名。
- en: 'Click **Save** to confirm:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**以确认：
- en: '![Figure 15.14: A new subdomain for our app](img/B21147_15_14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.14：我们应用的新子域名](img/B21147_15_14.jpg)'
- en: 'Figure 15.14: A new subdomain for our app'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.14：我们应用的新子域名
- en: 'This process is quick and efficient. Once completed, your app will be accessible
    via the newly set custom subdomain URL. In cases where the chosen custom subdomain
    is unavailable (for instance, if it is already in use), an error message will
    be displayed, prompting you to select a different subdomain, as shown in the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程既快速又高效。完成后，你的应用将通过新设置的自定义子域名URL进行访问。如果所选的自定义子域名不可用（例如已经被使用），系统会显示错误消息，提示你选择其他子域名，下面的截图演示了这一点：
- en: '![Figure 15.15: “This subdomain is already taken” error message](img/B21147_15_15.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.15：“该子域名已被占用”错误信息](img/B21147_15_15.jpg)'
- en: 'Figure 15.15: “This subdomain is already taken” error message'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.15：“该子域名已被占用”错误信息
- en: Being able to select a subdomain name that perfectly suits the aim of our web
    application is a very powerful customization.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 能够选择一个完美符合我们网页应用目标的子域名是一个非常强大的自定义功能。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered some topics that can really increase the level of
    our web applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些能够真正提升我们网页应用水平的主题。
- en: First of all, we saw what forms are and how to use them, discovering that having
    independent groups of widgets inside our web apps can make a big difference. All
    we need to do is define these forms and include some widgets inside them, using
    a button to trigger the widgets. Even the button is customizable since it can
    be included in the form or placed outside it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解了什么是表单以及如何使用它们，发现将独立的小部件组放入我们的网页应用中会带来很大不同。我们需要做的就是定义这些表单，并在其中包含一些小部件，使用按钮来触发这些小部件。甚至按钮也是可以自定义的，因为它可以放在表单内，也可以放在表单外。
- en: Further, we learned that Session State is an incredibly powerful weapon in our
    hands. At last, we can persist the values of our variables, and this opens up
    an incredible scenario of use cases to us. Moreover, thanks to callbacks, we can
    decide what to do when a user interacts with our widgets, calling back fully customized
    functions that completely match our needs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还学到了 Session State 是我们手中的一个极其强大的工具。最终，我们可以保存变量的值，这为我们打开了一个令人难以置信的使用场景。而且，借助回调，我们可以决定在用户与小部件交互时该做什么，调用完全自定义的函数，完美契合我们的需求。
- en: 'Finally, by customizing the subdomains of our deployed web applications, we
    achieved two targets: we made them much easier to remember and we gave them a
    very professional touch!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过自定义我们部署的网页应用的子域名，我们实现了两个目标：让它们更容易记住，并为它们增添了一丝专业感！
- en: In the next and final chapter, we are going to sum up the long journey we’ve
    made together, highlighting considerations about the Streamlit framework, discussing
    what the very important takeaways are, and giving some suggestions for the next
    steps.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的最后一章中，我们将总结我们共同经历的这段长旅程，重点讨论 Streamlit 框架的相关考虑事项，分析重要的收获，并提出一些下一步的建议。
