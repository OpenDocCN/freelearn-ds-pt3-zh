- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing Web Apps with Forms, Session State, and Customizable Subdomains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Streamlit, *forms*, *Session State*, and *customizable subdomains* are all
    features that allow for more advanced customization and functionality in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Forms* allow users to create interactive forms within their Streamlit web
    app that can be used to collect user input and perform actions based on a specific
    group of inputs. Forms can contain a variety of input elements, such as text fields,
    drop-down menus, and checkboxes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Session State* is a feature that allows users to store and persist data across
    different sessions of their web app. This can be useful for storing user preferences
    or app settings.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *customizable subdomains* allow users to create a custom subdomain
    for their Streamlit app that can be useful for branding or creating a more memorable
    URL (instead of using the standard anonymous URL proposed automatically).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are forms and when and why do we use them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Session State and when do we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are customizable subdomains and what possibilities do they offer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be using the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in this chapter can be accessed through the following GitHub link:
    [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/217479d2112ded99cfdd820a85709296ba5356b2/Chapter15)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are forms and when and why do we use them?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Streamlit forms** is a feature that allows you to create interactive web
    forms in your Streamlit apps. These forms enable you to collect user input through
    different widgets such as textboxes, selects, checkboxes, and more. When a user
    submits a form, Streamlit automatically captures the input values and makes them
    available to your Python code.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Streamlit forms is simple. You can define the form boundaries with `st.form()`
    and add widgets within it. Streamlit provides a variety of input components that
    make it easy for users to enter information such as text input, number input,
    and so on. This integration with Python eliminates the need for manual form handling.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit forms offer customization options to improve the user experience.
    You can add labels, default values, and tooltips to guide users. Additionally,
    you can control a form’s layout and style to match your app’s design.
  prefs: []
  type: TYPE_NORMAL
- en: Form submission is always triggered by a submit button, allowing you to capture
    user input and perform actions based on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, forms are groups of widgets, and we can run different groups
    of forms independently of one another. Let’s write some simple code to show this
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: Starting point for forms](img/B21147_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Starting point for forms'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is extremely simple: after importing `streamlit`, we just
    print a title on the screen. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: Starting point from the browser perspective](img/B21147_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Starting point from the browser perspective'
  prefs: []
  type: TYPE_NORMAL
- en: To introduce forms in our code, we essentially have two approaches. Let’s take
    a look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: The context manager approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way to introduce forms in our code is the *context manager approach*,
    an elegant approach that uses the `with` instruction. The `with` instruction makes
    it possible to *declare* the form just at the beginning of the code block (on
    *line 8* in *Figure 15**.3*) and then just use instructions in the usual way,
    typing `st.` with the name of the widget. So, write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: The context manager approach](img/B21147_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: The context manager approach'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the code shown in *Figure 15**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 8*, we created a form leveraging the `with` instruction. Please note
    that the only argument of the form is its key, and it can be any kind of text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, on *lines 9* and *10*, we inserted a couple of widgets in our new
    form, specifically a couple of `text_input` instances used to save the first name
    and last name of a hypothetical user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 11*, we just merged the first and last names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 13* is very important because each form needs to be activated by a submit
    button, which must be created using the `form_submit_button` method. In this case,
    as an argument, we use the label to be visualized in the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on *line 15*, we used an `if` clause to double-check whether the button
    has been pushed; if it has, we print a success message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the result in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: Result using the context manager approach in the browser](img/B21147_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Result using the context manager approach in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: When we click on the `text_input` instances and the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the message out of the form, we can slightly change the code, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: Keeping the success message outside the form](img/B21147_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: Keeping the success message outside the form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `if` clause indentation has been changed to be exactly below the `with`
    instruction, which means below the form – that is, outside its code block. This
    is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: A different position for the greeting message](img/B21147_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: A different position for the greeting message'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see the second approach, a classic one, used to introduce forms.
  prefs: []
  type: TYPE_NORMAL
- en: The classic approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The classic approach is quite straightforward, since it doesn’t require the
    `with` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: The classic approach to introduce forms in our code](img/B21147_15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: The classic approach to introduce forms in our code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what we are doing this time:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 19*, we directly introduce the form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, on *lines 20* and *21*, we create two new widgets, `text_input`
    and `selectbox`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 22*, we create a submit button. As usual, an `if` clause oversees whether
    or not the submit button has been pushed. It’s important to understand that, in
    this case, the indentation of the `if` clause will always be at the same level
    as that of the form, so the success message will always be outside the form box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how the two forms created using the two approaches look in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8: Two forms created with the context manager and classic approaches](img/B21147_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: Two forms created with the context manager and classic approaches'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we can insert data (this means using widgets) independently
    into the two forms. In fact, the two submit buttons are completely unrelated.
  prefs: []
  type: TYPE_NORMAL
- en: Forms are a very powerful way of keeping widgets and components segregated in
    a specific area of our web app. Let’s now see how to deal with so-called *sessions*.
  prefs: []
  type: TYPE_NORMAL
- en: What is Session State and when do we use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Streamlit was launched in 2019, and *statefulness* was a little problem for
    quite a long time since states weren’t managed natively. However, starting from
    version 0.8.4, things changed, and the official claim ([https://blog.streamlit.io/session-state-for-streamlit/](https://blog.streamlit.io/session-state-for-streamlit/))
    was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can now store information across app interactions* *and rerun!*'
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, that claim is really perfect because it conveys everything about
    sessions. Streamlit’s **Session State** feature offers an efficient and sophisticated
    approach to session management. This feature enables the storage of variables
    across multiple reruns, facilitates the creation of interactive events on input
    widgets, and allows the use of callback functions to manage these events effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The robust capabilities of Session State enhance the development of various
    applications. These capabilities include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating widgets that are interdependent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing engaging stateful games, such as Battleship and Tic-Tac-Toe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting data and image annotation tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending functionalities for diverse and complex uses, such as persistence
    of user data across multiple requests and efficient management of resources and
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, using Streamlit without Session State means that interacting with
    a widget initiates a rerun, causing the variables defined in the script to reset
    with each execution. In contrast, employing Session State enables the preservation
    of variable values across reruns, which is particularly beneficial when there
    is a need to maintain variable states without reinitialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following code to see a little example in action and understand
    more. Start by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9: Session State in code](img/B21147_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: Session State in code'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind Session State is simple and genial: Streamlit always runs from
    top to bottom on every iteration, so we check whether a variable of our interest
    (`count` in the example) has already been initialized in `st.session_state`. If
    it is not initialized yet, we initialize it to a specific value (`0` in our case);
    otherwise, we don’t do anything.'
  prefs: []
  type: TYPE_NORMAL
- en: So, `st.session_state` is just a kind of *collection* that saves variables we
    don’t want to initialize every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is very easy. Here’s a breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 13*, we check whether the `count` variable is not in `session_state`;
    in this case, we initialize it to `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 19*, we create a button to increment the count variable and we perform
    this operation using `st.session_state.count`; in this way, we remember the `count`
    variable’s value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 24*, we do the same, but decrementing the `count` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, on *line 28*, we visualize a little message on the screen showing the
    `count` variable value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the result in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: Session State in action](img/B21147_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: Session State in action'
  prefs: []
  type: TYPE_NORMAL
- en: Please verify that every time you click on the **Increment** or **Decrement**
    button, the value of **Count** is automatically updated.
  prefs: []
  type: TYPE_NORMAL
- en: The code in *Figure 15**.9* demonstrates the persistence of values across reruns.
    However, let’s explore a more intricate scenario. In Streamlit, it is feasible
    to assign *callbacks* to various widgets, such as `st.button` or `st.slider`.
    This is achieved by utilizing the `on_change` argument, allowing for more advanced
    interactivity and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A callback, often referred to as a *call-after* function, is a segment of executable
    code that is provided as an argument to another piece of code. This arrangement
    anticipates that the receiving code will execute the callback at a specified moment.
    Typical scenarios for such execution include user interactions such as clicking
    a button or adjusting a slider – essentially, whenever a change is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing Session State enables the management of events linked to modifications
    in a widget or button clicks through callback functions. This implies that when
    a callback function is associated with a widget, any alteration in the widget
    initiates a specific sequence: the callback function is executed first, followed
    by a top-to-bottom execution of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see callbacks in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: Callbacks in code](img/B21147_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: Callbacks in code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the code in *Figure 15**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: On *line 32*, we define a callback function named `update_first`. This function
    updates the value of the *second* variable contained in the `session_state` widget
    to the value of the *first* variable always stored in the `session_state` widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On *line 35*, we define a second callback function that is exactly the same
    as the first one, but updates the value of the *first* variable according to the
    value of the *second* one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On *lines 39 and 40*, we introduce two `text_input` widgets. Among their arguments,
    as usual, we can find a label and a key, but this time there is something new:
    `on_change`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the callbacks enter action when a change happens in the widgets (so, when
    some text is inserted) when the `update_first` function is executed at *line 39*
    and the `update_second` function is executed on *line 40*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this way, we create two widgets with mirrored values. This is the result
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12: Result of the callback action](img/B21147_15_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.12: Result of the callback action'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, every time we insert text into the first input box, the second
    one is updated, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Session State is perhaps one of the most powerful features of Streamlit. Please
    learn carefully how to leverage it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see the advantages offered by *customizable subdomains*.
  prefs: []
  type: TYPE_NORMAL
- en: What are customizable subdomains and what possibilities do they offer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already deployed two applications on Streamlit Cloud: the *NLP App*
    and the *COVID-19 Detection Tool*. So, we are quite familiar with the process,
    and even how to solve problems arising due to big files or a need for unconventional
    libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon deploying our application on Community Cloud, it is assigned an automatically
    generated subdomain, which is structured based on our GitHub repository. This
    subdomain, unique to our application, serves as a means to share the app with
    others. Nevertheless, the default subdomain can often be cumbersome and not particularly
    user-friendly. For instance, a subdomain such as the following may not be easily
    memorable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To enhance shareability and recognition, we have the option to establish a
    custom subdomain. This customization allows the subdomain to better represent
    the content of our app, our personal brand, or any other preferred aspect. The
    custom URL would then be formatted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To tailor the subdomain of your application within Streamlit’s Cloud workspace,
    follow these straightforward steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the right of your app, click on the **︙** overflow menu, and then
    select **Settings**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.13: Deployed app settings on Streamlit Cloud](img/B21147_15_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.13: Deployed app settings on Streamlit Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: In the app settings modal, access the **General** tab. Here, you’ll find your
    app’s current unique subdomain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a custom subdomain that is between `6` and `63` characters long for your
    app’s URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Save** to confirm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.14: A new subdomain for our app](img/B21147_15_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.14: A new subdomain for our app'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is quick and efficient. Once completed, your app will be accessible
    via the newly set custom subdomain URL. In cases where the chosen custom subdomain
    is unavailable (for instance, if it is already in use), an error message will
    be displayed, prompting you to select a different subdomain, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15: “This subdomain is already taken” error message](img/B21147_15_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.15: “This subdomain is already taken” error message'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to select a subdomain name that perfectly suits the aim of our web
    application is a very powerful customization.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some topics that can really increase the level of
    our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we saw what forms are and how to use them, discovering that having
    independent groups of widgets inside our web apps can make a big difference. All
    we need to do is define these forms and include some widgets inside them, using
    a button to trigger the widgets. Even the button is customizable since it can
    be included in the form or placed outside it.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we learned that Session State is an incredibly powerful weapon in our
    hands. At last, we can persist the values of our variables, and this opens up
    an incredible scenario of use cases to us. Moreover, thanks to callbacks, we can
    decide what to do when a user interacts with our widgets, calling back fully customized
    functions that completely match our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, by customizing the subdomains of our deployed web applications, we
    achieved two targets: we made them much easier to remember and we gave them a
    very professional touch!'
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we are going to sum up the long journey we’ve
    made together, highlighting considerations about the Streamlit framework, discussing
    what the very important takeaways are, and giving some suggestions for the next
    steps.
  prefs: []
  type: TYPE_NORMAL
