- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing NLP Techniques for Text Analysis and Processing in Streamlit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Translation and sentiment analysis are very important techniques used in **natural
    language processing** (**NLP**) for analyzing and processing text data.
  prefs: []
  type: TYPE_NORMAL
- en: Translation is the process of converting text from one language to another.
    Sentiment analysis is the process of identifying the emotional tone or sentiment
    of a piece of text. It is used to analyze customer feedback, social media sentiment,
    and product reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Both of them are powerful techniques that enable NLP applications to process
    and analyze text data and extract valuable insights from it. In this chapter,
    we will continue our exploration of web app creation with Streamlit while learning
    more about the techniques. In the previous chapter, we completed the **Text Analysis**
    voice of our web application’s menu, and now, finally, we are ready to finish
    all the parts of this application.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, our first web application will be more or less completed,
    and you will have a good understanding of how to build a Python web application
    step by step using Streamlit, in a very easy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deep-diving into NLP techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning more about language translation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-depth look at sentiment analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recap of our first web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the following libraries, packages, and tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sublime Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pipenv`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Streamlit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spacy`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textblob`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`neattext`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deep_translator`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code in the chapter can be accessed through the following GitHub link:
    [https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/c51973f13b69b94065544c4a33057412986e9b99/Chapter06](https://github.com/PacktPublishing/Web-App-Development-Made-Simple-with-Streamlit/tree/c51973f13b69b94065544c4a33057412986e9b99/Chapter06)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep-diving into NLP techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web application already has a well-structured skeleton that can be applied
    to future applications, which is very important. Additionally, our app offers
    a high level of customization, such as the ability to set a title and icon in
    the browser. We have also completed the **Text Analysis** and **About** sections
    of the menu. To see the current status of our developments, please refer to *Figure
    6**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Starting point of Chapter 6](img/B21147_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Starting point of Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: When we click on **Translation** or **Sentiment Analysis**, we just get, in
    the main part of our web app, a subheading reminding us of the section we are
    in, and nothing else. So, it’s now time to code these two functions.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the code, let’s try to understand exactly what translation
    and sentiment analysis are.
  prefs: []
  type: TYPE_NORMAL
- en: What is translation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Translation** in NLP is the task of automatically converting text or speech
    from one language to another. It helps break down language barriers and facilitates
    global communication. Advances in **machine translation** (**MT**) have revolutionized
    the field, with **statistical machine translation** (**SMT**) and **neural machine
    translation** (**NMT**) playing key roles. NMT, powered by deep learning and transformer
    models, captures context and generates more fluent translations. Challenges include
    preserving style, handling idioms, and adapting to specific domains. The future
    holds promise for further advancements in accurate and culturally sensitive translation
    systems, promoting cross-cultural understanding.'
  prefs: []
  type: TYPE_NORMAL
- en: What is sentiment analysis?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sentiment analysis**, or **opinion mining**, is a task in NLP that aims to
    extract emotions or subjective information from text. It involves classifying
    text into *positive*, *negative*, or *neutral* sentiments. Traditional approaches
    relied on rules and lexicons, while machine learning techniques, including deep
    learning and pre-trained models such as BERT, have revolutionized sentiment analysis.
    Challenges include fine-grained analysis and aspect-based sentiment. The future
    holds advancements in accuracy, language coverage, and ethical considerations.
    Sentiment analysis provides valuable insights for decision-making in various applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Sentiment analysis provides insights into opinions and emotions expressed in
    text. It helps businesses understand customer feedback, market trends, and public
    sentiment. By analyzing sentiment, companies can improve products, tailor marketing
    strategies, and make data-driven decisions. Sentiment analysis also finds applications
    in social media monitoring, reputation management, and public opinion analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Together, translation and sentiment analysis offer enhanced customer understanding.
    Businesses can analyze sentiment across languages, gaining insights from multilingual
    sources. This integration enables comprehensive views of customer sentiment across
    markets, aiding in identifying patterns, areas for improvement, and cultural context
    adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: These tools also contribute to social and political analysis. By analyzing sentiment
    across languages, researchers and policymakers gain a broader understanding of
    public sentiment on various topics, policies, and social movements. This facilitates
    effective communication and informed decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by checking out the **Translation** option on our menu.
  prefs: []
  type: TYPE_NORMAL
- en: Deep-diving into language translation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Translation breaks language barriers, facilitating global communication and
    cross-cultural understanding. It enables businesses to expand internationally,
    connect with diverse audiences, and foster cultural exchange. MT advancements
    make accurate and accessible translation services widely available, transforming
    the way we communicate in our interconnected world.
  prefs: []
  type: TYPE_NORMAL
- en: To add the translation function to our web app, we must add some lines of code
    in a very precise sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a text area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can imagine, the first thing to do to perform translation is to introduce
    a text area where we can write the text that needs to be translated. As we know
    very well, this operation is extremely easy since it needs just a line of code.
    So, the first step is to place our code in the appropriate section of the menu,
    as shown in *Figure 6**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Translation section](img/B21147_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Translation section'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add `text_area`, as shown in *Figure 6**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: A new text area](img/B21147_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: A new text area'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, by rerunning our web application in the browser, the new text area will
    be displayed. The text we put in this new `text_area` is stored in a variable
    named `raw_text`. When dealing with text, it’s always a good idea to check whether
    we really have some text to process or whether our content is empty, so let’s
    add a simple `if` clause to our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Text length check](img/B21147_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Text length check'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we would want to print a warning message if the text length is shorter
    than three characters. This is because many translation libraries need a minimum
    number of characters in order to process the text. So, if we write, for example,
    `hi`, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Text length check on the browser side](img/B21147_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Text length check on the browser side'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the text to be translated is ready, we need to deal with the translation
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the translation task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform the translation task, we will use a new library named `deep_translator`.
    So, first of all, let’s install it by simply typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let’s import this library by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are leveraging `GoogleTranslator` services.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get more information about `deep_translator`, please check its
    dedicated space on PyPI ([https://pypi.org/project/deep-translator/](https://pypi.org/project/deep-translator/)).
    You really will find out about a lot of extremely valuable features to explore.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.6: Deep\uFEFF-translator on PyPI](img/B21147_06_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Deep-translator on PyPI'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very important to define the language of the translation. So, let’s create
    a `select_box` that will enable users to choose a specific language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Text language selection](img/B21147_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Text language selection'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is very simple: we are just selecting a language from among a little
    subset (actually, a list) and assigning the proper code to it (`de` for German,
    `es` for Spanish, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, now that we have the target language, we just need to execute the
    translation and we can perform it, for example, by clicking on the **Translate**
    button; this is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: The Translation function code](img/B21147_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The Translation function code'
  prefs: []
  type: TYPE_NORMAL
- en: So, when the `GoogleTranslator` function of the `deep_translator` package (already
    imported previously), put the result into a `translated_text` variable, and then
    write it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result on the browser side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: The Translation function in action](img/B21147_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: The Translation function in action'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is very neat and clean and works perfectly! Of course, you can personalize
    this feature as you like, for example, by adding more target languages or performing
    different kinds of checks on the input text.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.10* shows the **Target Language** selection in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Target Language selection](img/B21147_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Target Language selection'
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have written less than 200 lines of code and our web application
    is working very well. With just a small amount of code, we were able to put together
    a backend and frontend, business logic running on a server, and a presentation
    layer living on a browser. Everything is in Python and is quite simple. This is
    the power of Streamlit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to our last NLP task: sentiment analysis. As we discovered in
    the introduction, it is a fascinating topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Diving deep into sentiment analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sentiment analysis task is quite easy because we can leverage `TextBlob`,
    which has already been imported. So, let’s start with the very poor code we have,
    which, at the moment, just prints a subheading on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Sentiment Analysis section](img/B21147_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Sentiment Analysis section'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, when we select **Sentiment Analysis** from our web application menu,
    we just get a subheading and some white space below it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Sentiment Analysis starting point](img/B21147_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Sentiment Analysis starting point'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by creating a text area, since we need somewhere to add the text
    we want to analyze in order to extract its sentiment. Adding a `text_area` now
    is really quite simple for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: A text_area for Sentiment Analysis](img/B21147_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: A text_area for Sentiment Analysis'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the result of the preceding change on the browser side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: The text area in the browser](img/B21147_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: The text area in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can type something in the text area and store it in a variable named,
    once again, `raw_data`.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, a great option we have is to add a button – we can call it, for example,
    `raw_text` length, and in case of missing text, we can print a warning message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple example of the code that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Evaluate button and check of raw_text length](img/B21147_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Evaluate button and check of raw_text length'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `raw_text` is not empty, we can use `TextBlob` to create a `blob` object.
    After that, we can use the blob’s `sentiment` method to get the sentiment of the
    text we just wrote, and at the end, we can write it on the screen. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16: The sentiment method provided by TextBlob](img/B21147_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: The sentiment method provided by TextBlob'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figures 6.17* and *6.18* show the result of the latest code modification in
    the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: The first case is positive sentiment, since the polarity is very high.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.17: An example of \uFEFFpositive sentiment](img/B21147_06_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: An example of positive sentiment'
  prefs: []
  type: TYPE_NORMAL
- en: The second case is negative sentiment, based on the rather low polarity.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.18: An example of \uFEFFnegative sentiment](img/B21147_06_18.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: An example of negative sentiment'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.19*, we can see the warning that appears when the **Evaluate**
    button is clicked, but there is no text to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.19: Enter \uFEFFa text... warning](img/B21147_06_19.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Enter a text... warning'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the TextBlob’s sentiment analysis returns two values: `polarity`
    and `subjectivity`. Let’s look in a little bit more detail at the meaning of these
    terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–1` up to `+1`. Specifically, `-1` indicates very negative sentiment, `+1`
    indicates very positive sentiment, and all values around `0` are generally considered
    neutral outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` up to `1`. Values around `0` are very objective results, while values around
    `1` are very subjective ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for a sentence such as *I loved that movie, it’s really great!*, we get
    a result like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20: High polarity and high subjectivity](img/B21147_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: High polarity and high subjectivity'
  prefs: []
  type: TYPE_NORMAL
- en: 'The movie received a high polarity score of `0.85` and a high subjectivity
    score due to the use of the first-person pronoun in *I loved*. This indicates
    a highly subjective opinion. Let’s write something different, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21: Neutral sentiment](img/B21147_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: Neutral sentiment'
  prefs: []
  type: TYPE_NORMAL
- en: The polarity of our statement is `0.26`, indicating neutrality since we presented
    a factual statement. The subjectivity is almost balanced since facts hold personal
    and universal perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s all! Our first web application is really finished! We implemented
    all the tasks we defined at the beginning using just Python, pure Python, and
    some free libraries!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take some time to recap what we have done so far.
  prefs: []
  type: TYPE_NORMAL
- en: Recap of our first web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s incredible, but we really did it! Starting from scratch, from an empty
    file, we created a well-working web application that performs a lot of tasks and
    provides us with very nice outputs.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we created a Python environment, and then we installed all the
    required libraries in it. After that, we started building the skeleton of our
    application. This point is very important because this skeleton, consisting of
    a menu that contains all the main features of our web application and various
    parts of code to manage these features, is something that we can reuse any time
    we want to create a new application.
  prefs: []
  type: TYPE_NORMAL
- en: The code of the application was created using basic widgets in Streamlit, that
    is, titles, subheaders, buttons, text areas, warnings, info, and so on, as well
    as some very interesting components, such as columns and expanders.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to add some basic HTML in our web applications, as well
    as some basic Markdown. We used these techniques to add some beautiful customizations
    on the titles. We then continued by talking about customizations. We also saw
    a way to associate a beautiful icon and a meaningful title or name to our application’s
    web browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'We delved into some fundamental concepts around NLP: tokens, lemmas, stopwords,
    word clouds, summarization, sentiment analysis, polarity, and objectivity. Our
    web app now also contains a very useful **About** section with information and
    working hyperlinks, which can be customized as you prefer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some screenshots of the final version of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22: Text Analysis](img/B21147_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Text Analysis'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.22*, we can see the complete menu on the left side of the screen
    and the result of the **Text Analysis** function applied to the short sentence
    in the text area in the main part of the web app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23: Translation](img/B21147_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: Translation'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.23* shows the behavior of the **Translation** function. This is
    quite self-explanatory: a sentence is typed into the text area, then a target
    language is selected, and finally, on pressing the **Translate** button, the translation
    task is performed and the result is displayed on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24: Sentiment Analysis](img/B21147_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: Sentiment Analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.24* shows an example of **Sentiment Analysis**, which in this case
    shows a very high polarity.'
  prefs: []
  type: TYPE_NORMAL
- en: We close the sequence of screenshots from the NLP web application we made together
    with the **About** section, as shown in *Figure 6**.25*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25: The About section](img/B21147_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.25: The About section'
  prefs: []
  type: TYPE_NORMAL
- en: The **About** section is very useful since it contains information about the
    author, links to external web pages, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is all the code we have written together up to now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26: NLP web application code part 1](img/B21147_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: NLP web application code part 1'
  prefs: []
  type: TYPE_NORMAL
- en: In part 1, we imported the packages, set the page configuration, and defined
    the `summarize_text` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: NLP web application code part 2](img/B21147_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: NLP web application code part 2'
  prefs: []
  type: TYPE_NORMAL
- en: In part 2, we wrote the `text_analyzer` function, then the `main` function,
    which contains the main title of the application, a subheading, and the menu in
    the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28: NLP web application code part 3](img/B21147_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.28: NLP web application code part 3'
  prefs: []
  type: TYPE_NORMAL
- en: In part 3, we developed the `main` function using an `if` loop and many advanced
    widgets, such as columns and expanders.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29: NLP web application code part 4](img/B21147_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.29: NLP web application code part 4'
  prefs: []
  type: TYPE_NORMAL
- en: In part 4, we mainly developed the **Translation** feature, making it possible
    to insert text and select a language.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.30: NLP web application code part 5](img/B21147_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: NLP web application code part 5'
  prefs: []
  type: TYPE_NORMAL
- en: In part 5, we implemented the `TextBlob` library, then completed the web app
    by adding the **About** section.
  prefs: []
  type: TYPE_NORMAL
- en: The full listing of our web application’s code makes it clear how powerful Streamlit
    is. Less than 200 lines of code are enough to create a fully working web application
    with a lot of advanced features and quite a nice look and feel. We achieved this
    result just using standard Python, with no need for HTML, CSS, JavaScript, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web application utilizing NLP is finished and running. You should be very
    proud of that!
  prefs: []
  type: TYPE_NORMAL
- en: We also recapped the main points and takeaways. So, what else can we do?
  prefs: []
  type: TYPE_NORMAL
- en: If we think about it, our application works very well, but only locally, or
    at least within the same network as the machine that we coded on.
  prefs: []
  type: TYPE_NORMAL
- en: For a web application to be defined as a real web application, it needs to be
    public. This means it needs to be accessible everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: To be accessed everywhere, our web application needs to live on a server on
    the real internet with a real public URL.
  prefs: []
  type: TYPE_NORMAL
- en: To put our web application on a real server on the web, we need to deploy it,
    and this is exactly what we are going to do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
