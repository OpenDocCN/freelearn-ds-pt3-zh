<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The pandas Library Architecture</h1>
                </header>
            
            <article>
                
<p>In this chapter, we examine the various libraries that are available to pandas users. This chapter is intended to be a short guide to help the user to navigate and find their way around the various modules and libraries that pandas provides. It gives a breakdown of how the library code is organized, and it gives a brief description of the various modules. It will be most valuable to users who are interested in seeing the inner workings of pandas , as well as to those who wish to make contributions to the code base. We will also briefly demonstrate how you can improve performance using Python extensions. The various topics that will be discussed are as follows:</p>
<ul>
<li>Introduction to the pandas library hierarchy</li>
<li>Description of pandas modules and files</li>
<li>Improving performance using Python extensions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the pandas file hierarchy</h1>
                </header>
            
            <article>
                
<p>Generally, upon installation, pandas is installed as a Python module in a standard location for third-party Python modules. In the following table, you will see the standard installation location for Unix/ macOS and the Windows platform: </p>
<table style="border-collapse: collapse;width: 840px;height: 222px" class="table" border="1">
<tbody>
<tr>
<td style="width: 119.132px" class="CDPAlignCenter CDPAlign">
<p><strong>Platform</strong></p>
</td>
<td style="width: 339.132px" class="CDPAlignCenter CDPAlign">
<p><strong>Standard installation location</strong></p>
</td>
<td style="width: 371.354px" class="CDPAlignCenter CDPAlign">
<p><strong>Example</strong></p>
</td>
</tr>
<tr>
<td style="width: 119.132px" class="CDPAlignCenter CDPAlign">
<p>Unix/macOS</p>
</td>
<td style="width: 339.132px" class="CDPAlignCenter CDPAlign">
<p><kbd>prefix/lib/pythonX.Y/site-packages</kbd></p>
</td>
<td style="width: 371.354px" class="CDPAlignCenter CDPAlign">
<p><kbd>/usr/local/lib/python2.7/site-packages</kbd></p>
</td>
</tr>
<tr>
<td style="width: 119.132px" class="CDPAlignCenter CDPAlign">
<p>Windows</p>
</td>
<td style="width: 339.132px" class="CDPAlignCenter CDPAlign">
<p><kbd>prefix\Lib\site-packages</kbd></p>
</td>
<td style="width: 371.354px" class="CDPAlignCenter CDPAlign">
<p><kbd>C:\Python27\Lib\site-packages</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If Python installation was done with Anaconda, then the pandas module can be found in the Anaconda directory, within a similar file path: <kbd>Anaconda3\pkgs\pandas-0.23.4-py37h830ac7b_0\Lib\site-packages\pandas</kbd>.</p>
<p class="mce-root"/>
<p>Now that we have had a look at the module on <span>third-party</span> Python modules, we will understand the file hierarchy. There are eight types of file in the installed Pandas library. The installed files follow a specific hierarchy, which is described here:</p>
<ul>
<li><kbd>pandas/core</kbd>: This contains files for fundamental data structures, such as Series/DataFrames and related functionalities.</li>
<li><kbd>pandas/src</kbd>: This contains Cython and C code for implementing fundamental algorithms.</li>
<li><kbd>pandas/io</kbd>: This contains input/output tools for handling different file formats, such as flat files, Excel, HDF5, and SQL.</li>
<li><kbd>pandas/tools</kbd>: This contains auxiliary data algorithms, merge and join routines, concatenation, pivot tables, and more. This module primarily serves data-manipulation operations.</li>
<li><kbd>pandas/sparse</kbd>: This contains sparse versions of data structures, such as series, DataFrame, Panels, and more.</li>
<li><kbd>pandas/stats</kbd>: This contains linear and panel regression, moving window regression, and several other statistical functions. This should be replaced by functionality in statsmodels.</li>
<li><kbd>pandas/util</kbd>: This contains utilities and development and testing tools.</li>
<li><kbd>pandas/rpy</kbd>: This contains the RPy2 interface for connecting to R, thereby widening the scope of analytical operations on data.</li>
</ul>
<p>For more information, see: <a href="http://pandas.pydata.org/developers.html"><span class="URLPACKT">http://pandas.pydata.org/developers.html</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Description of pandas modules and files</h1>
                </header>
            
            <article>
                
<p>In this section, we provide brief descriptions of the various sub-modules and files that make up the pandas library. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/core</h1>
                </header>
            
            <article>
                
<p>The module contains the core submodules of pandas. They are discussed as follows:</p>
<ul>
<li><kbd>api.py</kbd>: This imports some key modules and warnings for later use, such as indexing, <kbd>groupby</kbd>, and reshaping functions.</li>
<li><kbd>apply.py</kbd>: This module contains classes that help to apply a function to a DataFrame or series.</li>
<li><kbd>arrays</kbd>: This isolates pandas' exposure to <kbd>numpy</kbd>—that is, all direct <kbd>numpy</kbd> usage. The <kbd>base.py</kbd> submodule of array handles all array-oriented operations, such as the <kbd>ndarray</kbd> value, shape, and <kbd>ndim</kbd>, while the <kbd>categorical.py</kbd> submodule caters specifically for categorical values.</li>
<li><kbd>base.py</kbd>: This defines fundamental classes such as <kbd>StringMixin</kbd> and <kbd>PandasObject</kbd>, which is the base class for various pandas objects, such as <kbd>Period</kbd>, <kbd>PandasSQLTable</kbd>, <kbd>sparse.array.SparseArray</kbd>/<kbd>SparseList</kbd>, <kbd>internals.Block</kbd>, <kbd>internals.BlockManager</kbd>, <kbd>generic.NDFrame</kbd>, <kbd>groupby.GroupBy</kbd>, <kbd>base.FrozenList</kbd>, <kbd>base.FrozenNDArray</kbd>, <kbd>io.sql.PandasSQL</kbd>, <kbd>io.sql.PandasSQLTable</kbd>, <kbd>tseries.period.Period</kbd>, <kbd>FrozenList</kbd>, <kbd>FrozenNDArray: IndexOpsMixin</kbd>, and <kbd>DatetimeIndexOpsMixin</kbd>.</li>
<li><kbd>common.py</kbd>: This defines common utility methods for handling data structures. For example, the <kbd>isnull</kbd> object detects missing values.</li>
<li><kbd>config.py</kbd>: This is the module for handling package-wide configurable objects. It defines the following classes: <kbd>OptionError</kbd>, <kbd>DictWrapper</kbd>, <kbd>CallableDynamicDoc</kbd>, <kbd>option_context</kbd>, and <kbd>config_init</kbd>.</li>
<li><kbd>datetools.py</kbd>: This is a collection of functions that deal with dates in Python. It also utilizes some functions from the <kbd>tseries</kbd> module of pandas.</li>
<li><kbd>frame.py</kbd>: This defines the pandas DataFrame class and its various methods. DataFrame inherits from NDFrame (see the following). It borrows functions from several submodules under the <kbd>pandas-core</kbd> module to define the functional aspects of a DataFrame.</li>
<li><kbd>generic.py</kbd>: This defines the generic NDFrame base class, which is a base class for pandas DataFrame, series, and panel classes. NDFrame is derived from <kbd>PandasObject</kbd>, which is defined in <kbd>base.py</kbd>. An NDFrame can be regarded as an N-dimensional version of a pandas DataFrame. For more information on this, go to <a href="http://nullege.com/codes/search/pandas.core.generic.NDFrame">http://nullege.com/codes/search/pandas.core.generic.NDFrame</a>.</li>
<li><kbd>categorical.py</kbd>: This defines categorical, which is a class that derives from <kbd>PandasObject</kbd> and represents categorical variables 'a' la R/S-plus. (We will expand your knowledge on this a bit more later).</li>
<li><kbd>groupby.py</kbd>: This defines various classes that enable the <kbd>groupby</kbd> functionality:
<ul>
<li><strong>Splitter classes</strong>: This includes <kbd>DataSplitter</kbd>, <kbd>ArraySplitter</kbd>, <kbd>SeriesSplitter</kbd>, <kbd>FrameSplitter</kbd>, and <kbd>NDFrameSplitter</kbd>.</li>
<li><strong>Grouper/grouping classe</strong>s: This includes <kbd>Grouper</kbd>, <kbd>GroupBy</kbd>, <kbd>BaseGrouper</kbd>, <kbd>BinGrouper</kbd>, <kbd>Grouping</kbd>, <kbd>SeriesGroupBy</kbd>, and <kbd>NDFrameGroupBy</kbd>.</li>
</ul>
</li>
<li><kbd>ops.py</kbd>: This defines an internal API for arithmetic operations on <kbd>PandasObjects</kbd>. It defines functions that add arithmetic methods to objects. It defines a <kbd>_create_methods</kbd> metamethod, which is used to create other methods using arithmetic, comparison, and Boolean method constructors. The <kbd>add_methods</kbd> method takes a list of new methods, adds them to the existing list of methods, and binds them to their appropriate classes. The <kbd>add_special_arithmetic_methods</kbd>, <kbd>add_flex_arithmetic_methods</kbd>, <kbd>call _create_methods</kbd>, and <kbd>add_methods</kbd> are used to add arithmetic methods to a class.</li>
</ul>
<p style="padding-left: 90px">It defines the <kbd>_TimeOp</kbd> class, which is a wrapper for datetime-related arithmetic operations. It contains wrapper functions for arithmetic, comparison, and Boolean operations on series, DataFrame, and panel functions: <kbd>_arith_method_SERIES(..)</kbd>, <kbd>_comp_method_SERIES(..)</kbd>, <kbd>_bool_method_SERIES(..)</kbd>, <kbd>_flex_method_SERIES(..)</kbd>, <kbd>_arith_method_FRAME(..)</kbd>, <kbd>_comp_method_FRAME(..)</kbd>, <kbd>_flex_comp_method_FRAME(..)</kbd>, <kbd>_arith_method_PANEL(..)</kbd>, and <kbd>_comp_method_PANEL(..)</kbd>.</p>
<ul>
<li><kbd>index.py</kbd>: This defines the index class and its related functionality. Index is used by all pandas objects—series, DataFrame, and panel<span>—</span>to store axis labels. Underneath it is an immutable array that provides an ordered set that can be sliced.</li>
<li><kbd>indexing.py</kbd>: This module contains a series of functions and classes that make multi-indexing easier.</li>
<li><kbd>missing.py</kbd>: This defines techniques such as masking and interpolation to handle missing data.</li>
<li><kbd>internals.py</kbd>: This defines multiple object classes. These are listed as follows:
<ul>
<li><kbd>Block</kbd>: This is a homogeneously typed N-dimensional <kbd>numpy.ndarray</kbd> object with additional functionality for pandass—for example, it uses <kbd>__slots__</kbd> to restrict the attributes of the object to <kbd>ndim</kbd>, <kbd>values</kbd>, and <kbd>_mgr_locs</kbd>. It acts as the base class for other Block subclasses.</li>
<li><kbd>NumericBlock</kbd>: This is the base class for blocks with the numeric type.</li>
<li><kbd>FloatOrComplexBlock</kbd>: This is the base class for <kbd>FloatBlock</kbd> and <kbd>ComplexBlock</kbd> that inherits from <kbd><kbd>NumericBlock</kbd></kbd></li>
<li><kbd>ComplexBlock</kbd>: This is the class that handles the Block objects with the complex type.</li>
<li><kbd>FloatBlock</kbd>: This is the class that handles the Block objects with the float type.</li>
<li><kbd>IntBlock</kbd>: This is the class that handles the Block objects with the integer type.</li>
<li><kbd>TimeDeltaBlock</kbd>, <kbd>BoolBlock</kbd>, and <kbd>DatetimeBlock</kbd>: These are the block classes for timedelta, Boolean, and datetime.</li>
<li><kbd>ObjectBlock</kbd>: This is the class that handles block objects for user-defined objects.</li>
<li><kbd>SparseBlock</kbd>: This is the class that handles sparse arrays of the same type.</li>
<li><kbd>BlockManager</kbd>: This is the class that manages a set of block objects. It is not a public API class.</li>
<li><kbd>SingleBlockManager</kbd>: This is the class that manages a single block.</li>
<li><kbd>JoinUnit</kbd>: This is the utility class for block objects.</li>
</ul>
</li>
<li><kbd>nanops.py</kbd>: This submodule has a set of classes and functionalities for exclusively handling NaN values.</li>
<li><kbd>ops.py</kbd>: This defines arithmetic operations for pandas objects. It is not a public API.</li>
<li><kbd>panel.py</kbd>, <kbd>panel4d.py</kbd>, and <kbd>panelnd.py</kbd>: These provide the functionality for the pandas panel object.</li>
<li><kbd>resample.py</kbd>: This defines a custom <kbd>groupby</kbd> class for time-interval grouping and aggregation.</li>
<li><kbd>series.py</kbd>: This defines the pandas Series class and the various methods that Series inherits from NDFrame and <kbd>IndexOpsMixin</kbd> to accommodate 1-dimensional data structures and 1-dimensional time series data.</li>
<li><kbd>sorting.py</kbd>: This defines all necessary utilities for sorting.</li>
<li><kbd>sparse.py</kbd>: This defines the import for handling sparse data structures. Sparse data structures are compressed in that data points matching NaN or missing values are omitted. For more information on this, go to <a href="http://pandas.pydata.org/pandas-docs/stable/sparse.html">http://pandas.pydata.org/pandas-docs/stable/sparse.html</a>.</li>
<li><kbd>strings.py</kbd>: These have various functions, such as <kbd>str_replace</kbd>, <kbd>str_contains</kbd>, and <kbd>str_cat</kbd>, for handling strings manipulations.</li>
<li><kbd>window.py</kbd>: This helps in the windowing of data structures and computing aggregates in a rolling window.</li>
</ul>
<p>The following diagram gives an overview of the structure of the Pandas core:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bcfb4a6b-c2cc-4288-acd4-85c133bf8dee.png" style="width:15.50em;height:24.50em;"/><strong><br/></strong></p>
<p>Now, let's move on to the next submodule.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/io</h1>
                </header>
            
            <article>
                
<p>This module contains various modules for data I/O. These are as follows:</p>
<ul>
<li><kbd>api.py</kbd>: This defines various imports for the data I/O API.</li>
<li><kbd>common.py</kbd>: This defines the common functionality for the I/O API.</li>
<li><kbd>clipboards.py</kbd>: This contains cross-platform clipboard methods to enable the copy and paste functions from the keyboard. The pandas I/O API includes functions such as <kbd>pandas.read_clipboard()</kbd> and <kbd>pandas.to_clipboard(..)</kbd>.</li>
</ul>
<ul>
<li><kbd>date_converters.py</kbd>: This defines date conversion functions.</li>
<li><kbd>excel.py</kbd>: This module parses and converts Excel data. This defines the <kbd>ExcelFile</kbd> and <kbd>ExcelWriter</kbd> classes.</li>
<li><kbd>feather_format.py</kbd>: This module reads and writes data in Feather format.</li>
<li><kbd>gbq.py</kbd> : This is the module for Google's BigQuery.</li>
<li><kbd>html.py</kbd>: This is the module for dealing with HTML I/O.</li>
<li><kbd>json.py</kbd>: This is the module for dealing with JSON I/O in pandas. This defines the <kbd>Writer</kbd>, <kbd>SeriesWriter</kbd>, <kbd>FrameWriter</kbd>, <kbd>Parser</kbd>, <kbd>SeriesParser</kbd>, and <kbd>FrameParser</kbd> classes.</li>
<li><kbd>msgpack</kbd>: This module reads and writes data to <kbd>msgpack</kbd> format.</li>
<li><kbd>packer.py</kbd>: This is an <kbd>msgpack</kbd> serializer support for reading and writing pandas data structures to disk.</li>
<li><kbd>parquet.py</kbd>: This module reads and writes data in Parquet format.</li>
<li><kbd>parsers.py</kbd>: This is the module that defines various functions and classes that are used in parsing and processing files to create pandas DataFrames. All of the three <kbd>read_*</kbd> functions discussed in the following list have multiple configurable options for reading. For more details, see <a href="http://bit.ly/1EKDYbP">http://bit.ly/1EKDYbP</a>:
<ul>
<li><kbd>read_csv(..)</kbd>: This defines the <kbd>pandas.read_csv()</kbd> function that is used to read the contents of a CSV file into a DataFrame.</li>
<li><kbd>read_table(..)</kbd>: This reads a tab-separated table file into a DataFrame.</li>
<li><kbd>read_fwf(..)</kbd>: This reads a fixed-width format file into a DataFrame.</li>
<li><kbd>TextFileReader</kbd>: This is the class that is used for reading text files.</li>
<li><kbd>ParserBase</kbd>: This is the base class for parser objects.</li>
<li><kbd>CParserWrapper</kbd>, <kbd>PythonParser</kbd>: These are the parser for C and Python respectively. They both inherit from <kbd>ParserBase</kbd>.</li>
<li><kbd>FixedWidthReader</kbd>: This is the class for reading fixed-width data. A fixed-width data file contains fields in specific positions within the file.</li>
<li><kbd>FixedWithFieldParser</kbd>: This is the class for parsing fixed-width fields that have been inherited from <kbd>PythonParser</kbd>.</li>
</ul>
</li>
<li><kbd>pickle.py</kbd>: This provides methods for pickling (serializing) pandas objects. These are as follows:
<ul>
<li><kbd>to_pickle(..)</kbd>: This serializes an object to file.</li>
<li><kbd>read_pickle(..)</kbd>: This reads serialized objects from a file into a pandas object. It should only be used with trusted sources.</li>
</ul>
</li>
<li><kbd>pytables.py</kbd>: This is an interface for PyTables module for reading and writing pandas data structures to files on disk.</li>
<li><kbd>sql.py</kbd>: This is a collection of classes and functions that enable the retrieval of data from relational databases that attempts to be database-agnostic. These classes and functions are as follows:
<ul>
<li><kbd>PandasSQL</kbd>: This is the base class for interfacing pandas with SQL. It provides dummy <kbd>read_sql</kbd> and <kbd>to_sql</kbd> methods that must be implemented by subclasses.</li>
<li><kbd>PandasSQLAlchemy</kbd>: This is the subclass of <kbd>PandasSQL</kbd> that enables conversions between DataFrame and SQL databases using SQLAlchemy.</li>
<li><kbd>PandasSQLTable</kbd>: This maps pandas tables (DataFrame) to SQL tables.</li>
<li><kbd>pandasSQL_builder(..)</kbd>: This returns the correct PandasSQL subclass based on the provided parameters.</li>
<li><kbd>PandasSQLTableLegacy</kbd>: This class is the legacy support version of <kbd>PandasSQLTable.</kbd></li>
<li><kbd>PandasSQLLegacy</kbd>: This class is the legacy support version of <kbd>PandasSQLTable</kbd>.</li>
<li><kbd>get_schema(..)</kbd>: This gets the SQL database table schema for a given frame.</li>
<li><kbd>read_sql_table(..)</kbd>: This reads an SQL database table into a DataFrame.</li>
<li><kbd>read_sql_query(..)</kbd>: This reads an SQL query into a DataFrame.</li>
<li><kbd>read_sql(..)</kbd>: This reads an SQL query/table into a DataFrame.</li>
</ul>
</li>
<li><kbd>stata.py</kbd>: This contains tools for processing Stata files into pandas DataFrames.</li>
<li><kbd>sas</kbd>: This module contains submodules that help to read data from SAS outputs.</li>
<li><kbd>S3.py</kbd>: This module provides remote connectivity to S3 buckets.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/tools</h1>
                </header>
            
            <article>
                
<p>The details of the module are as follows:</p>
<ul>
<li><kbd>plotting.py</kbd>: This serves as a wrapper for the plotting module and has been deprecated in the recent version.</li>
<li><kbd>merge.py</kbd>: This provides functions for combining series, DataFrame, and panel objects, such as <kbd>merge(..)</kbd> and <kbd>concat(..)</kbd>, and has been deprecated in the recent version.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/util</h1>
                </header>
            
            <article>
                
<p>This <kbd>pandas/util</kbd> is the module that provides utility functionalities. The details of this module are as follows:</p>
<ul>
<li><kbd>testing.py</kbd>: This provides the <kbd>assertion</kbd>, <kbd>debug</kbd>, <kbd>unit test</kbd>, and other classes/functions for use in testing. It contains many special assert functions that make it easier to check whether series, DataFrame, or panel objects are equivalent. Some of these functions include <kbd>assert_equal(..)</kbd>, <kbd>assert_series_equal(..)</kbd>, <kbd>assert_frame_equal(..)</kbd>, and <kbd>assert_panelnd_equal(..)</kbd>. The <kbd>pandas.util.testing</kbd> module is especially useful to the contributors of the pandas code base. It defines a <kbd>util.TestCase</kbd> class. It also provides utilities for handling locales, console debugging, file cleanup, comparators, and so on for testing by potential code base contributors.</li>
<li><kbd>doctools.py</kbd>: This submodule has the <kbd>TablePlotter</kbd> class, which helps to define a layout for DataFrames.</li>
<li><kbd>validators.py</kbd>: This submodule helps to validate arguments passed to functions. For instance, it helps to evaluate the argument length, the default values, and argument values.</li>
<li><kbd>print_versions.py</kbd>: This defines the <kbd>get_sys_info()</kbd> function, which returns a dictionary of systems information and the <kbd>show_versions(..)</kbd> function, which displays the versions of available Python libraries.</li>
<li><kbd>misc.py</kbd>: This defines a couple of miscellaneous utilities.</li>
<li><kbd>decorators.py</kbd>: This defines some decorator functions and classes.</li>
<li>The substitution and appender classes are decorators that perform substitution and appending on function docstrings. For more information on Python decorators, go to <span class="MsoHyperlink"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a></span>.</li>
<li><kbd>test_decorators.py</kbd>: This submodule provides decorators to test objects.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/tests</h1>
                </header>
            
            <article>
                
<p>This <kbd>pandas/tests</kbd> is the module that provides many tests for various objects in pandas. The names of the specific library files are fairly self-explanatory, and I will not go into further details here; instead, I invite the reader to explore.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/compat</h1>
                </header>
            
            <article>
                
<p>Functionalities related to compatibility are explained as follows:</p>
<ul>
<li><kbd>chainmap.py</kbd> and <kbd>chainmap_impl.py</kbd>: These provide a <kbd>ChainMap</kbd> class that can group multiple <kbd>dicts</kbd> or mappings to produce a single view that can be updated.</li>
<li><kbd>pickle_compat.py</kbd>: This provides functionality for pickling pandas objects in versions that are earlier than 0.12.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/computation</h1>
                </header>
            
            <article>
                
<p>This <kbd>pandas/computation</kbd> is the module that provides functionality for computation and is discussed as follows:</p>
<ul>
<li><kbd>expressions.py</kbd>: This provides fast expression evaluation through <kbd>numexpr</kbd>. The <kbd>numexpr</kbd> function is used to accelerate certain numerical operations. It uses multiple cores as well as smart chunking and caching speedups. It defines the <kbd>evaluate(..)</kbd> and <kbd>where(..)</kbd> methods. This module has been deprecated in the most recent version of pandas; the alternative usage will be through <kbd>pandas.get_option</kbd>.</li>
<li>For more information on <kbd>numexpr</kbd>, go to <a href="https://code.google.com/p/numexpr/">https://code.google.com/p/numexpr/</a>. For information on the usage of this module, go to <a href="http://pandas.pydata.org/pandas-docs/version/0.15.0/computation.html">http://pandas.pydata.org/pandas-docs/version/0.15.0/computation.html</a>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/plotting</h1>
                </header>
            
            <article>
                
<p>The <kbd>pandas/plotting</kbd> is the module that takes care of all of the plotting functionalities pandas offers:</p>
<ul>
<li><kbd>compat.py</kbd>: This module checks for version compatibility.</li>
<li><kbd>converter.py</kbd>: This module helps process datetime values for plotting. It helps to execute functions such as autoscaling of time series axes and formatting ticks for datetime axes.</li>
<li><kbd>core.py</kbd>: This defines classes that help in creating plots, such as bar plots, scatter plots, hex bin plots, and box plots.</li>
<li><kbd>misc.py</kbd>: This provides a set of plotting functions that take a series or DataFrame as an argument. This module contains the following submodules for performing miscellaneous tasks, such as plotting scatter matries and Andrews curve:
<ul>
<li><kbd>scatter_matrix(..)</kbd>: This draws a matrix of scatter plots.</li>
<li><kbd>andrews_curves(..)</kbd>: This plots multivariate data as curves that are created using samples as coefficients for a Fourier series.</li>
<li><kbd>parallel_coordinates(..)</kbd>: This is a plotting technique that allows you to see clusters in data and visually estimate statistics.</li>
<li><kbd>lag_plot(..)</kbd>: This is used to check whether a dataset or a time series is random.</li>
<li><kbd>autocorrelation_plot(..)</kbd>: This is used for checking randomness in a time series.</li>
<li><kbd>bootstrap_plot(..)</kbd>: This plot is used to determine the uncertainty of a statistical measure, such as mean or median, in a visual manner</li>
<li><kbd>radviz(..)</kbd>: This plot is used to visualize multivariate data.</li>
</ul>
</li>
<li><kbd>style.py</kbd>: This provides a set of styling options for the plot.</li>
<li><kbd>timeseries.py</kbd>: This defines auxiliary classes for time series plots.</li>
<li><kbd>tools.py</kbd>: This contains some helper functions that create a table layout from DataFrames and series.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">pandas/tseries</h1>
                </header>
            
            <article>
                
<p class="mce-root">This section deals with the <kbd>pandas/tseries</kbd> module, which gives pandas its functionality to work with time series data:</p>
<ul>
<li><kbd>api.py</kbd>: This is a set of convenience imports.</li>
<li><kbd>converter.py</kbd>: This defines a set of classes that are used to format and convert.</li>
<li><kbd>datetime</kbd>: Upon importing pandas, this registers a set of unit converters with <kbd>matplotlib</kbd>. This is done via the <kbd>register()</kbd> <span>function,</span> <span>as follows:</span></li>
</ul>
<pre>In [1]: import matplotlib.units as munits<br/>In [2]: munits.registry<br/>Out[2]: {}<br/>In [3]: import pandas<br/>In [4]: munits.registry<br/>Out[4]:<br/>{pandas.tslib.Timestamp: &lt;pandas.tseries.converter.DatetimeConverter instance at 0x7fbbc4db17e8&gt;,<br/>pandas.tseries.period.Period: &lt;pandas.tseries.converter.PeriodConverter instance at 0x7fbbc4dc25f0&gt;,<br/>datetime.date: &lt;pandas.tseries.converter.DatetimeConverter instance at 0x7fbbc4dc2fc8&gt;,<br/>datetime.datetime: &lt;pandas.tseries.converter.DatetimeConverter instance at 0x7fbbc4dc2a70&gt;,<br/>datetime.time: &lt;pandas.tseries.converter.TimeConverter instance at 0x7fbbc4d61e18&gt;}</pre>
<ul>
<li><kbd>Converter</kbd>: This class includes <kbd>TimeConverter</kbd>, <kbd>PeriodConverter</kbd>, and <kbd>DateTimeConverter</kbd>.</li>
<li><kbd>Formatters</kbd>: This class includes <kbd>TimeFormatter</kbd>, <kbd>PandasAutoDateFormatter</kbd>, and <kbd>TimeSeries_DateFormatter</kbd>.</li>
<li><kbd>Locators</kbd>: This class includes <kbd>PandasAutoDateLocator</kbd>, <kbd>MilliSecondLocator</kbd>, and <kbd>TimeSeries_DateLocator</kbd>.</li>
</ul>
<div class="packt_infobox">The <kbd>Formatter</kbd> and <kbd>Locator</kbd> classes are used for handling ticks in <kbd>matplotlib</kbd> plotting.</div>
<ul>
<li><kbd>frequencies.py</kbd>: This defines the code for specifying frequencies<span>—</span>daily, weekly, quarterly, monthly, annual, and so on<span>—</span>of time series objects. This submodule depends on the <kbd>dtypes</kbd> submodule of the pandas/core module.</li>
<li><kbd>holiday.py</kbd>: This defines functions and classes for handling holidays<span>—</span><kbd>Holiday</kbd>, <kbd>AbstractHolidayCalendar</kbd>, and <kbd>USFederalHolidayCalendar</kbd> are among the classes defined.</li>
<li><kbd>offsets.py</kbd>: This defines various classes, including offsets that deal with time-related periods. These classes are explained as follows:
<ul>
<li><kbd>DateOffset</kbd>: This is an interface for classes that provide the time period functionality, such as <kbd>Week</kbd>, <kbd>WeekOfMonth</kbd>, <kbd>LastWeekOfMonth</kbd>, <kbd>QuarterOffset</kbd>, <kbd>YearOffset</kbd>, <kbd>Easter</kbd>, <kbd>FY5253</kbd>, and <kbd>FY5253Quarter</kbd>.</li>
<li><kbd>BusinessMixin</kbd>: This is the mixin class for business objects to provide functionality with time-related classes. This is inherited by the <kbd>BusinessDay</kbd> class. The <kbd>BusinessDay</kbd> subclass is derived from <kbd>BusinessMixin</kbd> and <kbd>SingleConstructorOffset</kbd>, and provides an offset on business days.</li>
<li><kbd>MonthOffset</kbd>: This is the interface for classes that provide the functionality for month time periods, such as <kbd>MonthEnd</kbd>, <kbd>MonthBegin</kbd>, <kbd>BusinessMonthEnd</kbd>, and <kbd>BusinessMonthBegin</kbd>.</li>
<li><kbd>MonthEnd</kbd> and <kbd>MonthBegin</kbd>: These provide a date offset of one month at the end or the beginning.</li>
<li><kbd>BusinessMonthEnd</kbd> and <kbd>BusinessMonthBegin</kbd>: These provide a date offset of one month at the end or the beginning of a business day calendar.</li>
<li><kbd>YearOffset</kbd>: This offset is subclassed by classes that provide year- period functionality<span>—</span><kbd>YearEnd</kbd>, <kbd>YearBegin</kbd>, <kbd>BYearEnd</kbd>, and <kbd>BYearBegin</kbd>.</li>
<li><kbd>YearEnd</kbd> and <kbd>YearBegin</kbd>: <span>These provide a date </span>offset of one year at the end or the beginning.</li>
<li><kbd>BYearEnd</kbd> and <kbd>BYearBegin</kbd>: <span>These provide a date </span>offset of one year at the end or the beginning of a business day calendar.</li>
<li><kbd>Week</kbd>: This provides an offset of one week.</li>
<li><kbd>WeekDay</kbd>: This provides mapping from a weekday (for example, Tue) to any day of the week (for example, =2).</li>
<li><kbd>WeekOfMonth</kbd> and <kbd>LastWeekOfMonth</kbd>: This describes dates in a week of the month.</li>
<li><kbd>QuarterOffset</kbd>: This is subclassed by classes that provide quarterly period functionality—<kbd>QuarterEnd</kbd>, <kbd>QuarterrBegin</kbd>, <kbd>BQuarterEnd</kbd>, and <kbd>BQuarterBegin</kbd>.</li>
<li><kbd>QuarterEnd</kbd>, <kbd>QuarterrBegin</kbd>, <kbd>BQuarterEnd</kbd>, and <kbd>BQuarterBegin</kbd>: These are the same as for <kbd>Year*</kbd> classes, except the period is a quarter instead of a year.</li>
<li><kbd>FY5253</kbd> and <kbd>FY5253Quarter</kbd>: These classes describe a 52- and 53-week fiscal year respectively. This is also known as a 4-4-5 calendar. </li>
<li><kbd>Easter</kbd>: This is <kbd>DateOffset</kbd> for the Easter holiday.</li>
<li><kbd>Tick</kbd>: This is the base class for the time unit classes, such as <kbd>Day</kbd>, <kbd>Hour</kbd>, <kbd>Minute</kbd>, <kbd>Second</kbd>, <kbd>Milli</kbd>, <kbd>Micro</kbd>, and <kbd>Nano</kbd>.</li>
</ul>
</li>
<li><kbd>plotting.py</kbd>: This imports the <kbd>tsplot(..)</kbd> submodule from the <kbd>pandas-plotting</kbd> module.</li>
</ul>
<p>Next, we will see how we can improve the performance of Python codes using Python extensions.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving performance using Python extensions</h1>
                </header>
            
            <article>
                
<p>One of the gripes of Python and pandas users is that the ease of use and expressiveness of the language and module comes with a significant downside<span>—</span>the performance. This happens especially when it comes to numeric computing.</p>
<p>According to programming benchmark <span><span>standards</span></span>, Python is often slower than compiled languages, such as C/C++, for many algorithms or data structure operations. An example of this would be binary-tree operations. In one simulation experiment, Python3 ran 104 times slower than the fastest C++ implementation of an <em>n</em>-body simulation calculation.</p>
<p>So, how can we solve this legitimate, yet vexing problem? We can mitigate this slowness in Python while maintaining the things that we like<span>—</span>clarity and productivity. This can be done by writing the parts of our code that are performance-sensitive-for example, numeric processing, algorithms in C/C++-and having them called by our Python code by writing a Python extension module. For more details, go to <a href="http://docs.python.org/2/extending/extending.html"><span class="URLPACKT">http://docs.python.org/2/extending/extending.html</span></a>.</p>
<p>Python extension modules enable us to make calls out to user-defined C/C++ code or library functions from Python, which enables us to boost our code performance and benefit from the ease of using Python.</p>
<p>To help us to understand what a Python extension module is, let's consider what happens in Python when a module has been imported. An import statement <em>imports</em> a module, but what does this really mean? There are three possibilities, which are as follows:</p>
<ul>
<li>Some Python extension modules are linked to the interpreter when it is built.</li>
<li>An import causes Python to load a <kbd>.pyc</kbd> file into memory. The <kbd>.pyc</kbd> files contain Python <kbd>bytecode</kbd>, as shown in the following code snippet:</li>
</ul>
<pre>    In [3]: import pandas
                    pandas.__file__
    Out[3]: '/usr/lib/python2.7/site-packages/pandas/__init__.pyc'</pre>
<ul>
<li>The import statement causes a Python extension module to be loaded into memory. The <kbd>.</kbd><kbd>so</kbd> (shared object) file is comprised of machine code, as shown in the following code snippet:</li>
</ul>
<pre>    In [4]: import math
              math.__file__
    Out[4]: '/usr/lib/python2.7/lib-dynload/math.so'</pre>
<p>We will focus on the third possibility as this is the most common. Even though we are dealing with a binary-shared object compiled from C, we can import it as a Python module. This shows the power of Python extensions<span>—</span>applications can import modules from Python machine code or machine code and the interface is the same. Cython and SWIG are the two most popular methods of writing extensions in C and C++. In writing an extension, we wrap up C/C++ machine code and turn it into Python extension modules that behave like pure Python code. In this brief discussion, we will only focus on Cython, as it was designed specifically for Python.</p>
<p>Cython is a superset of Python that was designed to significantly improve Python's performance by allowing us to call externally compiled code in C/C++, as well as declare types on variables.</p>
<p>The Cython command generates an optimized C/C++ source file from a Cython source file and compiles this optimized C/C++ source into a Python extension module. It offers built-in support for NumPy and combines C's performance with Python's usability.</p>
<p>We will give a quick demonstration of how we can use Cython to significantly speed up our code. Let's define a simple Fibonacci function:</p>
<pre>    In [17]: def fibonacci(n):
             a,b=1,1
             for i in range(n):
                 a,b=a+b,a
             return a
    In [18]: fibonacci(100)
    Out[18]: 927372692193078999176L
    In [19]: %timeit fibonacci(100)
             100000 loops, best of 3: 18.2 µs per loop  </pre>
<p>Using the <kbd>timeit</kbd> module, we see that it takes 18.2 µs per loop.</p>
<p>Let's now rewrite the function in Cython, specifying types for the variables by going through the following steps:</p>
<ol>
<li>First, we import the Cython magic function to iPython as follows:</li>
</ol>
<pre>    In [22]: %load_ext cythonmagic</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>Next, we rewrite our function in Cython, specifying types for our variables:</li>
</ol>
<pre>    In [24]: %%cython
             def cfibonacci(int n):
                 cdef int i, a,b
                 for i in range(n):
                     a,b=a+b,a
                 return a </pre>
<ol start="3">
<li>Let's time our new Cython function:</li>
</ol>
<pre>    In [25]: %timeit cfibonacci(100)
             1000000 loops, best of 3: 321 ns per loop
    
    In [26]: 18.2/0.321
    Out[26]: 56.69781931464174  </pre>
<ol start="4">
<li>We can see that the Cython version is 57 times faster than the pure Python version!</li>
</ol>
<p>For more information on writing Python extensions using Cython/SWIG or other options, please refer to the following sources:</p>
<ul>
<li>Pandas documentation, entitled <em>Enhancing Performance</em>, at <a href="http://pandas.pydata.org/pandas-docs/stable/enhancingperf.html"><span class="URLPACKT">http://pandas.pydata.org/pandas-docs/stable/enhancingperf.html</span></a></li>
<li>ScipPy lecture notes, entitled <em>Interfacing with C</em>, at <a href="https://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html"><span class="URLPACKT">https://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html</span></a></li>
<li>Cython documentation at <a href="http://docs.cython.org/index.html"><span class="URLPACKT">http://docs.cython.org/index.html</span></a></li>
<li>SWIG documentation at <a href="http://www.swig.org/Doc2.0/SWIGDocumentation.html"><span class="URLPACKT">http://www.swig.org/Doc2.0/SWIGDocumentation.html</span></a></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>To summarize this chapter, we took a tour of the library hierarchy of pandas in an attempt to illustrate the internal guts of the library. This understanding will be useful for building custom modules from pandas code or improving the functionalities of pandas as an open source contributor. We also touched on the benefits of speeding up our code performance by using a Python extension module.</p>
<p>In the next chapter, we will see how pandas compares to other data analysis tools in terms of various analysis operations.</p>


            </article>

            
        </section>
    </body></html>