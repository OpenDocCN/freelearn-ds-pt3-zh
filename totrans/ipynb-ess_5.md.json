["```py\n%pylab inline\n\n```", "```py\nfrom scipy import signal\n\n```", "```py\nsignal.correlate(…)\n\n```", "```py\n%pylab inline\n\n```", "```py\ndef make_supply(A, B, C):\n def supply_func(q):\n return A * q / (C  - B * q)\n return supply_func\ndef make_demand(K, L):\n def demand_func(q):\n return K / (1 + L * q)\n return demand_func\n\n```", "```py\nA, B, C = 23.3, 9.2, 82.4\nK, L = 1.2, 0.54\nsupply = make_supply(A, B, C)\ndemand = make_demand(K, L)\n\n```", "```py\nq = linspace(0.01,5,200)\nplot(q, supply(q), lw = 2)\nplot(q, demand(q), lw = 2)\ntitle('Supply and demand curves')\nxlabel('Quantity (thousands of units)')\nylabel('Price ($)')\nlegend(['Supply', 'Demand'], loc='upper left')\n\n```", "```py\nfrom scipy import optimize\ndef opt_func(q):\n return supply(q) - demand(q)\nq_eq = optimize.brentq(opt_func, 1.0, 2.0)\nprint q_eq, supply(q_eq), demand(q_eq)\n\n```", "```py\n1.75322153719 0.616415252177 0.616415252177\n\n```", "```py\npoints = array([[10.3,15.4],[6.5,8.8],[15.6,10.3],[4.7,12.8]])\n\n```", "```py\nplot(points[:,0],points[:,1], 'o', ms=12, mfc='LightSkyBlue')\n\n```", "```py\ndef make_txmin(points):\n def txmin_func(p):\n return sum(abs(points - p))\n return txmin_func\n\n```", "```py\nreturn sum(abs(points - p))\n\n```", "```py\ntxmin = make_txmin(points)\n\n```", "```py\nfrom scipy import optimize\nx0 = array([0.,0.])\nres = optimize.minimize(\n txmin, x0,\n method='nelder-mead',\n options={'xtol':1e-5, 'disp':True})\n\n```", "```py\nOptimization terminated successfully.\n Current function value: 23.800000\n Iterations: 87\n Function evaluations: 194\n\n```", "```py\nprint res.x\n\n```", "```py\n[  8.37782286  11.36247412]\n\n```", "```py\nplot(points[:,0],points[:,1], 'o', ms=12, mfc='LightSkyBlue')\nplot(res.x[0], res.x[1],'o', ms=12, mfc='LightYellow')\nlocstr = 'x={:5.2f}, y={:5.2f}'.format(res.x[0], res.x[1])\ntitle('Optimal facility location: {}'.format(locstr))\n\n```", "```py\ndef make_gen(a,b):\n def gen_func(y):\n return a/pi * arccos(2.0 * y / b - 1.0)\n return gen_func\na = 5.\nb = 4.\ngen = make_gen(a,b)\nx = linspace(0,b,200)\ny = gen(x)\nsubplot(111, aspect='equal')\nplot(x,y,lw=2)\n\n```", "```py\nfrom mpl_toolkits.mplot3d import Axes3D\nna = 50\nnr = 50\navalues = linspace(0, 2*pi, na, endpoint=False)\nrvalues = linspace(b/nr, b, nr)\navalues_r = repeat(avalues[...,newaxis], nr, axis=1)\nxvalues = append(0, (rvalues*cos(avalues_r)).flatten())\nyvalues = append(0, (rvalues*sin(avalues_r)).flatten())\nzvalues = gen(sqrt(xvalues*xvalues+yvalues*yvalues))\nfig = plt.figure()\nax = fig.gca(projection='3d')\nax.plot_trisurf(xvalues, yvalues, zvalues, \n color='Cyan',alpha=0.65,linewidth=0.)\n\n```", "```py\nimport scipy.integrate as integrate\nint_func  = lambda x: 2 * pi * x * gen(x)\nintegrate.quad(int_func, 0, b)\n\n```", "```py\n(94.24777961000055, 1.440860870616234e-07)\n\n```", "```py\nM = 5.9726E24\nG = 6.67384E-11\nC = G * M\ndef ode_func(xvec, t):\n x1, x2, v1, v2 = xvec\n d = (x1 * x1 + x2 * x2) ** 1.5\n return array([v1, v2, -C * x1 / d, -C * x2 / d ])\n\n```", "```py\nx1, x2, v1, v2 = xvec\n\n```", "```py\nimport scipy.integrate as integrate\nearth_radius = 6.371E6\nv0 = 8500\nh0 = 5E5\nic = array([0.0, earth_radius + h0, v0, 0.0])\ntmax = 8700.0\ndt = 10.0\ntvalues = arange(0.0, tmax, dt)\nxsol = integrate.odeint(ode_func, ic, tvalues)\n\n```", "```py\nic = array([0.0, earth_radius + h0, v0, 0.0])\n\n```", "```py\ntmax = 8650.0\ndt = 60.0\ntvalues = arange(0.0, tmax, dt)\n\n```", "```py\nxsol[:10]\n```", "```py\narray([[  0.00000000e+00,   6.87100000e+06,   8.50000000e+03,\n 0.00000000e+00],\n [  5.09624253e+05,   6.85581217e+06,   8.48122162e+03,\n -5.05935282e+02],\n [  1.01700042e+06,   6.81036510e+06,   8.42515172e+03,\n -1.00800330e+03],\n [  1.51991202e+06,   6.73500470e+06,   8.33257580e+03,\n -1.50243025e+03],\n [  2.01620463e+06,   6.63029830e+06,   8.20477026e+03,\n -1.98562415e+03],\n [  2.50381401e+06,   6.49702131e+06,   8.04345585e+03,\n -2.45425372e+03],\n [  2.98079103e+06,   6.33613950e+06,   7.85073707e+03,\n -2.90531389e+03],\n [  3.44532256e+06,   6.14878788e+06,   7.62903174e+03,\n -3.33617549e+03],\n [  3.89574810e+06,   5.93624710e+06,   7.38099497e+03,\n -3.74461812e+03],\n [  4.33057158e+06,   5.69991830e+06,   7.10944180e+03,\n -4.12884566e+03]])\n\n```", "```py\nsubplot(111, aspect='equal')\naxis(earth_radius * array([-1.5, 1.5, -1.8, 1.2]))\nearth = Circle((0.,0.), \n earth_radius, \n ec='Black', fc='Brown', lw=3)\ngca().add_artist(earth)\nplot(xsol[:,0], xsol[:,1], lw=2, color='DarkBlue')\ntitle('Newton\\'s Canon, $v_0={}$ m/s'.format(v0))\n\n```", "```py\nearth = Circle((0.,0.), \n earth_radius, \n ec='Black', fc='Brown', lw=3)\ngca().add_artist(earth)\n\n```", "```py\nplot(xsol[:,0], xsol[:,1], lw=2, color='DarkBlue')\n\n```", "```py\nodeint(ode_func, x0, tvalues, args=(), Dfun=None, col_deriv=0,\n full_output=0, ml=None, mu=None, rtol=None, atol=None,\n tcrit=None, h0=0.0, hmax=0.0, hmin=0.0,ixpr=0, mxstep=0,\n mxhnil=0, mxordn=12, mxords=5, printmessg=0)\n\n```", "```py\node_func(x, t, p1, p2, … , pn)\n\n```", "```py\ndef ode_func(xvec, t, sigma, rho, beta):\n x, y, z = xvec\n return array([sigma * (y - x),\n x * (rho - z) - y,\n x * y - beta * z ])\n\n```", "```py\ntmax = 50\ntdelta = 0.005\ntvalues = arange(0, tmax, tdelta) \nic = array([0.0, 1.0, 0.0])\nsol = integrate.odeint(ode_func, ic, tvalues, \n args=(10., 28., 8./3.))\n\n```", "```py\nargs=(10., 28., 8./3.)\n\n```", "```py\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure(figsize=(8,8))\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure(figsize=(8,8))\nax = fig.add_subplot(111, projection='3d')\nx, y, z = sol.transpose() \nax.plot(x, y, z, lw=0.5, color='DarkBlue')\nax.set_xlabel('$x$')\nax.set_ylabel('$y$')\nax.set_zlabel('$z$')\n\n```", "```py\nx, y, z = sol.transpose()\n\n```", "```py\ndef matrix_multiply(A, B):\n m, n = A.shape\n n, r = B.shape\n C = zeros((m, r), float64)\n for i in range(m):\n for j in range(r):\n acc = 0\n for k in range(n):\n acc += A[i, k] * B[k, j]\n C[i, j] = acc\n return C\n\n```", "```py\nA = array([[1,2,0],[1,-3,4],[0,-2,1],[3,7,-4]], dtype=float64)\nB = array([[3,4],[-2,0],[2,4]], dtype = float64)\nC = matrix_multiply(A, B)\nprint A\nprint B\nprint C\n\n```", "```py\n[[  1\\.   2\\.   0.]\n [  1\\.  -3\\.   4.]\n [  0\\.  -2\\.   1.]\n [  3\\.   7\\.  -4.]]\n[[  3    4]\n [ -2    0]\n [  2    4]]\n[[ -1\\.   4.]\n [  17\\. 20.]\n [  6\\.   4.]\n [ -13\\. -4.]]\n\n```", "```py\nC - A.dot(B)\narray([[ 0\\. ,  0.],\n [ 0\\. ,  0.],\n [ 0\\. ,  0.],\n [ 0\\. ,  0.]])\n\n```", "```py\nn = 100\nA = rand(n, n)\nB = rand(n, n)\n\n```", "```py\n%%timeit\nC = matrix_multiply(A, B)\n\n```", "```py\n1 loops, best of 3: 472 ms per loop\n\n```", "```py\nfrom numba import jit\n\n```", "```py\n@jit\ndef matrix_multiply_jit(A, B):\n m, n = A.shape\n n, r = B.shape\n C = zeros((m, r), float64)\n for i in range(m):\n for j in range(r):\n acc = 0\n for k in range(n):\n acc += A[i, k] * B[k, j]\n C[i, j] = acc\n return C\n\n```", "```py\n%%timeit\nC = matrix_multiply_jit(A, B)\n\n```", "```py\n1000 loops, best of 3: 1.8 ms per loop\n\n```", "```py\n%%timeit\nC = A.dot(B)\n\n```", "```py\n10000 loops, best of 3: 28.6 µs per loop\n\n```", "```py\nfrom numba import jit, f8\n@jit (f8(f8,f8))\ndef my_sum(a, b):\n return a + b\n\n```", "```py\n@jit (f8(f8,f8))\n\n```", "```py\nmy_sum(3.5, 6.9)\n\n```", "```py\na = array([1.4, 2.0])\nb = array([2.3, 5,2])\nmy_sum(a,b)\n\n```", "```py\n@jit (f8[:](f8[:],f8[:]))\ndef vector_sum(a, b):\n return a + b\n\n```", "```py\nimport numbapro\nnumbapro.check_cuda()\n\n```", "```py\nblockIdx.x=0, blockIdx.y=1, blockIdx.z=1\nthreadIdx.x=2, threadIdx.y=1, threadIdx.z=1\n\n```", "```py\nfrom numbapro import cuda\n@cuda.jit('void(float64[:], float64[:], float64[:])')\ndef sum(a, b, result):\n i = cuda.threadIdx.x \n result[i] = a[i] + b[i]\n\n```", "```py\na = array([1,2,3,4,5], dtype=float64)\nb = array([5,4,3,2,1], dtype=float64)\nresult = array([0,0,0,0,0], dtype=float64)\nsum[1,5](a, b, result)\nprint result\n\n```", "```py\n[ 6\\.  6\\.  6\\.  6\\.  6.]\n\n```", "```py\nsum[1,5](a, b, result)\n\n```", "```py\nn = 64\na = arange(0,n,dtype=float64)\nb = arange(n,0,-1, dtype=float64)\nresult = zeros(n,dtype=float64)\nsum[1,n](a, b, result)\nprint result[:5]\n\n```", "```py\nfrom numbapro import cuda\n@cuda.jit('void(float64[:], float64[:], float64[:], int32)')\ndef sum(a, b, result, n):\n tx = cuda.threadIdx.x\n bx = cuda.blockIdx.x\n bsz = cuda.blockDim.x\n i = tx + bx * bsz\n if i < n:\n result[i] = a[i] + b[i]\n\n```", "```py\nn = 100000\na = arange(0,n,dtype=float64)\nb = arange(n,0,-1, dtype=float64)\nresult = zeros(n,dtype=float64)\nsum[1000,64](a, b, result, n)\nprint result[:5]\n\n```", "```py\nn = 100000\na = rand(n)\nb = rand(n)\nresult = zeros(n, dtype=float64)\nbd = 10000\ngd = 64\nif bd * gd < n:\n print 'Block/grid dimensions too small'\nelse:\n sum[bd,gd](a, b, result, n)\nprint result[:10]\n\n```"]