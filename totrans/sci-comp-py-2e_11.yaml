- en: Communication by a Graphical User Interface
  prefs: []
  type: TYPE_NORMAL
- en: '**Graphical user interfaces (GUIs)** are convenient tools to input user data
    to your Python program. In all likelihood, you have used tools such as *selection
    lists*, *radio buttons,* or *sliders* to communicate with an application. In this
    chapter, we show how to add some of these tools to your program. We base this
    chapter on tools provided by the module **Matplotlib**, which we already met in
    [Section 6.2](86c61820-e645-486c-9418-10079ffac7f8.xhtml): *Working with Matplotlib
    objects directly*.'
  prefs: []
  type: TYPE_NORMAL
- en: Although there are alternatives such as the module **Tkinter** for a more sophisticated
    design of GUIs, Matplotlib appears as an ideal entry point with a low threshold
    to add this comfortable way of communicating with your code.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is to demonstrate the basic principles of GUI programming
    within Matplotlib. The role of events, slider movements, or mouse clicks and their
    interaction with so-called call-back functions is explained, along with a couple
    of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, we do not aim for completeness. Having understood the basic principles,
    the Matplotlib documentation is a reservoir of detailed information on various
    widgets and their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A guiding example to widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The button widget and mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.1 A guiding example to widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we present the basic components11.1 A guiding example to widgets
    of a **widget** and their counterparts in **Python**. We do this by using the
    guiding example displayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78061f1f-cc54-4907-b56c-dbbe1456ad89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: A widget to display ![](img/b7925514-4664-4123-958a-9553478a9f75.png) for
    user-given frequencies ![](img/9517305e-55a6-4f64-b1c6-3abe53043510.png)'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we see a slider bar at the top. With the use of a computer mouse,
    the blue bar can be moved from left to right and the value for ![](img/591c783c-9836-44ff-8973-c7f37f8af6f9.png),
    ranging between 1 and 5, is displayed on the right of the bar.
  prefs: []
  type: TYPE_NORMAL
- en: Correspondingly, the frequency of the sine wave displayed in the plot window
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This widget consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A figure object with an axes object and the plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An axes object containing a slider object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call-back function for updating the plot as soon as the slider value changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed how to program the first part, in [Section 6.2](86c61820-e645-486c-9418-10079ffac7f8.xhtml): *Working
    with Matplotlib objects directly*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we first create a figure with a given size and
    then a sufficiently large axes object that is placed into the figure such that
    its lower-left corner point is placed at the pair of figure coordinates ![](img/4eb07a74-351a-45dd-b7d9-ebfdbdbdfd6a.png).
    Then, the user is asked to input a floating-point number between 1 and 5 for the
    frequency ![](img/01537198-cd5f-4422-b047-3271dda4542a.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the next step, we add a second axes object and put it into it a slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The axes object for the slider, `sld_ax`, is defined by giving its dimensions
    and the location of the left lower point in the figure's coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: The new construction element is the `Slider` object. Its constructor uses the
    slider axes, a label, and maximum and minimum values displayed on the left and
    right sides of the slider. The slider object has an attribute `val`, which contains
    the value given by the slider position.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, the slider position is set to `valinit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the core part of the program, the call-back function, and
    the update of the plot, whenever the slider value changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A call-back function is a function called when the slider (or another widget
    object) is changed. In our case, it is the function `update_frequency`. The slider
    method `on_changed` defines the action to be performed whenever the slider value
    changes. Here, the function `update_frequency` is called with the slider value
    `val` as its single argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will conclude this introductory section by putting the parts together. Note
    that there is no longer any need for the input function used in the beginning
    as we now use the much more elegant GUI method to input values. We also provided
    the plot with a legend to display the use of the slider value. Note how string
    formatting and LaTeX commands were combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we demonstrated the use of a widget for user input. It is a
    user-friendly way to ask for parameters and to display related results.
  prefs: []
  type: TYPE_NORMAL
- en: 11.1.1 Changing a value with a slider bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we covered the use of a slider. The most important attribute
    of a slider is its value, `val`. This is communicated to the call-back function.
  prefs: []
  type: TYPE_NORMAL
- en: Other attributes are the limits of the value given by the slider, `valmin`,
    and `valmax`, and a stepping functionality, `valstep`, to make the change to the
    value discrete. A formatting attribute, `valfmt`, allows us to specify how `valmin`
    and `valmax` are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we modify the slider definition from above and provide
    it with these more specific attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The formatting argument, `%1.1f`, in this example says that the value should
    be displayed as a floating-point number, with one digit to the left of the decimal
    point and one digit to the right of it.
  prefs: []
  type: TYPE_NORMAL
- en: An example with two sliders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We extend the preceding example by providing two sliders, one for the amplitude
    and another for the frequency, and we put the sliders in vertical mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the two slider axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the two sliders with different minimum and maximum values and
    an orientation parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Both sliders have different call-back functions. They use the value of the
    related slider as an argument and the value of the other slider as a global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following figure, the GUI is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3cf3597-3db5-46a7-ac04-38ca819f57c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: A curve with two parameters given by two vertical sliders'
  prefs: []
  type: TYPE_NORMAL
- en: Some actions require that the user has to wait until the result of a change
    is seen. Often, it is more convenient and user-friendly to first collect the changes
    and then do the update. This can be made by a special button widget, which will
    be introduced in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 The button widget and mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The button widget is a simple little tool with a big variety of useful applications.
    We introduce it here by continuing the previous example and adding an update button
    to the GUI. Then we use a button to extract data from a curve.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.1 Updating curve parameters with a button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have updated the curve when the slider value changed and used the
    method `on_changed` for this. A complicated graphical output might take some computing
    time to update. In such a case, you would like to design the GUI in such a way
    that first, the curve parameters are set by sliders, and then a button is pressed
    to initiate the updating of the curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved by the `Button` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The coordinates in this example are set in such a way that the button is located
    under the two sliders. It is labeled by Update and its color turns to red when
    the mouse is placed over the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'This widget has a method, `on_clicked`, that is used instead of the slider
    method `on_changed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The call-back function has a single parameter, `event`. It is not used in this
    example. It could be used to assign different actions to the button depending
    on how the mouse was clicked – by a single click, double click, right-button click,
    or left-button click. We will look at events in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.2 Mouse events and textboxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last example, we encountered mouse events in the context of a button
    widget. We can also catch a mouse event without using a button. To this end, we
    need to connect a general button click to a call-back function.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we consider again the previously generated plot of the
    sine wave and pick by mouse clicks points and display their coordinates in a textbox
    to the plot. If clicked with the right mouse button, we also display the point
    picked by means of a red circle in the plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we prepare a textbox widget. We already know that we first have to position
    the widget by defining an axes object and then providing the widget with the desired
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We provided the box with no label but some initial text. The textbox has the
    attribute `val` containing the text. We will change this attribute now depending
    on the position of a mouse click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As there is no widget like a button widget used, we have to couple an event
    to a call-back function. This is done by the canvas method, `mpl_connect`. The
    call-back function `onclick` reacts to the position of the mouse click. We know
    from the event attribute `inaxes` in which axes object the mouse click occurred.
    Through this, we can even access information about the button pressed, and the
    exact coordinates of the mouse click are also available. The call-back function
    makes use of a `Line2D` object, `points`, which is initialized with empty data
    lists before the call-back function is used for the first time. This initialization
    defines the plot style, red circles in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f660987-525b-46b8-a02b-df6051726003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Displaying a value on the curve by using a mouse click'
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basic principles of GUI programming within Matplotlib.
    We also considered an example that helped us to learn more about widgets. In the
    next chapter, we are going to learn about error and exception handling.
  prefs: []
  type: TYPE_NORMAL
