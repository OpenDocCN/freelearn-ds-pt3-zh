- en: Chapter 10. Signal Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the frequency components of a signal with a Fast Fourier Transform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a linear filter to a digital signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the autocorrelation of a time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals are mathematical functions that describe the variation of a quantity
    across time or space. Time-dependent signals are often called **time series**.
    Examples of time series include share prices, which are typically presented as
    successive points in time spaced at uniform time intervals. In physics or biology,
    experimental devices record the evolution of variables such as electromagnetic
    waves or biological processes.
  prefs: []
  type: TYPE_NORMAL
- en: In signal processing, a general objective consists of extracting meaningful
    and relevant information from raw, noisy measurements. Signal processing topics
    include signal acquisition, transformation, compression, filtering, and feature
    extraction, among others. When dealing with a complex dataset, it can be beneficial
    to clean it before applying more advanced mathematical analysis methods (such
    as machine learning, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: In this concise chapter, we will illustrate and explain the main foundations
    of signal processing. In the next chapter, [Chapter 11](ch11.html "Chapter 11. Image
    and Audio Processing"), *Image and Audio Processing*, we will see particular signal
    processing methods adapted to images and sounds.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will give some important definitions in this introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Analog and digital signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signals can be time-dependent or space-dependent. In this chapter, we will focus
    on time-dependent signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let *x(t)* be a time-varying signal. We say that:'
  prefs: []
  type: TYPE_NORMAL
- en: This signal is **analog** if *t* is a continuous variable and *x(t)* is a real
    number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This signal is **digital** if *t* is a discrete variable (**discrete-time signal**)
    and *x(t)* can only take a finite number of values (**quantified signal**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the difference between an analog signal (the continuous
    curve) and a digital signal (dots):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Analog and digital signals](img/4818OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Difference between the analog and digital (quantified) signals
  prefs: []
  type: TYPE_NORMAL
- en: Analog signals are found in mathematics and in most physical systems such as
    electric circuits. Yet, computers being discrete machines, they can only understand
    digital signals. This is why computational science especially deals with digital
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'A digital signal recorded by an experimental device is typically characterized
    by two important quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The sampling rate**: The number of values (or samples) recorded every second
    (in Hertz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The resolution**: The precision of the quantization, usually in bits per
    sample (also known as **bit depth**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital signals with high sampling rates and bit depths are more accurate, but
    they require more memory and processing power. These two parameters are limited
    by the experimental devices that record the signals.
  prefs: []
  type: TYPE_NORMAL
- en: The Nyquist–Shannon sampling theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider a continuous (analog) time-varying signal *x(t)*. We record this
    physical signal with an experimental device, and we obtain a digital signal with
    a sampling rate of *f[s]*. As the original analog signal has an infinite precision,
    whereas the recorded signal has a finite precision, we expect to lose information
    in the analog-to-digital process.
  prefs: []
  type: TYPE_NORMAL
- en: The **Nyquist–Shannon sampling** theorem states that under certain conditions
    on the analog signal and the sampling rate, it is possible not to lose any information
    in the process. In other words, under these conditions, we can recover the original
    continuous signal from the sampled digital signal. For more details, refer to
    [http://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem](http://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define these conditions. The **Fourier transform** ![The Nyquist–Shannon
    sampling theorem](img/4818OS_10_20.jpg) of *x(t)* is defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Nyquist–Shannon sampling theorem](img/4818OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the Fourier transform is a representation of a time-dependent signal
    in the frequency domain. The **Nyquist criterion** states that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Nyquist–Shannon sampling theorem](img/4818OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In other words, the signal must be **bandlimited**, meaning that it must not
    contain any frequency higher than a certain cutoff frequency *B*. Additionally,
    the sampling rate *f[s]* needs to be at least twice as large as this frequency
    *B*. Here are a couple of definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Nyquist rate** is *2B*. For a given bandlimited analog signal, it is the
    minimal sampling rate required to sample the signal without loss.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Nyquist frequency** is *f[s]*/2\. For a given sampling rate, it is the
    maximal frequency that the signal can contain in order to be sampled without loss.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under these conditions, we can theoretically reconstruct the original analog
    signal from the sampled digital signal.
  prefs: []
  type: TYPE_NORMAL
- en: Compressed sensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compressed sensing is a modern and important approach to signal processing.
    It acknowledges that many real-world signals are intrinsically low dimensional.
    For example, speech signals have a very specific structure depending on the general
    physical constraints of the human vocal tract.
  prefs: []
  type: TYPE_NORMAL
- en: Even if a speech signal has many frequencies in the Fourier domain, it may be
    well approximated by a **sparse decomposition** on an adequate basis (dictionary).
    By definition, a decomposition is sparse if most of the coefficients are zero.
    If the dictionary is chosen well, every signal is a combination of a small number
    of the basis signals.
  prefs: []
  type: TYPE_NORMAL
- en: This dictionary contains elementary signals that are specific to the signals
    considered in a given problem. This is different from the Fourier transform that
    decomposes a signal on a *universal* basis of sine functions. In other words,
    with sparse representations, the Nyquist condition can be circumvented. We can
    precisely reconstruct a continuous signal from a sparse representation containing
    fewer samples than what the Nyquist condition requires.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse decompositions can be found with sophisticated algorithms. In particular,
    these problems may be turned into convex optimization problems that can be tackled
    with specific numerical optimization methods.
  prefs: []
  type: TYPE_NORMAL
- en: Compressed sensing has many applications in signal compression, image processing,
    computer vision, biomedical imaging, and many other scientific and engineering
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are further references about compressed sensing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Compressed_sensing](http://en.wikipedia.org/wiki/Compressed_sensing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Sparse_approximation](http://en.wikipedia.org/wiki/Sparse_approximation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Understanding Digital Signal Processing*, *Richard G. Lyons*, *Pearson Education*,
    *(2010)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For good coverage of compressed sensing, refer to the book *A Wavelet Tour
    of Signal Processing: The Sparse Way*, *Mallat Stéphane*, *Academic Press*, *(2008)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The book *Python for Signal Processing* by Jose Unpingco contains many more
    details than what we can cover in this chapter. The code is available as IPython
    notebooks on GitHub ([http://python-for-signal-processing.blogspot.com](http://python-for-signal-processing.blogspot.com)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital Signal Processing on WikiBooks available at [http://en.wikibooks.org/wiki/Digital_Signal_Processing](http://en.wikibooks.org/wiki/Digital_Signal_Processing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the frequency components of a signal with a Fast Fourier Transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to use a **Fast Fourier Transform** (**FFT**)
    to compute the spectral density of a signal. The spectrum represents the energy
    associated to frequencies (encoding periodic fluctuations in a signal). It is
    obtained with a Fourier transform, which is a frequency representation of a time-dependent
    signal. A signal can be transformed back and forth from one representation to
    the other without information loss.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will illustrate several aspects of the Fourier Transform.
    We will apply this tool to weather data spanning 20 years in France obtained from
    the US National Climatic Data Center.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the *Weather* dataset from the book's GitHub repository at [http://github.com/ipython-books/cookbook-data](http://github.com/ipython-books/cookbook-data),
    and extract it in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The data has been obtained from [www.ncdc.noaa.gov/cdo-web/datasets#GHCND](http://www.ncdc.noaa.gov/cdo-web/datasets#GHCND).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages, including `scipy.fftpack`, which includes many
    FFT-related routines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We import the data from the CSV file. The number `-9999` is used for N/A values.
    pandas can easily handle this. In addition, we tell pandas to parse dates contained
    in the `DATE` column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each row contains the precipitation and extreme temperatures recorded each
    day by one weather station in France. For every date in the calendar, we want
    to get a single average temperature for the whole country. The `groupby()` method
    provided by pandas lets us do this easily. We also remove any N/A value with `dropna()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we get the list of dates and the list of corresponding temperatures. The
    unit is in tenths of a degree, and we get the average value between the minimal
    and maximal temperature, which explains why we divide by 20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at the evolution of the temperature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'We now compute the Fourier transform and the spectral density of the signal.
    The first step is to compute the FFT of the signal using the `fft()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the FFT has been obtained, we need to take the square of its absolute
    value in order to get the **power spectral density** (**PSD**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to get the frequencies corresponding to the values of the
    PSD. The `fftfreq()` utility function does just that. It takes the length of the
    PSD vector as input as well as the frequency unit. Here, we choose an annual unit:
    a frequency of 1 corresponds to 1 year (365 days). We provide *1/365* because
    the original unit is in days.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fftfreq()` function returns positive and negative frequencies. We are only
    interested in positive frequencies here, as we have a real signal (this will be
    explained in the *How it works...* section of this recipe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now plot the power spectral density of our signal, as a function of the frequency
    (in unit of *1/year*). We choose a logarithmic scale for the *y* axis (**decibels**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Because the fundamental frequency of the signal is the yearly variation of the
    temperature, we observe a peak for *f=1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we cut out frequencies higher than the fundamental frequency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we perform an **inverse FFT** to convert the modified Fourier transform
    back to the temporal domain. This way, we recover a signal that mainly contains
    the fundamental frequency, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We get a smoothed version of the signal, because the fast variations have been
    lost when we have removed the high frequencies in the Fourier transform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broadly speaking, the Fourier transform is an alternative representation of
    a signal as a superposition of periodic components. It is an important mathematical
    result that any well-behaved function can be represented under this form. Whereas
    a time-varying signal is most naturally considered as a function of time, the
    Fourier transform represents it as a function of the frequency. A magnitude and
    a phase, which are both encoded in a single complex number, are associated to
    each frequency.
  prefs: []
  type: TYPE_NORMAL
- en: The Discrete Fourier Transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s consider a digital signal *x* represented by a vector *(x[0], ..., x[(N-1)])*.
    We assume that this signal is regularly sampled. The **Discrete Fourier Transform**
    (**DFT**) of *x* is *X = (X[0], ..., X[(N-1)])* defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Discrete Fourier Transform](img/4818OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The DFT can be computed efficiently with the Fast Fourier Transform (FFT), an
    algorithm that exploits symmetries and redundancies in this definition to considerably
    speed up the computation. The complexity of the FFT is *O(N* log *N)* instead
    of *O(N²)* for the naive DFT. The FFT is one of the most important algorithms
    of the digital universe.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an intuitive explanation of what the DFT describes. Instead of representing
    our signal on a real line, let's represent it on a circle. We can play the whole
    signal by making 1, 2, or any number *k* of laps on the circle. Therefore, when
    *k* is fixed, we represent each value *x[n]* of the signal with an angle ![The
    Discrete Fourier Transform](img/4818OS_10_22.jpg) and a distance from the original
    equal to *x[n]*.
  prefs: []
  type: TYPE_NORMAL
- en: If the signal shows a certain periodicity of *k* laps, it means that many correlated
    values will superimpose at that exact frequency so that the coefficient *X[k]*
    will be large. In other words, the modulus *|X[k]|* of the *k*-th coefficient
    represents the *energy* of the signal associated to this frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, the signal is a sine wave at the frequency *f=3 Hz*.
    The points of this signal are in blue, positioned at an angle ![The Discrete Fourier
    Transform](img/4818OS_10_22.jpg). Their algebraic sum in the complex plane is
    in red. These vectors represent the different coefficients of the signal's DFT.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Discrete Fourier Transform](img/4818OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the DFT
  prefs: []
  type: TYPE_NORMAL
- en: 'The next figure represents the previous signal''s **power spectral density**
    (**PSD**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Discrete Fourier Transform](img/4818OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The PSD of the signal in the previous example
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Fourier Transform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By considering all possible frequencies, we have an exact representation of
    our digital signal in the frequency domain. We can recover the initial signal
    with an **Inverse Fast Fourier Transform** that computes an **Inverse Discrete
    Fourier Transform**. The formula is very similar to the DFT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inverse Fourier Transform](img/4818OS_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The DFT is useful when periodic patterns are to be found. However, generally
    speaking, the Fourier transform cannot detect *transient* changes at specific
    frequencies. More local spectral methods are required, such as the **wavelet transform**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following links contain more details about Fourier transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the FFT with SciPy, available at [http://scipy-lectures.github.io/intro/scipy.html#fast-fourier-transforms-scipy-fftpack](http://scipy-lectures.github.io/intro/scipy.html#fast-fourier-transforms-scipy-fftpack)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference documentation for the fftpack in SciPy, available at [http://docs.scipy.org/doc/scipy/reference/fftpack.html](http://docs.scipy.org/doc/scipy/reference/fftpack.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourier Transform on Wikipedia, available at [http://en.wikipedia.org/wiki/Fourier_transform](http://en.wikipedia.org/wiki/Fourier_transform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discrete Fourier Transform on Wikipedia, available at [http://en.wikipedia.org/wiki/Discrete_Fourier_transform](http://en.wikipedia.org/wiki/Discrete_Fourier_transform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast Fourier Transform on Wikipedia, available at [http://en.wikipedia.org/wiki/Fast_Fourier_transform](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decibel on Wikipedia, available at [https://en.wikipedia.org/wiki/Decibel](https://en.wikipedia.org/wiki/Decibel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Applying a linear filter to a digital signal* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Computing the autocorrelation of a time series* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a linear filter to a digital signal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linear filters play a fundamental role in signal processing. With a linear filter,
    one can extract meaningful information from a digital signal.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show two examples using stock market data (the NASDAQ
    stock exchange). First, we will smooth out a very noisy signal with a low-pass
    filter to extract its slow variations. We will also apply a high-pass filter on
    the original time series to extract the fast variations. These are just two common
    examples among a wide variety of applications of linear filters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the *Nasdaq* dataset from the book's GitHub repository at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data)
    and extract it in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The data has been obtained from [http://finance.yahoo.com/q/hp?s=^IXIC&a=00&b=1&c=1990&d=00&e=1&f=2014&g=d](http://finance.yahoo.com/q/hp?s=%5EIXIC&a=00&b=1&c=1990&d=00&e=1&f=2014&g=d).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s import the packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We load the NASDAQ data with pandas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s extract two columns: the date and the daily closing value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at the raw signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, we will follow the first approach to get the slow variations of the signal.
    We will convolve the signal with a triangular window, which corresponds to a **FIR
    filter**. We will explain the idea behind this method in the *How it works...*
    section of this recipe. For now, let''s just say that we replace each value with
    a weighted mean of the signal around this value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, let''s use another method. We create an IIR Butterworth low-pass filter
    to extract the slow variations of the signal. The `filtfilt()` method allows us
    to apply a filter forward and backward in order to avoid phase delays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, we use the same method to create a high-pass filter and extract the
    *fast* variations of the signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The fast variations around 2000 correspond to the dot-com bubble burst, reflecting
    the high-market volatility and the fast fluctuations of the stock market indices
    at that time. For more details, refer to [http://en.wikipedia.org/wiki/Dot-com_bubble](http://en.wikipedia.org/wiki/Dot-com_bubble).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we explain the very basics of linear filters in the context
    of digital signals.
  prefs: []
  type: TYPE_NORMAL
- en: A **digital signal** is a discrete sequence *(x[n])* indexed by *n* ![How it
    works...](img/4818OS_10_26.jpg) * 0*. Although we often assume infinite sequences,
    in practice, a signal is represented by a *vector* of the finite size *N*.
  prefs: []
  type: TYPE_NORMAL
- en: In the continuous case, we would rather manipulate time-dependent functions
    *f(t)*. Loosely stated, we can go from continuous signals to discrete signals
    by discretizing time and transforming integrals into sums.
  prefs: []
  type: TYPE_NORMAL
- en: What are linear filters?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **linear filter** *F* transforms an input signal *x = (x[n])* to an output
    signal *y = (y[n])*. This transformation is *linear*—the transformation of the
    sum of two signals is the sum of the transformed signals: *F(x+y) = F(x)+F(y)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, multiplying the input signal by a constant ![What are
    linear filters?](img/4818OS_10_25.jpg) yields the same output as multiplying the
    original output signal by the same constant: ![What are linear filters?](img/4818OS_10_23.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Linear Time-Invariant** (**LTI**) filter has an additional property: if
    the signal *(x[n])* is transformed to *(y[n])*, then the *shifted* signal *(x[(n-k)])*
    is transformed to *(y[(n-k)])*, for any fixed *k*. In other words, the system
    is time-invariant because the output does not depend on the particular time the
    input is applied.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From now on, we will only consider LTI filters.
  prefs: []
  type: TYPE_NORMAL
- en: Linear filters and convolutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very important result in the LTI system theory is that LTI filters can be
    described by a single signal: the impulse response *h*. This is the output of
    the filter in response to an impulse signal. For digital filters, the impulse
    signal is *(1, 0, 0, 0, ...)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be shown that *x = (x[n])* is transformed to *y = (y[n])* defined by
    the **convolution** of the impulse response *h* with the signal *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linear filters and convolutions](img/4818OS_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The convolution is a fundamental mathematical operation in signal processing.
    Intuitively, and considering a convolution function peaking around zero, the convolution
    is equivalent to taking a local average of the signal (*x* here), weighted by
    a given window (*h* here).
  prefs: []
  type: TYPE_NORMAL
- en: It is implied, by our notations, that we restrict ourselves to **causal** filters
    (*h[n] = 0* for *n < 0*). This property means that the output of the signal only
    depends on the present and the past of the input, not the future. This is a natural
    property in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: The FIR and IIR filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **support** of a signal *(h[n])* is the set of *n* such that ![The FIR
    and IIR filters](img/4818OS_10_24.jpg). LTI filters can be classified into two
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Finite Impulse Response** (FIR) filter has an impulse response with finite
    support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Infinite Impulse Response** (IIR) filter has an impulse response with infinite
    support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A FIR filter can be described by a finite impulse response of size *N* (a vector).
    It works by convolving a signal with its impulse response. Let''s define *b[n]
    = h[n]* for *n* ![The FIR and IIR filters](img/4818OS_10_40.jpg) * N*. Then, *y[n]*
    is a linear combination of the last *N+1* values of the input signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The FIR and IIR filters](img/4818OS_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, an IIR filter is described by an infinite impulse response
    that cannot be represented exactly under this form. For this reason, we often
    use an alternative representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The FIR and IIR filters](img/4818OS_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This **difference equation** expresses *y[n]* as a linear combination of the
    last *N+1* values of the *input* signal (the **feedforward** term, like for a
    FIR filter) *and* a linear combination of the last *M* values of the *output*
    signal (**feedback** term). The feedback term makes the IIR filter more complex
    than a FIR filter in that the output depends not only on the input but also on
    the previous values of the output (dynamics).
  prefs: []
  type: TYPE_NORMAL
- en: Filters in the frequency domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We only described filters in the temporal domain. Alternate representations
    in other domains exist such as Laplace transforms, Z-transforms, and Fourier transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the *Fourier transform* has a very convenient property: it transforms
    convolutions into multiplications in the frequency domain. In other words, in
    the frequency domain, an LTI filter multiplies the Fourier transform of the input
    signal by the Fourier transform of the impulse response.'
  prefs: []
  type: TYPE_NORMAL
- en: The low-, high-, and band-pass filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Filters can be characterized by their effects on the amplitude of the input
    signal''s frequencies. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A **low-pass filter** attenuates the components of the signal at frequencies
    *higher* than a **cutoff frequency**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **high-pass filter** attenuates the components of the signal at frequencies
    *lower* than a **cutoff frequency**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **band-pass filter** passes the components of the signal at frequencies within
    a certain range and attenuates those outside
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we first convolved the input signal with a triangular window
    (with finite support). It can be shown that this operation corresponds to a low-pass
    FIR filter. It is a particular case of the **moving average** method, which computes
    a local weighted average of every value in order to smooth out the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we applied two instances of the **Butterworth filter**, a particular kind
    of IIR filter that can act as a low-pass, high-pass, or band-pass filter. In this
    recipe, we first used it as a low-pass filter to smooth out the signal, before
    using it as a high-pass filter to extract fast variations of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some general references about digital signal processing and linear
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: Digital signal processing on Wikipedia, available at [http://en.wikipedia.org/wiki/Digital_signal_processing](http://en.wikipedia.org/wiki/Digital_signal_processing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear filters on Wikipedia, available at [http://en.wikipedia.org/wiki/Linear_filter](http://en.wikipedia.org/wiki/Linear_filter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LTI filters on Wikipedia, available at [http://en.wikipedia.org/wiki/LTI_system_theory](http://en.wikipedia.org/wiki/LTI_system_theory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some references about impulse responses, convolutions, and FIR/IIR
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: Impulse responses described at [http://en.wikipedia.org/wiki/Impulse_response](http://en.wikipedia.org/wiki/Impulse_response)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convolution described at [http://en.wikipedia.org/wiki/Convolution](http://en.wikipedia.org/wiki/Convolution)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FIR filters described at [http://en.wikipedia.org/wiki/Finite_impulse_response](http://en.wikipedia.org/wiki/Finite_impulse_response)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIR filters described at [http://en.wikipedia.org/wiki/Infinite_impulse_response](http://en.wikipedia.org/wiki/Infinite_impulse_response)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-pass filters described at [http://en.wikipedia.org/wiki/Low-pass_filter](http://en.wikipedia.org/wiki/Low-pass_filter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-pass filters described at [http://en.wikipedia.org/wiki/High-pass_filter](http://en.wikipedia.org/wiki/High-pass_filter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Band-pass filters described at [http://en.wikipedia.org/wiki/Band-pass_filter](http://en.wikipedia.org/wiki/Band-pass_filter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Analyzing the frequency components of a signal with a Fast Fourier Transform*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing the autocorrelation of a time series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The autocorrelation of a time series can inform us about repeating patterns
    or serial correlation. The latter refers to the correlation between the signal
    at a given time and at a later time. The analysis of the autocorrelation can thereby
    inform us about the timescale of the fluctuations. Here, we use this tool to analyze
    the evolution of baby names in the US, based on the data provided by the United
    States Social Security Administration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Download the *Babies* dataset from the book's GitHub repository at [https://github.com/ipython-books/cookbook-data](https://github.com/ipython-books/cookbook-data),
    and extract it in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The data has been obtained from [www.data.gov](http://www.data.gov) ([http://catalog.data.gov/dataset/baby-names-from-social-security-card-applications-national-level-data-6315b](http://catalog.data.gov/dataset/baby-names-from-social-security-card-applications-national-level-data-6315b)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We read the data with pandas. The dataset contains one CSV file per year. Each
    file contains all baby names given that year with the respective frequencies.
    We load the data in a dictionary, containing one `DataFrame` per year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We write functions to retrieve the frequencies of baby names as a function
    of the name, gender, and birth year:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's define a function that computes the autocorrelation of a signal. This
    function is essentially based on NumPy's `correlate()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we create a function that displays the evolution of a baby name as well
    as its (normalized) autocorrelation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at two female names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](img/4818OS_10_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The autocorrelation of Olivia is decaying much faster than Maria's. This is
    mainly because of the steep increase of the name Olivia at the end of the twentieth
    century. By contrast, the name Maria is varying more slowly globally, and its
    autocorrelation is decaying somewhat slower.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **time series** is a sequence indexed by time. Important applications include
    stock markets, product sales, weather forecasting, biological signals, and many
    others. Time series analysis is an important part of statistical data analysis,
    signal processing, and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various definitions of the autocorrelation. Here, we define the autocorrelation
    of a time series *(x[n])* as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4818OS_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous plot, we normalized the autocorrelation by its maximum so as
    to compare the autocorrelation of two signals. The autocorrelation quantifies
    the average similarity between the signal and a shifted version of the same signal,
    as a function of the delay between the two. In other words, the autocorrelation
    can give us information about repeating patterns as well as the timescale of the
    signal's fluctuations. The faster the autocorrelation decays to zero, the faster
    the signal varies.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy's correlation function documentation, available at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.correlate.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.correlate.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocorrelation function in statsmodels, documented at [http://statsmodels.sourceforge.net/stable/tsa.html](http://statsmodels.sourceforge.net/stable/tsa.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time series on Wikipedia, available at [http://en.wikipedia.org/wiki/Time_series](http://en.wikipedia.org/wiki/Time_series)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial dependence on Wikipedia, available at [http://en.wikipedia.org/wiki/Serial_dependence](http://en.wikipedia.org/wiki/Serial_dependence)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocorrelation on Wikipedia, available at [http://en.wikipedia.org/wiki/Autocorrelation](http://en.wikipedia.org/wiki/Autocorrelation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Analyzing the frequency components of a signal with a Fast Fourier Transform*
    recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
