<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: An Introduction to Streamlit</h1>
			<p>Streamlit is a web application framework that helps you build and develop Python-based web applications that can be used to share analytics results, build complex interactive experiences, and illustrate new machine learning models. On top of that, developing and deploying Streamlit apps is incredibly fast and flexible, often turning application development time from days into hours. </p>
			<p>In this chapter, we start out with the Streamlit basics. We will learn how to download and run demo Streamlit apps, how to edit demo apps using our own text editor, how to organize our Streamlit apps, and finally, how to make our very own. Then, we will explore the basics of data visualization in Streamlit. We will learn how to accept some initial user input, and then add some finishing touches to our own apps with text. At the end of this chapter, you should be comfortable starting to make your own Streamlit applications!</p>
			<p>In particular, we will cover the following topics:</p>
			<ul>
				<li>Why Streamlit?</li>
				<li>Installing Streamlit</li>
				<li>Organizing Streamlit apps</li>
				<li>Streamlit plotting demo</li>
				<li>Making an app from scratch</li>
			</ul>
			<p>Before we begin, we will start with the technical requirements to make sure we have everything we need to get started. </p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>Here are the installations and setup required for this chapter:</p>
			<ul>
				<li>The requirements for this book are to have Python 3.7 (or later) downloaded (<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>), and have a text editor to edit Python files in. Any text editor will do. I use Sublime (<a href="https://www.sublimetext.com/3">https://www.sublimetext.com/3</a>). </li>
				<li>Some sections of this book use GitHub, and a GitHub account is recommended (<a href="https://github.com/join">https://github.com/join</a>). Understanding how to use Git is not necessary for this book but is always useful. If you want to get started, this link has a useful tutorial: <a href="https://guides.github.com/activities/hello-world/">https://guides.github.com/activities/hello-world/</a>.</li>
				<li>A basic understanding of Python is also very useful for this book. If you are not there yet, feel free to spend some time getting to know Python better using this tutorial (<a href="https://docs.python.org/3/tutorial/">https://docs.python.org/3/tutorial/</a>) or any other of the freely and readily available tutorials out there, and come back here when you are ready. We also need to have the Streamlit library installed, which we will do and test in a later section called <em class="italic">Installing Streamlit</em>.</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Why Streamlit?</h1>
			<p>Data scientists<a id="_idIndexMarker000"/> have become an increasingly valuable resource for companies and nonprofits over the course of the past decade. They help make data-driven decisions, make processes more efficient, and implement machine learning models to improve these decisions at a repeatable scale. One pain point for data scientists is in the process just after they have found a new insight or made a new model. What is the best way to show a dynamic result, a new model, or a complicated piece of analytics to a data scientist's colleagues? They can send a static visualization, which works in some cases but fails for complicated analyses that build on each other or on anything that requires user input. They can create a Word document (or export their Jupyter notebook as a document) that combines text and visualizations, which also doesn't work for user input and is harder to reproduce. Another option is to build out an entire web application from scratch using a framework such as Flask or Django, and then figure out how to deploy the entire app in AWS or another cloud provider. None of these options really work that well. Many are slow, don't take user input, or are suboptimal for informing the decision-making process so fundamental to data science. </p>
			<p>Enter Streamlit. Streamlit is all about speed and interaction. It is a web application framework that helps you build and develop Python web applications. It has built-in and convenient methods for taking in user input, graphing using the most popular and powerful Python graphing libraries, and quickly deploying graphs to a web application. </p>
			<p>I have spent the past year building Streamlit apps of all different flavors, from data projects for my personal portfolio to building quick applications for data science take-home problems, to even building mini-apps for repeatable analysis at work. I truly believe that Streamlit could be as valuable to you and your work as it has been to mine and wrote this to bring you quickly up to speed so you can accelerate your learning curve and get to building web applications in minutes and hours instead of days. If this is for you, read on! We will work in three sections, starting with an introduction to Streamlit, and ramp you up to building your own basic Streamlit applications. In part two, we'll extend this knowledge to more advanced topics such as production deployment methods and using components created by the Streamlit community for increasingly<a id="_idIndexMarker001"/> beautiful and usable Streamlit apps. And in the last part, we'll focus heavily on interviews with power users who use Streamlit at work, in academia, and for learning data science techniques. Before we begin, we need to get Streamlit set up and discuss how the rest of this book's examples will be structured. </p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Installing Streamlit</h1>
			<p>In order to<a id="_idIndexMarker002"/> run any Streamlit apps, you must first install Streamlit. I've used a package manager called pip to do this, but you can install it using any package manager you choose (for <a id="_idIndexMarker003"/>example, <strong class="bold">brew</strong>). This book uses Streamlit version 0.81, and Python 3.7, but it should work on newer versions as well.</p>
			<p>Throughout this book, we'll be using a mix of both terminal commands and code written in Python scripts. We will signpost in which location to run the code to make this as clear as possible. To install Streamlit, run the following code in a terminal:</p>
			<p class="source-code">pip install streamlit</p>
			<p>Now that we have Streamlit downloaded, we can call it directly from our command line using the preceding code to kick off Streamlit's <strong class="source-inline">demo.streamlit hello</strong>.</p>
			<p>Take some time to explore Streamlit's demo and take a glance at any code that you find interesting! We're going to borrow and edit the code behind the plotting demo, which <em class="italic">illustrates a combination of plotting and animation with Streamlit</em>. Before we dive in, let's take a <a id="_idIndexMarker004"/>second and talk about how to organize Streamlit apps.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Organizing Streamlit apps</h1>
			<p>Each Streamlit <a id="_idIndexMarker005"/>app we create in this book should be contained in its own folder. It is tempting to create new files for each Streamlit app, but this promotes a bad habit that will bite us later when we talk about deploying Streamlit apps and deal with permissions and data for Streamlit.</p>
			<p>For this book, I would recommend that you have a dedicated individual folder that will house all the apps you'll create throughout this book. I have named mine <strong class="source-inline">streamlit_apps</strong>. The following command will make a new folder called <strong class="source-inline">streamlit_apps</strong> and make it our current working directory: </p>
			<p class="source-code">mkdir streamlit_apps</p>
			<p class="source-code">cd streamlit_apps</p>
			<p>All the code for this book is housed at <a href="https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science">https://github.com/tylerjrichards/Getting-Started-with-Streamlit-for-Data-Science</a>, but I would highly recommend coding these by hand for practice.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Streamlit plotting demo</h1>
			<p>First, we're going<a id="_idIndexMarker006"/> to start to learn how to make Streamlit apps by reproducing the plotting demo we saw before in the Streamlit demo, with a Python file that we've made ourselves. In order to do that, we will do the following:</p>
			<ol>
				<li>Make a Python file where we will house all our Streamlit code.</li>
				<li>Use the plotting code given in the demo.</li>
				<li>Make small edits for practice.</li>
				<li>Run our file locally.</li>
			</ol>
			<p>Our first step is to create a folder called <strong class="source-inline">plotting_app</strong>, which will house our first example. The following code makes this folder when run in the terminal, changes our working directory to <strong class="source-inline">plotting_app</strong>, and creates an empty Python file we'll call <strong class="source-inline">plot_demo.py</strong>:</p>
			<p class="source-code">mkdir plotting_app</p>
			<p class="source-code">cd plotting_app</p>
			<p class="source-code">touch plot_demo.py</p>
			<p>Now that we've made a file called <strong class="source-inline">plot_demo.py</strong>, open it with any text editor (if you don't have one already, I'm partial to Sublime (<a href="https://www.sublimetext.com/">https://www.sublimetext.com/</a>). When you open it up, copy<a id="_idIndexMarker007"/> and paste the following code to your <strong class="source-inline">plot_demo.py</strong> file:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import time</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">progress_bar = st.sidebar.progress(0)</p>
			<p class="source-code">status_text = st.sidebar.empty()</p>
			<p class="source-code">last_rows = np.random.randn(1, 1)</p>
			<p class="source-code">chart = st.line_chart(last_rows)</p>
			<p class="source-code">for i in range(1, 101):</p>
			<p class="source-code">    new_rows = last_rows[-1, :] + np.random.randn(5, 1).cumsum(axis=0)</p>
			<p class="source-code">    status_text.text("%i%% Complete" % i)</p>
			<p class="source-code">    chart.add_rows(new_rows)</p>
			<p class="source-code">    progress_bar.progress(i)</p>
			<p class="source-code">    last_rows = new_rows</p>
			<p class="source-code">    time.sleep(0.05)</p>
			<p class="source-code">progress_bar.empty()</p>
			<p class="source-code"># Streamlit widgets automatically run the script from top to bottom. Since</p>
			<p class="source-code"># this button is not connected to any other logic, it just causes a plain</p>
			<p class="source-code"># rerun.</p>
			<p class="source-code">st.button("Re-run")</p>
			<p>This code does a <a id="_idIndexMarker008"/>few things. First, it imports all the libraries needed and creates a line chart in Streamlit's native graphing framework that starts at a random number sampled from a normal distribution with mean 0 and variance 1. And then it runs a <strong class="source-inline">for</strong> loop that keeps sampling new random numbers in bunches of 5 and adding that to the sum we had before while waiting for a twentieth of a second so we can see the graph change, simulating an animation.</p>
			<p>By the end of this book, you will be able to make apps like this extremely quickly. But for now, let's run this locally by typing the following code in our terminal:</p>
			<p class="source-code">streamlit run plot_demo.py</p>
			<p>This should open a new tab with your app in your default web browser. We should see our app run as shown in the following figure:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B16864_01_01.jpg" alt="Figure 1.1 – Plotting demo output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Plotting demo output</p>
			<p>This is how we will <a id="_idIndexMarker009"/>run every Streamlit app, by first calling <strong class="source-inline">streamlit run</strong> and then pointing Streamlit toward the Python script that houses our app's code. Now let's change something small within the app so we better understand how Streamlit works. The following code changes how many random numbers we plot on our graph, but feel free to make any changes you'd like. Make your changes using the following code, save your changes in your text editor of choice, and run the file again: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import time</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">progress_bar = st.sidebar.progress(0)</p>
			<p class="source-code">status_text = st.sidebar.empty()</p>
			<p class="source-code">last_rows = np.random.randn(1, 1)</p>
			<p class="source-code">chart = st.line_chart(last_rows)</p>
			<p class="source-code">for i in range(1, 101):</p>
			<p class="source-code">    new_rows = last_rows[-1, :] + np.random.randn(50, 1).cumsum(axis=0)</p>
			<p class="source-code">    status_text.text("%i%% Complete" % i)</p>
			<p class="source-code">    chart.add_rows(new_rows)</p>
			<p class="source-code">    progress_bar.progress(i)</p>
			<p class="source-code">    last_rows = new_rows</p>
			<p class="source-code">    time.sleep(0.05)</p>
			<p class="source-code">progress_bar.empty()</p>
			<p class="source-code"># Streamlit widgets automatically run the script from top to bottom. Since</p>
			<p class="source-code"># this button is not connected to any other logic, it just causes a plain</p>
			<p class="source-code"># rerun.</p>
			<p class="source-code">st.button("Re-run")</p>
			<p>You should<a id="_idIndexMarker010"/> notice that Streamlit detected a change to the source file and is prompting you to rerun the file if you'd like. Click <strong class="bold">Rerun</strong> (or <strong class="bold">Always rerun</strong> if you want this behavior to be the default, which I almost always do), and watch your app change. </p>
			<p>Feel free to try making some other changes to the plotting app to get the hang of it! Once you are ready, let's move on to making our own apps.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Making an app from scratch</h1>
			<p>Now that<a id="_idIndexMarker011"/> we've tried out the apps others have made, let's make our own! This app is going to focus on using the central limit theorem, which is a fundamental theorem of statistics that says that if we randomly sample with replacement enough from any distribution, then the distribution of the mean of our samples will approximate the normal distribution.</p>
			<p>We are not going to prove this with our app, but instead, let's try to generate a few graphs that help explain the power of the central limit theorem. First, let's make sure that we're in the correct directory (we called it <strong class="source-inline">streamlit_apps</strong> earlier), make a new folder called <strong class="source-inline">clt_app</strong>, and toss in a new file.</p>
			<p>The following code makes a new folder called <strong class="source-inline">clt_app</strong>, and again creates an empty Python file, this time called <strong class="source-inline">clt_demo.py</strong>: </p>
			<p class="source-code">mkdir clt_app</p>
			<p class="source-code">cd clt_app</p>
			<p class="source-code">touch clt_demo.py</p>
			<p>Whenever we start a new Streamlit app, we want to make sure to import Streamlit (often aliased in this book and elsewhere as <strong class="source-inline">st</strong>). Streamlit has unique functions for each type of<a id="_idIndexMarker012"/> content (text, graphs, pictures, and other media) that we can use as building blocks for all of our apps. The first one we'll use is <strong class="source-inline">st.write()</strong>, which is a function that takes a string (and as we'll see later, almost any Pythonic objects, such as dictionaries) and writes it directly into our web app in the order that it is called. As we are calling a Python script, Streamlit sequentially looks through the file and, every time it sees one of the functions, designates a sequential slot for that piece of content. This makes it very easy to use, as you can write all the Python you'd like, and when you want something to appear on the app you've made, you can simply use <strong class="source-inline">st.write()</strong> and you're all set.</p>
			<p>In our <strong class="source-inline">clt_demo.py</strong> file, we can start with the basic <strong class="source-inline">'Hello World'</strong> output using <strong class="source-inline">st.write()</strong>, using the following code: </p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">st.write('Hello World')</p>
			<p>Now we can test this by running the following code in the terminal:</p>
			<p class="source-code">streamlit run clt_demo.py</p>
			<p>We should see the string <strong class="source-inline">'Hello World'</strong> printed on our app, so all is good so far. The following figure is a screenshot of our app in Safari:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B16864_01_02.jpg" alt="Figure 1.2 – Hello World app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Hello World app</p>
			<p>There are three <a id="_idIndexMarker013"/>items to note in this screenshot. First, we see the string as we wrote it, which is great. Next, we see that the URL points to <strong class="bold">localhost:8501</strong>, which is just telling us that we're hosting this locally (that is, it's not on the internet anywhere) through port <strong class="source-inline">8501</strong>. We don't need to understand almost anything about the<a id="_idIndexMarker014"/> port system on computers, or the <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>). The important thing here is that this app is local to your computer. The third important item to note is the hamburger icon at the top right. The following screenshot shows us what happens when we click the icon: </p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B16864_01_03.jpg" alt="Figure 1.3 – Icon options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Icon options</p>
			<p>This is the default <a id="_idIndexMarker015"/>options panel for Streamlit apps. Throughout this book, we'll discuss each of these options in depth, especially the non-self-explanatory ones such as <strong class="bold">Clear cache</strong>. All we have to know for now is that if we want to rerun the app or find settings or the documentation, we can use this icon to find almost whatever we need.</p>
			<p>When we host applications so that others can use them, they'll see this same icon but have some different options (for example, they will not be able to clear the cache). We'll discuss this in greater detail later as well. Now back to our central limit theorem app!</p>
			<p>The next step is going to be generating a distribution that we want to sample from with replacement. I'm choosing the binomial here. We can read the following code as simulating 1,000 coin flips using the Python package <strong class="source-inline">numpy</strong>, and printing out the mean number of heads from those 1,000 coin flips:</p>
			<p class="source-code">import streamlit as st </p>
			<p class="source-code">import numpy as np </p>
			<p class="source-code">binom_dist = np.random.binomial(1, .5, 100)</p>
			<p class="source-code">st.write(np.mean(binom_dist))</p>
			<p>Now, given what we know about the central limit theorem, we would expect that if we sampled from <strong class="source-inline">binom_dist</strong> enough times, the mean of those samples would approximate the normal distribution.</p>
			<p>We've already discussed the <strong class="source-inline">st.write()</strong> function. Our next foray into writing content to the Streamlit app is through graphs. <strong class="source-inline">st.pyplot()</strong> is a function that lets us use all the power<a id="_idIndexMarker016"/> of the popular <strong class="source-inline">matplotlib</strong> library and push our <strong class="source-inline">matplotlib</strong> graph to Streamlit. Once we create a figure in <strong class="source-inline">matplotlib</strong>, we can explicitly tell Streamlit to write that to our app with the <strong class="source-inline">st.pyplot()</strong> function.</p>
			<p>So, all together now! This app simulates 1,000 coin flips and stores those values in a list we call <strong class="source-inline">binom_dist</strong>. We then sample (with replacement) 100 from that list, take the mean, and store that mean in the cleverly named variable <strong class="source-inline">list_of_means</strong>. We do that 1,000 times (it's overkill – we could do this even with dozens of samples), and then plot the histogram. After we do this, the result of the following code should show a bell-shaped distribution: </p>
			<p class="source-code">import streamlit as st </p>
			<p class="source-code">import numpy as np </p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">binom_dist = np.random.binomial(1, .5, 1000)</p>
			<p class="source-code">list_of_means = []</p>
			<p class="source-code">for i in range(0, 1000):</p>
			<p class="source-code">     list_of_means.append(np.random.choice(binom_dist, 100, replace=True).mean())</p>
			<p class="source-code">fig, ax = plt.subplots()</p>
			<p class="source-code">ax = plt.hist(list_of_means)</p>
			<p class="source-code">st.pyplot(fig)</p>
			<p>Each run of this app will create a new bell curve. When I ran it, my bell curve looked like the following figure. If your graph isn't exactly what you see in the next figure, that's totally fine because of the random sampling used in our code:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16864_01_04.jpg" alt="Figure 1.4 – Bell curve&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Bell curve</p>
			<p>As you probably<a id="_idIndexMarker017"/> noticed, we first created an empty figure and empty axes for that figure by calling <strong class="source-inline">plt.subplots()</strong>, and then assigned the histogram we created to the <strong class="source-inline">ax</strong> variable. Because of this, we were able to explicitly tell Streamlit to show the figure on our Streamlit app.</p>
			<p>This is an important step, as in Streamlit versions, we can also skip this step, and not assign our histogram to any variable, and then call <strong class="source-inline">st.pyplot()</strong> directly afterward. The following code takes this approach:</p>
			<p class="source-code">import streamlit as st </p>
			<p class="source-code">import numpy as np </p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">binom_dist = np.random.binomial(1, .5, 1000)</p>
			<p class="source-code">list_of_means = []</p>
			<p class="source-code">for i in range(0, 1000):</p>
			<p class="source-code">     list_of_means.append(np.random.choice(binom_dist, 100, replace=True).mean())</p>
			<p class="source-code">plt.hist(list_of_means)</p>
			<p class="source-code">st.pyplot()</p>
			<p>I don't recommend <a id="_idIndexMarker018"/>this method, as it can give you some unexpected results. Take this example, where we want to first make our histogram of means, and then make another histogram of a new list filled only with the number 1.</p>
			<p>Take a second and guess what the following code would do. How many graphs would we get? What would the output be?</p>
			<p class="source-code">import streamlit as st </p>
			<p class="source-code">import numpy as np </p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">binom_dist = np.random.binomial(1, .5, 1000)</p>
			<p class="source-code">list_of_means = []</p>
			<p class="source-code">for i in range(0, 1000):</p>
			<p class="source-code">     list_of_means.append(np.random.choice(binom_dist, 100, replace=True).mean())</p>
			<p class="source-code">plt.hist(list_of_means)</p>
			<p class="source-code">st.pyplot()</p>
			<p class="source-code">plt.hist([1,1,1,1])</p>
			<p class="source-code">st.pyplot()</p>
			<p>I would expect this to show two histograms, the first one of <strong class="source-inline">list_of_means</strong>, and the second <a id="_idIndexMarker019"/>one of the lists of <strong class="source-inline">1</strong>s:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16864_01_05.jpg" alt="Figure 1.5 – A tale of two histograms &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – A tale of two histograms </p>
			<p>What we actually get is different! The second histogram has data from the first and the second list! When we call <strong class="source-inline">plt.hist()</strong> without assigning the output to anything, <strong class="source-inline">matplotlib</strong> tacks the new histogram onto the old graph that is stored globally, and Streamlit pushes that new one to our app.</p>
			<p>Here's a solution to this issue. If we instead explicitly created two graphs, we could call the <strong class="source-inline">st.pyplot()</strong> function wherever we liked after the graph was generated, and have greater control over where exactly our graphs were placed. The following code separates the two <a id="_idIndexMarker020"/>graphs explicitly: </p>
			<p class="source-code">import streamlit as st </p>
			<p class="source-code">import numpy as np </p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">binom_dist = np.random.binomial(1, .5, 1000)</p>
			<p class="source-code">list_of_means = []</p>
			<p class="source-code">for i in range(0, 1000):</p>
			<p class="source-code">     list_of_means.append(np.random.choice(binom_dist, 100, replace=True).mean())</p>
			<p class="source-code">fig1, ax1 = plt.subplots()</p>
			<p class="source-code">ax1 = plt.hist(list_of_means)</p>
			<p class="source-code">st.pyplot(fig1)</p>
			<p class="source-code">fig2, ax2 = plt.subplots()</p>
			<p class="source-code">ax2 = plt.hist([1,1,1,1])</p>
			<p class="source-code">st.pyplot(fig2)</p>
			<p>The preceding code plots both histograms separately by first defining separate variables for each figure and axis using <strong class="source-inline">plt.subplots()</strong> and then assigning the histogram to the appropriate axis. After this, we can call <strong class="source-inline">st.pyplot()</strong> using the created figure, which produces the following app: </p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16864_01_06.jpg" alt="Figure 1.6 – Fixed histograms&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Fixed histograms</p>
			<p>We can clearly<a id="_idIndexMarker021"/> see in the preceding figure that the two histograms are now separated, which is the desired behavior. We will very often plot multiple visualizations in Streamlit and will use this method for the rest of the book. Now, on to accepting user input!</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Using user input in Streamlit apps</h2>
			<p>As of now, our <a id="_idIndexMarker022"/>app is just a fancy way to show our visualizations. But most web apps take some user input or are dynamic, not static visualizations. Luckily for us, Streamlit has many functions to accept inputs from users, all differentiated by the object that we want to input. There are freeform text inputs with <strong class="source-inline">st.text_input()</strong>; radio buttons, <strong class="source-inline">st.radio()</strong>; numeric inputs with <strong class="source-inline">st.number_input()</strong>; and a dozen more that are extremely helpful for making Streamlit apps. We will explore most of them in detail throughout this book, but we'll start with the numeric input.</p>
			<p>From the previous example, we assumed that the coins we were flipping were fair coins and had a 50/50 chance of being heads or tails. Let's let the user decide what the percentage chance of heads is, assign that to a variable, and use that as an input in our binomial distribution. The number input function takes a label, a minimum and maximum value, and a default value, which I have filled in the following code: </p>
			<p class="source-code">import streamlit as st </p>
			<p class="source-code">import numpy as np </p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">perc_heads = st.number_input(label = 'Chance of Coins Landing on Heads', min_value = 0.0, max_value = 1.0, value = .5)</p>
			<p class="source-code">binom_dist = np.random.binomial(1, perc_heads, 1000)</p>
			<p class="source-code">list_of_means = []</p>
			<p class="source-code">for i in range(0, 1000):</p>
			<p class="source-code">     list_of_means.append(np.random.choice(binom_dist, 100, replace=True).mean())</p>
			<p class="source-code">fig, ax = plt.subplots()</p>
			<p class="source-code">ax = plt.hist(list_of_means, range=[0,1])</p>
			<p class="source-code">st.pyplot(fig)</p>
			<p>The preceding code uses the <strong class="source-inline">st.number_input()</strong> function to collect our percentage, assigns the user input to a variable (<strong class="source-inline">perc_heads</strong>), then uses that variable to change the inputs to our binomial distribution function that we used before. It also sets our histogram's <em class="italic">x</em> axis to always be between 0 and 1, so we can better notice changes as our input changes. Try and play around with this app for a bit; change the number input and notice how the app responds whenever a user input is changed. For example, here is a result <a id="_idIndexMarker023"/>from when we set the numeric input to <strong class="source-inline">.25</strong>: </p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16864_01_07.jpg" alt="Figure 1.7 - An example of a result from when we set the numeric input to .25&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 - An example of a result from when we set the numeric input to .25</p>
			<p>As you probably noticed, every time that we changed the input of our script, Streamlit re-ran the entire application. This is the default behavior and is very important to understanding Streamlit performance; we will explore a few ways that allow us to change this default later in the book, such as adding caching or forms! We can also accept text input in Streamlit using the <strong class="source-inline">st.text_input()</strong> function, just as we did with the numeric input. The next bit of code takes a text input and assigns it to the title of our <a id="_idIndexMarker024"/>graph: </p>
			<p class="source-code">import streamlit as st  </p>
			<p class="source-code">import numpy as np  </p>
			<p class="source-code">import matplotlib.pyplot as plt </p>
			<p class="source-code">perc_heads = st.number_input(label='Chance of Coins Landing on Heads', min_value=0.0,  max_value=1.0, value=.5) </p>
			<p class="source-code">graph_title = st.text_input(label='Graph Title')</p>
			<p class="source-code">binom_dist = np.random.binomial(1, perc_heads, 1000) </p>
			<p class="source-code">list_of_means = [] </p>
			<p class="source-code">for i in range(0, 1000): </p>
			<p class="source-code">list_of_means.append(np.random.choice(binom_dist, 100, replace=True).mean()) </p>
			<p class="source-code"> </p>
			<p class="source-code">fig, ax = plt.subplots() </p>
			<p class="source-code">plt.hist(list_of_means, range=[0,1])</p>
			<p class="source-code">plt.title(graph_title)</p>
			<p class="source-code">st.pyplot(fig)</p>
			<p>This creates a Streamlit app with two inputs, both a numeric input and a text input, and uses them both to change our Streamlit app. Finally, this results in a Streamlit app that looks like the next figure, with dynamic titles and probabilities: </p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16864_01_08.jpg" alt="Figure 1.8 – A Streamlit app with dynamic titles and probabilities&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – A Streamlit app with dynamic titles and probabilities</p>
			<p>Now that we<a id="_idIndexMarker025"/> have worked a bit with user input, let's talk about text and Streamlit apps more deeply. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Finishing touches – adding text to Streamlit</h2>
			<p>Our app is <a id="_idIndexMarker026"/>functional, but it is missing a lot of nice touches. We talked earlier about the <strong class="source-inline">st.write()</strong> function, which the Streamlit docs call the Swiss Army knife of Streamlit commands. Almost whatever we wrap <strong class="source-inline">st.write()</strong> around will work by default and it should be our go-to function if we're not sure of the best path forward.</p>
			<p>Other than <strong class="source-inline">st.write()</strong>, we also can utilize other built-in functions that format our text for us, such as <strong class="source-inline">st.title()</strong>, <strong class="source-inline">st.header()</strong>, <strong class="source-inline">st.markdown()</strong>, and <strong class="source-inline">st.subheader()</strong>. Using these five functions helps to format text in our Streamlit apps easily and keeps sizing consistent for bigger apps. </p>
			<p>More specifically, <strong class="source-inline">st.title()</strong> will place a large block of text in our app, <strong class="source-inline">st.header()</strong> uses a slightly smaller font than <strong class="source-inline">st.title()</strong>, and <strong class="source-inline">st.subheader()</strong> uses an even smaller one. Other than those three, <strong class="source-inline">st.markdown()</strong> will allow anyone already familiar with Markdown to use the popular markup language in our Streamlit apps. Let's try a couple of them in the following <a id="_idIndexMarker027"/>code:</p>
			<p class="source-code">import streamlit as st</p>
			<p class="source-code">import numpy as np</p>
			<p class="source-code">import matplotlib.pyplot as plt</p>
			<p class="source-code">st.title('Illustrating the Central Limit Theorem with Streamlit')</p>
			<p class="source-code">st.subheader('An App by Tyler Richards')</p>
			<p class="source-code">st.write(('This app simulates a thousand coin flips using the chance of heads input below,' </p>
			<p class="source-code">     'and then samples with replacement from that population and plots the histogram of the'</p>
			<p class="source-code">     ' means of the samples, in order to illustrate the Central Limit Theorem!'))</p>
			<p class="source-code">perc_heads = st.number_input(</p>
			<p class="source-code">    label='Chance of Coins Landing on Heads', min_value=0.0, max_value=1.0, value=.5)</p>
			<p class="source-code">binom_dist = np.random.binomial(1, perc_heads, 1000)</p>
			<p class="source-code">list_of_means = []</p>
			<p class="source-code">for i in range(0, 1000):</p>
			<p class="source-code">    list_of_means.append(np.random.choice(</p>
			<p class="source-code">        binom_dist, 100, replace=True).mean())</p>
			<p class="source-code">fig, ax = plt.subplots()</p>
			<p class="source-code">ax = plt.hist(list_of_means)</p>
			<p class="source-code">st.pyplot(fig)</p>
			<p>This preceding<a id="_idIndexMarker028"/> code adds a large title (<strong class="source-inline">st.title()</strong>), adds a smaller subheader below (<strong class="source-inline">st.subheader()</strong>), and then adds some even smaller text below the subheader (<strong class="source-inline">st.write()</strong>). We also separated the long string of text in the preceding code block into three smaller strings for readability and to make it easier to edit in our text editor. It should look like the following screenshot. Note that because we are using randomly generated data for this histogram, it is OK (and expected!) if your histogram looks slightly different:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16864_01_09.jpg" alt="Figure 1.9 – Central Limit Theorem application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Central Limit Theorem application</p>
			<p>One other option<a id="_idIndexMarker029"/> Streamlit has for writing out text is <strong class="source-inline">st.markdown()</strong>, which interprets and writes Markdown-style text into your Streamlit app. If you already have familiarity with Markdown, this is a great option to test out instead of <strong class="source-inline">st.write()</strong>. </p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Summary</h1>
			<p>In this chapter, we started by learning how to organize our files and folders for the remainder of this book and quickly moved on to instructions for downloading Streamlit. We then built our first Streamlit application, Hello World, and learned how to run our Streamlit applications locally. Then we started building out a more complicated application to show the implications of the central limit theorem from the ground up, going from a simple histogram to accepting user input and formatting different types of text around our app for clarity and beautification. </p>
			<p>By now, you should be comfortable with subjects such as basic data visualization, editing Streamlit apps in a text editor, and locally running Streamlit apps. We're going to dive more deeply into data manipulation in our next chapter.</p>
		</div>
	</body></html>