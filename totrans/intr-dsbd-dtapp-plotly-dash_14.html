<html><head></head><body>
		<div id="_idContainer180">
			<h1 id="_idParaDest-151"><em class="italic"><a id="_idTextAnchor151"/>Chapter 11</em>: URLs and Multi-Page Apps</h1>
			<p>So far, we have been building everything on one page. We kept adding new charts and interactive components to a single div and incorporated them as we saw fit. Adding new URLs can be useful for space-saving purposes, so that we don't end up having too many components on a single page. URLs also serve as a tool for classifying content and providing context, so users know "where" they are and what they are doing.</p>
			<p>Even more interesting is the ability to programmatically generate many additional pages to your app, simply by displaying content based on the URL (or any part of it). This is what we will do in this chapter.</p>
			<p>Once we get to know how the <strong class="bold">Location</strong> and <strong class="bold">Link</strong> components work, we will then make a slight change to the structure of the app, by making and isolating new layouts. Then, it will be clear how easy it is to make a multi-page app. We will have a general layout with an empty area in the middle, and using a simple rule, content will be displayed based on the URL.</p>
			<p>All the functionality we have built was mainly based on indicators. We created many charts for those indicators, showing how they vary in time and across countries. Our users might also be interested in country-oriented reports. So, we will create a page for each country, where users can check whichever indicator they want for the country of interest and optionally compare with other countries. With a few simple changes, we will add 169 new pages to our app.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Getting to know the <strong class="source-inline">Location</strong> and <strong class="source-inline">Link</strong> components</li>
				<li>Extracting and using attributes of URLs</li>
				<li>Parsing URLs and using their components to modify parts of the app</li>
				<li>Restructuring your app to cater to multiple layouts</li>
				<li>Adding dynamically generated URLs to the app</li>
				<li>Incorporating the new URL interactivity into the app</li>
			</ul>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor152"/>Technical requirements</h1>
			<p>For the new components that we will introduce, we will still be using the same tools. Dash, Dash Core Components, Dash HTML Components, and Dash Bootstrap Components will be used to build our new functionality and add it to our app. We will also be using pandas for data manipulation, JupyterLab and <strong class="source-inline">jupyter_dash</strong> for experimenting with isolated functionality, and Plotly and Plotly Express for data visualization.</p>
			<p>The main topic of this chapter will be manipulating parts of the URLs and using them as inputs to modify other components. This is the same as using any other element of our app to create the functionality that we want. Let's start by getting to know the two components that make this possible.</p>
			<p>The code files of this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11">https://github.com/PacktPublishing/Interactive-Dashboards-and-Data-Apps-with-Plotly-and-Dash/tree/master/chapter_11</a>.</p>
			<p>Check out the following video to see the Code in Action at <a href="https://bit.ly/3eks3GI">https://bit.ly/3eks3GI</a>.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor153"/>Getting to know the Location and Link components</h1>
			<p>These components are part of <a id="_idIndexMarker538"/>Dash Core Components, and their names make <a id="_idIndexMarker539"/>quite clear what they are and what they might do. The <strong class="source-inline">Location</strong> component refers to the browser's location bar. It is also referred to as the address bar or the URL bar. We typically place a <strong class="source-inline">Location</strong> component in the app, and it doesn't produce anything visible. We mainly use it to discover where we are in the app, and based on that, we induce some functionality. Let's create a simple example to see how it can be used in its simplest form: </p>
			<ol>
				<li value="1">Create a simple app:<p class="source-code">import dash_html_components as html</p><p class="source-code">import dash_core_components as dcc</p><p class="source-code">from jupyter_dash import JupyterDash</p><p class="source-code">from dash.dependencies import Output, Input</p><p class="source-code">app = JupyterDash(__name__)</p></li>
				<li>Create a simple layout for the app containing a <strong class="source-inline">Location</strong> component and, right underneath it, an empty <strong class="source-inline">div</strong>: <p class="source-code">app.layout = html.Div([</p><p class="source-code">    <strong class="bold">dcc.Location(id='location')</strong>,</p><p class="source-code"> <strong class="bold">html.Div(id='output')</strong></p><p class="source-code">])</p></li>
				<li>Create a callback function <a id="_idIndexMarker540"/>that takes the <strong class="source-inline">href</strong> attribute of the <strong class="source-inline">Location</strong> component and prints it to the empty div: <p class="source-code">@app.callback(Output('output', 'children'), <strong class="bold">Input('location', 'href')</strong>)</p><p class="source-code">def display_href(href):</p><p class="source-code">    return f"You are at: {<strong class="bold">href</strong>}."</p></li>
				<li>Run the app and observe its output: <p class="source-code">app.run_server(mode='inline')</p><p class="source-code"><strong class="bold">You are at: http://127.0.0.1:8050/.</strong></p></li>
			</ol>
			<p>It's quite straightforward and clear. We simply ask the <strong class="source-inline">Location</strong> component to tell us where it is, and we <a id="_idIndexMarker541"/>display it in the empty div. In this example, we asked for the <strong class="source-inline">href</strong> attribute, and we got the full URL of the current page. For various reasons, we might be interested in other attributes, for more nuanced functionality. Let's build another simple app to extract the other available attributes of the <strong class="source-inline">Location</strong> component and get to know how to use the <strong class="source-inline">Link</strong> component as well.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor154"/>Getting to know the Link component</h2>
			<p>As the name suggests, this <a id="_idIndexMarker542"/>component produces links. Another way of creating links is by using the HTML <strong class="source-inline">&lt;a&gt;</strong> tag, which is available in the Dash HTML Components package. While <strong class="source-inline">&lt;a&gt;</strong> is more suitable for external links, <strong class="source-inline">Link</strong> is better suited for internal ones. A <a id="_idIndexMarker543"/>nice advantage is that it simply changes the pathname attribute and does so without refreshing the page. So, it is fast and responsive, just like changing the value in any other interactive component.</p>
			<p>In the update to our simple app, we will add an <strong class="source-inline">&lt;a&gt;</strong> link, as well as a few <strong class="source-inline">Link</strong> component links, so you can experience the difference in refreshing and also get to know both types of link. Our <strong class="source-inline">Location</strong> component will now get the location of the current page, but we will also use it to extract all the available attributes and discuss some ideas about how they might be used. Let's create the elements that will go into our app's layout:</p>
			<ol>
				<li value="1">Add a <strong class="source-inline">Location</strong> component:<p class="source-code">dcc.Location(id='location')</p></li>
				<li>Add an <strong class="source-inline">&lt;a&gt;</strong> component through Dash HTML Components, pointing to an internal page using a relative path:<p class="source-code">html.A(href='<strong class="bold">/path</strong>',</p><p class="source-code">       children='Go to a directory path'),</p></li>
				<li>Add a <strong class="source-inline">Link</strong> component <a id="_idIndexMarker544"/>pointing to a page with a search attribute (query parameters):<p class="source-code">dcc.Link(href='/path/search<strong class="bold">?one=1&amp;two=2</strong>',</p><p class="source-code">         children='Go to search page')</p></li>
				<li>Add another <strong class="source-inline">Link</strong> component pointing to a page with a hash, which is also known as a fragment:<p class="source-code">dcc.Link(href='path/?hello=HELLO<strong class="bold">#hash_string</strong>',   children='Go to a page with a hash')</p></li>
				<li>Add an empty div where the output will be displayed:<p class="source-code">html.Div(id='output')</p></li>
			</ol>
			<p>This is similar to the <a id="_idIndexMarker545"/>previous app, as you can see; we only added a few links. These will be displayed as regular links on the page. We will now extract and display the parts that we are interested in, using a new callback function:</p>
			<ol>
				<li value="1">Create the decorator of the function, adding a separate <strong class="source-inline">Input</strong> element for each attribute of the <strong class="source-inline">Location</strong> component. As you will see, the location is the full URL, but each part gets automatically extracted for us depending on what we specify:<p class="source-code">@app.callback(Output('output', 'children'),</p><p class="source-code">              Input('location', <strong class="bold">'pathname'</strong>),</p><p class="source-code">             Input('location', <strong class="bold">'search'</strong>),</p><p class="source-code">             Input('location', <strong class="bold">'href'</strong>),</p><p class="source-code">              Input('location', <strong class="bold">'hash'</strong>))</p></li>
				<li>Create the signature of the callback function, taking each of the <strong class="source-inline">Location</strong> component's attributes as <strong class="source-inline">Input</strong> elements. Note <a id="_idIndexMarker546"/>that we append an underscore to the <strong class="source-inline">hash</strong> argument, to make it clear that we are not using the built-in Python function of the same name:<p class="source-code">def show_url_parts(pathname, search, href, hash_)</p></li>
				<li>Return the <a id="_idIndexMarker547"/>different attributes of the URL we are in, in the empty div: <p class="source-code">return html.Div([</p><p class="source-code">    f"href: {href}",</p><p class="source-code">    f"path: {pathname}",</p><p class="source-code">    f"search: {search}",</p><p class="source-code">    f"hash: {hash_}"</p><p class="source-code">])</p></li>
			</ol>
			<p>Running the preceding code and clicking on the links we have created shows different URL attributes shown in the div, as you can see in <em class="italic">Figure 11.1</em>:</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B16780_11_1.jpg" alt="Figure 11.1 – The Location component showing various URL parts for different URLs"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – The Location component showing various URL parts for different URLs</p>
			<p>As you can see, we have used the <strong class="source-inline">Link</strong> component to change the URL and used <strong class="source-inline">Location</strong> to extract whichever attribute we wanted. You can easily see how this might be used in other types of callback functions that do more than just display those attributes. Let's take a look at how we can parse and extract query parameters and their values using Python's <strong class="source-inline">parse_qs</strong> (parse query string) function:</p>
			<p class="source-code">from urllib.parse import parse_qs</p>
			<p class="source-code">parse_qs('1=one&amp;2=two&amp;20=twenty')</p>
			<p class="source-code"><strong class="bold">{'1': ['one'], '2': ['two'], '20': ['twenty']}</strong></p>
			<p>We can now do <a id="_idIndexMarker548"/>whatever we want with those values. A more practical application, taking our dataset as an example, is that you can create specific and shareable URLs, where <a id="_idIndexMarker549"/>users can share a specific chart with a certain set of options, simply by providing a URL for it:</p>
			<p class="source-code">parse_qs('country_code=CAN&amp;year=2020&amp;inidcator=SI.DST.02ND.20')</p>
			<p class="source-code"><strong class="bold">{'country_code': ['CAN'], 'year': ['2020'], 'inidcator': ['SI.DST.02ND.20']}</strong></p>
			<p>Once you get a country name, a year, and an indicator, you can easily take this as an input to a callback function and produce the desired chart based on those selections. You can also imagine making it easier for your users, where the selections they make in the interactive components change the <strong class="source-inline">Location</strong> component, making it very easy to share those URLs. The great thing about this, as mentioned already, is that it works without refreshing the page, so it won't slow down the process in any way.</p>
			<p>Let's see how this works in a practical application, using our dataset.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor155"/>Parsing URLs and using their components to modify parts of the app</h1>
			<p>Having established some <a id="_idIndexMarker550"/>working knowledge about how <strong class="source-inline">Location</strong> and <strong class="source-inline">Link</strong> components work, we want to use this in our app. The plan is to add 169 new pages using three callbacks and adding a few new layout elements. The user will have a drop-down menu of countries to choose from. Selecting a country modifies the URL, which will render the country layout. This layout will include a heading, a chart, and a table <a id="_idIndexMarker551"/>about the country in the URL.</p>
			<p><em class="italic">Figure 11.2</em> shows a sample of a <a id="_idIndexMarker552"/>country page that we will build:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B16780_11_2.jpg" alt="Figure 11.2 – A sample country page showing a chart including other countries as well"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – A sample country page showing a chart including other countries as well</p>
			<p>As you can see, we now have a template for a country page. This was triggered because the URL contained a country that is one of the available countries in the dataset. Otherwise, it will display the main app, containing all the components that we have built so far. Users can also click on the <strong class="bold">Home</strong> link to go there.</p>
			<p>Let's first see how to restructure our app.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor156"/>Restructuring your app to cater to multiple layouts</h1>
			<p>At this stage, we haven't moved from the basic structure that we discussed in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>, and as a reminder, <em class="italic">Figure 11.3</em> shows a simplified representation of the current structure:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B16780_11_3.jpg" alt="Figure 11.3 – The structure of a Dash app"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – The structure of a Dash app</p>
			<p>Everything will remain the <a id="_idIndexMarker553"/>same, with the exception of the layout part. Right now, we only have one layout attribute, and everything was added to the main div. We used tabs to efficiently utilize space in some cases, and from Dash Bootstrap Components we used the <strong class="source-inline">Row</strong> and <strong class="source-inline">Col</strong> components to flexibly manage how components are displayed. To create the new layout structure, we need to create one main layout, which will serve as the skeleton of our app. In this layout, we will have an empty div, which will get populated with the appropriate content, depending on the URL we are on. <em class="italic">Figure 11.4</em> shows how this skeleton might look. This is just to make it easy to visualize; it would never show an empty page like this. Note that we also added a navigation bar, to which we can add several other elements, and this can be thought of as another addition to our app:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B16780_11_4.jpg" alt="Figure 11.4 – The new skeleton layout of the app showing an empty main content area"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – The new skeleton layout of the app showing an empty main content area</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">As you can see on the skeleton page with the empty body, you can use Dash for very fast prototyping and designing apps. Before you start coding, you can quickly build the layout you want, share with other stakeholders, get feedback, and only then start coding the interactivity.</p>
			<p class="callout">As we did with the same figure, you can also isolate or remove certain elements, to make it easier for your audience to understand the structure of the app you are building.</p>
			<p>Let's now code <a id="_idIndexMarker554"/>the different parts that we need to upgrade our app with country URLs and a navigation bar. We start by first creating a few separate layouts:</p>
			<ol>
				<li value="1"><strong class="bold">Main layout</strong>: This will function as the main skeleton of our app. It will contain the navigation bar together with the country drop-down menu. For now, we will simply declare a <strong class="source-inline">NavbarSimple</strong> component and discuss its details in the following section. Our layout will also contain the footer that has tabs, which we previously created. The body of this layout, like our simple app at the beginning of the chapter, will have a <strong class="source-inline">Location</strong> component, as well as an empty div that will display the required layout:<p class="source-code">main_layout = html.Div([</p><p class="source-code">                  dbc.NavbarSimple([                      …</p><p class="source-code">                  ]),</p><p class="source-code">                  <strong class="bold">dcc.Location(id='location')</strong>,</p><p class="source-code">                  <strong class="bold">html.Div(id='main_content')</strong>,</p><p class="source-code">                  dbc.Tabs([</p><p class="source-code">                  …</p><p class="source-code">                  ])</p><p class="source-code">])</p></li>
				<li><strong class="bold">Indicators dashboard</strong>: This is <a id="_idIndexMarker555"/>basically the layout part that we have been working with so far, as is, with no changes. We just save it to a new variable and pass it to the <strong class="source-inline">main_content</strong> div when the right condition is met (if the URL does not contain a country name):<p class="source-code">indicators_dashboard = html.Div([</p><p class="source-code">    # all components we built so far</p><p class="source-code">])</p></li>
				<li><strong class="bold">Country dashboard</strong>: This will also be saved to a variable and displayed when its condition is met, which is when there is a country name in the URL. The content of this layout (chart and table) will be for the country in the URL:<p class="source-code">country_dashboard = html.Div([</p><p class="source-code">    html.H1(id='country_heading'),</p><p class="source-code">    dcc.Graph(id='country_page_graph'),</p><p class="source-code">    dcc.Dropdown(id='country_page_indicator_dropdown'),</p><p class="source-code">    dcc.Dropdown(id='country_page_contry_dropdown'),</p><p class="source-code">    html.Div(id='country_table')</p><p class="source-code">])</p></li>
				<li><strong class="bold">Validation layout</strong>: This will be a <a id="_idIndexMarker556"/>simple list and has to be in the form of a Dash component, containing the previous three layouts. The importance of this list is to indicate to Dash which layouts are available to the app, as a whole. When we display the contents of one of the layouts and not the others, some components will not be part of the app, and some callbacks will break. The <strong class="source-inline">validation_layout</strong> attribute solves this issue for us. It's also a nice and easy way to know and manage the layout of our app as a whole. This can come in handy with more complex apps that have many more layouts. You can think of it as the app's table of contents:<p class="source-code">app.validation_layout = html.Div([</p><p class="source-code">    main_layout,</p><p class="source-code">    indicators_dashboard,</p><p class="source-code">    country_dashboard,</p><p class="source-code">])</p></li>
			</ol>
			<p>We still need to specify the app's <strong class="source-inline">layout</strong> attribute, so Dash knows which one to use as the default layout. This is very simple: </p>
			<p class="source-code">app.layout = main_layout</p>
			<p>Let's now see how to manage the content that will be displayed in the <strong class="source-inline">main_layout</strong> part.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor157"/>Displaying content based on the URL</h2>
			<p>Once our layouts have been set up the way we did, we need a very simple function to manage the content.</p>
			<p>The function checks if the <a id="_idIndexMarker557"/>path name attribute of the <strong class="source-inline">Location</strong> component is one of the available countries or not. If it is, it returns the <strong class="source-inline">country_dashboard</strong> layout. Otherwise, it returns <strong class="source-inline">indicators_layout</strong>. Note that the second condition includes anything other than a country from the available countries. Since we don't have any other functionality in this app, and to catch any URL errors, it's good to send anything else to the home page. In more elaborate apps, though, it might be better to create error pages.</p>
			<p>We need to take note of two simple points. First, that the pathname attribute returns the path which contains <strong class="source-inline">"/&lt;country_name&gt;"</strong>, so we need to extract everything but the first character. Second, when we change the URL, if it contains special characters, such as spaces, they are automatically URL-encoded. This can be easily handled with the <strong class="source-inline">unquote</strong> function:</p>
			<p class="source-code">from urllib.parse import unquote</p>
			<p class="source-code">unquote('Bosnia%20and%20Herzegovina')</p>
			<p class="source-code"><strong class="bold"> 'Bosnia and Herzegovina'</strong></p>
			<p>Choosing a country with spaces, as in this case, converts spaces to their URL-encoded equivalent <strong class="source-inline">%20</strong>, so we need to use <strong class="source-inline">unquote</strong> on the name to be able to handle it as normal text.</p>
			<p>Here is the code that creates a <strong class="source-inline">countries</strong> list, containing all available countries, and the simple callback that manages the display of the content, based on the URL:</p>
			<p class="source-code">countries = countries = poverty[poverty['is_country']]['Country Name'].drop_duplicates().sort_values().tolist()</p>
			<p class="source-code">@app.callback(Output('main_content', 'children'),</p>
			<p class="source-code">              Input('location', 'pathname'))</p>
			<p class="source-code"> def display_content(pathname):</p>
			<p class="source-code">    if unquote(pathname[1:]) in countries:</p>
			<p class="source-code">        return country_dashboard</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return indicators_dashboard</p>
			<p>We just went through a <a id="_idIndexMarker558"/>high-level description of the new layout and structure of the app, and we now need to fill in some blanks and discuss some details about how to create the navigation bar, the drop-down menu, and its links.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor158"/>Adding dynamically generated URLs to the app</h1>
			<p>We now want to complete our <a id="_idIndexMarker559"/>main layout with a navigation bar, a home page link, as well as a drop-down menu for the countries. To achieve that, we introduce the <strong class="source-inline">NavbarSimple</strong> component from Dash Bootstrap Components and see <a id="_idIndexMarker560"/>how we can use it. </p>
			<p>The <strong class="source-inline">NavbarSimple</strong> component will take a few elements to create the structure we want as follows:</p>
			<ol>
				<li value="1">We first create the navigation bar and give it <strong class="source-inline">brand</strong> and <strong class="source-inline">brand_href</strong> arguments, to indicate what the name would be and where it would link to:<p class="source-code">import dash_bootstrap_components as dbc</p><p class="source-code">dbc.NavbarSimple([</p><p class="source-code">    …</p><p class="source-code">], brand="Home", brand_href="/")</p></li>
				<li>For its <strong class="source-inline">children</strong> argument, we will add a <strong class="source-inline">dbc.DropdownMenu</strong> component. We will also give it a <strong class="source-inline">label</strong> value so users know what to expect when they click on the menu. We will fill its <strong class="source-inline">children</strong> argument in the next step:<p class="source-code">dbc.DropdownMenu(children=[</p><p class="source-code">    menu_item_1,</p><p class="source-code">    menu_item_2,</p><p class="source-code">    …</p><p class="source-code">], label="Select country")</p></li>
				<li>We now need to supply a list of <strong class="source-inline">dbc.DropdownMenuItem</strong> components to the drop-down menu. Those items will each get <strong class="source-inline">children</strong> and <strong class="source-inline">href</strong> arguments. Both of these will be for a <a id="_idIndexMarker561"/>country from the list of countries we created in the previous section: <p class="source-code">dbc.DropdownMenu([</p><p class="source-code">    dbc.DropdownMenuItem(country, href=country)</p><p class="source-code">    for country in countries</p><p class="source-code">])</p></li>
			</ol>
			<p>Putting together the <a id="_idIndexMarker562"/>code for the full <strong class="source-inline">NavbarSimple</strong> component, you can see it here:</p>
			<p class="source-code">dbc.NavbarSimple([</p>
			<p class="source-code">    dbc.DropdownMenu([</p>
			<p class="source-code">        dbc.DropdownMenuItem(country, href=country)</p>
			<p class="source-code">        for country in countries</p>
			<p class="source-code">    ], label='Select country')</p>
			<p class="source-code">], brand='Home',brand_href='/')</p>
			<p>With this, we have implemented our navigation bar, and we can also add the <strong class="source-inline">Tabs</strong> component to the same layout, which we implemented in <a href="B16780_01_Final_NM_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Overview of the Dash Ecosystem</em>. Now it is very easy to modify or add any navigational elements you want, whenever you want, which will take effect on the website as a whole.</p>
			<p>Note that the children of the navigation bar contained links that act the same way as the <strong class="source-inline">Link</strong> component, so we also have this option when needed.</p>
			<p>With the full layout of the whole app ready and the correct layout being loaded based on the URL, we are now ready to implement the last two callback functions that will generate the <strong class="source-inline">country_dashboard</strong> layout for us.</p>
			<p>But here is the situation. I, your former colleague, wrote the code and created the functionality. I left the <a id="_idIndexMarker563"/>company without explaining anything, and you cannot get in touch with me. You need to figure out the <a id="_idIndexMarker564"/>structure for yourself, and you want to make some changes to my code.</p>
			<p>This is a typical situation that you will probably face, so let's see how we can approach it.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor159"/>Incorporating the new URL interactivity into the app</h1>
			<p>Having created a dropdown that automatically <a id="_idIndexMarker565"/>changes the URL based on the selected value, we have allowed our users to go from page to page as they please. We now need to manage the display of the right content based on the selected country.</p>
			<p>Since the code was <a id="_idIndexMarker566"/>already written, one thing you can do is run the app in debug mode and get a visual representation of all the available components and see how they are connected with callbacks.</p>
			<p><em class="italic">Figure 11.5</em> shows the graph of the callbacks that have been created. Let's use it to understand how this functionality was implemented:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B16780_11_5.jpg" alt="Figure 11.5 – The various components and callbacks managing the URL functionality"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – The various components and callbacks managing the URL functionality</p>
			<p>Let's go through the figure from left to right and see what is going on here. You can refer to <em class="italic">Figure 11.2</em> to see how this graph corresponds to visible components in the app: </p>
			<ul>
				<li>Everything starts with the <strong class="bold">pathname</strong> attribute of the component with the ID <strong class="bold">location</strong>. This can be induced by the user selecting a country from the drop-down menu, directly <a id="_idIndexMarker567"/>entering the full URL containing a country name, or clicking on a link from a web page.</li>
				<li>The URL (its pathname attribute) influences three components, as you can see. Most importantly, it <a id="_idIndexMarker568"/>determines what goes into the <strong class="bold">children</strong> attribute of the <strong class="bold">main_content</strong> div. If the URL happens to contain a country, then the <strong class="source-inline">country_dashboard</strong> layout will be displayed, using the <strong class="bold">display_content</strong> callback. This would display certain components that would make the two other callbacks relevant.</li>
				<li>Assuming a country was selected, our second callback, <strong class="bold">set_dropdown_values</strong>, will take this country and use it to populate the dropdown that selects the country to plot on this page.</li>
				<li>The <strong class="bold">plot_country_charts</strong> callback takes three inputs and modifies three outputs, as you can see at the right end of <em class="italic">Figure 11.5</em>. The <strong class="bold">country_heading</strong> is a simple <strong class="source-inline">&lt;h1&gt;</strong> component that says <strong class="source-inline">"&lt;country name&gt; Poverty Data"</strong>. <strong class="bold">country_page_graph</strong> is the main graph that is displayed on the page, and <strong class="bold">country_table</strong> is a <strong class="source-inline">dbc.Table</strong> component showing various details about the country, extracted from the country CSV file that contains data about each country in the dataset.</li>
			</ul>
			<p>After this, you get the code from the repository to see how this was implemented, and you see two callbacks that you want to review and eventually change:</p>
			<p class="source-code">@app.callback(Output('country_page_contry_dropdown', 'value'),</p>
			<p class="source-code">              Input('location', 'pathname'))</p>
			<p class="source-code"> def set_dropdown_values(pathname):</p>
			<p class="source-code">    if unquote(pathname[1:]) in countries:</p>
			<p class="source-code">        country = unquote(pathname[1:])</p>
			<p class="source-code">        return [country]</p>
			<p class="source-code">@app.callback(Output('country_heading', 'children'),</p>
			<p class="source-code">              Output('country_page_graph', 'figure'),</p>
			<p class="source-code">              Output('country_table', 'children'),</p>
			<p class="source-code">              Input('location', 'pathname'),</p>
			<p class="source-code">              Input('country_page_contry_dropdown', 'value'),</p>
			<p class="source-code">              Input('country_page_indicator_dropdown', 'value'))</p>
			<p class="source-code"> def plot_country_charts(pathname, countries, indicator):</p>
			<p class="source-code">    if (not countries) or (not indicator):</p>
			<p class="source-code">        raise PreventUpdate</p>
			<p class="source-code">    if unquote(pathname[1:]) in countries:</p>
			<p class="source-code">        country = unquote(pathname[1:])    df = poverty[poverty['is_country'] &amp; poverty['Country Name'].isin(countries)]</p>
			<p class="source-code">    fig = px.line(df,</p>
			<p class="source-code">                  x='year',</p>
			<p class="source-code">                  y=indicator,</p>
			<p class="source-code">                  title='&lt;b&gt;' + indicator + '&lt;/b&gt;&lt;br&gt;' + ', '.join(countries),</p>
			<p class="source-code">                  color='Country Name')</p>
			<p class="source-code">    fig.layout.paper_bgcolor = '#E5ECF6'</p>
			<p class="source-code">    table = country_df[country_df['Short Name'] == countries[0]].T.reset_index()</p>
			<p class="source-code">    if table.shape[1] == 2:</p>
			<p class="source-code">        table.columns = [countries[0] + ' Info', '']</p>
			<p class="source-code">        table = dbc.Table.from_dataframe(table)</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        table = html.Div()</p>
			<p class="source-code">    return country + ' Poverty Data', fig, table</p>
			<p>By now, it should be easy for <a id="_idIndexMarker569"/>you to figure out how to read new code, even code that contains components that you have never seen before. The general <a id="_idIndexMarker570"/>structure of apps has been covered and modified so many times, with so many components, and I think you are now comfortable with figuring this out for yourself.</p>
			<p>This is the last coding exercise in the book, and the last functionality that we will add. It doesn't mean that the app is complete. On the contrary, there are many things that can be modified and added. One thing you might consider doing is implementing a special URL for each indicator and having a special page for it, just like we did with countries. The difference is that this may not be as straightforward as the case with countries. We have some indicators that are percentages and others that are simple numbers. Some indicators should be taken together as a group, such as the ones showing different income quantiles. You can really get creative with what you want to change and how.</p>
			<p>Let's now recap what we covered in this chapter.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/>Summary</h1>
			<p>We first got to know the two main components that are responsible for modifying, reading, and parsing URLs, the <strong class="bold">Location</strong> and <strong class="bold">Link</strong> components. We created two simple apps in which we saw how to extract the part of the URL that we are interested in and experimented with several options for what can be done with them.</p>
			<p>We then saw how to modify parts of an app by taking values from parsed URLs. With this knowledge, we were able to restructure our app. We created a skeleton layout with an empty div, in which the right content would then be displayed based on the URL.</p>
			<p>We then incorporated the new functionality into our app. We were left with a final exercise that you can expect to go through in real life, which is a colleague handing you some code that you have to figure out and modify yourself.</p>
			<p>Now that we have explored many options, layouts, components, and functionality, the next natural step is to deploy our app on a public server, so we can share it with the world.</p>
			<p>This will be the topic of the next chapter.</p>
		</div>
	</body></html>