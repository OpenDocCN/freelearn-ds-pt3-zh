["```py\nfrom statsmodels.tsa.stattools import adfuller\nresult = adfuller(y) \n```", "```py\nfrom src.transforms.stationary_utils import check_unit_root\n# We pass the time series along with the confidence with which we need the results\ncheck_unit_root(y, confidence=0.05) \n```", "```py\nfrom src.transforms.target_transformations import AdditiveDifferencingTransformer\ndiff_transformer = AdditiveDifferencingTransformer()\n# [1:] because differencing reduces the length of the time series by one\ny_diff = diff_transformer.fit_transform(y, freq=\"1D\")[1:] \n```", "```py\ncheck_deterministic_trend(y, confidence=0.05) \n```", "```py\nimport scipy.stats as stats\ntau, p_value = stats.kendalltau(y, np.arange(len(y))) \n```", "```py\ncheck_trend(y, confidence=0.05) \n```", "```py\ncheck_trend(y, confidence=0.05, mann_kendall=True) \n```", "```py\n# y_unit_root is the a synthetic unit root timeseries\ny_unit_root.plot()\nplt.show() \n```", "```py\nkendall_tau_res = check_trend(y_unit_root, confidence=0.05)\nmann_kendall_res = check_trend(y_unit_root, confidence=0.05, mann_kendall=True)\nprint(f\"Kendalls Tau: Trend: {kendall_tau_res.trend} | Direction: {kendall_tau_res.direction} | Deterministic: {kendall_tau_res.deterministic}\")\nprint(f\"Mann-Kendalls: Trend: {mann_kendall_res.trend} | Direction: {mann_kendall_res.direction} | Deterministic: {mann_kendall_res.deterministic}\")\n## Output \n```", "```py\n>> Kendalls Tau: Trend: True | Direction: decreasing | Deterministic: False\n>> Mann-Kendalls: Trend: True | Direction: decreasing | Deterministic: False \n```", "```py\n# y is the time series we are detrending\nx = np.arange(len(y))\n# degree is the degree of trend we are estimating. Linear, or polynomial\n# Fitting a regression on y using a linearly increasing x\nlinear_params = np.polyfit(x=x, y=y, deg=degree)\n# Extract trend using fitted parameters\ntrend = get_trend(y)\n# Now this extracted trend can be removed from y\ndetrended = y - trend \n```", "```py\nfrom src.transforms.target_transformations import DetrendingTransformer\ndetrending_transformer = DetrendingTransformer(degree=1)\ny_detrended = detrending_transformer.fit_transform(y, freq=\"1D\") \n```", "```py\n#WhiteNoise + Seasonal\ny_random = pd.Series(np.random.randn(length), index=index)\nt = np.arange(len(y_random))\ny_seasonal = (y_random+1.9*np.cos((2*np.pi*t)/(length/4))) \n```", "```py\n# Running the function without specifying seasonal period to identify the seasonality\nseasonality_res = check_seasonality(y_seasonal, max_lag=60, confidence=0.05)\nprint(f\"Seasonality identified for: {seasonality_res.seasonal_periods}\")\n## Output \n```", "```py\n>> Seasonality identified for: 25 \n```", "```py\nThis function can also be used to verify if your assumption about the seasonality is right.\n# Running the function specifying seasonal period to verify\nseasonality_res = check_seasonality(y_seasonal, max_lag=30, seasonal_period=25, confidence=0.05)print(f\"Seasonality Test for 25th lag: {seasonality_res.seasonal}\")\n## Output \n```", "```py\n>> Seasonality Test for 25th lag: True \n```", "```py\nfrom src.transforms.target_transformations import DeseasonalizingTransformer\ndeseasonalizing_transformer = DeseasonalizingTransformer(seasonality_extraction=\"period_averages\",seasonal_period=25)\ny_deseasonalized = deseasonalizing_transformer.fit_transform(y, freq=\"1D\") \n```", "```py\nimport statsmodels.api as sm\n# Fitting a linear trend regression\nx = np.arange(len(y))\nx = sm.add_constant(x)\nmodel = sm.OLS(y,x)\nresults = model.fit()\n# Using the het_white test on residuals\nlm_stat, lm_p_value, f_stat, f_p_value = het_white(results.resid, x)\n# Checking if both p values are less than confidence\nif lm_p_value<confidence and f_p_value < confidence:\n        hetero = True\n    else:\n        hetero = False \n```", "```py\nfrom src.transforms.stationary_utils import check_heteroscedastisticity\ncheck_heteroscedastisticity(y, confidence=0.05) \n```", "```py\n# Transform\nnp.log1p(y) if self.add_one else np.log(y)\n# Inverse Transform\nnp.expm1(y) if self.add_one else np.exp(y)y_log = log_transformer.fit_transform(y) \n```", "```py\nfrom src.transforms.target_transformations import LogTransformer\nlog_transformer = LogTransformer(add_one=True)\ny_log = log_transformer.fit_transform(y) \n```", "```py\n## Fit Process\n# Add one if needed\ny = self._add_one(y)\n# Find optimum box cox lamda if optimization is Guerrero\nself.boxcox_lambda = self._optimize_lambda(y)\n## Transform Process\nboxcox(y.values, lmbda=self.boxcox_lambda)\n## Inverse Transform\nself._subtract_one(inv_boxcox(y.values, self.boxcox_lambda)) \n```", "```py\nfrom src.transforms.target_transformations import BoxCoxTransformer\nboxcox_transformer = BoxCoxTransformer()\ny_boxcox = boxcox _transformer.fit_transform(y) \n```", "```py\nfrom src.transforms.target_transformations import AutoStationaryTransformer\nauto_stationary = AutoStationaryTransformer(seasonal_period=25)\ny_stat = auto_stationary.fit_transform(y_final) \n```", "```py\ntrain_df = pd.read_parquet(preprocessed/\"selected_blocks_train_missing_imputed_feature_engg.parquet\")\ntransformer_pipelines = {}\nfor _id in tqdm(train_df[\"LCLid\"].unique()):\n    #Initialize the AutoStationaryTransformer with a seasonality period of 48*7\n    auto_stationary = AutoStationaryTransformer(seasonal_period=48*7)\n    #Creating the timeseries with datetime index\n    y = train_df.loc[train_df[\"LCLid\"]==_id, [\"energy_consumption\",\"timestamp\"]].set_index(\"timestamp\")\n    #Fitting and transforming the train\n    y_stat = auto_stationary.fit_transform(y, freq=\"30min\")\n    # Setting the transformed series back to the dataframe\n    train_df.loc[train_df[\"LCLid\"]==_id, \"energy_consumption\"] = y_stat.values\n    #Saving the pipeline\n    transformer_pipelines[_id] = auto_stationary \n```"]